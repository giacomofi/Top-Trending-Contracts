['pragma solidity ^0.4.24;\n', '\n', 'contract EthGods {\n', '\n', '    // imported contracts\n', '    \n', '    EthGodsName private eth_gods_name;\n', '    function set_eth_gods_name_contract_address(address eth_gods_name_contract_address) public returns (bool) {\n', '        require(msg.sender == admin);\n', '        eth_gods_name = EthGodsName(eth_gods_name_contract_address);\n', '        return true;\n', '    }\n', '\n', '    EthGodsDice private eth_gods_dice;\n', '    function set_eth_gods_dice_contract_address(address eth_gods_dice_contract_address) public returns (bool) {\n', '        require(msg.sender == admin);\n', '        eth_gods_dice = EthGodsDice(eth_gods_dice_contract_address);\n', '        return true;\n', '    }\n', '    \n', '    // end of imported contracts\n', ' \n', ' \n', '     // start of database\n', '    \n', '    //contract information & administration\n', '    bool private contract_created; // in case constructor logic change in the future\n', '    address private contract_address; //shown at the top of the home page\n', '    string private contact_email = "ethgods@gmail.com";\n', '    string private official_url = "swarm-gateways.net/bzz:/ethgods.eth";\n', '\n', '    address private  admin; // public when testing\n', '    address private controller1 = 0xcA5A9Db0EF9a0Bf5C38Fc86fdE6CB897d9d86adD; // controller can change admin at once; \n', '    address private controller2 = 0x8396D94046a099113E5fe5CBad7eC95e96c2B796; // controller can change admin at once; \n', '\n', '    address private v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\n', "    uint private block_hash_duration = 255; // can't get block hash, after 256 blocks, adjustable\n", '    \n', '\n', '    // god\n', '    struct god {\n', '        uint god_id;\n', '        uint level;\n', '        uint exp;\n', '        uint pet_type;// 12 animals or zodiacs\n', '        uint pet_level;   \n', '        uint listed; // 0 not a god, 1 - ... rank_score in god list\n', '        uint invite_price;\n', '        uint blessing_player_id;\n', '        bool hosted_pray; // auto waitlist, when enlisted. others can invite, once hosted pray\n', '        uint bid_eth; // bid to host pray\n', '        \n', '        uint credit; // gained from the amulet invitation spending of invited fellows\n', '        uint count_amulets_generated;\n', '        uint first_amulet_generated;\n', '        uint count_amulets_at_hand;\n', '        uint count_amulets_selling;\n', '        uint amulets_start_id;\n', '        uint amulets_end_id;\n', '        \n', '        uint count_token_orders;\n', '        uint first_active_token_order;\n', '\n', '        uint allowed_block; // allow another account to use my egst\n', '        \n', '        uint block_number; // for pray\n', '        bytes32 gene;\n', '        bool gene_created;\n', '        bytes32 pray_hash; //hash created for each pray\n', '\n', '        uint inviter_id; // who invited this fellow to this world\n', '        uint count_gods_invited; // gods invited to this game by this god.\n', '        \n', '    }\n', '    uint private count_gods = 0; // Used when generating id for a new player, \n', '    mapping(address => god) private gods; // everyone is a god\n', "    mapping(uint => address) private gods_address; // gods' address => god_id\n", '\n', '    uint [] private listed_gods; // id of listed gods\n', '    uint private max_listed_gods = 10000; // adjustable\n', '\n', '    uint private initial_invite_price = 0.02 ether; // grows with each invitation for this god\n', '    uint private invite_price_increase = 0.02 ether; // grows by this amount with each invitation\n', '    uint private max_invite_price = 1000 ether; // adjustable\n', '    uint private max_extra_eth = 0.001 ether; // adjustable\n', '\n', '    uint private list_level = 10; // start from level 10\n', '    uint private max_gas_price = 100000000000; // 100 gwei for invite and pray, adjustable\n', '    \n', '    // amulet\n', '    struct amulet {\n', '        uint god_id;\n', '        address owner;\n', '        uint level;\n', "        uint bound_start_block;// can't sell, if just got\n", '        // bool selling;\n', "        uint start_selling_block; // can't bind & use in pk, if selling\n", '        uint price; // set to 0, when withdraw from selling or bought\n', '        // uint order_id; // should be 0, if not selling\n', '    }\n', '    uint private count_amulets = 0; \n', '    mapping(uint => amulet) private amulets; // public when testing\n', '    uint private bound_duration = 9000; // once bought, wait a while before sell it again, adjustable\n', '    uint private order_duration = 20000; // valid for about 3 days, then not to show to public in selling amulets/token orders, but still show in my_selling amulets/token orders. adjustable\n', '\n', '    // pray\n', '    address private pray_host_god; // public when testing\n', '    bool private pray_reward_top100; // if hosted by new god, reward top 100 gods egst\n', '    uint private pray_start_block; // public when testing\n', '    bool private rewarded_pray_winners = false;\n', '\n', '    uint private count_hosted_gods; // gods hosted pray (event started). If less than bidding gods, there are new gods waiting to host pray, \n', '    mapping (uint => address) private bidding_gods; // every listed god and bid to host pray\n', '    uint private initializer_reward = 36; // reward the god who burned gas to send pray rewards to community, adjustable\n', '    \n', '    mapping(uint => uint) private max_winners;  // max winners for each prize  \n', '    uint private min_pray_interval = 2000; // 2000, 36 in CBT, 2 in dev, adjustable\n', '    uint private min_pray_duration = 6000; // 6000, 600 in CBT, 60 in dev, adjustable\n', '    uint private max_pray_duration = 9000; // 9000, 900 in CBT, 90 in dev, adjustable\n', '\n', '    uint private count_waiting_prayers;\n', '    mapping (uint => address) private waiting_prayers; // uint is waiting sequence\n', '    uint private waiting_prayer_index = 1; // waiting sequence of the prayer ready to draw lot\n', '\n', '    mapping(uint => uint) private pk_positions; // public when testing\n', '    mapping(uint => uint) private count_listed_winners; // count for 5 prizes, public in testing\n', '    mapping (uint => mapping(uint => address)) private listed_winners; // winners for 5 prizes\n', '\n', '    bool private reEntrancyMutex = false; // for sendnig eth to msg.sender\n', '    \n', '    uint private pray_egses = 0; // 10% from reward pool to top 3 winners in each round of pray events\n', '    uint private pray_egst = 0;  // 10% from reward pool to 3rd & 4th prize winners in each round of pray events\n', '\n', '    mapping(address => uint) egses_balances;\n', '        \n', '\n', '    // eth_gods_token (EGST)\n', '    string public name = "EthGodsToken";\n', '    string public symbol = "EGST";\n', '    uint8 public decimals = 18; //same as ethereum\n', '    uint private _totalSupply;\n', '    mapping(address => uint) balances; // bought or gained from pray or revenue share\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    uint private allowed_use_CD = 20; // if used allowed amount, have to wait a while before approve new allowed amount again, prevent cheating, adjustable\n', '    \n', '\n', '    struct token_order {\n', '        uint id;\n', '        uint start_selling_block;\n', '        address seller;\n', '        uint unit_price;\n', '        uint egst_amount;\n', '    }\n', '    uint private count_token_orders = 0;\n', '    mapping (uint => token_order) token_orders;\n', '    uint private first_active_token_order = 0;\n', '\n', '    uint private min_unit_price = 20; // 1 egst min value is 0.0002 ether, adjustable\n', '    uint private max_unit_price = 200; // 1 egst max value is 0.002 ether, adjustable\n', '    uint private max_egst_amount = 1000000 ether; // for create_token_order, adjustable\n', '    uint private min_egst_amount = 0.00001 ether; // for create_token_order, adjustable\n', ' \n', ' \n', '    //logs\n', '    uint private count_rounds = 0;\n', '    \n', '    struct winner_log { // win a prize and if pk\n', '        uint god_block_number;\n', '        bytes32 block_hash; \n', '        address prayer;\n', '        address previous_winner;\n', '        uint prize;\n', '        bool pk_result;\n', '    }\n', '    mapping (uint => uint) private count_rounds_winner_logs;\n', '    mapping(uint => mapping(uint => winner_log)) private winner_logs;\n', '    \n', '    struct change_log {\n', '        uint block_number;\n', '        uint asset_type; // 1 egst, 2 eth_surplus\n', '        \n', '        // egses change reasons:  \n', '            // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,\n', '            // 4 admin_deposit to reward_pool, 5 withdraw egses\n', '            // 6 sell amulet, 7 sell egst, 8 withdraw bid\n', '        \n', '        // egst_change reasons: \n', '            // 1 pray_reward, 2 top_gods_reward, \n', '            // 3 create_token_order, 4 withdraw token_order, 5 buy token,  \n', '            // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward\n', '        \n', '        uint reason; // > 10 is buy token unit_price\n', '        uint change_amount;\n', '        uint after_amount;\n', '        address _from;\n', '        address _to;\n', '    }\n', '    mapping (uint => uint) private count_rounds_change_logs;\n', '    mapping(uint => mapping(uint => change_log)) private change_logs;\n', '\n', '    // end of database\n', '  \n', '    \n', '    // start of constructor\n', '    constructor () public {\n', '        require (contract_created == false);\n', '        contract_created = true;\n', '        contract_address = address(this);\n', '        admin = msg.sender;\n', '\n', '        create_god(admin, 0);\n', '        create_god(v_god, 0);\n', '        gods[v_god].level = 10;\n', '        enlist_god(v_god);\n', '        \n', '        max_winners[1] = 1; // 1\n', '        max_winners[2] = 2; // 2\n', '        max_winners[3] = 8; // 8\n', '        max_winners[4] = 16; // 16\n', '        max_winners[5] = 100; // 100\n', '\n', '        _totalSupply = 6000000 ether;\n', '        pray_egst = 1000 ether;\n', '        balances[admin] = sub(_totalSupply, pray_egst);\n', '  \n', '        initialize_pray();\n', '    }\n', '    \n', "    // destruct for testing contracts. can't destruct since round 3\n", '    function finalize() public {\n', '        require(msg.sender == admin && count_rounds <= 3);\n', '        selfdestruct(admin); \n', '    }\n', '    \n', '\n', '    function () public payable {\n', '        revert ();\n', '    }   \n', '    // end of constructor\n', '     \n', '         \n', '    //start of contract information & administration\n', '    \n', '    function get_controller () public view returns (address, address){\n', '        require (msg.sender == admin || msg.sender == controller1  || msg.sender == controller2);\n', '        return (controller1, controller2);\n', '    }\n', '    \n', '    function set_controller (uint controller_index, address new_controller_address) public returns (bool){\n', '        if (controller_index == 1){\n', '            require(msg.sender == controller2);\n', '            controller1 = new_controller_address;\n', '        } else {\n', '            require(msg.sender == controller1);\n', '            controller2 = new_controller_address;            \n', '        }\n', '        return true;\n', '    }\n', '     \n', '    function set_admin (address new_admin_address) public returns (bool) {\n', '        require (msg.sender == controller1 || msg.sender == controller2);\n', "        // admin don't have game attributes, such as level'\n", '        // no need to transfer egses and egst to new_admin_address\n', '        delete gods[admin];\n', '        admin = new_admin_address;\n', '        gods_address[0] = admin;\n', '        gods[admin].god_id = 0;\n', '        return true;\n', '    }  \n', '    \n', '    // update system parameters\n', '    function set_parameters (uint parameter_type, uint new_parameter) public returns (bool){\n', '        require (msg.sender == admin);\n', '        if (parameter_type == 1) {\n', '            max_pray_duration = new_parameter;\n', '        } else if (parameter_type == 2) {\n', '            min_pray_duration = new_parameter;\n', '        } else if (parameter_type == 3) {\n', '            block_hash_duration = new_parameter;\n', '        } else if (parameter_type == 4) {\n', '            min_pray_interval = new_parameter;\n', '        } else if (parameter_type == 5) {\n', '            order_duration = new_parameter;\n', '        } else if (parameter_type == 6) {\n', '            bound_duration = new_parameter;\n', '        } else if (parameter_type == 7) {\n', '            initializer_reward = new_parameter;\n', '        } else if (parameter_type == 8) {\n', '            allowed_use_CD = new_parameter;\n', '        } else if (parameter_type == 9) {\n', '            min_unit_price = new_parameter;\n', '        } else if (parameter_type == 10) {\n', '            max_unit_price = new_parameter;\n', '        } else if (parameter_type == 11) {\n', '            max_listed_gods = new_parameter;\n', '        } else if (parameter_type == 12) {\n', '            max_gas_price = new_parameter;\n', '        } else if (parameter_type == 13) {\n', '            max_invite_price = new_parameter;\n', '        } else if (parameter_type == 14) {\n', '            min_egst_amount = new_parameter;\n', '        } else if (parameter_type == 15) {\n', '            max_egst_amount = new_parameter;\n', '        } else if (parameter_type == 16) {\n', '            max_extra_eth = new_parameter;\n', '        }\n', '        return true;\n', '    }  \n', '        \n', '    function set_strings (uint string_type, string new_string) public returns (bool){\n', '        require (msg.sender == admin);\n', '        \n', '        if (string_type == 1){\n', '            official_url = new_string;\n', '        } else if (string_type == 2){\n', '            name = new_string; // egst name\n', '        } else if (string_type == 3){\n', '            symbol = new_string; // egst symbol\n', '        }\n', '        return true;\n', '    }    \n', '    \n', '  \n', '    // for basic information to show to players, and to update parameter in sub-contracts\n', '    function query_contract () public view returns(uint, uint, address, uint, string, uint, uint){\n', '        return (count_gods,\n', '                listed_gods.length, \n', '                admin,\n', '                block_hash_duration,\n', '                official_url,\n', '                bound_duration,\n', '                min_pray_interval\n', '               );\n', '    }\n', '    \n', '    \n', '    function query_uints () public view returns (uint[7] uints){\n', '        uints[0] = max_invite_price;\n', '        uints[1] = list_level;\n', '        uints[2] = max_pray_duration;\n', '        uints[3] = min_pray_duration;\n', '        uints[4] = initializer_reward;\n', '        uints[5] = min_unit_price;\n', '        uints[6] = max_unit_price;\n', '        \n', '        return uints;\n', '    }\n', '    \n', '    \n', '    function query_uints2 () public view returns (uint[6] uints){\n', '        uints[0] = allowed_use_CD;\n', '        uints[1] = max_listed_gods;\n', '        uints[2] = max_gas_price;\n', '        uints[3] = min_egst_amount;\n', '        uints[4] = max_egst_amount;\n', '        uints[5] = max_extra_eth;\n', '\n', '        return uints;\n', '    }\n', '  \n', '    //end of contract information & administration\n', '\n', '    \n', '    // god related functions: register, create_god, upgrade_pet, add_exp, burn_gas, invite, enlist\n', '    \n', '    // if a new player comes when a round just completed, the new player may not want to initialize the next round\n', '    function register_god (uint inviter_id) public returns (uint) {\n', '        return create_god(msg.sender, inviter_id);\n', '    }\n', '    function create_god (address god_address, uint inviter_id) private returns(uint god_id){ // created by the contract // public when testing\n', '        // check if the god is already created\n', '        if (gods[god_address].credit == 0) { // create admin as god[0]\n', '            gods[god_address].credit = 1; // give 1 credit, so we know this address has a god\n', '            \n', "            god_id = count_gods; // 1st god's id is admin 0\n", '            count_gods = add(count_gods, 1) ;\n', '            gods_address[god_id] = god_address;\n', '            gods[god_address].god_id = god_id;\n', '                        \n', '            if (god_id > 0){ // not admin\n', '                add_exp(god_address, 100);\n', '                set_inviter(inviter_id);\n', '            }\n', '            \n', '            return god_id;\n', '        }\n', '    }\n', '    \n', '    function set_inviter (uint inviter_id) public returns (bool){\n', '        if (inviter_id > 0 && gods_address[inviter_id] != address(0)\n', '        && gods[msg.sender].inviter_id == 0\n', '        && gods[gods_address[inviter_id]].inviter_id != gods[msg.sender].god_id){\n', '            gods[msg.sender].inviter_id = inviter_id;\n', '            address inviter_address = gods_address[inviter_id];\n', '            gods[inviter_address].count_gods_invited = add(gods[inviter_address].count_gods_invited, 1);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function add_exp (address god_address, uint exp_up) private returns(uint new_level, uint new_exp) { // public when testing\n', '        if (god_address == admin){\n', '            return (0,0);\n', '        }\n', '        if (gods[god_address].god_id == 0){\n', '            uint inviter_id = gods[god_address].inviter_id;\n', '            create_god(god_address, inviter_id);\n', '        }\n', '        new_exp = add(gods[god_address].exp, exp_up);\n', '        uint current_god_level = gods[god_address].level;\n', '        uint level_up_exp;\n', '        new_level = current_god_level;\n', '\n', '        for (uint i=0;i<10;i++){ // if still have extra exp, level up next time\n', '            if (current_god_level < 99){\n', '                level_up_exp = mul(10, add(new_level, 1));\n', '            } else {\n', '                level_up_exp = 1000;\n', '            }\n', '            if (new_exp >= level_up_exp){\n', '                new_exp = sub(new_exp, level_up_exp);\n', '                new_level = add(new_level, 1);\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '\n', '        gods[god_address].exp = new_exp;\n', '\n', '        if(new_level > current_god_level) {\n', '            gods[god_address].level = new_level;\n', '            if (gods[god_address].listed > 0) {\n', '                if (listed_gods.length > 1) {\n', '                    sort_gods(gods[god_address].god_id);\n', '                }\n', '            } else if (new_level >= list_level && listed_gods.length < max_listed_gods) {\n', '                enlist_god(god_address);\n', '            }\n', '        }\n', '        \n', '        return (new_level, new_exp);\n', '    }\n', '\n', '   \n', '    function enlist_god (address god_address) private returns (uint) { // public when testing\n', '        require(gods[god_address].level >= list_level && god_address != admin);\n', '                \n', '        // if the god is not listed yet, enlist and add level requirement for the next enlist\n', '        if (gods[god_address].listed == 0) {\n', '            uint god_id = gods[god_address].god_id;\n', '            if (god_id == 0){\n', '                god_id = create_god(god_address, 0); // get a god_id and set inviter as v god\n', '            }\n', '            gods[god_address].listed = listed_gods.push(god_id); // start from 1, 0 is not listed\n', '            gods[god_address].invite_price = initial_invite_price;\n', '\n', '            list_level = add(list_level, 1);\n', '            bidding_gods[listed_gods.length] = god_address;\n', '            \n', '        }\n', '        return list_level;\n', '    }\n', '    \n', '    function sort_gods_admin(uint god_id) public returns (bool){\n', '        require (msg.sender == admin);\n', '        sort_gods(god_id);\n', '        return true;\n', '    }\n', '\n', '\n', '    // when a listed god level up and is not top 1 of the list, compare power with higher god, if higher than the higher god, swap position\n', '    function sort_gods (uint god_id) private returns (uint){ \n', '        require (god_id > 0);\n', '        uint list_length = listed_gods.length;\n', '        if (list_length > 1) {\n', '            address god_address = gods_address[god_id];\n', '            uint this_god_listed = gods[god_address].listed;\n', '            if (this_god_listed < list_length) {\n', '                uint higher_god_listed = add(this_god_listed, 1);\n', '                uint higher_god_id = listed_gods[sub(higher_god_listed, 1)];\n', '                address higher_god = gods_address[higher_god_id];\n', '                if(gods[god_address].level > gods[higher_god].level\n', '                || (gods[god_address].level == gods[higher_god].level\n', '                    && gods[god_address].exp > gods[higher_god].exp)){\n', '                        listed_gods[sub(this_god_listed, 1)] = higher_god_id;\n', '                        listed_gods[sub(higher_god_listed, 1)] = god_id;\n', '                        gods[higher_god].listed = this_god_listed;\n', '                        gods[god_address].listed = higher_god_listed;\n', '                }\n', '            }\n', '        }\n', '        return gods[god_address].listed;\n', '    }\n', '\n', '\n', '    function burn_gas (uint god_id) public returns (uint god_new_level, uint god_new_exp) {\n', '        address god_address = gods_address[god_id];\n', '        require(god_id > 0 \n', '                && god_id <= count_gods\n', '                && gods[god_address].listed > 0);\n', '\n', '        add_exp(god_address, 1);\n', '        add_exp(msg.sender, 1);\n', '        return (gods[god_address].level, gods[god_address].exp); // return bool, if out of gas\n', '    }\n', '\n', '\n', '    function invite (uint god_id) public payable returns (uint new_invite_price)  {\n', '        address god_address = gods_address[god_id];\n', '        require(god_id > 0 \n', '                && god_id <= count_gods\n', '                && gods[god_address].hosted_pray == true\n', '                && tx.gasprice <= max_gas_price\n', '                );\n', '\n', '        uint invite_price = gods[god_address].invite_price;\n', '\n', '        require(msg.value >= invite_price); \n', '\n', '        if (gods[god_address].invite_price < max_invite_price) {\n', '            gods[god_address].invite_price = add(invite_price, invite_price_increase);\n', '        }\n', '        \n', '        uint exp_up = div(invite_price, (10 ** 15)); // 1000 exp for each eth\n', '        add_exp(god_address, exp_up);\n', '        add_exp(msg.sender, exp_up);\n', '       \n', '        //generate a new amulet of this god for the inviter\n', '        count_amulets ++;\n', '        amulets[count_amulets].god_id = god_id;\n', '        amulets[count_amulets].owner = msg.sender;\n', '\n', '        gods[god_address].count_amulets_generated = add(gods[god_address].count_amulets_generated, 1);\n', '        if (gods[god_address].count_amulets_generated == 1){\n', '            gods[god_address].first_amulet_generated = count_amulets;\n', '        }\n', '        gods[msg.sender].count_amulets_at_hand = add(gods[msg.sender].count_amulets_at_hand, 1);\n', '        update_amulets_count(msg.sender, count_amulets, true);\n', '\n', '        // invite_price to egses: 60% to pray_egses, 20% to god, changed\n', '        // pray_egses = add(pray_egses, div(mul(60, invite_price), 100));\n', '        // egses_from_contract(gods_address[god_id], div(mul(20, invite_price), 100), 2); //2 reward god for being invited\n', '        // reduce reward pool share from 60 to 50%, reduce god reward from 20% to 10%\n', '        // add 20% share to blessing player (the last player invited this god)\n', '        pray_egses = add(pray_egses, div(mul(50, invite_price), 100)); \n', '        egses_from_contract(god_address, div(mul(10, invite_price), 100), 2); //2 reward god for being invited\n', '        egses_from_contract(gods_address[gods[god_address].blessing_player_id], div(mul(20, invite_price), 100), 2); //2 reward god for being invited, no need to check if blessing player id is > 0\n', '        gods[god_address].blessing_player_id = gods[msg.sender].god_id;\n', '\n', '        reward_inviter(msg.sender, invite_price);\n', '        emit invited_god (msg.sender, god_id);\n', '\n', '        return gods[god_address].invite_price;\n', '    }\n', '    event invited_god (address msg_sender, uint god_id);\n', '    \n', '\n', '    function reward_inviter (address inviter_address, uint invite_price) private returns (bool){\n', '        // the fellow spending eth also get credit and share\n', '        uint previous_share = 0;\n', '        uint inviter_share = 0;\n', '        uint share_diff;\n', '        // uint invite_credit = div(invite_price, 10 ** 15);\n', '        \n', '        for (uint i = 0; i < 9; i++){ // max trace 9 layers of inviter\n', "            if (inviter_address != address(0) && inviter_address != admin){ // admin doesn't get reward or credit\n", '                share_diff = 0;\n', '                // gods[inviter_address].credit = add(gods[inviter_address].credit, invite_credit);\n', '                gods[inviter_address].credit = add(gods[inviter_address].credit, invite_price);\n', '                inviter_share = get_vip_level(inviter_address);\n', '\n', '                if (inviter_share > previous_share) {\n', '                    share_diff = sub(inviter_share, previous_share);\n', '                    if (share_diff > 18) {\n', '                        share_diff = 18;\n', '                    }\n', '                    previous_share = inviter_share;\n', '                }\n', '                \n', '                if (share_diff > 0) {\n', '                    egses_from_contract(inviter_address, div(mul(share_diff, invite_price), 100), 3); // 3 inviter_reward\n', '                }\n', '                \n', "                inviter_address = gods_address[gods[inviter_address].inviter_id]; // get the address of inviter's inviter'\n", '            } else{\n', '                break;\n', '            }\n', '        }\n', '        // invite_price to egses: sub(20%, previous_share) to admin\n', '        share_diff = sub(20, inviter_share); \n', '        egses_from_contract(admin, div(mul(share_diff, invite_price), 100), 2); // remaining goes to admin, 2 god_reward for being invited\n', '        \n', '        return true;\n', '    }\n', '    \n', '\n', '    function upgrade_pet () public returns(bool){\n', '        //use egst to level up pet;\n', '        uint egst_cost = mul(add(gods[msg.sender].pet_level, 1), 10 ether);\n', '        egst_to_contract(msg.sender, egst_cost, 6);// 6 upgrade_pet\n', '        gods[msg.sender].pet_level = add(gods[msg.sender].pet_level, 1);\n', '        add_exp(msg.sender, div(egst_cost, 1 ether));\n', '        pray_egst = add(pray_egst, egst_cost);\n', '\n', '        // pray_egst = add(pray_egst, div(egst_cost, 2));\n', '        // egst_from_contract(admin, div(egst_cost, 2), 8); // 8 admin reward\n', '        emit upgradeAmulet(msg.sender, 0, gods[msg.sender].pet_level);\n', '        \n', '        return true;\n', '    }\n', '    event upgradeAmulet (address owner, uint amulet_id, uint new_level);\n', '\n', '    function set_pet_type (uint new_type) public returns (bool){\n', '        if (gods[msg.sender].pet_type != new_type) {\n', '            gods[msg.sender].pet_type = new_type;\n', '            return true;\n', '        }\n', '    }\n', '  \n', '      \n', '    function get_vip_level (address god_address) public view returns (uint vip_level){\n', '        uint inviter_credit = gods[god_address].credit;\n', '        \n', '        if (inviter_credit > 500 ether){\n', '            vip_level = 18;\n', '        } else if (inviter_credit > 200 ether){\n', '            vip_level = 15;\n', '        } else if (inviter_credit > 100 ether){\n', '            vip_level = 12;\n', '        } else if (inviter_credit > 50 ether){\n', '            vip_level = 10;\n', '        } else if (inviter_credit > 20 ether){\n', '            vip_level = 8;\n', '        } else if (inviter_credit > 10 ether){\n', '            vip_level = 6;\n', '        } else if (inviter_credit > 5 ether){\n', '            vip_level = 5;\n', '        } else if (inviter_credit > 2 ether){\n', '            vip_level = 4;\n', '        } else if (inviter_credit > 1 ether){\n', '            vip_level = 3;\n', '        } else if (inviter_credit > 0.5 ether){\n', '            vip_level = 2;\n', '        } else {\n', '            vip_level = 1;\n', '        }\n', '        return vip_level;\n', '    }\n', '\n', '\n', "    // view god's information\n", '    \n', '    function get_god_id (address god_address) public view returns (uint god_id){\n', '        return gods[god_address].god_id;\n', '    }\n', '    \n', '    \n', '    function get_god_address(uint god_id) public view returns (address){\n', '        return gods_address[god_id];\n', '    }\n', '\n', '\n', '    function get_god (uint god_id) public view returns(uint, string, uint, uint, uint, uint, uint) {\n', '        address god_address = gods_address[god_id];\n', '        string memory god_name;\n', '\n', '        god_name = eth_gods_name.get_god_name(god_address);\n', '        if (bytes(god_name).length == 0){\n', '            god_name = "Unknown";\n', '        }\n', '\n', '        return (gods[god_address].god_id,\n', '                god_name,\n', '                gods[god_address].level,\n', '                gods[god_address].exp,\n', '                gods[god_address].invite_price,\n', '                gods[god_address].listed,\n', '                gods[god_address].blessing_player_id\n', '                );\n', '    }\n', '    \n', '    \n', '    function get_god_info (address god_address) public view returns (uint, bytes32, bool, uint, uint, uint, bytes32){\n', '        return (gods[god_address].block_number,\n', '                gods[god_address].gene,\n', '                gods[god_address].gene_created,\n', '                gods[god_address].pet_type,\n', '                gods[god_address].pet_level,\n', '                gods[god_address].bid_eth,\n', '                gods[god_address].pray_hash\n', '                );\n', '    }\n', '    \n', '    \n', '    function get_god_hosted_pray (uint god_id) public view returns (bool){\n', '        return gods[gods_address[god_id]].hosted_pray;\n', '    }\n', '    \n', '    \n', '    function get_my_info () public view returns(uint, uint, uint, uint, uint, uint, uint) { //private information\n', '\n', '        return (gods[msg.sender].god_id,\n', '                egses_balances[msg.sender], //egses\n', '                balances[msg.sender], //egst\n', '                get_vip_level(msg.sender),\n', '                gods[msg.sender].credit, // inviter_credit\n', '                gods[msg.sender].inviter_id,\n', '                gods[msg.sender].count_gods_invited\n', '                );\n', '    }   \n', '\n', '    \n', '    function get_listed_gods (uint page_number) public view returns (uint[]){\n', '        \n', '        uint count_listed_gods = listed_gods.length;\n', '        require(count_listed_gods <= mul(page_number, 20));\n', '        \n', '        uint[] memory tempArray = new uint[] (20);\n', '\n', '        if (page_number < 1) {\n', '            page_number = 1;\n', '        } \n', '\n', '        for (uint i = 0; i < 20; i++){\n', '            if(count_listed_gods > add(i, mul(20, sub(page_number, 1)))) {\n', '                tempArray[i] = listed_gods[sub(sub(sub(count_listed_gods, i), 1), mul(20, sub(page_number, 1)))];\n', '            } else {\n', '                break;\n', '            }\n', '        }\n', '        \n', '        return tempArray;\n', '    }\n', '\n', '\n', '    // amulets\n', '   \n', '    function upgrade_amulet (uint amulet_id) public returns(uint){\n', '        require(amulets[amulet_id].owner == msg.sender);\n', '        uint egst_cost = mul(add(amulets[amulet_id].level, 1), 10 ether);\n', '        egst_to_contract(msg.sender, egst_cost, 7);// reason 7, upgrade_amulet\n', '        pray_egst = add(pray_egst, egst_cost);\n', '        // pray_egst = add(pray_egst, div(egst_cost, 2));\n', '        // egst_from_contract(admin, div(egst_cost, 2), 8); // 8 admin reward\n', '        \n', '        amulets[amulet_id].level = add(amulets[amulet_id].level, 1);\n', '        add_exp(msg.sender, div(egst_cost, 1 ether));\n', '        emit upgradeAmulet(msg.sender, amulet_id, amulets[amulet_id].level);\n', '        \n', '        return amulets[amulet_id].level;\n', '    }\n', '    \n', '    \n', '    function create_amulet_order (uint amulet_id, uint price) public returns (uint) {\n', '        require(msg.sender == amulets[amulet_id].owner\n', '                && amulet_id >= 1 && amulet_id <= count_amulets\n', '                && amulets[amulet_id].start_selling_block == 0\n', '                && add(amulets[amulet_id].bound_start_block, bound_duration) < block.number\n', '                && price > 0);\n', '\n', '        amulets[amulet_id].start_selling_block = block.number;\n', '        amulets[amulet_id].price = price;\n', '        gods[msg.sender].count_amulets_at_hand = sub(gods[msg.sender].count_amulets_at_hand, 1);\n', '        gods[msg.sender].count_amulets_selling = add(gods[msg.sender].count_amulets_selling, 1);\n', '        \n', '        return gods[msg.sender].count_amulets_selling;\n', '\n', '    }\n', '\n', '    function buy_amulet (uint amulet_id) public payable returns (bool) {\n', '        uint price = amulets[amulet_id].price;\n', '        require(msg.value >= price && msg.value < add(price, max_extra_eth)\n', '        && amulets[amulet_id].start_selling_block > 0\n', '        && amulets[amulet_id].owner != msg.sender\n', '        && price > 0);\n', '        \n', '        address seller = amulets[amulet_id].owner;\n', '        amulets[amulet_id].owner = msg.sender;\n', '        amulets[amulet_id].bound_start_block = block.number;\n', '        amulets[amulet_id].start_selling_block = 0;\n', '\n', '        gods[msg.sender].count_amulets_at_hand++;\n', '        update_amulets_count(msg.sender, amulet_id, true);\n', '        gods[seller].count_amulets_selling--;\n', '        update_amulets_count(seller, amulet_id, false);\n', '\n', '        egses_from_contract(seller, price, 6); // 6 sell amulet\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw_amulet_order (uint amulet_id) public returns (uint){\n', '        // an amulet can only have one order_id, so withdraw amulet_id instead of withdraw order_id, since only amulet_id is shown in amulets_at_hand\n', '        require(msg.sender == amulets[amulet_id].owner\n', '                && amulet_id >= 1 && amulet_id <= count_amulets\n', '                && amulets[amulet_id].start_selling_block > 0);\n', '                \n', '        amulets[amulet_id].start_selling_block = 0;\n', '        gods[msg.sender].count_amulets_at_hand++;\n', '        gods[msg.sender].count_amulets_selling--;\n', '\n', '        return gods[msg.sender].count_amulets_selling;\n', '    }\n', '    \n', '    function update_amulets_count (address god_address, uint amulet_id, bool obtained) private returns (uint){\n', '        if (obtained == true){\n', '            if (amulet_id < gods[god_address].amulets_start_id) {\n', '                gods[god_address].amulets_start_id = amulet_id;\n', '            }\n', '        } else {\n', '            if (amulet_id == gods[god_address].amulets_start_id){\n', '                for (uint i = amulet_id; i <= count_amulets; i++){\n', '                    if (amulets[i].owner == god_address && i > amulet_id){\n', '                        gods[god_address].amulets_start_id = i;\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return gods[god_address].amulets_start_id;\n', '    }\n', '    \n', '\n', '    function get_amulets_generated (uint god_id) public view returns (uint[]) {\n', '        address god_address = gods_address[god_id];\n', '        uint count_amulets_generated = gods[god_address].count_amulets_generated;\n', '        \n', '        uint [] memory temp_list = new uint[](count_amulets_generated);\n', '        uint count_elements = 0;\n', '        for (uint i = gods[god_address].first_amulet_generated; i <= count_amulets; i++){\n', '            if (amulets[i].god_id == god_id){\n', '                temp_list [count_elements] = i;\n', '                count_elements++;\n', '                \n', '                if (count_elements >= count_amulets_generated){\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return temp_list;\n', '    }\n', '\n', '    \n', '    function get_amulets_at_hand (address god_address) public view returns (uint[]) {\n', '        uint count_amulets_at_hand = gods[god_address].count_amulets_at_hand;\n', '        uint [] memory temp_list = new uint[] (count_amulets_at_hand);\n', '        uint count_elements = 0;\n', '        for (uint i = gods[god_address].amulets_start_id; i <= count_amulets; i++){\n', '            if (amulets[i].owner == god_address && amulets[i].start_selling_block == 0){\n', '                temp_list[count_elements] = i;\n', '                count_elements++;\n', '                \n', '                if (count_elements >= count_amulets_at_hand){\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return temp_list;\n', '    }\n', '    \n', '    \n', '    function get_my_amulets_selling () public view returns (uint[]){\n', '\n', '        uint count_amulets_selling = gods[msg.sender].count_amulets_selling;\n', '        uint [] memory temp_list = new uint[] (count_amulets_selling);\n', '        uint count_elements = 0;\n', '        for (uint i = gods[msg.sender].amulets_start_id; i <= count_amulets; i++){\n', '            if (amulets[i].owner == msg.sender \n', '            && amulets[i].start_selling_block > 0){\n', '                temp_list[count_elements] = i;\n', '                count_elements++;\n', '                \n', '                if (count_elements >= count_amulets_selling){\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return temp_list;\n', '    }\n', '\n', '    // to calculate how many pages\n', '    function get_amulet_orders_overview () public view returns(uint){\n', '        uint count_amulets_selling = 0;\n', '        for (uint i = 1; i <= count_amulets; i++){\n', '            if (add(amulets[i].start_selling_block, order_duration) > block.number && amulets[i].owner != msg.sender){\n', '                count_amulets_selling ++;\n', '            }\n', '        }        \n', '        \n', '        return count_amulets_selling; // to show page numbers when getting amulet_orders\n', '    }\n', '\n', '    function get_amulet_orders (uint page_number) public view returns (uint[]){\n', '        uint[] memory temp_list = new uint[] (20);\n', '        uint count_amulets_selling = 0;\n', '        uint count_list_elements = 0;\n', '\n', '        if ((page_number < 1)\n', '            || count_amulets  <= 20) {\n', '            page_number = 1; // chose a page out of range\n', '        }\n', '        uint start_amulets_count = mul(sub(page_number, 1), 20);\n', '\n', '        for (uint i = 1; i <= count_amulets; i++){\n', '            if (add(amulets[i].start_selling_block, order_duration) > block.number && amulets[i].owner != msg.sender){\n', '                \n', '                if (count_amulets_selling <= start_amulets_count) {\n', '                    count_amulets_selling ++;\n', '                }\n', '                if (count_amulets_selling > start_amulets_count){\n', '                    \n', '                    temp_list[count_list_elements] = i;\n', '                    count_list_elements ++;\n', '                    \n', '                    if (count_list_elements >= 20){\n', '                        break;\n', '                    }\n', '                }\n', '                \n', '            }\n', '        }\n', '        \n', '        return temp_list;\n', '    }\n', '    \n', '    \n', '    function get_amulet (uint amulet_id) public view returns(address, string, uint, uint, uint, uint, uint){\n', '        uint god_id = amulets[amulet_id].god_id;\n', '        // address god_address = gods_address[god_id];\n', '        string memory god_name = eth_gods_name.get_god_name(gods_address[god_id]);\n', '        uint god_level = gods[gods_address[god_id]].level;\n', '        uint amulet_level = amulets[amulet_id].level;\n', '        uint start_selling_block = amulets[amulet_id].start_selling_block;\n', '        uint price = amulets[amulet_id].price;\n', '\n', '        return(amulets[amulet_id].owner,\n', '                god_name,\n', '                god_id,\n', '                god_level,\n', '                amulet_level,\n', '                start_selling_block,\n', '                price\n', '              );\n', '    }\n', '\n', '    function get_amulet2 (uint amulet_id) public view returns(uint){\n', '        return amulets[amulet_id].bound_start_block;\n', '    }\n', '\n', '    // end of amulet\n', '    \n', '    // start of pray\n', '    function admin_deposit (uint egst_amount) public payable returns (bool) {\n', '        require (msg.sender == admin);\n', '        if (msg.value > 0){\n', '            pray_egses = add(pray_egses, msg.value);\n', '            egses_from_contract(admin, msg.value, 4); // 4 admin_deposit to reward_pool\n', '        }\n', '        if (egst_amount > 0){\n', '            pray_egst = add(pray_egst, egst_amount);\n', '            egst_to_contract(admin, egst_amount, 4); // 4 admin_deposit to reward_pool            \n', '        }\n', '        return true;\n', '    }\n', '        \n', '    function initialize_pray () private returns (bool){\n', '        if (pray_start_block > 0) {\n', '            require (check_event_completed() == true\n', '            && rewarded_pray_winners == true);\n', '        }\n', '        \n', '        count_rounds = add(count_rounds, 1);\n', '        count_rounds_winner_logs[count_rounds] = 0;\n', '        pray_start_block = block.number;\n', '        rewarded_pray_winners = false;\n', '\n', '        for (uint i = 1; i <= 5; i++){\n', '            pk_positions[i] = max_winners[i]; // pk start from the last slot\n', '\t\t\tcount_listed_winners[i] = 0;\n', '        }\n', '        if (listed_gods.length > count_hosted_gods) {\n', "            // a new god's turn\n", '            count_hosted_gods = add(count_hosted_gods, 1);\n', '            pray_host_god = bidding_gods[count_hosted_gods];\n', '            gods[pray_host_god].hosted_pray = true;\n', '            pray_reward_top100 = true;\n', '        } else {\n', '            //choose highest bidder\n', '            (uint highest_bid, address highest_bidder) = compare_bid_eth();\n', '\n', '            gods[highest_bidder].bid_eth = 0;\n', '            pray_host_god = highest_bidder;\n', '            pray_egses = add(pray_egses, highest_bid);\n', '            pray_reward_top100 = false;\n', '\n', '        }\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '    function bid_host () public payable returns (bool) {\n', '        require (msg.value > 0 && gods[msg.sender].listed > 0);\n', '        gods[msg.sender].bid_eth = add (gods[msg.sender].bid_eth, msg.value);\n', '\n', '        return true;\n', '    }\n', '    \n', '\n', '    function withdraw_bid () public returns (bool) {\n', '        require(gods[msg.sender].bid_eth > 0);\n', '        gods[msg.sender].bid_eth = 0;\n', '        egses_from_contract(msg.sender, gods[msg.sender].bid_eth, 8); // 8  withdraw bid\n', '        return true;\n', '    }\n', '    \n', '    \n', "    // if browser web3 didn't get god's credit, use pray_create in the pray button to create god_id first\n", '    function pray_create (uint inviter_id) public returns (bool) {\n', '        // when create a new god, set credit as 1, so credit <= 0 means god_id not created yet\n', '        create_god(msg.sender, inviter_id);\n', '        pray();\n', '    }\n', '    \n', "    // if browser web3 got god's credit, use pray in the pray button\n", '    function pray () public returns (bool){\n', '        require (add(gods[msg.sender].block_number, min_pray_interval) < block.number\n', '        && tx.gasprice <= max_gas_price\n', '        && check_event_completed() == false);\n', '\n', '        if (waiting_prayer_index <= count_waiting_prayers) {\n', '\n', '            address waiting_prayer = waiting_prayers[waiting_prayer_index];\n', '            uint god_block_number = gods[waiting_prayer].block_number;\n', '            bytes32 block_hash;\n', '            \n', '            if ((add(god_block_number, 1)) < block.number) {// can only get previous block hash\n', '\n', '                if (add(god_block_number, block_hash_duration) < block.number) {// make sure this god has a valid block_number to generate block hash\n', "                    gods[waiting_prayer].block_number = block.number; // refresh this god's expired block_id\n", '                    // delete waiting_prayers[waiting_prayer_index];\n', '                    count_waiting_prayers = add(count_waiting_prayers, 1);\n', '                    waiting_prayers[count_waiting_prayers] = waiting_prayer;\n', '                } else {// draw lottery and/or create gene for the waiting prayer\n', '                    block_hash = keccak256(abi.encodePacked(blockhash(add(god_block_number, 1))));\n', '                    if(gods[waiting_prayer].gene_created == false){\n', '                        gods[waiting_prayer].gene = block_hash;\n', '                        gods[waiting_prayer].gene_created = true;\n', '                    }\n', '                    gods[waiting_prayer].pray_hash = block_hash;\n', '    \n', '                    uint dice_result = eth_gods_dice.throw_dice (block_hash)[0];\n', '\n', '                    if (dice_result >= 1 && dice_result <= 5){\n', '                        set_winner(dice_result, waiting_prayer, block_hash, god_block_number);\n', '                    }\n', '                }\n', '                waiting_prayer_index = add(waiting_prayer_index, 1);\n', '            }\n', '        }\n', '        \n', '        count_waiting_prayers = add(count_waiting_prayers, 1);\n', '        waiting_prayers[count_waiting_prayers] = msg.sender;\n', '\n', '        gods[msg.sender].block_number = block.number;\n', '        gods[msg.sender].pray_hash = 0x0;\n', '        add_exp(msg.sender, 1);\n', '        add_exp(pray_host_god, 1);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function set_winner (uint prize, address waiting_prayer, bytes32 block_hash, uint god_block_number) private returns (uint){\n', '\n', '        count_rounds_winner_logs[count_rounds] = add(count_rounds_winner_logs[count_rounds], 1);\n', '        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].god_block_number = god_block_number;\n', '        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].block_hash = block_hash;\n', '        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].prayer = waiting_prayer;\n', '        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].prize = prize;\n', '\n', '        if (count_listed_winners[prize] >= max_winners[prize]){ // winner_list maxed, so the new prayer challenge previous winners\n', '           \tuint pk_position = pk_positions[prize];\n', '        \taddress previous_winner = listed_winners[prize][pk_position];  \n', '\n', '            bool pk_result = pk(waiting_prayer, previous_winner, block_hash);\n', '\n', '\t\t\twinner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].pk_result = pk_result;\n', '\t\t\twinner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].previous_winner = previous_winner;\n', '            \n', '            if (pk_result == true) {\n', '                listed_winners[prize][pk_position] = waiting_prayer; // attacker defeat defender\n', '            }\n', '            if (prize > 1) { // no need to change pk_pos for champion\n', '                if (pk_positions[prize] > 1){\n', '                    pk_positions[prize] = sub(pk_positions[prize], 1);\n', '                } else {\n', '                    pk_positions[prize] = max_winners[prize];\n', '                }               \n', '            }\n', '        } else {\n', '            count_listed_winners[prize] = add(count_listed_winners[prize], 1);\n', '            listed_winners[prize][count_listed_winners[prize]] = waiting_prayer;\n', '        }\n', '     \n', '        return count_listed_winners[prize];\n', '    }\n', '\n', '    function reward_pray_winners () public returns (bool){\n', '        require (check_event_completed() == true);\n', '\n', '        uint this_reward_egses;\n', '        uint reward_pool_egses = div(pray_egses, 10);\n', '        pray_egses = sub(pray_egses, reward_pool_egses);\n', '        uint this_reward_egst;\n', '        uint reward_pool_egst = div(pray_egst, 10);\n', '        pray_egst = sub(pray_egst, reward_pool_egst); // reduce sum for less calculation\n', '        \n', '        egst_from_contract(pray_host_god, mul(div(reward_pool_egst, 100), 60), 1); // 1 pray_reward for hosting event\n', '        \n', '        for (uint i = 1; i<=5; i++){\n', '            this_reward_egses = 0;\n', '            this_reward_egst = 0;\n', '            if (i == 1) {\n', '                this_reward_egses = mul(div(reward_pool_egses, 100), 60);\n', '            } else if (i == 2){\n', '                this_reward_egses = mul(div(reward_pool_egses, 100), 20);\n', '            } else if (i == 3){\n', '                this_reward_egst = mul(div(reward_pool_egst, 100), 3);\n', '            } else if (i == 4){\n', '                this_reward_egst = div(reward_pool_egst, 100);\n', '            } \n', '            \n', '            for (uint reward_i = 1; reward_i <= count_listed_winners[i]; reward_i++){\n', '                address rewarding_winner = listed_winners[i][reward_i];\n', '\n', '                if (this_reward_egses > 0 ) {\n', '                    egses_from_contract(rewarding_winner, this_reward_egses, 1); // 1 pray_reward\n', '                } else if (this_reward_egst > 0) {\n', '                    egst_from_contract(rewarding_winner, this_reward_egst, 1); // 1 pray_reward\n', '                }  \n', '                \n', '                add_exp(rewarding_winner, 6);\n', '            }\n', '        }\n', '            \n', '        \n', '        if(pray_reward_top100 == true) {\n', '            reward_top_gods();\n', '        }\n', '            \n', '        // a small gift of exp & egst to the god who burned gas to send rewards to the community\n', '        egst_from_contract(msg.sender, mul(initializer_reward, 1 ether), 1); // 1 pray_reward\n', '        _totalSupply = add(_totalSupply, mul(initializer_reward, 1 ether));  \n', '        add_exp(msg.sender, initializer_reward);\n', '\n', '        rewarded_pray_winners = true;\n', '        initialize_pray();\n', '        return true;\n', '    }\n', '\n', '\n', '    // more listed gods, more reward to the top gods, highest reward 600 egst\n', '    function reward_top_gods () private returns (bool){ // public when testing\n', '        \n', '        uint count_listed_gods = listed_gods.length;\n', '        uint last_god_index;\n', '        \n', '        if (count_listed_gods > 100) {\n', '            last_god_index = sub(count_listed_gods, 100);\n', '        } else {\n', '            last_god_index = 0;\n', '        }\n', '        \n', '        uint reward_egst = 0;\n', '        uint base_reward = 6 ether;\n', '        if (count_rounds == 6){\n', '            base_reward = mul(base_reward, 6);\n', '        }\n', '        for (uint i = last_god_index; i < count_listed_gods; i++) {\n', '            reward_egst = mul(base_reward, sub(add(i, 1), last_god_index));\n', '            egst_from_contract(gods_address[listed_gods[i]], reward_egst, 2);// 2 top_gods_reward\n', '            _totalSupply = add(_totalSupply, reward_egst);   \n', '            if (gods[gods_address[listed_gods[i]]].blessing_player_id > 0){\n', '                egst_from_contract(gods_address[gods[gods_address[listed_gods[i]]].blessing_player_id], reward_egst, 2);// 2 top_gods_reward\n', '                _totalSupply = add(_totalSupply, reward_egst); \n', '            }\n', '        }\n', '        \n', '        return true;\n', '    }\n', '\n', '\n', '    function compare_bid_eth () private view returns (uint, address) {\n', '        uint highest_bid = 0;\n', '        address highest_bidder = v_god; // if no one bid, v god host this event\n', '\n', '        for (uint j = 1; j <= listed_gods.length; j++){\n', '            if (gods[bidding_gods[j]].bid_eth > highest_bid){\n', '                highest_bid = gods[bidding_gods[j]].bid_eth;\n', '                highest_bidder = bidding_gods[j];\n', '            }\n', '        }\n', '        return (highest_bid, highest_bidder);\n', '    }\n', '\n', '\n', '    function check_event_completed () public view returns (bool){\n', '        // check min and max pray_event duration\n', '        if (add(pray_start_block, max_pray_duration) > block.number){\n', '            if (add(pray_start_block, min_pray_duration) < block.number){\n', '                for (uint i = 1; i <= 5; i++){\n', '                    if(count_listed_winners[i] < max_winners[i]){\n', '                        return false;\n', '                    }           \n', '                }\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '            \n', '        } else {\n', '            return true;   \n', '        }\n', '    }\n', '\n', '\n', '    function pk (address attacker, address defender, bytes32 block_hash) public view returns (bool pk_result){// make it public, view only, other contract may use it\n', '\n', '        (uint attacker_sum_god_levels, uint attacker_sum_amulet_levels) = get_sum_levels_pk(attacker);\n', '        (uint defender_sum_god_levels, uint defender_sum_amulet_levels) = get_sum_levels_pk(defender);\n', '    \n', '        pk_result = eth_gods_dice.pk(block_hash, attacker_sum_god_levels, attacker_sum_amulet_levels, defender_sum_god_levels, defender_sum_amulet_levels);\n', '        \n', '        return pk_result;\n', '    }\n', '    \n', '    \n', '    function get_sum_levels_pk (address god_address) public view returns (uint sum_gods_level, uint sum_amulets_level){\n', '             \n', '        sum_gods_level =  gods[god_address].level;\n', '        sum_amulets_level = gods[god_address].pet_level; // add pet level to the sum\n', '\t\tuint amulet_god_id;\n', '        uint amulet_god_level;\n', '        for (uint i = 1; i <= count_amulets; i++){\n', '            if (amulets[i].owner == god_address && amulets[i].start_selling_block == 0){\n', '                amulet_god_id = amulets[i].god_id;\n', '                amulet_god_level = gods[gods_address[amulet_god_id]].level;\n', '                sum_gods_level = add(sum_gods_level, amulet_god_level);\n', '                sum_amulets_level = add(sum_amulets_level, amulets[i].level);\n', '            }\n', '        }\n', '                \n', '        return (sum_gods_level, sum_amulets_level);\n', '    }\n', '        \n', '    //admin need this function\n', '    function get_listed_winners (uint prize) public view returns (address[]){\n', '        address [] memory temp_list = new address[] (count_listed_winners[prize]);\n', '        for (uint i = 0; i < count_listed_winners[prize]; i++){\n', '            temp_list[i] = listed_winners[prize][add(i,1)];\n', '        }\n', '        return temp_list;\n', '    }\n', '\n', '   \n', '    function query_pray () public view returns (uint, uint, uint, address, address, uint, bool){\n', '        (uint highest_bid, address highest_bidder) = compare_bid_eth();\n', '        return (highest_bid, \n', '                pray_egses, \n', '                pray_egst, \n', '                pray_host_god, \n', '                highest_bidder,\n', '                count_rounds,\n', '                pray_reward_top100);\n', '    }     \n', '    \n', '\n', ' \n', '    // end of pray\n', '\n', '    // start of egses\n', '\n', '    function egses_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing\n', '        if (reason == 1) {\n', '            require (pray_egses > tokens);\n', '            pray_egses = sub(pray_egses, tokens);\n', '        }\n', '\n', '        egses_balances[to] = add(egses_balances[to], tokens);\n', '\n', '        create_change_log(1, reason, tokens, egses_balances[to], contract_address, to);\n', '        return true;\n', '    } \n', '    \n', '    function egses_withdraw () public returns (uint tokens){\n', '        tokens = egses_balances[msg.sender];\n', '        require (tokens > 0 && contract_address.balance >= tokens && reEntrancyMutex == false);\n', '\n', '        reEntrancyMutex = true; // if met problem, it will use up gas from msg.sender and roll back to false\n', '        egses_balances[msg.sender] = 0;\n', '        msg.sender.transfer(tokens);\n', '        reEntrancyMutex = false;\n', '        \n', '        emit withdraw_egses(msg.sender, tokens);\n', '        create_change_log(1, 5, tokens, 0, contract_address, msg.sender); // 5 withdraw egses\n', '\n', '        return tokens;\n', '    }\n', '    event withdraw_egses (address receiver, uint tokens);\n', '\n', '   // end of egses\n', '   \n', '\n', '    // start of erc20 for egst\n', '    function totalSupply () public view returns (uint){\n', '        return _totalSupply;\n', '    }\n', '\n', '\n', '    function balanceOf (address tokenOwner) public view returns (uint){\n', "        return balances[tokenOwner]; // will return 0 if doesn't exist\n", '    }\n', '\n', '    function allowance (address tokenOwner, address spender) public view returns (uint) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    function transfer (address to, uint tokens) public returns (bool success){\n', '        require (balances[msg.sender] >= tokens);\n', '        balances[msg.sender] = sub(balances[msg.sender], tokens);\n', '        balances[to] = add(balances[to], tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        create_change_log(2, 9, tokens, balances[to], msg.sender, to);\n', '        \n', '        return true;    \n', '    }\n', '    event Transfer (address indexed from, address indexed to, uint tokens);\n', '\n', '\n', '    function approve (address spender, uint tokens) public returns (bool success) {\n', '        // if allowed amount used and owner tries to reset allowed amount within a short time,\n', '        // the allowed account might be cheating the owner\n', '        require (balances[msg.sender] >= tokens);\n', '        if (tokens > 0){\n', '            require (add(gods[msg.sender].allowed_block, allowed_use_CD) < block.number);\n', '        }\n', '\n', '        allowed[msg.sender][spender] = tokens;\n', '        \n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    event Approval (address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '\n', '    function transferFrom (address from, address to, uint tokens) public returns (bool success) {\n', '        require (balances[from] >= tokens);\n', '        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens);\n', '        balances[from] = sub(balances[from], tokens);\n', '        balances[to] = add(balances[to], tokens);\n', '        gods[from].allowed_block = block.number;\n', '        \n', '        emit Transfer(from, to, tokens);\n', '        create_change_log(2, 10, tokens, balances[to], from, to);\n', '        return true;    \n', '    }\n', '\n', '    // end of erc20 for egst\n', '    \n', '    \n', '    // egst\n', '  \n', '    function egst_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing\n', '        balances[to] = add(balances[to], tokens);\n', '\n', '        create_change_log(2, reason, tokens, balances[to], contract_address, to); \n', '        return true;\n', '    }\n', '\n', '    function egst_to_contract (address from, uint tokens, uint reason) private returns (bool) { // public when testing\n', '        require (balances[from] >= tokens);\n', '        balances[from] = sub(balances[from], tokens);\n', '        \n', '\n', '        emit spend_egst(from, tokens, reason);\n', '        create_change_log(2, reason, tokens, balances[from], from, contract_address);\n', '        return true;\n', '    }\n', '    event spend_egst (address from, uint tokens, uint reason);\n', '\n', '\n', '    function create_token_order (uint unit_price, uint egst_amount) public returns (uint) {      \n', '        require(unit_price >= min_unit_price && unit_price <= max_unit_price \n', '        && balances[msg.sender] >= egst_amount\n', '        && egst_amount <= max_egst_amount\n', '        && egst_amount >= min_egst_amount);\n', '\n', '        count_token_orders = add(count_token_orders, 1);\n', '\n', '        egst_to_contract(msg.sender, egst_amount, 3); // 3 create_token_order\n', '        \n', '        token_orders[count_token_orders].start_selling_block = block.number;    \n', '        token_orders[count_token_orders].seller = msg.sender;\n', '        token_orders[count_token_orders].unit_price = unit_price;\n', '        token_orders[count_token_orders].egst_amount = egst_amount;\n', '        gods[msg.sender].count_token_orders++;\n', '        \n', '        update_first_active_token_order(msg.sender);\n', '\n', '        return gods[msg.sender].count_token_orders++;\n', '    }\n', '\n', '\n', '    function withdraw_token_order (uint order_id) public returns (bool) { \n', '        require (msg.sender == token_orders[order_id].seller\n', '                && token_orders[order_id].egst_amount > 0);\n', '\n', '        uint egst_amount = token_orders[order_id].egst_amount;\n', '        token_orders[order_id].start_selling_block = 0;\n', '        token_orders[order_id].egst_amount = 0;\n', '        // balances[msg.sender] = add(balances[msg.sender], tokens);\n', '        egst_from_contract(msg.sender, egst_amount, 4); // 4  withdraw token_order\n', '        gods[msg.sender].count_token_orders = sub(gods[msg.sender].count_token_orders, 1);\n', '        \n', '        update_first_active_token_order(msg.sender);\n', '        emit WithdrawTokenOrder(msg.sender, order_id);\n', '\n', '        return true;\n', '    }\n', '    event WithdrawTokenOrder (address seller, uint order_id);\n', '\n', '    function buy_token (uint order_id, uint egst_amount) public payable returns (uint) { \n', '\n', '        require(order_id >= first_active_token_order \n', '                && order_id <= count_token_orders\n', '                && egst_amount <= token_orders[order_id].egst_amount\n', '                && token_orders[order_id].egst_amount > 0);\n', '        \n', '        // unit_price 100 means 1 egst = 0.001 ether\n', '        uint eth_cost = div(mul(token_orders[order_id].unit_price, egst_amount), 100000);\n', '        require(msg.value >= eth_cost && msg.value < add(eth_cost, max_extra_eth) );\n', '\n', '        token_orders[order_id].egst_amount = sub(token_orders[order_id].egst_amount, egst_amount);\n', '        egst_from_contract(msg.sender, egst_amount, token_orders[order_id].unit_price); // uint price (> 10) will be recorded as reason in change log and translated by front end as buy token & unit_price\n', '        // balances[msg.sender] = add(balances[msg.sender], egst_amount);\n', '        \n', '        address seller = token_orders[order_id].seller;\n', '        egses_from_contract(seller, eth_cost, 7); // 7 sell egst\n', '        \n', '        \n', '        if (token_orders[order_id].egst_amount <= 0){\n', '            token_orders[order_id].start_selling_block = 0;\n', '            gods[seller].count_token_orders = sub(gods[seller].count_token_orders, 1);\n', '            update_first_active_token_order(seller);\n', '        }\n', '        \n', '        emit BuyToken(msg.sender, order_id, egst_amount);\n', '\n', '        return token_orders[order_id].egst_amount;\n', '    }\n', '    event BuyToken (address buyer, uint order_id, uint egst_amount);\n', '\n', '  \n', '    function update_first_active_token_order (address god_address) private returns (uint, uint){ // public when testing\n', '        if (count_token_orders > 0 \n', '        && first_active_token_order == 0){\n', '            first_active_token_order = 1;\n', '        } else {\n', '            for (uint i = first_active_token_order; i <= count_token_orders; i++) {\n', '                if (add(token_orders[i].start_selling_block, order_duration) > block.number){\n', '                    // find the first active order and compare with the currect index\n', '                    if (i > first_active_token_order){\n', '                        first_active_token_order = i;\n', '                    }\n', '                    break;\n', '                }\n', '            }    \n', '        }\n', '            \n', '        if (gods[god_address].count_token_orders > 0\n', '        && gods[god_address].first_active_token_order == 0){\n', '            gods[god_address].first_active_token_order = 1; // may not be 1, but it will correct next time\n', '        } else {\n', '            for (uint j = gods[god_address].first_active_token_order; j < count_token_orders; j++){\n', '                if (token_orders[j].seller == god_address \n', "                && token_orders[j].start_selling_block > 0){ // don't check duration, show it to selling, even if expired\n", '                    // find the first active order and compare with the currect index\n', '                    if(j > gods[god_address].first_active_token_order){\n', '                        gods[god_address].first_active_token_order = j;\n', '                    }\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        \n', '        return (first_active_token_order, gods[msg.sender].first_active_token_order);\n', '    }\n', '\n', '\n', '    function get_token_order (uint order_id) public view returns(uint, address, uint, uint){\n', '        require(order_id >= 1 && order_id <= count_token_orders);\n', '\n', '        return(token_orders[order_id].start_selling_block,\n', '               token_orders[order_id].seller,\n', '               token_orders[order_id].unit_price,\n', '               token_orders[order_id].egst_amount);\n', '    }\n', '\n', '    // return total orders and lowest price to browser, browser query each active order and show at most three orders of lowest price\n', '    function get_token_orders () public view returns(uint, uint, uint, uint, uint) {\n', '        uint lowest_price = max_unit_price;\n', '        for (uint i = first_active_token_order; i <= count_token_orders; i++){\n', '            if (token_orders[i].unit_price < lowest_price \n', '            && token_orders[i].egst_amount > 0\n', '            && add(token_orders[i].start_selling_block, order_duration) > block.number){\n', '                lowest_price = token_orders[i].unit_price;\n', '            }\n', '        }\n', '        return (count_token_orders, first_active_token_order, order_duration, max_unit_price, lowest_price);\n', '    }\n', '    \n', '\n', '    function get_my_token_orders () public view returns(uint []) {\n', '        uint my_count_token_orders = gods[msg.sender].count_token_orders;\n', '        uint [] memory temp_list = new uint[] (my_count_token_orders);\n', '        uint count_list_elements = 0;\n', '        for (uint i = gods[msg.sender].first_active_token_order; i <= count_token_orders; i++){\n', '            if (token_orders[i].seller == msg.sender\n', '            && token_orders[i].start_selling_block > 0){\n', '                temp_list[count_list_elements] = i;\n', '                count_list_elements++;\n', '                \n', '                if (count_list_elements >= my_count_token_orders){\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        return temp_list;\n', '    }\n', '\n', '\n', '    // end of egst\n', '    \n', '   \n', '    // logs\n', '    function get_winner_log (uint pray_round, uint log_id) public view returns (uint, bytes32, address, address, uint, bool){\n', '        require(log_id >= 1 && log_id <= count_rounds_winner_logs[pray_round]);\n', '        winner_log storage this_winner_log = winner_logs[pray_round][log_id];\n', '        return (this_winner_log.god_block_number,\n', '                this_winner_log.block_hash,\n', '                this_winner_log.prayer,\n', '                this_winner_log.previous_winner,\n', '                this_winner_log.prize,\n', '                this_winner_log.pk_result);\n', '    }    \n', '\n', '    function get_count_rounds_winner_logs (uint pray_round) public view returns (uint){\n', '        return count_rounds_winner_logs[pray_round];\n', '    }\n', '\n', '\n', '    // egses change reasons:  \n', '        // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,\n', '        // 4 admin_deposit to reward_pool, 5 withdraw egses\n', '        // 6 sell amulet, 7 sell egst, 8 withdraw bid\n', '    \n', '    // egst_change reasons: \n', '        // 1 pray_reward, 2 top_gods_reward, \n', '        // 3 create_token_order, 4 withdraw token_order, 5 buy token (> 10),  \n', '        // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward, \n', '        // 9 transfer, 10 transferFrom(owner & receiver)\n', '\n', '        \n', '    function create_change_log (uint asset_type, uint reason, uint change_amount, uint after_amount, address _from, address _to) private returns (uint) {\n', '        count_rounds_change_logs[count_rounds] = add(count_rounds_change_logs[count_rounds], 1);\n', '        uint log_id = count_rounds_change_logs[count_rounds];\n', ' \n', '        change_logs[count_rounds][log_id].block_number = block.number;\n', '        change_logs[count_rounds][log_id].asset_type = asset_type;\n', '        change_logs[count_rounds][log_id].reason = reason;\n', '        change_logs[count_rounds][log_id].change_amount = change_amount;\n', '        change_logs[count_rounds][log_id].after_amount = after_amount; \n', '        change_logs[count_rounds][log_id]._from = _from;\n', '        change_logs[count_rounds][log_id]._to = _to;\n', '        \n', '        return log_id;\n', '    }\n', '          \n', '    function get_change_log (uint pray_round, uint log_id) public view returns (uint, uint, uint, uint, uint, address, address){ // public\n', '        change_log storage this_log = change_logs[pray_round][log_id];\n', '        return (this_log.block_number,\n', '                this_log.asset_type,\n', '                this_log.reason, // reason > 10 is buy_token unit_price\n', '                this_log.change_amount,\n', "                this_log.after_amount, // god's after amount. transfer or transferFrom doesn't record log\n", '                this_log._from,\n', '                this_log._to);\n', '        \n', '    }\n', '    \n', '    function get_count_rounds_change_logs (uint pray_round) public view returns(uint){\n', '        return count_rounds_change_logs[pray_round];\n', '    }\n', '    \n', '    // end of logs\n', '\n', '\n', '    // common functions\n', '\n', '     function add (uint a, uint b) internal pure returns (uint c) {\n', '         c = a + b;\n', '         require(c >= a);\n', '     }\n', '     function sub (uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '         c = a - b;\n', '     }\n', '     function mul (uint a, uint b) internal pure returns (uint c) {\n', '         c = a * b;\n', '         require(a == 0 || c / a == b);\n', '     }\n', '     function div (uint a, uint b) internal pure returns (uint c) {\n', '         require(b > 0);\n', '         c = a / b;\n', '     }\n', '\n', '}\n', '\n', 'contract EthGodsDice {\n', '    \n', '    // ethgods\n', '    EthGods private eth_gods;\n', '    address private ethgods_contract_address = address(0);// publish ethgods first, then use that address in constructor \n', '    function set_eth_gods_contract_address(address eth_gods_contract_address) public returns (bool){\n', '        require (msg.sender == admin);\n', '        \n', '        ethgods_contract_address = eth_gods_contract_address;\n', '        eth_gods = EthGods(ethgods_contract_address); \n', '        return true;\n', '    }\n', '  \n', "    address private admin; // manually update to ethgods' admin\n", '    uint private block_hash_duration;\n', '    function update_admin () public returns (bool){\n', '        (,,address new_admin, uint new_block_hash_duration,,,) = eth_gods.query_contract();\n', '        require (msg.sender == new_admin);\n', '        admin = new_admin;\n', '        block_hash_duration = new_block_hash_duration;\n', '        return true;\n', '    }\n', '        \n', '    //contract information & administration\n', '    bool private contract_created; // in case constructor logic change in the future\n', '    address private contract_address; //shown at the top of the home page\n', '    \n', '    // start of constructor and destructor\n', '    constructor () public {\n', '        require (contract_created == false);\n', '        contract_created = true;\n', '        contract_address = address(this);\n', '        admin = msg.sender;\n', '\n', '    }\n', '\n', '    function finalize () public {\n', '        require (msg.sender == admin);\n', '        selfdestruct(msg.sender); \n', '    }\n', '    \n', '    function () public payable {\n', '        revert();  // if received eth for no reason, reject\n', '    }\n', '    \n', '    // end of constructor and destructor\n', '\n', '    function tell_fortune_blockhash () public view returns (bytes32){\n', '        bytes32 block_hash;\n', '        (uint god_block_number,,,,,,) = eth_gods.get_god_info(msg.sender);\n', '        if (god_block_number > 0\n', '            && add(god_block_number, 1) < block.number\n', '            && add(god_block_number, block_hash_duration) > block.number) {\n', '            block_hash = keccak256(abi.encodePacked(blockhash(god_block_number + 1)));\n', '        } else {\n', '            block_hash = keccak256(abi.encodePacked(blockhash(block.number - 1)));\n', '        }\n', '        return block_hash;\n', '    }\n', '    \n', '        \n', '    function tell_fortune () public view returns (uint[]){\n', '        bytes32 block_hash;\n', '        (uint god_block_number,,,,,,) = eth_gods.get_god_info(msg.sender);\n', '        if (god_block_number > 0\n', '            && add(god_block_number, 1) < block.number\n', '            && add(god_block_number, block_hash_duration) > block.number) {\n', '            block_hash = keccak256(abi.encodePacked(blockhash(god_block_number + 1)));\n', '        } else {\n', '            block_hash = keccak256(abi.encodePacked(blockhash(block.number - 1)));\n', '        }\n', '        return throw_dice (block_hash);\n', '    }\n', '\n', '    \n', '    function throw_dice (bytes32 block_hash) public pure returns (uint[]) {// 0 for prize, 1-6 for 6 numbers should be pure\n', '        uint[] memory dice_numbers = new uint[](7);\n', '        //uint [7] memory dice_numbers;\n', '        uint hash_number;\n', '        uint[] memory count_dice_numbers = new uint[](7);\n', '        //uint [7] memory count_dice_numbers;   // how many times for each dice number\n', '        uint i; // for loop\n', '  \n', '        for (i = 1; i <= 6; i++) {\n', '            hash_number = uint(block_hash[i]);\n', '            // hash_number=1;\n', '            if (hash_number >= 214) { // 214\n', '                dice_numbers[i] = 6;\n', '            } else if (hash_number >= 172) { // 172\n', '                dice_numbers[i] = 5;\n', '            } else if (hash_number >= 129) { // 129\n', '                dice_numbers[i] = 4;\n', '            } else if (hash_number >= 86) { // 86\n', '                dice_numbers[i] = 3;\n', '            } else if (hash_number >= 43) { // 43\n', '                dice_numbers[i] = 2;\n', '            } else {\n', '                dice_numbers[i] = 1;\n', '            }\n', '            count_dice_numbers[dice_numbers[i]] ++;\n', '        }\n', '\n', '        bool won_super_prize = false;\n', '        uint count_super_eth = 0;\n', '        for (i = 1; i <= 6; i++) {\n', '            if (count_dice_numbers[i] >= 5) {\n', '                dice_numbers[0] = 1; //champion_eth\n', '                won_super_prize = true;\n', '                break;\n', '            }else if (count_dice_numbers[i] == 4) {\n', '                dice_numbers[0] = 3; // super_egst\n', '                won_super_prize = true;\n', '                break;\n', '            }else if (count_dice_numbers[i] == 1) {\n', '                count_super_eth ++;\n', '                if (count_super_eth == 6) {\n', '                    dice_numbers[0] = 2; // super_eth\n', '                    won_super_prize = true;\n', '                }\n', '            } \n', '        }\n', '\n', '        if (won_super_prize == false) {\n', '            if (count_dice_numbers[6] >= 2){\n', '                dice_numbers[0] = 4; // primary_egst\n', '            } else if (count_dice_numbers[6] == 1){\n', '                dice_numbers[0] = 5; // lucky_star\n', '            } \n', '        }\n', '        \n', '        return dice_numbers;\n', '    }\n', '    \n', '    function pk (bytes32 block_hash, uint attacker_sum_god_levels, uint attacker_sum_amulet_levels, uint defender_sum_god_levels, uint defender_sum_amulet_levels) public pure returns (bool){\n', '     \n', '        uint god_win_chance;\n', '        attacker_sum_god_levels = add(attacker_sum_god_levels, 10);\n', '        if (attacker_sum_god_levels < defender_sum_god_levels){\n', '            god_win_chance = 0;\n', '        } else {\n', '            god_win_chance = sub(attacker_sum_god_levels, defender_sum_god_levels);\n', '            if (god_win_chance > 20) {\n', '                god_win_chance = 100;\n', '            } else { // equal level, 50% chance to win\n', '                god_win_chance = mul(god_win_chance, 5);\n', '            }\n', '        }        \n', '        \n', '        \n', '        uint amulet_win_chance;\n', '        attacker_sum_amulet_levels = add(attacker_sum_amulet_levels, 10);\n', '        if (attacker_sum_amulet_levels < defender_sum_amulet_levels){\n', '            amulet_win_chance = 0;\n', '        } else {\n', '            amulet_win_chance = sub(attacker_sum_amulet_levels, defender_sum_amulet_levels);\n', '            if (amulet_win_chance > 20) {\n', '                amulet_win_chance = 100;\n', '            } else { // equal level, 50% chance to win\n', '                amulet_win_chance = mul(amulet_win_chance, 5);\n', '            }\n', '        }\n', '\n', '        \n', '        uint attacker_win_chance = div(add(god_win_chance, amulet_win_chance), 2);\n', '        if (attacker_win_chance >= div(mul(uint(block_hash[3]),2),5)){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    // common functions\n', '\n', '     function add (uint a, uint b) internal pure returns (uint c) {\n', '         c = a + b;\n', '         require(c >= a);\n', '     }\n', '     function sub (uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '         c = a - b;\n', '     }\n', '     function mul (uint a, uint b) internal pure returns (uint c) {\n', '         c = a * b;\n', '         require(a == 0 || c / a == b);\n', '     }\n', '     function div (uint a, uint b) internal pure returns (uint c) {\n', '         require(b > 0);\n', '         c = a / b;\n', '     }\n', '        \n', '}\n', '\n', '\n', 'contract EthGodsName {\n', '\n', '    // EthGods\n', '    EthGods private eth_gods;\n', '    address private ethgods_contract_address;   \n', '    function set_eth_gods_contract_address (address eth_gods_contract_address) public returns (bool){\n', '        require (msg.sender == admin);\n', '        \n', '        ethgods_contract_address = eth_gods_contract_address;\n', '        eth_gods = EthGods(ethgods_contract_address); \n', '        return true;\n', '    }\n', '  \n', "    address private admin; // manually update to ethgods' admin\n", '    function update_admin () public returns (bool){\n', '        (,,address new_admin,,,,) = eth_gods.query_contract();\n', '        require (msg.sender == new_admin);\n', '        admin = new_admin;\n', '        return true;\n', '    }\n', '\n', '    //contract information & administration\n', '    bool private contract_created; // in case constructor logic change in the future\n', '    address private contract_address; //shown at the top of the home page   \n', '    \n', '    string private invalid_chars = "\\\\\\"";\n', '    bytes private invalid_bytes = bytes(invalid_chars);\n', '    function set_invalid_chars (string new_invalid_chars) public returns (bool) {\n', '        require(msg.sender == admin);\n', '        invalid_chars = new_invalid_chars;\n', '        invalid_bytes = bytes(invalid_chars);\n', '        return true;\n', '    }\n', '    \n', '    uint private valid_length = 16;    \n', '    function set_valid_length (uint new_valid_length) public returns (bool) {\n', '        require(msg.sender == admin);\n', '        valid_length = new_valid_length;\n', '        return true;\n', '    }\n', '    \n', '    struct god_name {\n', '        string god_name;\n', '        uint block_number;\n', '        uint block_duration;\n', '    }\n', '    mapping (address => god_name) private gods_name;\n', '\n', '    // start of constructor and destructor\n', '    \n', '    constructor () public {    \n', '        require (contract_created == false);\n', '        contract_created = true;\n', '        contract_address = address(this);\n', '        admin = msg.sender;     \n', '        address v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\n', '        gods_name[v_god].god_name = "V";\n', '    }\n', '\n', '    function () public payable {\n', '        revert();  // if received eth for no reason, reject\n', '    }\n', '\n', '    function finalize() public {\n', '        require (msg.sender == admin);\n', '        selfdestruct(msg.sender); \n', '    }\n', '    \n', '    // end of constructor and destructor\n', '    \n', '    \n', '    function set_god_name (string new_name) public returns (bool){\n', '        address god_address = msg.sender;\n', '        require (add(gods_name[god_address].block_number, gods_name[god_address].block_duration) < block.number );\n', '\n', '        bytes memory bs = bytes(new_name);\n', '        require (bs.length <= valid_length);\n', '        \n', '        for (uint i = 0; i < bs.length; i++){\n', '            for (uint j = 0; j < invalid_bytes.length; j++) {\n', '                if (bs[i] == invalid_bytes[j]){\n', '                    return false;\n', '                } \n', '            }\n', '        }\n', '\n', '        gods_name[god_address].god_name = new_name;\n', '        emit set_name(god_address, new_name);\n', '        return true;\n', '    }\n', '    event set_name (address indexed god_address, string new_name);\n', '\n', '\n', '    function get_god_name (address god_address) public view returns (string) {\n', '        return gods_name[god_address].god_name;\n', '    }\n', '\n', '    function block_god_name (address god_address, uint block_duration) public {\n', '        require (msg.sender == admin);\n', '        gods_name[god_address].god_name = "Unkown";\n', '        gods_name[god_address].block_number = block.number;\n', '        gods_name[god_address].block_duration = block_duration;\n', '    }\n', '    \n', '    function add (uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '}']