['/*\n', '    The MIT License (MIT)\n', '\n', '    Copyright 2017 - 2018, Alchemy Limited, LLC and Smart Contract Solutions.\n', '\n', '    Permission is hereby granted, free of charge, to any person obtaining\n', '    a copy of this software and associated documentation files (the\n', '    "Software"), to deal in the Software without restriction, including\n', '    without limitation the rights to use, copy, modify, merge, publish,\n', '    distribute, sublicense, and/or sell copies of the Software, and to\n', '    permit persons to whom the Software is furnished to do so, subject to\n', '    the following conditions:\n', '\n', '    The above copyright notice and this permission notice shall be included\n', '    in all copies or substantial portions of the Software.\n', '\n', '    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', '    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', '    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', '    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', '    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', '    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', '    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', '*/\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * Reference: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' *\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '/* end SafeMath library */\n', '\n', '\n', '/// @title Math operation when both numbers has decimal places.\n', '/// @notice Use this contract when both numbers has 18 decimal places. \n', 'contract FixedMath {\n', '    \n', '    using SafeMath for uint;\n', '    uint constant internal METDECIMALS = 18;\n', '    uint constant internal METDECMULT = 10 ** METDECIMALS;\n', '    uint constant internal DECIMALS = 18;\n', '    uint constant internal DECMULT = 10 ** DECIMALS;\n', '\n', '    /// @notice Multiplication.\n', '    function fMul(uint x, uint y) internal pure returns (uint) {\n', '        return (x.mul(y)).div(DECMULT);\n', '    }\n', '\n', '    /// @notice Division.\n', '    function fDiv(uint numerator, uint divisor) internal pure returns (uint) {\n', '        return (numerator.mul(DECMULT)).div(divisor);\n', '    }\n', '\n', '    /// @notice Square root.\n', '    /// @dev Reference: https://stackoverflow.com/questions/3766020/binary-search-to-compute-square-root-java\n', '    function fSqrt(uint n) internal pure returns (uint) {\n', '        if (n == 0) {\n', '            return 0;\n', '        }\n', '        uint z = n * n;\n', '        require(z / n == n);\n', '\n', '        uint high = fAdd(n, DECMULT);\n', '        uint low = 0;\n', '        while (fSub(high, low) > 1) {\n', '            uint mid = fAdd(low, high) / 2;\n', '            if (fSqr(mid) <= n) {\n', '                low = mid;\n', '            } else {\n', '                high = mid;\n', '            }\n', '        }\n', '        return low;\n', '    }\n', '\n', '    /// @notice Square.\n', '    function fSqr(uint n) internal pure returns (uint) {\n', '        return fMul(n, n);\n', '    }\n', '\n', '    /// @notice Add.\n', '    function fAdd(uint x, uint y) internal pure returns (uint) {\n', '        return x.add(y);\n', '    }\n', '\n', '    /// @notice Sub.\n', '    function fSub(uint x, uint y) internal pure returns (uint) {\n', '        return x.sub(y);\n', '    }\n', '}\n', '\n', '\n', '/// @title A formula contract for converter\n', 'contract Formula is FixedMath {\n', '\n', '    /// @notice Trade in reserve(ETH/MET) and mint new smart tokens\n', '    /// @param smartTokenSupply Total supply of smart token\n', '    /// @param reserveTokensSent Amount of token sent by caller\n', '    /// @param reserveTokenBalance Balance of reserve token in the contract\n', '    /// @return Smart token minted\n', '    function returnForMint(uint smartTokenSupply, uint reserveTokensSent, uint reserveTokenBalance) \n', '        internal pure returns (uint)\n', '    {\n', '        uint s = smartTokenSupply;\n', '        uint e = reserveTokensSent;\n', '        uint r = reserveTokenBalance;\n', '        /// smartToken for mint(T) = S * (sqrt(1 + E/R) - 1)\n', '        /// DECMULT is same as 1 for values with 18 decimal places\n', '        return ((fMul(s, (fSub(fSqrt(fAdd(DECMULT, fDiv(e, r))), DECMULT)))).mul(METDECMULT)).div(DECMULT);\n', '    }\n', '\n', '    /// @notice Redeem smart tokens, get back reserve(ETH/MET) token\n', '    /// @param smartTokenSupply Total supply of smart token\n', '    /// @param smartTokensSent Smart token sent\n', '    /// @param reserveTokenBalance Balance of reserve token in the contract\n', '    /// @return Reserve token redeemed\n', '    function returnForRedemption(uint smartTokenSupply, uint smartTokensSent, uint reserveTokenBalance)\n', '        internal pure returns (uint)\n', '    {\n', '        uint s = smartTokenSupply;\n', '        uint t = smartTokensSent;\n', '        uint r = reserveTokenBalance;\n', '        /// reserveToken (E) = R * (1 - (1 - T/S)**2)\n', '        /// DECMULT is same as 1 for values with 18 decimal places\n', '        return ((fMul(r, (fSub(DECMULT, fSqr(fSub(DECMULT, fDiv(t, s))))))).mul(METDECMULT)).div(DECMULT);\n', '    }\n', '}\n', '\n', '\n', '/// @title Pricer contract to calculate descending price during auction.\n', 'contract Pricer {\n', '\n', '    using SafeMath for uint;\n', '    uint constant internal METDECIMALS = 18;\n', '    uint constant internal METDECMULT = 10 ** METDECIMALS;\n', '    uint public minimumPrice = 33*10**11;\n', '    uint public minimumPriceInDailyAuction = 1;\n', '\n', '    uint public tentimes;\n', '    uint public hundredtimes;\n', '    uint public thousandtimes;\n', '\n', '    uint constant public MULTIPLIER = 1984320568*10**5;\n', '\n', '    /// @notice Pricer constructor, calculate 10, 100 and 1000 times of 0.99.\n', '    function initPricer() public {\n', '        uint x = METDECMULT;\n', '        uint i;\n', '        \n', '        /// Calculate 10 times of 0.99\n', '        for (i = 0; i < 10; i++) {\n', '            x = x.mul(99).div(100);\n', '        }\n', '        tentimes = x;\n', '        x = METDECMULT;\n', '\n', '        /// Calculate 100 times of 0.99 using tentimes calculated above.\n', '        /// tentimes has 18 decimal places and due to this METDECMLT is\n', '        /// used as divisor.\n', '        for (i = 0; i < 10; i++) {\n', '            x = x.mul(tentimes).div(METDECMULT);\n', '        }\n', '        hundredtimes = x;\n', '        x = METDECMULT;\n', '\n', '        /// Calculate 1000 times of 0.99 using hundredtimes calculated above.\n', '        /// hundredtimes has 18 decimal places and due to this METDECMULT is\n', '        /// used as divisor.\n', '        for (i = 0; i < 10; i++) {\n', '            x = x.mul(hundredtimes).div(METDECMULT);\n', '        }\n', '        thousandtimes = x;\n', '    }\n', '\n', '    /// @notice Price of MET at nth minute out during operational auction\n', '    /// @param initialPrice The starting price ie last purchase price\n', '    /// @param _n The number of minutes passed since last purchase\n', '    /// @return The resulting price\n', '    function priceAt(uint initialPrice, uint _n) public view returns (uint price) {\n', '        uint mult = METDECMULT;\n', '        uint i;\n', '        uint n = _n;\n', '\n', '        /// If quotient of n/1000 is greater than 0 then calculate multiplier by\n', '        /// multiplying thousandtimes and mult in a loop which runs quotient times.\n', '        /// Also assign new value to n which is remainder of n/1000.\n', '        if (n / 1000 > 0) {\n', '            for (i = 0; i < n / 1000; i++) {\n', '                mult = mult.mul(thousandtimes).div(METDECMULT);\n', '            }\n', '            n = n % 1000;\n', '        }\n', '\n', '        /// If quotient of n/100 is greater than 0 then calculate multiplier by\n', '        /// multiplying hundredtimes and mult in a loop which runs quotient times.\n', '        /// Also assign new value to n which is remainder of n/100.\n', '        if (n / 100 > 0) {\n', '            for (i = 0; i < n / 100; i++) {\n', '                mult = mult.mul(hundredtimes).div(METDECMULT);\n', '            }\n', '            n = n % 100;\n', '        }\n', '\n', '        /// If quotient of n/10 is greater than 0 then calculate multiplier by\n', '        /// multiplying tentimes and mult in a loop which runs quotient times.\n', '        /// Also assign new value to n which is remainder of n/10.\n', '        if (n / 10 > 0) {\n', '            for (i = 0; i < n / 10; i++) {\n', '                mult = mult.mul(tentimes).div(METDECMULT);\n', '            }\n', '            n = n % 10;\n', '        }\n', '\n', '        /// Calculate multiplier by multiplying 0.99 and mult, repeat it n times.\n', '        for (i = 0; i < n; i++) {\n', '            mult = mult.mul(99).div(100);\n', '        }\n', '\n', '        /// price is calculated as initialPrice multiplied by 0.99 and that too _n times.\n', '        /// Here mult is METDECMULT multiplied by 0.99 and that too _n times.\n', '        price = initialPrice.mul(mult).div(METDECMULT);\n', '        \n', '        if (price < minimumPriceInDailyAuction) {\n', '            price = minimumPriceInDailyAuction;\n', '        }\n', '    }\n', '\n', '    /// @notice Price of MET at nth minute during initial auction.\n', '    /// @param lastPurchasePrice The price of MET in last transaction\n', '    /// @param numTicks The number of minutes passed since last purchase\n', '    /// @return The resulting price\n', '    function priceAtInitialAuction(uint lastPurchasePrice, uint numTicks) public view returns (uint price) {\n', '        /// Price will decrease linearly every minute by the factor of MULTIPLIER.\n', '        /// If lastPurchasePrice is greater than decrease in price then calculated the price.\n', '        /// Return minimumPrice, if calculated price is less than minimumPrice.\n', '        /// If decrease in price is more than lastPurchasePrice then simply return the minimumPrice.\n', '        if (lastPurchasePrice > MULTIPLIER.mul(numTicks)) {\n', '            price = lastPurchasePrice.sub(MULTIPLIER.mul(numTicks));\n', '        }\n', '\n', '        if (price < minimumPrice) {\n', '            price = minimumPrice;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @dev Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '/// @notice ERC20 standard interface\n', 'interface ERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '}\n', '\n', '\n', '/// @title Ownable\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '    event OwnershipChanged(address indexed prevOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param _newOwner \n', '    /// @return true/false\n', '    function changeOwnership(address _newOwner) public onlyOwner returns (bool) {\n', '        require(_newOwner != address(0));\n', '        require(_newOwner != owner);\n', '        emit OwnershipChanged(owner, _newOwner);\n', '        owner = _newOwner;\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/// @title Owned\n', 'contract Owned is Ownable {\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '    /// @param _newOwner \n', '    /// @return true/false\n', '    function changeOwnership(address _newOwner) public onlyOwner returns (bool) {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows the new owner to accept ownership of the contract.\n', '    /// @return true/false\n', '    function acceptOwnership() public returns (bool) {\n', '        require(msg.sender == newOwner);\n', '\n', '        emit OwnershipChanged(owner, newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/// @title Mintable contract to allow minting and destroy.\n', 'contract Mintable is Owned {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    event Mint(address indexed _to, uint _value);\n', '    event Destroy(address indexed _from, uint _value);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    uint256 internal _totalSupply;\n', '    mapping(address => uint256) internal _balanceOf;\n', '\n', '    address public autonomousConverter;\n', '    address public minter;\n', '    ITokenPorter public tokenPorter;\n', '\n', '    /// @notice init reference of other contract and initial supply\n', '    /// @param _autonomousConverter \n', '    /// @param _minter \n', '    /// @param _initialSupply \n', '    /// @param _decmult Decimal places\n', '    function initMintable(address _autonomousConverter, address _minter, uint _initialSupply, \n', '        uint _decmult) public onlyOwner {\n', '        require(autonomousConverter == 0x0 && _autonomousConverter != 0x0);\n', '        require(minter == 0x0 && _minter != 0x0);\n', '      \n', '        autonomousConverter = _autonomousConverter;\n', '        minter = _minter;\n', '        _totalSupply = _initialSupply.mul(_decmult);\n', '        _balanceOf[_autonomousConverter] = _totalSupply;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256) {\n', '        return _balanceOf[_owner];\n', '    }\n', '\n', '    /// @notice set address of token porter\n', '    /// @param _tokenPorter address of token porter\n', '    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {\n', '        require(_tokenPorter != 0x0);\n', '\n', '        tokenPorter = ITokenPorter(_tokenPorter);\n', '        return true;\n', '    }\n', '\n', '    /// @notice allow minter and tokenPorter to mint token and assign to address\n', '    /// @param _to \n', '    /// @param _value Amount to be minted  \n', '    function mint(address _to, uint _value) public returns (bool) {\n', '        require(msg.sender == minter || msg.sender == address(tokenPorter));\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '        _totalSupply = _totalSupply.add(_value);\n', '        emit Mint(_to, _value);\n', '        emit Transfer(0x0, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice allow autonomousConverter and tokenPorter to mint token and assign to address\n', '    /// @param _from \n', '    /// @param _value Amount to be destroyed\n', '    function destroy(address _from, uint _value) public returns (bool) {\n', '        require(msg.sender == autonomousConverter || msg.sender == address(tokenPorter));\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Destroy(_from, _value);\n', '        emit Transfer(_from, 0x0, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/// @title Token contract\n', 'contract Token is ERC20, Mintable {\n', '    mapping(address => mapping(address => uint256)) internal _allowance;\n', '\n', '    function initToken(address _autonomousConverter, address _minter,\n', '     uint _initialSupply, uint _decmult) public onlyOwner {\n', '        initMintable(_autonomousConverter, _minter, _initialSupply, _decmult);\n', '    }\n', '\n', '    /// @notice Provide allowance information\n', '    function allowance(address _owner, address _spender) public constant returns (uint256) {\n', '        return _allowance[_owner][_spender];\n', '    }\n', '\n', '    /// @notice Transfer tokens from sender to the provided address.\n', '    /// @param _to Receiver of the tokens\n', '    /// @param _value Amount of token\n', '    /// @return true/false\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(_to != minter);\n', '        require(_to != address(this));\n', '        require(_to != autonomousConverter);\n', '        Proceeds proceeds = Auctions(minter).proceeds();\n', '        require((_to != address(proceeds)));\n', '\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer tokens based on allowance.\n', '    /// msg.sender must have allowance for spending the tokens from owner ie _from\n', '    /// @param _from Owner of the tokens\n', '    /// @param _to Receiver of the tokens\n', '    /// @param _value Amount of tokens to transfer\n', '    /// @return true/false\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { \n', '        require(_to != address(0));       \n', '        require(_to != minter && _from != minter);\n', '        require(_to != address(this) && _from != address(this));\n', '        Proceeds proceeds = Auctions(minter).proceeds();\n', '        require(_to != address(proceeds) && _from != address(proceeds));\n', '        //AC can accept MET via this function, needed for MetToEth conversion\n', '        require(_from != autonomousConverter);\n', '        require(_allowance[_from][msg.sender] >= _value);\n', '        \n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approve spender to spend the tokens ie approve allowance\n', '    /// @param _spender Spender of the tokens\n', '    /// @param _value Amount of tokens that can be spent by spender\n', '    /// @return true/false\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(_spender != address(this));\n', '        _allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer the tokens from sender to all the address provided in the array.\n', '    /// @dev Left 160 bits are the recipient address and the right 96 bits are the token amount.\n', '    /// @param bits array of uint\n', '    /// @return true/false\n', '    function multiTransfer(uint[] bits) public returns (bool) {\n', '        for (uint i = 0; i < bits.length; i++) {\n', '            address a = address(bits[i] >> 96);\n', '            uint amount = bits[i] & ((1 << 96) - 1);\n', '            if (!transfer(a, amount)) revert();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Increase allowance of spender\n', '    /// @param _spender Spender of the tokens\n', '    /// @param _value Amount of tokens that can be spent by spender\n', '    /// @return true/false\n', '    function approveMore(address _spender, uint256 _value) public returns (bool) {\n', '        uint previous = _allowance[msg.sender][_spender];\n', '        uint newAllowance = previous.add(_value);\n', '        _allowance[msg.sender][_spender] = newAllowance;\n', '        emit Approval(msg.sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Decrease allowance of spender\n', '    /// @param _spender Spender of the tokens\n', '    /// @param _value Amount of tokens that can be spent by spender\n', '    /// @return true/false\n', '    function approveLess(address _spender, uint256 _value) public returns (bool) {\n', '        uint previous = _allowance[msg.sender][_spender];\n', '        uint newAllowance = previous.sub(_value);\n', '        _allowance[msg.sender][_spender] = newAllowance;\n', '        emit Approval(msg.sender, _spender, newAllowance);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/// @title  Smart tokens are an intermediate token generated during conversion of MET-ETH\n', 'contract SmartToken is Mintable {\n', '    uint constant internal METDECIMALS = 18;\n', '    uint constant internal METDECMULT = 10 ** METDECIMALS;\n', '\n', '    function initSmartToken(address _autonomousConverter, address _minter, uint _initialSupply) public  onlyOwner {\n', '        initMintable(_autonomousConverter, _minter, _initialSupply, METDECMULT); \n', '    }\n', '}\n', '\n', '\n', '/// @title ERC20 token. Metronome token \n', 'contract METToken is Token {\n', '\n', '    string public constant name = "Metronome";\n', '    string public constant symbol = "MET";\n', '    uint8 public constant decimals = 18;\n', '\n', '    bool public transferAllowed;\n', '\n', '    function initMETToken(address _autonomousConverter, address _minter, \n', '        uint _initialSupply, uint _decmult) public onlyOwner {\n', '        initToken(_autonomousConverter, _minter, _initialSupply, _decmult);\n', '    }\n', '    \n', '    /// @notice Transferable modifier to allow transfer only after initial auction ended.\n', '    modifier transferable() {\n', '        require(transferAllowed);\n', '        _;\n', '    }\n', '\n', '    function enableMETTransfers() public returns (bool) {\n', '        require(!transferAllowed && Auctions(minter).isInitialAuctionEnded());\n', '        transferAllowed = true; \n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer tokens from caller to another address\n', '    /// @param _to address The address which you want to transfer to\n', '    /// @param _value uint256 the amout of tokens to be transfered\n', '    function transfer(address _to, uint256 _value) public transferable returns (bool) {\n', '        return super.transfer(_to, _value);\n', '        \n', '    }\n', '\n', '    /// @notice Transfer tokens from one address to another\n', '    /// @param _from address The address from which you want to transfer\n', '    /// @param _to address The address which you want to transfer to\n', '    /// @param _value uint256 the amout of tokens to be transfered\n', '    function transferFrom(address _from, address _to, uint256 _value) public transferable returns (bool) {        \n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice Transfer the token from sender to all the addresses provided in array.\n', '    /// @dev Left 160 bits are the recipient address and the right 96 bits are the token amount.\n', '    /// @param bits array of uint\n', '    /// @return true/false\n', '    function multiTransfer(uint[] bits) public transferable returns (bool) {\n', '        return super.multiTransfer(bits);\n', '    }\n', '    \n', '    mapping (address => bytes32) public roots;\n', '\n', '    function setRoot(bytes32 data) public {\n', '        roots[msg.sender] = data;\n', '    }\n', '\n', '    function getRoot(address addr) public view returns (bytes32) {\n', '        return roots[addr];\n', '    }\n', '\n', '    function rootsMatch(address a, address b) public view returns (bool) {\n', '        return roots[a] == roots[b];\n', '    }\n', '\n', '    /// @notice import MET tokens from another chain to this chain.\n', '    /// @param _destinationChain destination chain name\n', '    /// @param _addresses _addresses[0] is destMetronomeAddr and _addresses[1] is recipientAddr\n', '    /// @param _extraData extra information for import\n', '    /// @param _burnHashes _burnHashes[0] is previous burnHash, _burnHashes[1] is current burnHash\n', '    /// @param _supplyOnAllChains MET supply on all supported chains\n', '    /// @param _importData _importData[0] is _blockTimestamp, _importData[1] is _amount, _importData[2] is _fee\n', '    /// _importData[3] is _burnedAtTick, _importData[4] is _genesisTime, _importData[5] is _dailyMintable\n', '    /// _importData[6] is _burnSequence, _importData[7] is _dailyAuctionStartTime\n', '    /// @param _proof proof\n', '    /// @return true/false\n', '    function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData, \n', '        bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool)\n', '    {\n', '        require(address(tokenPorter) != 0x0);\n', '        return tokenPorter.importMET(_originChain, _destinationChain, _addresses, _extraData, \n', '        _burnHashes, _supplyOnAllChains, _importData, _proof);\n', '    }\n', '\n', '    /// @notice export MET tokens from this chain to another chain.\n', '    /// @param _destChain destination chain address\n', '    /// @param _destMetronomeAddr address of Metronome contract on the destination chain \n', '    /// where this MET will be imported.\n', '    /// @param _destRecipAddr address of account on destination chain\n', '    /// @param _amount amount\n', '    /// @param _extraData extra information for future expansion\n', '    /// @return true/false\n', '    function export(bytes8 _destChain, address _destMetronomeAddr, address _destRecipAddr, uint _amount, uint _fee, \n', '    bytes _extraData) public returns (bool)\n', '    {\n', '        require(address(tokenPorter) != 0x0);\n', '        return tokenPorter.export(msg.sender, _destChain, _destMetronomeAddr,\n', '        _destRecipAddr, _amount, _fee, _extraData);\n', '    }\n', '\n', '    struct Sub {\n', '        uint startTime;      \n', '        uint payPerWeek; \n', '        uint lastWithdrawTime;\n', '    }\n', '\n', '    event LogSubscription(address indexed subscriber, address indexed subscribesTo);\n', '    event LogCancelSubscription(address indexed subscriber, address indexed subscribesTo);\n', '\n', '    mapping (address => mapping (address => Sub)) public subs;\n', '\n', '    /// @notice subscribe for a weekly recurring payment \n', '    /// @param _startTime Subscription start time.\n', '    /// @param _payPerWeek weekly payment\n', '    /// @param _recipient address of beneficiary\n', '    /// @return true/false\n', '    function subscribe(uint _startTime, uint _payPerWeek, address _recipient) public returns (bool) {\n', '        require(_startTime >= block.timestamp);\n', '        require(_payPerWeek != 0);\n', '        require(_recipient != 0);\n', '\n', '        subs[msg.sender][_recipient] = Sub(_startTime, _payPerWeek, _startTime);  \n', '        \n', '        emit LogSubscription(msg.sender, _recipient);\n', '        return true;\n', '    }\n', '\n', '    /// @notice cancel a subcription. \n', '    /// @param _recipient address of beneficiary\n', '    /// @return true/false\n', '    function cancelSubscription(address _recipient) public returns (bool) {\n', '        require(subs[msg.sender][_recipient].startTime != 0);\n', '        require(subs[msg.sender][_recipient].payPerWeek != 0);\n', '\n', '        subs[msg.sender][_recipient].startTime = 0;\n', '        subs[msg.sender][_recipient].payPerWeek = 0;\n', '        subs[msg.sender][_recipient].lastWithdrawTime = 0;\n', '\n', '        emit LogCancelSubscription(msg.sender, _recipient);\n', '        return true;\n', '    }\n', '\n', '    /// @notice get subcription details\n', '    /// @param _owner \n', '    /// @param _recipient \n', '    /// @return startTime, payPerWeek, lastWithdrawTime\n', '    function getSubscription(address _owner, address _recipient) public constant\n', '        returns (uint startTime, uint payPerWeek, uint lastWithdrawTime) \n', '    {\n', '        Sub storage sub = subs[_owner][_recipient];\n', '        return (\n', '            sub.startTime,\n', '            sub.payPerWeek,\n', '            sub.lastWithdrawTime\n', '        );\n', '    }\n', '\n', '    /// @notice caller can withdraw the token from subscribers.\n', '    /// @param _owner subcriber\n', '    /// @return true/false\n', '    function subWithdraw(address _owner) public transferable returns (bool) {\n', '        require(subWithdrawFor(_owner, msg.sender));\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allow callers to withdraw token in one go from all of its subscribers\n', '    /// @param _owners array of address of subscribers\n', '    /// @return number of successful transfer done\n', '    function multiSubWithdraw(address[] _owners) public returns (uint) {\n', '        uint n = 0;\n', '        for (uint i=0; i < _owners.length; i++) {\n', '            if (subWithdrawFor(_owners[i], msg.sender)) {\n', '                n++;\n', '            } \n', '        }\n', '        return n;\n', '    }\n', '\n', '    /// @notice Trigger MET token transfers for all pairs of subscribers and beneficiaries\n', '    /// @dev address at i index in owners and recipients array is subcriber-beneficiary pair.\n', '    /// @param _owners \n', '    /// @param _recipients \n', '    /// @return number of successful transfer done\n', '    function multiSubWithdrawFor(address[] _owners, address[] _recipients) public returns (uint) {\n', '        // owners and recipients need 1-to-1 mapping, must be same length\n', '        require(_owners.length == _recipients.length);\n', '\n', '        uint n = 0;\n', '        for (uint i = 0; i < _owners.length; i++) {\n', '            if (subWithdrawFor(_owners[i], _recipients[i])) {\n', '                n++;\n', '            }\n', '        }\n', '\n', '        return n;\n', '    }\n', '\n', '    function subWithdrawFor(address _from, address _to) internal returns (bool) {\n', '        Sub storage sub = subs[_from][_to];\n', '        \n', '        if (sub.startTime > 0 && sub.startTime < block.timestamp && sub.payPerWeek > 0) {\n', '            uint weekElapsed = (now.sub(sub.lastWithdrawTime)).div(7 days);\n', '            uint amount = weekElapsed.mul(sub.payPerWeek);\n', '            if (weekElapsed > 0 && _balanceOf[_from] >= amount) {\n', '                subs[_from][_to].lastWithdrawTime = block.timestamp;\n', '                _balanceOf[_from] = _balanceOf[_from].sub(amount);\n', '                _balanceOf[_to] = _balanceOf[_to].add(amount);\n', '                emit Transfer(_from, _to, amount);\n', '                return true;\n', '            }\n', '        }       \n', '        return false;\n', '    }\n', '}\n', '\n', '\n', '/// @title Autonomous Converter contract for MET <=> ETH exchange\n', 'contract AutonomousConverter is Formula, Owned {\n', '\n', '    SmartToken public smartToken;\n', '    METToken public reserveToken;\n', '    Auctions public auctions;\n', '\n', '    enum WhichToken { Eth, Met }\n', '    bool internal initialized = false;\n', '\n', '    event LogFundsIn(address indexed from, uint value);\n', '    event ConvertEthToMet(address indexed from, uint eth, uint met);\n', '    event ConvertMetToEth(address indexed from, uint eth, uint met);\n', '\n', '    function init(address _reserveToken, address _smartToken, address _auctions) \n', '        public onlyOwner payable \n', '    {\n', '        require(!initialized);\n', '        auctions = Auctions(_auctions);\n', '        reserveToken = METToken(_reserveToken);\n', '        smartToken = SmartToken(_smartToken);\n', '        initialized = true;\n', '    }\n', '\n', '    function handleFund() public payable {\n', '        require(msg.sender == address(auctions.proceeds()));\n', '        emit LogFundsIn(msg.sender, msg.value);\n', '    }\n', '\n', '    function getMetBalance() public view returns (uint) {\n', '        return balanceOf(WhichToken.Met);\n', '    }\n', '\n', '    function getEthBalance() public view returns (uint) {\n', '        return balanceOf(WhichToken.Eth);\n', '    }\n', '\n', '    /// @notice return the expected MET for ETH\n', '    /// @param _depositAmount ETH.\n', '    /// @return expected MET value for ETH\n', '    function getMetForEthResult(uint _depositAmount) public view returns (uint256) {\n', '        return convertingReturn(WhichToken.Eth, _depositAmount);\n', '    }\n', '\n', '    /// @notice return the expected ETH for MET\n', '    /// @param _depositAmount MET.\n', '    /// @return expected ETH value for MET\n', '    function getEthForMetResult(uint _depositAmount) public view returns (uint256) {\n', '        return convertingReturn(WhichToken.Met, _depositAmount);\n', '    }\n', '\n', '    /// @notice send ETH and get MET\n', '    /// @param _mintReturn execute conversion only if return is equal or more than _mintReturn\n', '    /// @return returnedMet MET retured after conversion\n', '    function convertEthToMet(uint _mintReturn) public payable returns (uint returnedMet) {\n', '        returnedMet = convert(WhichToken.Eth, _mintReturn, msg.value);\n', '        emit ConvertEthToMet(msg.sender, msg.value, returnedMet);\n', '    }\n', '\n', '    /// @notice send MET and get ETH\n', '    /// @dev Caller will be required to approve the AutonomousConverter to initiate the transfer\n', '    /// @param _amount MET amount\n', '    /// @param _mintReturn execute conversion only if return is equal or more than _mintReturn\n', '    /// @return returnedEth ETh returned after conversion\n', '    function convertMetToEth(uint _amount, uint _mintReturn) public returns (uint returnedEth) {\n', '        returnedEth = convert(WhichToken.Met, _mintReturn, _amount);\n', '        emit ConvertMetToEth(msg.sender, returnedEth, _amount);\n', '    }\n', '\n', '    function balanceOf(WhichToken which) internal view returns (uint) {\n', '        if (which == WhichToken.Eth) return address(this).balance;\n', '        if (which == WhichToken.Met) return reserveToken.balanceOf(this);\n', '        revert();\n', '    }\n', '\n', '    function convertingReturn(WhichToken whichFrom, uint _depositAmount) internal view returns (uint256) {\n', '        \n', '        WhichToken to = WhichToken.Met;\n', '        if (whichFrom == WhichToken.Met) {\n', '            to = WhichToken.Eth;\n', '        }\n', '\n', '        uint reserveTokenBalanceFrom = balanceOf(whichFrom).add(_depositAmount);\n', '        uint mintRet = returnForMint(smartToken.totalSupply(), _depositAmount, reserveTokenBalanceFrom);\n', '        \n', '        uint newSmartTokenSupply = smartToken.totalSupply().add(mintRet);\n', '        uint reserveTokenBalanceTo = balanceOf(to);\n', '        return returnForRedemption(\n', '            newSmartTokenSupply,\n', '            mintRet,\n', '            reserveTokenBalanceTo);\n', '    }\n', '\n', '    function convert(WhichToken whichFrom, uint _minReturn, uint amnt) internal returns (uint) {\n', '        WhichToken to = WhichToken.Met;\n', '        if (whichFrom == WhichToken.Met) {\n', '            to = WhichToken.Eth;\n', '            require(reserveToken.transferFrom(msg.sender, this, amnt));\n', '        }\n', '\n', '        uint mintRet = mint(whichFrom, amnt, 1);\n', '        \n', '        return redeem(to, mintRet, _minReturn);\n', '    }\n', '\n', '    function mint(WhichToken which, uint _depositAmount, uint _minReturn) internal returns (uint256 amount) {\n', '        require(_minReturn > 0);\n', '\n', '        amount = mintingReturn(which, _depositAmount);\n', '        require(amount >= _minReturn);\n', '        require(smartToken.mint(msg.sender, amount));\n', '    }\n', '\n', '    function mintingReturn(WhichToken which, uint _depositAmount) internal view returns (uint256) {\n', '        uint256 smartTokenSupply = smartToken.totalSupply();\n', '        uint256 reserveBalance = balanceOf(which);\n', '        return returnForMint(smartTokenSupply, _depositAmount, reserveBalance);\n', '    }\n', '\n', '    function redeem(WhichToken which, uint _amount, uint _minReturn) internal returns (uint redeemable) {\n', '        require(_amount <= smartToken.balanceOf(msg.sender));\n', '        require(_minReturn > 0);\n', '\n', '        redeemable = redemptionReturn(which, _amount);\n', '        require(redeemable >= _minReturn);\n', '\n', '        uint256 reserveBalance = balanceOf(which);\n', '        require(reserveBalance >= redeemable);\n', '\n', '        uint256 tokenSupply = smartToken.totalSupply();\n', '        require(_amount < tokenSupply);\n', '\n', '        smartToken.destroy(msg.sender, _amount);\n', '        if (which == WhichToken.Eth) {\n', '            msg.sender.transfer(redeemable);\n', '        } else {\n', '            require(reserveToken.transfer(msg.sender, redeemable));\n', '        }\n', '    }\n', '\n', '    function redemptionReturn(WhichToken which, uint smartTokensSent) internal view returns (uint256) {\n', '        uint smartTokenSupply = smartToken.totalSupply();\n', '        uint reserveTokenBalance = balanceOf(which);\n', '        return returnForRedemption(\n', '            smartTokenSupply,\n', '            smartTokensSent,\n', '            reserveTokenBalance);\n', '    }\n', '}\n', '\n', '\n', '/// @title Proceeds contract\n', 'contract Proceeds is Owned {\n', '    using SafeMath for uint256;\n', '\n', '    AutonomousConverter public autonomousConverter;\n', '    Auctions public auctions;\n', '    event LogProceedsIn(address indexed from, uint value); \n', '    event LogClosedAuction(address indexed from, uint value);\n', '    uint latestAuctionClosed;\n', '\n', '    function initProceeds(address _autonomousConverter, address _auctions) public onlyOwner {\n', '        require(address(auctions) == 0x0 && _auctions != 0x0);\n', '        require(address(autonomousConverter) == 0x0 && _autonomousConverter != 0x0);\n', '\n', '        autonomousConverter = AutonomousConverter(_autonomousConverter);\n', '        auctions = Auctions(_auctions);\n', '    }\n', '\n', '    function handleFund() public payable {\n', '        require(msg.sender == address(auctions));\n', '        emit LogProceedsIn(msg.sender, msg.value);\n', '    }\n', '\n', '    /// @notice Forward 0.25% of total ETH balance of proceeds to AutonomousConverter contract\n', '    function closeAuction() public {\n', '        uint lastPurchaseTick = auctions.lastPurchaseTick();\n', '        uint currentAuction = auctions.currentAuction();\n', '        uint val = ((address(this).balance).mul(25)).div(10000); \n', '        if (val > 0 && (currentAuction > auctions.whichAuction(lastPurchaseTick)) \n', '            && (latestAuctionClosed < currentAuction)) {\n', '            latestAuctionClosed = currentAuction;\n', '            autonomousConverter.handleFund.value(val)();\n', '            emit LogClosedAuction(msg.sender, val);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @title Auction contract. Send ETH to the contract address and buy MET. \n', 'contract Auctions is Pricer, Owned {\n', '\n', '    using SafeMath for uint256;\n', '    METToken public token;\n', '    Proceeds public proceeds;\n', '    address[] public founders;\n', '    mapping(address => TokenLocker) public tokenLockers;\n', '    uint internal constant DAY_IN_SECONDS = 86400;\n', '    uint internal constant DAY_IN_MINUTES = 1440;\n', '    uint public genesisTime;\n', '    uint public lastPurchaseTick;\n', '    uint public lastPurchasePrice;\n', '    uint public constant INITIAL_GLOBAL_DAILY_SUPPLY = 2880 * METDECMULT;\n', '    uint public INITIAL_FOUNDER_SUPPLY = 1999999 * METDECMULT;\n', '    uint public INITIAL_AC_SUPPLY = 1 * METDECMULT;\n', '    uint public totalMigratedOut = 0;\n', '    uint public totalMigratedIn = 0;\n', '    uint public timeScale = 1;\n', '    uint public constant INITIAL_SUPPLY = 10000000 * METDECMULT;\n', '    uint public mintable = INITIAL_SUPPLY;\n', '    uint public initialAuctionDuration = 7 days;\n', '    uint public initialAuctionEndTime;\n', '    uint public dailyAuctionStartTime;\n', '    uint public constant DAILY_PURCHASE_LIMIT = 1000 ether;\n', '    mapping (address => uint) internal purchaseInTheAuction;\n', '    mapping (address => uint) internal lastPurchaseAuction;\n', '    bool public minted;\n', '    bool public initialized;\n', '    uint public globalSupplyAfterPercentageLogic = 52598080 * METDECMULT;\n', '    uint public constant AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS = 14791;\n', '    bytes8 public chain = "ETH";\n', '    event LogAuctionFundsIn(address indexed sender, uint amount, uint tokens, uint purchasePrice, uint refund);\n', '\n', '    function Auctions() public {\n', '        mintable = INITIAL_SUPPLY - 2000000 * METDECMULT;\n', '    }\n', '\n', '    /// @notice Payable function to buy MET in descending price auction\n', '    function () public payable running {\n', '        require(msg.value > 0);\n', '        \n', '        uint amountForPurchase = msg.value;\n', '        uint excessAmount;\n', '\n', '        if (currentAuction() > whichAuction(lastPurchaseTick)) {\n', '            proceeds.closeAuction();\n', '            restartAuction();\n', '        }\n', '\n', '        if (isInitialAuctionEnded()) {\n', '            require(now >= dailyAuctionStartTime);\n', '            if (lastPurchaseAuction[msg.sender] < currentAuction()) {\n', '                if (amountForPurchase > DAILY_PURCHASE_LIMIT) {\n', '                    excessAmount = amountForPurchase.sub(DAILY_PURCHASE_LIMIT);\n', '                    amountForPurchase = DAILY_PURCHASE_LIMIT;\n', '                }           \n', '                purchaseInTheAuction[msg.sender] = msg.value;\n', '                lastPurchaseAuction[msg.sender] = currentAuction();\n', '            } else {\n', '                require(purchaseInTheAuction[msg.sender] < DAILY_PURCHASE_LIMIT);\n', '                if (purchaseInTheAuction[msg.sender].add(amountForPurchase) > DAILY_PURCHASE_LIMIT) {\n', '                    excessAmount = (purchaseInTheAuction[msg.sender].add(amountForPurchase)).sub(DAILY_PURCHASE_LIMIT);\n', '                    amountForPurchase = amountForPurchase.sub(excessAmount);\n', '                }\n', '                purchaseInTheAuction[msg.sender] = purchaseInTheAuction[msg.sender].add(msg.value);\n', '            }\n', '        }\n', '\n', '        uint _currentTick = currentTick();\n', '\n', '        uint weiPerToken;\n', '        uint tokens;\n', '        uint refund;\n', '        (weiPerToken, tokens, refund) = calcPurchase(amountForPurchase, _currentTick);\n', '        require(tokens > 0);\n', '\n', '        if (now < initialAuctionEndTime && (token.totalSupply()).add(tokens) >= INITIAL_SUPPLY) {\n', '            initialAuctionEndTime = now;\n', '            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;\n', '        }\n', '\n', '        lastPurchaseTick = _currentTick;\n', '        lastPurchasePrice = weiPerToken;\n', '\n', '        assert(tokens <= mintable);\n', '        mintable = mintable.sub(tokens);\n', '\n', '        assert(refund <= amountForPurchase);\n', '        uint ethForProceeds = amountForPurchase.sub(refund);\n', '\n', '        proceeds.handleFund.value(ethForProceeds)();\n', '\n', '        require(token.mint(msg.sender, tokens));\n', '\n', '        refund = refund.add(excessAmount);\n', '        if (refund > 0) {\n', '            if (purchaseInTheAuction[msg.sender] > 0) {\n', '                purchaseInTheAuction[msg.sender] = purchaseInTheAuction[msg.sender].sub(refund);\n', '            }\n', '            msg.sender.transfer(refund);\n', '        }\n', '        emit LogAuctionFundsIn(msg.sender, ethForProceeds, tokens, lastPurchasePrice, refund);\n', '    }\n', '\n', '    modifier running() {\n', '        require(isRunning());\n', '        _;\n', '    }\n', '\n', '    function isRunning() public constant returns (bool) {\n', '        return (block.timestamp >= genesisTime && genesisTime > 0);\n', '    }\n', '\n', '    /// @notice current tick(minute) of the metronome clock\n', '    /// @return tick count\n', '    function currentTick() public view returns(uint) {\n', '        return whichTick(block.timestamp);\n', '    }\n', '\n', '    /// @notice current auction\n', '    /// @return auction count \n', '    function currentAuction() public view returns(uint) {\n', '        return whichAuction(currentTick());\n', '    }\n', '\n', '    /// @notice tick count at the timestamp t. \n', '    /// @param t timestamp\n', '    /// @return tick count\n', '    function whichTick(uint t) public view returns(uint) {\n', '        if (genesisTime > t) { \n', '            revert(); \n', '        }\n', '        return (t - genesisTime) * timeScale / 1 minutes;\n', '    }\n', '\n', '    /// @notice Auction count at given the timestamp t\n', '    /// @param t timestamp\n', '    /// @return Auction count\n', '    function whichAuction(uint t) public view returns(uint) {\n', '        if (whichTick(dailyAuctionStartTime) > t) {\n', '            return 0;\n', '        } else {\n', '            return ((t - whichTick(dailyAuctionStartTime)) / DAY_IN_MINUTES) + 1;\n', '        }\n', '    }\n', '\n', '    /// @notice one single function telling everything about Metronome Auction\n', '    function heartbeat() public view returns (\n', '        bytes8 _chain,\n', '        address auctionAddr,\n', '        address convertAddr,\n', '        address tokenAddr,\n', '        uint minting,\n', '        uint totalMET,\n', '        uint proceedsBal,\n', '        uint currTick,\n', '        uint currAuction,\n', '        uint nextAuctionGMT,\n', '        uint genesisGMT,\n', '        uint currentAuctionPrice,\n', '        uint _dailyMintable,\n', '        uint _lastPurchasePrice) {\n', '        _chain = chain;\n', '        convertAddr = proceeds.autonomousConverter();\n', '        tokenAddr = token;\n', '        auctionAddr = this;\n', '        totalMET = token.totalSupply();\n', '        proceedsBal = address(proceeds).balance;\n', '\n', '        currTick = currentTick();\n', '        currAuction = currentAuction();\n', '        if (currAuction == 0) {\n', '            nextAuctionGMT = dailyAuctionStartTime;\n', '        } else {\n', '            nextAuctionGMT = (currAuction * DAY_IN_SECONDS) / timeScale + dailyAuctionStartTime;\n', '        }\n', '        genesisGMT = genesisTime;\n', '\n', '        currentAuctionPrice = currentPrice();\n', '        _dailyMintable = dailyMintable();\n', '        minting = currentMintable();\n', '        _lastPurchasePrice = lastPurchasePrice;\n', '    }\n', '\n', '    /// @notice Skip Initialization and minting if we&#39;re not the OG Metronome\n', '    /// @param _token MET token contract address\n', '    /// @param _proceeds Address of Proceeds contract\n', '    /// @param _genesisTime The block.timestamp when first auction started on OG chain\n', '    /// @param _minimumPrice Nobody can buy tokens for less than this price\n', '    /// @param _startingPrice Start price of MET when first auction starts\n', '    /// @param _timeScale time scale factor for auction. will be always 1 in live environment\n', '    /// @param _chain chain where this contract is being deployed\n', '    /// @param _initialAuctionEndTime  Initial Auction end time in ETH chain. \n', '    function skipInitBecauseIAmNotOg(address _token, address _proceeds, uint _genesisTime, \n', '        uint _minimumPrice, uint _startingPrice, uint _timeScale, bytes8 _chain, \n', '        uint _initialAuctionEndTime) public onlyOwner returns (bool) {\n', '        require(!minted);\n', '        require(!initialized);\n', '        require(_timeScale != 0);\n', '        require(address(token) == 0x0 && _token != 0x0);\n', '        require(address(proceeds) == 0x0 && _proceeds != 0x0);\n', '        initPricer();\n', '\n', '        // minting substitute section\n', '        token = METToken(_token);\n', '        proceeds = Proceeds(_proceeds);\n', '\n', '        INITIAL_FOUNDER_SUPPLY = 0;\n', '        INITIAL_AC_SUPPLY = 0;\n', '        mintable = 0;  // \n', '\n', '        // initial auction substitute section\n', '        genesisTime = _genesisTime;\n', '        initialAuctionEndTime = _initialAuctionEndTime;\n', '\n', '        // if initialAuctionEndTime is midnight, then daily auction will start immediately\n', '        // after initial auction.\n', '        if (initialAuctionEndTime == (initialAuctionEndTime / 1 days) * 1 days) {\n', '            dailyAuctionStartTime = initialAuctionEndTime;\n', '        } else {\n', '            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;\n', '        }\n', '\n', '        lastPurchaseTick = 0;\n', '\n', '        if (_minimumPrice > 0) {\n', '            minimumPrice = _minimumPrice;\n', '        }\n', '\n', '        timeScale = _timeScale;\n', '\n', '        if (_startingPrice > 0) {\n', '            lastPurchasePrice = _startingPrice * 1 ether;\n', '        } else {\n', '            lastPurchasePrice = 2 ether;\n', '        }\n', '        chain = _chain;\n', '        minted = true;\n', '        initialized = true;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Initialize Auctions parameters\n', '    /// @param _startTime The block.timestamp when first auction starts\n', '    /// @param _minimumPrice Nobody can buy tokens for less than this price\n', '    /// @param _startingPrice Start price of MET when first auction starts\n', '    /// @param _timeScale time scale factor for auction. will be always 1 in live environment\n', '    function initAuctions(uint _startTime, uint _minimumPrice, uint _startingPrice, uint _timeScale) \n', '        public onlyOwner returns (bool) \n', '    {\n', '        require(minted);\n', '        require(!initialized);\n', '        require(_timeScale != 0);\n', '        initPricer();\n', '        if (_startTime > 0) { \n', '            genesisTime = (_startTime / (1 minutes)) * (1 minutes) + 60;\n', '        } else {\n', '            genesisTime = block.timestamp + 60 - (block.timestamp % 60);\n', '        }\n', '\n', '        initialAuctionEndTime = genesisTime + initialAuctionDuration;\n', '\n', '        // if initialAuctionEndTime is midnight, then daily auction will start immediately\n', '        // after initial auction.\n', '        if (initialAuctionEndTime == (initialAuctionEndTime / 1 days) * 1 days) {\n', '            dailyAuctionStartTime = initialAuctionEndTime;\n', '        } else {\n', '            dailyAuctionStartTime = ((initialAuctionEndTime / 1 days) + 1) * 1 days;\n', '        }\n', '\n', '        lastPurchaseTick = 0;\n', '\n', '        if (_minimumPrice > 0) {\n', '            minimumPrice = _minimumPrice;\n', '        }\n', '\n', '        timeScale = _timeScale;\n', '\n', '        if (_startingPrice > 0) {\n', '            lastPurchasePrice = _startingPrice * 1 ether;\n', '        } else {\n', '            lastPurchasePrice = 2 ether;\n', '        }\n', '\n', '        for (uint i = 0; i < founders.length; i++) {\n', '            TokenLocker tokenLocker = tokenLockers[founders[i]];\n', '            tokenLocker.lockTokenLocker();\n', '        }\n', '        \n', '        initialized = true;\n', '        return true;\n', '    }\n', '\n', '    function createTokenLocker(address _founder, address _token) public onlyOwner {\n', '        require(_token != 0x0);\n', '        require(_founder != 0x0);\n', '        founders.push(_founder);\n', '        TokenLocker tokenLocker = new TokenLocker(address(this), _token);\n', '        tokenLockers[_founder] = tokenLocker;\n', '        tokenLocker.changeOwnership(_founder);\n', '    }\n', '\n', '    /// @notice Mint initial supply for founder and move to token locker\n', '    /// @param _founders Left 160 bits are the founder address and the right 96 bits are the token amount.\n', '    /// @param _token MET token contract address\n', '    /// @param _proceeds Address of Proceeds contract\n', '    function mintInitialSupply(uint[] _founders, address _token, \n', '        address _proceeds, address _autonomousConverter) public onlyOwner returns (bool) \n', '    {\n', '        require(!minted);\n', '        require(_founders.length != 0);\n', '        require(address(token) == 0x0 && _token != 0x0);\n', '        require(address(proceeds) == 0x0 && _proceeds != 0x0);\n', '        require(_autonomousConverter != 0x0);\n', '\n', '        token = METToken(_token);\n', '        proceeds = Proceeds(_proceeds);\n', '\n', '        // _founders will be minted into individual token lockers\n', '        uint foundersTotal;\n', '        for (uint i = 0; i < _founders.length; i++) {\n', '            address addr = address(_founders[i] >> 96);\n', '            require(addr != 0x0);\n', '            uint amount = _founders[i] & ((1 << 96) - 1);\n', '            require(amount > 0);\n', '            TokenLocker tokenLocker = tokenLockers[addr];\n', '            require(token.mint(address(tokenLocker), amount));\n', '            tokenLocker.deposit(addr, amount);\n', '            foundersTotal = foundersTotal.add(amount);\n', '        }\n', '\n', '        // reconcile minted total for founders\n', '        require(foundersTotal == INITIAL_FOUNDER_SUPPLY);\n', '\n', '        // mint a small amount to the AC\n', '        require(token.mint(_autonomousConverter, INITIAL_AC_SUPPLY));\n', '\n', '        minted = true;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Suspend auction if not started yet\n', '    function stopEverything() public onlyOwner {\n', '        if (genesisTime < block.timestamp) {\n', '            revert(); \n', '        }\n', '        genesisTime = genesisTime + 1000 years;\n', '        initialAuctionEndTime = genesisTime;\n', '        dailyAuctionStartTime = genesisTime;\n', '    }\n', '\n', '    /// @notice Return information about initial auction status.\n', '    function isInitialAuctionEnded() public view returns (bool) {\n', '        return (initialAuctionEndTime != 0 && \n', '            (now >= initialAuctionEndTime || token.totalSupply() >= INITIAL_SUPPLY));\n', '    }\n', '\n', '    /// @notice Global MET supply\n', '    function globalMetSupply() public view returns (uint) {\n', '\n', '        uint currAuc = currentAuction();\n', '        if (currAuc > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {\n', '            return globalSupplyAfterPercentageLogic;\n', '        } else {\n', '            return INITIAL_SUPPLY.add(INITIAL_GLOBAL_DAILY_SUPPLY.mul(currAuc));\n', '        }\n', '    }\n', '\n', '    /// @notice Global MET daily supply. Daily supply is greater of 1) 2880 2)2% of then outstanding supply per year.\n', '    /// @dev 2% logic will kicks in at 14792th auction. \n', '    function globalDailySupply() public view returns (uint) {\n', '        uint dailySupply = INITIAL_GLOBAL_DAILY_SUPPLY;\n', '        uint thisAuction = currentAuction();\n', '\n', '        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {\n', '            uint lastAuctionPurchase = whichAuction(lastPurchaseTick);\n', '            uint recentAuction = AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS + 1;\n', '            if (lastAuctionPurchase > recentAuction) {\n', '                recentAuction = lastAuctionPurchase;\n', '            }\n', '\n', '            uint totalAuctions = thisAuction - recentAuction;\n', '            if (totalAuctions > 1) {\n', '                // derived formula to find close to accurate daily supply when some auction missed. \n', '                uint factor = 36525 + ((totalAuctions - 1) * 2);\n', '                dailySupply = (globalSupplyAfterPercentageLogic.mul(2).mul(factor)).div(36525 ** 2);\n', '\n', '            } else {\n', '                dailySupply = globalSupplyAfterPercentageLogic.mul(2).div(36525);\n', '            }\n', '\n', '            if (dailySupply < INITIAL_GLOBAL_DAILY_SUPPLY) {\n', '                dailySupply = INITIAL_GLOBAL_DAILY_SUPPLY; \n', '            }\n', '        }\n', '\n', '        return dailySupply;\n', '    }\n', '\n', '    /// @notice Current price of MET in current auction\n', '    /// @return weiPerToken \n', '    function currentPrice() public constant returns (uint weiPerToken) {\n', '        weiPerToken = calcPriceAt(currentTick());\n', '    }\n', '\n', '    /// @notice Daily mintable MET in current auction\n', '    function dailyMintable() public constant returns (uint) {\n', '        return nextAuctionSupply(0);\n', '    }\n', '\n', '    /// @notice Total tokens on this chain\n', '    function tokensOnThisChain() public view returns (uint) {\n', '        uint totalSupply = token.totalSupply();\n', '        uint currMintable = currentMintable();\n', '        return totalSupply.add(currMintable);\n', '    }\n', '\n', '    /// @notice Current mintable MET in auction\n', '    function currentMintable() public view returns (uint) {\n', '        uint currMintable = mintable;\n', '        uint currAuction = currentAuction();\n', '        uint totalAuctions = currAuction.sub(whichAuction(lastPurchaseTick));\n', '        if (totalAuctions > 0) {\n', '            currMintable = mintable.add(nextAuctionSupply(totalAuctions));\n', '        }\n', '        return currMintable;\n', '    }\n', '\n', '    /// @notice prepare auction when first import is done on a non ETH chain\n', '    function prepareAuctionForNonOGChain() public {\n', '        require(msg.sender == address(token.tokenPorter()) || msg.sender == address(token));\n', '        require(token.totalSupply() == 0);\n', '        require(chain != "ETH");\n', '        lastPurchaseTick = currentTick();\n', '    }\n', '\n', '    /// @notice Find out what the results would be of a prospective purchase\n', '    /// @param _wei Amount of wei the purchaser will pay\n', '    /// @param _timestamp Prospective purchase timestamp\n', '    /// @return weiPerToken expected MET token rate\n', '    /// @return tokens Expected token for a prospective purchase\n', '    /// @return refund Wei refund the purchaser will get if amount is excess and MET supply is less\n', '    function whatWouldPurchaseDo(uint _wei, uint _timestamp) public constant\n', '        returns (uint weiPerToken, uint tokens, uint refund)\n', '    {\n', '        weiPerToken = calcPriceAt(whichTick(_timestamp));\n', '        uint calctokens = METDECMULT.mul(_wei).div(weiPerToken);\n', '        tokens = calctokens;\n', '        if (calctokens > mintable) {\n', '            tokens = mintable;\n', '            uint weiPaying = mintable.mul(weiPerToken).div(METDECMULT);\n', '            refund = _wei.sub(weiPaying);\n', '        }\n', '    }\n', '    \n', '    /// @notice Return the information about the next auction\n', '    /// @return _startTime Start time of next auction\n', '    /// @return _startPrice Start price of MET in next auction\n', '    /// @return _auctionTokens  MET supply in next auction\n', '    function nextAuction() internal constant returns(uint _startTime, uint _startPrice, uint _auctionTokens) {\n', '        if (block.timestamp < genesisTime) {\n', '            _startTime = genesisTime;\n', '            _startPrice = lastPurchasePrice;\n', '            _auctionTokens = mintable;\n', '            return;\n', '        }\n', '\n', '        uint recentAuction = whichAuction(lastPurchaseTick);\n', '        uint currAuc = currentAuction();\n', '        uint totalAuctions = currAuc - recentAuction;\n', '        _startTime = dailyAuctionStartTime;\n', '        if (currAuc > 1) {\n', '            _startTime = auctionStartTime(currentTick());\n', '        }\n', '\n', '        _auctionTokens = nextAuctionSupply(totalAuctions);\n', '\n', '        if (totalAuctions > 1) {\n', '            _startPrice = lastPurchasePrice / 100 + 1;\n', '        } else {\n', '            if (mintable == 0 || totalAuctions == 0) {\n', '                // Sold out scenario or someone querying projected start price of next auction\n', '                _startPrice = (lastPurchasePrice * 2) + 1;   \n', '            } else {\n', '                // Timed out and all tokens not sold.\n', '                if (currAuc == 1) {\n', '                    // If initial auction timed out then price before start of new auction will touch floor price\n', '                    _startPrice = minimumPrice * 2;\n', '                } else {\n', '                    // Descending price till end of auction and then multiply by 2\n', '                    uint tickWhenAuctionEnded = whichTick(_startTime);\n', '                    uint numTick = 0;\n', '                    if (tickWhenAuctionEnded > lastPurchaseTick) {\n', '                        numTick = tickWhenAuctionEnded - lastPurchaseTick;\n', '                    }\n', '                    _startPrice = priceAt(lastPurchasePrice, numTick) * 2;\n', '                }\n', '                \n', '                \n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Calculate results of a purchase\n', '    /// @param _wei Amount of wei the purchaser will pay\n', '    /// @param _t Prospective purchase tick\n', '    /// @return weiPerToken expected MET token rate\n', '    /// @return tokens Expected token for a prospective purchase\n', '    /// @return refund Wei refund the purchaser will get if amount is excess and MET supply is less\n', '    function calcPurchase(uint _wei, uint _t) internal view returns (uint weiPerToken, uint tokens, uint refund)\n', '    {\n', '        require(_t >= lastPurchaseTick);\n', '        uint numTicks = _t - lastPurchaseTick;\n', '        if (isInitialAuctionEnded()) {\n', '            weiPerToken = priceAt(lastPurchasePrice, numTicks);\n', '        } else {\n', '            weiPerToken = priceAtInitialAuction(lastPurchasePrice, numTicks);\n', '        }\n', '\n', '        uint calctokens = METDECMULT.mul(_wei).div(weiPerToken);\n', '        tokens = calctokens;\n', '        if (calctokens > mintable) {\n', '            tokens = mintable;\n', '            uint ethPaying = mintable.mul(weiPerToken).div(METDECMULT);\n', '            refund = _wei.sub(ethPaying);\n', '        }\n', '    }\n', '\n', '    /// @notice MET supply for next Auction also considering  carry forward met.\n', '    /// @param totalAuctionMissed auction count when no purchase done.\n', '    function nextAuctionSupply(uint totalAuctionMissed) internal view returns (uint supply) {\n', '        uint thisAuction = currentAuction();\n', '        uint tokensHere = token.totalSupply().add(mintable);\n', '        supply = INITIAL_GLOBAL_DAILY_SUPPLY;\n', '        uint dailySupplyAtLastPurchase;\n', '        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {\n', '            supply = globalDailySupply();\n', '            if (totalAuctionMissed > 1) {\n', '                dailySupplyAtLastPurchase = globalSupplyAfterPercentageLogic.mul(2).div(36525);\n', '                supply = dailySupplyAtLastPurchase.add(supply).mul(totalAuctionMissed).div(2);\n', '            } \n', '            supply = (supply.mul(tokensHere)).div(globalSupplyAfterPercentageLogic);\n', '        } else {\n', '            if (totalAuctionMissed > 1) {\n', '                supply = supply.mul(totalAuctionMissed);\n', '            }\n', '            uint previousGlobalMetSupply = \n', '            INITIAL_SUPPLY.add(INITIAL_GLOBAL_DAILY_SUPPLY.mul(whichAuction(lastPurchaseTick)));\n', '            supply = (supply.mul(tokensHere)).div(previousGlobalMetSupply);\n', '        \n', '        }\n', '    }\n', '\n', '    /// @notice price at a number of minutes out in Initial auction and daily auction\n', '    /// @param _tick Metronome tick\n', '    /// @return weiPerToken\n', '    function calcPriceAt(uint _tick) internal constant returns (uint weiPerToken) {\n', '        uint recentAuction = whichAuction(lastPurchaseTick);\n', '        uint totalAuctions = whichAuction(_tick).sub(recentAuction);\n', '        uint prevPrice;\n', '\n', '        uint numTicks = 0;\n', '\n', '        // Auction is sold out and metronome clock is in same auction\n', '        if (mintable == 0 && totalAuctions == 0) {\n', '            return lastPurchasePrice;\n', '        }\n', '\n', '        // Metronome has missed one auction ie no purchase in last auction\n', '        if (totalAuctions > 1) {\n', '            prevPrice = lastPurchasePrice / 100 + 1;\n', '            numTicks = numTicksSinceAuctionStart(_tick);\n', '        } else if (totalAuctions == 1) {\n', '            // Metronome clock is in new auction, next auction\n', '            // previous auction sold out\n', '            if (mintable == 0) {\n', '                prevPrice = lastPurchasePrice * 2;\n', '            } else {\n', '                // previous auctions timed out\n', '                // first daily auction\n', '                if (whichAuction(_tick) == 1) {\n', '                    prevPrice = minimumPrice * 2;\n', '                } else {\n', '                    prevPrice = priceAt(lastPurchasePrice, numTicksTillAuctionStart(_tick)) * 2;\n', '                }\n', '            }\n', '            numTicks = numTicksSinceAuctionStart(_tick);\n', '        } else {\n', '            //Auction is running\n', '            prevPrice = lastPurchasePrice;\n', '            numTicks = _tick - lastPurchaseTick;\n', '        }\n', '\n', '        require(numTicks >= 0);\n', '\n', '        if (isInitialAuctionEnded()) {\n', '            weiPerToken = priceAt(prevPrice, numTicks);\n', '        } else {\n', '            weiPerToken = priceAtInitialAuction(prevPrice, numTicks);\n', '        }\n', '    }\n', '\n', '    /// @notice Calculate number of ticks elapsed between auction start time and given tick.\n', '    /// @param _tick Given metronome tick\n', '    function numTicksSinceAuctionStart(uint _tick) private view returns (uint ) {\n', '        uint currentAuctionStartTime = auctionStartTime(_tick);\n', '        return _tick - whichTick(currentAuctionStartTime);\n', '    }\n', '    \n', '    /// @notice Calculate number of ticks elapsed between lastPurchaseTick and auctions start time of given tick.\n', '    /// @param _tick Given metronome tick\n', '    function numTicksTillAuctionStart(uint _tick) private view returns (uint) {\n', '        uint currentAuctionStartTime = auctionStartTime(_tick);\n', '        return whichTick(currentAuctionStartTime) - lastPurchaseTick;\n', '    }\n', '\n', '    /// @notice First calculate the auction which contains the given tick and then calculate\n', '    /// auction start time of given tick.\n', '    /// @param _tick Metronome tick\n', '    function auctionStartTime(uint _tick) private view returns (uint) {\n', '        return ((whichAuction(_tick)) * 1 days) / timeScale + dailyAuctionStartTime - 1 days;\n', '    }\n', '\n', '    /// @notice start the next day&#39;s auction\n', '    function restartAuction() private {\n', '        uint time;\n', '        uint price;\n', '        uint auctionTokens;\n', '        (time, price, auctionTokens) = nextAuction();\n', '\n', '        uint thisAuction = currentAuction();\n', '        if (thisAuction > AUCTION_WHEN_PERCENTAGE_LOGIC_STARTS) {\n', '            globalSupplyAfterPercentageLogic = globalSupplyAfterPercentageLogic.add(globalDailySupply());\n', '        }\n', '\n', '        mintable = mintable.add(auctionTokens);\n', '        lastPurchasePrice = price;\n', '        lastPurchaseTick = whichTick(time);\n', '    }\n', '}\n', '\n', '\n', '/// @title This contract serves as a locker for a founder&#39;s tokens\n', 'contract TokenLocker is Ownable {\n', '    using SafeMath for uint;\n', '    uint internal constant QUARTER = 91 days + 450 minutes;\n', '  \n', '    Auctions public auctions;\n', '    METToken public token;\n', '    bool public locked = false;\n', '  \n', '    uint public deposited;\n', '    uint public lastWithdrawTime;\n', '    uint public quarterlyWithdrawable;\n', '    \n', '    event Withdrawn(address indexed who, uint amount);\n', '    event Deposited(address indexed who, uint amount);\n', '\n', '    modifier onlyAuction() {\n', '        require(msg.sender == address(auctions));\n', '        _;\n', '    }\n', '\n', '    modifier preLock() { \n', '        require(!locked);\n', '        _; \n', '    }\n', '\n', '    modifier postLock() { \n', '        require(locked); \n', '        _; \n', '    }\n', '\n', '    /// @notice Constructor to initialize TokenLocker contract.\n', '    /// @param _auctions Address of auctions contract\n', '    /// @param _token Address of METToken contract\n', '    function TokenLocker(address _auctions, address _token) public {\n', '        require(_auctions != 0x0);\n', '        require(_token != 0x0);\n', '        auctions = Auctions(_auctions);\n', '        token = METToken(_token);\n', '    }\n', '\n', '    /// @notice If auctions is initialized, call to this function will result in\n', '    /// locking of deposited tokens and further deposit of tokens will not be allowed.\n', '    function lockTokenLocker() public onlyAuction {\n', '        require(auctions.initialAuctionEndTime() != 0);\n', '        require(auctions.initialAuctionEndTime() >= auctions.genesisTime()); \n', '        locked = true;\n', '    }\n', '\n', '    /// @notice It will deposit tokens into the locker for given beneficiary.\n', '    /// @param beneficiary Address of the beneficiary, whose tokens are being locked.\n', '    /// @param amount Amount of tokens being locked\n', '    function deposit (address beneficiary, uint amount ) public onlyAuction preLock {\n', '        uint totalBalance = token.balanceOf(this);\n', '        require(totalBalance.sub(deposited) >= amount);\n', '        deposited = deposited.add(amount);\n', '        emit Deposited(beneficiary, amount);\n', '    }\n', '\n', '    /// @notice This function will allow token withdraw from locker.\n', '    /// 25% of total deposited tokens can be withdrawn after initial auction end.\n', '    /// Remaining 75% can be withdrawn in equal amount over 12 quarters.\n', '    function withdraw() public onlyOwner postLock {\n', '        require(deposited > 0);\n', '        uint withdrawable = 0; \n', '        uint withdrawTime = auctions.initialAuctionEndTime();\n', '        if (lastWithdrawTime == 0 && auctions.isInitialAuctionEnded()) {\n', '            withdrawable = withdrawable.add((deposited.mul(25)).div(100));\n', '            quarterlyWithdrawable = (deposited.sub(withdrawable)).div(12);\n', '            lastWithdrawTime = withdrawTime;\n', '        }\n', '\n', '        require(lastWithdrawTime != 0);\n', '\n', '        if (now >= lastWithdrawTime.add(QUARTER)) {\n', '            uint daysSinceLastWithdraw = now.sub(lastWithdrawTime);\n', '            uint totalQuarters = daysSinceLastWithdraw.div(QUARTER);\n', '\n', '            require(totalQuarters > 0);\n', '        \n', '            withdrawable = withdrawable.add(quarterlyWithdrawable.mul(totalQuarters));\n', '\n', '            if (now >= withdrawTime.add(QUARTER.mul(12))) {\n', '                withdrawable = deposited;\n', '            }\n', '\n', '            lastWithdrawTime = lastWithdrawTime.add(totalQuarters.mul(QUARTER));\n', '        }\n', '\n', '        if (withdrawable > 0) {\n', '            deposited = deposited.sub(withdrawable);\n', '            token.transfer(msg.sender, withdrawable);\n', '            emit Withdrawn(msg.sender, withdrawable);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @title Interface for TokenPorter contract.\n', '/// Define events and functions for TokenPorter contract\n', 'interface ITokenPorter {\n', '    event ExportOnChainClaimedReceiptLog(address indexed destinationMetronomeAddr, \n', '        address indexed destinationRecipientAddr, uint amount);\n', '\n', '    event ExportReceiptLog(bytes8 destinationChain, address destinationMetronomeAddr,\n', '        address indexed destinationRecipientAddr, uint amountToBurn, uint fee, bytes extraData, uint currentTick,\n', '        uint indexed burnSequence, bytes32 indexed currentBurnHash, bytes32 prevBurnHash, uint dailyMintable,\n', '        uint[] supplyOnAllChains, uint genesisTime, uint blockTimestamp, uint dailyAuctionStartTime);\n', '\n', '    event ImportReceiptLog(address indexed destinationRecipientAddr, uint amountImported, \n', '        uint fee, bytes extraData, uint currentTick, uint indexed importSequence, \n', '        bytes32 indexed currentHash, bytes32 prevHash, uint dailyMintable, uint blockTimestamp, address caller);\n', '\n', '    function export(address tokenOwner, bytes8 _destChain, address _destMetronomeAddr, \n', '        address _destRecipAddr, uint _amount, uint _fee, bytes _extraData) public returns (bool);\n', '    \n', '    function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData, \n', '        bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool);\n', '\n', '}\n', '\n', '\n', '/// @title This contract will provide export functionality for tokens.\n', 'contract TokenPorter is ITokenPorter, Owned {\n', '    using SafeMath for uint;\n', '    Auctions public auctions;\n', '    METToken public token;\n', '    Validator public validator;\n', '    ChainLedger public chainLedger;\n', '\n', '    uint public burnSequence = 1;\n', '    uint public importSequence = 1;\n', '    bytes32[] public exportedBurns;\n', '    uint[] public supplyOnAllChains = new uint[](6);\n', '\n', '    /// @notice mapping that tracks valid destination chains for export\n', '    mapping(bytes8 => address) public destinationChains;\n', '\n', '    /// @notice Initialize TokenPorter contract.\n', '    /// @param _tokenAddr Address of metToken contract\n', '    /// @param _auctionsAddr Address of auctions contract\n', '    function initTokenPorter(address _tokenAddr, address _auctionsAddr) public onlyOwner {\n', '        require(_tokenAddr != 0x0);\n', '        require(_auctionsAddr != 0x0);\n', '        auctions = Auctions(_auctionsAddr);\n', '        token = METToken(_tokenAddr);\n', '    }\n', '\n', '    /// @notice set address of validator contract\n', '    /// @param _validator address of validator contract\n', '    function setValidator(address _validator) public onlyOwner returns (bool) {\n', '        require(_validator != 0x0);\n', '        validator = Validator(_validator);\n', '        return true;\n', '    }\n', '\n', '    /// @notice set address of chainLedger contract\n', '    /// @param _chainLedger address of chainLedger contract\n', '    function setChainLedger(address _chainLedger) public onlyOwner returns (bool) {\n', '        require(_chainLedger != 0x0);\n', '        chainLedger = ChainLedger(_chainLedger);\n', '        return true;\n', '    }\n', '\n', '    /// @notice only owner can add destination chains\n', '    /// @param _chainName string of destination blockchain name\n', '    /// @param _contractAddress address of destination MET token to import to\n', '    function addDestinationChain(bytes8 _chainName, address _contractAddress) \n', '        public onlyOwner returns (bool) \n', '    {\n', '        require(_chainName != 0 && _contractAddress != address(0));\n', '        destinationChains[_chainName] = _contractAddress;\n', '        return true;\n', '    }\n', '\n', '    /// @notice only owner can remove destination chains\n', '    /// @param _chainName string of destination blockchain name\n', '    function removeDestinationChain(bytes8 _chainName) public onlyOwner returns (bool) {\n', '        require(_chainName != 0);\n', '        require(destinationChains[_chainName] != address(0));\n', '        destinationChains[_chainName] = address(0);\n', '        return true;   \n', '    }\n', '\n', '    /// @notice holds claims from users that have exported on-chain\n', '    /// @param key is address of destination MET token contract\n', '    /// @param subKey is address of users account that burned their original MET token\n', '    mapping (address  => mapping(address => uint)) public claimables;\n', '\n', '    /// @notice destination MET token contract calls claimReceivables to record burned \n', '    /// tokens have been minted in new chain\n', '    /// @param recipients array of addresses of each user that has exported from\n', '    /// original chain.  These can be generated by ExportReceiptLog\n', '    function claimReceivables(address[] recipients) public returns (uint) {\n', '        require(recipients.length > 0);\n', '\n', '        uint total;\n', '        for (uint i = 0; i < recipients.length; i++) {\n', '            address recipient = recipients[i];\n', '            uint amountBurned = claimables[msg.sender][recipient];\n', '            if (amountBurned > 0) {\n', '                claimables[msg.sender][recipient] = 0;\n', '                emit ExportOnChainClaimedReceiptLog(msg.sender, recipient, amountBurned);\n', '                total = total.add(1);\n', '            }\n', '        }\n', '        return total;\n', '    }\n', '\n', '    /// @notice import MET tokens from another chain to this chain.\n', '    /// @param _destinationChain destination chain name\n', '    /// @param _addresses _addresses[0] is destMetronomeAddr and _addresses[1] is recipientAddr\n', '    /// @param _extraData extra information for import\n', '    /// @param _burnHashes _burnHashes[0] is previous burnHash, _burnHashes[1] is current burnHash\n', '    /// @param _supplyOnAllChains MET supply on all supported chains\n', '    /// @param _importData _importData[0] is _blockTimestamp, _importData[1] is _amount, _importData[2] is _fee\n', '    /// _importData[3] is _burnedAtTick, _importData[4] is _genesisTime, _importData[5] is _dailyMintable\n', '    /// _importData[6] is _burnSequence, _importData[7] is _dailyAuctionStartTime\n', '    /// @param _proof proof\n', '    /// @return true/false\n', '    function importMET(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData, \n', '        bytes32[] _burnHashes, uint[] _supplyOnAllChains, uint[] _importData, bytes _proof) public returns (bool)\n', '    {\n', '        \n', '        require(msg.sender == address(token));\n', '        require(_importData.length == 8);\n', '        require(_addresses.length == 2);\n', '        require(_burnHashes.length == 2);\n', '        require(validator.isReceiptClaimable(_originChain, _destinationChain, _addresses, _extraData, _burnHashes, \n', '        _supplyOnAllChains, _importData, _proof));\n', '\n', '        validator.claimHash(_burnHashes[1]);\n', '\n', '        require(_destinationChain == auctions.chain());\n', '        uint amountToImport = _importData[1].add(_importData[2]);\n', '        require(amountToImport.add(token.totalSupply()) <= auctions.globalMetSupply());\n', '\n', '        require(_addresses[0] == address(token));\n', '\n', '        if (_importData[1] == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (importSequence == 1 && token.totalSupply() == 0) {\n', '            auctions.prepareAuctionForNonOGChain();\n', '        }\n', '        \n', '        token.mint(_addresses[1], _importData[1]);\n', '        emit ImportReceiptLog(_addresses[1], _importData[1], _importData[2], _extraData,\n', '        auctions.currentTick(), importSequence, _burnHashes[1],\n', '        _burnHashes[0], auctions.dailyMintable(), now, msg.sender);\n', '        importSequence++;\n', '        chainLedger.registerImport(_originChain, _destinationChain, _importData[1]);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Export MET tokens from this chain to another chain.\n', '    /// @param tokenOwner Owner of the token, whose tokens are being exported.\n', '    /// @param _destChain Destination chain for exported tokens\n', '    /// @param _destMetronomeAddr Metronome address on destination chain\n', '    /// @param _destRecipAddr Recipient address on the destination chain\n', '    /// @param _amount Amount of token being exported\n', '    /// @param _extraData Extra data for this export\n', '    /// @return boolean true/false based on the outcome of export\n', '    function export(address tokenOwner, bytes8 _destChain, address _destMetronomeAddr,\n', '        address _destRecipAddr, uint _amount, uint _fee, bytes _extraData) public returns (bool) \n', '    {\n', '        require(msg.sender == address(token));\n', '\n', '        require(_destChain != 0x0 && _destMetronomeAddr != 0x0 && _destRecipAddr != 0x0 && _amount != 0);\n', '        require(destinationChains[_destChain] == _destMetronomeAddr);\n', '        \n', '        require(token.balanceOf(tokenOwner) >= _amount.add(_fee));\n', '\n', '        token.destroy(tokenOwner, _amount.add(_fee));\n', '\n', '        uint dailyMintable = auctions.dailyMintable();\n', '        uint currentTick = auctions.currentTick();\n', '       \n', '       \n', '        if (burnSequence == 1) {\n', '            exportedBurns.push(keccak256(uint8(0)));\n', '        }\n', '\n', '        if (_destChain == auctions.chain()) {\n', '            claimables[_destMetronomeAddr][_destRecipAddr] = \n', '                claimables[_destMetronomeAddr][_destRecipAddr].add(_amount);\n', '        }\n', '        uint blockTime = block.timestamp;\n', '        bytes32 currentBurn = keccak256(\n', '            blockTime, \n', '            auctions.chain(),\n', '            _destChain, \n', '            _destMetronomeAddr, \n', '            _destRecipAddr, \n', '            _amount,\n', '            currentTick,\n', '            auctions.genesisTime(),\n', '            dailyMintable,\n', '            token.totalSupply(),\n', '            _extraData,\n', '            exportedBurns[burnSequence - 1]);\n', '       \n', '        exportedBurns.push(currentBurn);\n', '\n', '        supplyOnAllChains[0] = token.totalSupply();\n', '        \n', '        emit ExportReceiptLog(_destChain, _destMetronomeAddr, _destRecipAddr, _amount, _fee, _extraData, \n', '            currentTick, burnSequence, currentBurn, exportedBurns[burnSequence - 1], dailyMintable,\n', '            supplyOnAllChains, auctions.genesisTime(), blockTime, auctions.dailyAuctionStartTime());\n', '\n', '        burnSequence = burnSequence + 1;\n', '        chainLedger.registerExport(auctions.chain(), _destChain, _amount);\n', '        return true;\n', '    }\n', '}    \n', '\n', '\n', 'contract ChainLedger is Owned {\n', '\n', '    using SafeMath for uint;\n', '    mapping (bytes8 => uint) public balance;\n', '    mapping (bytes8 => bool) public validChain;\n', '    bytes8[] public chains;\n', '\n', '    address public tokenPorter;\n', '    Auctions public auctions;\n', '\n', '    event LogRegisterChain(address indexed caller, bytes8 indexed chain, uint supply, bool outcome);\n', '    event LogRegisterExport(address indexed caller, bytes8 indexed originChain, bytes8 indexed destChain, uint amount);\n', '    event LogRegisterImport(address indexed caller, bytes8 indexed originChain, bytes8 indexed destChain, uint amount);\n', '\n', '    function initChainLedger(address _tokenPorter, address _auctionsAddr) public onlyOwner returns (bool) {\n', '        require(_tokenPorter != 0x0);\n', '        require(_auctionsAddr != 0x0);\n', '        \n', '        tokenPorter = _tokenPorter;\n', '        auctions = Auctions(_auctionsAddr);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function registerChain(bytes8 chain, uint supply) public onlyOwner returns (bool) {\n', '        require(!validChain[chain]); \n', '        validChain[chain] = true;\n', '        chains.push(chain);\n', '        balance[chain] = supply;\n', '        emit LogRegisterChain(msg.sender, chain, supply, true);\n', '    }\n', '\n', '    function registerExport(bytes8 originChain, bytes8 destChain, uint amount) public {\n', '        require(msg.sender == tokenPorter || msg.sender == owner);\n', '        require(validChain[originChain] && validChain[destChain]);\n', '        require(balance[originChain] >= amount);\n', '\n', '        balance[originChain] = balance[originChain].sub(amount);\n', '        balance[destChain] = balance[destChain].add(amount);\n', '        emit LogRegisterExport(msg.sender, originChain, destChain, amount);\n', '    }\n', '\n', '    function registerImport(bytes8 originChain, bytes8 destChain, uint amount) public {\n', '        require(msg.sender == tokenPorter || msg.sender == owner);\n', '        require(validChain[originChain] && validChain[destChain]);\n', '\n', '        balance[originChain] = balance[originChain].sub(amount);\n', '        balance[destChain] = balance[destChain].add(amount);\n', '        emit LogRegisterImport(msg.sender, originChain, destChain, amount);\n', '    }  \n', '}\n', '\n', '\n', 'contract Validator is Owned {\n', '\n', '    mapping (bytes32 => mapping (address => bool)) public hashAttestations;\n', '    mapping (address => bool) public isValidator;\n', '    mapping (address => uint8) public validatorNum;\n', '    address[] public validators;\n', '    address public metToken;\n', '    address public tokenPorter;\n', '\n', '    mapping (bytes32 => bool) public hashClaimed;\n', '\n', '    uint8 public threshold = 2;\n', '\n', '    event LogAttestation(bytes32 indexed hash, address indexed who, bool isValid);\n', '\n', '    /// @param _validator1 first validator  \n', '    /// @param _validator2 second validator\n', '    /// @param _validator3 third validator\n', '    function initValidator(address _validator1, address _validator2, address _validator3) public onlyOwner {\n', '        // Clear old validators. Validators can be updated multiple times\n', '        for (uint8 i = 0; i < validators.length; i++) {\n', '            delete isValidator[validators[i]];\n', '            delete validatorNum[validators[i]];\n', '        }\n', '        delete validators;\n', '        validators.push(_validator1);\n', '        validators.push(_validator2);\n', '        validators.push(_validator3);\n', '        // TODO: This will be NA, Bloq and a third party (escrow or company) at launch, \n', '        // and should be scripted into deploy\n', '\n', '        isValidator[_validator1] = true;\n', '        isValidator[_validator2] = true;\n', '        isValidator[_validator3] = true;\n', '\n', '        validatorNum[_validator1] = 0;\n', '        validatorNum[_validator2] = 1;\n', '        validatorNum[_validator3] = 2;\n', '\n', '    }\n', '\n', '    /// @notice set address of token porter\n', '    /// @param _tokenPorter address of token porter\n', '    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {\n', '        require(_tokenPorter != 0x0);\n', '        tokenPorter = _tokenPorter;\n', '        return true;\n', '    }\n', '\n', '    function validateHash(bytes32 hash) public {\n', '        require(isValidator[msg.sender]);\n', '        hashAttestations[hash][msg.sender] = true;\n', '        emit LogAttestation(hash, msg.sender, true);\n', '    }\n', '\n', '    function invalidateHash(bytes32 hash) public {\n', '        require(isValidator[msg.sender]);\n', '        hashAttestations[hash][msg.sender] = false;\n', '        emit LogAttestation(hash, msg.sender, false);\n', '    }\n', '\n', '    function hashClaimable(bytes32 hash) public view returns(bool) {\n', '        if (hashClaimed[hash]) { return false; }\n', '\n', '        uint8 count = 0;\n', '\n', '        for (uint8 i = 0; i < validators.length; i++) {\n', '            if (hashAttestations[hash][validators[i]]) { count++;} \n', '        }\n', '\n', '        if (count >= threshold) { return true; }\n', '        return false;\n', '    }\n', '\n', '    function claimHash(bytes32 hash) public {\n', '        require(msg.sender == tokenPorter);\n', '        require(hashClaimable(hash));\n', '        hashClaimed[hash] = true;\n', '    }\n', '\n', '    function isReceiptClaimable(bytes8 _originChain, bytes8 _destinationChain, address[] _addresses, bytes _extraData, \n', '        bytes32[] _burnHashes, uint[] _supplyOnAllChain, uint[] _importData, bytes _proof) public view returns(bool) {\n', '        // We want to validate that these hash to the provided hash as a safety check, \n', '        // then we want to know if the hash is Claimable. \n', '\n', '        // Due to stack too deep error and limitation in using number of local \n', '        // variables we have to use uint array here. \n', '        // _importData[0] is _blockTimestamp, _importData[1] is _amount, _importData[2] is _fee,\n', '        // _importData[3] is _burnedAtTick, _importData[4] is _genesisTime,\n', '        // _importData[5] is _dailyMintable, _importData[6] is _burnSequence,\n', '        // _addresses[0] is _destMetronomeAddr and _addresses[1] is _recipAddr\n', '\n', '        require(_burnHashes[1] == keccak256(_importData[0], _originChain, _destinationChain, _addresses[0], \n', '            _addresses[1], _importData[1], _importData[3], _importData[4], _importData[5], _supplyOnAllChain[0], \n', '            _extraData, _burnHashes[0]));\n', '\n', '        if (hashClaimable(_burnHashes[1])) {\n', '            return true;\n', '        } \n', '        \n', '        return false;\n', '\n', '    }\n', '}']