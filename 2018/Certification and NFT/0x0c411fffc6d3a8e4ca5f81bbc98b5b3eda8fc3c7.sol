['contract SafeMath {\n', '    \n', '    uint256 constant MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        require(x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) {\n', '            return 0;\n', '        }\n', '        require(x <= (MAX_UINT256 / y));\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract Lockable is Owned {\n', '\n', '    uint256 public lockedUntilBlock;\n', '\n', '    event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '    modifier lockAffected {\n', '        require(block.number > lockedUntilBlock);\n', '        _;\n', '    }\n', '\n', '    function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '\n', '\n', '    function lockUntil(uint256 _untilBlock, string _reason) onlyOwner public {\n', '        lockedUntilBlock = _untilBlock;\n', '        ContractLocked(_untilBlock, _reason);\n', '    }\n', '}\n', '\n', 'contract ERC20TokenInterface {\n', '  function totalSupply() public constant returns (uint256 _totalSupply);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract InsurePalTokenInterface {\n', '    function mint(address _to, uint256 _amount) public;\n', '}\n', '\n', 'contract tokenRecipientInterface {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'contract KycContractInterface {\n', '    function isAddressVerified(address _address) public view returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract KycContract is Owned {\n', '    \n', '    mapping (address => bool) verifiedAddresses;\n', '    \n', '    function isAddressVerified(address _address) public view returns (bool) {\n', '        return verifiedAddresses[_address];\n', '    }\n', '    \n', '    function addAddress(address _newAddress) public onlyOwner {\n', '        require(!verifiedAddresses[_newAddress]);\n', '        \n', '        verifiedAddresses[_newAddress] = true;\n', '    }\n', '    \n', '    function removeAddress(address _oldAddress) public onlyOwner {\n', '        require(verifiedAddresses[_oldAddress]);\n', '        \n', '        verifiedAddresses[_oldAddress] = false;\n', '    }\n', '    \n', '    function batchAddAddresses(address[] _addresses) public onlyOwner {\n', '        for (uint cnt = 0; cnt < _addresses.length; cnt++) {\n', '            assert(!verifiedAddresses[_addresses[cnt]]);\n', '            verifiedAddresses[_addresses[cnt]] = true;\n', '        }\n', '    }\n', '    \n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{\n', '        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '    \n', '    function killContract() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned {\n', '\n', '  struct ContributorData {\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint nextContributorIndex;\n', '  mapping(uint => address) contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '\n', '  uint public crowdsaleStartBlock;\n', '  uint public crowdsaleEndedBlock;\n', '\n', '  event CrowdsaleStarted(uint blockNumber);\n', '  event CrowdsaleEnded(uint blockNumber);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockNumber);\n', '  event MaxCapReached(uint blockNumber);\n', '\n', '  address tokenAddress = 0x0;\n', '  address kycAddress = 0x0;\n', '  uint decimals = 18;\n', '\n', '  uint public minCap; //InTokens\n', '  uint public maxCap; //InTokens\n', '  uint public ethRaised;\n', '  uint public tokenTotalSupply = 300000000 * 10**decimals;\n', '  uint public tokensIssued = 0;\n', '\n', '  address public multisigAddress;\n', '  uint blocksInADay;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint crowdsaleTokenCap =          201000000 * 10**decimals;\n', '  uint founders =                    30000000 * 10**decimals;\n', '  uint insurePalTeam =               18000000 * 10**decimals;\n', '  uint tcsSupportTeam =              18000000 * 10**decimals;\n', '  uint advisorsAndAmbassadors =      18000000 * 10**decimals;\n', '  uint incentives =                   9000000 * 10**decimals;\n', '  uint earlyInvestors =               6000000 * 10**decimals;\n', '  bool foundersTokensClaimed = false;\n', '  bool insurePalTeamTokensClaimed = false;\n', '  bool tcsSupportTeamTokensClaimed = false;\n', '  bool advisorsAndAmbassadorsTokensClaimed = false;\n', '  bool incentivesTokensClaimed = false;\n', '  bool earlyInvestorsTokensClaimed = false;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  //\n', '  function() noReentrancy payable public {\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\n', '    require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.crowdsale) {\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    } else {\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool) {\n', '    if (tokensIssued == maxCap && crowdsaleState != state.crowdsaleEnded) {                     // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      CrowdsaleEnded(block.number);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.number >= crowdsaleStartBlock && block.number <= crowdsaleEndedBlock) {            // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale) {                                                  // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.number);                                                         // Raise event\n', '        return true;\n', '      }\n', '    } else {\n', '      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock) {       // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.number);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal {\n', '    if (_stateChanged) {\n', '      msg.sender.transfer(msg.value);\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function calculateEthToToken(uint _eth, uint _blockNumber) constant public returns(uint) {\n', '    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 4) {\n', '      return _eth * 12817;\n', '    }\n', '    if (_eth >= 50*10**decimals) {\n', '      return _eth * 12817;\n', '    }\n', '    if (_blockNumber > crowdsaleStartBlock) {\n', '      return _eth * 11652;\n', '    }\n', '  }\n', '\n', '  function calculateTokenToEth(uint _token, uint _blockNumber) constant public returns(uint) {\n', '    if (_blockNumber < crowdsaleStartBlock + blocksInADay * 4) {\n', '      return _token * 10000 / 12817;\n', '    }\n', '    if (_token >= 50*12817*10**decimals) {\n', '      return _token * 10000 / 12817;\n', '    }\n', '    if (_blockNumber > crowdsaleStartBlock) {\n', '      return _token * 10000 / 11652;\n', '    }\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '\n', '  function processTransaction(address _contributor, uint _amount) internal {\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '    uint tokensToGive = calculateEthToToken(contributionAmount, block.number);\n', '\n', '    if (tokensToGive > (maxCap - tokensIssued)) {                                     // Check if max contribution is lower than _amount sent\n', '      contributionAmount = calculateTokenToEth(maxCap - tokensIssued, block.number) / 10000;  // Set that user contibutes his maximum alowed contribution\n', '      returnAmount = _amount - contributionAmount;                                    // Calculate howmuch he must get back\n', '      tokensToGive = maxCap - tokensIssued;\n', '      MaxCapReached(block.number);\n', '    }\n', '\n', '    if (contributorList[_contributor].contributionAmount == 0) {\n', '        contributorIndexes[nextContributorIndex] = _contributor;\n', '        nextContributorIndex += 1;\n', '    }\n', '\n', '    contributorList[_contributor].contributionAmount += contributionAmount;\n', '    ethRaised += contributionAmount;                                              // Add to eth raised\n', '\n', '    if (tokensToGive > 0) {\n', '      InsurePalTokenInterface(tokenAddress).mint(_contributor, tokensToGive);       // Issue new tokens\n', '      contributorList[_contributor].tokensIssued += tokensToGive;                  // log token issuance\n', '      tokensIssued += tokensToGive;\n', '    }\n', '    if (returnAmount != 0) {\n', '      _contributor.transfer(returnAmount);\n', '    } \n', '  }\n', '\n', '  function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner public {\n', '      processTransaction(_address, _ethContributed);\n', '  }\n', '\n', '  function depositAngelInvestmentEth() payable onlyOwner public {}\n', '  \n', '\n', '  //\n', '  // Method is needed for recovering tokens accedentaly sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner public {\n', '    ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  //\n', '  function withdrawEth() onlyOwner public {\n', '    require(this.balance != 0);\n', '    require(tokensIssued >= minCap);\n', '\n', '    multisigAddress.transfer(this.balance);\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed() public {\n', '    require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)) {                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner public {\n', '    require(block.number > crowdsaleEndedBlock && tokensIssued < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++) {\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) {\n', '        return;                                                                       // Check if all the participants were compensated\n', '      }\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)) {                          // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner public {\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  function claimTeamTokens(address _to, uint _choice) onlyOwner public {\n', '    require(crowdsaleState == state.crowdsaleEnded);\n', '    require(tokensIssued >= minCap);\n', '\n', '    uint mintAmount;\n', '    if (_choice == 1) {\n', '      assert(!insurePalTeamTokensClaimed);\n', '      mintAmount = insurePalTeam;\n', '      insurePalTeamTokensClaimed = true;\n', '    } else if (_choice == 2) {\n', '      assert(!tcsSupportTeamTokensClaimed);\n', '      mintAmount = tcsSupportTeam;\n', '      tcsSupportTeamTokensClaimed = true;\n', '    } else if (_choice == 3) {\n', '      assert(!advisorsAndAmbassadorsTokensClaimed);\n', '      mintAmount = advisorsAndAmbassadors;\n', '      advisorsAndAmbassadorsTokensClaimed = true;\n', '    } else if (_choice == 4) {\n', '      assert(!incentivesTokensClaimed);\n', '      mintAmount = incentives;\n', '      incentivesTokensClaimed = true;\n', '    } else if (_choice == 5) {\n', '      assert(!earlyInvestorsTokensClaimed);\n', '      mintAmount = earlyInvestors;\n', '      earlyInvestorsTokensClaimed = true;\n', '    } else if (_choice == 6) {\n', '      assert(!foundersTokensClaimed);\n', '      assert(insurePalTeamTokensClaimed);\n', '      assert(tcsSupportTeamTokensClaimed);\n', '      assert(advisorsAndAmbassadorsTokensClaimed);\n', '      assert(incentivesTokensClaimed);\n', '      assert(earlyInvestorsTokensClaimed);\n', '      assert(tokenTotalSupply > ERC20TokenInterface(tokenAddress).totalSupply());\n', '      mintAmount = tokenTotalSupply - ERC20TokenInterface(tokenAddress).totalSupply();\n', '      foundersTokensClaimed = true;\n', '    } else {\n', '      revert();\n', '    }\n', '    InsurePalTokenInterface(tokenAddress).mint(_to, mintAmount);\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner public {\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) onlyOwner public {\n', '    tokenAddress = _newAddress;\n', '  }\n', '\n', '  function setKycAddress(address _newAddress) onlyOwner public {\n', '    kycAddress = _newAddress;\n', '  }\n', '\n', '  function getTokenAddress() constant public returns(address) {\n', '    return tokenAddress;\n', '  }\n', '\n', '  function investorCount() constant public returns(uint) {\n', '    return nextContributorIndex;\n', '  }\n', '\n', '  function setCrowdsaleStartBlock(uint _block) onlyOwner public {\n', '    crowdsaleStartBlock = _block;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract InsurePalCrowdsale is Crowdsale {\n', '  \n', '  function InsurePalCrowdsale() {\n', '\n', '    crowdsaleStartBlock = 4918135;\n', '    crowdsaleEndedBlock = 5031534; \n', '\n', '    minCap = 50000000 * 10**18;\n', '    maxCap = 201000000 * 10**18;\n', '\n', '    blocksInADay = 5400;\n', '  }\n', '}']