['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable \n', '{\n', '    address public owner;\n', '    address public newOwner;\n', '    \n', '    function Ownable() public \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public \n', '    {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public \n', '    {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 \n', '{\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public;\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public;\n', '    function approve(address spender, uint256 value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function getDecimals() public constant returns(uint8);\n', '    function getTotalSupply() public constant returns(uint256 supply);\n', '}\n', '\n', '\n', '\n', 'contract IzubrToken is Ownable, ERC20, SafeMath \n', '{\n', '    string  public constant standard    = &#39;Token 0.1&#39;;\n', '    string  public constant name        = &#39;Izubr&#39;;\n', '    string  public constant symbol      = "IZR";\n', '    uint8   public constant decimals    = 18;\n', '    uint256 public constant tokenKoef = 1000000000000000000;\n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    uint       private constant gasPrice = 3000000;\n', '\n', '    uint256    public etherPrice;\n', '    uint256    public minimalSuccessTokens;\n', '    uint256    public collectedTokens;\n', '\n', '    enum    State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\n', '    event   NewState(State state);\n', '\n', '    State      public state = State.Disabled;\n', '    uint256    public crowdsaleStartTime;\n', '    uint256    public crowdsaleFinishTime;\n', '\n', '    mapping (address => uint256)  public investors;\n', '    mapping (uint256 => address)  public investorsIter;\n', '    uint256                       public numberOfInvestors;\n', '\n', '    modifier onlyTokenHolders \n', '    {\n', '        require(balances[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) \n', '    {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    modifier enabledState \n', '    {\n', '        require(state == State.Enabled);\n', '        _;\n', '    }\n', '\n', '    modifier enabledOrMigrationState \n', '    {\n', '        require(state == State.Enabled || state == State.Migration);\n', '        _;\n', '    }\n', '\n', '\n', '\n', '    function getDecimals() public constant returns(uint8)\n', '    {\n', '        return decimals;\n', '    }\n', '\n', '    function balanceOf(address who) public constant returns (uint256) \n', '    {\n', '        return balances[who];\n', '    }\n', '\n', '    function investorsCount() public constant returns (uint256) \n', '    {\n', '        return numberOfInvestors;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        public enabledState onlyPayloadSize(2 * 32) \n', '    {\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = sub( balances[msg.sender], _value );\n', '        balances[_to] = add( balances[_to], _value );\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public enabledState onlyPayloadSize(3 * 32) \n', '    {\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '\n', '        balances[_from] = sub( balances[_from], _value );\n', '        balances[_to] = add( balances[_to], _value );\n', '\n', '        allowed[_from][msg.sender] = sub( allowed[_from][msg.sender], _value );\n', '\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public enabledState \n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant enabledState\n', '        returns (uint256 remaining) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    \n', '    function () public payable\n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '\n', '        uint256 valueWei = msg.value;\n', '\n', '        uint256 price = currentPrice();\n', '\n', '        uint256 valueTokens = div( mul( valueWei, price ), 1 ether);\n', '\n', '        if( valueTokens > 33333*tokenKoef ) // 5 BTC\n', '        {\n', '            price = price * 112 / 100;\n', '            valueTokens = mul( valueWei, price );\n', '        }\n', '\n', '        require(valueTokens > 10*tokenKoef);\n', '\n', '\n', '        collectedTokens = add( collectedTokens, valueTokens );\n', '            \n', '        if(msg.data.length == 20) \n', '        {\n', '            address referer = bytesToAddress(bytes(msg.data));\n', '\n', '            require(referer != msg.sender);\n', '\n', '            mintTokensWithReferal(msg.sender, referer, valueTokens);\n', '        }\n', '        else\n', '        {\n', '            mintTokens(msg.sender, valueTokens);\n', '        }\n', '    }\n', '\n', '    function bytesToAddress(bytes source) internal pure returns(address) \n', '    {\n', '        uint result;\n', '        uint mul = 1;\n', '\n', '        for(uint i = 20; i > 0; i--) \n', '        {\n', '            result += uint8(source[i-1])*mul;\n', '            mul = mul*256;\n', '        }\n', '\n', '        return address(result);\n', '    }\n', '\n', '    function getTotalSupply() public constant returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function depositTokens(address _who, uint256 _valueTokens) public onlyOwner \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '\n', '        uint256 bonus = currentBonus();\n', '        uint256 tokens = _valueTokens * (100 + bonus) / 100;\n', '\n', '        collectedTokens = add( collectedTokens, tokens );\n', '\n', '        mintTokens(_who, tokens);\n', '    }\n', '\n', '\n', '    function bonusForDate(uint date) public constant returns (uint256) \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        uint nday = (date - crowdsaleStartTime) / (1 days);\n', '\n', '        uint256 bonus = 0;\n', '\n', '        if (state == State.PreICO) \n', '        {\n', '            if( nday < 7*1 ) bonus = 100;\n', '            else\n', '            if( nday < 7*2 ) bonus = 80;\n', '            else\n', '            if( nday < 7*3 ) bonus = 70;\n', '            else\n', '            if( nday < 7*4 ) bonus = 60;\n', '            else\n', '            if( nday < 7*5 ) bonus = 50;\n', '            else             bonus = 40;\n', '        }\n', '        else\n', '        if (state == State.Crowdsale) \n', '        {\n', '            if( nday < 1 ) bonus = 20;\n', '            else\n', '            if( nday < 4 ) bonus = 15;\n', '            else\n', '            if( nday < 8 ) bonus = 10;\n', '            else\n', '            if( nday < 12 ) bonus = 5;\n', '        }\n', '\n', '        return bonus;\n', '    }\n', '\n', '    function currentBonus() public constant returns (uint256) \n', '    {\n', '        return bonusForDate(now);\n', '    }\n', '\n', '\n', '    function priceForDate(uint date) public constant returns (uint256) \n', '    {\n', '        uint256 bonus = bonusForDate(date);\n', '\n', '        return etherPrice * (100 + bonus) / 100;\n', '    }\n', '\n', '    function currentPrice() public constant returns (uint256) \n', '    {\n', '        return priceForDate(now);\n', '    }\n', '\n', '\n', '    function mintTokens(address _who, uint256 _tokens) internal \n', '    {\n', '        uint256 inv = investors[_who];\n', '\n', '        if (inv == 0) // new investor\n', '        {\n', '            investorsIter[numberOfInvestors++] = _who;\n', '        }\n', '\n', '        inv = add( inv, _tokens );\n', '        balances[_who] = add( balances[_who], _tokens );\n', '\n', '        Transfer(this, _who, _tokens);\n', '\n', '        totalSupply = add( totalSupply, _tokens );\n', '    }\n', '\n', '\n', '    function mintTokensWithReferal(address _who, address _referal, uint256 _valueTokens) internal \n', '    {\n', '        uint256 refererTokens = _valueTokens * 5 / 100;\n', '\n', '        uint256 valueTokens = _valueTokens * 103 / 100;\n', '\n', '        mintTokens(_referal, refererTokens);\n', '\n', '        mintTokens(_who, valueTokens);\n', '    }\n', '    \n', '    function startTokensSale(\n', '            uint    _crowdsaleStartTime,\n', '            uint    _crowdsaleFinishTime,\n', '            uint256 _minimalSuccessTokens,\n', '            uint256 _etherPrice) public onlyOwner \n', '    {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '\n', '        crowdsaleStartTime  = _crowdsaleStartTime;\n', '        crowdsaleFinishTime = _crowdsaleFinishTime;\n', '\n', '        etherPrice = _etherPrice;\n', '        delete numberOfInvestors;\n', '        delete collectedTokens;\n', '\n', '        minimalSuccessTokens = _minimalSuccessTokens;\n', '\n', '        if (state == State.Disabled) \n', '        {\n', '            state = State.PreICO;\n', '        } \n', '        else \n', '        {\n', '            state = State.Crowdsale;\n', '        }\n', '\n', '        NewState(state);\n', '    }\n', '    \n', '    function timeToFinishTokensSale() public constant returns(uint256 t) \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        if (now > crowdsaleFinishTime) \n', '        {\n', '            t = 0;\n', '        } \n', '        else \n', '        {\n', '            t = crowdsaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishTokensSale(uint256 _investorsToProcess) public \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        require(now >= crowdsaleFinishTime || \n', '            (collectedTokens >= minimalSuccessTokens && msg.sender == owner));\n', '\n', '        if (collectedTokens < minimalSuccessTokens) \n', '        {\n', '            // Investors can get their ether calling withdrawBack() function\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) \n', '            {\n', '                address addr = investorsIter[--numberOfInvestors];\n', '                uint256 inv = investors[addr];\n', '                balances[addr] = sub( balances[addr], inv );\n', '                totalSupply = sub( totalSupply, inv );\n', '                Transfer(addr, this, inv);\n', '\n', '                --_investorsToProcess;\n', '\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '\n', '            if (numberOfInvestors > 0) \n', '            {\n', '                return;\n', '            }\n', '\n', '            if (state == State.PreICO) \n', '            {\n', '                state = State.Disabled;\n', '            } \n', '            else \n', '            {\n', '                state = State.CompletePreICO;\n', '            }\n', '        } \n', '        else \n', '        {\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) \n', '            {\n', '                --numberOfInvestors;\n', '                --_investorsToProcess;\n', '\n', '                address i = investorsIter[numberOfInvestors];\n', '\n', '                investors[i] = 0;\n', '\n', '                delete investors[i];\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '\n', '            if (numberOfInvestors > 0) \n', '            {\n', '                return;\n', '            }\n', '\n', '            if (state == State.PreICO) \n', '            {\n', '                state = State.CompletePreICO;\n', '            } \n', '            else \n', '            {\n', '                // Create additional tokens for owner (40% of complete totalSupply)\n', '                uint256 tokens = div( mul( 4, totalSupply ) , 6 );\n', '                balances[owner] = tokens;\n', '                totalSupply = add( totalSupply, tokens );\n', '                Transfer(this, owner, tokens);\n', '                state = State.Enabled;\n', '            }\n', '        }\n', '\n', '        NewState(state);\n', '    }\n', '    \n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() public \n', '    {\n', '        require(state == State.Disabled);\n', '\n', '        uint256 tokens = investors[msg.sender];\n', '        uint256 value = div( tokens, etherPrice );\n', '\n', '        if (value > 0) \n', '        {\n', '            investors[msg.sender] = 0;\n', '            require( msg.sender.call.gas(gasPrice).value(value)() );\n', '\n', '            totalSupply = sub( totalSupply, tokens );\n', '        }\n', '    }\n', '\n', '    \n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable \n', '{\n', '    address public owner;\n', '    address public newOwner;\n', '    \n', '    function Ownable() public \n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public \n', '    {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public \n', '    {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 \n', '{\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public;\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public;\n', '    function approve(address spender, uint256 value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function getDecimals() public constant returns(uint8);\n', '    function getTotalSupply() public constant returns(uint256 supply);\n', '}\n', '\n', '\n', '\n', 'contract IzubrToken is Ownable, ERC20, SafeMath \n', '{\n', "    string  public constant standard    = 'Token 0.1';\n", "    string  public constant name        = 'Izubr';\n", '    string  public constant symbol      = "IZR";\n', '    uint8   public constant decimals    = 18;\n', '    uint256 public constant tokenKoef = 1000000000000000000;\n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    uint       private constant gasPrice = 3000000;\n', '\n', '    uint256    public etherPrice;\n', '    uint256    public minimalSuccessTokens;\n', '    uint256    public collectedTokens;\n', '\n', '    enum    State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\n', '    event   NewState(State state);\n', '\n', '    State      public state = State.Disabled;\n', '    uint256    public crowdsaleStartTime;\n', '    uint256    public crowdsaleFinishTime;\n', '\n', '    mapping (address => uint256)  public investors;\n', '    mapping (uint256 => address)  public investorsIter;\n', '    uint256                       public numberOfInvestors;\n', '\n', '    modifier onlyTokenHolders \n', '    {\n', '        require(balances[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) \n', '    {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    modifier enabledState \n', '    {\n', '        require(state == State.Enabled);\n', '        _;\n', '    }\n', '\n', '    modifier enabledOrMigrationState \n', '    {\n', '        require(state == State.Enabled || state == State.Migration);\n', '        _;\n', '    }\n', '\n', '\n', '\n', '    function getDecimals() public constant returns(uint8)\n', '    {\n', '        return decimals;\n', '    }\n', '\n', '    function balanceOf(address who) public constant returns (uint256) \n', '    {\n', '        return balances[who];\n', '    }\n', '\n', '    function investorsCount() public constant returns (uint256) \n', '    {\n', '        return numberOfInvestors;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        public enabledState onlyPayloadSize(2 * 32) \n', '    {\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        balances[msg.sender] = sub( balances[msg.sender], _value );\n', '        balances[_to] = add( balances[_to], _value );\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public enabledState onlyPayloadSize(3 * 32) \n', '    {\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '\n', '        balances[_from] = sub( balances[_from], _value );\n', '        balances[_to] = add( balances[_to], _value );\n', '\n', '        allowed[_from][msg.sender] = sub( allowed[_from][msg.sender], _value );\n', '\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public enabledState \n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant enabledState\n', '        returns (uint256 remaining) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    \n', '    function () public payable\n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '\n', '        uint256 valueWei = msg.value;\n', '\n', '        uint256 price = currentPrice();\n', '\n', '        uint256 valueTokens = div( mul( valueWei, price ), 1 ether);\n', '\n', '        if( valueTokens > 33333*tokenKoef ) // 5 BTC\n', '        {\n', '            price = price * 112 / 100;\n', '            valueTokens = mul( valueWei, price );\n', '        }\n', '\n', '        require(valueTokens > 10*tokenKoef);\n', '\n', '\n', '        collectedTokens = add( collectedTokens, valueTokens );\n', '            \n', '        if(msg.data.length == 20) \n', '        {\n', '            address referer = bytesToAddress(bytes(msg.data));\n', '\n', '            require(referer != msg.sender);\n', '\n', '            mintTokensWithReferal(msg.sender, referer, valueTokens);\n', '        }\n', '        else\n', '        {\n', '            mintTokens(msg.sender, valueTokens);\n', '        }\n', '    }\n', '\n', '    function bytesToAddress(bytes source) internal pure returns(address) \n', '    {\n', '        uint result;\n', '        uint mul = 1;\n', '\n', '        for(uint i = 20; i > 0; i--) \n', '        {\n', '            result += uint8(source[i-1])*mul;\n', '            mul = mul*256;\n', '        }\n', '\n', '        return address(result);\n', '    }\n', '\n', '    function getTotalSupply() public constant returns(uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function depositTokens(address _who, uint256 _valueTokens) public onlyOwner \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '\n', '        uint256 bonus = currentBonus();\n', '        uint256 tokens = _valueTokens * (100 + bonus) / 100;\n', '\n', '        collectedTokens = add( collectedTokens, tokens );\n', '\n', '        mintTokens(_who, tokens);\n', '    }\n', '\n', '\n', '    function bonusForDate(uint date) public constant returns (uint256) \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        uint nday = (date - crowdsaleStartTime) / (1 days);\n', '\n', '        uint256 bonus = 0;\n', '\n', '        if (state == State.PreICO) \n', '        {\n', '            if( nday < 7*1 ) bonus = 100;\n', '            else\n', '            if( nday < 7*2 ) bonus = 80;\n', '            else\n', '            if( nday < 7*3 ) bonus = 70;\n', '            else\n', '            if( nday < 7*4 ) bonus = 60;\n', '            else\n', '            if( nday < 7*5 ) bonus = 50;\n', '            else             bonus = 40;\n', '        }\n', '        else\n', '        if (state == State.Crowdsale) \n', '        {\n', '            if( nday < 1 ) bonus = 20;\n', '            else\n', '            if( nday < 4 ) bonus = 15;\n', '            else\n', '            if( nday < 8 ) bonus = 10;\n', '            else\n', '            if( nday < 12 ) bonus = 5;\n', '        }\n', '\n', '        return bonus;\n', '    }\n', '\n', '    function currentBonus() public constant returns (uint256) \n', '    {\n', '        return bonusForDate(now);\n', '    }\n', '\n', '\n', '    function priceForDate(uint date) public constant returns (uint256) \n', '    {\n', '        uint256 bonus = bonusForDate(date);\n', '\n', '        return etherPrice * (100 + bonus) / 100;\n', '    }\n', '\n', '    function currentPrice() public constant returns (uint256) \n', '    {\n', '        return priceForDate(now);\n', '    }\n', '\n', '\n', '    function mintTokens(address _who, uint256 _tokens) internal \n', '    {\n', '        uint256 inv = investors[_who];\n', '\n', '        if (inv == 0) // new investor\n', '        {\n', '            investorsIter[numberOfInvestors++] = _who;\n', '        }\n', '\n', '        inv = add( inv, _tokens );\n', '        balances[_who] = add( balances[_who], _tokens );\n', '\n', '        Transfer(this, _who, _tokens);\n', '\n', '        totalSupply = add( totalSupply, _tokens );\n', '    }\n', '\n', '\n', '    function mintTokensWithReferal(address _who, address _referal, uint256 _valueTokens) internal \n', '    {\n', '        uint256 refererTokens = _valueTokens * 5 / 100;\n', '\n', '        uint256 valueTokens = _valueTokens * 103 / 100;\n', '\n', '        mintTokens(_referal, refererTokens);\n', '\n', '        mintTokens(_who, valueTokens);\n', '    }\n', '    \n', '    function startTokensSale(\n', '            uint    _crowdsaleStartTime,\n', '            uint    _crowdsaleFinishTime,\n', '            uint256 _minimalSuccessTokens,\n', '            uint256 _etherPrice) public onlyOwner \n', '    {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '\n', '        crowdsaleStartTime  = _crowdsaleStartTime;\n', '        crowdsaleFinishTime = _crowdsaleFinishTime;\n', '\n', '        etherPrice = _etherPrice;\n', '        delete numberOfInvestors;\n', '        delete collectedTokens;\n', '\n', '        minimalSuccessTokens = _minimalSuccessTokens;\n', '\n', '        if (state == State.Disabled) \n', '        {\n', '            state = State.PreICO;\n', '        } \n', '        else \n', '        {\n', '            state = State.Crowdsale;\n', '        }\n', '\n', '        NewState(state);\n', '    }\n', '    \n', '    function timeToFinishTokensSale() public constant returns(uint256 t) \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        if (now > crowdsaleFinishTime) \n', '        {\n', '            t = 0;\n', '        } \n', '        else \n', '        {\n', '            t = crowdsaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishTokensSale(uint256 _investorsToProcess) public \n', '    {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '\n', '        require(now >= crowdsaleFinishTime || \n', '            (collectedTokens >= minimalSuccessTokens && msg.sender == owner));\n', '\n', '        if (collectedTokens < minimalSuccessTokens) \n', '        {\n', '            // Investors can get their ether calling withdrawBack() function\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) \n', '            {\n', '                address addr = investorsIter[--numberOfInvestors];\n', '                uint256 inv = investors[addr];\n', '                balances[addr] = sub( balances[addr], inv );\n', '                totalSupply = sub( totalSupply, inv );\n', '                Transfer(addr, this, inv);\n', '\n', '                --_investorsToProcess;\n', '\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '\n', '            if (numberOfInvestors > 0) \n', '            {\n', '                return;\n', '            }\n', '\n', '            if (state == State.PreICO) \n', '            {\n', '                state = State.Disabled;\n', '            } \n', '            else \n', '            {\n', '                state = State.CompletePreICO;\n', '            }\n', '        } \n', '        else \n', '        {\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) \n', '            {\n', '                --numberOfInvestors;\n', '                --_investorsToProcess;\n', '\n', '                address i = investorsIter[numberOfInvestors];\n', '\n', '                investors[i] = 0;\n', '\n', '                delete investors[i];\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '\n', '            if (numberOfInvestors > 0) \n', '            {\n', '                return;\n', '            }\n', '\n', '            if (state == State.PreICO) \n', '            {\n', '                state = State.CompletePreICO;\n', '            } \n', '            else \n', '            {\n', '                // Create additional tokens for owner (40% of complete totalSupply)\n', '                uint256 tokens = div( mul( 4, totalSupply ) , 6 );\n', '                balances[owner] = tokens;\n', '                totalSupply = add( totalSupply, tokens );\n', '                Transfer(this, owner, tokens);\n', '                state = State.Enabled;\n', '            }\n', '        }\n', '\n', '        NewState(state);\n', '    }\n', '    \n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() public \n', '    {\n', '        require(state == State.Disabled);\n', '\n', '        uint256 tokens = investors[msg.sender];\n', '        uint256 value = div( tokens, etherPrice );\n', '\n', '        if (value > 0) \n', '        {\n', '            investors[msg.sender] = 0;\n', '            require( msg.sender.call.gas(gasPrice).value(value)() );\n', '\n', '            totalSupply = sub( totalSupply, tokens );\n', '        }\n', '    }\n', '\n', '    \n', '}']
