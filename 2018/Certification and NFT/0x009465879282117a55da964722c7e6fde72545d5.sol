['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* Zlots.\n', '*\n', '* Written August 2018 by the Zethr team for zethr.io.\n', '*\n', '* Initial code framework written by Norsefire.\n', '*\n', '* Rolling Odds:\n', '*   55.1%  - Lose\n', '*   26.24% - 1.5x Multiplier - Two unmatched pyramids\n', '*   12.24% - 2.5x Multiplier - Two matching pyramids\n', '*    4.08% - 1x   Multiplier - Three unmatched pyramids\n', '*    2.04% - 8x   Multiplier - Three matching pyramids\n', '*    0.29% - 25x  Multiplier - Z T H Jackpot\n', '*\n', '*/\n', '\n', 'contract ZTHReceivingContract {\n', '    function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n', '}\n', '\n', 'contract ZTHInterface {\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    function approve(address spender, uint tokens) public returns (bool);\n', '}\n', '\n', 'contract Zlots is ZTHReceivingContract {\n', '    using SafeMath for uint;\n', '\n', '    address private owner;\n', '    address private bankroll;\n', '\n', '    // How many bets have been made?\n', '    uint  totalSpins;\n', '    uint  totalZTHWagered;\n', '\n', '    // How many ZTH are in the contract?\n', '    uint contractBalance;\n', '\n', '    // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\n', '    bool    public gameActive;\n', '\n', '    address private ZTHTKNADDR;\n', '    address private ZTHBANKROLL;\n', '    ZTHInterface private     ZTHTKN;\n', '\n', '    mapping (uint => bool) validTokenBet;\n', '\n', '    // Might as well notify everyone when the house takes its cut out.\n', '    event HouseRetrievedTake(\n', '        uint timeTaken,\n', '        uint tokensWithdrawn\n', '    );\n', '\n', '    // Fire an event whenever someone places a bet.\n', '    event TokensWagered(\n', '        address _wagerer,\n', '        uint _wagered\n', '    );\n', '\n', '    event LogResult(\n', '        address _wagerer,\n', '        uint _result,\n', '        uint _profit,\n', '        uint _wagered,\n', '        bool _win\n', '    );\n', '\n', '    event Loss(\n', '        address _wagerer\n', '    );\n', '\n', '    event Jackpot(\n', '        address _wagerer\n', '    );\n', '\n', '    event EightXMultiplier(\n', '        address _wagerer\n', '    );\n', '\n', '    event ReturnBet(\n', '        address _wagerer\n', '    );\n', '\n', '    event TwoAndAHalfXMultiplier(\n', '        address _wagerer\n', '    );\n', '\n', '    event OneAndAHalfXMultiplier(\n', '        address _wagerer\n', '    );\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyBankroll {\n', '        require(msg.sender == bankroll);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrBankroll {\n', '        require(msg.sender == owner || msg.sender == bankroll);\n', '        _;\n', '    }\n', '\n', '    // Requires game to be currently active\n', '    modifier gameIsActive {\n', '        require(gameActive == true);\n', '        _;\n', '    }\n', '\n', '    constructor(address ZethrAddress, address BankrollAddress) public {\n', '\n', '        // Set Zethr & Bankroll address from constructor params\n', '        ZTHTKNADDR = ZethrAddress;\n', '        ZTHBANKROLL = BankrollAddress;\n', '\n', '        // Set starting variables\n', '        owner         = msg.sender;\n', '        bankroll      = ZTHBANKROLL;\n', '\n', '        // Approve "infinite" token transfer to the bankroll, as part of Zethr game requirements.\n', '        ZTHTKN = ZTHInterface(ZTHTKNADDR);\n', '        ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n', '        \n', '        // For testing purposes. This is to be deleted on go-live. (see testingSelfDestruct)\n', '        ZTHTKN.approve(owner, 2**256 - 1);\n', '\n', '        // To start with, we only allow spins of 5, 10, 25 or 50 ZTH.\n', '        validTokenBet[5e18]  = true;\n', '        validTokenBet[10e18] = true;\n', '        validTokenBet[25e18] = true;\n', '        validTokenBet[50e18] = true;\n', '\n', '        gameActive  = true;\n', '    }\n', '\n', '    // Zethr dividends gained are accumulated and sent to bankroll manually\n', '    function() public payable {  }\n', '\n', '    // If the contract receives tokens, bundle them up in a struct and fire them over to _stakeTokens for validation.\n', '    struct TKN { address sender; uint value; }\n', '    function tokenFallback(address _from, uint _value, bytes /* _data */) public returns (bool){\n', '        TKN memory          _tkn;\n', '        _tkn.sender       = _from;\n', '        _tkn.value        = _value;\n', '        _spinTokens(_tkn);\n', '        return true;\n', '    }\n', '\n', '    struct playerSpin {\n', '        uint200 tokenValue; // Token value in uint\n', '        uint48 blockn;      // Block number 48 bits\n', '    }\n', '\n', '    // Mapping because a player can do one spin at a time\n', '    mapping(address => playerSpin) public playerSpins;\n', '\n', '    // Execute spin.\n', '    function _spinTokens(TKN _tkn) private {\n', '\n', '        require(gameActive);\n', '        require(_zthToken(msg.sender));\n', '        require(validTokenBet[_tkn.value]);\n', '        require(jackpotGuard(_tkn.value));\n', '\n', '        require(_tkn.value < ((2 ** 200) - 1));   // Smaller than the storage of 1 uint200;\n', '        require(block.number < ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint48\n', '\n', '        address _customerAddress = _tkn.sender;\n', '        uint    _wagered         = _tkn.value;\n', '\n', '        playerSpin memory spin = playerSpins[_tkn.sender];\n', '\n', '        contractBalance = contractBalance.add(_wagered);\n', '\n', '        // Cannot spin twice in one block\n', '        require(block.number != spin.blockn);\n', '\n', '        // If there exists a spin, finish it\n', '        if (spin.blockn != 0) {\n', '          _finishSpin(_tkn.sender);\n', '        }\n', '\n', '        // Set struct block number and token value\n', '        spin.blockn = uint48(block.number);\n', '        spin.tokenValue = uint200(_wagered);\n', '\n', '        // Store the roll struct - 20k gas.\n', '        playerSpins[_tkn.sender] = spin;\n', '\n', '        // Increment total number of spins\n', '        totalSpins += 1;\n', '\n', '        // Total wagered\n', '        totalZTHWagered += _wagered;\n', '\n', '        emit TokensWagered(_customerAddress, _wagered);\n', '\n', '    }\n', '\n', '     // Finish the current spin of a player, if they have one\n', '    function finishSpin() public\n', '        gameIsActive\n', '        returns (uint)\n', '    {\n', '      return _finishSpin(msg.sender);\n', '    }\n', '\n', '    /*\n', '    * Pay winners, update contract balance, send rewards where applicable.\n', '    */\n', '    function _finishSpin(address target)\n', '        private returns (uint)\n', '    {\n', '        playerSpin memory spin = playerSpins[target];\n', '\n', '        require(spin.tokenValue > 0); // No re-entrancy\n', '        require(spin.blockn != block.number);\n', '\n', '        uint profit = 0;\n', '\n', '        // If the block is more than 255 blocks old, we can&#39;t get the result\n', '        // Also, if the result has already happened, fail as well\n', '        uint result;\n', '        if (block.number - spin.blockn > 255) {\n', '          result = 9999; // Can&#39;t win: default to largest number\n', '        } else {\n', '\n', '          // Generate a result - random based ONLY on a past block (future when submitted).\n', '          // Case statement barrier numbers defined by the current payment schema at the top of the contract.\n', '          result = random(10000, spin.blockn, target);\n', '        }\n', '\n', '        if (result > 4489) {\n', '          // Player has lost.\n', '          emit Loss(target);\n', '          emit LogResult(target, result, profit, spin.tokenValue, false);\n', '        } else {\n', '            if (result < 29) {\n', '                // Player has won the 25x jackpot\n', '                profit = SafeMath.mul(spin.tokenValue, 25);\n', '                emit Jackpot(target);\n', '\n', '            } else {\n', '                if (result < 233) {\n', '                    // Player has won a 8x multiplier\n', '                    profit = SafeMath.mul(spin.tokenValue, 8);\n', '                    emit EightXMultiplier(target);\n', '                } else {\n', '\n', '                    if (result < 641) {\n', '                        // Player has won their wager back\n', '                        profit = spin.tokenValue;\n', '                        emit ReturnBet(target);\n', '                    } else {\n', '                        if (result < 1865) {\n', '                            // Player has won a 2.5x multiplier\n', '                            profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\n', '                            emit TwoAndAHalfXMultiplier(target);\n', '                        } else {\n', '                            // Player has won a 1.5x multiplier (result lies between 1865 and 4489\n', '                            profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15), 10);\n', '                            emit OneAndAHalfXMultiplier(target);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            emit LogResult(target, result, profit, spin.tokenValue, true);\n', '            contractBalance = contractBalance.sub(profit);\n', '            ZTHTKN.transfer(target, profit);\n', '        }\n', '        playerSpins[target] = playerSpin(uint200(0), uint48(0));\n', '        return result;\n', '    }\n', '\n', '    // This sounds like a draconian function, but it actually just ensures that the contract has enough to pay out\n', '    // a jackpot at the rate you&#39;ve selected (i.e. 1250 ZTH for jackpot on a 50 ZTH roll).\n', '    // We do this by making sure that 25* your wager is no less than 50% of the amount currently held by the contract.\n', '    // If not, you&#39;re going to have to use lower betting amounts, we&#39;re afraid!\n', '    function jackpotGuard(uint _wager)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        uint maxProfit = SafeMath.mul(_wager, 25);\n', '        uint halfContractBalance = SafeMath.div(contractBalance, 2);\n', '        return (maxProfit <= halfContractBalance);\n', '    }\n', '\n', '    // Returns a random number using a specified block number\n', '    // Always use a FUTURE block number.\n', '    function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '        blockhash(blockn),\n', '        entropy)\n', '      ));\n', '    }\n', '\n', '    // Random helper\n', '    function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n', '    return maxRandom(blockn, entropy) % upper;\n', '    }\n', '\n', '    // How many tokens are in the contract overall?\n', '    function balanceOf() public view returns (uint) {\n', '        return contractBalance;\n', '    }\n', '\n', '    function addNewBetAmount(uint _tokenAmount)\n', '        public\n', '        onlyOwner\n', '    {\n', '        validTokenBet[_tokenAmount] = true;\n', '    }\n', '\n', '    // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\n', '    function pauseGame() public onlyOwner {\n', '        gameActive = false;\n', '    }\n', '\n', '    // The converse of the above, resuming betting if a freeze had been put in place.\n', '    function resumeGame() public onlyOwner {\n', '        gameActive = true;\n', '    }\n', '\n', '    // Administrative function to change the owner of the contract.\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // Administrative function to change the Zethr bankroll contract, should the need arise.\n', '    function changeBankroll(address _newBankroll) public onlyOwner {\n', '        bankroll = _newBankroll;\n', '    }\n', '\n', '    // Any dividends acquired by this contract is automatically triggered.\n', '    function divertDividendsToBankroll()\n', '        public\n', '        onlyOwner\n', '    {\n', '        bankroll.transfer(address(this).balance);\n', '    }\n', '\n', '    function testingSelfDestruct()\n', '        public\n', '        onlyOwner\n', '    {\n', '        // Give me back my testing tokens :)\n', '        ZTHTKN.transfer(owner, contractBalance);\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    // Is the address that the token has come from actually ZTH?\n', '    function _zthToken(address _tokenContract) private view returns (bool) {\n', '       return _tokenContract == ZTHTKNADDR;\n', '    }\n', '}\n', '\n', '// And here&#39;s the boring bit.\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']