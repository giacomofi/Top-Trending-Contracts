['pragma solidity ^0.4.18;\n', '\n', 'contract Manager {\n', '    address public ceo;\n', '    address public cfo;\n', '    address public coo;\n', '    address public cao;\n', '\n', '    event OwnershipTransferred(address previousCeo, address newCeo);\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Manager() public {\n', '        coo = msg.sender; \n', '        cfo = 0x7810704C6197aFA95e940eF6F719dF32657AD5af;\n', '        ceo = 0x96C0815aF056c5294Ad368e3FBDb39a1c9Ae4e2B;\n', '        cao = 0xC4888491B404FfD15cA7F599D624b12a9D845725;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCOO() {\n', '        require(msg.sender == coo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCAO() {\n', '        require(msg.sender == cao);\n', '        _;\n', '    }\n', '    \n', '    bool allowTransfer = false;\n', '    \n', '    function changeAllowTransferState() public onlyCOO {\n', '        if (allowTransfer) {\n', '            allowTransfer = false;\n', '        } else {\n', '            allowTransfer = true;\n', '        }\n', '    }\n', '    \n', '    modifier whenTransferAllowed() {\n', '        require(allowTransfer);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newCeo.\n', '    * @param newCeo The address to transfer ownership to.\n', '    */\n', '    function demiseCEO(address newCeo) public onlyCEO {\n', '        require(newCeo != address(0));\n', '        emit OwnershipTransferred(ceo, newCeo);\n', '        ceo = newCeo;\n', '    }\n', '\n', '    function setCFO(address newCfo) public onlyCEO {\n', '        require(newCfo != address(0));\n', '        cfo = newCfo;\n', '    }\n', '\n', '    function setCOO(address newCoo) public onlyCEO {\n', '        require(newCoo != address(0));\n', '        coo = newCoo;\n', '    }\n', '\n', '    function setCAO(address newCao) public onlyCEO {\n', '        require(newCao != address(0));\n', '        cao = newCao;\n', '    }\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyCAO whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyCAO whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract SkinBase is Manager {\n', '\n', '    struct Skin {\n', '        uint128 appearance;\n', '        uint64 cooldownEndTime;\n', '        uint64 mixingWithId;\n', '    }\n', '\n', '    // All skins, mapping from skin id to skin apprance\n', '    mapping (uint256 => Skin) skins;\n', '\n', '    // Mapping from skin id to owner\n', '    mapping (uint256 => address) public skinIdToOwner;\n', '\n', '    // Whether a skin is on sale\n', '    mapping (uint256 => bool) public isOnSale;\n', '\n', '    // Using \n', '    mapping (address => uint256) public accountsToActiveSkin;\n', '\n', '    // Number of all total valid skins\n', '    // skinId 0 should not correspond to any skin, because skin.mixingWithId==0 indicates not mixing\n', '    uint256 public nextSkinId = 1;  \n', '\n', '    // Number of skins an account owns\n', '    mapping (address => uint256) public numSkinOfAccounts;\n', '\n', '    event SkinTransfer(address from, address to, uint256 skinId);\n', '    event SetActiveSkin(address account, uint256 skinId);\n', '\n', '    // Get the i-th skin an account owns, for off-chain usage only\n', '    function skinOfAccountById(address account, uint256 id) external view returns (uint256) {\n', '        uint256 count = 0;\n', '        uint256 numSkinOfAccount = numSkinOfAccounts[account];\n', '        require(numSkinOfAccount > 0);\n', '        require(id < numSkinOfAccount);\n', '        for (uint256 i = 1; i < nextSkinId; i++) {\n', '            if (skinIdToOwner[i] == account) {\n', '                // This skin belongs to current account\n', '                if (count == id) {\n', '                    // This is the id-th skin of current account, a.k.a, what we need\n', '                    return i;\n', '                } \n', '                count++;\n', '            }\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Get skin by id\n', '    function getSkin(uint256 id) public view returns (uint128, uint64, uint64) {\n', '        require(id > 0);\n', '        require(id < nextSkinId);\n', '        Skin storage skin = skins[id];\n', '        return (skin.appearance, skin.cooldownEndTime, skin.mixingWithId);\n', '    }\n', '\n', '    function withdrawETH() external onlyCAO {\n', '        cfo.transfer(address(this).balance);\n', '    }\n', '    \n', '    function transferP2P(uint256 id, address targetAccount) whenTransferAllowed public {\n', '        require(skinIdToOwner[id] == msg.sender);\n', '        require(msg.sender != targetAccount);\n', '        skinIdToOwner[id] = targetAccount;\n', '        \n', '        numSkinOfAccounts[msg.sender] -= 1;\n', '        numSkinOfAccounts[targetAccount] += 1;\n', '        \n', '        // emit event\n', '        emit SkinTransfer(msg.sender, targetAccount, id);\n', '    }\n', '\n', '    function _isComplete(uint256 id) internal view returns (bool) {\n', '        uint128 _appearance = skins[id].appearance;\n', '        uint128 mask = uint128(65535);\n', '        uint128 _type = _appearance & mask;\n', '        uint128 maskedValue;\n', '        for (uint256 i = 1; i < 8; i++) {\n', '            mask = mask << 16;\n', '            maskedValue = (_appearance & mask) >> (16*i);\n', '            if (maskedValue != _type) {\n', '                return false;\n', '            }\n', '        } \n', '        return true;\n', '    }\n', '\n', '    function setActiveSkin(uint256 id) public {\n', '        require(skinIdToOwner[id] == msg.sender);\n', '        require(_isComplete(id));\n', '        require(isOnSale[id] == false);\n', '        require(skins[id].mixingWithId == 0);\n', '\n', '        accountsToActiveSkin[msg.sender] = id;\n', '        emit SetActiveSkin(msg.sender, id);\n', '    }\n', '\n', '    function getActiveSkin(address account) public view returns (uint128) {\n', '        uint256 activeId = accountsToActiveSkin[account];\n', '        if (activeId == 0) {\n', '            return uint128(0);\n', '        }\n', '        return (skins[activeId].appearance & uint128(65535));\n', '    }\n', '}\n', '\n', '\n', 'contract SkinMix is SkinBase {\n', '\n', '    // Mix formula\n', '    MixFormulaInterface public mixFormula;\n', '\n', '\n', '    // Pre-paid ether for synthesization, will be returned to user if the synthesization failed (minus gas).\n', '    uint256 public prePaidFee = 150000 * 5000000000; // (15w gas * 5 gwei)\n', '\n', '    bool public enableMix = false;\n', '\n', '    // Events\n', '    event MixStart(address account, uint256 skinAId, uint256 skinBId);\n', '    event AutoMix(address account, uint256 skinAId, uint256 skinBId, uint64 cooldownEndTime);\n', '    event MixSuccess(address account, uint256 skinId, uint256 skinAId, uint256 skinBId);\n', '\n', '    // Set mix formula contract address \n', '    function setMixFormulaAddress(address mixFormulaAddress) external onlyCOO {\n', '        mixFormula = MixFormulaInterface(mixFormulaAddress);\n', '    }\n', '\n', '    // setPrePaidFee: set advance amount, only owner can call this\n', '    function setPrePaidFee(uint256 newPrePaidFee) external onlyCOO {\n', '        prePaidFee = newPrePaidFee;\n', '    }\n', '\n', '    function changeMixEnable(bool newState) external onlyCOO {\n', '        enableMix = newState;\n', '    }\n', '\n', '    // _isCooldownReady: check whether cooldown period has been passed\n', '    function _isCooldownReady(uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        return (skins[skinAId].cooldownEndTime <= uint64(now)) && (skins[skinBId].cooldownEndTime <= uint64(now));\n', '    }\n', '\n', '    // _isNotMixing: check whether two skins are in another mixing process\n', '    function _isNotMixing(uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        return (skins[skinAId].mixingWithId == 0) && (skins[skinBId].mixingWithId == 0);\n', '    }\n', '\n', '    // _setCooldownTime: set new cooldown time\n', '    function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private {\n', '        uint256 end = now + 20 minutes;\n', '        // uint256 end = now;\n', '        skins[skinAId].cooldownEndTime = uint64(end);\n', '        skins[skinBId].cooldownEndTime = uint64(end);\n', '    }\n', '\n', '    // _isValidSkin: whether an account can mix using these skins\n', '    // Make sure two things:\n', '    // 1. these two skins do exist\n', '    // 2. this account owns these skins\n', '    function _isValidSkin(address account, uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        // Make sure those two skins belongs to this account\n', '        if (skinAId == skinBId) {\n', '            return false;\n', '        }\n', '        if ((skinAId == 0) || (skinBId == 0)) {\n', '            return false;\n', '        }\n', '        if ((skinAId >= nextSkinId) || (skinBId >= nextSkinId)) {\n', '            return false;\n', '        }\n', '        if (accountsToActiveSkin[account] == skinAId || accountsToActiveSkin[account] == skinBId) {\n', '            return false;\n', '        }\n', '        return (skinIdToOwner[skinAId] == account) && (skinIdToOwner[skinBId] == account);\n', '    }\n', '\n', '    // _isNotOnSale: whether a skin is not on sale\n', '    function _isNotOnSale(uint256 skinId) private view returns (bool) {\n', '        return (isOnSale[skinId] == false);\n', '    }\n', '\n', '    // mix  \n', '    function mix(uint256 skinAId, uint256 skinBId) public whenNotPaused {\n', '\n', '        require(enableMix == true);\n', '        // Check whether skins are valid\n', '        require(_isValidSkin(msg.sender, skinAId, skinBId));\n', '\n', '        // Check whether skins are neither on sale\n', '        require(_isNotOnSale(skinAId) && _isNotOnSale(skinBId));\n', '\n', '        // Check cooldown\n', '        require(_isCooldownReady(skinAId, skinBId));\n', '\n', '        // Check these skins are not in another process\n', '        require(_isNotMixing(skinAId, skinBId));\n', '\n', '        // Set new cooldown time\n', '        _setCooldownEndTime(skinAId, skinBId);\n', '\n', '        // Mark skins as in mixing\n', '        skins[skinAId].mixingWithId = uint64(skinBId);\n', '        skins[skinBId].mixingWithId = uint64(skinAId);\n', '\n', '        // Emit MixStart event\n', '        emit MixStart(msg.sender, skinAId, skinBId);\n', '    }\n', '\n', '    // Mixing auto\n', '    function mixAuto(uint256 skinAId, uint256 skinBId) public payable whenNotPaused {\n', '        require(msg.value >= prePaidFee);\n', '\n', '        mix(skinAId, skinBId);\n', '\n', '        Skin storage skin = skins[skinAId];\n', '\n', '        emit AutoMix(msg.sender, skinAId, skinBId, skin.cooldownEndTime);\n', '    }\n', '\n', '    // Get mixing result, return the resulted skin id\n', '    function getMixingResult(uint256 skinAId, uint256 skinBId) public whenNotPaused {\n', '        // Check these two skins belongs to the same account\n', '        address account = skinIdToOwner[skinAId];\n', '        require(account == skinIdToOwner[skinBId]);\n', '\n', '        // Check these two skins are in the same mixing process\n', '        Skin storage skinA = skins[skinAId];\n', '        Skin storage skinB = skins[skinBId];\n', '        require(skinA.mixingWithId == uint64(skinBId));\n', '        require(skinB.mixingWithId == uint64(skinAId));\n', '\n', '        // Check cooldown\n', '        require(_isCooldownReady(skinAId, skinBId));\n', '\n', '        // Create new skin\n', '        uint128 newSkinAppearance = mixFormula.calcNewSkinAppearance(skinA.appearance, skinB.appearance, getActiveSkin(account));\n', '        Skin memory newSkin = Skin({appearance: newSkinAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = account;\n', '        isOnSale[nextSkinId] = false;\n', '        nextSkinId++;\n', '\n', '        // Clear old skins\n', '        skinA.mixingWithId = 0;\n', '        skinB.mixingWithId = 0;\n', '\n', '        // In order to distinguish created skins in minting with destroyed skins\n', '        // skinIdToOwner[skinAId] = owner;\n', '        // skinIdToOwner[skinBId] = owner;\n', '        delete skinIdToOwner[skinAId];\n', '        delete skinIdToOwner[skinBId];\n', '        // require(numSkinOfAccounts[account] >= 2);\n', '        numSkinOfAccounts[account] -= 1;\n', '\n', '        emit MixSuccess(account, nextSkinId - 1, skinAId, skinBId);\n', '    }\n', '}\n', '\n', '\n', 'contract MixFormulaInterface {\n', '    function calcNewSkinAppearance(uint128 x, uint128 y, uint128 addition) public returns (uint128);\n', '\n', '    // create random appearance\n', '    function randomSkinAppearance(uint256 externalNum, uint128 addition) public returns (uint128);\n', '\n', '    // bleach\n', '    function bleachAppearance(uint128 appearance, uint128 attributes) public returns (uint128);\n', '\n', '    // recycle\n', '    function recycleAppearance(uint128[5] appearances, uint256 preference, uint128 addition) public returns (uint128);\n', '\n', '    // summon10\n', '    function summon10SkinAppearance(uint256 externalNum, uint128 addition) public returns (uint128);\n', '}\n', '\n', '\n', 'contract SkinMarket is SkinMix {\n', '\n', '    // Cut ratio for a transaction\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint128 public trCut = 400;\n', '\n', '    // Sale orders list \n', '    mapping (uint256 => uint256) public desiredPrice;\n', '\n', '    // events\n', '    event PutOnSale(address account, uint256 skinId);\n', '    event WithdrawSale(address account, uint256 skinId);\n', '    event BuyInMarket(address buyer, uint256 skinId);\n', '\n', '    // functions\n', '\n', '    function setTrCut(uint256 newCut) external onlyCOO {\n', '        trCut = uint128(newCut);\n', '    }\n', '\n', '    // Put asset on sale\n', '    function putOnSale(uint256 skinId, uint256 price) public whenNotPaused {\n', '        // Only owner of skin pass\n', '        require(skinIdToOwner[skinId] == msg.sender);\n', '        require(accountsToActiveSkin[msg.sender] != skinId);\n', '\n', '        // Check whether skin is mixing \n', '        require(skins[skinId].mixingWithId == 0);\n', '\n', '        // Check whether skin is already on sale\n', '        require(isOnSale[skinId] == false);\n', '\n', '        require(price > 0); \n', '\n', '        // Put on sale\n', '        desiredPrice[skinId] = price;\n', '        isOnSale[skinId] = true;\n', '\n', '        // Emit the Approval event\n', '        emit PutOnSale(msg.sender, skinId);\n', '    }\n', '  \n', '    // Withdraw an sale order\n', '    function withdrawSale(uint256 skinId) external whenNotPaused {\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == true);\n', '        \n', '        // Can only withdraw self&#39;s sale\n', '        require(skinIdToOwner[skinId] == msg.sender);\n', '\n', '        // Withdraw\n', '        isOnSale[skinId] = false;\n', '        desiredPrice[skinId] = 0;\n', '\n', '        // Emit the cancel event\n', '        emit WithdrawSale(msg.sender, skinId);\n', '    }\n', ' \n', '    // Buy skin in market\n', '    function buyInMarket(uint256 skinId) external payable whenNotPaused {\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == true);\n', '\n', '        address seller = skinIdToOwner[skinId];\n', '\n', '        // Check the sender isn&#39;t the seller\n', '        require(msg.sender != seller);\n', '\n', '        uint256 _price = desiredPrice[skinId];\n', '        // Check whether pay value is enough\n', '        require(msg.value >= _price);\n', '\n', '        // Cut and then send the proceeds to seller\n', '        uint256 sellerProceeds = _price - _computeCut(_price);\n', '\n', '        seller.transfer(sellerProceeds);\n', '\n', '        // Transfer skin from seller to buyer\n', '        numSkinOfAccounts[seller] -= 1;\n', '        skinIdToOwner[skinId] = msg.sender;\n', '        numSkinOfAccounts[msg.sender] += 1;\n', '        isOnSale[skinId] = false;\n', '        desiredPrice[skinId] = 0;\n', '\n', '        // Emit the buy event\n', '        emit BuyInMarket(msg.sender, skinId);\n', '    }\n', '\n', '    // Compute the marketCut\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price / 10000 * trCut;\n', '    }\n', '}\n', '\n', '\n', 'contract SkinMinting is SkinMarket {\n', '\n', '    // Limits the number of skins the contract owner can ever create.\n', '    uint256 public skinCreatedLimit = 50000;\n', '    uint256 public skinCreatedNum;\n', '\n', '    // The summon and bleach numbers of each accounts: will be cleared every day\n', '    mapping (address => uint256) public accountToSummonNum;\n', '    mapping (address => uint256) public accountToBleachNum;\n', '\n', '    // Pay level of each accounts\n', '    mapping (address => uint256) public accountToPayLevel;\n', '    mapping (address => uint256) public accountLastClearTime;\n', '    mapping (address => uint256) public bleachLastClearTime;\n', '\n', '    // Free bleach number donated\n', '    mapping (address => uint256) public freeBleachNum;\n', '    bool isBleachAllowed = false;\n', '    bool isRecycleAllowed = false;\n', '\n', '    uint256 public levelClearTime = now;\n', '\n', '    // price and limit\n', '    uint256 public bleachDailyLimit = 3;\n', '    uint256 public baseSummonPrice = 1 finney;\n', '    uint256 public bleachPrice = 100 ether;  // do not call this\n', '\n', '    // Pay level\n', '    uint256[5] public levelSplits = [10,\n', '                                     20,\n', '                                     50,\n', '                                     100,\n', '                                     200];\n', '\n', '    uint256[6] public payMultiple = [10,\n', '                                     12,\n', '                                     15,\n', '                                     20,\n', '                                     30,\n', '                                     40];\n', '\n', '\n', '    // events\n', '    event CreateNewSkin(uint256 skinId, address account);\n', '    event Bleach(uint256 skinId, uint128 newAppearance);\n', '    event Recycle(uint256 skinId0, uint256 skinId1, uint256 skinId2, uint256 skinId3, uint256 skinId4, uint256 newSkinId);\n', '\n', '    // functions\n', '\n', '    // Set price\n', '    function setBaseSummonPrice(uint256 newPrice) external onlyCOO {\n', '        baseSummonPrice = newPrice;\n', '    }\n', '\n', '    function setBleachPrice(uint256 newPrice) external onlyCOO {\n', '        bleachPrice = newPrice;\n', '    }\n', '\n', '    function setBleachDailyLimit(uint256 limit) external onlyCOO {\n', '        bleachDailyLimit = limit;\n', '    }\n', '\n', '    function switchBleachAllowed(bool newBleachAllowed) external onlyCOO {\n', '        isBleachAllowed = newBleachAllowed;\n', '    }\n', '\n', '    function switchRecycleAllowed(bool newRecycleAllowed) external onlyCOO {\n', '        isRecycleAllowed = newRecycleAllowed;\n', '    }\n', '\n', '    // Create base skin for sell. Only owner can create\n', '    function createSkin(uint128 specifiedAppearance, uint256 salePrice) external onlyCOO {\n', '        require(skinCreatedNum < skinCreatedLimit);\n', '\n', '        // Create specified skin\n', '        // uint128 randomAppearance = mixFormula.randomSkinAppearance();\n', '        Skin memory newSkin = Skin({appearance: specifiedAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = coo;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, coo);\n', '\n', '        // Put this skin on sale\n', '        putOnSale(nextSkinId, salePrice);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[coo] += 1;\n', '        skinCreatedNum += 1;\n', '    }\n', '\n', '    // Donate a skin to player. Only COO can operate\n', '    function donateSkin(uint128 specifiedAppearance, address donee) external whenNotPaused onlyCOO {\n', '        Skin memory newSkin = Skin({appearance: specifiedAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = donee;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, donee);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[donee] += 1;\n', '        skinCreatedNum += 1;\n', '    }\n', '\n', '    //\n', '    function moveData(uint128[] legacyAppearance, address[] legacyOwner, bool[] legacyIsOnSale, uint256[] legacyDesiredPrice) external onlyCOO {\n', '        Skin memory newSkin = Skin({appearance: 0, cooldownEndTime: 0, mixingWithId: 0});\n', '        for (uint256 i = 0; i < legacyOwner.length; i++) {\n', '            newSkin.appearance = legacyAppearance[i];\n', '            newSkin.cooldownEndTime = uint64(now);\n', '            newSkin.mixingWithId = 0;\n', '\n', '            skins[nextSkinId] = newSkin;\n', '            skinIdToOwner[nextSkinId] = legacyOwner[i];\n', '            isOnSale[nextSkinId] = legacyIsOnSale[i];\n', '            desiredPrice[nextSkinId] = legacyDesiredPrice[i];\n', '\n', '            // Emit the create event\n', '            emit CreateNewSkin(nextSkinId, legacyOwner[i]);\n', '\n', '            nextSkinId++;\n', '            numSkinOfAccounts[legacyOwner[i]] += 1;\n', '            if (numSkinOfAccounts[legacyOwner[i]] > freeBleachNum[legacyOwner[i]]*10 || freeBleachNum[legacyOwner[i]] == 0) {\n', '                freeBleachNum[legacyOwner[i]] += 1;\n', '            }\n', '            skinCreatedNum += 1;\n', '        }\n', '    }\n', '\n', '    // Summon\n', '    function summon() external payable whenNotPaused {\n', '        // Clear daily summon numbers\n', '        if (accountLastClearTime[msg.sender] == uint256(0)) {\n', '            // This account&#39;s first time to summon, we do not need to clear summon numbers\n', '            accountLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (accountLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToSummonNum[msg.sender] = 0;\n', '                accountToPayLevel[msg.sender] = 0;\n', '                accountLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        uint256 payLevel = accountToPayLevel[msg.sender];\n', '        uint256 price = payMultiple[payLevel] * baseSummonPrice;\n', '        require(msg.value >= price);\n', '\n', '        // Create random skin\n', '        uint128 randomAppearance = mixFormula.randomSkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '        // uint128 randomAppearance = 0;\n', '        Skin memory newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, msg.sender);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[msg.sender] += 1;\n', '\n', '        accountToSummonNum[msg.sender] += 1;\n', '\n', '        // Handle the paylevel\n', '        if (payLevel < 5) {\n', '            if (accountToSummonNum[msg.sender] >= levelSplits[payLevel]) {\n', '                accountToPayLevel[msg.sender] = payLevel + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Summon10\n', '    function summon10() external payable whenNotPaused {\n', '        // Clear daily summon numbers\n', '        if (accountLastClearTime[msg.sender] == uint256(0)) {\n', '            // This account&#39;s first time to summon, we do not need to clear summon numbers\n', '            accountLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (accountLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToSummonNum[msg.sender] = 0;\n', '                accountToPayLevel[msg.sender] = 0;\n', '                accountLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        uint256 payLevel = accountToPayLevel[msg.sender];\n', '        uint256 price = payMultiple[payLevel] * baseSummonPrice;\n', '        require(msg.value >= price*10);\n', '\n', '        Skin memory newSkin;\n', '        uint128 randomAppearance;\n', '        // Create random skin\n', '        for (uint256 i = 0; i < 10; i++) {\n', '            randomAppearance = mixFormula.randomSkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '            newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '            skins[nextSkinId] = newSkin;\n', '            skinIdToOwner[nextSkinId] = msg.sender;\n', '            isOnSale[nextSkinId] = false;\n', '            // Emit the create event\n', '            emit CreateNewSkin(nextSkinId, msg.sender);\n', '            nextSkinId++;\n', '        }\n', '\n', '        // Give additional skin\n', '        randomAppearance = mixFormula.summon10SkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '        newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, msg.sender);\n', '        nextSkinId++;\n', '\n', '        numSkinOfAccounts[msg.sender] += 11;\n', '        accountToSummonNum[msg.sender] += 10;\n', '\n', '        // Handle the paylevel\n', '        if (payLevel < 5) {\n', '            if (accountToSummonNum[msg.sender] >= levelSplits[payLevel]) {\n', '                accountToPayLevel[msg.sender] = payLevel + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Recycle bin\n', '    function recycleSkin(uint256[5] wasteSkins, uint256 preferIndex) external whenNotPaused {\n', '        require(isRecycleAllowed == true);\n', '        for (uint256 i = 0; i < 5; i++) {\n', '            require(skinIdToOwner[wasteSkins[i]] == msg.sender);\n', '            skinIdToOwner[wasteSkins[i]] = address(0);\n', '        }\n', '\n', '        uint128[5] memory apps;\n', '        for (i = 0; i < 5; i++) {\n', '            apps[i] = skins[wasteSkins[i]].appearance;\n', '        }\n', '        // Create random skin\n', '        uint128 recycleApp = mixFormula.recycleAppearance(apps, preferIndex, getActiveSkin(msg.sender));\n', '        Skin memory newSkin = Skin({appearance: recycleApp, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit event\n', '        emit Recycle(wasteSkins[0], wasteSkins[1], wasteSkins[2], wasteSkins[3], wasteSkins[4], nextSkinId);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[msg.sender] -= 4;\n', '    }\n', '\n', '    // Bleach some attributes\n', '    function bleach(uint128 skinId, uint128 attributes) external payable whenNotPaused {\n', '        require(isBleachAllowed);\n', '\n', '        // Clear daily summon numbers\n', '        if (bleachLastClearTime[msg.sender] == uint256(0)) {\n', '            // This account&#39;s first time to summon, we do not need to clear bleach numbers\n', '            bleachLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (bleachLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToBleachNum[msg.sender] = 0;\n', '                bleachLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        require(accountToBleachNum[msg.sender] < bleachDailyLimit);\n', '        accountToBleachNum[msg.sender] += 1;\n', '\n', '        // Check whether msg.sender is owner of the skin\n', '        require(msg.sender == skinIdToOwner[skinId]);\n', '\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == false);\n', '\n', '        uint256 bleachNum = 0;\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            if ((attributes & (uint128(1) << i)) > 0) {\n', '                if (freeBleachNum[msg.sender] > 0) {\n', '                    freeBleachNum[msg.sender]--;\n', '                } else {\n', '                    bleachNum++;\n', '                }\n', '            }\n', '        }\n', '        // Check whether there is enough money\n', '        require(msg.value >= bleachNum * bleachPrice);\n', '\n', '        Skin storage originSkin = skins[skinId];\n', '        // Check whether this skin is in mixing\n', '        require(originSkin.mixingWithId == 0);\n', '\n', '        uint128 newAppearance = mixFormula.bleachAppearance(originSkin.appearance, attributes);\n', '        originSkin.appearance = newAppearance;\n', '\n', '        // Emit bleach event\n', '        emit Bleach(skinId, newAppearance);\n', '    }\n', '\n', '    // Our daemon will clear daily summon numbers\n', '    function clearSummonNum() external onlyCOO {\n', '        uint256 nextDay = levelClearTime + 1 days;\n', '        if (now > nextDay) {\n', '            levelClearTime = nextDay;\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Manager {\n', '    address public ceo;\n', '    address public cfo;\n', '    address public coo;\n', '    address public cao;\n', '\n', '    event OwnershipTransferred(address previousCeo, address newCeo);\n', '    event Pause();\n', '    event Unpause();\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Manager() public {\n', '        coo = msg.sender; \n', '        cfo = 0x7810704C6197aFA95e940eF6F719dF32657AD5af;\n', '        ceo = 0x96C0815aF056c5294Ad368e3FBDb39a1c9Ae4e2B;\n', '        cao = 0xC4888491B404FfD15cA7F599D624b12a9D845725;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCOO() {\n', '        require(msg.sender == coo);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCAO() {\n', '        require(msg.sender == cao);\n', '        _;\n', '    }\n', '    \n', '    bool allowTransfer = false;\n', '    \n', '    function changeAllowTransferState() public onlyCOO {\n', '        if (allowTransfer) {\n', '            allowTransfer = false;\n', '        } else {\n', '            allowTransfer = true;\n', '        }\n', '    }\n', '    \n', '    modifier whenTransferAllowed() {\n', '        require(allowTransfer);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newCeo.\n', '    * @param newCeo The address to transfer ownership to.\n', '    */\n', '    function demiseCEO(address newCeo) public onlyCEO {\n', '        require(newCeo != address(0));\n', '        emit OwnershipTransferred(ceo, newCeo);\n', '        ceo = newCeo;\n', '    }\n', '\n', '    function setCFO(address newCfo) public onlyCEO {\n', '        require(newCfo != address(0));\n', '        cfo = newCfo;\n', '    }\n', '\n', '    function setCOO(address newCoo) public onlyCEO {\n', '        require(newCoo != address(0));\n', '        coo = newCoo;\n', '    }\n', '\n', '    function setCAO(address newCao) public onlyCEO {\n', '        require(newCao != address(0));\n', '        cao = newCao;\n', '    }\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyCAO whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyCAO whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract SkinBase is Manager {\n', '\n', '    struct Skin {\n', '        uint128 appearance;\n', '        uint64 cooldownEndTime;\n', '        uint64 mixingWithId;\n', '    }\n', '\n', '    // All skins, mapping from skin id to skin apprance\n', '    mapping (uint256 => Skin) skins;\n', '\n', '    // Mapping from skin id to owner\n', '    mapping (uint256 => address) public skinIdToOwner;\n', '\n', '    // Whether a skin is on sale\n', '    mapping (uint256 => bool) public isOnSale;\n', '\n', '    // Using \n', '    mapping (address => uint256) public accountsToActiveSkin;\n', '\n', '    // Number of all total valid skins\n', '    // skinId 0 should not correspond to any skin, because skin.mixingWithId==0 indicates not mixing\n', '    uint256 public nextSkinId = 1;  \n', '\n', '    // Number of skins an account owns\n', '    mapping (address => uint256) public numSkinOfAccounts;\n', '\n', '    event SkinTransfer(address from, address to, uint256 skinId);\n', '    event SetActiveSkin(address account, uint256 skinId);\n', '\n', '    // Get the i-th skin an account owns, for off-chain usage only\n', '    function skinOfAccountById(address account, uint256 id) external view returns (uint256) {\n', '        uint256 count = 0;\n', '        uint256 numSkinOfAccount = numSkinOfAccounts[account];\n', '        require(numSkinOfAccount > 0);\n', '        require(id < numSkinOfAccount);\n', '        for (uint256 i = 1; i < nextSkinId; i++) {\n', '            if (skinIdToOwner[i] == account) {\n', '                // This skin belongs to current account\n', '                if (count == id) {\n', '                    // This is the id-th skin of current account, a.k.a, what we need\n', '                    return i;\n', '                } \n', '                count++;\n', '            }\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Get skin by id\n', '    function getSkin(uint256 id) public view returns (uint128, uint64, uint64) {\n', '        require(id > 0);\n', '        require(id < nextSkinId);\n', '        Skin storage skin = skins[id];\n', '        return (skin.appearance, skin.cooldownEndTime, skin.mixingWithId);\n', '    }\n', '\n', '    function withdrawETH() external onlyCAO {\n', '        cfo.transfer(address(this).balance);\n', '    }\n', '    \n', '    function transferP2P(uint256 id, address targetAccount) whenTransferAllowed public {\n', '        require(skinIdToOwner[id] == msg.sender);\n', '        require(msg.sender != targetAccount);\n', '        skinIdToOwner[id] = targetAccount;\n', '        \n', '        numSkinOfAccounts[msg.sender] -= 1;\n', '        numSkinOfAccounts[targetAccount] += 1;\n', '        \n', '        // emit event\n', '        emit SkinTransfer(msg.sender, targetAccount, id);\n', '    }\n', '\n', '    function _isComplete(uint256 id) internal view returns (bool) {\n', '        uint128 _appearance = skins[id].appearance;\n', '        uint128 mask = uint128(65535);\n', '        uint128 _type = _appearance & mask;\n', '        uint128 maskedValue;\n', '        for (uint256 i = 1; i < 8; i++) {\n', '            mask = mask << 16;\n', '            maskedValue = (_appearance & mask) >> (16*i);\n', '            if (maskedValue != _type) {\n', '                return false;\n', '            }\n', '        } \n', '        return true;\n', '    }\n', '\n', '    function setActiveSkin(uint256 id) public {\n', '        require(skinIdToOwner[id] == msg.sender);\n', '        require(_isComplete(id));\n', '        require(isOnSale[id] == false);\n', '        require(skins[id].mixingWithId == 0);\n', '\n', '        accountsToActiveSkin[msg.sender] = id;\n', '        emit SetActiveSkin(msg.sender, id);\n', '    }\n', '\n', '    function getActiveSkin(address account) public view returns (uint128) {\n', '        uint256 activeId = accountsToActiveSkin[account];\n', '        if (activeId == 0) {\n', '            return uint128(0);\n', '        }\n', '        return (skins[activeId].appearance & uint128(65535));\n', '    }\n', '}\n', '\n', '\n', 'contract SkinMix is SkinBase {\n', '\n', '    // Mix formula\n', '    MixFormulaInterface public mixFormula;\n', '\n', '\n', '    // Pre-paid ether for synthesization, will be returned to user if the synthesization failed (minus gas).\n', '    uint256 public prePaidFee = 150000 * 5000000000; // (15w gas * 5 gwei)\n', '\n', '    bool public enableMix = false;\n', '\n', '    // Events\n', '    event MixStart(address account, uint256 skinAId, uint256 skinBId);\n', '    event AutoMix(address account, uint256 skinAId, uint256 skinBId, uint64 cooldownEndTime);\n', '    event MixSuccess(address account, uint256 skinId, uint256 skinAId, uint256 skinBId);\n', '\n', '    // Set mix formula contract address \n', '    function setMixFormulaAddress(address mixFormulaAddress) external onlyCOO {\n', '        mixFormula = MixFormulaInterface(mixFormulaAddress);\n', '    }\n', '\n', '    // setPrePaidFee: set advance amount, only owner can call this\n', '    function setPrePaidFee(uint256 newPrePaidFee) external onlyCOO {\n', '        prePaidFee = newPrePaidFee;\n', '    }\n', '\n', '    function changeMixEnable(bool newState) external onlyCOO {\n', '        enableMix = newState;\n', '    }\n', '\n', '    // _isCooldownReady: check whether cooldown period has been passed\n', '    function _isCooldownReady(uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        return (skins[skinAId].cooldownEndTime <= uint64(now)) && (skins[skinBId].cooldownEndTime <= uint64(now));\n', '    }\n', '\n', '    // _isNotMixing: check whether two skins are in another mixing process\n', '    function _isNotMixing(uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        return (skins[skinAId].mixingWithId == 0) && (skins[skinBId].mixingWithId == 0);\n', '    }\n', '\n', '    // _setCooldownTime: set new cooldown time\n', '    function _setCooldownEndTime(uint256 skinAId, uint256 skinBId) private {\n', '        uint256 end = now + 20 minutes;\n', '        // uint256 end = now;\n', '        skins[skinAId].cooldownEndTime = uint64(end);\n', '        skins[skinBId].cooldownEndTime = uint64(end);\n', '    }\n', '\n', '    // _isValidSkin: whether an account can mix using these skins\n', '    // Make sure two things:\n', '    // 1. these two skins do exist\n', '    // 2. this account owns these skins\n', '    function _isValidSkin(address account, uint256 skinAId, uint256 skinBId) private view returns (bool) {\n', '        // Make sure those two skins belongs to this account\n', '        if (skinAId == skinBId) {\n', '            return false;\n', '        }\n', '        if ((skinAId == 0) || (skinBId == 0)) {\n', '            return false;\n', '        }\n', '        if ((skinAId >= nextSkinId) || (skinBId >= nextSkinId)) {\n', '            return false;\n', '        }\n', '        if (accountsToActiveSkin[account] == skinAId || accountsToActiveSkin[account] == skinBId) {\n', '            return false;\n', '        }\n', '        return (skinIdToOwner[skinAId] == account) && (skinIdToOwner[skinBId] == account);\n', '    }\n', '\n', '    // _isNotOnSale: whether a skin is not on sale\n', '    function _isNotOnSale(uint256 skinId) private view returns (bool) {\n', '        return (isOnSale[skinId] == false);\n', '    }\n', '\n', '    // mix  \n', '    function mix(uint256 skinAId, uint256 skinBId) public whenNotPaused {\n', '\n', '        require(enableMix == true);\n', '        // Check whether skins are valid\n', '        require(_isValidSkin(msg.sender, skinAId, skinBId));\n', '\n', '        // Check whether skins are neither on sale\n', '        require(_isNotOnSale(skinAId) && _isNotOnSale(skinBId));\n', '\n', '        // Check cooldown\n', '        require(_isCooldownReady(skinAId, skinBId));\n', '\n', '        // Check these skins are not in another process\n', '        require(_isNotMixing(skinAId, skinBId));\n', '\n', '        // Set new cooldown time\n', '        _setCooldownEndTime(skinAId, skinBId);\n', '\n', '        // Mark skins as in mixing\n', '        skins[skinAId].mixingWithId = uint64(skinBId);\n', '        skins[skinBId].mixingWithId = uint64(skinAId);\n', '\n', '        // Emit MixStart event\n', '        emit MixStart(msg.sender, skinAId, skinBId);\n', '    }\n', '\n', '    // Mixing auto\n', '    function mixAuto(uint256 skinAId, uint256 skinBId) public payable whenNotPaused {\n', '        require(msg.value >= prePaidFee);\n', '\n', '        mix(skinAId, skinBId);\n', '\n', '        Skin storage skin = skins[skinAId];\n', '\n', '        emit AutoMix(msg.sender, skinAId, skinBId, skin.cooldownEndTime);\n', '    }\n', '\n', '    // Get mixing result, return the resulted skin id\n', '    function getMixingResult(uint256 skinAId, uint256 skinBId) public whenNotPaused {\n', '        // Check these two skins belongs to the same account\n', '        address account = skinIdToOwner[skinAId];\n', '        require(account == skinIdToOwner[skinBId]);\n', '\n', '        // Check these two skins are in the same mixing process\n', '        Skin storage skinA = skins[skinAId];\n', '        Skin storage skinB = skins[skinBId];\n', '        require(skinA.mixingWithId == uint64(skinBId));\n', '        require(skinB.mixingWithId == uint64(skinAId));\n', '\n', '        // Check cooldown\n', '        require(_isCooldownReady(skinAId, skinBId));\n', '\n', '        // Create new skin\n', '        uint128 newSkinAppearance = mixFormula.calcNewSkinAppearance(skinA.appearance, skinB.appearance, getActiveSkin(account));\n', '        Skin memory newSkin = Skin({appearance: newSkinAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = account;\n', '        isOnSale[nextSkinId] = false;\n', '        nextSkinId++;\n', '\n', '        // Clear old skins\n', '        skinA.mixingWithId = 0;\n', '        skinB.mixingWithId = 0;\n', '\n', '        // In order to distinguish created skins in minting with destroyed skins\n', '        // skinIdToOwner[skinAId] = owner;\n', '        // skinIdToOwner[skinBId] = owner;\n', '        delete skinIdToOwner[skinAId];\n', '        delete skinIdToOwner[skinBId];\n', '        // require(numSkinOfAccounts[account] >= 2);\n', '        numSkinOfAccounts[account] -= 1;\n', '\n', '        emit MixSuccess(account, nextSkinId - 1, skinAId, skinBId);\n', '    }\n', '}\n', '\n', '\n', 'contract MixFormulaInterface {\n', '    function calcNewSkinAppearance(uint128 x, uint128 y, uint128 addition) public returns (uint128);\n', '\n', '    // create random appearance\n', '    function randomSkinAppearance(uint256 externalNum, uint128 addition) public returns (uint128);\n', '\n', '    // bleach\n', '    function bleachAppearance(uint128 appearance, uint128 attributes) public returns (uint128);\n', '\n', '    // recycle\n', '    function recycleAppearance(uint128[5] appearances, uint256 preference, uint128 addition) public returns (uint128);\n', '\n', '    // summon10\n', '    function summon10SkinAppearance(uint256 externalNum, uint128 addition) public returns (uint128);\n', '}\n', '\n', '\n', 'contract SkinMarket is SkinMix {\n', '\n', '    // Cut ratio for a transaction\n', '    // Values 0-10,000 map to 0%-100%\n', '    uint128 public trCut = 400;\n', '\n', '    // Sale orders list \n', '    mapping (uint256 => uint256) public desiredPrice;\n', '\n', '    // events\n', '    event PutOnSale(address account, uint256 skinId);\n', '    event WithdrawSale(address account, uint256 skinId);\n', '    event BuyInMarket(address buyer, uint256 skinId);\n', '\n', '    // functions\n', '\n', '    function setTrCut(uint256 newCut) external onlyCOO {\n', '        trCut = uint128(newCut);\n', '    }\n', '\n', '    // Put asset on sale\n', '    function putOnSale(uint256 skinId, uint256 price) public whenNotPaused {\n', '        // Only owner of skin pass\n', '        require(skinIdToOwner[skinId] == msg.sender);\n', '        require(accountsToActiveSkin[msg.sender] != skinId);\n', '\n', '        // Check whether skin is mixing \n', '        require(skins[skinId].mixingWithId == 0);\n', '\n', '        // Check whether skin is already on sale\n', '        require(isOnSale[skinId] == false);\n', '\n', '        require(price > 0); \n', '\n', '        // Put on sale\n', '        desiredPrice[skinId] = price;\n', '        isOnSale[skinId] = true;\n', '\n', '        // Emit the Approval event\n', '        emit PutOnSale(msg.sender, skinId);\n', '    }\n', '  \n', '    // Withdraw an sale order\n', '    function withdrawSale(uint256 skinId) external whenNotPaused {\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == true);\n', '        \n', "        // Can only withdraw self's sale\n", '        require(skinIdToOwner[skinId] == msg.sender);\n', '\n', '        // Withdraw\n', '        isOnSale[skinId] = false;\n', '        desiredPrice[skinId] = 0;\n', '\n', '        // Emit the cancel event\n', '        emit WithdrawSale(msg.sender, skinId);\n', '    }\n', ' \n', '    // Buy skin in market\n', '    function buyInMarket(uint256 skinId) external payable whenNotPaused {\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == true);\n', '\n', '        address seller = skinIdToOwner[skinId];\n', '\n', "        // Check the sender isn't the seller\n", '        require(msg.sender != seller);\n', '\n', '        uint256 _price = desiredPrice[skinId];\n', '        // Check whether pay value is enough\n', '        require(msg.value >= _price);\n', '\n', '        // Cut and then send the proceeds to seller\n', '        uint256 sellerProceeds = _price - _computeCut(_price);\n', '\n', '        seller.transfer(sellerProceeds);\n', '\n', '        // Transfer skin from seller to buyer\n', '        numSkinOfAccounts[seller] -= 1;\n', '        skinIdToOwner[skinId] = msg.sender;\n', '        numSkinOfAccounts[msg.sender] += 1;\n', '        isOnSale[skinId] = false;\n', '        desiredPrice[skinId] = 0;\n', '\n', '        // Emit the buy event\n', '        emit BuyInMarket(msg.sender, skinId);\n', '    }\n', '\n', '    // Compute the marketCut\n', '    function _computeCut(uint256 _price) internal view returns (uint256) {\n', '        return _price / 10000 * trCut;\n', '    }\n', '}\n', '\n', '\n', 'contract SkinMinting is SkinMarket {\n', '\n', '    // Limits the number of skins the contract owner can ever create.\n', '    uint256 public skinCreatedLimit = 50000;\n', '    uint256 public skinCreatedNum;\n', '\n', '    // The summon and bleach numbers of each accounts: will be cleared every day\n', '    mapping (address => uint256) public accountToSummonNum;\n', '    mapping (address => uint256) public accountToBleachNum;\n', '\n', '    // Pay level of each accounts\n', '    mapping (address => uint256) public accountToPayLevel;\n', '    mapping (address => uint256) public accountLastClearTime;\n', '    mapping (address => uint256) public bleachLastClearTime;\n', '\n', '    // Free bleach number donated\n', '    mapping (address => uint256) public freeBleachNum;\n', '    bool isBleachAllowed = false;\n', '    bool isRecycleAllowed = false;\n', '\n', '    uint256 public levelClearTime = now;\n', '\n', '    // price and limit\n', '    uint256 public bleachDailyLimit = 3;\n', '    uint256 public baseSummonPrice = 1 finney;\n', '    uint256 public bleachPrice = 100 ether;  // do not call this\n', '\n', '    // Pay level\n', '    uint256[5] public levelSplits = [10,\n', '                                     20,\n', '                                     50,\n', '                                     100,\n', '                                     200];\n', '\n', '    uint256[6] public payMultiple = [10,\n', '                                     12,\n', '                                     15,\n', '                                     20,\n', '                                     30,\n', '                                     40];\n', '\n', '\n', '    // events\n', '    event CreateNewSkin(uint256 skinId, address account);\n', '    event Bleach(uint256 skinId, uint128 newAppearance);\n', '    event Recycle(uint256 skinId0, uint256 skinId1, uint256 skinId2, uint256 skinId3, uint256 skinId4, uint256 newSkinId);\n', '\n', '    // functions\n', '\n', '    // Set price\n', '    function setBaseSummonPrice(uint256 newPrice) external onlyCOO {\n', '        baseSummonPrice = newPrice;\n', '    }\n', '\n', '    function setBleachPrice(uint256 newPrice) external onlyCOO {\n', '        bleachPrice = newPrice;\n', '    }\n', '\n', '    function setBleachDailyLimit(uint256 limit) external onlyCOO {\n', '        bleachDailyLimit = limit;\n', '    }\n', '\n', '    function switchBleachAllowed(bool newBleachAllowed) external onlyCOO {\n', '        isBleachAllowed = newBleachAllowed;\n', '    }\n', '\n', '    function switchRecycleAllowed(bool newRecycleAllowed) external onlyCOO {\n', '        isRecycleAllowed = newRecycleAllowed;\n', '    }\n', '\n', '    // Create base skin for sell. Only owner can create\n', '    function createSkin(uint128 specifiedAppearance, uint256 salePrice) external onlyCOO {\n', '        require(skinCreatedNum < skinCreatedLimit);\n', '\n', '        // Create specified skin\n', '        // uint128 randomAppearance = mixFormula.randomSkinAppearance();\n', '        Skin memory newSkin = Skin({appearance: specifiedAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = coo;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, coo);\n', '\n', '        // Put this skin on sale\n', '        putOnSale(nextSkinId, salePrice);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[coo] += 1;\n', '        skinCreatedNum += 1;\n', '    }\n', '\n', '    // Donate a skin to player. Only COO can operate\n', '    function donateSkin(uint128 specifiedAppearance, address donee) external whenNotPaused onlyCOO {\n', '        Skin memory newSkin = Skin({appearance: specifiedAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = donee;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, donee);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[donee] += 1;\n', '        skinCreatedNum += 1;\n', '    }\n', '\n', '    //\n', '    function moveData(uint128[] legacyAppearance, address[] legacyOwner, bool[] legacyIsOnSale, uint256[] legacyDesiredPrice) external onlyCOO {\n', '        Skin memory newSkin = Skin({appearance: 0, cooldownEndTime: 0, mixingWithId: 0});\n', '        for (uint256 i = 0; i < legacyOwner.length; i++) {\n', '            newSkin.appearance = legacyAppearance[i];\n', '            newSkin.cooldownEndTime = uint64(now);\n', '            newSkin.mixingWithId = 0;\n', '\n', '            skins[nextSkinId] = newSkin;\n', '            skinIdToOwner[nextSkinId] = legacyOwner[i];\n', '            isOnSale[nextSkinId] = legacyIsOnSale[i];\n', '            desiredPrice[nextSkinId] = legacyDesiredPrice[i];\n', '\n', '            // Emit the create event\n', '            emit CreateNewSkin(nextSkinId, legacyOwner[i]);\n', '\n', '            nextSkinId++;\n', '            numSkinOfAccounts[legacyOwner[i]] += 1;\n', '            if (numSkinOfAccounts[legacyOwner[i]] > freeBleachNum[legacyOwner[i]]*10 || freeBleachNum[legacyOwner[i]] == 0) {\n', '                freeBleachNum[legacyOwner[i]] += 1;\n', '            }\n', '            skinCreatedNum += 1;\n', '        }\n', '    }\n', '\n', '    // Summon\n', '    function summon() external payable whenNotPaused {\n', '        // Clear daily summon numbers\n', '        if (accountLastClearTime[msg.sender] == uint256(0)) {\n', "            // This account's first time to summon, we do not need to clear summon numbers\n", '            accountLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (accountLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToSummonNum[msg.sender] = 0;\n', '                accountToPayLevel[msg.sender] = 0;\n', '                accountLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        uint256 payLevel = accountToPayLevel[msg.sender];\n', '        uint256 price = payMultiple[payLevel] * baseSummonPrice;\n', '        require(msg.value >= price);\n', '\n', '        // Create random skin\n', '        uint128 randomAppearance = mixFormula.randomSkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '        // uint128 randomAppearance = 0;\n', '        Skin memory newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, msg.sender);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[msg.sender] += 1;\n', '\n', '        accountToSummonNum[msg.sender] += 1;\n', '\n', '        // Handle the paylevel\n', '        if (payLevel < 5) {\n', '            if (accountToSummonNum[msg.sender] >= levelSplits[payLevel]) {\n', '                accountToPayLevel[msg.sender] = payLevel + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Summon10\n', '    function summon10() external payable whenNotPaused {\n', '        // Clear daily summon numbers\n', '        if (accountLastClearTime[msg.sender] == uint256(0)) {\n', "            // This account's first time to summon, we do not need to clear summon numbers\n", '            accountLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (accountLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToSummonNum[msg.sender] = 0;\n', '                accountToPayLevel[msg.sender] = 0;\n', '                accountLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        uint256 payLevel = accountToPayLevel[msg.sender];\n', '        uint256 price = payMultiple[payLevel] * baseSummonPrice;\n', '        require(msg.value >= price*10);\n', '\n', '        Skin memory newSkin;\n', '        uint128 randomAppearance;\n', '        // Create random skin\n', '        for (uint256 i = 0; i < 10; i++) {\n', '            randomAppearance = mixFormula.randomSkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '            newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '            skins[nextSkinId] = newSkin;\n', '            skinIdToOwner[nextSkinId] = msg.sender;\n', '            isOnSale[nextSkinId] = false;\n', '            // Emit the create event\n', '            emit CreateNewSkin(nextSkinId, msg.sender);\n', '            nextSkinId++;\n', '        }\n', '\n', '        // Give additional skin\n', '        randomAppearance = mixFormula.summon10SkinAppearance(nextSkinId, getActiveSkin(msg.sender));\n', '        newSkin = Skin({appearance: randomAppearance, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '        // Emit the create event\n', '        emit CreateNewSkin(nextSkinId, msg.sender);\n', '        nextSkinId++;\n', '\n', '        numSkinOfAccounts[msg.sender] += 11;\n', '        accountToSummonNum[msg.sender] += 10;\n', '\n', '        // Handle the paylevel\n', '        if (payLevel < 5) {\n', '            if (accountToSummonNum[msg.sender] >= levelSplits[payLevel]) {\n', '                accountToPayLevel[msg.sender] = payLevel + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // Recycle bin\n', '    function recycleSkin(uint256[5] wasteSkins, uint256 preferIndex) external whenNotPaused {\n', '        require(isRecycleAllowed == true);\n', '        for (uint256 i = 0; i < 5; i++) {\n', '            require(skinIdToOwner[wasteSkins[i]] == msg.sender);\n', '            skinIdToOwner[wasteSkins[i]] = address(0);\n', '        }\n', '\n', '        uint128[5] memory apps;\n', '        for (i = 0; i < 5; i++) {\n', '            apps[i] = skins[wasteSkins[i]].appearance;\n', '        }\n', '        // Create random skin\n', '        uint128 recycleApp = mixFormula.recycleAppearance(apps, preferIndex, getActiveSkin(msg.sender));\n', '        Skin memory newSkin = Skin({appearance: recycleApp, cooldownEndTime: uint64(now), mixingWithId: 0});\n', '        skins[nextSkinId] = newSkin;\n', '        skinIdToOwner[nextSkinId] = msg.sender;\n', '        isOnSale[nextSkinId] = false;\n', '\n', '        // Emit event\n', '        emit Recycle(wasteSkins[0], wasteSkins[1], wasteSkins[2], wasteSkins[3], wasteSkins[4], nextSkinId);\n', '\n', '        nextSkinId++;\n', '        numSkinOfAccounts[msg.sender] -= 4;\n', '    }\n', '\n', '    // Bleach some attributes\n', '    function bleach(uint128 skinId, uint128 attributes) external payable whenNotPaused {\n', '        require(isBleachAllowed);\n', '\n', '        // Clear daily summon numbers\n', '        if (bleachLastClearTime[msg.sender] == uint256(0)) {\n', "            // This account's first time to summon, we do not need to clear bleach numbers\n", '            bleachLastClearTime[msg.sender] = now;\n', '        } else {\n', '            if (bleachLastClearTime[msg.sender] < levelClearTime && now > levelClearTime) {\n', '                accountToBleachNum[msg.sender] = 0;\n', '                bleachLastClearTime[msg.sender] = now;\n', '            }\n', '        }\n', '\n', '        require(accountToBleachNum[msg.sender] < bleachDailyLimit);\n', '        accountToBleachNum[msg.sender] += 1;\n', '\n', '        // Check whether msg.sender is owner of the skin\n', '        require(msg.sender == skinIdToOwner[skinId]);\n', '\n', '        // Check whether this skin is on sale\n', '        require(isOnSale[skinId] == false);\n', '\n', '        uint256 bleachNum = 0;\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            if ((attributes & (uint128(1) << i)) > 0) {\n', '                if (freeBleachNum[msg.sender] > 0) {\n', '                    freeBleachNum[msg.sender]--;\n', '                } else {\n', '                    bleachNum++;\n', '                }\n', '            }\n', '        }\n', '        // Check whether there is enough money\n', '        require(msg.value >= bleachNum * bleachPrice);\n', '\n', '        Skin storage originSkin = skins[skinId];\n', '        // Check whether this skin is in mixing\n', '        require(originSkin.mixingWithId == 0);\n', '\n', '        uint128 newAppearance = mixFormula.bleachAppearance(originSkin.appearance, attributes);\n', '        originSkin.appearance = newAppearance;\n', '\n', '        // Emit bleach event\n', '        emit Bleach(skinId, newAppearance);\n', '    }\n', '\n', '    // Our daemon will clear daily summon numbers\n', '    function clearSummonNum() external onlyCOO {\n', '        uint256 nextDay = levelClearTime + 1 days;\n', '        if (now > nextDay) {\n', '            levelClearTime = nextDay;\n', '        }\n', '    }\n', '}']
