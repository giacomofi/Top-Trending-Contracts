['contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', 'contract PIPOTFlip is Owner {\n', '  \n', '  uint256 lastHash;\n', '  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n', '  \n', '  // Game fee.\n', '  uint public fee = 5;\n', '  uint public multLevel1 = 0.01 ether;\n', '  uint public multLevel2 = 0.05 ether;\n', '  uint public multLevel3 = 0.1 ether;\n', '  \n', '  // Funds distributor address.\n', '  address public fundsDistributor;\n', '  \n', '  event Win(bool guess, uint amount, address winAddress, bool result);\n', '  event Lose(bool guess, uint amount, address winAddress, bool result);\n', '  \n', '  /**\n', '    * @dev Check sender address and compare it to an owner.\n', '    */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '    \n', '  function PIPOTFlip(address _fund) public Owner(msg.sender) {\n', '     fundsDistributor = _fund;\n', '  }\n', '  \n', '  function () external payable {\n', '        \n', '  }\n', '  \n', '  function claimEther() public onlyOwner() {\n', '      uint256 balance = address(this).balance;\n', '      fundsDistributor.transfer(balance);\n', '  }\n', '\n', '  function flip(bool _guess) public payable {\n', '    uint256 blockValue = uint256(block.blockhash(block.number-1));\n', '    require(msg.value >= multLevel1);\n', '    \n', '    if (lastHash == blockValue) {\n', '      revert();\n', '    }\n', '    \n', '    address player = msg.sender;\n', '    uint distribute = msg.value * fee / 100;\n', '    uint loseAmount = msg.value - distribute;\n', '    uint winAmount = 0;\n', '    \n', '    if(msg.value >= multLevel1 && msg.value < multLevel2){\n', '        winAmount = msg.value * 194/100;\n', '    }\n', '    \n', '    if(msg.value >= multLevel2 && msg.value < multLevel3){\n', '        winAmount = msg.value * 197/100;\n', '    }\n', '    \n', '    if(msg.value >= multLevel3){\n', '        winAmount = msg.value * 198/100;\n', '    }\n', '    \n', '    fundsDistributor.transfer(distribute);\n', '    \n', '    lastHash = blockValue;\n', '    uint256 coinFlip = blockValue / FACTOR;\n', '    bool side = coinFlip == 1 ? true : false;\n', '\n', '    if (side == _guess) {\n', '      player.transfer(winAmount);\n', '      emit Win(_guess, winAmount, msg.sender, side);\n', '    }\n', '    else{\n', '      fundsDistributor.transfer(loseAmount);  \n', '      emit Lose(_guess, msg.value, msg.sender, side);\n', '    }\n', '  }\n', '}']