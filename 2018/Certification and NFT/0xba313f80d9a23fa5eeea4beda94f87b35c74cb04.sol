['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() \n', '    public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) \n', '        onlyOwner \n', '    public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath32 {\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BalanceHolder {\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    event LogWithdraw(\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '\n', '    function withdraw() \n', '    public {\n', '        uint256 bal = balanceOf[msg.sender];\n', '        balanceOf[msg.sender] = 0;\n', '        msg.sender.transfer(bal);\n', '        LogWithdraw(msg.sender, bal);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract RealityCheck is BalanceHolder {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath32 for uint32;\n', '\n', '    address constant NULL_ADDRESS = address(0);\n', '\n', '    // History hash when no history is created, or history has been cleared\n', '    bytes32 constant NULL_HASH = bytes32(0);\n', '\n', '    // An unitinalized finalize_ts for a question will indicate an unanswered question.\n', '    uint32 constant UNANSWERED = 0;\n', '\n', '    // An unanswered reveal_ts for a commitment will indicate that it does not exist.\n', '    uint256 constant COMMITMENT_NON_EXISTENT = 0;\n', '\n', '    // Commit->reveal timeout is 1/8 of the question timeout (rounded down).\n', '    uint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\n', '\n', '    event LogSetQuestionFee(\n', '        address arbitrator,\n', '        uint256 amount\n', '    );\n', '\n', '    event LogNewTemplate(\n', '        uint256 indexed template_id,\n', '        address indexed user, \n', '        string question_text\n', '    );\n', '\n', '    event LogNewQuestion(\n', '        bytes32 indexed question_id,\n', '        address indexed user, \n', '        uint256 template_id,\n', '        string question,\n', '        bytes32 indexed content_hash,\n', '        address arbitrator, \n', '        uint32 timeout,\n', '        uint32 opening_ts,\n', '        uint256 nonce,\n', '        uint256 created\n', '    );\n', '\n', '    event LogFundAnswerBounty(\n', '        bytes32 indexed question_id,\n', '        uint256 bounty_added,\n', '        uint256 bounty,\n', '        address indexed user \n', '    );\n', '\n', '    event LogNewAnswer(\n', '        bytes32 answer,\n', '        bytes32 indexed question_id,\n', '        bytes32 history_hash,\n', '        address indexed user,\n', '        uint256 bond,\n', '        uint256 ts,\n', '        bool is_commitment\n', '    );\n', '\n', '    event LogAnswerReveal(\n', '        bytes32 indexed question_id, \n', '        address indexed user, \n', '        bytes32 indexed answer_hash, \n', '        bytes32 answer, \n', '        uint256 nonce, \n', '        uint256 bond\n', '    );\n', '\n', '    event LogNotifyOfArbitrationRequest(\n', '        bytes32 indexed question_id,\n', '        address indexed user \n', '    );\n', '\n', '    event LogFinalize(\n', '        bytes32 indexed question_id,\n', '        bytes32 indexed answer\n', '    );\n', '\n', '    event LogClaim(\n', '        bytes32 indexed question_id,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '\n', '    struct Question {\n', '        bytes32 content_hash;\n', '        address arbitrator;\n', '        uint32 opening_ts;\n', '        uint32 timeout;\n', '        uint32 finalize_ts;\n', '        bool is_pending_arbitration;\n', '        uint256 bounty;\n', '        bytes32 best_answer;\n', '        bytes32 history_hash;\n', '        uint256 bond;\n', '    }\n', '\n', '    // Stored in a mapping indexed by commitment_id, a hash of commitment hash, question, bond. \n', '    struct Commitment {\n', '        uint32 reveal_ts;\n', '        bool is_revealed;\n', '        bytes32 revealed_answer;\n', '    }\n', '\n', '    // Only used when claiming more bonds than fits into a transaction\n', '    // Stored in a mapping indexed by question_id.\n', '    struct Claim {\n', '        address payee;\n', '        uint256 last_bond;\n', '        uint256 queued_funds;\n', '    }\n', '\n', '    uint256 nextTemplateID = 0;\n', '    mapping(uint256 => uint256) public templates;\n', '    mapping(bytes32 => Question) public questions;\n', '    mapping(bytes32 => Claim) question_claims;\n', '    mapping(bytes32 => Commitment) public commitments;\n', '    mapping(address => uint256) public arbitrator_question_fees; \n', '\n', '    modifier onlyArbitrator(bytes32 question_id) {\n', '        require(msg.sender == questions[question_id].arbitrator);\n', '        _;\n', '    }\n', '\n', '    modifier stateAny() {\n', '        _;\n', '    }\n', '\n', '    modifier stateNotCreated(bytes32 question_id) {\n', '        require(questions[question_id].timeout == 0);\n', '        _;\n', '    }\n', '\n', '    modifier stateOpen(bytes32 question_id) {\n', '        require(questions[question_id].timeout > 0); // Check existence\n', '        require(!questions[question_id].is_pending_arbitration);\n', '        uint32 finalize_ts = questions[question_id].finalize_ts;\n', '        require(finalize_ts == UNANSWERED || finalize_ts > uint32(now));\n', '        uint32 opening_ts = questions[question_id].opening_ts;\n', '        require(opening_ts == 0 || opening_ts <= uint32(now)); \n', '        _;\n', '    }\n', '\n', '    modifier statePendingArbitration(bytes32 question_id) {\n', '        require(questions[question_id].is_pending_arbitration);\n', '        _;\n', '    }\n', '\n', '    modifier stateFinalized(bytes32 question_id) {\n', '        require(isFinalized(question_id));\n', '        _;\n', '    }\n', '\n', '    modifier bondMustBeZero() {\n', '        require(msg.value == 0);\n', '        _;\n', '    }\n', '\n', '    modifier bondMustDouble(bytes32 question_id) {\n', '        require(msg.value > 0); \n', '        require(msg.value >= (questions[question_id].bond.mul(2)));\n', '        _;\n', '    }\n', '\n', '    modifier previousBondMustNotBeatMaxPrevious(bytes32 question_id, uint256 max_previous) {\n', '        if (max_previous > 0) {\n', '            require(questions[question_id].bond <= max_previous);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor, sets up some initial templates\n', '    /// @dev Creates some generalized templates for different question types used in the DApp.\n', '    function RealityCheck() \n', '    public {\n', '        createTemplate(&#39;{"title": "%s", "type": "bool", "category": "%s"}&#39;);\n', '        createTemplate(&#39;{"title": "%s", "type": "uint", "decimals": 18, "category": "%s"}&#39;);\n', '        createTemplate(&#39;{"title": "%s", "type": "int", "decimals": 18, "category": "%s"}&#39;);\n', '        createTemplate(&#39;{"title": "%s", "type": "single-select", "outcomes": [%s], "category": "%s"}&#39;);\n', '        createTemplate(&#39;{"title": "%s", "type": "multiple-select", "outcomes": [%s], "category": "%s"}&#39;);\n', '        createTemplate(&#39;{"title": "%s", "type": "datetime", "category": "%s"}&#39;);\n', '    }\n', '\n', '    /// @notice Function for arbitrator to set an optional per-question fee. \n', '    /// @dev The per-question fee, charged when a question is asked, is intended as an anti-spam measure.\n', '    /// @param fee The fee to be charged by the arbitrator when a question is asked\n', '    function setQuestionFee(uint256 fee) \n', '        stateAny() \n', '    external {\n', '        arbitrator_question_fees[msg.sender] = fee;\n', '        LogSetQuestionFee(msg.sender, fee);\n', '    }\n', '\n', '    /// @notice Create a reusable template, which should be a JSON document.\n', '    /// Placeholders should use gettext() syntax, eg %s.\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param content The template content\n', '    /// @return The ID of the newly-created template, which is created sequentially.\n', '    function createTemplate(string content) \n', '        stateAny()\n', '    public returns (uint256) {\n', '        uint256 id = nextTemplateID;\n', '        templates[id] = block.number;\n', '        LogNewTemplate(id, msg.sender, content);\n', '        nextTemplateID = id.add(1);\n', '        return id;\n', '    }\n', '\n', '    /// @notice Create a new reusable template and use it to ask a question\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param content The template content\n', '    /// @param question A string containing the parameters that will be passed into the template to make the question\n', '    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\n', '    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\n', '    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\n', '    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\n', '    /// @return The ID of the newly-created template, which is created sequentially.\n', '    function createTemplateAndAskQuestion(\n', '        string content, \n', '        string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce \n', '    ) \n', '        // stateNotCreated is enforced by the internal _askQuestion\n', '    public payable returns (bytes32) {\n', '        uint256 template_id = createTemplate(content);\n', '        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\n', '    }\n', '\n', '    /// @notice Ask a new question and return the ID\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param template_id The ID number of the template the question will use\n', '    /// @param question A string containing the parameters that will be passed into the template to make the question\n', '    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\n', '    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\n', '    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\n', '    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\n', '    /// @return The ID of the newly-created question, created deterministically.\n', '    function askQuestion(uint256 template_id, string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) \n', '        // stateNotCreated is enforced by the internal _askQuestion\n', '    public payable returns (bytes32) {\n', '\n', '        require(templates[template_id] > 0); // Template must exist\n', '\n', '        bytes32 content_hash = keccak256(template_id, opening_ts, question);\n', '        bytes32 question_id = keccak256(content_hash, arbitrator, timeout, msg.sender, nonce);\n', '\n', '        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts);\n', '        LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\n', '\n', '        return question_id;\n', '    }\n', '\n', '    function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts) \n', '        stateNotCreated(question_id)\n', '    internal {\n', '\n', '        // A timeout of 0 makes no sense, and we will use this to check existence\n', '        require(timeout > 0); \n', '        require(timeout < 365 days); \n', '        require(arbitrator != NULL_ADDRESS);\n', '\n', '        uint256 bounty = msg.value;\n', '\n', '        // The arbitrator can set a fee for asking a question. \n', '        // This is intended as an anti-spam defence.\n', '        // The fee is waived if the arbitrator is asking the question.\n', '        // This allows them to set an impossibly high fee and make users proxy the question through them.\n', '        // This would allow more sophisticated pricing, question whitelisting etc.\n', '        if (msg.sender != arbitrator) {\n', '            uint256 question_fee = arbitrator_question_fees[arbitrator];\n', '            require(bounty >= question_fee); \n', '            bounty = bounty.sub(question_fee);\n', '            balanceOf[arbitrator] = balanceOf[arbitrator].add(question_fee);\n', '        }\n', '\n', '        questions[question_id].content_hash = content_hash;\n', '        questions[question_id].arbitrator = arbitrator;\n', '        questions[question_id].opening_ts = opening_ts;\n', '        questions[question_id].timeout = timeout;\n', '        questions[question_id].bounty = bounty;\n', '\n', '    }\n', '\n', '    /// @notice Add funds to the bounty for a question\n', '    /// @dev Add bounty funds after the initial question creation. Can be done any time until the question is finalized.\n', '    /// @param question_id The ID of the question you wish to fund\n', '    function fundAnswerBounty(bytes32 question_id) \n', '        stateOpen(question_id)\n', '    external payable {\n', '        questions[question_id].bounty = questions[question_id].bounty.add(msg.value);\n', '        LogFundAnswerBounty(question_id, msg.value, questions[question_id].bounty, msg.sender);\n', '    }\n', '\n', '    /// @notice Submit an answer for a question.\n', '    /// @dev Adds the answer to the history and updates the current "best" answer.\n', '    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded into bytes32\n', '    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\n', '    function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) \n', '        stateOpen(question_id)\n', '        bondMustDouble(question_id)\n', '        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\n', '    external payable {\n', '        _addAnswerToHistory(question_id, answer, msg.sender, msg.value, false);\n', '        _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\n', '    }\n', '\n', '    /// @notice Submit the hash of an answer, laying your claim to that answer if you reveal it in a subsequent transaction.\n', '    /// @dev Creates a hash, commitment_id, uniquely identifying this answer, to this question, with this bond.\n', '    /// The commitment_id is stored in the answer history where the answer would normally go.\n', '    /// Does not update the current best answer - this is left to the later submitAnswerReveal() transaction.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer_hash The hash of your answer, plus a nonce that you will later reveal\n', '    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\n', '    /// @param _answerer If specified, the address to be given as the question answerer. Defaults to the sender.\n', '    /// @dev Specifying the answerer is useful if you want to delegate the commit-and-reveal to a third-party.\n', '    function submitAnswerCommitment(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) \n', '        stateOpen(question_id)\n', '        bondMustDouble(question_id)\n', '        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\n', '    external payable {\n', '\n', '        bytes32 commitment_id = keccak256(question_id, answer_hash, msg.value);\n', '        address answerer = (_answerer == NULL_ADDRESS) ? msg.sender : _answerer;\n', '\n', '        require(commitments[commitment_id].reveal_ts == COMMITMENT_NON_EXISTENT);\n', '\n', '        uint32 commitment_timeout = questions[question_id].timeout / COMMITMENT_TIMEOUT_RATIO;\n', '        commitments[commitment_id].reveal_ts = uint32(now).add(commitment_timeout);\n', '\n', '        _addAnswerToHistory(question_id, commitment_id, answerer, msg.value, true);\n', '\n', '    }\n', '\n', '    /// @notice Submit the answer whose hash you sent in a previous submitAnswerCommitment() transaction\n', '    /// @dev Checks the parameters supplied recreate an existing commitment, and stores the revealed answer\n', '    /// Updates the current answer unless someone has since supplied a new answer with a higher bond\n', '    /// msg.sender is intentionally not restricted to the user who originally sent the commitment; \n', '    /// For example, the user may want to provide the answer+nonce to a third-party service and let them send the tx\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded as bytes32\n', '    /// @param nonce The nonce that, combined with the answer, recreates the answer_hash you gave in submitAnswerCommitment()\n', '    /// @param bond The bond that you paid in your submitAnswerCommitment() transaction\n', '    function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) \n', '        stateOpen(question_id)\n', '    external {\n', '\n', '        bytes32 answer_hash = keccak256(answer, nonce);\n', '        bytes32 commitment_id = keccak256(question_id, answer_hash, bond);\n', '\n', '        require(!commitments[commitment_id].is_revealed);\n', '        require(commitments[commitment_id].reveal_ts > uint32(now)); // Reveal deadline must not have passed\n', '\n', '        commitments[commitment_id].revealed_answer = answer;\n', '        commitments[commitment_id].is_revealed = true;\n', '\n', '        if (bond == questions[question_id].bond) {\n', '            _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\n', '        }\n', '\n', '        LogAnswerReveal(question_id, msg.sender, answer_hash, answer, nonce, bond);\n', '\n', '    }\n', '\n', '    function _addAnswerToHistory(bytes32 question_id, bytes32 answer_or_commitment_id, address answerer, uint256 bond, bool is_commitment) \n', '    internal \n', '    {\n', '        bytes32 new_history_hash = keccak256(questions[question_id].history_hash, answer_or_commitment_id, bond, answerer, is_commitment);\n', '\n', '        questions[question_id].bond = bond;\n', '        questions[question_id].history_hash = new_history_hash;\n', '\n', '        LogNewAnswer(answer_or_commitment_id, question_id, new_history_hash, answerer, bond, now, is_commitment);\n', '    }\n', '\n', '    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint32 timeout_secs)\n', '    internal {\n', '        questions[question_id].best_answer = answer;\n', '        questions[question_id].finalize_ts = uint32(now).add(timeout_secs);\n', '    }\n', '\n', '    /// @notice Notify the contract that the arbitrator has been paid for a question, freezing it pending their decision.\n', '    /// @dev The arbitrator contract is trusted to only call this if they&#39;ve been paid, and tell us who paid them.\n', '    /// @param question_id The ID of the question\n', '    /// @param requester The account that requested arbitration\n', '    function notifyOfArbitrationRequest(bytes32 question_id, address requester) \n', '        onlyArbitrator(question_id)\n', '        stateOpen(question_id)\n', '    external {\n', '        questions[question_id].is_pending_arbitration = true;\n', '        LogNotifyOfArbitrationRequest(question_id, requester);\n', '    }\n', '\n', '    /// @notice Submit the answer for a question, for use by the arbitrator.\n', '    /// @dev Doesn&#39;t require (or allow) a bond.\n', '    /// If the current final answer is correct, the account should be whoever submitted it.\n', '    /// If the current final answer is wrong, the account should be whoever paid for arbitration.\n', '    /// However, the answerer stipulations are not enforced by the contract.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded into bytes32\n', '    /// @param answerer The account credited with this answer for the purpose of bond claims\n', '    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \n', '        onlyArbitrator(question_id)\n', '        statePendingArbitration(question_id)\n', '        bondMustBeZero\n', '    external {\n', '\n', '        require(answerer != NULL_ADDRESS);\n', '        LogFinalize(question_id, answer);\n', '\n', '        questions[question_id].is_pending_arbitration = false;\n', '        _addAnswerToHistory(question_id, answer, answerer, 0, false);\n', '        _updateCurrentAnswer(question_id, answer, 0);\n', '\n', '    }\n', '\n', '    /// @notice Report whether the answer to the specified question is finalized\n', '    /// @param question_id The ID of the question\n', '    /// @return Return true if finalized\n', '    function isFinalized(bytes32 question_id) \n', '    constant public returns (bool) {\n', '        uint32 finalize_ts = questions[question_id].finalize_ts;\n', '        return ( !questions[question_id].is_pending_arbitration && (finalize_ts > UNANSWERED) && (finalize_ts <= uint32(now)) );\n', '    }\n', '\n', '    /// @notice Return the final answer to the specified question, or revert if there isn&#39;t one\n', '    /// @param question_id The ID of the question\n', '    /// @return The answer formatted as a bytes32\n', '    function getFinalAnswer(bytes32 question_id) \n', '        stateFinalized(question_id)\n', '    external constant returns (bytes32) {\n', '        return questions[question_id].best_answer;\n', '    }\n', '\n', '    /// @notice Return the final answer to the specified question, provided it matches the specified criteria.\n', '    /// @dev Reverts if the question is not finalized, or if it does not match the specified criteria.\n', '    /// @param question_id The ID of the question\n', '    /// @param content_hash The hash of the question content (template ID + opening time + question parameter string)\n', '    /// @param arbitrator The arbitrator chosen for the question (regardless of whether they are asked to arbitrate)\n', '    /// @param min_timeout The timeout set in the initial question settings must be this high or higher\n', '    /// @param min_bond The bond sent with the final answer must be this high or higher\n', '    /// @return The answer formatted as a bytes32\n', '    function getFinalAnswerIfMatches(\n', '        bytes32 question_id, \n', '        bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond\n', '    ) \n', '        stateFinalized(question_id)\n', '    external constant returns (bytes32) {\n', '        require(content_hash == questions[question_id].content_hash);\n', '        require(arbitrator == questions[question_id].arbitrator);\n', '        require(min_timeout <= questions[question_id].timeout);\n', '        require(min_bond <= questions[question_id].bond);\n', '        return questions[question_id].best_answer;\n', '    }\n', '\n', '    /// @notice Assigns the winnings (bounty and bonds) to everyone who gave the accepted answer\n', '    /// Caller must provide the answer history, in reverse order\n', '    /// @dev Works up the chain and assign bonds to the person who gave the right answer\n', '    /// If someone gave the winning answer earlier, they must get paid from the higher bond\n', '    /// That means we can&#39;t pay out the bond added at n until we have looked at n-1\n', '    /// The first answer is authenticated by checking against the stored history_hash.\n', '    /// One of the inputs to history_hash is the history_hash before it, so we use that to authenticate the next entry, etc\n', '    /// Once we get to a null hash we&#39;ll know we&#39;re done and there are no more answers.\n', '    /// Usually you would call the whole thing in a single transaction, but if not then the data is persisted to pick up later.\n', '    /// @param question_id The ID of the question\n', '    /// @param history_hashes Second-last-to-first, the hash of each history entry. (Final one should be empty).\n', '    /// @param addrs Last-to-first, the address of each answerer or commitment sender\n', '    /// @param bonds Last-to-first, the bond supplied with each answer or commitment\n', '    /// @param answers Last-to-first, each answer supplied, or commitment ID if the answer was supplied with commit->reveal\n', '    function claimWinnings(\n', '        bytes32 question_id, \n', '        bytes32[] history_hashes, address[] addrs, uint256[] bonds, bytes32[] answers\n', '    ) \n', '        stateFinalized(question_id)\n', '    public {\n', '\n', '        require(history_hashes.length > 0);\n', '\n', '        // These are only set if we split our claim over multiple transactions.\n', '        address payee = question_claims[question_id].payee; \n', '        uint256 last_bond = question_claims[question_id].last_bond; \n', '        uint256 queued_funds = question_claims[question_id].queued_funds; \n', '\n', '        // Starts as the hash of the final answer submitted. It&#39;ll be cleared when we&#39;re done.\n', '        // If we&#39;re splitting the claim over multiple transactions, it&#39;ll be the hash where we left off last time\n', '        bytes32 last_history_hash = questions[question_id].history_hash;\n', '\n', '        bytes32 best_answer = questions[question_id].best_answer;\n', '\n', '        uint256 i;\n', '        for (i = 0; i < history_hashes.length; i++) {\n', '        \n', '            // Check input against the history hash, and see which of 2 possible values of is_commitment fits.\n', '            bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]);\n', '            \n', '            queued_funds = queued_funds.add(last_bond); \n', '            (queued_funds, payee) = _processHistoryItem(\n', '                question_id, best_answer, queued_funds, payee, \n', '                addrs[i], bonds[i], answers[i], is_commitment);\n', ' \n', '            // Line the bond up for next time, when it will be added to somebody&#39;s queued_funds\n', '            last_bond = bonds[i];\n', '            last_history_hash = history_hashes[i];\n', '\n', '        }\n', ' \n', '        if (last_history_hash != NULL_HASH) {\n', '            // We haven&#39;t yet got to the null hash (1st answer), ie the caller didn&#39;t supply the full answer chain.\n', '            // Persist the details so we can pick up later where we left off later.\n', '\n', '            // If we know who to pay we can go ahead and pay them out, only keeping back last_bond\n', '            // (We always know who to pay unless all we saw were unrevealed commits)\n', '            if (payee != NULL_ADDRESS) {\n', '                _payPayee(question_id, payee, queued_funds);\n', '                queued_funds = 0;\n', '            }\n', '\n', '            question_claims[question_id].payee = payee;\n', '            question_claims[question_id].last_bond = last_bond;\n', '            question_claims[question_id].queued_funds = queued_funds;\n', '        } else {\n', '            // There is nothing left below us so the payee can keep what remains\n', '            _payPayee(question_id, payee, queued_funds.add(last_bond));\n', '            delete question_claims[question_id];\n', '        }\n', '\n', '        questions[question_id].history_hash = last_history_hash;\n', '\n', '    }\n', '\n', '    function _payPayee(bytes32 question_id, address payee, uint256 value) \n', '    internal {\n', '        balanceOf[payee] = balanceOf[payee].add(value);\n', '        LogClaim(question_id, payee, value);\n', '    }\n', '\n', '    function _verifyHistoryInputOrRevert(\n', '        bytes32 last_history_hash,\n', '        bytes32 history_hash, bytes32 answer, uint256 bond, address addr\n', '    )\n', '    internal pure returns (bool) {\n', '        if (last_history_hash == keccak256(history_hash, answer, bond, addr, true) ) {\n', '            return true;\n', '        }\n', '        if (last_history_hash == keccak256(history_hash, answer, bond, addr, false) ) {\n', '            return false;\n', '        } \n', '        revert();\n', '    }\n', '\n', '    function _processHistoryItem(\n', '        bytes32 question_id, bytes32 best_answer, \n', '        uint256 queued_funds, address payee, \n', '        address addr, uint256 bond, bytes32 answer, bool is_commitment\n', '    )\n', '    internal returns (uint256, address) {\n', '\n', '        // For commit-and-reveal, the answer history holds the commitment ID instead of the answer.\n', '        // We look at the referenced commitment ID and switch in the actual answer.\n', '        if (is_commitment) {\n', '            bytes32 commitment_id = answer;\n', '            // If it&#39;s a commit but it hasn&#39;t been revealed, it will always be considered wrong.\n', '            if (!commitments[commitment_id].is_revealed) {\n', '                delete commitments[commitment_id];\n', '                return (queued_funds, payee);\n', '            } else {\n', '                answer = commitments[commitment_id].revealed_answer;\n', '                delete commitments[commitment_id];\n', '            }\n', '        }\n', '\n', '        if (answer == best_answer) {\n', '\n', '            if (payee == NULL_ADDRESS) {\n', '\n', '                // The entry is for the first payee we come to, ie the winner.\n', '                // They get the question bounty.\n', '                payee = addr;\n', '                queued_funds = queued_funds.add(questions[question_id].bounty);\n', '                questions[question_id].bounty = 0;\n', '\n', '            } else if (addr != payee) {\n', '\n', '                // Answerer has changed, ie we found someone lower down who needs to be paid\n', '\n', '                // The lower answerer will take over receiving bonds from higher answerer.\n', '                // They should also be paid the takeover fee, which is set at a rate equivalent to their bond. \n', '                // (This is our arbitrary rule, to give consistent right-answerers a defence against high-rollers.)\n', '\n', '                // There should be enough for the fee, but if not, take what we have.\n', '                // There&#39;s an edge case involving weird arbitrator behaviour where we may be short.\n', '                uint256 answer_takeover_fee = (queued_funds >= bond) ? bond : queued_funds;\n', '\n', '                // Settle up with the old (higher-bonded) payee\n', '                _payPayee(question_id, payee, queued_funds.sub(answer_takeover_fee));\n', '\n', '                // Now start queued_funds again for the new (lower-bonded) payee\n', '                payee = addr;\n', '                queued_funds = answer_takeover_fee;\n', '\n', '            }\n', '\n', '        }\n', '\n', '        return (queued_funds, payee);\n', '\n', '    }\n', '\n', '    /// @notice Convenience function to assign bounties/bonds for multiple questions in one go, then withdraw all your funds.\n', '    /// Caller must provide the answer history for each question, in reverse order\n', '    /// @dev Can be called by anyone to assign bonds/bounties, but funds are only withdrawn for the user making the call.\n', '    /// @param question_ids The IDs of the questions you want to claim for\n', '    /// @param lengths The number of history entries you will supply for each question ID\n', '    /// @param hist_hashes In a single list for all supplied questions, the hash of each history entry.\n', '    /// @param addrs In a single list for all supplied questions, the address of each answerer or commitment sender\n', '    /// @param bonds In a single list for all supplied questions, the bond supplied with each answer or commitment\n', '    /// @param answers In a single list for all supplied questions, each answer supplied, or commitment ID \n', '    function claimMultipleAndWithdrawBalance(\n', '        bytes32[] question_ids, uint256[] lengths, \n', '        bytes32[] hist_hashes, address[] addrs, uint256[] bonds, bytes32[] answers\n', '    ) \n', '        stateAny() // The finalization checks are done in the claimWinnings function\n', '    public {\n', '        \n', '        uint256 qi;\n', '        uint256 i;\n', '        for (qi = 0; qi < question_ids.length; qi++) {\n', '            bytes32 qid = question_ids[qi];\n', '            uint256 ln = lengths[qi];\n', '            bytes32[] memory hh = new bytes32[](ln);\n', '            address[] memory ad = new address[](ln);\n', '            uint256[] memory bo = new uint256[](ln);\n', '            bytes32[] memory an = new bytes32[](ln);\n', '            uint256 j;\n', '            for (j = 0; j < ln; j++) {\n', '                hh[j] = hist_hashes[i];\n', '                ad[j] = addrs[i];\n', '                bo[j] = bonds[i];\n', '                an[j] = answers[i];\n', '                i++;\n', '            }\n', '            claimWinnings(qid, hh, ad, bo, an);\n', '        }\n', '        withdraw();\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Arbitrator is Owned {\n', '\n', '    RealityCheck public realitycheck;\n', '\n', '    mapping(bytes32 => uint256) public arbitration_bounties;\n', '\n', '    uint256 dispute_fee;\n', '    mapping(bytes32 => uint256) custom_dispute_fees;\n', '\n', '    event LogRequestArbitration(\n', '        bytes32 indexed question_id,\n', '        uint256 fee_paid,\n', '        address requester,\n', '        uint256 remaining\n', '    );\n', '\n', '    event LogSetRealityCheck(\n', '        address realitycheck\n', '    );\n', '\n', '    event LogSetQuestionFee(\n', '        uint256 fee\n', '    );\n', '\n', '\n', '    event LogSetDisputeFee(\n', '        uint256 fee\n', '    );\n', '\n', '    event LogSetCustomDisputeFee(\n', '        bytes32 indexed question_id,\n', '        uint256 fee\n', '    );\n', '\n', '    /// @notice Constructor. Sets the deploying address as owner.\n', '    function Arbitrator() \n', '    public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Set the Reality Check contract address\n', '    /// @param addr The address of the Reality Check contract\n', '    function setRealityCheck(address addr) \n', '        onlyOwner \n', '    public {\n', '        realitycheck = RealityCheck(addr);\n', '        LogSetRealityCheck(addr);\n', '    }\n', '\n', '    /// @notice Set the default fee\n', '    /// @param fee The default fee amount\n', '    function setDisputeFee(uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        dispute_fee = fee;\n', '        LogSetDisputeFee(fee);\n', '    }\n', '\n', '    /// @notice Set a custom fee for this particular question\n', '    /// @param question_id The question in question\n', '    /// @param fee The fee amount\n', '    function setCustomDisputeFee(bytes32 question_id, uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        custom_dispute_fees[question_id] = fee;\n', '        LogSetCustomDisputeFee(question_id, fee);\n', '    }\n', '\n', '    /// @notice Return the dispute fee for the specified question. 0 indicates that we won&#39;t arbitrate it.\n', '    /// @param question_id The question in question\n', '    /// @dev Uses a general default, but can be over-ridden on a question-by-question basis.\n', '    function getDisputeFee(bytes32 question_id) \n', '    public constant returns (uint256) {\n', '        return (custom_dispute_fees[question_id] > 0) ? custom_dispute_fees[question_id] : dispute_fee;\n', '    }\n', '\n', '    /// @notice Set a fee for asking a question with us as the arbitrator\n', '    /// @param fee The fee amount\n', '    /// @dev Default is no fee. Unlike the dispute fee, 0 is an acceptable setting.\n', '    /// You could set an impossibly high fee if you want to prevent us being used as arbitrator unless we submit the question.\n', '    /// (Submitting the question ourselves is not implemented here.)\n', '    /// This fee can be used as a revenue source, an anti-spam measure, or both.\n', '    function setQuestionFee(uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        realitycheck.setQuestionFee(fee);\n', '        LogSetQuestionFee(fee);\n', '    }\n', '\n', '    /// @notice Submit the arbitrator&#39;s answer to a question.\n', '    /// @param question_id The question in question\n', '    /// @param answer The answer\n', '    /// @param answerer The answerer. If arbitration changed the answer, it should be the payer. If not, the old answerer.\n', '    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \n', '        onlyOwner \n', '    public {\n', '        delete arbitration_bounties[question_id];\n', '        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);\n', '    }\n', '\n', '    /// @notice Request arbitration, freezing the question until we send submitAnswerByArbitrator\n', '    /// @dev The bounty can be paid only in part, in which case the last person to pay will be considered the payer\n', '    /// Will trigger an error if the notification fails, eg because the question has already been finalized\n', '    /// @param question_id The question in question\n', '    function requestArbitration(bytes32 question_id) \n', '    external payable returns (bool) {\n', '\n', '        uint256 arbitration_fee = getDisputeFee(question_id);\n', '        require(arbitration_fee > 0);\n', '\n', '        arbitration_bounties[question_id] += msg.value;\n', '        uint256 paid = arbitration_bounties[question_id];\n', '\n', '        if (paid >= arbitration_fee) {\n', '            realitycheck.notifyOfArbitrationRequest(question_id, msg.sender);\n', '            LogRequestArbitration(question_id, msg.value, msg.sender, 0);\n', '            return true;\n', '        } else {\n', '            require(!realitycheck.isFinalized(question_id));\n', '            LogRequestArbitration(question_id, msg.value, msg.sender, arbitration_fee - paid);\n', '            return false;\n', '        }\n', '\n', '    }\n', '\n', '    /// @notice Withdraw any accumulated fees to the specified address\n', '    /// @param addr The address to which the balance should be sent\n', '    function withdraw(address addr) \n', '        onlyOwner \n', '    public {\n', '        addr.transfer(this.balance); \n', '    }\n', '\n', '    function() \n', '    public payable {\n', '    }\n', '\n', '    /// @notice Withdraw any accumulated question fees from the specified address into this contract\n', '    /// @dev Funds can then be liberated from this contract with our withdraw() function\n', '    function callWithdraw() \n', '        onlyOwner \n', '    public {\n', '        realitycheck.withdraw(); \n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() \n', '    public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) \n', '        onlyOwner \n', '    public {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath32 {\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract BalanceHolder {\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    event LogWithdraw(\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '\n', '    function withdraw() \n', '    public {\n', '        uint256 bal = balanceOf[msg.sender];\n', '        balanceOf[msg.sender] = 0;\n', '        msg.sender.transfer(bal);\n', '        LogWithdraw(msg.sender, bal);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract RealityCheck is BalanceHolder {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath32 for uint32;\n', '\n', '    address constant NULL_ADDRESS = address(0);\n', '\n', '    // History hash when no history is created, or history has been cleared\n', '    bytes32 constant NULL_HASH = bytes32(0);\n', '\n', '    // An unitinalized finalize_ts for a question will indicate an unanswered question.\n', '    uint32 constant UNANSWERED = 0;\n', '\n', '    // An unanswered reveal_ts for a commitment will indicate that it does not exist.\n', '    uint256 constant COMMITMENT_NON_EXISTENT = 0;\n', '\n', '    // Commit->reveal timeout is 1/8 of the question timeout (rounded down).\n', '    uint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\n', '\n', '    event LogSetQuestionFee(\n', '        address arbitrator,\n', '        uint256 amount\n', '    );\n', '\n', '    event LogNewTemplate(\n', '        uint256 indexed template_id,\n', '        address indexed user, \n', '        string question_text\n', '    );\n', '\n', '    event LogNewQuestion(\n', '        bytes32 indexed question_id,\n', '        address indexed user, \n', '        uint256 template_id,\n', '        string question,\n', '        bytes32 indexed content_hash,\n', '        address arbitrator, \n', '        uint32 timeout,\n', '        uint32 opening_ts,\n', '        uint256 nonce,\n', '        uint256 created\n', '    );\n', '\n', '    event LogFundAnswerBounty(\n', '        bytes32 indexed question_id,\n', '        uint256 bounty_added,\n', '        uint256 bounty,\n', '        address indexed user \n', '    );\n', '\n', '    event LogNewAnswer(\n', '        bytes32 answer,\n', '        bytes32 indexed question_id,\n', '        bytes32 history_hash,\n', '        address indexed user,\n', '        uint256 bond,\n', '        uint256 ts,\n', '        bool is_commitment\n', '    );\n', '\n', '    event LogAnswerReveal(\n', '        bytes32 indexed question_id, \n', '        address indexed user, \n', '        bytes32 indexed answer_hash, \n', '        bytes32 answer, \n', '        uint256 nonce, \n', '        uint256 bond\n', '    );\n', '\n', '    event LogNotifyOfArbitrationRequest(\n', '        bytes32 indexed question_id,\n', '        address indexed user \n', '    );\n', '\n', '    event LogFinalize(\n', '        bytes32 indexed question_id,\n', '        bytes32 indexed answer\n', '    );\n', '\n', '    event LogClaim(\n', '        bytes32 indexed question_id,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '\n', '    struct Question {\n', '        bytes32 content_hash;\n', '        address arbitrator;\n', '        uint32 opening_ts;\n', '        uint32 timeout;\n', '        uint32 finalize_ts;\n', '        bool is_pending_arbitration;\n', '        uint256 bounty;\n', '        bytes32 best_answer;\n', '        bytes32 history_hash;\n', '        uint256 bond;\n', '    }\n', '\n', '    // Stored in a mapping indexed by commitment_id, a hash of commitment hash, question, bond. \n', '    struct Commitment {\n', '        uint32 reveal_ts;\n', '        bool is_revealed;\n', '        bytes32 revealed_answer;\n', '    }\n', '\n', '    // Only used when claiming more bonds than fits into a transaction\n', '    // Stored in a mapping indexed by question_id.\n', '    struct Claim {\n', '        address payee;\n', '        uint256 last_bond;\n', '        uint256 queued_funds;\n', '    }\n', '\n', '    uint256 nextTemplateID = 0;\n', '    mapping(uint256 => uint256) public templates;\n', '    mapping(bytes32 => Question) public questions;\n', '    mapping(bytes32 => Claim) question_claims;\n', '    mapping(bytes32 => Commitment) public commitments;\n', '    mapping(address => uint256) public arbitrator_question_fees; \n', '\n', '    modifier onlyArbitrator(bytes32 question_id) {\n', '        require(msg.sender == questions[question_id].arbitrator);\n', '        _;\n', '    }\n', '\n', '    modifier stateAny() {\n', '        _;\n', '    }\n', '\n', '    modifier stateNotCreated(bytes32 question_id) {\n', '        require(questions[question_id].timeout == 0);\n', '        _;\n', '    }\n', '\n', '    modifier stateOpen(bytes32 question_id) {\n', '        require(questions[question_id].timeout > 0); // Check existence\n', '        require(!questions[question_id].is_pending_arbitration);\n', '        uint32 finalize_ts = questions[question_id].finalize_ts;\n', '        require(finalize_ts == UNANSWERED || finalize_ts > uint32(now));\n', '        uint32 opening_ts = questions[question_id].opening_ts;\n', '        require(opening_ts == 0 || opening_ts <= uint32(now)); \n', '        _;\n', '    }\n', '\n', '    modifier statePendingArbitration(bytes32 question_id) {\n', '        require(questions[question_id].is_pending_arbitration);\n', '        _;\n', '    }\n', '\n', '    modifier stateFinalized(bytes32 question_id) {\n', '        require(isFinalized(question_id));\n', '        _;\n', '    }\n', '\n', '    modifier bondMustBeZero() {\n', '        require(msg.value == 0);\n', '        _;\n', '    }\n', '\n', '    modifier bondMustDouble(bytes32 question_id) {\n', '        require(msg.value > 0); \n', '        require(msg.value >= (questions[question_id].bond.mul(2)));\n', '        _;\n', '    }\n', '\n', '    modifier previousBondMustNotBeatMaxPrevious(bytes32 question_id, uint256 max_previous) {\n', '        if (max_previous > 0) {\n', '            require(questions[question_id].bond <= max_previous);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @notice Constructor, sets up some initial templates\n', '    /// @dev Creates some generalized templates for different question types used in the DApp.\n', '    function RealityCheck() \n', '    public {\n', '        createTemplate(\'{"title": "%s", "type": "bool", "category": "%s"}\');\n', '        createTemplate(\'{"title": "%s", "type": "uint", "decimals": 18, "category": "%s"}\');\n', '        createTemplate(\'{"title": "%s", "type": "int", "decimals": 18, "category": "%s"}\');\n', '        createTemplate(\'{"title": "%s", "type": "single-select", "outcomes": [%s], "category": "%s"}\');\n', '        createTemplate(\'{"title": "%s", "type": "multiple-select", "outcomes": [%s], "category": "%s"}\');\n', '        createTemplate(\'{"title": "%s", "type": "datetime", "category": "%s"}\');\n', '    }\n', '\n', '    /// @notice Function for arbitrator to set an optional per-question fee. \n', '    /// @dev The per-question fee, charged when a question is asked, is intended as an anti-spam measure.\n', '    /// @param fee The fee to be charged by the arbitrator when a question is asked\n', '    function setQuestionFee(uint256 fee) \n', '        stateAny() \n', '    external {\n', '        arbitrator_question_fees[msg.sender] = fee;\n', '        LogSetQuestionFee(msg.sender, fee);\n', '    }\n', '\n', '    /// @notice Create a reusable template, which should be a JSON document.\n', '    /// Placeholders should use gettext() syntax, eg %s.\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param content The template content\n', '    /// @return The ID of the newly-created template, which is created sequentially.\n', '    function createTemplate(string content) \n', '        stateAny()\n', '    public returns (uint256) {\n', '        uint256 id = nextTemplateID;\n', '        templates[id] = block.number;\n', '        LogNewTemplate(id, msg.sender, content);\n', '        nextTemplateID = id.add(1);\n', '        return id;\n', '    }\n', '\n', '    /// @notice Create a new reusable template and use it to ask a question\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param content The template content\n', '    /// @param question A string containing the parameters that will be passed into the template to make the question\n', '    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\n', '    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\n', '    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\n', '    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\n', '    /// @return The ID of the newly-created template, which is created sequentially.\n', '    function createTemplateAndAskQuestion(\n', '        string content, \n', '        string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce \n', '    ) \n', '        // stateNotCreated is enforced by the internal _askQuestion\n', '    public payable returns (bytes32) {\n', '        uint256 template_id = createTemplate(content);\n', '        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\n', '    }\n', '\n', '    /// @notice Ask a new question and return the ID\n', '    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\n', '    /// @param template_id The ID number of the template the question will use\n', '    /// @param question A string containing the parameters that will be passed into the template to make the question\n', '    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\n', '    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\n', '    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\n', '    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\n', '    /// @return The ID of the newly-created question, created deterministically.\n', '    function askQuestion(uint256 template_id, string question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) \n', '        // stateNotCreated is enforced by the internal _askQuestion\n', '    public payable returns (bytes32) {\n', '\n', '        require(templates[template_id] > 0); // Template must exist\n', '\n', '        bytes32 content_hash = keccak256(template_id, opening_ts, question);\n', '        bytes32 question_id = keccak256(content_hash, arbitrator, timeout, msg.sender, nonce);\n', '\n', '        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts);\n', '        LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\n', '\n', '        return question_id;\n', '    }\n', '\n', '    function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts) \n', '        stateNotCreated(question_id)\n', '    internal {\n', '\n', '        // A timeout of 0 makes no sense, and we will use this to check existence\n', '        require(timeout > 0); \n', '        require(timeout < 365 days); \n', '        require(arbitrator != NULL_ADDRESS);\n', '\n', '        uint256 bounty = msg.value;\n', '\n', '        // The arbitrator can set a fee for asking a question. \n', '        // This is intended as an anti-spam defence.\n', '        // The fee is waived if the arbitrator is asking the question.\n', '        // This allows them to set an impossibly high fee and make users proxy the question through them.\n', '        // This would allow more sophisticated pricing, question whitelisting etc.\n', '        if (msg.sender != arbitrator) {\n', '            uint256 question_fee = arbitrator_question_fees[arbitrator];\n', '            require(bounty >= question_fee); \n', '            bounty = bounty.sub(question_fee);\n', '            balanceOf[arbitrator] = balanceOf[arbitrator].add(question_fee);\n', '        }\n', '\n', '        questions[question_id].content_hash = content_hash;\n', '        questions[question_id].arbitrator = arbitrator;\n', '        questions[question_id].opening_ts = opening_ts;\n', '        questions[question_id].timeout = timeout;\n', '        questions[question_id].bounty = bounty;\n', '\n', '    }\n', '\n', '    /// @notice Add funds to the bounty for a question\n', '    /// @dev Add bounty funds after the initial question creation. Can be done any time until the question is finalized.\n', '    /// @param question_id The ID of the question you wish to fund\n', '    function fundAnswerBounty(bytes32 question_id) \n', '        stateOpen(question_id)\n', '    external payable {\n', '        questions[question_id].bounty = questions[question_id].bounty.add(msg.value);\n', '        LogFundAnswerBounty(question_id, msg.value, questions[question_id].bounty, msg.sender);\n', '    }\n', '\n', '    /// @notice Submit an answer for a question.\n', '    /// @dev Adds the answer to the history and updates the current "best" answer.\n', '    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded into bytes32\n', '    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\n', '    function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) \n', '        stateOpen(question_id)\n', '        bondMustDouble(question_id)\n', '        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\n', '    external payable {\n', '        _addAnswerToHistory(question_id, answer, msg.sender, msg.value, false);\n', '        _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\n', '    }\n', '\n', '    /// @notice Submit the hash of an answer, laying your claim to that answer if you reveal it in a subsequent transaction.\n', '    /// @dev Creates a hash, commitment_id, uniquely identifying this answer, to this question, with this bond.\n', '    /// The commitment_id is stored in the answer history where the answer would normally go.\n', '    /// Does not update the current best answer - this is left to the later submitAnswerReveal() transaction.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer_hash The hash of your answer, plus a nonce that you will later reveal\n', '    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\n', '    /// @param _answerer If specified, the address to be given as the question answerer. Defaults to the sender.\n', '    /// @dev Specifying the answerer is useful if you want to delegate the commit-and-reveal to a third-party.\n', '    function submitAnswerCommitment(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) \n', '        stateOpen(question_id)\n', '        bondMustDouble(question_id)\n', '        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\n', '    external payable {\n', '\n', '        bytes32 commitment_id = keccak256(question_id, answer_hash, msg.value);\n', '        address answerer = (_answerer == NULL_ADDRESS) ? msg.sender : _answerer;\n', '\n', '        require(commitments[commitment_id].reveal_ts == COMMITMENT_NON_EXISTENT);\n', '\n', '        uint32 commitment_timeout = questions[question_id].timeout / COMMITMENT_TIMEOUT_RATIO;\n', '        commitments[commitment_id].reveal_ts = uint32(now).add(commitment_timeout);\n', '\n', '        _addAnswerToHistory(question_id, commitment_id, answerer, msg.value, true);\n', '\n', '    }\n', '\n', '    /// @notice Submit the answer whose hash you sent in a previous submitAnswerCommitment() transaction\n', '    /// @dev Checks the parameters supplied recreate an existing commitment, and stores the revealed answer\n', '    /// Updates the current answer unless someone has since supplied a new answer with a higher bond\n', '    /// msg.sender is intentionally not restricted to the user who originally sent the commitment; \n', '    /// For example, the user may want to provide the answer+nonce to a third-party service and let them send the tx\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded as bytes32\n', '    /// @param nonce The nonce that, combined with the answer, recreates the answer_hash you gave in submitAnswerCommitment()\n', '    /// @param bond The bond that you paid in your submitAnswerCommitment() transaction\n', '    function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) \n', '        stateOpen(question_id)\n', '    external {\n', '\n', '        bytes32 answer_hash = keccak256(answer, nonce);\n', '        bytes32 commitment_id = keccak256(question_id, answer_hash, bond);\n', '\n', '        require(!commitments[commitment_id].is_revealed);\n', '        require(commitments[commitment_id].reveal_ts > uint32(now)); // Reveal deadline must not have passed\n', '\n', '        commitments[commitment_id].revealed_answer = answer;\n', '        commitments[commitment_id].is_revealed = true;\n', '\n', '        if (bond == questions[question_id].bond) {\n', '            _updateCurrentAnswer(question_id, answer, questions[question_id].timeout);\n', '        }\n', '\n', '        LogAnswerReveal(question_id, msg.sender, answer_hash, answer, nonce, bond);\n', '\n', '    }\n', '\n', '    function _addAnswerToHistory(bytes32 question_id, bytes32 answer_or_commitment_id, address answerer, uint256 bond, bool is_commitment) \n', '    internal \n', '    {\n', '        bytes32 new_history_hash = keccak256(questions[question_id].history_hash, answer_or_commitment_id, bond, answerer, is_commitment);\n', '\n', '        questions[question_id].bond = bond;\n', '        questions[question_id].history_hash = new_history_hash;\n', '\n', '        LogNewAnswer(answer_or_commitment_id, question_id, new_history_hash, answerer, bond, now, is_commitment);\n', '    }\n', '\n', '    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer, uint32 timeout_secs)\n', '    internal {\n', '        questions[question_id].best_answer = answer;\n', '        questions[question_id].finalize_ts = uint32(now).add(timeout_secs);\n', '    }\n', '\n', '    /// @notice Notify the contract that the arbitrator has been paid for a question, freezing it pending their decision.\n', "    /// @dev The arbitrator contract is trusted to only call this if they've been paid, and tell us who paid them.\n", '    /// @param question_id The ID of the question\n', '    /// @param requester The account that requested arbitration\n', '    function notifyOfArbitrationRequest(bytes32 question_id, address requester) \n', '        onlyArbitrator(question_id)\n', '        stateOpen(question_id)\n', '    external {\n', '        questions[question_id].is_pending_arbitration = true;\n', '        LogNotifyOfArbitrationRequest(question_id, requester);\n', '    }\n', '\n', '    /// @notice Submit the answer for a question, for use by the arbitrator.\n', "    /// @dev Doesn't require (or allow) a bond.\n", '    /// If the current final answer is correct, the account should be whoever submitted it.\n', '    /// If the current final answer is wrong, the account should be whoever paid for arbitration.\n', '    /// However, the answerer stipulations are not enforced by the contract.\n', '    /// @param question_id The ID of the question\n', '    /// @param answer The answer, encoded into bytes32\n', '    /// @param answerer The account credited with this answer for the purpose of bond claims\n', '    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \n', '        onlyArbitrator(question_id)\n', '        statePendingArbitration(question_id)\n', '        bondMustBeZero\n', '    external {\n', '\n', '        require(answerer != NULL_ADDRESS);\n', '        LogFinalize(question_id, answer);\n', '\n', '        questions[question_id].is_pending_arbitration = false;\n', '        _addAnswerToHistory(question_id, answer, answerer, 0, false);\n', '        _updateCurrentAnswer(question_id, answer, 0);\n', '\n', '    }\n', '\n', '    /// @notice Report whether the answer to the specified question is finalized\n', '    /// @param question_id The ID of the question\n', '    /// @return Return true if finalized\n', '    function isFinalized(bytes32 question_id) \n', '    constant public returns (bool) {\n', '        uint32 finalize_ts = questions[question_id].finalize_ts;\n', '        return ( !questions[question_id].is_pending_arbitration && (finalize_ts > UNANSWERED) && (finalize_ts <= uint32(now)) );\n', '    }\n', '\n', "    /// @notice Return the final answer to the specified question, or revert if there isn't one\n", '    /// @param question_id The ID of the question\n', '    /// @return The answer formatted as a bytes32\n', '    function getFinalAnswer(bytes32 question_id) \n', '        stateFinalized(question_id)\n', '    external constant returns (bytes32) {\n', '        return questions[question_id].best_answer;\n', '    }\n', '\n', '    /// @notice Return the final answer to the specified question, provided it matches the specified criteria.\n', '    /// @dev Reverts if the question is not finalized, or if it does not match the specified criteria.\n', '    /// @param question_id The ID of the question\n', '    /// @param content_hash The hash of the question content (template ID + opening time + question parameter string)\n', '    /// @param arbitrator The arbitrator chosen for the question (regardless of whether they are asked to arbitrate)\n', '    /// @param min_timeout The timeout set in the initial question settings must be this high or higher\n', '    /// @param min_bond The bond sent with the final answer must be this high or higher\n', '    /// @return The answer formatted as a bytes32\n', '    function getFinalAnswerIfMatches(\n', '        bytes32 question_id, \n', '        bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond\n', '    ) \n', '        stateFinalized(question_id)\n', '    external constant returns (bytes32) {\n', '        require(content_hash == questions[question_id].content_hash);\n', '        require(arbitrator == questions[question_id].arbitrator);\n', '        require(min_timeout <= questions[question_id].timeout);\n', '        require(min_bond <= questions[question_id].bond);\n', '        return questions[question_id].best_answer;\n', '    }\n', '\n', '    /// @notice Assigns the winnings (bounty and bonds) to everyone who gave the accepted answer\n', '    /// Caller must provide the answer history, in reverse order\n', '    /// @dev Works up the chain and assign bonds to the person who gave the right answer\n', '    /// If someone gave the winning answer earlier, they must get paid from the higher bond\n', "    /// That means we can't pay out the bond added at n until we have looked at n-1\n", '    /// The first answer is authenticated by checking against the stored history_hash.\n', '    /// One of the inputs to history_hash is the history_hash before it, so we use that to authenticate the next entry, etc\n', "    /// Once we get to a null hash we'll know we're done and there are no more answers.\n", '    /// Usually you would call the whole thing in a single transaction, but if not then the data is persisted to pick up later.\n', '    /// @param question_id The ID of the question\n', '    /// @param history_hashes Second-last-to-first, the hash of each history entry. (Final one should be empty).\n', '    /// @param addrs Last-to-first, the address of each answerer or commitment sender\n', '    /// @param bonds Last-to-first, the bond supplied with each answer or commitment\n', '    /// @param answers Last-to-first, each answer supplied, or commitment ID if the answer was supplied with commit->reveal\n', '    function claimWinnings(\n', '        bytes32 question_id, \n', '        bytes32[] history_hashes, address[] addrs, uint256[] bonds, bytes32[] answers\n', '    ) \n', '        stateFinalized(question_id)\n', '    public {\n', '\n', '        require(history_hashes.length > 0);\n', '\n', '        // These are only set if we split our claim over multiple transactions.\n', '        address payee = question_claims[question_id].payee; \n', '        uint256 last_bond = question_claims[question_id].last_bond; \n', '        uint256 queued_funds = question_claims[question_id].queued_funds; \n', '\n', "        // Starts as the hash of the final answer submitted. It'll be cleared when we're done.\n", "        // If we're splitting the claim over multiple transactions, it'll be the hash where we left off last time\n", '        bytes32 last_history_hash = questions[question_id].history_hash;\n', '\n', '        bytes32 best_answer = questions[question_id].best_answer;\n', '\n', '        uint256 i;\n', '        for (i = 0; i < history_hashes.length; i++) {\n', '        \n', '            // Check input against the history hash, and see which of 2 possible values of is_commitment fits.\n', '            bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]);\n', '            \n', '            queued_funds = queued_funds.add(last_bond); \n', '            (queued_funds, payee) = _processHistoryItem(\n', '                question_id, best_answer, queued_funds, payee, \n', '                addrs[i], bonds[i], answers[i], is_commitment);\n', ' \n', "            // Line the bond up for next time, when it will be added to somebody's queued_funds\n", '            last_bond = bonds[i];\n', '            last_history_hash = history_hashes[i];\n', '\n', '        }\n', ' \n', '        if (last_history_hash != NULL_HASH) {\n', "            // We haven't yet got to the null hash (1st answer), ie the caller didn't supply the full answer chain.\n", '            // Persist the details so we can pick up later where we left off later.\n', '\n', '            // If we know who to pay we can go ahead and pay them out, only keeping back last_bond\n', '            // (We always know who to pay unless all we saw were unrevealed commits)\n', '            if (payee != NULL_ADDRESS) {\n', '                _payPayee(question_id, payee, queued_funds);\n', '                queued_funds = 0;\n', '            }\n', '\n', '            question_claims[question_id].payee = payee;\n', '            question_claims[question_id].last_bond = last_bond;\n', '            question_claims[question_id].queued_funds = queued_funds;\n', '        } else {\n', '            // There is nothing left below us so the payee can keep what remains\n', '            _payPayee(question_id, payee, queued_funds.add(last_bond));\n', '            delete question_claims[question_id];\n', '        }\n', '\n', '        questions[question_id].history_hash = last_history_hash;\n', '\n', '    }\n', '\n', '    function _payPayee(bytes32 question_id, address payee, uint256 value) \n', '    internal {\n', '        balanceOf[payee] = balanceOf[payee].add(value);\n', '        LogClaim(question_id, payee, value);\n', '    }\n', '\n', '    function _verifyHistoryInputOrRevert(\n', '        bytes32 last_history_hash,\n', '        bytes32 history_hash, bytes32 answer, uint256 bond, address addr\n', '    )\n', '    internal pure returns (bool) {\n', '        if (last_history_hash == keccak256(history_hash, answer, bond, addr, true) ) {\n', '            return true;\n', '        }\n', '        if (last_history_hash == keccak256(history_hash, answer, bond, addr, false) ) {\n', '            return false;\n', '        } \n', '        revert();\n', '    }\n', '\n', '    function _processHistoryItem(\n', '        bytes32 question_id, bytes32 best_answer, \n', '        uint256 queued_funds, address payee, \n', '        address addr, uint256 bond, bytes32 answer, bool is_commitment\n', '    )\n', '    internal returns (uint256, address) {\n', '\n', '        // For commit-and-reveal, the answer history holds the commitment ID instead of the answer.\n', '        // We look at the referenced commitment ID and switch in the actual answer.\n', '        if (is_commitment) {\n', '            bytes32 commitment_id = answer;\n', "            // If it's a commit but it hasn't been revealed, it will always be considered wrong.\n", '            if (!commitments[commitment_id].is_revealed) {\n', '                delete commitments[commitment_id];\n', '                return (queued_funds, payee);\n', '            } else {\n', '                answer = commitments[commitment_id].revealed_answer;\n', '                delete commitments[commitment_id];\n', '            }\n', '        }\n', '\n', '        if (answer == best_answer) {\n', '\n', '            if (payee == NULL_ADDRESS) {\n', '\n', '                // The entry is for the first payee we come to, ie the winner.\n', '                // They get the question bounty.\n', '                payee = addr;\n', '                queued_funds = queued_funds.add(questions[question_id].bounty);\n', '                questions[question_id].bounty = 0;\n', '\n', '            } else if (addr != payee) {\n', '\n', '                // Answerer has changed, ie we found someone lower down who needs to be paid\n', '\n', '                // The lower answerer will take over receiving bonds from higher answerer.\n', '                // They should also be paid the takeover fee, which is set at a rate equivalent to their bond. \n', '                // (This is our arbitrary rule, to give consistent right-answerers a defence against high-rollers.)\n', '\n', '                // There should be enough for the fee, but if not, take what we have.\n', "                // There's an edge case involving weird arbitrator behaviour where we may be short.\n", '                uint256 answer_takeover_fee = (queued_funds >= bond) ? bond : queued_funds;\n', '\n', '                // Settle up with the old (higher-bonded) payee\n', '                _payPayee(question_id, payee, queued_funds.sub(answer_takeover_fee));\n', '\n', '                // Now start queued_funds again for the new (lower-bonded) payee\n', '                payee = addr;\n', '                queued_funds = answer_takeover_fee;\n', '\n', '            }\n', '\n', '        }\n', '\n', '        return (queued_funds, payee);\n', '\n', '    }\n', '\n', '    /// @notice Convenience function to assign bounties/bonds for multiple questions in one go, then withdraw all your funds.\n', '    /// Caller must provide the answer history for each question, in reverse order\n', '    /// @dev Can be called by anyone to assign bonds/bounties, but funds are only withdrawn for the user making the call.\n', '    /// @param question_ids The IDs of the questions you want to claim for\n', '    /// @param lengths The number of history entries you will supply for each question ID\n', '    /// @param hist_hashes In a single list for all supplied questions, the hash of each history entry.\n', '    /// @param addrs In a single list for all supplied questions, the address of each answerer or commitment sender\n', '    /// @param bonds In a single list for all supplied questions, the bond supplied with each answer or commitment\n', '    /// @param answers In a single list for all supplied questions, each answer supplied, or commitment ID \n', '    function claimMultipleAndWithdrawBalance(\n', '        bytes32[] question_ids, uint256[] lengths, \n', '        bytes32[] hist_hashes, address[] addrs, uint256[] bonds, bytes32[] answers\n', '    ) \n', '        stateAny() // The finalization checks are done in the claimWinnings function\n', '    public {\n', '        \n', '        uint256 qi;\n', '        uint256 i;\n', '        for (qi = 0; qi < question_ids.length; qi++) {\n', '            bytes32 qid = question_ids[qi];\n', '            uint256 ln = lengths[qi];\n', '            bytes32[] memory hh = new bytes32[](ln);\n', '            address[] memory ad = new address[](ln);\n', '            uint256[] memory bo = new uint256[](ln);\n', '            bytes32[] memory an = new bytes32[](ln);\n', '            uint256 j;\n', '            for (j = 0; j < ln; j++) {\n', '                hh[j] = hist_hashes[i];\n', '                ad[j] = addrs[i];\n', '                bo[j] = bonds[i];\n', '                an[j] = answers[i];\n', '                i++;\n', '            }\n', '            claimWinnings(qid, hh, ad, bo, an);\n', '        }\n', '        withdraw();\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Arbitrator is Owned {\n', '\n', '    RealityCheck public realitycheck;\n', '\n', '    mapping(bytes32 => uint256) public arbitration_bounties;\n', '\n', '    uint256 dispute_fee;\n', '    mapping(bytes32 => uint256) custom_dispute_fees;\n', '\n', '    event LogRequestArbitration(\n', '        bytes32 indexed question_id,\n', '        uint256 fee_paid,\n', '        address requester,\n', '        uint256 remaining\n', '    );\n', '\n', '    event LogSetRealityCheck(\n', '        address realitycheck\n', '    );\n', '\n', '    event LogSetQuestionFee(\n', '        uint256 fee\n', '    );\n', '\n', '\n', '    event LogSetDisputeFee(\n', '        uint256 fee\n', '    );\n', '\n', '    event LogSetCustomDisputeFee(\n', '        bytes32 indexed question_id,\n', '        uint256 fee\n', '    );\n', '\n', '    /// @notice Constructor. Sets the deploying address as owner.\n', '    function Arbitrator() \n', '    public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Set the Reality Check contract address\n', '    /// @param addr The address of the Reality Check contract\n', '    function setRealityCheck(address addr) \n', '        onlyOwner \n', '    public {\n', '        realitycheck = RealityCheck(addr);\n', '        LogSetRealityCheck(addr);\n', '    }\n', '\n', '    /// @notice Set the default fee\n', '    /// @param fee The default fee amount\n', '    function setDisputeFee(uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        dispute_fee = fee;\n', '        LogSetDisputeFee(fee);\n', '    }\n', '\n', '    /// @notice Set a custom fee for this particular question\n', '    /// @param question_id The question in question\n', '    /// @param fee The fee amount\n', '    function setCustomDisputeFee(bytes32 question_id, uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        custom_dispute_fees[question_id] = fee;\n', '        LogSetCustomDisputeFee(question_id, fee);\n', '    }\n', '\n', "    /// @notice Return the dispute fee for the specified question. 0 indicates that we won't arbitrate it.\n", '    /// @param question_id The question in question\n', '    /// @dev Uses a general default, but can be over-ridden on a question-by-question basis.\n', '    function getDisputeFee(bytes32 question_id) \n', '    public constant returns (uint256) {\n', '        return (custom_dispute_fees[question_id] > 0) ? custom_dispute_fees[question_id] : dispute_fee;\n', '    }\n', '\n', '    /// @notice Set a fee for asking a question with us as the arbitrator\n', '    /// @param fee The fee amount\n', '    /// @dev Default is no fee. Unlike the dispute fee, 0 is an acceptable setting.\n', '    /// You could set an impossibly high fee if you want to prevent us being used as arbitrator unless we submit the question.\n', '    /// (Submitting the question ourselves is not implemented here.)\n', '    /// This fee can be used as a revenue source, an anti-spam measure, or both.\n', '    function setQuestionFee(uint256 fee) \n', '        onlyOwner \n', '    public {\n', '        realitycheck.setQuestionFee(fee);\n', '        LogSetQuestionFee(fee);\n', '    }\n', '\n', "    /// @notice Submit the arbitrator's answer to a question.\n", '    /// @param question_id The question in question\n', '    /// @param answer The answer\n', '    /// @param answerer The answerer. If arbitration changed the answer, it should be the payer. If not, the old answerer.\n', '    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \n', '        onlyOwner \n', '    public {\n', '        delete arbitration_bounties[question_id];\n', '        realitycheck.submitAnswerByArbitrator(question_id, answer, answerer);\n', '    }\n', '\n', '    /// @notice Request arbitration, freezing the question until we send submitAnswerByArbitrator\n', '    /// @dev The bounty can be paid only in part, in which case the last person to pay will be considered the payer\n', '    /// Will trigger an error if the notification fails, eg because the question has already been finalized\n', '    /// @param question_id The question in question\n', '    function requestArbitration(bytes32 question_id) \n', '    external payable returns (bool) {\n', '\n', '        uint256 arbitration_fee = getDisputeFee(question_id);\n', '        require(arbitration_fee > 0);\n', '\n', '        arbitration_bounties[question_id] += msg.value;\n', '        uint256 paid = arbitration_bounties[question_id];\n', '\n', '        if (paid >= arbitration_fee) {\n', '            realitycheck.notifyOfArbitrationRequest(question_id, msg.sender);\n', '            LogRequestArbitration(question_id, msg.value, msg.sender, 0);\n', '            return true;\n', '        } else {\n', '            require(!realitycheck.isFinalized(question_id));\n', '            LogRequestArbitration(question_id, msg.value, msg.sender, arbitration_fee - paid);\n', '            return false;\n', '        }\n', '\n', '    }\n', '\n', '    /// @notice Withdraw any accumulated fees to the specified address\n', '    /// @param addr The address to which the balance should be sent\n', '    function withdraw(address addr) \n', '        onlyOwner \n', '    public {\n', '        addr.transfer(this.balance); \n', '    }\n', '\n', '    function() \n', '    public payable {\n', '    }\n', '\n', '    /// @notice Withdraw any accumulated question fees from the specified address into this contract\n', '    /// @dev Funds can then be liberated from this contract with our withdraw() function\n', '    function callWithdraw() \n', '        onlyOwner \n', '    public {\n', '        realitycheck.withdraw(); \n', '    }\n', '\n', '}']
