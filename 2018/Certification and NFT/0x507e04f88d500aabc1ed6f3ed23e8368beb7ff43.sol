['pragma solidity ^0.4.18;\n', '/* ==================================================================== */\n', '/* Copyright (c) 2018 The Priate Conquest Project.  All rights reserved.\n', '/* \n', '/* https://www.pirateconquest.com One of the world&#39;s slg games of blockchain \n', '/*  \n', '/* authors rainy@livestar.com/Jonny.Fu@livestar.com\n', '/*                 \n', '/* ==================================================================== */\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', 'contract ERC721 /* is ERC165 */ {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '  function ownerOf(uint256 _tokenId) external view returns (address);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '  function approve(address _approved, uint256 _tokenId) external payable;\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', 'interface ERC165 {\n', '     function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x780e9d63\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /*\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() external onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() external onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function div32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function add32(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract AccessAdmin is Pausable {\n', '\n', '  /// @dev Admin Address\n', '  mapping (address => bool) adminContracts;\n', '\n', '  /// @dev Trust contract\n', '  mapping (address => bool) actionContracts;\n', '\n', '  function setAdminContract(address _addr, bool _useful) public onlyOwner {\n', '    require(_addr != address(0));\n', '    adminContracts[_addr] = _useful;\n', '  }\n', '\n', '  modifier onlyAdmin {\n', '    require(adminContracts[msg.sender]); \n', '    _;\n', '  }\n', '\n', '  function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n', '    actionContracts[_actionAddr] = _useful;\n', '  }\n', '\n', '  modifier onlyAccess() {\n', '    require(actionContracts[msg.sender]);\n', '    _;\n', '  }\n', '}\n', '\n', 'interface CaptainGameConfigInterface {\n', '  function getLevelConfig(uint32 cardId, uint32 level) external view returns (uint32 atk,uint32 defense,uint32 atk_min,uint32 atk_max);\n', '}\n', 'contract CaptainToken is AccessAdmin, ERC721 {\n', '  using SafeMath for SafeMath;\n', '  //event \n', '  event CreateCaptain(uint tokenId,uint32 captainId, address _owner, uint256 _price);\n', '  //ERC721\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  event LevelUP(address indexed _owner,uint32 oldLevel, uint32 newLevel);\n', '\n', '  struct Captain {\n', '    uint32 captainId;  \n', '    uint32 color; // 1,2,3,4  \n', '    uint32 atk; \n', '    uint32 defense;\n', '    uint32 level;\n', '    uint256 exp;\n', '  }\n', '  CaptainGameConfigInterface public config;\n', '\n', '  Captain[] public captains; //dynamic Array\n', '  function CaptainToken() public {\n', '    captains.length += 1;\n', '    setAdminContract(msg.sender,true);\n', '    setActionContract(msg.sender,true);\n', '  }\n', '  //setting configuration\n', '  function setGameConfigContract(address _address) external onlyOwner {\n', '    config = CaptainGameConfigInterface(_address);\n', '  }\n', '\n', '  /**MAPPING**/\n', '  /// @dev tokenId to owner  tokenId -> address\n', '  mapping (uint256 => address) public captainTokenIdToOwner;\n', '  /// @dev Equipment token ID search in owner array captainId -> tokenId\n', '  mapping (uint256 => uint256) captainIdToOwnerIndex;  \n', '  /// @dev captains owner by the owner (array)\n', '  mapping (address => uint256[]) ownerToCaptainArray;\n', '  /// @dev price of each token\n', '  mapping (uint256 => uint256) captainTokenIdToPrice;\n', '  /// @dev token count of captain\n', '  mapping (uint32 => uint256) tokenCountOfCaptain;\n', '  /// @dev tokens by the captain\n', '  mapping (uint256 => uint32) IndexToCaptain;\n', '  /// @dev The authorized address for each Captain\n', '  mapping (uint256 => address) captainTokenIdToApprovals;\n', '  /// @dev The authorized operators for each address\n', '  mapping (address => mapping (address => bool)) operatorToApprovals;\n', '  mapping(uint256 => bool) tokenToSell;\n', '  \n', '\n', '  /*** CONSTRUCTOR ***/\n', '  /// @dev Amount of tokens destroyed\n', '  uint256 destroyCaptainCount;\n', '  \n', '  // modifier\n', '  /// @dev Check if token ID is valid\n', '  modifier isValidToken(uint256 _tokenId) {\n', '    require(_tokenId >= 1 && _tokenId <= captains.length);\n', '    require(captainTokenIdToOwner[_tokenId] != address(0)); \n', '    _;\n', '  }\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(msg.sender == captainTokenIdToOwner[_tokenId] || msg.sender == captainTokenIdToApprovals[_tokenId]);\n', '    _;\n', '  }\n', '  /// @dev Creates a new Captain with the given name.\n', '  function CreateCaptainToken(address _owner,uint256 _price, uint32 _captainId, uint32 _color,uint32 _atk,uint32 _defense,uint32 _level,uint256 _exp) public onlyAccess {\n', '    _createCaptainToken(_owner,_price,_captainId,_color,_atk,_defense,_level,_exp);\n', '  }\n', '\n', '  /// For creating CaptainToken\n', '  function _createCaptainToken(address _owner, uint256 _price, uint32 _captainId, uint32 _color, uint32 _atk, uint32 _defense,uint32 _level,uint256 _exp) \n', '  internal {\n', '    uint256 newTokenId = captains.length;\n', '    Captain memory _captain = Captain({\n', '      captainId: _captainId,\n', '      color: _color,\n', '      atk: _atk,\n', '      defense: _defense,\n', '      level: _level,\n', '      exp: _exp \n', '    });\n', '    captains.push(_captain);\n', '    //event\n', '    CreateCaptain(newTokenId, _captainId, _owner, _price);\n', '    captainTokenIdToPrice[newTokenId] = _price;\n', '    IndexToCaptain[newTokenId] = _captainId;\n', '    tokenCountOfCaptain[_captainId] = SafeMath.add(tokenCountOfCaptain[_captainId],1);\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newTokenId);\n', '  } \n', '  /// @dev set the token price\n', '  function setTokenPrice(uint256 _tokenId, uint256 _price) external onlyAccess {\n', '    captainTokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '  /// @dev let owner set the token price\n', '  function setTokenPriceByOwner(uint256 _tokenId, uint256 _price) external {\n', '    require(captainTokenIdToOwner[_tokenId] == msg.sender);\n', '    captainTokenIdToPrice[_tokenId] = _price;\n', '  }\n', '\n', '  /// @dev set sellable\n', '  function setSelled(uint256 _tokenId, bool fsell) external onlyAccess {\n', '    tokenToSell[_tokenId] = fsell;\n', '  }\n', '\n', '  function getSelled(uint256 _tokenId) external view returns (bool) {\n', '    return tokenToSell[_tokenId];\n', '  }\n', '\n', '  /// @dev Do the real transfer with out any condition checking\n', '  /// @param _from The old owner of this Captain(If created: 0x0)\n', '  /// @param _to The new owner of this Captain \n', '  /// @param _tokenId The tokenId of the Captain\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '    if (_from != address(0)) {\n', '      uint256 indexFrom = captainIdToOwnerIndex[_tokenId];  // tokenId -> captainId\n', '      uint256[] storage cpArray = ownerToCaptainArray[_from];\n', '      require(cpArray[indexFrom] == _tokenId);\n', '\n', '      // If the Captain is not the element of array, change it to with the last\n', '      if (indexFrom != cpArray.length - 1) {\n', '        uint256 lastTokenId = cpArray[cpArray.length - 1];\n', '        cpArray[indexFrom] = lastTokenId; \n', '        captainIdToOwnerIndex[lastTokenId] = indexFrom;\n', '      }\n', '      cpArray.length -= 1; \n', '    \n', '      if (captainTokenIdToApprovals[_tokenId] != address(0)) {\n', '        delete captainTokenIdToApprovals[_tokenId];\n', '      }      \n', '    }\n', '\n', '    // Give the Captain to &#39;_to&#39;\n', '    captainTokenIdToOwner[_tokenId] = _to;\n', '    ownerToCaptainArray[_to].push(_tokenId);\n', '    captainIdToOwnerIndex[_tokenId] = ownerToCaptainArray[_to].length - 1;\n', '        \n', '    Transfer(_from != address(0) ? _from : this, _to, _tokenId);\n', '  }\n', '\n', '\n', '  /// @notice Returns all the relevant information about a specific tokenId.\n', '  /// @param _tokenId The tokenId of the captain\n', '  function getCaptainInfo(uint256 _tokenId) external view returns (\n', '    uint32 captainId,  \n', '    uint32 color, \n', '    uint32 atk,\n', '    uint32 defense,\n', '    uint32 level,\n', '    uint256 exp, \n', '    uint256 price,\n', '    address owner,\n', '    bool selled\n', '  ) {\n', '    Captain storage captain = captains[_tokenId];\n', '    captainId = captain.captainId;\n', '    color = captain.color;\n', '    atk = captain.atk;\n', '    defense = captain.defense;\n', '    level = captain.level;\n', '    exp = captain.exp;\n', '    price = captainTokenIdToPrice[_tokenId];\n', '    owner = captainTokenIdToOwner[_tokenId];\n', '    selled = tokenToSell[_tokenId];\n', '  }\n', '\n', '  /// @dev levelUp \n', '  function LevelUp(uint256 _tokenId,uint32 _level) external payable {\n', '    require(msg.sender == captainTokenIdToOwner[_tokenId]);\n', '    Captain storage captain = captains[_tokenId];\n', '    uint32 captainId = captain.captainId;\n', '    uint32 level = captain.level;\n', '    uint256 cur_exp = SafeMath.mul(SafeMath.mul(level,SafeMath.sub(level,1)),25); // level*(level-1)*25\n', '    uint256 req_exp = SafeMath.mul(SafeMath.mul(_level,SafeMath.sub(_level,1)),25);\n', '    require(captain.exp>=SafeMath.sub(req_exp,cur_exp));\n', '    uint256 exp = SafeMath.sub(captain.exp,SafeMath.sub(req_exp,cur_exp));\n', '    if (SafeMath.add32(level,_level)>=99) {\n', '      captains[_tokenId].level = 99;\n', '    } else {\n', '      captains[_tokenId].level = _level;\n', '    }\n', '\n', '    (captains[_tokenId].atk,captains[_tokenId].defense,,) = config.getLevelConfig(captainId,captains[_tokenId].level);\n', '    captains[_tokenId].exp = exp;\n', '    //event tell the world\n', '    LevelUP(msg.sender,level,captain.level);\n', '  }\n', '\n', '  /// ERC721 \n', '\n', '  function balanceOf(address _owner) external view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownerToCaptainArray[_owner].length;\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address) {\n', '    return captainTokenIdToOwner[_tokenId];\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, data);\n', '  }\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /// @dev Actually perform the safeTransferFrom\n', '  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) \n', '    internal\n', '    isValidToken(_tokenId) \n', '    canTransfer(_tokenId)\n', '    {\n', '    address owner = captainTokenIdToOwner[_tokenId];\n', '    require(owner != address(0) && owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '\n', '    // Do the callback after everything is done to avoid reentrancy attack\n', '    /*uint256 codeSize;\n', '    assembly { codeSize := extcodesize(_to) }\n', '    if (codeSize == 0) {\n', '      return;\n', '    }*/\n', '    bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '    // bytes4(keccak256("onERC721Received(address,uint256,bytes)")) = 0xf0b9e5ba;\n', '    require(retval == 0xf0b9e5ba);\n', '  }\n', '    \n', '  /// @dev Transfer ownership of an Captain, &#39;_to&#39; must be a vaild address, or the WAR will lost\n', '  /// @param _from The current owner of the Captain\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The Captain to transfer\n', '  function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        external\n', '        whenNotPaused\n', '        isValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '        payable\n', '    {\n', '    address owner = captainTokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(owner == _from);\n', '    require(_to != address(0));\n', '        \n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Safe transfer by trust contracts\n', '  function safeTransferByContract(address _from,address _to, uint256 _tokenId) \n', '  external\n', '  whenNotPaused\n', '  {\n', '    require(actionContracts[msg.sender]);\n', '\n', '    require(_tokenId >= 1 && _tokenId <= captains.length);\n', '    address owner = captainTokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(_to != address(0));\n', '    require(owner != _to);\n', '    require(_from == owner);\n', '\n', '    _transfer(owner, _to, _tokenId);\n', '  }\n', '\n', '  /// @dev Set or reaffirm the approved address for an captain\n', '  /// @param _approved The new approved captain controller\n', '  /// @param _tokenId The captain to approve\n', '  function approve(address _approved, uint256 _tokenId)\n', '    external\n', '    whenNotPaused \n', '    payable\n', '  {\n', '    address owner = captainTokenIdToOwner[_tokenId];\n', '    require(owner != address(0));\n', '    require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\n', '\n', '    captainTokenIdToApprovals[_tokenId] = _approved;\n', '    Approval(owner, _approved, _tokenId);\n', '  }\n', '\n', '  /// @dev Enable or disable approval for a third party ("operator") to manage all your asset.\n', '  /// @param _operator Address to add to the set of authorized operators.\n', '  /// @param _approved True if the operators is approved, false to revoke approval\n', '  function setApprovalForAll(address _operator, bool _approved) \n', '    external \n', '    whenNotPaused\n', '  {\n', '    operatorToApprovals[msg.sender][_operator] = _approved;\n', '    ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @dev Get the approved address for a single Captain\n', '  /// @param _tokenId The WAR to find the approved address for\n', '  /// @return The approved address for this WAR, or the zero address if there is none\n', '  function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\n', '    return captainTokenIdToApprovals[_tokenId];\n', '  }\n', '  \n', '  /// @dev Query if an address is an authorized operator for another address\n', '  /// @param _owner The address that owns the WARs\n', '  /// @param _operator The address that acts on behalf of the owner\n', '  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '    return operatorToApprovals[_owner][_operator];\n', '  }\n', '  /// @notice A descriptive name for a collection of NFTs in this contract\n', '  function name() public pure returns(string) {\n', '    return "Pirate Conquest Token";\n', '  }\n', '  /// @notice An abbreviated name for NFTs in this contract\n', '  function symbol() public pure returns(string) {\n', '    return "PCT";\n', '  }\n', '  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '  ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '  ///  Metadata JSON Schema".\n', '  //function tokenURI(uint256 _tokenId) external view returns (string);\n', '\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  function totalSupply() external view returns (uint256) {\n', '    return captains.length - destroyCaptainCount -1;\n', '  }\n', '  /// @notice Enumerate valid NFTs\n', '  /// @dev Throws if `_index` >= `totalSupply()`.\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for the `_index`th NFT,\n', '  ///  (sort order not specified)\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '    require(_index<(captains.length - destroyCaptainCount));\n', '    //return captainIdToOwnerIndex[_index];\n', '    return _index;\n', '  }\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '    require(_index < ownerToCaptainArray[_owner].length);\n', '    if (_owner != address(0)) {\n', '      uint256 tokenId = ownerToCaptainArray[_owner][_index];\n', '      return tokenId;\n', '    }\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) external view returns (uint256[],uint32[]) {\n', '    uint256 len = ownerToCaptainArray[_owner].length;\n', '    uint256[] memory tokens = new uint256[](len);\n', '    uint32[] memory captainss = new uint32[](len);\n', '    uint256 icount;\n', '    if (_owner != address(0)) {\n', '      for (uint256 i=0;i<len;i++) {\n', '        tokens[i] = ownerToCaptainArray[_owner][icount];\n', '        captainss[i] = IndexToCaptain[ownerToCaptainArray[_owner][icount]];\n', '        icount++;\n', '      }\n', '    }\n', '    return (tokens,captainss);\n', '  }\n', '\n', '  /// @param _captainId The captain whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfCaptain(uint32 _captainId) public view returns(uint256[] captainTokens) {\n', '    uint256 tokenCount = tokenCountOfCaptain[_captainId];\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalcaptains = captains.length - destroyCaptainCount - 1;\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 tokenId;\n', '      for (tokenId = 0; tokenId <= totalcaptains; tokenId++) {\n', '        if (IndexToCaptain[tokenId] == _captainId) {\n', '          result[resultIndex] = tokenId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  } \n', '}']