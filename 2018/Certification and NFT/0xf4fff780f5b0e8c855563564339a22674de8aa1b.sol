['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require(b <= a);\n', '    c = a - b;\n', '  }\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require(a == 0 || c / a == b);\n', '  }\n', '  function div(uint a, uint b) internal pure returns (uint c) {\n', '    require(b > 0);\n', '    c = a / b;\n', '  }\n', '}\n', '\n', 'contract ERC20Interface {\n', '  function totalSupply()\n', '    public\n', '    constant\n', '    returns(uint);\n', '  function balanceOf(\n', '    address tokenOwner)\n', '    public\n', '    constant\n', '    returns(uint balance);\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender)\n', '    public\n', '    constant\n', '    returns(uint approve);\n', '  function transfer(\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '  function approve(\n', '    address spender,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens);\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '    newOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '  function receiveApproval(\n', '    address from,\n', '    uint256 tokens,\n', '    address token,\n', '    bytes data) public;\n', '}\n', '\n', 'contract CryptopusToken is ERC20Interface, Owned {\n', '  using SafeMath for uint;\n', '\n', '  address public preSaleContract;\n', '\n', '  string public symbol;\n', '  string public name;\n', '  uint8 public decimals;\n', '  uint public _totalSupply;\n', '  uint public saleLimit;\n', '  uint public alreadySold;\n', '\n', '  uint public firstWavePrice;\n', '  uint public secondWavePrice;\n', '  uint public thirdWavePrice;\n', '\n', '  bool public saleOngoing;\n', '\n', '  mapping(address => uint8) approved;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowed;\n', '\n', '  function CryptopusToken() public {\n', '    symbol = "CPP";\n', '    name = "Cryptopus Token";\n', '    decimals = 18;\n', '    _totalSupply = 100000000 * 10**uint(decimals);\n', '    saleLimit = 40000000 * 10**uint(decimals);\n', '    alreadySold = 0;\n', '    balances[owner] = _totalSupply;\n', '    Transfer(address(0), owner, _totalSupply);\n', '    firstWavePrice = 0.0008 ether;\n', '    secondWavePrice = 0.0009 ether;\n', '    thirdWavePrice = 0.001 ether;\n', '    saleOngoing = false;\n', '  }\n', '\n', '  modifier onlyIfOngoing() {\n', '    require(saleOngoing);\n', '    _;\n', '  }\n', '\n', '  modifier onlyApproved(address _owner) {\n', '    require(approved[_owner] != 0);\n', '    _;\n', '  }\n', '\n', '  function setPrices(\n', '    uint _newPriceFirst,\n', '    uint _newPriceSecond,\n', '    uint _newPriceThird)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    firstWavePrice = _newPriceFirst;\n', '    secondWavePrice = _newPriceSecond;\n', '    thirdWavePrice = _newPriceThird;\n', '    return true;\n', '  }\n', '\n', '  function setPreSaleContract(\n', '    address _owner)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    preSaleContract = _owner;\n', '    return true;\n', '  }\n', '\n', '  function updateSaleStatus()\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    saleOngoing = !saleOngoing;\n', '    return true;\n', '  }\n', '\n', '  function pushToApproved(\n', '    address _contributor,\n', '    uint8 waveNumber)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    approved[_contributor] = waveNumber;\n', '    return true;\n', '  }\n', '\n', '  function totalSupply()\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return _totalSupply - balances[address(0)];\n', '  }\n', '\n', '  function balanceOf(\n', '    address tokenOwner)\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function transfer(\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(\n', '    address spender,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender)\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '\n', '  function approveAndCall(\n', '    address spender,\n', '    uint tokens,\n', '    bytes data)\n', '    public\n', '    returns(bool) {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    ApproveAndCallFallBack(spender)\n', '      .receiveApproval(\n', '        msg.sender,\n', '        tokens,\n', '        this,\n', '        data);\n', '    return true;\n', '  }\n', '\n', '  function burnTokens(\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[address(0)] = balances[address(0)].add(tokens);\n', '    Transfer(msg.sender, address(0), tokens);\n', '    return true;\n', '  }\n', '\n', '  function withdraw()\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    owner.transfer(address(this).balance);\n', '    return true;\n', '  }\n', '\n', '  function exchangeTokens()\n', '    public\n', '    returns(bool) {\n', '    uint tokens = uint(\n', '      ERC20Interface(preSaleContract)\n', '        .allowance(msg.sender, this));\n', '    require(tokens > 0 &&\n', '            ERC20Interface(preSaleContract)\n', '              .balanceOf(msg.sender) == tokens);\n', '    ERC20Interface(preSaleContract)\n', '      .transferFrom(msg.sender, address(0), tokens);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    Transfer(owner, msg.sender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function()\n', '    public\n', '    onlyIfOngoing\n', '    onlyApproved(msg.sender)\n', '    payable {\n', '    uint tokenPrice;\n', '    if(approved[msg.sender] == 1) {\n', '      tokenPrice = firstWavePrice;\n', '    } else if(approved[msg.sender] == 2) {\n', '      tokenPrice = secondWavePrice;\n', '    } else if(approved[msg.sender] == 3) {\n', '      tokenPrice = thirdWavePrice;\n', '    } else {\n', '      revert();\n', '    }\n', '    require(msg.value >= tokenPrice);\n', '    uint tokenAmount = (msg.value / tokenPrice) * 10 ** uint(decimals);\n', '    require(saleOngoing && alreadySold.add(tokenAmount) <= saleLimit);\n', '    balances[owner] = balances[owner].sub(tokenAmount);\n', '    balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '    alreadySold = alreadySold.add(tokenAmount);\n', '    Transfer(owner, msg.sender, tokenAmount);\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath {\n', '  function add(uint a, uint b) internal pure returns (uint c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '  function sub(uint a, uint b) internal pure returns (uint c) {\n', '    require(b <= a);\n', '    c = a - b;\n', '  }\n', '  function mul(uint a, uint b) internal pure returns (uint c) {\n', '    c = a * b;\n', '    require(a == 0 || c / a == b);\n', '  }\n', '  function div(uint a, uint b) internal pure returns (uint c) {\n', '    require(b > 0);\n', '    c = a / b;\n', '  }\n', '}\n', '\n', 'contract ERC20Interface {\n', '  function totalSupply()\n', '    public\n', '    constant\n', '    returns(uint);\n', '  function balanceOf(\n', '    address tokenOwner)\n', '    public\n', '    constant\n', '    returns(uint balance);\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender)\n', '    public\n', '    constant\n', '    returns(uint approve);\n', '  function transfer(\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '  function approve(\n', '    address spender,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool success);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint tokens);\n', '  event Approval(\n', '    address indexed tokenOwner,\n', '    address indexed spender,\n', '    uint tokens);\n', '}\n', '\n', 'contract Owned {\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  function Owned() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '    newOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '  function receiveApproval(\n', '    address from,\n', '    uint256 tokens,\n', '    address token,\n', '    bytes data) public;\n', '}\n', '\n', 'contract CryptopusToken is ERC20Interface, Owned {\n', '  using SafeMath for uint;\n', '\n', '  address public preSaleContract;\n', '\n', '  string public symbol;\n', '  string public name;\n', '  uint8 public decimals;\n', '  uint public _totalSupply;\n', '  uint public saleLimit;\n', '  uint public alreadySold;\n', '\n', '  uint public firstWavePrice;\n', '  uint public secondWavePrice;\n', '  uint public thirdWavePrice;\n', '\n', '  bool public saleOngoing;\n', '\n', '  mapping(address => uint8) approved;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowed;\n', '\n', '  function CryptopusToken() public {\n', '    symbol = "CPP";\n', '    name = "Cryptopus Token";\n', '    decimals = 18;\n', '    _totalSupply = 100000000 * 10**uint(decimals);\n', '    saleLimit = 40000000 * 10**uint(decimals);\n', '    alreadySold = 0;\n', '    balances[owner] = _totalSupply;\n', '    Transfer(address(0), owner, _totalSupply);\n', '    firstWavePrice = 0.0008 ether;\n', '    secondWavePrice = 0.0009 ether;\n', '    thirdWavePrice = 0.001 ether;\n', '    saleOngoing = false;\n', '  }\n', '\n', '  modifier onlyIfOngoing() {\n', '    require(saleOngoing);\n', '    _;\n', '  }\n', '\n', '  modifier onlyApproved(address _owner) {\n', '    require(approved[_owner] != 0);\n', '    _;\n', '  }\n', '\n', '  function setPrices(\n', '    uint _newPriceFirst,\n', '    uint _newPriceSecond,\n', '    uint _newPriceThird)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    firstWavePrice = _newPriceFirst;\n', '    secondWavePrice = _newPriceSecond;\n', '    thirdWavePrice = _newPriceThird;\n', '    return true;\n', '  }\n', '\n', '  function setPreSaleContract(\n', '    address _owner)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    preSaleContract = _owner;\n', '    return true;\n', '  }\n', '\n', '  function updateSaleStatus()\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    saleOngoing = !saleOngoing;\n', '    return true;\n', '  }\n', '\n', '  function pushToApproved(\n', '    address _contributor,\n', '    uint8 waveNumber)\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    approved[_contributor] = waveNumber;\n', '    return true;\n', '  }\n', '\n', '  function totalSupply()\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return _totalSupply - balances[address(0)];\n', '  }\n', '\n', '  function balanceOf(\n', '    address tokenOwner)\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return balances[tokenOwner];\n', '  }\n', '\n', '  function transfer(\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(msg.sender, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function approve(\n', '    address spender,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[from] = balances[from].sub(tokens);\n', '    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '    balances[to] = balances[to].add(tokens);\n', '    Transfer(from, to, tokens);\n', '    return true;\n', '  }\n', '\n', '  function allowance(\n', '    address tokenOwner,\n', '    address spender)\n', '    public\n', '    constant\n', '    returns(uint) {\n', '    return allowed[tokenOwner][spender];\n', '  }\n', '\n', '  function approveAndCall(\n', '    address spender,\n', '    uint tokens,\n', '    bytes data)\n', '    public\n', '    returns(bool) {\n', '    allowed[msg.sender][spender] = tokens;\n', '    Approval(msg.sender, spender, tokens);\n', '    ApproveAndCallFallBack(spender)\n', '      .receiveApproval(\n', '        msg.sender,\n', '        tokens,\n', '        this,\n', '        data);\n', '    return true;\n', '  }\n', '\n', '  function burnTokens(\n', '    uint tokens)\n', '    public\n', '    returns(bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    balances[address(0)] = balances[address(0)].add(tokens);\n', '    Transfer(msg.sender, address(0), tokens);\n', '    return true;\n', '  }\n', '\n', '  function withdraw()\n', '    public\n', '    onlyOwner\n', '    returns(bool) {\n', '    owner.transfer(address(this).balance);\n', '    return true;\n', '  }\n', '\n', '  function exchangeTokens()\n', '    public\n', '    returns(bool) {\n', '    uint tokens = uint(\n', '      ERC20Interface(preSaleContract)\n', '        .allowance(msg.sender, this));\n', '    require(tokens > 0 &&\n', '            ERC20Interface(preSaleContract)\n', '              .balanceOf(msg.sender) == tokens);\n', '    ERC20Interface(preSaleContract)\n', '      .transferFrom(msg.sender, address(0), tokens);\n', '    balances[owner] = balances[owner].sub(tokens);\n', '    balances[msg.sender] = balances[msg.sender].add(tokens);\n', '    Transfer(owner, msg.sender, tokens);\n', '    return true;\n', '  }\n', '\n', '  function()\n', '    public\n', '    onlyIfOngoing\n', '    onlyApproved(msg.sender)\n', '    payable {\n', '    uint tokenPrice;\n', '    if(approved[msg.sender] == 1) {\n', '      tokenPrice = firstWavePrice;\n', '    } else if(approved[msg.sender] == 2) {\n', '      tokenPrice = secondWavePrice;\n', '    } else if(approved[msg.sender] == 3) {\n', '      tokenPrice = thirdWavePrice;\n', '    } else {\n', '      revert();\n', '    }\n', '    require(msg.value >= tokenPrice);\n', '    uint tokenAmount = (msg.value / tokenPrice) * 10 ** uint(decimals);\n', '    require(saleOngoing && alreadySold.add(tokenAmount) <= saleLimit);\n', '    balances[owner] = balances[owner].sub(tokenAmount);\n', '    balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '    alreadySold = alreadySold.add(tokenAmount);\n', '    Transfer(owner, msg.sender, tokenAmount);\n', '  }\n', '}']
