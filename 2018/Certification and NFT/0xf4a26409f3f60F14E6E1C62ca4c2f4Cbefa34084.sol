['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// WhiteListed - SENC Token Sale Whitelisting Contract\n', '//\n', '// Copyright (c) 2018 InfoCorp Technologies Pte Ltd.\n', '// http://www.sentinel-chain.org/\n', '//\n', '// The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', '// ----------------------------------------------------------------------------\n', '// The SENC Token Sale Whitelist Contract is designed to facilitate the features:\n', '//\n', '// 1. Track whitelisted users and allocations\n', '// Each whitelisted user is tracked by its wallet address as well as the maximum\n', '// SENC allocation it can purchase.\n', '//\n', '// 2. Track batches\n', '// To prevent a gas war, each contributor will be assigned a batch number that\n', '// corresponds to the time that the contributor can start purchasing.\n', '//\n', '// 3. Whitelist Operators\n', '// A primary and a secondary operators can be assigned to facilitate the management\n', '// of the whiteList.\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract OperatableBasic {\n', '    function setPrimaryOperator (address addr) public;\n', '    function setSecondaryOperator (address addr) public;\n', '    function isPrimaryOperator(address addr) public view returns (bool);\n', '    function isSecondaryOperator(address addr) public view returns (bool);\n', '}\n', '\n', 'contract Operatable is Ownable, OperatableBasic {\n', '    address public primaryOperator;\n', '    address public secondaryOperator;\n', '\n', '    modifier canOperate() {\n', '        require(msg.sender == primaryOperator || msg.sender == secondaryOperator || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Operatable() public {\n', '        primaryOperator = owner;\n', '        secondaryOperator = owner;\n', '    }\n', '\n', '    function setPrimaryOperator (address addr) public onlyOwner {\n', '        primaryOperator = addr;\n', '    }\n', '\n', '    function setSecondaryOperator (address addr) public onlyOwner {\n', '        secondaryOperator = addr;\n', '    }\n', '\n', '    function isPrimaryOperator(address addr) public view returns (bool) {\n', '        return (addr == primaryOperator);\n', '    }\n', '\n', '    function isSecondaryOperator(address addr) public view returns (bool) {\n', '        return (addr == secondaryOperator);\n', '    }\n', '}\n', '\n', 'contract WhiteListedBasic is OperatableBasic {\n', '    function addWhiteListed(address[] addrs, uint[] batches, uint[] weiAllocation) external;\n', '    function getAllocated(address addr) public view returns (uint);\n', '    function getBatchNumber(address addr) public view returns (uint);\n', '    function getWhiteListCount() public view returns (uint);\n', '    function isWhiteListed(address addr) public view returns (bool);\n', '    function removeWhiteListed(address addr) public;\n', '    function setAllocation(address[] addrs, uint[] allocation) public;\n', '    function setBatchNumber(address[] addrs, uint[] batch) public;\n', '}\n', '\n', 'contract WhiteListed is Operatable, WhiteListedBasic {\n', '\n', '    struct Batch {\n', '        bool isWhitelisted;\n', '        uint weiAllocated;\n', '        uint batchNumber;\n', '    }\n', '\n', '    uint public count;\n', '    mapping (address => Batch) public batchMap;\n', '\n', '    event Whitelisted(address indexed addr, uint whitelistedCount, bool isWhitelisted, uint indexed batch, uint weiAllocation);\n', '\n', '    function addWhiteListed(address[] addrs, uint[] batches, uint[] weiAllocation) external canOperate {\n', '        require(addrs.length == batches.length);\n', '        require(addrs.length == weiAllocation.length);\n', '        for (uint i = 0; i < addrs.length; i++) {\n', '            Batch storage batch = batchMap[addrs[i]];\n', '            if (batch.isWhitelisted != true) {\n', '                batch.isWhitelisted = true;\n', '                batch.weiAllocated = weiAllocation[i];\n', '                batch.batchNumber = batches[i];\n', '                count++;\n', '                Whitelisted(addrs[i], count, true, batches[i], weiAllocation[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getAllocated(address addr) public view returns (uint) {\n', '        return batchMap[addr].weiAllocated;\n', '    }\n', '\n', '    function getBatchNumber(address addr) public view returns (uint) {\n', '        return batchMap[addr].batchNumber;\n', '    }\n', '\n', '    function getWhiteListCount() public view returns (uint) {\n', '        return count;\n', '    }\n', '\n', '    function isWhiteListed(address addr) public view returns (bool) {\n', '        return batchMap[addr].isWhitelisted;\n', '    }\n', '\n', '    function removeWhiteListed(address addr) public canOperate {\n', '        Batch storage batch = batchMap[addr];\n', '        require(batch.isWhitelisted == true); \n', '        batch.isWhitelisted = false;\n', '        count--;\n', '        Whitelisted(addr, count, false, batch.batchNumber, batch.weiAllocated);\n', '    }\n', '\n', '    function setAllocation(address[] addrs, uint[] weiAllocation) public canOperate {\n', '        require(addrs.length == weiAllocation.length);\n', '        for (uint i = 0; i < addrs.length; i++) {\n', '            if (batchMap[addrs[i]].isWhitelisted == true) {\n', '                batchMap[addrs[i]].weiAllocated = weiAllocation[i];\n', '            }\n', '        }\n', '    }\n', '\n', '    function setBatchNumber(address[] addrs, uint[] batch) public canOperate {\n', '        require(addrs.length == batch.length);\n', '        for (uint i = 0; i < addrs.length; i++) {\n', '            if (batchMap[addrs[i]].isWhitelisted == true) {\n', '                batchMap[addrs[i]].batchNumber = batch[i];\n', '            }\n', '        }\n', '    }\n', '}']