['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/includes/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/includes/Claimable.sol\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    // emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '// File: contracts/includes/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/CelebsPartyGate.sol\n', '\n', 'contract CelebsPartyGate is Claimable, Pausable {\n', '  address public cfoAddress;\n', '  \n', '  function CelebsPartyGate() public {\n', '    cfoAddress = msg.sender;\n', '  }\n', '\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  function setCFO(address _newCFO) external onlyOwner {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '}\n', '\n', '// File: contracts/includes/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/CelebsParty.sol\n', '\n', 'contract CelebsParty is CelebsPartyGate {\n', '    using SafeMath for uint256;\n', '\n', '    event AgentHired(uint256 identifier, address player, bool queued);\n', '    event Birth(uint256 identifier, string name, address owner, bool queued);\n', '    event CategoryCreated(uint256 indexed identifier, string name);\n', '    event CelebrityBought(uint256 indexed identifier, address indexed oldOwner, address indexed newOwner, uint256 price);\n', '    event CelebrityReleased(uint256 indexed identifier, address player);\n', '    event FameAcquired(uint256 indexed identifier, address player, uint256 fame);\n', '    event PriceUpdated(uint256 indexed identifier, uint256 price);\n', '    event PrizeAwarded(address player, uint256 amount, string reason);\n', '    event UsernameUpdated(address player, string username);\n', '\n', '    struct Category {\n', '        uint256 identifier;\n', '        string name;\n', '    }\n', '\n', '    struct Celebrity {\n', '        uint256 identifier;\n', '        uint256[] categories;\n', '        string name;\n', '        uint256 price;\n', '        address owner;\n', '        bool isQueued;\n', '        uint256 lastQueueBlock;\n', '        address agent;\n', '        uint256 agentAwe;\n', '        uint256 famePerBlock;\n', '        uint256 lastFameBlock;\n', '    }\n', '\n', '    mapping(uint256 => Category) public categories;\n', '    mapping(uint256 => Celebrity) public celebrities;\n', '    mapping(address => uint256) public fameBalance;\n', '    mapping(address => string) public usernames;\n', '    \n', '    uint256 public categoryCount;\n', '    uint256 public circulatingFame;\n', '    uint256 public celebrityCount;\n', '    uint256 public devBalance;\n', '    uint256 public prizePool;\n', '\n', '    uint256 public minRequiredBlockQueueTime;\n', '\n', '    function CelebsParty() public {\n', '        _initializeGame();\n', '    }\n', '\n', '    function acquireFame(uint256 _identifier) external {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address player = msg.sender;\n', '        require(celeb.owner == player);\n', '        uint256 acquiredFame = SafeMath.mul((block.number - celeb.lastFameBlock), celeb.famePerBlock);\n', '        fameBalance[player] = SafeMath.add(fameBalance[player], acquiredFame);\n', '        celeb.lastFameBlock = block.number;\n', '        // increase the supply of the fame\n', '        circulatingFame = SafeMath.add(circulatingFame, acquiredFame);\n', '        FameAcquired(_identifier, player, acquiredFame);\n', '    }\n', '\n', '    function becomeAgent(uint256 _identifier, uint256 _agentAwe) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address newAgent = msg.sender;\n', '        address oldAgent = celeb.agent;\n', '        uint256 currentAgentAwe = celeb.agentAwe;\n', '        // ensure current agent is not the current player\n', '        require(oldAgent != newAgent);\n', '        // ensure the player can afford to become the agent\n', '        require(fameBalance[newAgent] >= _agentAwe);\n', '        // ensure the sent fame is more than the current agent sent\n', '        require(_agentAwe > celeb.agentAwe);\n', '        // if we are pre-drop, reset timer and give some fame back to previous bidder\n', '        if (celeb.isQueued) {\n', '            // reset the queue block timer\n', '            celeb.lastQueueBlock = block.number;\n', '            // give the old agent 50% of their fame back (this is a fame burn)\n', '            if(oldAgent != address(this)) {\n', '                uint256 halfOriginalFame = SafeMath.div(currentAgentAwe, 2);\n', '                circulatingFame = SafeMath.add(circulatingFame, halfOriginalFame);\n', '                fameBalance[oldAgent] = SafeMath.add(fameBalance[oldAgent], halfOriginalFame);\n', '            }\n', '        }\n', '        // set the celebrity&#39;s agent to the current player\n', '        celeb.agent = newAgent;\n', '        // set the new min required bid\n', '        celeb.agentAwe = _agentAwe;\n', '        // deduct the sent fame amount from the current player&#39;s balance\n', '        circulatingFame = SafeMath.sub(circulatingFame, _agentAwe);\n', '        fameBalance[newAgent] = SafeMath.sub(fameBalance[newAgent], _agentAwe);\n', '        AgentHired(_identifier, newAgent, celeb.isQueued);\n', '    }\n', '\n', '    function buyCelebrity(uint256 _identifier) public payable whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        // ensure that the celebrity is on the market and not queued\n', '        require(!celeb.isQueued);\n', '        address oldOwner = celeb.owner;\n', '        uint256 salePrice = celeb.price;\n', '        address newOwner = msg.sender;\n', '        // ensure the current player is not the current owner\n', '        require(oldOwner != newOwner);\n', '        // ensure the current player can actually afford to buy the celebrity\n', '        require(msg.value >= salePrice);\n', '        address agent = celeb.agent;\n', '        // determine how much fame the celebrity has generated\n', '        uint256 generatedFame = uint256(SafeMath.mul((block.number - celeb.lastFameBlock), celeb.famePerBlock));\n', '        // 91% of the sale will go the previous owner\n', '        uint256 payment = uint256(SafeMath.div(SafeMath.mul(salePrice, 91), 100));\n', '        // 4% of the sale will go to the celebrity&#39;s agent\n', '        uint256 agentFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 4), 100));\n', '        // 3% of the sale will go to the developer of the game\n', '        uint256 devFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 3), 100));\n', '        // 2% of the sale will go to the prize pool\n', '        uint256 prizeFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 2), 100));\n', '        // calculate any excess wei that should be refunded\n', '        uint256 purchaseExcess = SafeMath.sub(msg.value, salePrice);\n', '        if (oldOwner != address(this)) {\n', '            // only transfer the funds if the contract doesn&#39;t own the celebrity (no pre-mine)\n', '            oldOwner.transfer(payment);\n', '        } else {\n', '            // if this is the first sale, main proceeds go to the prize pool\n', '            prizePool = SafeMath.add(prizePool, payment);\n', '        }\n', '        if (agent != address(this)) {\n', '            // send the agent their cut of the sale\n', '            agent.transfer(agentFee);\n', '        }\n', '        // new owner gets half of the unacquired, generated fame on the celebrity\n', '        uint256 spoils = SafeMath.div(generatedFame, 2);\n', '        circulatingFame = SafeMath.add(circulatingFame, spoils);\n', '        fameBalance[newOwner] = SafeMath.add(fameBalance[newOwner], spoils);\n', '        // don&#39;t send the dev anything, but make a note of it\n', '        devBalance = SafeMath.add(devBalance, devFee);\n', '        // increase the prize pool balance\n', '        prizePool = SafeMath.add(prizePool, prizeFee);\n', '        // set the new owner of the celebrity\n', '        celeb.owner = newOwner;\n', '        // set the new price of the celebrity\n', '        celeb.price = _nextPrice(salePrice);\n', '        // destroy all unacquired fame by resetting the block number\n', '        celeb.lastFameBlock = block.number;\n', '        // the fame acquired per block increases by 1 every time the celebrity is purchased\n', '        // this is capped at 100 fpb\n', '        if(celeb.famePerBlock < 100) {\n', '            celeb.famePerBlock = SafeMath.add(celeb.famePerBlock, 1);\n', '        }\n', '        // let the world know the celebrity has been purchased\n', '        CelebrityBought(_identifier, oldOwner, newOwner, salePrice);\n', '        // send the new owner any excess wei\n', '        newOwner.transfer(purchaseExcess);\n', '    }\n', '\n', '    function createCategory(string _name) external onlyOwner {\n', '        _mintCategory(_name);\n', '    }\n', '\n', '    function createCelebrity(string _name, address _owner, address _agent, uint256 _agentAwe, uint256 _price, bool _queued, uint256[] _categories) public onlyOwner {\n', '        require(celebrities[celebrityCount].price == 0);\n', '        address newOwner = _owner;\n', '        address newAgent = _agent;\n', '        if (newOwner == 0x0) {\n', '            newOwner = address(this);\n', '        }\n', '        if (newAgent == 0x0) {\n', '            newAgent = address(this);\n', '        }\n', '        uint256 newIdentifier = celebrityCount;\n', '        Celebrity memory celeb = Celebrity({\n', '            identifier: newIdentifier,\n', '            owner: newOwner,\n', '            price: _price,\n', '            name: _name,\n', '            famePerBlock: 0,\n', '            lastQueueBlock: block.number,\n', '            lastFameBlock: block.number,\n', '            agent: newAgent,\n', '            agentAwe: _agentAwe,\n', '            isQueued: _queued,\n', '            categories: _categories\n', '        });\n', '        celebrities[newIdentifier] = celeb;\n', '        celebrityCount = SafeMath.add(celebrityCount, 1);\n', '        Birth(newIdentifier, _name, _owner, _queued);\n', '    }\n', '    \n', '    function getCelebrity(uint256 _identifier) external view returns\n', '    (uint256 id, string name, uint256 price, uint256 nextPrice, address agent, uint256 agentAwe, address owner, uint256 fame, uint256 lastFameBlock, uint256[] cats, bool queued, uint256 lastQueueBlock)\n', '    {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        id = celeb.identifier;\n', '        name = celeb.name;\n', '        owner = celeb.owner;\n', '        agent = celeb.agent;\n', '        price = celeb.price;\n', '        fame = celeb.famePerBlock;\n', '        lastFameBlock = celeb.lastFameBlock;\n', '        nextPrice = _nextPrice(price);\n', '        cats = celeb.categories;\n', '        agentAwe = celeb.agentAwe;\n', '        queued = celeb.isQueued;\n', '        lastQueueBlock = celeb.lastQueueBlock;\n', '    }\n', '\n', '    function getFameBalance(address _player) external view returns(uint256) {\n', '        return fameBalance[_player];\n', '    }\n', '\n', '    function getUsername(address _player) external view returns(string) {\n', '        return usernames[_player];\n', '    }\n', '\n', '    function releaseCelebrity(uint256 _identifier) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address player = msg.sender;\n', '        // ensure that enough blocks have been mined (no one has bid within this time period)\n', '        require(block.number - celeb.lastQueueBlock >= minRequiredBlockQueueTime);\n', '        // ensure the celebrity isn&#39;t already released!\n', '        require(celeb.isQueued);\n', '        // ensure current agent is the current player\n', '        require(celeb.agent == player);\n', '        // celebrity is no longer queued and can be displayed on the market\n', '        celeb.isQueued = false;\n', '        CelebrityReleased(_identifier, player);\n', '    }\n', '\n', '    function setCelebrityPrice(uint256 _identifier, uint256 _price) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        // ensure the current player is the owner of the celebrity\n', '        require(msg.sender == celeb.owner);\n', '        // the player can only set a price that is lower than the current asking price\n', '        require(_price < celeb.price);\n', '        // set the new price \n', '        celeb.price = _price;\n', '        PriceUpdated(_identifier, _price);\n', '    }\n', '\n', '    function setRequiredBlockQueueTime(uint256 _blocks) external onlyOwner {\n', '        minRequiredBlockQueueTime = _blocks;\n', '    }\n', '\n', '    function setUsername(address _player, string _username) public {\n', '        // ensure the player to be changed is the current player\n', '        require(_player == msg.sender);\n', '        // set the username\n', '        usernames[_player] = _username;\n', '        UsernameUpdated(_player, _username);\n', '    }\n', '\n', '    function sendPrize(address _player, uint256 _amount, string _reason) external onlyOwner {\n', '        uint256 newPrizePoolAmount = prizePool - _amount;\n', '        require(prizePool >= _amount);\n', '        require(newPrizePoolAmount >= 0);\n', '        prizePool = newPrizePoolAmount;\n', '        _player.transfer(_amount);\n', '        PrizeAwarded(_player, _amount, _reason);\n', '    }\n', '\n', '    function withdrawDevBalance() external onlyOwner {\n', '        require(devBalance > 0);\n', '        uint256 withdrawAmount = devBalance;\n', '        devBalance = 0;\n', '        owner.transfer(withdrawAmount);\n', '    }\n', '\n', '    /**************************\n', '        internal funcs\n', '    ***************************/\n', '\n', '    function _nextPrice(uint256 currentPrice) internal pure returns(uint256) {\n', '        if (currentPrice < .1 ether) {\n', '            return currentPrice.mul(200).div(100);\n', '        } else if (currentPrice < 1 ether) {\n', '            return currentPrice.mul(150).div(100);\n', '        } else if (currentPrice < 10 ether) {\n', '            return currentPrice.mul(130).div(100);\n', '        } else {\n', '            return currentPrice.mul(120).div(100);\n', '        }\n', '    }\n', '\n', '    function _mintCategory(string _name) internal {\n', '        uint256 newIdentifier = categoryCount;\n', '        categories[newIdentifier] = Category(newIdentifier, _name);\n', '        CategoryCreated(newIdentifier, _name);\n', '        categoryCount = SafeMath.add(categoryCount, 1);\n', '    }\n', '\n', '    function _initializeGame() internal {\n', '        categoryCount = 0;\n', '        celebrityCount = 0;\n', '        minRequiredBlockQueueTime = 1000;\n', '        paused = true;\n', '        _mintCategory("business");\n', '        _mintCategory("film/tv");\n', '        _mintCategory("music");\n', '        _mintCategory("personality");\n', '        _mintCategory("tech");\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/includes/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/includes/Claimable.sol\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    // emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '// File: contracts/includes/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: contracts/CelebsPartyGate.sol\n', '\n', 'contract CelebsPartyGate is Claimable, Pausable {\n', '  address public cfoAddress;\n', '  \n', '  function CelebsPartyGate() public {\n', '    cfoAddress = msg.sender;\n', '  }\n', '\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  function setCFO(address _newCFO) external onlyOwner {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '}\n', '\n', '// File: contracts/includes/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/CelebsParty.sol\n', '\n', 'contract CelebsParty is CelebsPartyGate {\n', '    using SafeMath for uint256;\n', '\n', '    event AgentHired(uint256 identifier, address player, bool queued);\n', '    event Birth(uint256 identifier, string name, address owner, bool queued);\n', '    event CategoryCreated(uint256 indexed identifier, string name);\n', '    event CelebrityBought(uint256 indexed identifier, address indexed oldOwner, address indexed newOwner, uint256 price);\n', '    event CelebrityReleased(uint256 indexed identifier, address player);\n', '    event FameAcquired(uint256 indexed identifier, address player, uint256 fame);\n', '    event PriceUpdated(uint256 indexed identifier, uint256 price);\n', '    event PrizeAwarded(address player, uint256 amount, string reason);\n', '    event UsernameUpdated(address player, string username);\n', '\n', '    struct Category {\n', '        uint256 identifier;\n', '        string name;\n', '    }\n', '\n', '    struct Celebrity {\n', '        uint256 identifier;\n', '        uint256[] categories;\n', '        string name;\n', '        uint256 price;\n', '        address owner;\n', '        bool isQueued;\n', '        uint256 lastQueueBlock;\n', '        address agent;\n', '        uint256 agentAwe;\n', '        uint256 famePerBlock;\n', '        uint256 lastFameBlock;\n', '    }\n', '\n', '    mapping(uint256 => Category) public categories;\n', '    mapping(uint256 => Celebrity) public celebrities;\n', '    mapping(address => uint256) public fameBalance;\n', '    mapping(address => string) public usernames;\n', '    \n', '    uint256 public categoryCount;\n', '    uint256 public circulatingFame;\n', '    uint256 public celebrityCount;\n', '    uint256 public devBalance;\n', '    uint256 public prizePool;\n', '\n', '    uint256 public minRequiredBlockQueueTime;\n', '\n', '    function CelebsParty() public {\n', '        _initializeGame();\n', '    }\n', '\n', '    function acquireFame(uint256 _identifier) external {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address player = msg.sender;\n', '        require(celeb.owner == player);\n', '        uint256 acquiredFame = SafeMath.mul((block.number - celeb.lastFameBlock), celeb.famePerBlock);\n', '        fameBalance[player] = SafeMath.add(fameBalance[player], acquiredFame);\n', '        celeb.lastFameBlock = block.number;\n', '        // increase the supply of the fame\n', '        circulatingFame = SafeMath.add(circulatingFame, acquiredFame);\n', '        FameAcquired(_identifier, player, acquiredFame);\n', '    }\n', '\n', '    function becomeAgent(uint256 _identifier, uint256 _agentAwe) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address newAgent = msg.sender;\n', '        address oldAgent = celeb.agent;\n', '        uint256 currentAgentAwe = celeb.agentAwe;\n', '        // ensure current agent is not the current player\n', '        require(oldAgent != newAgent);\n', '        // ensure the player can afford to become the agent\n', '        require(fameBalance[newAgent] >= _agentAwe);\n', '        // ensure the sent fame is more than the current agent sent\n', '        require(_agentAwe > celeb.agentAwe);\n', '        // if we are pre-drop, reset timer and give some fame back to previous bidder\n', '        if (celeb.isQueued) {\n', '            // reset the queue block timer\n', '            celeb.lastQueueBlock = block.number;\n', '            // give the old agent 50% of their fame back (this is a fame burn)\n', '            if(oldAgent != address(this)) {\n', '                uint256 halfOriginalFame = SafeMath.div(currentAgentAwe, 2);\n', '                circulatingFame = SafeMath.add(circulatingFame, halfOriginalFame);\n', '                fameBalance[oldAgent] = SafeMath.add(fameBalance[oldAgent], halfOriginalFame);\n', '            }\n', '        }\n', "        // set the celebrity's agent to the current player\n", '        celeb.agent = newAgent;\n', '        // set the new min required bid\n', '        celeb.agentAwe = _agentAwe;\n', "        // deduct the sent fame amount from the current player's balance\n", '        circulatingFame = SafeMath.sub(circulatingFame, _agentAwe);\n', '        fameBalance[newAgent] = SafeMath.sub(fameBalance[newAgent], _agentAwe);\n', '        AgentHired(_identifier, newAgent, celeb.isQueued);\n', '    }\n', '\n', '    function buyCelebrity(uint256 _identifier) public payable whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        // ensure that the celebrity is on the market and not queued\n', '        require(!celeb.isQueued);\n', '        address oldOwner = celeb.owner;\n', '        uint256 salePrice = celeb.price;\n', '        address newOwner = msg.sender;\n', '        // ensure the current player is not the current owner\n', '        require(oldOwner != newOwner);\n', '        // ensure the current player can actually afford to buy the celebrity\n', '        require(msg.value >= salePrice);\n', '        address agent = celeb.agent;\n', '        // determine how much fame the celebrity has generated\n', '        uint256 generatedFame = uint256(SafeMath.mul((block.number - celeb.lastFameBlock), celeb.famePerBlock));\n', '        // 91% of the sale will go the previous owner\n', '        uint256 payment = uint256(SafeMath.div(SafeMath.mul(salePrice, 91), 100));\n', "        // 4% of the sale will go to the celebrity's agent\n", '        uint256 agentFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 4), 100));\n', '        // 3% of the sale will go to the developer of the game\n', '        uint256 devFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 3), 100));\n', '        // 2% of the sale will go to the prize pool\n', '        uint256 prizeFee = uint256(SafeMath.div(SafeMath.mul(salePrice, 2), 100));\n', '        // calculate any excess wei that should be refunded\n', '        uint256 purchaseExcess = SafeMath.sub(msg.value, salePrice);\n', '        if (oldOwner != address(this)) {\n', "            // only transfer the funds if the contract doesn't own the celebrity (no pre-mine)\n", '            oldOwner.transfer(payment);\n', '        } else {\n', '            // if this is the first sale, main proceeds go to the prize pool\n', '            prizePool = SafeMath.add(prizePool, payment);\n', '        }\n', '        if (agent != address(this)) {\n', '            // send the agent their cut of the sale\n', '            agent.transfer(agentFee);\n', '        }\n', '        // new owner gets half of the unacquired, generated fame on the celebrity\n', '        uint256 spoils = SafeMath.div(generatedFame, 2);\n', '        circulatingFame = SafeMath.add(circulatingFame, spoils);\n', '        fameBalance[newOwner] = SafeMath.add(fameBalance[newOwner], spoils);\n', "        // don't send the dev anything, but make a note of it\n", '        devBalance = SafeMath.add(devBalance, devFee);\n', '        // increase the prize pool balance\n', '        prizePool = SafeMath.add(prizePool, prizeFee);\n', '        // set the new owner of the celebrity\n', '        celeb.owner = newOwner;\n', '        // set the new price of the celebrity\n', '        celeb.price = _nextPrice(salePrice);\n', '        // destroy all unacquired fame by resetting the block number\n', '        celeb.lastFameBlock = block.number;\n', '        // the fame acquired per block increases by 1 every time the celebrity is purchased\n', '        // this is capped at 100 fpb\n', '        if(celeb.famePerBlock < 100) {\n', '            celeb.famePerBlock = SafeMath.add(celeb.famePerBlock, 1);\n', '        }\n', '        // let the world know the celebrity has been purchased\n', '        CelebrityBought(_identifier, oldOwner, newOwner, salePrice);\n', '        // send the new owner any excess wei\n', '        newOwner.transfer(purchaseExcess);\n', '    }\n', '\n', '    function createCategory(string _name) external onlyOwner {\n', '        _mintCategory(_name);\n', '    }\n', '\n', '    function createCelebrity(string _name, address _owner, address _agent, uint256 _agentAwe, uint256 _price, bool _queued, uint256[] _categories) public onlyOwner {\n', '        require(celebrities[celebrityCount].price == 0);\n', '        address newOwner = _owner;\n', '        address newAgent = _agent;\n', '        if (newOwner == 0x0) {\n', '            newOwner = address(this);\n', '        }\n', '        if (newAgent == 0x0) {\n', '            newAgent = address(this);\n', '        }\n', '        uint256 newIdentifier = celebrityCount;\n', '        Celebrity memory celeb = Celebrity({\n', '            identifier: newIdentifier,\n', '            owner: newOwner,\n', '            price: _price,\n', '            name: _name,\n', '            famePerBlock: 0,\n', '            lastQueueBlock: block.number,\n', '            lastFameBlock: block.number,\n', '            agent: newAgent,\n', '            agentAwe: _agentAwe,\n', '            isQueued: _queued,\n', '            categories: _categories\n', '        });\n', '        celebrities[newIdentifier] = celeb;\n', '        celebrityCount = SafeMath.add(celebrityCount, 1);\n', '        Birth(newIdentifier, _name, _owner, _queued);\n', '    }\n', '    \n', '    function getCelebrity(uint256 _identifier) external view returns\n', '    (uint256 id, string name, uint256 price, uint256 nextPrice, address agent, uint256 agentAwe, address owner, uint256 fame, uint256 lastFameBlock, uint256[] cats, bool queued, uint256 lastQueueBlock)\n', '    {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        id = celeb.identifier;\n', '        name = celeb.name;\n', '        owner = celeb.owner;\n', '        agent = celeb.agent;\n', '        price = celeb.price;\n', '        fame = celeb.famePerBlock;\n', '        lastFameBlock = celeb.lastFameBlock;\n', '        nextPrice = _nextPrice(price);\n', '        cats = celeb.categories;\n', '        agentAwe = celeb.agentAwe;\n', '        queued = celeb.isQueued;\n', '        lastQueueBlock = celeb.lastQueueBlock;\n', '    }\n', '\n', '    function getFameBalance(address _player) external view returns(uint256) {\n', '        return fameBalance[_player];\n', '    }\n', '\n', '    function getUsername(address _player) external view returns(string) {\n', '        return usernames[_player];\n', '    }\n', '\n', '    function releaseCelebrity(uint256 _identifier) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        address player = msg.sender;\n', '        // ensure that enough blocks have been mined (no one has bid within this time period)\n', '        require(block.number - celeb.lastQueueBlock >= minRequiredBlockQueueTime);\n', "        // ensure the celebrity isn't already released!\n", '        require(celeb.isQueued);\n', '        // ensure current agent is the current player\n', '        require(celeb.agent == player);\n', '        // celebrity is no longer queued and can be displayed on the market\n', '        celeb.isQueued = false;\n', '        CelebrityReleased(_identifier, player);\n', '    }\n', '\n', '    function setCelebrityPrice(uint256 _identifier, uint256 _price) public whenNotPaused {\n', '        Celebrity storage celeb = celebrities[_identifier];\n', '        // ensure the current player is the owner of the celebrity\n', '        require(msg.sender == celeb.owner);\n', '        // the player can only set a price that is lower than the current asking price\n', '        require(_price < celeb.price);\n', '        // set the new price \n', '        celeb.price = _price;\n', '        PriceUpdated(_identifier, _price);\n', '    }\n', '\n', '    function setRequiredBlockQueueTime(uint256 _blocks) external onlyOwner {\n', '        minRequiredBlockQueueTime = _blocks;\n', '    }\n', '\n', '    function setUsername(address _player, string _username) public {\n', '        // ensure the player to be changed is the current player\n', '        require(_player == msg.sender);\n', '        // set the username\n', '        usernames[_player] = _username;\n', '        UsernameUpdated(_player, _username);\n', '    }\n', '\n', '    function sendPrize(address _player, uint256 _amount, string _reason) external onlyOwner {\n', '        uint256 newPrizePoolAmount = prizePool - _amount;\n', '        require(prizePool >= _amount);\n', '        require(newPrizePoolAmount >= 0);\n', '        prizePool = newPrizePoolAmount;\n', '        _player.transfer(_amount);\n', '        PrizeAwarded(_player, _amount, _reason);\n', '    }\n', '\n', '    function withdrawDevBalance() external onlyOwner {\n', '        require(devBalance > 0);\n', '        uint256 withdrawAmount = devBalance;\n', '        devBalance = 0;\n', '        owner.transfer(withdrawAmount);\n', '    }\n', '\n', '    /**************************\n', '        internal funcs\n', '    ***************************/\n', '\n', '    function _nextPrice(uint256 currentPrice) internal pure returns(uint256) {\n', '        if (currentPrice < .1 ether) {\n', '            return currentPrice.mul(200).div(100);\n', '        } else if (currentPrice < 1 ether) {\n', '            return currentPrice.mul(150).div(100);\n', '        } else if (currentPrice < 10 ether) {\n', '            return currentPrice.mul(130).div(100);\n', '        } else {\n', '            return currentPrice.mul(120).div(100);\n', '        }\n', '    }\n', '\n', '    function _mintCategory(string _name) internal {\n', '        uint256 newIdentifier = categoryCount;\n', '        categories[newIdentifier] = Category(newIdentifier, _name);\n', '        CategoryCreated(newIdentifier, _name);\n', '        categoryCount = SafeMath.add(categoryCount, 1);\n', '    }\n', '\n', '    function _initializeGame() internal {\n', '        categoryCount = 0;\n', '        celebrityCount = 0;\n', '        minRequiredBlockQueueTime = 1000;\n', '        paused = true;\n', '        _mintCategory("business");\n', '        _mintCategory("film/tv");\n', '        _mintCategory("music");\n', '        _mintCategory("personality");\n', '        _mintCategory("tech");\n', '    }\n', '}']
