['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/OpenZeppelin/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/OpenZeppelin/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether.\n', ' */\n', '\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // Address of the contract owner\n', '  address public owner;\n', '\n', '  // The rate of tokens per ether. Only applied for the first tier, the first\n', '  // 150 million tokens sold\n', '  uint256 public rate;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '\n', '  // Amount of sold tokens\n', '  uint256 public soldTokens;\n', '\n', '  // Amount of tokens processed\n', '  uint256 public processedTokens;\n', '\n', '  // Amount of unsold tokens to burn\n', '  uint256 public unSoldTokens;\n', '\n', '  // Amount of locked tokens\n', '  uint256 public lockedTokens;\n', '\n', '  // Amount of alocated tokens\n', '  uint256 public allocatedTokens;\n', '\n', '  // Amount of distributed tokens\n', '  uint256 public distributedTokens;\n', '\n', '  // ICO state paused or not\n', '  bool public paused = false;\n', '\n', '  // Minimal amount to exchange in ETH\n', '  uint256 public minPurchase = 53 finney;\n', '\n', '  // Keeping track of current round\n', '  uint256 public currentRound;\n', '\n', '  // We can only sell maximum total amount- 1,000,000,000 tokens during the ICO\n', '  uint256 public constant maxTokensRaised = 1000000000E4;\n', '\n', '  // Timestamp when the crowdsale starts 01/01/2018 @ 00:00am (UTC);\n', '  uint256 public startTime = 1527703200;\n', '\n', '  // Timestamp when the initial round ends (UTC);\n', '  uint256 public currentRoundStart = startTime;\n', '\n', '  // Timestamp when the crowdsale ends 07/07/2018 @ 00:00am (UTC);\n', '  uint256 public endTime = 1532386740;\n', '\n', '  // Timestamp when locked tokens become unlocked 21/09/2018 @ 00:00am (UTC);\n', '  uint256 public lockedTill = 1542931200;\n', '\n', '  // Timestamp when approved tokens become available 21/09/2018 @ 00:00am (UTC);\n', '  uint256 public approvedTill = 1535328000;\n', '\n', '  // How much each user paid for the crowdsale\n', '  mapping(address => uint256) public crowdsaleBalances;\n', '\n', '  // How many tokens each user got for the crowdsale\n', '  mapping(address => uint256) public tokensBought;\n', '\n', '  // How many tokens each user got for the crowdsale as bonus\n', '  mapping(address => uint256) public bonusBalances;\n', '\n', '  // How many tokens each user got locked\n', '  mapping(address => uint256) public lockedBalances;\n', '\n', '  // How many tokens each user got pre-delivered\n', '  mapping(address => uint256) public allocatedBalances;\n', '\n', '  // If user is approved to withdraw tokens\n', '  mapping(address => bool) public approved;\n', '\n', '  // How many tokens each user got distributed\n', '  mapping(address => uint256) public distributedBalances;\n', '\n', '  // Bonus levels per each round\n', '  mapping (uint256 => uint256) public bonusLevels;\n', '\n', '  // Rate levels per each round\n', '  mapping (uint256 => uint256) public rateLevels;\n', '\n', '  // Cap levels per each round\n', '  mapping (uint256 => uint256) public capLevels;\n', '\n', '  // To track list of contributors\n', '  address[] public allocatedAddresses;              \n', '\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '  function setNewBonusLevel (uint256 _bonusIndex, uint256 _bonusValue) onlyOwner external {\n', '    bonusLevels[_bonusIndex] = _bonusValue;\n', '  }\n', '\n', '  function setNewRateLevel (uint256 _rateIndex, uint256 _rateValue) onlyOwner external {\n', '    rateLevels[_rateIndex] = _rateValue;\n', '  }\n', '\n', '  function setMinPurchase (uint256 _minPurchase) onlyOwner external {\n', '    minPurchase = _minPurchase;\n', '  }\n', '\n', '   // @notice Set&#39;s the rate of tokens per ether for each round\n', '  function setNewRatesCustom (uint256 _r1, uint256 _r2, uint256 _r3, uint256 _r4, uint256 _r5, uint256 _r6) onlyOwner external {\n', '    require(_r1 > 0 && _r2 > 0 && _r3 > 0 && _r4 > 0 && _r5 > 0 && _r6 > 0);\n', '    rateLevels[1] = _r1;\n', '    rateLevels[2] = _r2;\n', '    rateLevels[3] = _r3;\n', '    rateLevels[4] = _r4;\n', '    rateLevels[5] = _r5;\n', '    rateLevels[6] = _r6;\n', '  }\n', '\n', '   // @notice Set&#39;s the rate of tokens per ether for each round\n', '  function setNewRatesBase (uint256 _r1) onlyOwner external {\n', '    require(_r1 > 0);\n', '    rateLevels[1] = _r1;\n', '    rateLevels[2] = _r1.div(2);\n', '    rateLevels[3] = _r1.div(3);\n', '    rateLevels[4] = _r1.div(4);\n', '    rateLevels[5] = _r1.div(5);\n', '    rateLevels[6] = _r1.div(5);\n', '  }\n', '\n', '  /**\n', '   * @param _rate Number of token units a buyer gets per ETH\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   */\n', '\n', '  constructor(uint256 _rate, address _wallet, address _owner, ERC20 _token) public {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '\n', '    wallet = _wallet;\n', '    token = _token;\n', '    owner = _owner;\n', '\n', '    soldTokens = 0;\n', '    unSoldTokens = 0;\n', '    processedTokens = 0;\n', '\n', '    lockedTokens = 0;\n', '    distributedTokens = 0;\n', '\n', '    currentRound = 1;\n', '\n', '    //bonus values per each round;\n', '    bonusLevels[1] =  5;\n', '    bonusLevels[2] = 10;\n', '    bonusLevels[3] = 15;\n', '    bonusLevels[4] = 20;\n', '    bonusLevels[5] = 50;\n', '    bonusLevels[6] = 0;\n', '\n', '    //rate values per each round;\n', '    rateLevels[1] = _rate;\n', '    rateLevels[2] = _rate.div(2);\n', '    rateLevels[3] = _rate.div(3);\n', '    rateLevels[4] = _rate.div(4);\n', '    rateLevels[5] = _rate.div(5);\n', '    rateLevels[6] = _rate.div(5);\n', '\n', '    //cap values per each round\n', '    capLevels[1] = 150000000E4;\n', '    capLevels[2] = 210000000E4;\n', '    capLevels[3] = 255000000E4;\n', '    capLevels[4] = 285000000E4;\n', '    capLevels[5] = 300000000E4;\n', '    capLevels[6] = maxTokensRaised;\n', '\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Crowdsale interface\n', '  // -----------------------------------------\n', '\n', '  function () external payable whenNotPaused {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused {\n', '\n', '    uint256 amountPaid = msg.value;\n', '    _preValidatePurchase(_beneficiary, amountPaid);\n', '\n', '    uint256 tokens = 0;\n', '    uint256 bonusTokens = 0;\n', '    uint256 fullTokens = 0;\n', '\n', '    // Round 1\n', '    if(processedTokens < capLevels[1]) {\n', '\n', '        tokens = _getTokensAmount(amountPaid, 1);\n', '        bonusTokens = _getBonusAmount(tokens, 1);\n', '        fullTokens = tokens.add(bonusTokens);\n', '\n', '        // If the amount of tokens that you want to buy gets out of round 1\n', '        if(processedTokens.add(fullTokens) > capLevels[1]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 1);\n', '            bonusTokens = _calculateExcessBonus(tokens, 1);\n', '            setCurrentRound(2);\n', '        }\n', '\n', '    // Round 2\n', '    } else if(processedTokens >= capLevels[1] && processedTokens < capLevels[2]) {\n', '        tokens = _getTokensAmount(amountPaid, 2);\n', '        bonusTokens = _getBonusAmount(tokens, 2);\n', '        fullTokens = tokens.add(bonusTokens);\n', '\n', '        // If the amount of tokens that you want to buy gets out of round 2\n', '        if(processedTokens.add(fullTokens) > capLevels[2]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 2);\n', '            bonusTokens = _calculateExcessBonus(tokens, 2);\n', '            setCurrentRound(3);\n', '        }\n', '\n', '    // Round 3\n', '    } else if(processedTokens >= capLevels[2] && processedTokens < capLevels[3]) {\n', '         tokens = _getTokensAmount(amountPaid, 3);\n', '         bonusTokens = _getBonusAmount(tokens, 3);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 3\n', '         if(processedTokens.add(fullTokens) > capLevels[3]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 3);\n', '            bonusTokens = _calculateExcessBonus(tokens, 3);\n', '            setCurrentRound(4);\n', '         }\n', '\n', '    // Round 4\n', '    } else if(processedTokens >= capLevels[3] && processedTokens < capLevels[4]) {\n', '         tokens = _getTokensAmount(amountPaid, 4);\n', '         bonusTokens = _getBonusAmount(tokens, 4);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 4\n', '         if(processedTokens.add(fullTokens) > capLevels[4]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 4);\n', '            bonusTokens = _calculateExcessBonus(tokens, 4);\n', '            setCurrentRound(5);\n', '         }\n', '\n', '    // Round 5\n', '    } else if(processedTokens >= capLevels[4] && processedTokens < capLevels[5]) {\n', '         tokens = _getTokensAmount(amountPaid, 5);\n', '         bonusTokens = _getBonusAmount(tokens, 5);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 5\n', '         if(processedTokens.add(fullTokens) > capLevels[5]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 5);\n', '            bonusTokens = 0;\n', '            setCurrentRound(6);\n', '         }\n', '\n', '    // Round 6\n', '    } else if(processedTokens >= capLevels[5]) {\n', '        tokens = _getTokensAmount(amountPaid, 6);\n', '    }\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(amountPaid);\n', '    fullTokens = tokens.add(bonusTokens);\n', '    soldTokens = soldTokens.add(fullTokens);\n', '    processedTokens = processedTokens.add(fullTokens);\n', '\n', '    // Keep a record of how many tokens everybody gets in case we need to do refunds\n', '    tokensBought[msg.sender] = tokensBought[msg.sender].add(tokens);\n', '\n', '    // Kepp a record of how many wei everybody contributed in case we need to do refunds\n', '    crowdsaleBalances[msg.sender] = crowdsaleBalances[msg.sender].add(amountPaid);\n', '\n', '    // Kepp a record of how many token everybody got as bonus to display in\n', '    bonusBalances[msg.sender] = bonusBalances[msg.sender].add(bonusTokens);\n', '\n', '   // Combine bought tokens with bonus tokens before sending to investor\n', '    uint256 totalTokens = tokens.add(bonusTokens);\n', '\n', '    // Distribute the token\n', '    _processPurchase(_beneficiary, totalTokens);\n', '    emit TokenPurchase(\n', '      msg.sender,\n', '      _beneficiary,\n', '      amountPaid,\n', '      totalTokens\n', '    );\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\n', '\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '\n', '    bool withinPeriod = hasStarted() && hasNotEnded();\n', '    bool nonZeroPurchase = msg.value > 0;\n', '    bool withinTokenLimit = processedTokens < maxTokensRaised;\n', '    bool minimumPurchase = msg.value >= minPurchase;\n', '\n', '    require(withinPeriod);\n', '    require(nonZeroPurchase);\n', '    require(withinTokenLimit);\n', '    require(minimumPurchase);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    uint256 _tokensToPreAllocate = _tokenAmount.div(2);\n', '    uint256 _tokensToLock = _tokenAmount.sub(_tokensToPreAllocate);\n', '    \n', '    //record address for future distribution\n', '    allocatedAddresses.push(_beneficiary);    \n', '\n', '    //pre allocate 50% of purchase for delivery in 30 days\n', '    _preAllocateTokens(_beneficiary, _tokensToPreAllocate);\n', '    \n', '    //lock 50% of purchase for delivery after 4 months\n', '    _lockTokens(_beneficiary, _tokensToLock);\n', '    \n', '    //approve by default (dissaprove manually)\n', '    approved[_beneficiary] = true;\n', '  }\n', '\n', '  function _lockTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    lockedBalances[_beneficiary] = lockedBalances[_beneficiary].add(_tokenAmount);\n', '    lockedTokens = lockedTokens.add(_tokenAmount);\n', '  }\n', '\n', '  function _preAllocateTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    allocatedBalances[_beneficiary] = allocatedBalances[_beneficiary].add(_tokenAmount);\n', '    allocatedTokens = allocatedTokens.add(_tokenAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to bonus tokens.\n', '   * @param _tokenAmount Value in wei to be converted into tokens\n', '   * @return Number of bonus tokens that can be distributed with the specified bonus percent\n', '   */\n', '  function _getBonusAmount(uint256 _tokenAmount, uint256 _bonusIndex) internal view returns (uint256) {\n', '    uint256 bonusValue = _tokenAmount.mul(bonusLevels[_bonusIndex]);\n', '    return bonusValue.div(100);\n', '  }\n', '\n', '    function _calculateExcessBonus(uint256 _tokens, uint256 _level) internal view returns (uint256) {\n', '        uint256 thisLevelTokens = processedTokens.add(_tokens);\n', '        uint256 nextLevelTokens = thisLevelTokens.sub(capLevels[_level]);\n', '        uint256 totalBonus = _getBonusAmount(nextLevelTokens, _level.add(1));\n', '        return totalBonus;\n', '    }\n', '\n', '   function _calculateExcessTokens(\n', '      uint256 amount,\n', '      uint256 roundSelected\n', '   ) internal returns(uint256) {\n', '      require(amount > 0);\n', '      require(roundSelected >= 1 && roundSelected <= 6);\n', '\n', '      uint256 _rate = rateLevels[roundSelected];\n', '      uint256 _leftTokens = capLevels[roundSelected].sub(processedTokens);\n', '      uint256 weiThisRound = _leftTokens.div(_rate).mul(1E14);\n', '      uint256 weiNextRound = amount.sub(weiThisRound);\n', '      uint256 tokensNextRound = 0;\n', '\n', '      // If there&#39;s excessive wei for the last tier, refund those\n', '      uint256 nextRound = roundSelected.add(1);\n', '      if(roundSelected != 6) {\n', '        tokensNextRound = _getTokensAmount(weiNextRound, nextRound);\n', '      }\n', '      else {\n', '         msg.sender.transfer(weiNextRound);\n', '      }\n', '\n', '      uint256 totalTokens = _leftTokens.add(tokensNextRound);\n', '      return totalTokens;\n', '   }\n', '\n', '\n', '   function _getTokensAmount(uint256 weiPaid, uint256 roundSelected)\n', '        internal constant returns(uint256 calculatedTokens)\n', '   {\n', '      require(weiPaid > 0);\n', '      require(roundSelected >= 1 && roundSelected <= 6);\n', '      uint256 typeTokenWei = weiPaid.div(1E14);\n', '      calculatedTokens = typeTokenWei.mul(rateLevels[roundSelected]);\n', '\n', '   }\n', '\n', '  // -----------------------------------------\n', '  // External interface (withdraw)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Determines how ETH is being transfered to owners wallet.\n', '   */\n', '  function _withdrawAllFunds() onlyOwner external {\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function _withdrawWei(uint256 _amount) onlyOwner external {\n', '    wallet.transfer(_amount);\n', '  }\n', '\n', '   function _changeLockDate(uint256 _newDate) onlyOwner external {\n', '    require(_newDate <= endTime.add(36 weeks));\n', '    lockedTill = _newDate;\n', '  }\n', '\n', '   function _changeApproveDate(uint256 _newDate) onlyOwner external {\n', '    require(_newDate <= endTime.add(12 weeks));\n', '    approvedTill = _newDate;\n', '  }\n', '\n', '  function changeWallet(address _newWallet) onlyOwner external {\n', '    wallet = _newWallet;\n', '  }\n', '\n', '   /// @notice Public function to check if the crowdsale has ended or not\n', '   function hasNotEnded() public constant returns(bool) {\n', '      return now < endTime && processedTokens < maxTokensRaised;\n', '   }\n', '\n', '   /// @notice Public function to check if the crowdsale has started or not\n', '   function hasStarted() public constant returns(bool) {\n', '      return now > startTime;\n', '   }\n', '\n', '    function setCurrentRound(uint256 _roundIndex) internal {\n', '        currentRound = _roundIndex;\n', '        currentRoundStart = now;\n', '    }\n', '\n', '    //move to next round by overwriting soldTokens value, unsold tokens will be burned;\n', '   function goNextRound() onlyOwner external {\n', '       require(currentRound < 6);\n', '       uint256 notSold = getUnsold();\n', '       unSoldTokens = unSoldTokens.add(notSold);\n', '       processedTokens = capLevels[currentRound];\n', '       currentRound = currentRound.add(1);\n', '       currentRoundStart = now;\n', '   }\n', '\n', '    function getUnsold() internal view returns (uint256) {\n', '        uint256 unSold = capLevels[currentRound].sub(processedTokens);\n', '        return unSold;\n', '    }\n', '\n', '    function checkUnsold() onlyOwner external view returns (uint256) {\n', '        uint256 unSold = capLevels[currentRound].sub(processedTokens);\n', '        return unSold;\n', '    }\n', '\n', '    function round() public view returns(uint256) {\n', '        return currentRound;\n', '    }\n', '\n', '    function currentBonusLevel() public view returns(uint256) {\n', '        return bonusLevels[currentRound];\n', '    }\n', '\n', '    function currentRateLevel() public view returns(uint256) {\n', '        return rateLevels[currentRound];\n', '    }\n', '\n', '    function currentCapLevel() public view returns(uint256) {\n', '        return capLevels[currentRound];\n', '    }\n', '\n', '    function changeApproval(address _beneficiary, bool _newStatus) onlyOwner public {\n', '        approved[_beneficiary] = _newStatus;\n', '    }\n', '\n', '    function massApproval(bool _newStatus, uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            approved[allocatedAddresses[i]] = _newStatus;\n', '        }\n', '    }\n', '\n', '    function autoTransferApproved(uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            transferApprovedBalance(allocatedAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function autoTransferLocked(uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            transferLockedBalance(allocatedAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function transferApprovedBalance(address _beneficiary) public {\n', '        require(_beneficiary != address(0));\n', '        require(now >= approvedTill);\n', '        require(allocatedTokens > 0);\n', '        require(approved[_beneficiary]);\n', '        require(allocatedBalances[_beneficiary] > 0);\n', '        \n', '        uint256 _approvedTokensToTransfer = allocatedBalances[_beneficiary];\n', '        token.transfer(_beneficiary, _approvedTokensToTransfer);\n', '        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_approvedTokensToTransfer);\n', '        allocatedTokens = allocatedTokens.sub(_approvedTokensToTransfer);\n', '        allocatedBalances[_beneficiary] = 0;\n', '        distributedTokens = distributedTokens.add(_approvedTokensToTransfer);\n', '    }\n', '\n', '    function transferLockedBalance(address _beneficiary) public {\n', '        require(_beneficiary != address(0));\n', '        require(now >= lockedTill);\n', '        require(lockedTokens > 0);\n', '        require(approved[_beneficiary]);\n', '        require(lockedBalances[_beneficiary] > 0);\n', '\n', '        uint256 _lockedTokensToTransfer = lockedBalances[_beneficiary];\n', '        token.transfer(_beneficiary, _lockedTokensToTransfer);\n', '        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_lockedTokensToTransfer);\n', '        lockedTokens = lockedTokens.sub(_lockedTokensToTransfer);\n', '        lockedBalances[_beneficiary] = 0;\n', '        distributedTokens = distributedTokens.add(_lockedTokensToTransfer);\n', '    }\n', '\n', '    function transferToken(uint256 _tokens) external onlyOwner returns (bool success) {\n', '        //bool withinPeriod = hasStarted() && hasNotEnded();\n', '        //require(!withinPeriod);\n', '        return token.transfer(owner, _tokens);\n', '    }\n', '\n', '    function tokenBalance() public view returns (uint256) {\n', '        return token.balanceOf(address(this));\n', '    }\n', '\n', '    //destory contract with unsold tokens\n', '    function burnUnsold() public onlyOwner {\n', '        require(now > lockedTill);\n', '        require(address(this).balance == 0);\n', '        require(lockedTokens == 0);\n', '        require(allocatedTokens == 0);\n', '        require(unSoldTokens > 0);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/OpenZeppelin/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/OpenZeppelin/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether.\n', ' */\n', '\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // Address of the contract owner\n', '  address public owner;\n', '\n', '  // The rate of tokens per ether. Only applied for the first tier, the first\n', '  // 150 million tokens sold\n', '  uint256 public rate;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '\n', '  // Amount of sold tokens\n', '  uint256 public soldTokens;\n', '\n', '  // Amount of tokens processed\n', '  uint256 public processedTokens;\n', '\n', '  // Amount of unsold tokens to burn\n', '  uint256 public unSoldTokens;\n', '\n', '  // Amount of locked tokens\n', '  uint256 public lockedTokens;\n', '\n', '  // Amount of alocated tokens\n', '  uint256 public allocatedTokens;\n', '\n', '  // Amount of distributed tokens\n', '  uint256 public distributedTokens;\n', '\n', '  // ICO state paused or not\n', '  bool public paused = false;\n', '\n', '  // Minimal amount to exchange in ETH\n', '  uint256 public minPurchase = 53 finney;\n', '\n', '  // Keeping track of current round\n', '  uint256 public currentRound;\n', '\n', '  // We can only sell maximum total amount- 1,000,000,000 tokens during the ICO\n', '  uint256 public constant maxTokensRaised = 1000000000E4;\n', '\n', '  // Timestamp when the crowdsale starts 01/01/2018 @ 00:00am (UTC);\n', '  uint256 public startTime = 1527703200;\n', '\n', '  // Timestamp when the initial round ends (UTC);\n', '  uint256 public currentRoundStart = startTime;\n', '\n', '  // Timestamp when the crowdsale ends 07/07/2018 @ 00:00am (UTC);\n', '  uint256 public endTime = 1532386740;\n', '\n', '  // Timestamp when locked tokens become unlocked 21/09/2018 @ 00:00am (UTC);\n', '  uint256 public lockedTill = 1542931200;\n', '\n', '  // Timestamp when approved tokens become available 21/09/2018 @ 00:00am (UTC);\n', '  uint256 public approvedTill = 1535328000;\n', '\n', '  // How much each user paid for the crowdsale\n', '  mapping(address => uint256) public crowdsaleBalances;\n', '\n', '  // How many tokens each user got for the crowdsale\n', '  mapping(address => uint256) public tokensBought;\n', '\n', '  // How many tokens each user got for the crowdsale as bonus\n', '  mapping(address => uint256) public bonusBalances;\n', '\n', '  // How many tokens each user got locked\n', '  mapping(address => uint256) public lockedBalances;\n', '\n', '  // How many tokens each user got pre-delivered\n', '  mapping(address => uint256) public allocatedBalances;\n', '\n', '  // If user is approved to withdraw tokens\n', '  mapping(address => bool) public approved;\n', '\n', '  // How many tokens each user got distributed\n', '  mapping(address => uint256) public distributedBalances;\n', '\n', '  // Bonus levels per each round\n', '  mapping (uint256 => uint256) public bonusLevels;\n', '\n', '  // Rate levels per each round\n', '  mapping (uint256 => uint256) public rateLevels;\n', '\n', '  // Cap levels per each round\n', '  mapping (uint256 => uint256) public capLevels;\n', '\n', '  // To track list of contributors\n', '  address[] public allocatedAddresses;              \n', '\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '  function setNewBonusLevel (uint256 _bonusIndex, uint256 _bonusValue) onlyOwner external {\n', '    bonusLevels[_bonusIndex] = _bonusValue;\n', '  }\n', '\n', '  function setNewRateLevel (uint256 _rateIndex, uint256 _rateValue) onlyOwner external {\n', '    rateLevels[_rateIndex] = _rateValue;\n', '  }\n', '\n', '  function setMinPurchase (uint256 _minPurchase) onlyOwner external {\n', '    minPurchase = _minPurchase;\n', '  }\n', '\n', "   // @notice Set's the rate of tokens per ether for each round\n", '  function setNewRatesCustom (uint256 _r1, uint256 _r2, uint256 _r3, uint256 _r4, uint256 _r5, uint256 _r6) onlyOwner external {\n', '    require(_r1 > 0 && _r2 > 0 && _r3 > 0 && _r4 > 0 && _r5 > 0 && _r6 > 0);\n', '    rateLevels[1] = _r1;\n', '    rateLevels[2] = _r2;\n', '    rateLevels[3] = _r3;\n', '    rateLevels[4] = _r4;\n', '    rateLevels[5] = _r5;\n', '    rateLevels[6] = _r6;\n', '  }\n', '\n', "   // @notice Set's the rate of tokens per ether for each round\n", '  function setNewRatesBase (uint256 _r1) onlyOwner external {\n', '    require(_r1 > 0);\n', '    rateLevels[1] = _r1;\n', '    rateLevels[2] = _r1.div(2);\n', '    rateLevels[3] = _r1.div(3);\n', '    rateLevels[4] = _r1.div(4);\n', '    rateLevels[5] = _r1.div(5);\n', '    rateLevels[6] = _r1.div(5);\n', '  }\n', '\n', '  /**\n', '   * @param _rate Number of token units a buyer gets per ETH\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   */\n', '\n', '  constructor(uint256 _rate, address _wallet, address _owner, ERC20 _token) public {\n', '    require(_rate > 0);\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '\n', '    wallet = _wallet;\n', '    token = _token;\n', '    owner = _owner;\n', '\n', '    soldTokens = 0;\n', '    unSoldTokens = 0;\n', '    processedTokens = 0;\n', '\n', '    lockedTokens = 0;\n', '    distributedTokens = 0;\n', '\n', '    currentRound = 1;\n', '\n', '    //bonus values per each round;\n', '    bonusLevels[1] =  5;\n', '    bonusLevels[2] = 10;\n', '    bonusLevels[3] = 15;\n', '    bonusLevels[4] = 20;\n', '    bonusLevels[5] = 50;\n', '    bonusLevels[6] = 0;\n', '\n', '    //rate values per each round;\n', '    rateLevels[1] = _rate;\n', '    rateLevels[2] = _rate.div(2);\n', '    rateLevels[3] = _rate.div(3);\n', '    rateLevels[4] = _rate.div(4);\n', '    rateLevels[5] = _rate.div(5);\n', '    rateLevels[6] = _rate.div(5);\n', '\n', '    //cap values per each round\n', '    capLevels[1] = 150000000E4;\n', '    capLevels[2] = 210000000E4;\n', '    capLevels[3] = 255000000E4;\n', '    capLevels[4] = 285000000E4;\n', '    capLevels[5] = 300000000E4;\n', '    capLevels[6] = maxTokensRaised;\n', '\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Crowdsale interface\n', '  // -----------------------------------------\n', '\n', '  function () external payable whenNotPaused {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable whenNotPaused {\n', '\n', '    uint256 amountPaid = msg.value;\n', '    _preValidatePurchase(_beneficiary, amountPaid);\n', '\n', '    uint256 tokens = 0;\n', '    uint256 bonusTokens = 0;\n', '    uint256 fullTokens = 0;\n', '\n', '    // Round 1\n', '    if(processedTokens < capLevels[1]) {\n', '\n', '        tokens = _getTokensAmount(amountPaid, 1);\n', '        bonusTokens = _getBonusAmount(tokens, 1);\n', '        fullTokens = tokens.add(bonusTokens);\n', '\n', '        // If the amount of tokens that you want to buy gets out of round 1\n', '        if(processedTokens.add(fullTokens) > capLevels[1]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 1);\n', '            bonusTokens = _calculateExcessBonus(tokens, 1);\n', '            setCurrentRound(2);\n', '        }\n', '\n', '    // Round 2\n', '    } else if(processedTokens >= capLevels[1] && processedTokens < capLevels[2]) {\n', '        tokens = _getTokensAmount(amountPaid, 2);\n', '        bonusTokens = _getBonusAmount(tokens, 2);\n', '        fullTokens = tokens.add(bonusTokens);\n', '\n', '        // If the amount of tokens that you want to buy gets out of round 2\n', '        if(processedTokens.add(fullTokens) > capLevels[2]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 2);\n', '            bonusTokens = _calculateExcessBonus(tokens, 2);\n', '            setCurrentRound(3);\n', '        }\n', '\n', '    // Round 3\n', '    } else if(processedTokens >= capLevels[2] && processedTokens < capLevels[3]) {\n', '         tokens = _getTokensAmount(amountPaid, 3);\n', '         bonusTokens = _getBonusAmount(tokens, 3);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 3\n', '         if(processedTokens.add(fullTokens) > capLevels[3]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 3);\n', '            bonusTokens = _calculateExcessBonus(tokens, 3);\n', '            setCurrentRound(4);\n', '         }\n', '\n', '    // Round 4\n', '    } else if(processedTokens >= capLevels[3] && processedTokens < capLevels[4]) {\n', '         tokens = _getTokensAmount(amountPaid, 4);\n', '         bonusTokens = _getBonusAmount(tokens, 4);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 4\n', '         if(processedTokens.add(fullTokens) > capLevels[4]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 4);\n', '            bonusTokens = _calculateExcessBonus(tokens, 4);\n', '            setCurrentRound(5);\n', '         }\n', '\n', '    // Round 5\n', '    } else if(processedTokens >= capLevels[4] && processedTokens < capLevels[5]) {\n', '         tokens = _getTokensAmount(amountPaid, 5);\n', '         bonusTokens = _getBonusAmount(tokens, 5);\n', '         fullTokens = tokens.add(bonusTokens);\n', '\n', '         // If the amount of tokens that you want to buy gets out of round 5\n', '         if(processedTokens.add(fullTokens) > capLevels[5]) {\n', '            tokens = _calculateExcessTokens(amountPaid, 5);\n', '            bonusTokens = 0;\n', '            setCurrentRound(6);\n', '         }\n', '\n', '    // Round 6\n', '    } else if(processedTokens >= capLevels[5]) {\n', '        tokens = _getTokensAmount(amountPaid, 6);\n', '    }\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(amountPaid);\n', '    fullTokens = tokens.add(bonusTokens);\n', '    soldTokens = soldTokens.add(fullTokens);\n', '    processedTokens = processedTokens.add(fullTokens);\n', '\n', '    // Keep a record of how many tokens everybody gets in case we need to do refunds\n', '    tokensBought[msg.sender] = tokensBought[msg.sender].add(tokens);\n', '\n', '    // Kepp a record of how many wei everybody contributed in case we need to do refunds\n', '    crowdsaleBalances[msg.sender] = crowdsaleBalances[msg.sender].add(amountPaid);\n', '\n', '    // Kepp a record of how many token everybody got as bonus to display in\n', '    bonusBalances[msg.sender] = bonusBalances[msg.sender].add(bonusTokens);\n', '\n', '   // Combine bought tokens with bonus tokens before sending to investor\n', '    uint256 totalTokens = tokens.add(bonusTokens);\n', '\n', '    // Distribute the token\n', '    _processPurchase(_beneficiary, totalTokens);\n', '    emit TokenPurchase(\n', '      msg.sender,\n', '      _beneficiary,\n', '      amountPaid,\n', '      totalTokens\n', '    );\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) view internal {\n', '\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '\n', '    bool withinPeriod = hasStarted() && hasNotEnded();\n', '    bool nonZeroPurchase = msg.value > 0;\n', '    bool withinTokenLimit = processedTokens < maxTokensRaised;\n', '    bool minimumPurchase = msg.value >= minPurchase;\n', '\n', '    require(withinPeriod);\n', '    require(nonZeroPurchase);\n', '    require(withinTokenLimit);\n', '    require(minimumPurchase);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    uint256 _tokensToPreAllocate = _tokenAmount.div(2);\n', '    uint256 _tokensToLock = _tokenAmount.sub(_tokensToPreAllocate);\n', '    \n', '    //record address for future distribution\n', '    allocatedAddresses.push(_beneficiary);    \n', '\n', '    //pre allocate 50% of purchase for delivery in 30 days\n', '    _preAllocateTokens(_beneficiary, _tokensToPreAllocate);\n', '    \n', '    //lock 50% of purchase for delivery after 4 months\n', '    _lockTokens(_beneficiary, _tokensToLock);\n', '    \n', '    //approve by default (dissaprove manually)\n', '    approved[_beneficiary] = true;\n', '  }\n', '\n', '  function _lockTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    lockedBalances[_beneficiary] = lockedBalances[_beneficiary].add(_tokenAmount);\n', '    lockedTokens = lockedTokens.add(_tokenAmount);\n', '  }\n', '\n', '  function _preAllocateTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    allocatedBalances[_beneficiary] = allocatedBalances[_beneficiary].add(_tokenAmount);\n', '    allocatedTokens = allocatedTokens.add(_tokenAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to bonus tokens.\n', '   * @param _tokenAmount Value in wei to be converted into tokens\n', '   * @return Number of bonus tokens that can be distributed with the specified bonus percent\n', '   */\n', '  function _getBonusAmount(uint256 _tokenAmount, uint256 _bonusIndex) internal view returns (uint256) {\n', '    uint256 bonusValue = _tokenAmount.mul(bonusLevels[_bonusIndex]);\n', '    return bonusValue.div(100);\n', '  }\n', '\n', '    function _calculateExcessBonus(uint256 _tokens, uint256 _level) internal view returns (uint256) {\n', '        uint256 thisLevelTokens = processedTokens.add(_tokens);\n', '        uint256 nextLevelTokens = thisLevelTokens.sub(capLevels[_level]);\n', '        uint256 totalBonus = _getBonusAmount(nextLevelTokens, _level.add(1));\n', '        return totalBonus;\n', '    }\n', '\n', '   function _calculateExcessTokens(\n', '      uint256 amount,\n', '      uint256 roundSelected\n', '   ) internal returns(uint256) {\n', '      require(amount > 0);\n', '      require(roundSelected >= 1 && roundSelected <= 6);\n', '\n', '      uint256 _rate = rateLevels[roundSelected];\n', '      uint256 _leftTokens = capLevels[roundSelected].sub(processedTokens);\n', '      uint256 weiThisRound = _leftTokens.div(_rate).mul(1E14);\n', '      uint256 weiNextRound = amount.sub(weiThisRound);\n', '      uint256 tokensNextRound = 0;\n', '\n', "      // If there's excessive wei for the last tier, refund those\n", '      uint256 nextRound = roundSelected.add(1);\n', '      if(roundSelected != 6) {\n', '        tokensNextRound = _getTokensAmount(weiNextRound, nextRound);\n', '      }\n', '      else {\n', '         msg.sender.transfer(weiNextRound);\n', '      }\n', '\n', '      uint256 totalTokens = _leftTokens.add(tokensNextRound);\n', '      return totalTokens;\n', '   }\n', '\n', '\n', '   function _getTokensAmount(uint256 weiPaid, uint256 roundSelected)\n', '        internal constant returns(uint256 calculatedTokens)\n', '   {\n', '      require(weiPaid > 0);\n', '      require(roundSelected >= 1 && roundSelected <= 6);\n', '      uint256 typeTokenWei = weiPaid.div(1E14);\n', '      calculatedTokens = typeTokenWei.mul(rateLevels[roundSelected]);\n', '\n', '   }\n', '\n', '  // -----------------------------------------\n', '  // External interface (withdraw)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Determines how ETH is being transfered to owners wallet.\n', '   */\n', '  function _withdrawAllFunds() onlyOwner external {\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function _withdrawWei(uint256 _amount) onlyOwner external {\n', '    wallet.transfer(_amount);\n', '  }\n', '\n', '   function _changeLockDate(uint256 _newDate) onlyOwner external {\n', '    require(_newDate <= endTime.add(36 weeks));\n', '    lockedTill = _newDate;\n', '  }\n', '\n', '   function _changeApproveDate(uint256 _newDate) onlyOwner external {\n', '    require(_newDate <= endTime.add(12 weeks));\n', '    approvedTill = _newDate;\n', '  }\n', '\n', '  function changeWallet(address _newWallet) onlyOwner external {\n', '    wallet = _newWallet;\n', '  }\n', '\n', '   /// @notice Public function to check if the crowdsale has ended or not\n', '   function hasNotEnded() public constant returns(bool) {\n', '      return now < endTime && processedTokens < maxTokensRaised;\n', '   }\n', '\n', '   /// @notice Public function to check if the crowdsale has started or not\n', '   function hasStarted() public constant returns(bool) {\n', '      return now > startTime;\n', '   }\n', '\n', '    function setCurrentRound(uint256 _roundIndex) internal {\n', '        currentRound = _roundIndex;\n', '        currentRoundStart = now;\n', '    }\n', '\n', '    //move to next round by overwriting soldTokens value, unsold tokens will be burned;\n', '   function goNextRound() onlyOwner external {\n', '       require(currentRound < 6);\n', '       uint256 notSold = getUnsold();\n', '       unSoldTokens = unSoldTokens.add(notSold);\n', '       processedTokens = capLevels[currentRound];\n', '       currentRound = currentRound.add(1);\n', '       currentRoundStart = now;\n', '   }\n', '\n', '    function getUnsold() internal view returns (uint256) {\n', '        uint256 unSold = capLevels[currentRound].sub(processedTokens);\n', '        return unSold;\n', '    }\n', '\n', '    function checkUnsold() onlyOwner external view returns (uint256) {\n', '        uint256 unSold = capLevels[currentRound].sub(processedTokens);\n', '        return unSold;\n', '    }\n', '\n', '    function round() public view returns(uint256) {\n', '        return currentRound;\n', '    }\n', '\n', '    function currentBonusLevel() public view returns(uint256) {\n', '        return bonusLevels[currentRound];\n', '    }\n', '\n', '    function currentRateLevel() public view returns(uint256) {\n', '        return rateLevels[currentRound];\n', '    }\n', '\n', '    function currentCapLevel() public view returns(uint256) {\n', '        return capLevels[currentRound];\n', '    }\n', '\n', '    function changeApproval(address _beneficiary, bool _newStatus) onlyOwner public {\n', '        approved[_beneficiary] = _newStatus;\n', '    }\n', '\n', '    function massApproval(bool _newStatus, uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            approved[allocatedAddresses[i]] = _newStatus;\n', '        }\n', '    }\n', '\n', '    function autoTransferApproved(uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            transferApprovedBalance(allocatedAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function autoTransferLocked(uint256 _start, uint256 _end) onlyOwner public {\n', '        require(_start >= 0);\n', '        require(_end > 0);\n', '        require(_end > _start);\n', '        for (uint256 i = _start; i < _end; i++) {\n', '            transferLockedBalance(allocatedAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function transferApprovedBalance(address _beneficiary) public {\n', '        require(_beneficiary != address(0));\n', '        require(now >= approvedTill);\n', '        require(allocatedTokens > 0);\n', '        require(approved[_beneficiary]);\n', '        require(allocatedBalances[_beneficiary] > 0);\n', '        \n', '        uint256 _approvedTokensToTransfer = allocatedBalances[_beneficiary];\n', '        token.transfer(_beneficiary, _approvedTokensToTransfer);\n', '        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_approvedTokensToTransfer);\n', '        allocatedTokens = allocatedTokens.sub(_approvedTokensToTransfer);\n', '        allocatedBalances[_beneficiary] = 0;\n', '        distributedTokens = distributedTokens.add(_approvedTokensToTransfer);\n', '    }\n', '\n', '    function transferLockedBalance(address _beneficiary) public {\n', '        require(_beneficiary != address(0));\n', '        require(now >= lockedTill);\n', '        require(lockedTokens > 0);\n', '        require(approved[_beneficiary]);\n', '        require(lockedBalances[_beneficiary] > 0);\n', '\n', '        uint256 _lockedTokensToTransfer = lockedBalances[_beneficiary];\n', '        token.transfer(_beneficiary, _lockedTokensToTransfer);\n', '        distributedBalances[_beneficiary] = distributedBalances[_beneficiary].add(_lockedTokensToTransfer);\n', '        lockedTokens = lockedTokens.sub(_lockedTokensToTransfer);\n', '        lockedBalances[_beneficiary] = 0;\n', '        distributedTokens = distributedTokens.add(_lockedTokensToTransfer);\n', '    }\n', '\n', '    function transferToken(uint256 _tokens) external onlyOwner returns (bool success) {\n', '        //bool withinPeriod = hasStarted() && hasNotEnded();\n', '        //require(!withinPeriod);\n', '        return token.transfer(owner, _tokens);\n', '    }\n', '\n', '    function tokenBalance() public view returns (uint256) {\n', '        return token.balanceOf(address(this));\n', '    }\n', '\n', '    //destory contract with unsold tokens\n', '    function burnUnsold() public onlyOwner {\n', '        require(now > lockedTill);\n', '        require(address(this).balance == 0);\n', '        require(lockedTokens == 0);\n', '        require(allocatedTokens == 0);\n', '        require(unSoldTokens > 0);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
