['pragma solidity ^0.4.19;\n', '\n', '/******************************************************************************\n', '\n', 'ILOT - An Interest-paying ERC20 token and Ethereum lottery.\n', '\n', 'Visit us at https://ILOT.io/\n', '\n', 'ERC20 Compatible Token\n', 'Decimal places: 18\n', 'Symbol: ILOT\n', '\n', '*******************************************************************************\n', '\n', 'Copyright (C) 2018 ILOT.io\n', '\n', 'This program is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'This program is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '-----\n', '\n', 'If you use this code on your own contracts, please credit the website https://ILOT.io/ - Thank you!\n', '\n', '-----\n', '\n', '////////////////\n', '/B/S/B/J/M/A/F/\n', '//////////////\n', '////PEACE////\n', '////////////\n', '\n', '*/\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint _value, address _token, bytes _extraData) public; }\n', '\n', 'contract ILOTContract {\n', '\n', '    string public name = "ILOT Interest-Paying Lottery Token";\n', '    string public symbol = "ILOT";\n', '    \n', '    /*\n', "        We've hardcoded our official website into the blockchain!\n", '        Please do not send ETH to scams/clones/copies. \n', '        The website indicated below is the only official ILOT website.\n', '    */\n', '    string public site_url = "https://ILOT.io/";\n', '\n', '    bytes32 private current_jackpot_hash = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF";\n', '    uint8 public decimals = 18;\n', '    uint public totalSupply = 0; // No pre-minted amount.\n', '    uint public interestRate = 15; // 1.5% fixed monthly interest = 15 / 1000\n', '    uint tokensPerEthereum = 147000; // 147k tokens per ETH\n', '    uint public jackpotDifficulty = 6;\n', '    address public owner;\n', '\n', '    function ILOTContract() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    mapping (address => uint) public depositTotal; // total ETH deposited per address\n', '    mapping (address => uint) public lastBlockInterestPaid;\n', '\n', '    /*\n', '        Declare ILOT events.\n', '    */\n', '    event Transfer(address indexed from, address indexed to, uint bhtc_value);\n', '    event Burn(address indexed from, uint bhtc_value);\n', '    event GameResult(address player, uint zeroes);\n', '    event BonusPaid(address to, uint bhtc_value);\n', '    event InterestPaid(address to, uint bhtc_value);\n', '    event Jackpot(address winner, uint eth_amount);\n', '\n', '    uint maintenanceDebt;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /*\n', "        Return an addresse's current unpaid interest amount in ILOT.\n", '    */\n', '    function getInterest(address _to) public view returns (uint interest) {\n', '\n', '        if (lastBlockInterestPaid[_to] > 0) {\n', '            interest = ((block.number - lastBlockInterestPaid[_to]) * balanceOf[_to] * interestRate) / (86400000);\n', '        } else {\n', '            interest = 0;\n', '        }\n', '\n', '        return interest;\n', '    }\n', '\n', '    /*\n', '        Allows users to check their current deposit bonus amount.\n', '        Formula: 1% bonus over lifetime ETH deposit history\n', '        depositTotal is denominated in ETH\n', '    */\n', '    function getBonus(address _to) public view returns (uint interest) {\n', '        return ((depositTotal[_to] * tokensPerEthereum) / 100);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        /*\n', '            Owed interest is paid before transfers/withdrawals.\n', '            Users may be able to withdraw/transfer more than they publicly see.\n', '            Use getInterest(ETHEREUM_ADDRESS) to check how much interests\n', '            will be paid before transfers or future deposits.\n', '        */\n', '        payInterest(_from);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function setUrl(string u) public onlyOwner {\n', '        site_url = u;\n', '    }\n', '\n', '    function getUrl() public view returns (string) {\n', '        return site_url;\n', '    }\n', '\n', '    /*\n', '        Difficulty adjustment.\n', '    */\n', '    function setDifficulty(uint z) public onlyOwner {\n', '        jackpotDifficulty = z;\n', '    }\n', '\n', '    /*\n', '        Get current difficulty.\n', '        Returns number of zeroes currently required.\n', '    */\n', '    function getDifficulty() public view returns (uint) {\n', '        return jackpotDifficulty;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public\n', '    returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint _value, bytes _extraData)\n', '    public\n', '    returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function chown(address to) public onlyOwner { owner = to; }\n', '\n', '    function burn(uint _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Updates totalSupply\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '        totalSupply -= _value;                              // Update totalSupply\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Pays interest on available funds.\n', '    */\n', '    function payInterest(address _to) private {\n', '\n', '        uint interest = getInterest(_to);\n', '\n', '        if (interest > 0) {\n', '            require( (balanceOf[_to] + interest) > balanceOf[_to]);\n', '            // pay interest\n', '            balanceOf[msg.sender] += interest;\n', '            totalSupply += interest;\n', '            Transfer(this, msg.sender, interest);\n', '            InterestPaid(_to, interest);\n', '        }\n', '\n', '        lastBlockInterestPaid[_to] = block.number;\n', '\n', '    }\n', '\n', '    /*\n', '        Pays a 1% bonus over lifetime deposits made to this address.\n', '        Does not carry over if you change Ethereum addresses.\n', '    */\n', '    function payBonus(address _to) private {\n', '        if (depositTotal[_to] > 0) {\n', '            uint bonus = getBonus(_to);\n', '            if (bonus > 0) {\n', '                require( (balanceOf[_to] + bonus) > balanceOf[_to]);\n', '                balanceOf[_to] +=  bonus;\n', '                totalSupply += bonus;\n', '                Transfer(this, _to, bonus);\n', '                BonusPaid(_to, bonus);\n', '            }\n', '        }\n', '    }\n', '\n', '    function hashDifficulty(bytes32 hash) public pure returns(uint) {\n', '        uint diff = 0;\n', '\n', '        for (uint i=0;i<32;i++) {\n', '            if (hash[i] == 0) {\n', '                diff++;\n', '            } else {\n', '                return diff;\n', '            }\n', '        }\n', '\n', '        return diff;\n', '    }\n', '\n', '    /*\n', '        Credit to user @eth from StackExchange at:\n', '        https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\n', '        License for addressToString(): CC BY-SA 3.0\n', '    */\n', '    function addressToString(address x) private pure returns (string) {\n', '        bytes memory b = new bytes(20);\n', '        for (uint i = 0; i < 20; i++)\n', '            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n', '        return string(b);\n', '    }\n', '\n', '    /*\n', '        Performs token exchange and runs the lottery routine.\n', '\n', '    */\n', '    function () public payable {\n', '\n', '        /*\n', '            Owner cannot play lottery.\n', '        */\n', '        if (msg.sender == owner) {\n', '            return;\n', '        }\n', '\n', '        if (msg.value > 0) {\n', '\n', '            /*\n', '                Maintenance fee 2%\n', '            */\n', '            uint mfee = (2 * msg.value) / 100;\n', '\n', '            /*\n', '                If the contract does not have sufficient balance to pay mfee,\n', '                it will add mfee to maintenanceDebt and will not transfer it\n', '                at this time. During a later transaction, if the fee is enough,\n', '                the previous debt is transferred and zeroed out.\n', '            */\n', '            if (address(this).balance >= mfee) {\n', '                if (address(this).balance >= (mfee + maintenanceDebt) ) {\n', "                    // there's enough to cover previous debt\n", '                    owner.transfer(mfee + maintenanceDebt);\n', '                    maintenanceDebt = 0;\n', '                } else {\n', '                    // enough to pay fee but not previous debts\n', '                    owner.transfer(mfee);\n', '                }\n', '\n', '            } else {\n', '                maintenanceDebt += mfee;\n', '            }\n', '\n', '            /*\n', '                Convert ETH to ILOT at tokensPerEthereum rate.\n', '            */\n', '            uint tokenAmount = tokensPerEthereum * msg.value;\n', '            if (tokenAmount > 0) {\n', '                require( (balanceOf[msg.sender] + tokenAmount) > balanceOf[msg.sender]);\n', '\n', '                /*\n', '                    Pay fidelity bonus.\n', '                */\n', '                payBonus(msg.sender);\n', '\n', '                /*\n', '                    Pay interests on previous balance.\n', '                */\n', '                payInterest(msg.sender);\n', '\n', '                /*\n', '                    Update balance.\n', '                */\n', '                balanceOf[msg.sender] += tokenAmount;\n', '                totalSupply += tokenAmount;\n', '                Transfer(this, msg.sender, tokenAmount);\n', '\n', '                /*\n', '                    Add total after paying bonus.\n', '                    This deposit will count towards the next deposit bonus.\n', '                */\n', '                depositTotal[msg.sender] += msg.value;\n', '\n', '                string memory ats = addressToString(msg.sender);\n', '\n', '                /*\n', '                    Perform lottery routine.\n', '                */\n', '                current_jackpot_hash = keccak256(current_jackpot_hash, ats, block.coinbase, block.number, block.timestamp);\n', '                uint diffx = hashDifficulty(current_jackpot_hash);\n', '\n', '                if (diffx >= jackpotDifficulty) {\n', '                    /*\n', '\n', '                        ********************\n', '                        ****  JACKPOT!  ****\n', '                        ********************\n', '\n', '                        Winner receives the entire contract balance.\n', '                        Jackpot event makes the result public.\n', '\n', '                    */\n', '                    Jackpot(msg.sender, address(this).balance);\n', '                    msg.sender.transfer(address(this).balance);\n', '                }\n', '\n', '                /*\n', '                    Make the game result public for transparency.\n', '                */\n', '                GameResult(msg.sender, diffx);\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '}']