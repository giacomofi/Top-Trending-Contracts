['pragma solidity ^0.4.23;\n', '/*\n', '\n', 'LIGO CrowdSale - Wave 1\n', '\n', '*/\n', '\n', '// interface to represent the LIGO token contract, so we can call functions on it\n', 'interface ligoToken {\n', '    function transfer(address receiver, uint amount) external;\n', '    function balanceOf(address holder) external returns(uint); \n', '}\n', '\n', 'contract Crowdsale {\n', '\t// Public visible variables\n', '    address public beneficiary;\n', '    uint public fundingGoal;\n', '    uint public startTime;\n', '    uint public deadline;\n', '    ligoToken public tokenReward;\n', '    uint public amountRaised;\n', '    uint public buyerCount = 0;\n', '    bool public fundingGoalReached = false;\n', '\tuint public withdrawlDeadline;\n', '    // bool public hasStarted = false; // not needed, automatically start wave 1 when deployed\n', '\t// public array of buyers\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => uint256) public fundedAmount;\n', '    mapping(uint => address) public buyers;\n', '\t// private variables\n', '    bool crowdsaleClosed = false;\n', '\t// crowdsale settings\n', '\tuint constant minContribution  = 20000000000000000; // 0.02 ETH\n', '\tuint constant maxContribution = 100 ether; \n', '\tuint constant fundsOnHoldAfterDeadline = 30 days; //Escrow period\n', '\n', '    event GoalReached(address recipient, uint totalAmountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor(\n', '        address ifSuccessfulSendTo,\n', '        uint fundingGoalInEthers,\n', '        uint startUnixTime,\n', '        uint durationInMinutes,\n', '        address addressOfTokenUsedAsReward\n', '    ) public {\n', '        beneficiary = ifSuccessfulSendTo;\n', '        fundingGoal = fundingGoalInEthers * 1 ether;\n', '        startTime = startUnixTime;\n', '        deadline = startTime + durationInMinutes * 1 minutes;\n', '\t\twithdrawlDeadline = deadline + fundsOnHoldAfterDeadline;\n', '        tokenReward = ligoToken(addressOfTokenUsedAsReward);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () public payable {\n', '        require(!crowdsaleClosed);\n', '        require(!(now <= startTime));\n', '\t\trequire(!(amountRaised >= fundingGoal)); // stop accepting payments when the goal is reached.\n', '\n', '\t\t// get the total for this contributor so far\n', '        uint totalContribution = balanceOf[msg.sender];\n', '\t\t// if total > 0, this user already contributed\n', '\t\tbool exstingContributor = totalContribution > 0;\n', '\n', '        uint amount = msg.value;\n', '        bool moreThanMinAmount = amount >= minContribution; //> 0.02 Ether\n', '        bool lessThanMaxTotalContribution = amount + totalContribution <= maxContribution; // < 100 Ether total, including this amount\n', '\n', '        require(moreThanMinAmount);\n', '        require(lessThanMaxTotalContribution);\n', '\n', '        if (lessThanMaxTotalContribution && moreThanMinAmount) {\n', '            // Add to buyer&#39;s balance\n', '            balanceOf[msg.sender] += amount;\n', '            // Add to tracking array\n', '            fundedAmount[msg.sender] += amount;\n', '            emit FundTransfer(msg.sender, amount, true);\n', '\t\t\tif (!exstingContributor) {\n', '\t\t\t\t// this is a new contributor, add to the count and the buyers array\n', '\t\t\t\tbuyers[buyerCount] = msg.sender;\n', '\t\t\t\tbuyerCount += 1;\n', '\t\t\t}\n', '            amountRaised += amount;\n', '\t\t}\n', '    }\n', '\n', '    modifier afterDeadline() { if (now >= deadline) _; }\n', '    modifier afterWithdrawalDeadline() { if (now >= withdrawlDeadline) _; }\n', '\n', '    /**\n', '     * Check if goal was reached\n', '     *\n', '     * Checks if the goal or time limit has been reached and ends the campaign\n', '     */\n', '    function checkGoalReached() public afterDeadline {\n', '\t\tif (beneficiary == msg.sender) {\n', '\t\t\tif (amountRaised >= fundingGoal){\n', '\t\t\t\tfundingGoalReached = true;\n', '\t\t\t\temit GoalReached(beneficiary, amountRaised);\n', '\t\t\t}\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\n', '    }\n', '\n', '    /**\n', '     * returns contract&#39;s LIGO balance\n', '     */\n', '    function getContractTokenBalance() public constant returns (uint) {\n', '        return tokenReward.balanceOf(address(this));\n', '    }\n', '    \n', '    /**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if time limit has been reached, and if so, \n', '     * sends the entire amount to the beneficiary, and send LIGO to buyers. \n', '     */\n', '    function safeWithdrawal() public afterWithdrawalDeadline {\n', '\t\t\n', '\t\t// Only the beneficiery can withdraw from Wave 1\n', '\t\tif (beneficiary == msg.sender) {\n', '\n', '\t\t\t// first send all the ETH to beneficiary\n', '            if (beneficiary.send(amountRaised)) {\n', '                emit FundTransfer(beneficiary, amountRaised, false);\n', '            }\n', '\n', '\t\t\t// Read amount of total LIGO in this contract\n', '\t\t\tuint totalTokens = tokenReward.balanceOf(address(this));\n', '\t\t\tuint remainingTokens = totalTokens;\n', '\n', '\t\t\t// send the LIGO to each buyer\n', '\t\t\tfor (uint i=0; i<buyerCount; i++) {\n', '\t\t\t\taddress buyerId = buyers[i];\n', '\t\t\t\tuint amount = ((balanceOf[buyerId] * 500) * 125) / 100; //Modifier is 100->125% so divide by 100.\n', '\t\t\t\t// Make sure there are enough remaining tokens in the contract before trying to send\n', '\t\t\t\tif (remainingTokens >= amount) {\n', '\t\t\t\t\ttokenReward.transfer(buyerId, amount); \n', '\t\t\t\t\t// subtract from the total\n', '\t\t\t\t\tremainingTokens -= amount;\n', '\t\t\t\t\t// clear out buyer&#39;s balance\n', '\t\t\t\t\tbalanceOf[buyerId] = 0;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\n', '\t\t\t// send unsold tokens back to contract init wallet\n', '\t\t\tif (remainingTokens > 0) {\n', '\t\t\t\ttokenReward.transfer(beneficiary, remainingTokens);\n', '\t\t\t}\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '/*\n', '\n', 'LIGO CrowdSale - Wave 1\n', '\n', '*/\n', '\n', '// interface to represent the LIGO token contract, so we can call functions on it\n', 'interface ligoToken {\n', '    function transfer(address receiver, uint amount) external;\n', '    function balanceOf(address holder) external returns(uint); \n', '}\n', '\n', 'contract Crowdsale {\n', '\t// Public visible variables\n', '    address public beneficiary;\n', '    uint public fundingGoal;\n', '    uint public startTime;\n', '    uint public deadline;\n', '    ligoToken public tokenReward;\n', '    uint public amountRaised;\n', '    uint public buyerCount = 0;\n', '    bool public fundingGoalReached = false;\n', '\tuint public withdrawlDeadline;\n', '    // bool public hasStarted = false; // not needed, automatically start wave 1 when deployed\n', '\t// public array of buyers\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => uint256) public fundedAmount;\n', '    mapping(uint => address) public buyers;\n', '\t// private variables\n', '    bool crowdsaleClosed = false;\n', '\t// crowdsale settings\n', '\tuint constant minContribution  = 20000000000000000; // 0.02 ETH\n', '\tuint constant maxContribution = 100 ether; \n', '\tuint constant fundsOnHoldAfterDeadline = 30 days; //Escrow period\n', '\n', '    event GoalReached(address recipient, uint totalAmountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    constructor(\n', '        address ifSuccessfulSendTo,\n', '        uint fundingGoalInEthers,\n', '        uint startUnixTime,\n', '        uint durationInMinutes,\n', '        address addressOfTokenUsedAsReward\n', '    ) public {\n', '        beneficiary = ifSuccessfulSendTo;\n', '        fundingGoal = fundingGoalInEthers * 1 ether;\n', '        startTime = startUnixTime;\n', '        deadline = startTime + durationInMinutes * 1 minutes;\n', '\t\twithdrawlDeadline = deadline + fundsOnHoldAfterDeadline;\n', '        tokenReward = ligoToken(addressOfTokenUsedAsReward);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () public payable {\n', '        require(!crowdsaleClosed);\n', '        require(!(now <= startTime));\n', '\t\trequire(!(amountRaised >= fundingGoal)); // stop accepting payments when the goal is reached.\n', '\n', '\t\t// get the total for this contributor so far\n', '        uint totalContribution = balanceOf[msg.sender];\n', '\t\t// if total > 0, this user already contributed\n', '\t\tbool exstingContributor = totalContribution > 0;\n', '\n', '        uint amount = msg.value;\n', '        bool moreThanMinAmount = amount >= minContribution; //> 0.02 Ether\n', '        bool lessThanMaxTotalContribution = amount + totalContribution <= maxContribution; // < 100 Ether total, including this amount\n', '\n', '        require(moreThanMinAmount);\n', '        require(lessThanMaxTotalContribution);\n', '\n', '        if (lessThanMaxTotalContribution && moreThanMinAmount) {\n', "            // Add to buyer's balance\n", '            balanceOf[msg.sender] += amount;\n', '            // Add to tracking array\n', '            fundedAmount[msg.sender] += amount;\n', '            emit FundTransfer(msg.sender, amount, true);\n', '\t\t\tif (!exstingContributor) {\n', '\t\t\t\t// this is a new contributor, add to the count and the buyers array\n', '\t\t\t\tbuyers[buyerCount] = msg.sender;\n', '\t\t\t\tbuyerCount += 1;\n', '\t\t\t}\n', '            amountRaised += amount;\n', '\t\t}\n', '    }\n', '\n', '    modifier afterDeadline() { if (now >= deadline) _; }\n', '    modifier afterWithdrawalDeadline() { if (now >= withdrawlDeadline) _; }\n', '\n', '    /**\n', '     * Check if goal was reached\n', '     *\n', '     * Checks if the goal or time limit has been reached and ends the campaign\n', '     */\n', '    function checkGoalReached() public afterDeadline {\n', '\t\tif (beneficiary == msg.sender) {\n', '\t\t\tif (amountRaised >= fundingGoal){\n', '\t\t\t\tfundingGoalReached = true;\n', '\t\t\t\temit GoalReached(beneficiary, amountRaised);\n', '\t\t\t}\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\n', '    }\n', '\n', '    /**\n', "     * returns contract's LIGO balance\n", '     */\n', '    function getContractTokenBalance() public constant returns (uint) {\n', '        return tokenReward.balanceOf(address(this));\n', '    }\n', '    \n', '    /**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if time limit has been reached, and if so, \n', '     * sends the entire amount to the beneficiary, and send LIGO to buyers. \n', '     */\n', '    function safeWithdrawal() public afterWithdrawalDeadline {\n', '\t\t\n', '\t\t// Only the beneficiery can withdraw from Wave 1\n', '\t\tif (beneficiary == msg.sender) {\n', '\n', '\t\t\t// first send all the ETH to beneficiary\n', '            if (beneficiary.send(amountRaised)) {\n', '                emit FundTransfer(beneficiary, amountRaised, false);\n', '            }\n', '\n', '\t\t\t// Read amount of total LIGO in this contract\n', '\t\t\tuint totalTokens = tokenReward.balanceOf(address(this));\n', '\t\t\tuint remainingTokens = totalTokens;\n', '\n', '\t\t\t// send the LIGO to each buyer\n', '\t\t\tfor (uint i=0; i<buyerCount; i++) {\n', '\t\t\t\taddress buyerId = buyers[i];\n', '\t\t\t\tuint amount = ((balanceOf[buyerId] * 500) * 125) / 100; //Modifier is 100->125% so divide by 100.\n', '\t\t\t\t// Make sure there are enough remaining tokens in the contract before trying to send\n', '\t\t\t\tif (remainingTokens >= amount) {\n', '\t\t\t\t\ttokenReward.transfer(buyerId, amount); \n', '\t\t\t\t\t// subtract from the total\n', '\t\t\t\t\tremainingTokens -= amount;\n', "\t\t\t\t\t// clear out buyer's balance\n", '\t\t\t\t\tbalanceOf[buyerId] = 0;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\n', '\t\t\t// send unsold tokens back to contract init wallet\n', '\t\t\tif (remainingTokens > 0) {\n', '\t\t\t\ttokenReward.transfer(beneficiary, remainingTokens);\n', '\t\t\t}\n', '        }\n', '    }\n', '}']
