['pragma solidity ^0.4.17;\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    \n', '    constructor() public {\n', '    }\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public pure returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address _prevOwner, address _newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'contract IToken {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public pure returns (string) {}\n', '    function symbol() public pure returns (string) {}\n', '    function decimals() public pure returns (uint8) {}\n', '    function totalSupply() public pure returns (uint256) {}\n', '    function balanceOf(address _owner) public pure returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public pure returns (uint256) { _owner; _spender; }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal;\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '}\n', '\n', '\n', 'contract Token is IToken, Owned, Utils {\n', '    \n', "    string public standard = '';\n", "    string public name = '';\n", "    string public symbol = '';\n", '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    constructor() public \n', '    {\n', "        name = 'MKC';\n", "        symbol = 'MKC';\n", '        decimals = 8;\n', '        totalSupply = 1000000000 * 10 ** uint256(decimals);\n', '\n', '        balanceOf[owner] = totalSupply;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value)\n', '      internal\n', '      validAddress(_from)\n', '      validAddress(_to)\n', '    {\n', '\n', '      require(balanceOf[_from] >= _value);\n', '      require(balanceOf[_to] + _value > balanceOf[_to]);\n', '      uint previousBalances = safeAdd(balanceOf[_from], balanceOf[_to]);\n', '      balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '      balanceOf[_to] += safeAdd(balanceOf[_to], _value);\n', '\n', '      emit Transfer(_from, _to, _value);\n', '\n', '      assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '      public\n', '      validAddress(_to)\n', '      returns (bool)\n', '    {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool)\n', '    {\n', '        require(_value <= allowance[_from][msg.sender]);   // Check allowance\n', '\n', '        allowance[_from][msg.sender] -= safeSub(allowance[_from][msg.sender], _value);\n', '\n', '        _transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', '\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IMKC {\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal;\n', '    function freezeAccount(address target, bool freeze) public;\n', '}\n', '\n', '\n', 'contract SmartToken is Owned, Token {\n', '\n', "    string public version = '1.0';\n", '\n', '    event NewSmartToken(address _token);\n', '\n', '    constructor()\n', '        public\n', '        Token ()\n', '    {\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract MKC is IMKC, Token {\n', '\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    event FrozenFunds(address target, bool frozen);\n', '\n', '    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '\n', '\n', '    constructor()\n', '      public\n', '      Token ()\n', '    {\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint _value)\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        internal\n', '    {\n', '        require (balanceOf[_from] > _value);\n', '        require (balanceOf[_to] + _value > balanceOf[_to]);\n', '        require(!frozenAccount[_from]);\n', '        require(!frozenAccount[_to]);\n', '\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '    }\n', '\n', '    function freezeAccount(address target, bool freeze)\n', '        validAddress(target)\n', '        public\n', '        onlyOwner\n', '    {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '}']