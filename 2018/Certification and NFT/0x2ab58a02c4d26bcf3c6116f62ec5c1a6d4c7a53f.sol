['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/TweedentityRegistry.sol\n', '\n', 'contract Pausable {\n', '\n', '  bool public paused;\n', '}\n', '\n', '\n', '/**\n', ' * @title TweedentityRegistry\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev It store the tweedentities contracts addresses to allows dapp to be updated\n', ' */\n', '\n', '\n', 'contract TweedentityRegistry\n', 'is HasNoEther\n', '{\n', '\n', '  string public version = "1.4.0";\n', '\n', '  uint public totalStores;\n', '  mapping (bytes32 => address) private stores;\n', '\n', '  address public manager;\n', '  address public claimer;\n', '\n', '  event ContractRegistered(\n', '    bytes32 indexed key,\n', '    string spec,\n', '    address addr\n', '  );\n', '\n', '\n', '  function setManager(\n', '    address _manager\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    manager = _manager;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '  }\n', '\n', '\n', '  function setClaimer(\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_claimer != address(0));\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setManagerAndClaimer(\n', '    address _manager,\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    require(_claimer != address(0));\n', '    manager = _manager;\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setAStore(\n', '    string _appNickname,\n', '    address _store\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_store != address(0));\n', '    if (getStore(_appNickname) == address(0)) {\n', '      totalStores++;\n', '    }\n', '    stores[keccak256(_appNickname)] = _store;\n', '    ContractRegistered(keccak256("store"), _appNickname, _store);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Gets the store managing the specified app\n', '   * @param _appNickname The nickname of the app\n', '   */\n', '  function getStore(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns(address)\n', '  {\n', '    return stores[keccak256(_appNickname)];\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns true if the registry looks ready\n', '   */\n', '  function isReady()\n', '  external\n', '  constant returns(bool)\n', '  {\n', '    Pausable pausable = Pausable(manager);\n', '    return totalStores > 0 && manager != address(0) && claimer != address(0) && pausable.paused() == false;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/TweedentityRegistry.sol\n', '\n', 'contract Pausable {\n', '\n', '  bool public paused;\n', '}\n', '\n', '\n', '/**\n', ' * @title TweedentityRegistry\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev It store the tweedentities contracts addresses to allows dapp to be updated\n', ' */\n', '\n', '\n', 'contract TweedentityRegistry\n', 'is HasNoEther\n', '{\n', '\n', '  string public version = "1.4.0";\n', '\n', '  uint public totalStores;\n', '  mapping (bytes32 => address) private stores;\n', '\n', '  address public manager;\n', '  address public claimer;\n', '\n', '  event ContractRegistered(\n', '    bytes32 indexed key,\n', '    string spec,\n', '    address addr\n', '  );\n', '\n', '\n', '  function setManager(\n', '    address _manager\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    manager = _manager;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '  }\n', '\n', '\n', '  function setClaimer(\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_claimer != address(0));\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setManagerAndClaimer(\n', '    address _manager,\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    require(_claimer != address(0));\n', '    manager = _manager;\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setAStore(\n', '    string _appNickname,\n', '    address _store\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(_store != address(0));\n', '    if (getStore(_appNickname) == address(0)) {\n', '      totalStores++;\n', '    }\n', '    stores[keccak256(_appNickname)] = _store;\n', '    ContractRegistered(keccak256("store"), _appNickname, _store);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Gets the store managing the specified app\n', '   * @param _appNickname The nickname of the app\n', '   */\n', '  function getStore(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns(address)\n', '  {\n', '    return stores[keccak256(_appNickname)];\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns true if the registry looks ready\n', '   */\n', '  function isReady()\n', '  external\n', '  constant returns(bool)\n', '  {\n', '    Pausable pausable = Pausable(manager);\n', '    return totalStores > 0 && manager != address(0) && claimer != address(0) && pausable.paused() == false;\n', '  }\n', '\n', '}']
