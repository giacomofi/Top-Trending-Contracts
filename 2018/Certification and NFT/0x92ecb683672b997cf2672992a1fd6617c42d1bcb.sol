['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    /**\n', '    * Multiplies method\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    /**\n', '    * Division method.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * Subtracts method.\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * Add method.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', 'contract ERC223Interface {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) public constant returns (uint) ;\n', '    function transfer(address to, uint value) public;\n', '    function transfer(address to, uint value, bytes data) public;\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', 'contract ERC223ReceivingContract { \n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', 'contract KaraOmToken is ERC223Interface {\n', '    using SafeMath for uint;\n', '    address owner = msg.sender;\n', '    mapping(address => uint) balances; // List of user balances.\n', '\n', '    string public constant name = "KaraOm Token";\n', '    string public constant symbol = "KOM";\n', '    uint public constant decimals = 8;\n', '    uint256 public totalSupply = 690000000e8;\n', '    uint256 public tokensPerEth = 15000000e8;\n', '    uint256 public bonusPercent = 20;\n', '    uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; // 0.01 Ether\n', '    uint256 public constant MIN_BONUS = 1 ether / 10; // 0.1 Ether\n', '    uint256 public totalDistributed = 0 ;\n', '    bool public distributionFinished = false;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Distr(address indexed to, uint256 amount);\n', '    event Burn(address indexed burner, uint256 value);\n', '    event TokensPerEthUpdated(uint _tokensPerEth);\n', '    event BonusPercent(uint _bonusPercent);\n', '    event TransferOwnership(address _newOwner);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier canDistr() {\n', '        require(!distributionFinished);\n', '        _;\n', '    }\n', '    function KaraOmToken() public {  \n', '            distr(0x373D48aF72C3d3Ef19182369Cd52EcBffBeA220D, (totalSupply.div(100)).mul(5));\n', '            distr(0x6Ac58E07CF9432c8e34E7d11a720b9AC7C8d1e48, 138000000e8);\n', '            distr(0xC6691e2608c069e6FB10a4194bcc40555d82B9ef, (totalSupply.div(100)).mul(10));\n', '    }\n', '    \n', '    function () external payable {\n', '        getTokens();\n', '     }\n', '    function getTokens() payable canDistr public {\n', '        uint256 tokens = 0;\n', '        address investor = msg.sender; \n', '        if(msg.value >= MIN_CONTRIBUTION){\n', '            tokens = tokensPerEth.mul(msg.value) / 1 ether;    \n', '            if(msg.value >= MIN_BONUS){\n', '                tokens.add((tokens.div(100)).mul(bonusPercent));\n', '            }    \n', '        }\n', '        if (tokens > 0) {\n', '            distr(investor, tokens);\n', '        }\n', '        if (totalDistributed >= totalSupply) {\n', '            distributionFinished = true;\n', '        }\n', '        \n', '    }\n', '    function distr(address _to, uint256 _amount)  private returns (bool) {  \n', '        totalDistributed = totalDistributed.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Distr(_to, _amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '\n', '        return true;\n', '    }\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        if (_newOwner != address(0)) {\n', '            owner = _newOwner;\n', '        }\n', '        emit TransferOwnership(_newOwner);\n', '    }\n', '    function transfer(address _to, uint _value, bytes _data) public{\n', '        uint codeLength;\n', '\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value, _data);\n', '        }\n', '         emit Transfer(msg.sender, _to, _value);\n', '    }\n', '  \n', '    function transfer(address _to, uint _value) public{\n', '        uint codeLength;\n', '        bytes memory empty;\n', '        assembly {\n', '            codeLength := extcodesize(_to)\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        if(codeLength>0) {\n', '            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '            receiver.tokenFallback(msg.sender, _value,empty);\n', '        }\n', '        emit Transfer(msg.sender, _to, _value);\n', '    }\n', '    function updateTokensPerEth(uint _tokensPerEth) onlyOwner public {        \n', '        tokensPerEth = _tokensPerEth;\n', '        emit TokensPerEthUpdated(_tokensPerEth);\n', '    }\n', '    function updateBonusPercent(uint _bonusPercent) onlyOwner public {        \n', '        bonusPercent = _bonusPercent;\n', '        emit BonusPercent(_bonusPercent);\n', '    }\n', '    function burn(uint256 _value) onlyOwner public {\n', '        require(_value <= balances[msg.sender]);\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Burn(burner, _value);\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        address myAddress = this;\n', '        uint256 etherBalance = myAddress.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}']