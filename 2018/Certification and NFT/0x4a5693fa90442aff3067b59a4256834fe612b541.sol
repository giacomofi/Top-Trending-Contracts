['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', ' * ownership control to OpenZeppelin&#39;s Ownable class. In this model, the original owner \n', ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  address public pendingOwner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    pendingOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '\n', '}\n', '\n', '/**\n', '* @title CarbonDollarStorage\n', '* @notice Contains necessary storage contracts for CarbonDollar (FeeSheet and StablecoinWhitelist).\n', '*/\n', 'contract CarbonDollarStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /** \n', '        Mappings\n', '    */\n', '    /* fees for withdrawing to stablecoin, in tenths of a percent) */\n', '    mapping (address => uint256) public fees;\n', '    /** @dev Units for fees are always in a tenth of a percent */\n', '    uint256 public defaultFee;\n', '    /* is the token address referring to a stablecoin/whitelisted token? */\n', '    mapping (address => bool) public whitelist;\n', '\n', '\n', '    /** \n', '        Events\n', '    */\n', '    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);\n', '    event FeeChanged(address indexed stablecoin, uint256 oldFee, uint256 newFee);\n', '    event FeeRemoved(address indexed stablecoin, uint256 oldFee);\n', '    event StablecoinAdded(address indexed stablecoin);\n', '    event StablecoinRemoved(address indexed stablecoin);\n', '\n', '    /** @notice Sets the default fee for burning CarbonDollar into a whitelisted stablecoin.\n', '        @param _fee The default fee.\n', '    */\n', '    function setDefaultFee(uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = defaultFee;\n', '        defaultFee = _fee;\n', '        if (oldFee != defaultFee)\n', '            emit DefaultFeeChanged(oldFee, _fee);\n', '    }\n', '    \n', '    /** @notice Set a fee for burning CarbonDollar into a stablecoin.\n', '        @param _stablecoin Address of a whitelisted stablecoin.\n', '        @param _fee the fee.\n', '    */\n', '    function setFee(address _stablecoin, uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = _fee;\n', '        if (oldFee != _fee)\n', '            emit FeeChanged(_stablecoin, oldFee, _fee);\n', '    }\n', '\n', '    /** @notice Remove the fee for burning CarbonDollar into a particular kind of stablecoin.\n', '        @param _stablecoin Address of stablecoin.\n', '    */\n', '    function removeFee(address _stablecoin) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = 0;\n', '        if (oldFee != 0)\n', '            emit FeeRemoved(_stablecoin, oldFee);\n', '    }\n', '\n', '    /** @notice Add a token to the whitelist.\n', '        @param _stablecoin Address of the new stablecoin.\n', '    */\n', '    function addStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = true;\n', '        emit StablecoinAdded(_stablecoin);\n', '    }\n', '\n', '    /** @notice Removes a token from the whitelist.\n', '        @param _stablecoin Address of the ex-stablecoin.\n', '    */\n', '    function removeStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = false;\n', '        emit StablecoinRemoved(_stablecoin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _stablecoin The stablecoin whose fee will be used.\n', '     */\n', '    function computeStablecoinFee(uint256 _amount, address _stablecoin) public view returns (uint256) {\n', '        uint256 fee = fees[_stablecoin];\n', '        return computeFee(_amount, fee);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _fee The fee that will be charged, in tenths of a percent.\n', '     */\n', '    function computeFee(uint256 _amount, uint256 _fee) public pure returns (uint256) {\n', '        return _amount.mul(_fee).div(1000);\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', '// library AddressUtils {\n', '\n', '//   /**\n', '//    * Returns whether the target address is a contract\n', '//    * @dev This function will return false if invoked during the constructor of a contract,\n', '//    * as the code is not actually created until after the constructor finishes.\n', '//    * @param addr address to check\n', '//    * @return whether the target address is a contract\n', '//    */\n', '//   function isContract(address addr) internal view returns (bool) {\n', '//     uint256 size;\n', '//     // XXX Currently there is no better way to check if there is a contract in an address\n', '//     // than to check the size of the code at that address.\n', '//     // See https://ethereum.stackexchange.com/a/14016/36603\n', '//     // for more details about how this works.\n', '//     // TODO Check this again before the Serenity release, because all addresses will be\n', '//     // contracts then.\n', '//     // solium-disable-next-line security/no-inline-assembly\n', '//     assembly { size := extcodesize(addr) }\n', '//     return size > 0;\n', '//   }\n', '\n', '// }\n', '\n', '/**\n', '* @title PermissionedTokenStorage\n', '* @notice a PermissionedTokenStorage is constructed by setting Regulator, BalanceSheet, and AllowanceSheet locations.\n', '* Once the storages are set, they cannot be changed.\n', '*/\n', 'contract PermissionedTokenStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '        Storage\n', '    */\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '    mapping (address => uint256) public balances;\n', '    uint256 public totalSupply;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = _value;\n', '    }\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  function () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', '   * This is a low level function that doesn&#39;t return to its internal call site.\n', '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize)\n', '\n', '      // Call the implementation.\n', '      // out and outsize are 0 because we don&#39;t know the size yet.\n', '      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize)\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize) }\n', '      default { return(0, returndatasize) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() internal {\n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _implementation Address of the initial implementation.\n', '   */\n', '  constructor(address _implementation) public {\n', '    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));\n', '\n', '    _setImplementation(_implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) private {\n', '    require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', '*\n', '* @dev Stores permissions and validators and provides setter and getter methods. \n', '* Permissions determine which methods users have access to call. Validators\n', '* are able to mutate permissions at the Regulator level.\n', '*\n', '*/\n', 'contract RegulatorStorage is Ownable {\n', '    \n', '    /** \n', '        Structs \n', '    */\n', '\n', '    /* Contains metadata about a permission to execute a particular method signature. */\n', '    struct Permission {\n', '        string name; // A one-word description for the permission. e.g. "canMint"\n', '        string description; // A longer description for the permission. e.g. "Allows user to mint tokens."\n', '        string contract_name; // e.g. "PermissionedToken"\n', '        bool active; // Permissions can be turned on or off by regulator\n', '    }\n', '\n', '    /** \n', '        Constants: stores method signatures. These are potential permissions that a user can have, \n', '        and each permission gives the user the ability to call the associated PermissionedToken method signature\n', '    */\n', '    bytes4 public constant MINT_SIG = bytes4(keccak256("mint(address,uint256)"));\n', '    bytes4 public constant MINT_CUSD_SIG = bytes4(keccak256("mintCUSD(address,uint256)"));\n', '    bytes4 public constant CONVERT_WT_SIG = bytes4(keccak256("convertWT(uint256)"));\n', '    bytes4 public constant BURN_SIG = bytes4(keccak256("burn(uint256)"));\n', '    bytes4 public constant CONVERT_CARBON_DOLLAR_SIG = bytes4(keccak256("convertCarbonDollar(address,uint256)"));\n', '    bytes4 public constant BURN_CARBON_DOLLAR_SIG = bytes4(keccak256("burnCarbonDollar(address,uint256)"));\n', '    bytes4 public constant DESTROY_BLACKLISTED_TOKENS_SIG = bytes4(keccak256("destroyBlacklistedTokens(address,uint256)"));\n', '    bytes4 public constant APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG = bytes4(keccak256("approveBlacklistedAddressSpender(address)"));\n', '    bytes4 public constant BLACKLISTED_SIG = bytes4(keccak256("blacklisted()"));\n', '\n', '    /** \n', '        Mappings \n', '    */\n', '\n', '    /* each method signature maps to a Permission */\n', '    mapping (bytes4 => Permission) public permissions;\n', '    /* list of validators, either active or inactive */\n', '    mapping (address => bool) public validators;\n', '    /* each user can be given access to a given method signature */\n', '    mapping (address => mapping (bytes4 => bool)) public userPermissions;\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event PermissionAdded(bytes4 methodsignature);\n', '    event PermissionRemoved(bytes4 methodsignature);\n', '    event ValidatorAdded(address indexed validator);\n', '    event ValidatorRemoved(address indexed validator);\n', '\n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets a permission within the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    * @param _permissionName A "slug" name for this permission (e.g. "canMint").\n', '    * @param _permissionDescription A lengthier description for this permission (e.g. "Allows user to mint tokens").\n', '    * @param _contractName Name of the contract that the method belongs to.\n', '    */\n', '    function addPermission(\n', '        bytes4 _methodsignature, \n', '        string _permissionName, \n', '        string _permissionDescription, \n', '        string _contractName) public onlyValidator { \n', '        Permission memory p = Permission(_permissionName, _permissionDescription, _contractName, true);\n', '        permissions[_methodsignature] = p;\n', '        emit PermissionAdded(_methodsignature);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removePermission(bytes4 _methodsignature) public onlyValidator {\n', '        permissions[_methodsignature].active = false;\n', '        emit PermissionRemoved(_methodsignature);\n', '    }\n', '    \n', '    /**\n', '    * @notice Sets a permission in the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function setUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being set must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission from the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removeUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being removed must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = false;\n', '    }\n', '\n', '    /**\n', '    * @notice add a Validator\n', '    * @param _validator Address of validator to add\n', '    */\n', '    function addValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = true;\n', '        emit ValidatorAdded(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice remove a Validator\n', '    * @param _validator Address of validator to remove\n', '    */\n', '    function removeValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = false;\n', '        emit ValidatorRemoved(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice does validator exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isValidator(address _validator) public view returns (bool) {\n', '        return validators[_validator];\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isPermission(bytes4 _methodsignature) public view returns (bool) {\n', '        return permissions[_methodsignature].active;\n', '    }\n', '\n', '    /**\n', '    * @notice get Permission structure\n', '    * @param _methodsignature request to retrieve the Permission struct for this methodsignature\n', '    * @return Permission\n', '    **/\n', '    function getPermission(bytes4 _methodsignature) public view returns \n', '        (string name, \n', '         string description, \n', '         string contract_name,\n', '         bool active) {\n', '        return (permissions[_methodsignature].name,\n', '                permissions[_methodsignature].description,\n', '                permissions[_methodsignature].contract_name,\n', '                permissions[_methodsignature].active);\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function hasUserPermission(address _who, bytes4 _methodsignature) public view returns (bool) {\n', '        return userPermissions[_who][_methodsignature];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Regulator\n', ' * @dev Regulator can be configured to meet relevant securities regulations, KYC policies\n', ' * AML requirements, tax laws, and more. The Regulator ensures that the PermissionedToken\n', ' * makes compliant transfers possible. Contains the userPermissions necessary\n', ' * for regulatory compliance.\n', ' *\n', ' */\n', 'contract Regulator is RegulatorStorage {\n', '    \n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event LogWhitelistedUser(address indexed who);\n', '    event LogBlacklistedUser(address indexed who);\n', '    event LogNonlistedUser(address indexed who);\n', '    event LogSetMinter(address indexed who);\n', '    event LogRemovedMinter(address indexed who);\n', '    event LogSetBlacklistDestroyer(address indexed who);\n', '    event LogRemovedBlacklistDestroyer(address indexed who);\n', '    event LogSetBlacklistSpender(address indexed who);\n', '    event LogRemovedBlacklistSpender(address indexed who);\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setMinter(address _who) public onlyValidator {\n', '        _setMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeMinter(address _who) public onlyValidator {\n', '        _removeMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        setUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogSetBlacklistSpender(_who);\n', '    }\n', '    \n', '    /**\n', '    * @notice Removes the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        removeUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogRemovedBlacklistSpender(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        setUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogSetBlacklistDestroyer(_who);\n', '    }\n', '    \n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogRemovedBlacklistDestroyer(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "whitelisted" user.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setWhitelistedUser(address _who) public onlyValidator {\n', '        _setWhitelistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "blacklisted" user. A blacklisted user has their accounts\n', '    * frozen; they cannot transfer, burn, or withdraw any tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistedUser(address _who) public onlyValidator {\n', '        _setBlacklistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "nonlisted" user. Nonlisted users can trade tokens,\n', '    * but cannot burn them (and therefore cannot convert them into fiat.)\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setNonlistedUser(address _who) public onlyValidator {\n', '        _setNonlistedUser(_who);\n', '    }\n', '\n', '    /** Returns whether or not a user is whitelisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is whitelisted, `false` otherwise.\n', '     */\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is blacklisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is blacklisted, `false` otherwise.\n', '     */\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is nonlisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is nonlisted, `false` otherwise.\n', '     */\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist spender.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist spender, `false` otherwise.\n', '     */\n', '    function isBlacklistSpender(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist destroyer.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist destroyer, `false` otherwise.\n', '     */\n', '    function isBlacklistDestroyer(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a minter.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a minter, `false` otherwise.\n', '     */\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, MINT_SIG);\n', '    }\n', '\n', '    /** Internal Functions **/\n', '\n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        setUserPermission(_who, MINT_SIG);\n', '        emit LogSetMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        removeUserPermission(_who, MINT_SIG);\n', '        emit LogRemovedMinter(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        setUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title PermissionedTokenProxy\n', '* @notice A proxy contract that serves the latest implementation of PermissionedToken.\n', '*/\n', 'contract PermissionedTokenProxy is UpgradeabilityProxy, Ownable {\n', '    \n', '    PermissionedTokenStorage public tokenStorage;\n', '    Regulator public regulator;\n', '\n', '    // Events\n', '    event ChangedRegulator(address indexed oldRegulator, address indexed newRegulator );\n', '\n', '\n', '    /**\n', '    * @dev create a new PermissionedToken as a proxy contract\n', '    * with a brand new data storage \n', '    **/\n', '    constructor(address _implementation, address _regulator) \n', '    UpgradeabilityProxy(_implementation) public {\n', '        regulator = Regulator(_regulator);\n', '        tokenStorage = new PermissionedTokenStorage();\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrade the backing implementation of the proxy.\n', '    * Only the admin can call this function.\n', '    * @param newImplementation Address of the new implementation.\n', '    */\n', '    function upgradeTo(address newImplementation) public onlyOwner {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '\n', '    /**\n', '    * @return The address of the implementation.\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return _implementation();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title CarbonDollarRegulator\n', ' * @dev CarbonDollarRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A CarbonDollar\n', ' * provides a user the additional ability to convert from CUSD into a whtielisted stablecoin\n', ' *\n', ' */\n', 'contract CarbonDollarRegulator is Regulator {\n', '\n', '    // Getters\n', '    function isWhitelistedUser(address _who) public view returns(bool) {\n', '        return (hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Internal functions **/\n', '    \n', '    // Setters: CarbonDollarRegulator overrides the definitions of whitelisted, nonlisted, and blacklisted setUserPermission\n', '\n', '    // CarbonDollar whitelisted users burn CUSD into a WhitelistedToken. Unlike PermissionedToken \n', '    // whitelisted users, CarbonDollar whitelisted users cannot burn ordinary CUSD without converting into WT\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        setUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollarProxy\n', '* @notice This contract will be the public facing CarbonUSD. All calls to the CarbonUSD contract will\n', '* be routed through this proxy, since this proxy contract is the owner of the\n', '* storage contracts.\n', '*/\n', 'contract CarbonDollarProxy is PermissionedTokenProxy {\n', '    \n', '    CarbonDollarStorage public tokenStorage_CD;\n', '\n', '    /** CONSTRUCTOR\n', '    * @dev Passes along arguments to base class.\n', '    */\n', '    constructor(address _implementation, address _regulator) public PermissionedTokenProxy(_implementation, _regulator) {\n', '        // base class override\n', '        regulator = CarbonDollarRegulator(_regulator);\n', '\n', '        tokenStorage_CD = new CarbonDollarStorage();\n', '\n', '    }\n', '}\n', '\n', '/**\n', '*\n', '* @dev CarbonDollarProxyFactory creates new CarbonDollarProxy contracts with new data storage sheets, properly configured\n', '* with ownership, and the proxy logic implementations are based on a user-specified CarbonDollar. \n', '*\n', '**/\n', 'contract CarbonDollarProxyFactory {\n', '    // Parameters\n', '    address[] public tokens;\n', '\n', '    // Events\n', '    event CreatedCarbonDollarProxy(address newToken, uint256 index);\n', '    \n', '    /**\n', '    *\n', '    * @dev generate a new proxy address that users can cast to a PermissionedToken or PermissionedTokenProxy. The\n', '    * proxy has empty data storage contracts connected to it and it is set with an initial logic contract\n', '    * to which it will delegate functionality\n', '    * @param regulator the address of the initial regulator contract that regulates the proxy\n', '    * @param tokenImplementation the address of the initial PT token implementation\n', '    *\n', '    **/\n', '    function createToken(address tokenImplementation, address regulator) public {\n', '        \n', '        address proxy = address(new CarbonDollarProxy(tokenImplementation, regulator));\n', '\n', '        // The function caller should own the proxy contract\n', '        CarbonDollarProxy(proxy).transferOwnership(msg.sender);\n', '\n', '        tokens.push(proxy);\n', '        emit CreatedCarbonDollarProxy(proxy, getCount()-1);\n', '    }\n', '\n', '    // Return number of token proxy contracts created so far\n', '    function getCount() public view returns (uint256) {\n', '        return tokens.length;\n', '    }\n', '\n', '    // Return the i&#39;th created token\n', '    function getToken(uint i) public view returns(address) {\n', '        require((i < tokens.length) && (i >= 0), "Invalid index");\n', '        return tokens[i];\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions". This adds two-phase\n', " * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n", ' * designates a new owner but does not actually transfer ownership. The new owner then accepts \n', ' * ownership and completes the transfer.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  address public pendingOwner;\n', '\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    pendingOwner = _newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '\n', '\n', '}\n', '\n', '/**\n', '* @title CarbonDollarStorage\n', '* @notice Contains necessary storage contracts for CarbonDollar (FeeSheet and StablecoinWhitelist).\n', '*/\n', 'contract CarbonDollarStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /** \n', '        Mappings\n', '    */\n', '    /* fees for withdrawing to stablecoin, in tenths of a percent) */\n', '    mapping (address => uint256) public fees;\n', '    /** @dev Units for fees are always in a tenth of a percent */\n', '    uint256 public defaultFee;\n', '    /* is the token address referring to a stablecoin/whitelisted token? */\n', '    mapping (address => bool) public whitelist;\n', '\n', '\n', '    /** \n', '        Events\n', '    */\n', '    event DefaultFeeChanged(uint256 oldFee, uint256 newFee);\n', '    event FeeChanged(address indexed stablecoin, uint256 oldFee, uint256 newFee);\n', '    event FeeRemoved(address indexed stablecoin, uint256 oldFee);\n', '    event StablecoinAdded(address indexed stablecoin);\n', '    event StablecoinRemoved(address indexed stablecoin);\n', '\n', '    /** @notice Sets the default fee for burning CarbonDollar into a whitelisted stablecoin.\n', '        @param _fee The default fee.\n', '    */\n', '    function setDefaultFee(uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = defaultFee;\n', '        defaultFee = _fee;\n', '        if (oldFee != defaultFee)\n', '            emit DefaultFeeChanged(oldFee, _fee);\n', '    }\n', '    \n', '    /** @notice Set a fee for burning CarbonDollar into a stablecoin.\n', '        @param _stablecoin Address of a whitelisted stablecoin.\n', '        @param _fee the fee.\n', '    */\n', '    function setFee(address _stablecoin, uint256 _fee) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = _fee;\n', '        if (oldFee != _fee)\n', '            emit FeeChanged(_stablecoin, oldFee, _fee);\n', '    }\n', '\n', '    /** @notice Remove the fee for burning CarbonDollar into a particular kind of stablecoin.\n', '        @param _stablecoin Address of stablecoin.\n', '    */\n', '    function removeFee(address _stablecoin) public onlyOwner {\n', '        uint256 oldFee = fees[_stablecoin];\n', '        fees[_stablecoin] = 0;\n', '        if (oldFee != 0)\n', '            emit FeeRemoved(_stablecoin, oldFee);\n', '    }\n', '\n', '    /** @notice Add a token to the whitelist.\n', '        @param _stablecoin Address of the new stablecoin.\n', '    */\n', '    function addStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = true;\n', '        emit StablecoinAdded(_stablecoin);\n', '    }\n', '\n', '    /** @notice Removes a token from the whitelist.\n', '        @param _stablecoin Address of the ex-stablecoin.\n', '    */\n', '    function removeStablecoin(address _stablecoin) public onlyOwner {\n', '        whitelist[_stablecoin] = false;\n', '        emit StablecoinRemoved(_stablecoin);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _stablecoin The stablecoin whose fee will be used.\n', '     */\n', '    function computeStablecoinFee(uint256 _amount, address _stablecoin) public view returns (uint256) {\n', '        uint256 fee = fees[_stablecoin];\n', '        return computeFee(_amount, fee);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the fee that will be charged on a "burn" operation.\n', '     * @param _amount The amount that will be traded.\n', '     * @param _fee The fee that will be charged, in tenths of a percent.\n', '     */\n', '    function computeFee(uint256 _amount, uint256 _fee) public pure returns (uint256) {\n', '        return _amount.mul(_fee).div(1000);\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', '// library AddressUtils {\n', '\n', '//   /**\n', '//    * Returns whether the target address is a contract\n', '//    * @dev This function will return false if invoked during the constructor of a contract,\n', '//    * as the code is not actually created until after the constructor finishes.\n', '//    * @param addr address to check\n', '//    * @return whether the target address is a contract\n', '//    */\n', '//   function isContract(address addr) internal view returns (bool) {\n', '//     uint256 size;\n', '//     // XXX Currently there is no better way to check if there is a contract in an address\n', '//     // than to check the size of the code at that address.\n', '//     // See https://ethereum.stackexchange.com/a/14016/36603\n', '//     // for more details about how this works.\n', '//     // TODO Check this again before the Serenity release, because all addresses will be\n', '//     // contracts then.\n', '//     // solium-disable-next-line security/no-inline-assembly\n', '//     assembly { size := extcodesize(addr) }\n', '//     return size > 0;\n', '//   }\n', '\n', '// }\n', '\n', '/**\n', '* @title PermissionedTokenStorage\n', '* @notice a PermissionedTokenStorage is constructed by setting Regulator, BalanceSheet, and AllowanceSheet locations.\n', '* Once the storages are set, they cannot be changed.\n', '*/\n', 'contract PermissionedTokenStorage is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '        Storage\n', '    */\n', '    mapping (address => mapping (address => uint256)) public allowances;\n', '    mapping (address => uint256) public balances;\n', '    uint256 public totalSupply;\n', '\n', '    function addAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].add(_value);\n', '    }\n', '\n', '    function subAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = allowances[_tokenHolder][_spender].sub(_value);\n', '    }\n', '\n', '    function setAllowance(address _tokenHolder, address _spender, uint256 _value) public onlyOwner {\n', '        allowances[_tokenHolder][_spender] = _value;\n', '    }\n', '\n', '    function addBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].add(_value);\n', '    }\n', '\n', '    function subBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = balances[_addr].sub(_value);\n', '    }\n', '\n', '    function setBalance(address _addr, uint256 _value) public onlyOwner {\n', '        balances[_addr] = _value;\n', '    }\n', '\n', '    function addTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.add(_value);\n', '    }\n', '\n', '    function subTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = totalSupply.sub(_value);\n', '    }\n', '\n', '    function setTotalSupply(uint256 _value) public onlyOwner {\n', '        totalSupply = _value;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  function () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', "   * This is a low level function that doesn't return to its internal call site.\n", '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize)\n', '\n', '      // Call the implementation.\n', "      // out and outsize are 0 because we don't know the size yet.\n", '      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize)\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize) }\n', '      default { return(0, returndatasize) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() internal {\n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "org.zeppelinos.proxy.implementation", and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _implementation Address of the initial implementation.\n', '   */\n', '  constructor(address _implementation) public {\n', '    assert(IMPLEMENTATION_SLOT == keccak256("org.zeppelinos.proxy.implementation"));\n', '\n', '    _setImplementation(_implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) private {\n', '    require(AddressUtils.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', '*\n', '* @dev Stores permissions and validators and provides setter and getter methods. \n', '* Permissions determine which methods users have access to call. Validators\n', '* are able to mutate permissions at the Regulator level.\n', '*\n', '*/\n', 'contract RegulatorStorage is Ownable {\n', '    \n', '    /** \n', '        Structs \n', '    */\n', '\n', '    /* Contains metadata about a permission to execute a particular method signature. */\n', '    struct Permission {\n', '        string name; // A one-word description for the permission. e.g. "canMint"\n', '        string description; // A longer description for the permission. e.g. "Allows user to mint tokens."\n', '        string contract_name; // e.g. "PermissionedToken"\n', '        bool active; // Permissions can be turned on or off by regulator\n', '    }\n', '\n', '    /** \n', '        Constants: stores method signatures. These are potential permissions that a user can have, \n', '        and each permission gives the user the ability to call the associated PermissionedToken method signature\n', '    */\n', '    bytes4 public constant MINT_SIG = bytes4(keccak256("mint(address,uint256)"));\n', '    bytes4 public constant MINT_CUSD_SIG = bytes4(keccak256("mintCUSD(address,uint256)"));\n', '    bytes4 public constant CONVERT_WT_SIG = bytes4(keccak256("convertWT(uint256)"));\n', '    bytes4 public constant BURN_SIG = bytes4(keccak256("burn(uint256)"));\n', '    bytes4 public constant CONVERT_CARBON_DOLLAR_SIG = bytes4(keccak256("convertCarbonDollar(address,uint256)"));\n', '    bytes4 public constant BURN_CARBON_DOLLAR_SIG = bytes4(keccak256("burnCarbonDollar(address,uint256)"));\n', '    bytes4 public constant DESTROY_BLACKLISTED_TOKENS_SIG = bytes4(keccak256("destroyBlacklistedTokens(address,uint256)"));\n', '    bytes4 public constant APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG = bytes4(keccak256("approveBlacklistedAddressSpender(address)"));\n', '    bytes4 public constant BLACKLISTED_SIG = bytes4(keccak256("blacklisted()"));\n', '\n', '    /** \n', '        Mappings \n', '    */\n', '\n', '    /* each method signature maps to a Permission */\n', '    mapping (bytes4 => Permission) public permissions;\n', '    /* list of validators, either active or inactive */\n', '    mapping (address => bool) public validators;\n', '    /* each user can be given access to a given method signature */\n', '    mapping (address => mapping (bytes4 => bool)) public userPermissions;\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event PermissionAdded(bytes4 methodsignature);\n', '    event PermissionRemoved(bytes4 methodsignature);\n', '    event ValidatorAdded(address indexed validator);\n', '    event ValidatorRemoved(address indexed validator);\n', '\n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Sets a permission within the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    * @param _permissionName A "slug" name for this permission (e.g. "canMint").\n', '    * @param _permissionDescription A lengthier description for this permission (e.g. "Allows user to mint tokens").\n', '    * @param _contractName Name of the contract that the method belongs to.\n', '    */\n', '    function addPermission(\n', '        bytes4 _methodsignature, \n', '        string _permissionName, \n', '        string _permissionDescription, \n', '        string _contractName) public onlyValidator { \n', '        Permission memory p = Permission(_permissionName, _permissionDescription, _contractName, true);\n', '        permissions[_methodsignature] = p;\n', '        emit PermissionAdded(_methodsignature);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission the list of permissions.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removePermission(bytes4 _methodsignature) public onlyValidator {\n', '        permissions[_methodsignature].active = false;\n', '        emit PermissionRemoved(_methodsignature);\n', '    }\n', '    \n', '    /**\n', '    * @notice Sets a permission in the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function setUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being set must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = true;\n', '    }\n', '\n', '    /**\n', '    * @notice Removes a permission from the list of permissions that a user has.\n', '    * @param _methodsignature Signature of the method that this permission controls.\n', '    */\n', '    function removeUserPermission(address _who, bytes4 _methodsignature) public onlyValidator {\n', '        require(permissions[_methodsignature].active, "Permission being removed must be for a valid method signature");\n', '        userPermissions[_who][_methodsignature] = false;\n', '    }\n', '\n', '    /**\n', '    * @notice add a Validator\n', '    * @param _validator Address of validator to add\n', '    */\n', '    function addValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = true;\n', '        emit ValidatorAdded(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice remove a Validator\n', '    * @param _validator Address of validator to remove\n', '    */\n', '    function removeValidator(address _validator) public onlyOwner {\n', '        validators[_validator] = false;\n', '        emit ValidatorRemoved(_validator);\n', '    }\n', '\n', '    /**\n', '    * @notice does validator exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isValidator(address _validator) public view returns (bool) {\n', '        return validators[_validator];\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function isPermission(bytes4 _methodsignature) public view returns (bool) {\n', '        return permissions[_methodsignature].active;\n', '    }\n', '\n', '    /**\n', '    * @notice get Permission structure\n', '    * @param _methodsignature request to retrieve the Permission struct for this methodsignature\n', '    * @return Permission\n', '    **/\n', '    function getPermission(bytes4 _methodsignature) public view returns \n', '        (string name, \n', '         string description, \n', '         string contract_name,\n', '         bool active) {\n', '        return (permissions[_methodsignature].name,\n', '                permissions[_methodsignature].description,\n', '                permissions[_methodsignature].contract_name,\n', '                permissions[_methodsignature].active);\n', '    }\n', '\n', '    /**\n', '    * @notice does permission exist?\n', '    * @return true if yes, false if no\n', '    **/\n', '    function hasUserPermission(address _who, bytes4 _methodsignature) public view returns (bool) {\n', '        return userPermissions[_who][_methodsignature];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Regulator\n', ' * @dev Regulator can be configured to meet relevant securities regulations, KYC policies\n', ' * AML requirements, tax laws, and more. The Regulator ensures that the PermissionedToken\n', ' * makes compliant transfers possible. Contains the userPermissions necessary\n', ' * for regulatory compliance.\n', ' *\n', ' */\n', 'contract Regulator is RegulatorStorage {\n', '    \n', '    /** \n', '        Modifiers \n', '    */\n', '    /**\n', '    * @notice Throws if called by any account that does not have access to set attributes\n', '    */\n', '    modifier onlyValidator() {\n', '        require (isValidator(msg.sender), "Sender must be validator");\n', '        _;\n', '    }\n', '\n', '    /** \n', '        Events \n', '    */\n', '    event LogWhitelistedUser(address indexed who);\n', '    event LogBlacklistedUser(address indexed who);\n', '    event LogNonlistedUser(address indexed who);\n', '    event LogSetMinter(address indexed who);\n', '    event LogRemovedMinter(address indexed who);\n', '    event LogSetBlacklistDestroyer(address indexed who);\n', '    event LogRemovedBlacklistDestroyer(address indexed who);\n', '    event LogSetBlacklistSpender(address indexed who);\n', '    event LogRemovedBlacklistSpender(address indexed who);\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setMinter(address _who) public onlyValidator {\n', '        _setMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to mint tokens.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeMinter(address _who) public onlyValidator {\n', '        _removeMinter(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        setUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogSetBlacklistSpender(_who);\n', '    }\n', '    \n', '    /**\n', '    * @notice Removes the necessary permissions for a user to spend tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistSpender(address _who) public onlyValidator {\n', '        require(isPermission(APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG), "Blacklist spending not supported by token");\n', '        removeUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '        emit LogRemovedBlacklistSpender(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        setUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogSetBlacklistDestroyer(_who);\n', '    }\n', '    \n', '\n', '    /**\n', '    * @notice Removes the necessary permissions for a user to destroy tokens from a blacklisted account.\n', '    * @param _who The address of the account that we are removing permissions for.\n', '    */\n', '    function removeBlacklistDestroyer(address _who) public onlyValidator {\n', '        require(isPermission(DESTROY_BLACKLISTED_TOKENS_SIG), "Blacklist token destruction not supported by token");\n', '        removeUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '        emit LogRemovedBlacklistDestroyer(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "whitelisted" user.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setWhitelistedUser(address _who) public onlyValidator {\n', '        _setWhitelistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "blacklisted" user. A blacklisted user has their accounts\n', '    * frozen; they cannot transfer, burn, or withdraw any tokens.\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setBlacklistedUser(address _who) public onlyValidator {\n', '        _setBlacklistedUser(_who);\n', '    }\n', '\n', '    /**\n', '    * @notice Sets the necessary permissions for a "nonlisted" user. Nonlisted users can trade tokens,\n', '    * but cannot burn them (and therefore cannot convert them into fiat.)\n', '    * @param _who The address of the account that we are setting permissions for.\n', '    */\n', '    function setNonlistedUser(address _who) public onlyValidator {\n', '        _setNonlistedUser(_who);\n', '    }\n', '\n', '    /** Returns whether or not a user is whitelisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is whitelisted, `false` otherwise.\n', '     */\n', '    function isWhitelistedUser(address _who) public view returns (bool) {\n', '        return (hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is blacklisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is blacklisted, `false` otherwise.\n', '     */\n', '    function isBlacklistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is nonlisted.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is nonlisted, `false` otherwise.\n', '     */\n', '    function isNonlistedUser(address _who) public view returns (bool) {\n', '        return (!hasUserPermission(_who, BURN_SIG) && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist spender.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist spender, `false` otherwise.\n', '     */\n', '    function isBlacklistSpender(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a blacklist destroyer.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a blacklist destroyer, `false` otherwise.\n', '     */\n', '    function isBlacklistDestroyer(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, DESTROY_BLACKLISTED_TOKENS_SIG);\n', '    }\n', '\n', '    /** Returns whether or not a user is a minter.\n', '     * @param _who The address of the account in question.\n', '     * @return `true` if the user is a minter, `false` otherwise.\n', '     */\n', '    function isMinter(address _who) public view returns (bool) {\n', '        return hasUserPermission(_who, MINT_SIG);\n', '    }\n', '\n', '    /** Internal Functions **/\n', '\n', '    function _setMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        setUserPermission(_who, MINT_SIG);\n', '        emit LogSetMinter(_who);\n', '    }\n', '\n', '    function _removeMinter(address _who) internal {\n', '        require(isPermission(MINT_SIG), "Minting not supported by token");\n', '        removeUserPermission(_who, MINT_SIG);\n', '        emit LogRemovedMinter(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        removeUserPermission(_who, BURN_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(BURN_SIG), "Burn method not supported by token");\n', '        require(isPermission(BLACKLISTED_SIG), "Self-destruct method not supported by token");\n', '        setUserPermission(_who, BURN_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title PermissionedTokenProxy\n', '* @notice A proxy contract that serves the latest implementation of PermissionedToken.\n', '*/\n', 'contract PermissionedTokenProxy is UpgradeabilityProxy, Ownable {\n', '    \n', '    PermissionedTokenStorage public tokenStorage;\n', '    Regulator public regulator;\n', '\n', '    // Events\n', '    event ChangedRegulator(address indexed oldRegulator, address indexed newRegulator );\n', '\n', '\n', '    /**\n', '    * @dev create a new PermissionedToken as a proxy contract\n', '    * with a brand new data storage \n', '    **/\n', '    constructor(address _implementation, address _regulator) \n', '    UpgradeabilityProxy(_implementation) public {\n', '        regulator = Regulator(_regulator);\n', '        tokenStorage = new PermissionedTokenStorage();\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrade the backing implementation of the proxy.\n', '    * Only the admin can call this function.\n', '    * @param newImplementation Address of the new implementation.\n', '    */\n', '    function upgradeTo(address newImplementation) public onlyOwner {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '\n', '    /**\n', '    * @return The address of the implementation.\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return _implementation();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title CarbonDollarRegulator\n', ' * @dev CarbonDollarRegulator is a type of Regulator that modifies its definitions of\n', ' * what constitutes a "whitelisted/nonlisted/blacklisted" user. A CarbonDollar\n', ' * provides a user the additional ability to convert from CUSD into a whtielisted stablecoin\n', ' *\n', ' */\n', 'contract CarbonDollarRegulator is Regulator {\n', '\n', '    // Getters\n', '    function isWhitelistedUser(address _who) public view returns(bool) {\n', '        return (hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isBlacklistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    function isNonlistedUser(address _who) public view returns(bool) {\n', '        return (!hasUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BURN_CARBON_DOLLAR_SIG) \n', '        && !hasUserPermission(_who, BLACKLISTED_SIG));\n', '    }\n', '\n', '    /** Internal functions **/\n', '    \n', '    // Setters: CarbonDollarRegulator overrides the definitions of whitelisted, nonlisted, and blacklisted setUserPermission\n', '\n', '    // CarbonDollar whitelisted users burn CUSD into a WhitelistedToken. Unlike PermissionedToken \n', '    // whitelisted users, CarbonDollar whitelisted users cannot burn ordinary CUSD without converting into WT\n', '    function _setWhitelistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        setUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogWhitelistedUser(_who);\n', '    }\n', '\n', '    function _setBlacklistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        setUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogBlacklistedUser(_who);\n', '    }\n', '\n', '    function _setNonlistedUser(address _who) internal {\n', '        require(isPermission(CONVERT_CARBON_DOLLAR_SIG), "Converting CUSD not supported");\n', '        require(isPermission(BURN_CARBON_DOLLAR_SIG), "Burning CUSD not supported");\n', '        require(isPermission(BLACKLISTED_SIG), "Blacklisting not supported");\n', '        removeUserPermission(_who, CONVERT_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BURN_CARBON_DOLLAR_SIG);\n', '        removeUserPermission(_who, BLACKLISTED_SIG);\n', '        emit LogNonlistedUser(_who);\n', '    }\n', '}\n', '\n', '/**\n', '* @title CarbonDollarProxy\n', '* @notice This contract will be the public facing CarbonUSD. All calls to the CarbonUSD contract will\n', '* be routed through this proxy, since this proxy contract is the owner of the\n', '* storage contracts.\n', '*/\n', 'contract CarbonDollarProxy is PermissionedTokenProxy {\n', '    \n', '    CarbonDollarStorage public tokenStorage_CD;\n', '\n', '    /** CONSTRUCTOR\n', '    * @dev Passes along arguments to base class.\n', '    */\n', '    constructor(address _implementation, address _regulator) public PermissionedTokenProxy(_implementation, _regulator) {\n', '        // base class override\n', '        regulator = CarbonDollarRegulator(_regulator);\n', '\n', '        tokenStorage_CD = new CarbonDollarStorage();\n', '\n', '    }\n', '}\n', '\n', '/**\n', '*\n', '* @dev CarbonDollarProxyFactory creates new CarbonDollarProxy contracts with new data storage sheets, properly configured\n', '* with ownership, and the proxy logic implementations are based on a user-specified CarbonDollar. \n', '*\n', '**/\n', 'contract CarbonDollarProxyFactory {\n', '    // Parameters\n', '    address[] public tokens;\n', '\n', '    // Events\n', '    event CreatedCarbonDollarProxy(address newToken, uint256 index);\n', '    \n', '    /**\n', '    *\n', '    * @dev generate a new proxy address that users can cast to a PermissionedToken or PermissionedTokenProxy. The\n', '    * proxy has empty data storage contracts connected to it and it is set with an initial logic contract\n', '    * to which it will delegate functionality\n', '    * @param regulator the address of the initial regulator contract that regulates the proxy\n', '    * @param tokenImplementation the address of the initial PT token implementation\n', '    *\n', '    **/\n', '    function createToken(address tokenImplementation, address regulator) public {\n', '        \n', '        address proxy = address(new CarbonDollarProxy(tokenImplementation, regulator));\n', '\n', '        // The function caller should own the proxy contract\n', '        CarbonDollarProxy(proxy).transferOwnership(msg.sender);\n', '\n', '        tokens.push(proxy);\n', '        emit CreatedCarbonDollarProxy(proxy, getCount()-1);\n', '    }\n', '\n', '    // Return number of token proxy contracts created so far\n', '    function getCount() public view returns (uint256) {\n', '        return tokens.length;\n', '    }\n', '\n', "    // Return the i'th created token\n", '    function getToken(uint i) public view returns(address) {\n', '        require((i < tokens.length) && (i >= 0), "Invalid index");\n', '        return tokens[i];\n', '    }\n', '}']
