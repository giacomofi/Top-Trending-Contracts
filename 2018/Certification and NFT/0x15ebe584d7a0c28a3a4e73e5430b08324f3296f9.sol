['pragma solidity >=0.4.22 <0.6.0;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address who) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender)\n', '    external view returns (uint256);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function approve(address spender, uint256 value)\n', '    external returns (bool);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    external returns (bool);\n', '\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title ERC20Detailed token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '\n', '  constructor(string name, string symbol, uint8 decimals) public {\n', '    _name = name;\n', '    _symbol = symbol;\n', '    _decimals = decimals;\n', '  }\n', '\n', '  /**\n', '   * @return the name of the token.\n', '   */\n', '  function name() public view returns(string) {\n', '    return _name;\n', '  }\n', '\n', '  /**\n', '   * @return the symbol of the token.\n', '   */\n', '  function symbol() public view returns(string) {\n', '    return _symbol;\n', '  }\n', '\n', '  /**\n', '   * @return the number of decimals of the token.\n', '   */\n', '  function decimals() public view returns(uint8) {\n', '    return _decimals;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract ERC20 is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  mapping (address => uint256) private _balances;\n', '\n', '  mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '  uint256 private _totalSupply;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param owner The address to query the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param owner address The address which owns the funds.\n', '   * @param spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address owner,\n', '    address spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return _allowed[owner][spender];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  */\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    _transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param spender The address which will spend the funds.\n', '   * @param value The amount of tokens to be spent.\n', '   */\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param from address The address which you want to send tokens from\n', '   * @param to address The address which you want to transfer to\n', '   * @param value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(value <= _allowed[from][msg.sender]);\n', '\n', '    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '    _transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed_[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param spender The address which will spend the funds.\n', '   * @param addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseAllowance(\n', '    address spender,\n', '    uint256 addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].add(addedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed_[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param spender The address which will spend the funds.\n', '   * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseAllowance(\n', '    address spender,\n', '    uint256 subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(spender != address(0));\n', '\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].sub(subtractedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified addresses\n', '  * @param from The address to transfer from.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  */\n', '  function _transfer(address from, address to, uint256 value) internal {\n', '    require(value <= _balances[from]);\n', '    require(to != address(0));\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(from, to, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that mints an amount of the token and assigns it to\n', '   * an account. This encapsulates the modification of balances such that the\n', '   * proper events are emitted.\n', '   * @param account The account that will receive the created tokens.\n', '   * @param value The amount that will be created.\n', '   */\n', '  function _mint(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    _totalSupply = _totalSupply.add(value);\n', '    _balances[account] = _balances[account].add(value);\n', '    emit Transfer(address(0), account, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that burns an amount of the token of a given\n', '   * account.\n', '   * @param account The account whose tokens will be burnt.\n', '   * @param value The amount that will be burnt.\n', '   */\n', '  function _burn(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    require(value <= _balances[account]);\n', '\n', '    _totalSupply = _totalSupply.sub(value);\n', '    _balances[account] = _balances[account].sub(value);\n', '    emit Transfer(account, address(0), value);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function that burns an amount of the token of a given\n', "   * account, deducting from the sender's allowance for said account. Uses the\n", '   * internal burn function.\n', '   * @param account The account whose tokens will be burnt.\n', '   * @param value The amount that will be burnt.\n', '   */\n', '  function _burnFrom(address account, uint256 value) internal {\n', '    require(value <= _allowed[account][msg.sender]);\n', '\n', '    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n', '    // this function needs to emit an event with the updated approval.\n', '    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n', '      value);\n', '    _burn(account, value);\n', '  }\n', '}\n', '\n', 'library CommUtils{\n', '\n', ' \n', '    uint256 constant MAX_MUL_BASE = 340282366920939000000000000000000000000;\n', '\n', '\n', '    function abs(uint256 a,uint256 b) internal pure returns(uint256){\n', '        return a>b ? a-b : b-a;\n', '    }\n', '\n', '   \n', '    function mult(uint256 a, uint256 b) \n', '        internal \n', '        pure \n', '        returns (uint256 c) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }    \n', '\n', '    function pwr(uint256 x, uint256 y)\n', '        internal \n', '        pure \n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else \n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mult(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '\n', '\n', '    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\n', '        return tar *rate / 100;\n', '    }  \n', '    \n', '    function mulRate1000(uint256 tar,uint256 rate) public pure returns (uint256){\n', '        return tar *rate / 1000;\n', '    }  \n', '    \n', '    \n', '    /**\n', '     * @dev filters name strings\n', '     * -converts uppercase to lower case.  \n', '     * -makes sure it does not start/end with a space\n', '     * -makes sure it does not contain multiple spaces in a row\n', '     * -cannot be only numbers\n', '     * -cannot start with 0x \n', '     * -restricts characters to A-Z, a-z, 0-9, and space.\n', '     * @return reprocessed string in bytes32 format\n', '     */\n', '    function nameFilter(string _input)\n', '        internal\n', '        pure\n', '        returns(bytes32)\n', '    {\n', '        bytes memory _temp = bytes(_input);\n', '        uint256 _length = _temp.length;\n', '        \n', '        //sorry limited to 32 characters\n', '        require (_length <= 32 && _length > 0, "string must be between 1 and 32 characters");\n', '        // make sure it doesnt start with or end with space\n', '        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, "string cannot start or end with space");\n', '        // make sure first two characters are not 0x\n', '        if (_temp[0] == 0x30)\n', '        {\n', '            require(_temp[1] != 0x78, "string cannot start with 0x");\n', '            require(_temp[1] != 0x58, "string cannot start with 0X");\n', '        }\n', '        \n', '        // create a bool to track if we have a non number character\n', '        bool _hasNonNumber;\n', '        \n', '        // convert & check\n', '        for (uint256 i = 0; i < _length; i++)\n', '        {\n', '            // if its uppercase A-Z\n', '            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n', '            {\n', '                // convert to lower case a-z\n', '                _temp[i] = byte(uint(_temp[i]) + 32);\n', '                \n', '                // we have a non number\n', '                if (_hasNonNumber == false)\n', '                    _hasNonNumber = true;\n', '            } else {\n', '                require\n', '                (\n', '                    // require character is a space\n', '                    _temp[i] == 0x20 || \n', '                    // OR lowercase a-z\n', '                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n', '                    // or 0-9\n', '                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\n', '                    "string contains invalid characters"\n', '                );\n', '                // make sure theres not 2x spaces in a row\n', '                if (_temp[i] == 0x20)\n', '                    require( _temp[i+1] != 0x20, "string cannot contain consecutive spaces");\n', '                \n', '                // see if we have a character other than a number\n', '                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n', '                    _hasNonNumber = true;    \n', '            }\n', '        }\n', '        \n', '        require(_hasNonNumber == true, "string cannot be only numbers");\n', '        \n', '        bytes32 _ret;\n', '        assembly {\n', '            _ret := mload(add(_temp, 32))\n', '        }\n', '        return (_ret);\n', '    }   \n', '    \n', '    function isStringEmpty(string str) internal pure returns(bool){\n', '        bytes memory tempEmptyStringTest = bytes(str); \n', '        return tempEmptyStringTest.length == 0;\n', '    }\n', '     \n', '    \n', '    \n', '    \n', '    \n', '    struct Float{\n', '        uint256 number;\n', '        uint256 digits;\n', '    }\n', '    \n', '    function initFloat(uint256 v,uint256 denominator) internal pure returns(Float){\n', '        return Float(v*denominator,denominator);\n', '    }\n', '    \n', '    \n', '    function pow(Float f ,uint256 count) internal pure returns(Float ans){\n', '\n', '        if (count==0){\n', '            return Float(10,1);\n', '        }\n', '        ans.number = f.number;\n', '        ans.digits = f.digits;\n', '        for(uint256 i=1;i<count;i++){\n', '            ans = multiply(ans,f);\n', '        }\n', '    }\n', '    \n', '    function decrease(Float f,Float o) internal pure returns(bool ok,Float ans){\n', '        sameDigits(f,o);\n', '        require(f.digits == o.digits,"it`s must same sameDigits");\n', '        if(f.number >= o.number ){\n', '            ok = true;            \n', '            ans.number = f.number - o.number;\n', '            ans.digits = f.digits;\n', '        }\n', '    }\n', '    \n', '    function increase(Float f,Float o) internal pure returns(Float ans){\n', '        sameDigits(f,o);\n', '        require(f.digits == o.digits,"it`s must same sameDigits");\n', '        ans.number = f.number+o.number;\n', '        ans.digits = f.digits;\n', '    }\n', '    \n', '    function sameDigits(Float f,Float o) private pure {\n', '        return f.digits > o.digits ? _sameDigits(f,o) : _sameDigits(o,f) ;\n', '    }\n', '    \n', '    function _sameDigits(Float big,Float small ) private pure {\n', '        uint256 dd = big.digits - small.digits;\n', '        small.number = small.number * pwr(10,dd);\n', '        small.digits = big.digits;\n', '    }\n', '    \n', '    function multiSafe(uint256 a,uint256 b) internal pure returns (uint256 ans,uint256 ap,uint256 bp){\n', '        (uint256 newA, uint256 apow)  = powDown(a);\n', '        (uint256 newB, uint256 bpow)  = powDown(b);\n', '        ans = mult(newA , newB);\n', '        ap = apow;\n', '        bp = bpow;\n', '    }\n', '    \n', '    function powDown(uint256 a) internal pure returns(uint256 newA,uint256 pow10){\n', '        newA = a;\n', '        while(newA>=MAX_MUL_BASE){\n', '            pow10++;\n', '            newA /= 10;\n', '        }\n', '    }\n', '    \n', '    function multiply(Float  f,Float o) internal pure returns(Float ans){\n', '        (uint256 v,uint256 ap,uint256 bp ) = multiSafe(f.number,o.number);\n', '        ans.number = v;  \n', '        ans.digits = f.digits+o.digits-(ap+bp);\n', '    }\n', '    \n', '    function multiply(Float  f,uint256 tar) internal pure returns(Float ans){\n', '        (uint256 v,uint256 ap,uint256 bp ) = multiSafe(f.number,tar);\n', '        ans.number = v;\n', '        ans.digits = f.digits-(ap+bp);\n', '    }    \n', '    \n', '    function divide(Float f,Float o) internal pure returns(Float ans){\n', '       if(f.digits >= o.digits){\n', '           ans.digits = f.digits - o.digits;\n', '       }else{\n', '           uint256 dp = o.digits - f.digits;\n', '           ans.digits = 0;\n', '           ans.number = mult( f.number , pwr(10,dp));\n', '       }\n', '        ans.number = ans.number / o.number;\n', '    }\n', '    \n', '    function toUint256(Float f) internal pure returns(uint256 ans){\n', '        ans = f.number;\n', '        for(uint256 i=0;i<f.digits;i++){\n', '            ans /= 10;\n', '        }\n', '    }\n', '    \n', '    function getIntegral(Float exCoefficient,uint256 xb,uint256 tokenDigits,uint256 X_POW) internal pure returns(uint256 ){\n', '        CommUtils.Float memory x = CommUtils.Float(xb,tokenDigits);\n', '        Float memory xPow = pow(x,X_POW+1);\n', '        Float memory ec = pow(exCoefficient,X_POW);\n', '        Float memory tempAns = multiply(xPow,ec);\n', '        return toUint256(tempAns)/(X_POW+1); \n', '    }   \n', '    \n', '    \n', '    \n', '    struct Countdown{\n', '        uint128 max;\n', '        uint128 current;\n', '        uint256 timestamp;\n', '        uint256 period;\n', '        bool passing;\n', '    }\n', '    \n', '    function freshAndCheck(Countdown  d,uint256 curP,uint256 max,uint256 period) view internal returns(Countdown){\n', '        if(d.timestamp == 0) {\n', '            d=Countdown( uint128( max),0,  now,period , true);\n', '        }  \n', '        if(now - d.timestamp > period){\n', '          d= Countdown( uint128( max),0,now,period,true);  \n', '        } \n', '        d.current += uint128(curP);\n', '        d.passing = d.current <= d.max;\n', '        return d;\n', '    }    \n', '    \n', '    \n', '}\n', '\n', '\n', '\n', 'library Player{\n', '\n', '    using CommUtils for string;\n', '    using CommUtils for CommUtils.Countdown;\n', '    uint256 public constant BONUS_INTERVAL = 60*60*24*7;\n', '    \n', '    \n', '    struct Map{\n', '        mapping(address=>uint256) bonusAt;\n', '        mapping(address=>uint256) ethMap;\n', '        mapping(address=>address) referrerMap;\n', '        mapping(address=>bytes32) addrNameMap;\n', '        mapping(bytes32=>address) nameAddrMap;\n', '        mapping(address=>CommUtils.Countdown) sellLimeMap;\n', '    }\n', '    \n', '    function remove(Map storage ps,address adr) internal{\n', '        //transferAuthor(ps.ethMap[adr]);\n', '        delete ps.ethMap[adr];\n', '        bytes32 b = ps.addrNameMap[adr];\n', '        delete ps.nameAddrMap[b];\n', '        delete ps.addrNameMap[adr];\n', '    }\n', '    \n', '    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\n', '       ps.ethMap[adr]+=v;\n', '        return v;\n', '    }\n', '    \n', '    \n', '\n', '\n', '\n', '    function refleshBonusAt(Map storage  ps,address addr,uint256 allCount,uint256 plusCount) internal{\n', '        if(ps.bonusAt[addr] == 0)        {\n', '            ps.bonusAt[addr] = now;\n', '            return;\n', '        }\n', '        uint256 plsuAt = BONUS_INTERVAL * plusCount / allCount;\n', '        ps.bonusAt[addr] += plsuAt;\n', '        ps.bonusAt[addr] = ps.bonusAt[addr] > now ? now : ps.bonusAt[addr];\n', '    }\n', '    \n', '    \n', '    \n', '    function isOverBonusAt(Map storage ps,address addr) internal returns(bool ){\n', '        if( (ps.bonusAt[addr] - now)> BONUS_INTERVAL){\n', '            ps.bonusAt[addr] = now;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function transferSafe(address addr,uint256 v) internal {\n', '        if(address(this).balance>=v){\n', '            addr.transfer(v);\n', '        }else{\n', '            addr.transfer( address(this).balance);\n', '        }\n', '    }\n', '    \n', '\n', '    function minus(Map storage  ps,address adr,uint256 num) internal  {\n', '        uint256 sum = ps.ethMap[adr];\n', '        if(sum==num){\n', '             withdrawalAll(ps,adr);\n', '        }else{\n', '            require(sum > num);\n', '            ps.ethMap[adr] = sum-num;\n', '        }\n', '    }\n', '    \n', '    function minusAndTransfer(Map storage  ps,address adr,uint256 num) internal  {\n', '        minus(ps,adr,num);\n', '        transferSafe(adr,num);\n', '    }    \n', '    \n', '    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\n', '        uint256 sum = ps.ethMap[adr];\n', '        delete ps.ethMap[adr];\n', '        return sum;\n', '    }\n', '    \n', '    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\n', '        return ps.ethMap[adr];\n', '    }\n', '    \n', '    function registerName(Map storage ps,bytes32 _name)internal  {\n', '        require(ps.nameAddrMap[_name] == address(0) );\n', '        ps.nameAddrMap[_name] = msg.sender;\n', '        ps.addrNameMap[msg.sender] = _name;\n', '    }\n', '    \n', '    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\n', '        return ps.nameAddrMap[_name] == address(0);\n', '    }\n', '    \n', '    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\n', '        return ps.nameAddrMap[_name] ;\n', '    }\n', '    \n', '    function getName(Map storage ps) public view returns(bytes32){\n', '        return ps.addrNameMap[msg.sender];\n', '    }\n', '    \n', '    function getName(Map storage ps,address adr) public view returns(bytes32){\n', '        return ps.addrNameMap[adr];\n', '    }    \n', '    \n', '    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\n', '        return ps.addrNameMap[adr];\n', '    }    \n', '    \n', '    function getReferrer(Map storage ps,address adr)public view returns(address){\n', '        address refA = ps.referrerMap[adr];\n', '        bytes32 b= ps.addrNameMap[refA];\n', '        return b.length == 0 ? getReferrer(ps,refA) : refA;\n', '    }\n', '    \n', '    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\n', '        return getNameByAddr(ps,getReferrer(ps,adr));\n', '    }\n', '    \n', '    function setReferrer(Map storage ps,address self,address referrer)internal {\n', '         ps.referrerMap[self] = referrer;\n', '    }\n', '    \n', '    function applyReferrer(Map storage ps,string referrer)internal {\n', '        bytes32 rbs = referrer.nameFilter();\n', '        address referrerAdr = getByName(ps,rbs);\n', '        require(referrerAdr != address(0),"referrerAdr is null");\n', '        require(getReferrer(ps,msg.sender) == address(0) ,"must reffer is null");\n', '        require(referrerAdr != msg.sender ,"referrerAdr is self ");\n', '        require(getName(ps).length==0 || getName(ps) == bytes32(0),"must not reqester");\n', '        setReferrer(ps,msg.sender,referrerAdr);\n', '    }    \n', '    \n', '    \n', '    function checkSellLimt(Map storage ps,uint256 curP,uint256 max,uint256 period)  internal returns(CommUtils.Countdown) {\n', '        CommUtils.Countdown storage cd =  ps.sellLimeMap[msg.sender];\n', '        ps.sellLimeMap[msg.sender] = cd.freshAndCheck(curP,max,period);\n', '        return ps.sellLimeMap[msg.sender];\n', '    }   \n', '    \n', '    function getSellLimt(Map storage ps) internal view returns (CommUtils.Countdown ) {\n', '        return ps.sellLimeMap[msg.sender];\n', '    }\n', '    \n', '    \n', '    \n', '}\n', '\n', '\n', 'contract IOE is  ERC20, ERC20Detailed {\n', '    \n', '    using CommUtils for CommUtils.Countdown;\n', '    using CommUtils for CommUtils.Float;\n', '    using CommUtils for string;\n', '    using Player for Player.Map;\n', '    \n', '    \n', '\n', '    uint256 private constant MAX_BUY_BY_USER_RATE = 3;\n', '    uint256 private constant MAX_SELL_BY_USER_RATE = 10;\n', '    uint256 private constant MAX_SELL_PER_USER_RATE = 25;\n', '    uint256 private constant SELL_BUY_PERIOD= 60*60*24;\n', '    uint256 private constant tokenDigits = 9;\n', '    uint256 private constant tokenM = 1000000000;\n', '    uint256 private constant INITIAL_SUPPLY = 100000000 * tokenM;\n', '    uint256 private constant X_POW = 2; // y= (exCoefficient * x)^X_POW\n', '    uint256 private constant BUY_BONUS_IN_1000 = 80;\n', '    uint256 private constant SELL_BONUS_IN_1000 = 100;\n', '    uint256 private constant REGESTER_FEE = 0.02 ether;\n', '    uint256 private constant VIP_DISCOUNT_WEIGHT = 3;\n', '    uint256 private constant VIP_INTTO_POOL_WEIGHT = 3;\n', '    uint256 private constant VIP_TOUP_WEIGHT = 3;\n', '    uint256 private constant VIP_RETOUP_RATE_1000 = 110;\n', '    uint256 private constant HELP_MINING_BUY_1000 = 30;\n', '    uint256 private constant HELP_MINING_SELL_1000 = 50;\n', '    uint256 private constant VIP_ALL_WEIGHT = VIP_DISCOUNT_WEIGHT+VIP_INTTO_POOL_WEIGHT+VIP_TOUP_WEIGHT;\n', '\n', '    address private OFFICIAL_ADDR ;\n', '    uint256 private constant MIN_TX_ETHER = 0.001 ether;\n', '    uint256 private providedCount =0;\n', '    uint256 private vipPool = 0;\n', '    Player.Map private players;\n', '    CommUtils.Float exCoefficient;\n', '    CommUtils.Countdown private buyByUserCD ;\n', '    CommUtils.Countdown private sellByUserCD ;\n', '    \n', '\n', '    /**\n', '     * @dev Constructor that gives msg.sender all of existing tokens.\n', '     */\n', '    constructor (address oa) public   ERC20Detailed("INTELLIGENT OPERATING SYSTEM EXCHANGE", "IOE",9) {\n', '        _mint(this, INITIAL_SUPPLY);\n', '        require(CommUtils.pwr(10,tokenDigits) == tokenM,"it`s not same tokenM");\n', '        exCoefficient = CommUtils.Float(1224744871,8);\n', '        OFFICIAL_ADDR = oa;\n', '    } \n', '    \n', '    \n', '    function getInfo() public view returns(\n', '            uint256, //constractBlance\n', '            uint256, //current providedCount count\n', '            uint256,   // selfTokenBlance\n', '            uint256,  //bounus pool\n', '            uint256,   // contract now\n', '            uint256,    // bonusAt\n', '            bytes32, // registeredName\n', '            bytes32, // refname\n', '            uint256,   //VIP Reward\n', '            address   //offAdd\n', '        ){\n', '        return (\n', '            address(this).balance,\n', '            providedCount, \n', '            balanceOf(msg.sender),\n', '            getBonusPool(),\n', '            now,\n', '            players.bonusAt[msg.sender],\n', '            players.getName(),\n', '            players.getReferrerName(msg.sender),\n', '            players.getAmmount(msg.sender),\n', '            OFFICIAL_ADDR\n', '        );\n', '    }\n', '    \n', '    function getLimtInfo() public view returns(\n', '        uint256 buyMax,uint256 buyCur,uint256 buyStartAt,\n', '        uint256 sellMax , uint256 sellCur , uint256 sellStartAt,\n', '        uint256 sellPerMax, uint256 sellCurPer , uint256 sellPerStartAt\n', '    ){\n', '        CommUtils.Countdown memory bCD = buyByUserCD.freshAndCheck(0,CommUtils.mulRate(INITIAL_SUPPLY-providedCount,MAX_BUY_BY_USER_RATE),SELL_BUY_PERIOD);\n', '        buyMax = bCD.max;\n', '        buyCur = bCD.current;\n', '        buyStartAt = bCD.timestamp;\n', '        CommUtils.Countdown memory sCD  = sellByUserCD.freshAndCheck(0,CommUtils.mulRate(providedCount,MAX_SELL_BY_USER_RATE),SELL_BUY_PERIOD);\n', '        sellMax = sCD.max;\n', '        sellCur = sCD.current;\n', '        sellStartAt = sCD.timestamp;\n', '        CommUtils.Countdown memory perCD = players.getSellLimt().freshAndCheck(0,CommUtils.mulRate(balanceOf(msg.sender),MAX_SELL_PER_USER_RATE),SELL_BUY_PERIOD);\n', '        sellPerMax = perCD.max;\n', '        sellCurPer = perCD.current;\n', '        sellPerStartAt = perCD.timestamp;\n', '    }\n', '    \n', '    \n', '    \n', '    function applyReferrer(string referrer) private {\n', '        if(referrer.isStringEmpty()) return;\n', '        players.applyReferrer(referrer);\n', '    }\n', '    \n', '    function getBuyMinPow(uint256 eth) view public  returns(uint256 pow, uint256 current,uint256 valuePowNum,uint256 valuePowDig){\n', '        pow = X_POW+1;\n', '        current = providedCount;\n', '        CommUtils.Float memory x2Pow = CommUtils.Float(providedCount,tokenDigits).pow(X_POW+1);\n', '        CommUtils.Float memory rr = exCoefficient.pow(X_POW);\n', '        CommUtils.Float memory V3 = CommUtils.Float((X_POW+1) * eth,0);\n', '        CommUtils.Float memory LEFT = V3.divide(rr);\n', '        CommUtils.Float memory value = LEFT.increase( x2Pow);\n', '        valuePowNum = value.number;\n', '        valuePowDig = value.digits;\n', '    }\n', '    \n', '    function getSellMinPow(uint256 eth) view public  returns(uint256 pow, uint256 current,uint256 valuePowNum,uint256 valuePowDig){\n', '        pow = X_POW+1;\n', '        current = providedCount;\n', '        CommUtils.Float memory x2Pow = CommUtils.Float(providedCount,tokenDigits).pow(X_POW+1);\n', '        CommUtils.Float memory rr = exCoefficient.pow(X_POW);\n', '        CommUtils.Float memory V3 = CommUtils.Float((X_POW+1) * eth,0);\n', '        CommUtils.Float memory LEFT = V3.divide(rr);\n', '        (bool ok,CommUtils.Float memory _value) = x2Pow.decrease(LEFT);\n', '        CommUtils.Float memory value = ok ? _value : CommUtils.Float(current,tokenDigits).pow(pow);\n', '        valuePowNum = value.number;\n', '        valuePowDig = value.digits;\n', '    }    \n', '    \n', '    \n', '    function getIntegralAtBound(uint256 start,uint256 end) view public  returns(uint256){\n', '        require(end>start,"must end > start");\n', '        uint256 endI = exCoefficient.getIntegral(end,tokenDigits,X_POW);\n', '        uint256 startI = exCoefficient.getIntegral(start,tokenDigits,X_POW);\n', '        require(endI > startI ,"it`s endI  Integral > startI");\n', '        return endI - startI;\n', '    }\n', '    \n', '    function buyByUser(uint256 count,string referrer)   public payable {\n', '        buyByUserCD = buyByUserCD.freshAndCheck(count,CommUtils.mulRate(INITIAL_SUPPLY-providedCount,MAX_BUY_BY_USER_RATE),SELL_BUY_PERIOD);\n', '        require(buyByUserCD.passing ,"it`s over buy max count");\n', '        applyReferrer(referrer);\n', '        uint256 all = providedCount+count;\n', '        require(all<= INITIAL_SUPPLY,"count over INITIAL_SUPPLY");\n', '        uint256 costEth = getIntegralAtBound(providedCount,providedCount+count);\n', '        uint256 reqEth = costEth * (1000+BUY_BONUS_IN_1000) / 1000;\n', '        require(msg.value >= reqEth,"not enough eth");\n', '        bonusFee(costEth,reqEth);\n', '        providedCount = all;\n', '        uint256 helpM = CommUtils.mulRate1000(count,HELP_MINING_BUY_1000);\n', '        _transfer(this,msg.sender,count-helpM);\n', '         _transfer(this,OFFICIAL_ADDR,helpM);\n', '        players.refleshBonusAt(msg.sender,balanceOf(msg.sender),count);\n', '        emit OnDealed (msg.sender,true,count,providedCount); \n', '    }\n', '    \n', '    function sellByUser(uint256 count,string referrer)   public  {\n', '        require(providedCount >= count ,"count over providedCount ");\n', '        sellByUserCD = sellByUserCD.freshAndCheck(count,CommUtils.mulRate(providedCount,MAX_SELL_BY_USER_RATE),SELL_BUY_PERIOD);\n', '        require(sellByUserCD.passing ,"it`s over sell max count");\n', '        require(players.checkSellLimt(count,CommUtils.mulRate(balanceOf(msg.sender),MAX_SELL_PER_USER_RATE),SELL_BUY_PERIOD).passing,"SELL over per user count");\n', '        applyReferrer(referrer);\n', '        uint256 helpM = CommUtils.mulRate1000(count,HELP_MINING_SELL_1000);\n', '        uint256 realCount = (count-helpM);\n', '        uint256 start = providedCount-realCount;\n', '        uint256 end = providedCount;\n', '        uint256 reqEth = getIntegralAtBound(start,end);\n', '        uint256 costEth = reqEth * (1000- SELL_BONUS_IN_1000) / 1000;\n', '        providedCount -= realCount;\n', '        bonusFee(costEth,reqEth);\n', '        transfer(this,count);\n', '         _transfer(this,OFFICIAL_ADDR,helpM);\n', '        emit OnDealed (msg.sender,false,count,providedCount); \n', '        Player.transferSafe(msg.sender,costEth);\n', '    }\n', '    \n', '    function bonusFee(uint256 costEth,uint256 reqEth) private {\n', '        address referrer = players.getReferrer(msg.sender);\n', '        bool unreged = players.getName().length==0 || players.getName() == bytes32(0);\n', '        if(unreged && referrer==address(0)) return;\n', '        if(reqEth < costEth ) return ;\n', '        uint256 orgFee = reqEth - costEth;\n', '        uint256 repay = orgFee * VIP_DISCOUNT_WEIGHT / VIP_ALL_WEIGHT;\n', '        uint256 toUp = orgFee * VIP_TOUP_WEIGHT / VIP_ALL_WEIGHT;\n', '       // uint256 inPool = orgFee -(repay+toUp);\n', '        players.deposit(msg.sender,repay);\n', '        vipPool += repay;\n', '        if(referrer != address(0)){\n', '            players.deposit(referrer,toUp);\n', '            vipPool += toUp;\n', '        }\n', '    }    \n', '    \n', '    /*  @override  */  \n', '    function transferFrom(address from,address to,uint256 value)public returns (bool){\n', '        players.refleshBonusAt(to,balanceOf(to),value);\n', '        return super.transferFrom(from,to,value);\n', '    }    \n', '    \n', '    /*  @override  */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        players.refleshBonusAt(to,balanceOf(to),value);\n', '        return super.transfer(to,value);\n', '    }    \n', '    \n', '    function getStockBlance() view private returns(uint256){\n', '        return exCoefficient.getIntegral(providedCount,tokenDigits,X_POW);\n', '    }\n', '    \n', '    function getBonusPool() view private returns(uint256){\n', '        return address(this).balance - (getStockBlance()+ vipPool);\n', '    }    \n', '\n', '    function withdrawalBunos(address[] adrs) public  {\n', '        if(adrs.length == 0){\n', '            withdrawalBunos(msg.sender);\n', '        }else{\n', '            for(uint256 i=0;i<adrs.length;i++){\n', '                withdrawalBunos(adrs[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function withdrawalBunos(address adr) private {\n', '        bool b = players.isOverBonusAt(adr) ;\n', '        if(!b) return;\n', '        uint256 bonus = getBonusPool() * balanceOf(adr) / providedCount;\n', '        Player.transferSafe(adr,bonus);\n', '    }    \n', '    \n', '    function withdrawalVipReward() public  {\n', '        uint256 reward = players.withdrawalAll(msg.sender);\n', '        uint256 toUp = CommUtils.mulRate1000(reward,VIP_RETOUP_RATE_1000);\n', '        uint256 realReward =reward- toUp;\n', '        vipPool -= realReward;\n', '        Player.transferSafe(msg.sender,realReward);\n', '        address referrer = players.getReferrer(msg.sender);\n', '        if(referrer != address(0)){\n', '            players.deposit(referrer,toUp);\n', '        }else{\n', '            vipPool -= toUp;\n', '        }\n', '    }    \n', '    \n', '    \n', '    function isEmptyName(string _n) public view returns(bool){\n', '        return players.isEmptyName(_n.nameFilter());\n', '    }     \n', '    \n', '    function registerName(string name)  public  payable {\n', '        require(msg.value >= REGESTER_FEE,"fee not enough");\n', '        players.registerName(name.nameFilter());\n', '    }     \n', '\n', '    // function testWithdrawalAll()  public {\n', '    //     msg.sender.transfer(address( this).balance);\n', '    // }\n', '    \n', '\n', '    event OnDealed(\n', '        address who,\n', '        bool buyed,\n', '        uint256 ammount,\n', '        uint256 newProvidedCount\n', '    );\n', '\n', '\n', '}']