['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TokenRecipient {\n', '    event ReceivedEther(address indexed sender, uint amount);\n', '    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\n', '\n', '    /**\n', '     * @dev Receive tokens and generate a log event\n', '     * @param from Address from which to transfer tokens\n', '     * @param value Amount of tokens to transfer\n', '     * @param token Address of token\n', '     * @param extraData Additional data to log\n', '     */\n', '    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\n', '        ERC20 t = ERC20(token);\n', '        require(t.transferFrom(from, this, value));\n', '        ReceivedTokens(from, value, token, extraData);\n', '    }\n', '\n', '    /**\n', '     * @dev Receive Ether and generate a log event\n', '     */\n', '    function () payable public {\n', '        ReceivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', 'contract DelegateProxy is TokenRecipient, Ownable {\n', '\n', '    /**\n', '     * Execute a DELEGATECALL from the proxy contract\n', '     *\n', '     * @dev Owner only\n', '     * @param dest Address to which the call will be sent\n', '     * @param calldata Calldata to send\n', '     * @return Result of the delegatecall (success or failure)\n', '     */\n', '    function delegateProxy(address dest, bytes calldata)\n', '        public\n', '        onlyOwner\n', '        returns (bool result)\n', '    {\n', '        return dest.delegatecall(calldata);\n', '    }\n', '\n', '    /**\n', '     * Execute a DELEGATECALL and assert success\n', '     *\n', '     * @dev Same functionality as `delegateProxy`, just asserts the return value\n', '     * @param dest Address to which the call will be sent\n', '     * @param calldata Calldata to send\n', '     */\n', '    function delegateProxyAssert(address dest, bytes calldata)\n', '        public\n', '    {\n', '        require(delegateProxy(dest, calldata));\n', '    }\n', '\n', '}\n', '\n', 'contract WyvernDAOProxy is DelegateProxy {\n', '\n', '    function WyvernDAOProxy ()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract TokenRecipient {\n', '    event ReceivedEther(address indexed sender, uint amount);\n', '    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\n', '\n', '    /**\n', '     * @dev Receive tokens and generate a log event\n', '     * @param from Address from which to transfer tokens\n', '     * @param value Amount of tokens to transfer\n', '     * @param token Address of token\n', '     * @param extraData Additional data to log\n', '     */\n', '    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\n', '        ERC20 t = ERC20(token);\n', '        require(t.transferFrom(from, this, value));\n', '        ReceivedTokens(from, value, token, extraData);\n', '    }\n', '\n', '    /**\n', '     * @dev Receive Ether and generate a log event\n', '     */\n', '    function () payable public {\n', '        ReceivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', 'contract DelegateProxy is TokenRecipient, Ownable {\n', '\n', '    /**\n', '     * Execute a DELEGATECALL from the proxy contract\n', '     *\n', '     * @dev Owner only\n', '     * @param dest Address to which the call will be sent\n', '     * @param calldata Calldata to send\n', '     * @return Result of the delegatecall (success or failure)\n', '     */\n', '    function delegateProxy(address dest, bytes calldata)\n', '        public\n', '        onlyOwner\n', '        returns (bool result)\n', '    {\n', '        return dest.delegatecall(calldata);\n', '    }\n', '\n', '    /**\n', '     * Execute a DELEGATECALL and assert success\n', '     *\n', '     * @dev Same functionality as `delegateProxy`, just asserts the return value\n', '     * @param dest Address to which the call will be sent\n', '     * @param calldata Calldata to send\n', '     */\n', '    function delegateProxyAssert(address dest, bytes calldata)\n', '        public\n', '    {\n', '        require(delegateProxy(dest, calldata));\n', '    }\n', '\n', '}\n', '\n', 'contract WyvernDAOProxy is DelegateProxy {\n', '\n', '    function WyvernDAOProxy ()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '}']
