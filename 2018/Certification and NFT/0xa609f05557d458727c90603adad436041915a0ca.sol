['pragma solidity ^0.4.23;\n', '\n', 'interface StorageInterface {\n', '  function getTarget(bytes32 exec_id, bytes4 selector)\n', '      external view returns (address implementation);\n', '  function getIndex(bytes32 exec_id) external view returns (address index);\n', '  function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\n', '      external payable returns (bytes32 instance_exec_id, bytes32 version);\n', '  function createRegistry(address index, address implementation) external returns (bytes32 exec_id);\n', '  function exec(address sender, bytes32 exec_id, bytes calldata)\n', '      external payable returns (uint emitted, uint paid, uint stored);\n', '}\n', '\n', 'interface RegistryInterface {\n', '  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n', '      external view returns (bytes32 latest_name);\n', '  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n', '      external view returns (address index, bytes4[] selectors, address[] implementations);\n', '}\n', '\n', 'contract ScriptExec {\n', '\n', '  /// DEFAULT VALUES ///\n', '\n', '  address public app_storage;\n', '  address public provider;\n', '  bytes32 public registry_exec_id;\n', '  address public exec_admin;\n', '\n', '  /// APPLICATION INSTANCE METADATA ///\n', '\n', '  struct Instance {\n', '    address current_provider;\n', '    bytes32 current_registry_exec_id;\n', '    bytes32 app_exec_id;\n', '    bytes32 app_name;\n', '    bytes32 version_name;\n', '  }\n', '\n', '  // Maps the execution ids of deployed instances to the address that deployed them -\n', '  mapping (bytes32 => address) public deployed_by;\n', '  // Maps the execution ids of deployed instances to a struct containing their metadata -\n', '  mapping (bytes32 => Instance) public instance_info;\n', '  // Maps an address that deployed app instances to metadata about the deployed instance -\n', '  mapping (address => Instance[]) public deployed_instances;\n', '  // Maps an application name to the exec ids under which it is deployed -\n', '  mapping (bytes32 => bytes32[]) public app_instances;\n', '\n', '  /// EVENTS ///\n', '\n', '  event AppInstanceCreated(address indexed creator, bytes32 indexed execution_id, bytes32 app_name, bytes32 version_name);\n', '  event StorageException(bytes32 indexed execution_id, string message);\n', '\n', '  // Modifier - The sender must be the contract administrator\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == exec_admin);\n', '    _;\n', '  }\n', '\n', '  // Payable function - for abstract storage refunds\n', '  function () public payable { }\n', '\n', '  /*\n', '  Configure various defaults for a script exec contract\n', '  @param _exec_admin: A privileged address, able to set the target provider and registry exec id\n', '  @param _app_storage: The address to which applications will be stored\n', '  @param _provider: The address under which applications have been initialized\n', '  */\n', '  function configure(address _exec_admin, address _app_storage, address _provider) public {\n', '    require(app_storage == 0, "ScriptExec already configured");\n', '    require(_app_storage != 0, &#39;Invalid input&#39;);\n', '    exec_admin = _exec_admin;\n', '    app_storage = _app_storage;\n', '    provider = _provider;\n', '\n', '    if (exec_admin == 0)\n', '      exec_admin = msg.sender;\n', '  }\n', '\n', '  /// APPLICATION EXECUTION ///\n', '\n', '  bytes4 internal constant EXEC_SEL = bytes4(keccak256(&#39;exec(address,bytes32,bytes)&#39;));\n', '\n', '  /*\n', '  Executes an application using its execution id and storage address.\n', '\n', '  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\n', '  @param _calldata: The calldata to forward to the application\n', '  @return success: Whether execution succeeded or not\n', '  */\n', '  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success);\n', '\n', '  bytes4 internal constant ERR = bytes4(keccak256(&#39;Error(string)&#39;));\n', '\n', '  // Return the bytes4 action requestor stored at the pointer, and cleans the remaining bytes\n', '  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n', '    assembly {\n', '      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n', '      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n', '    }\n', '  }\n', '\n', '  // Checks to see if an error message was returned with the failed call, and emits it if so -\n', '  function checkErrors(bytes32 _exec_id) internal {\n', '    // If the returned data begins with selector &#39;Error(string)&#39;, get the contained message -\n', '    string memory message;\n', '    bytes4 err_sel = ERR;\n', '    assembly {\n', '      // Get pointer to free memory, place returned data at pointer, and update free memory pointer\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, returndatasize)\n', '      mstore(0x40, add(ptr, returndatasize))\n', '\n', '      // Check value at pointer for equality with Error selector -\n', '      if eq(mload(ptr), and(err_sel, 0xffffffff00000000000000000000000000000000000000000000000000000000)) {\n', '        message := add(0x24, ptr)\n', '      }\n', '    }\n', '    // If no returned message exists, emit a default error message. Otherwise, emit the error message\n', '    if (bytes(message).length == 0)\n', '      emit StorageException(_exec_id, "No error recieved");\n', '    else\n', '      emit StorageException(_exec_id, message);\n', '  }\n', '\n', '  // Checks data returned by an application and returns whether or not the execution changed state\n', '  function checkReturn() internal pure returns (bool success) {\n', '    success = false;\n', '    assembly {\n', '      // returndata size must be 0x60 bytes\n', '      if eq(returndatasize, 0x60) {\n', '        // Copy returned data to pointer and check that at least one value is nonzero\n', '        let ptr := mload(0x40)\n', '        returndatacopy(ptr, 0, returndatasize)\n', '        if iszero(iszero(mload(ptr))) { success := 1 }\n', '        if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\n', '        if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\n', '      }\n', '    }\n', '    return success;\n', '  }\n', '\n', '  /// APPLICATION INITIALIZATION ///\n', '\n', '  /*\n', '  Initializes an instance of an application. Uses default app provider and registry app.\n', '  Uses latest app version by default.\n', '  @param _app_name: The name of the application to initialize\n', '  @param _init_calldata: Calldata to be forwarded to the application&#39;s initialization function\n', '  @return exec_id: The execution id (within the application&#39;s storage) of the created application instance\n', '  @return version: The name of the version of the instance\n', '  */\n', '  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n', '    require(_app_name != 0 && _init_calldata.length >= 4, &#39;invalid input&#39;);\n', '    (exec_id, version) = StorageInterface(app_storage).createInstance(\n', '      msg.sender, _app_name, provider, registry_exec_id, _init_calldata\n', '    );\n', '    // Set various app metadata values -\n', '    deployed_by[exec_id] = msg.sender;\n', '    app_instances[_app_name].push(exec_id);\n', '    Instance memory inst = Instance(\n', '      provider, registry_exec_id, exec_id, _app_name, version\n', '    );\n', '    instance_info[exec_id] = inst;\n', '    deployed_instances[msg.sender].push(inst);\n', '    // Emit event -\n', '    emit AppInstanceCreated(msg.sender, exec_id, _app_name, version);\n', '  }\n', '\n', '  /// ADMIN FUNCTIONS ///\n', '\n', '  /*\n', '  Allows the exec admin to set the registry exec id from which applications will be initialized -\n', '  @param _exec_id: The new exec id from which applications will be initialized\n', '  */\n', '  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\n', '    registry_exec_id = _exec_id;\n', '  }\n', '\n', '  /*\n', '  Allows the exec admin to set the provider from which applications will be initialized in the given registry exec id\n', '  @param _provider: The address under which applications to initialize are registered\n', '  */\n', '  function setProvider(address _provider) public onlyAdmin() {\n', '    provider = _provider;\n', '  }\n', '\n', '  // Allows the admin to set a new admin address\n', '  function setAdmin(address _admin) public onlyAdmin() {\n', '    require(_admin != 0);\n', '    exec_admin = _admin;\n', '  }\n', '\n', '  /// STORAGE GETTERS ///\n', '\n', '  // Returns a list of execution ids under which the given app name was deployed\n', '  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n', '    return app_instances[_app_name];\n', '  }\n', '\n', '  /*\n', '  Returns the number of instances an address has created\n', '  @param _deployer: The address that deployed the instances\n', '  @return uint: The number of instances deployed by the deployer\n', '  */\n', '  function getDeployedLength(address _deployer) public view returns (uint) {\n', '    return deployed_instances[_deployer].length;\n', '  }\n', '\n', '  // The function selector for a simple registry &#39;registerApp&#39; function\n', '  bytes4 internal constant REGISTER_APP_SEL = bytes4(keccak256(&#39;registerApp(bytes32,address,bytes4[],address[])&#39;));\n', '\n', '  /*\n', '  Returns the index address and implementing address for the simple registry app set as the default\n', '  @return indx: The index address for the registry application - contains getters for the Registry, as well as its init funciton\n', '  @return implementation: The address implementing the registry&#39;s functions\n', '  */\n', '  function getRegistryImplementation() public view returns (address index, address implementation) {\n', '    index = StorageInterface(app_storage).getIndex(registry_exec_id);\n', '    implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);\n', '  }\n', '\n', '  /*\n', '  Returns the functions and addresses implementing those functions that make up an application under the give execution id\n', '  @param _exec_id: The execution id that represents the application in storage\n', '  @return index: The index address of the instance - holds the app&#39;s getter functions and init functions\n', '  @return functions: A list of function selectors supported by the application\n', '  @return implementations: A list of addresses corresponding to the function selectors, where those selectors are implemented\n', '  */\n', '  function getInstanceImplementation(bytes32 _exec_id) public view\n', '  returns (address index, bytes4[] memory functions, address[] memory implementations) {\n', '    Instance memory app = instance_info[_exec_id];\n', '    index = StorageInterface(app_storage).getIndex(app.current_registry_exec_id);\n', '    (index, functions, implementations) = RegistryInterface(index).getVersionImplementation(\n', '      app_storage, app.current_registry_exec_id, app.current_provider, app.app_name, app.version_name\n', '    );\n', '  }\n', '}\n', '\n', 'contract RegistryExec is ScriptExec {\n', '\n', '  struct Registry {\n', '    address index;\n', '    address implementation;\n', '  }\n', '\n', '  // Maps execution ids to its registry app metadata\n', '  mapping (bytes32 => Registry) public registry_instance_info;\n', '  // Maps address to list of deployed Registry instances\n', '  mapping (address => Registry[]) public deployed_registry_instances;\n', '\n', '  /// EVENTS ///\n', '\n', '  event RegistryInstanceCreated(address indexed creator, bytes32 indexed execution_id, address index, address implementation);\n', '\n', '  /// APPLICATION EXECUTION ///\n', '\n', '  bytes4 internal constant EXEC_SEL = bytes4(keccak256(&#39;exec(address,bytes32,bytes)&#39;));\n', '\n', '  /*\n', '  Executes an application using its execution id and storage address.\n', '\n', '  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\n', '  @param _calldata: The calldata to forward to the application\n', '  @return success: Whether execution succeeded or not\n', '  */\n', '  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n', '    // Get function selector from calldata -\n', '    bytes4 sel = getSelector(_calldata);\n', '    // Ensure no registry functions are being called -\n', '    require(\n', '      sel != this.registerApp.selector &&\n', '      sel != this.registerAppVersion.selector &&\n', '      sel != UPDATE_INST_SEL &&\n', '      sel != UPDATE_EXEC_SEL\n', '    );\n', '\n', '    // Call &#39;exec&#39; in AbstractStorage, passing in the sender&#39;s address, the app exec id, and the calldata to forward -\n', '    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n', '      EXEC_SEL, msg.sender, _exec_id, _calldata\n', '    )) == false) {\n', '      // Call failed - emit error message from storage and return &#39;false&#39;\n', '      checkErrors(_exec_id);\n', '      // Return unspent wei to sender\n', '      address(msg.sender).transfer(address(this).balance);\n', '      return false;\n', '    }\n', '\n', '    // Get returned data\n', '    success = checkReturn();\n', '    // If execution failed,\n', '    require(success, &#39;Execution failed&#39;);\n', '\n', '    // Transfer any returned wei back to the sender\n', '    address(msg.sender).transfer(address(this).balance);\n', '  }\n', '\n', '  // Returns the first 4 bytes of calldata\n', '  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n', '    assembly {\n', '      selector := and(\n', '        mload(add(0x20, _calldata)),\n', '        0xffffffff00000000000000000000000000000000000000000000000000000000\n', '      )\n', '    }\n', '  }\n', '\n', '  /// REGISTRY FUNCTIONS ///\n', '\n', '  /*\n', '  Creates an instance of a registry application and returns its execution id\n', '  @param _index: The index file of the registry app (holds getters and init functions)\n', '  @param _implementation: The file implementing the registry&#39;s functionality\n', '  @return exec_id: The execution id under which the registry will store data\n', '  */\n', '  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n', '    // Validate input -\n', '    require(_index != 0 && _implementation != 0, &#39;Invalid input&#39;);\n', '\n', '    // Creates a registry from storage and returns the registry exec id -\n', '    exec_id = StorageInterface(app_storage).createRegistry(_index, _implementation);\n', '\n', '    // Ensure a valid execution id returned from storage -\n', '    require(exec_id != 0, &#39;Invalid response from storage&#39;);\n', '\n', '    // If there is not already a default registry exec id set, set it\n', '    if (registry_exec_id == 0)\n', '      registry_exec_id = exec_id;\n', '\n', '    // Create Registry struct in memory -\n', '    Registry memory reg = Registry(_index, _implementation);\n', '\n', '    // Set various app metadata values -\n', '    deployed_by[exec_id] = msg.sender;\n', '    registry_instance_info[exec_id] = reg;\n', '    deployed_registry_instances[msg.sender].push(reg);\n', '    // Emit event -\n', '    emit RegistryInstanceCreated(msg.sender, exec_id, _index, _implementation);\n', '  }\n', '\n', '  /*\n', '  Registers an application as the admin under the provider and registry exec id\n', '  @param _app_name: The name of the application to register\n', '  @param _index: The index file of the application - holds the getters and init functions\n', '  @param _selectors: The selectors of the functions which the app implements\n', '  @param _implementations: The addresses at which each function is located\n', '  */\n', '  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n', '    // Validate input\n', '    require(_app_name != 0 && _index != 0, &#39;Invalid input&#39;);\n', '    require(_selectors.length == _implementations.length && _selectors.length != 0, &#39;Invalid input&#39;);\n', '    // Check contract variables for valid initialization\n', '    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, &#39;Invalid state&#39;);\n', '\n', '    // Execute registerApp through AbstractStorage -\n', '    uint emitted;\n', '    uint paid;\n', '    uint stored;\n', '    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n', '\n', '    // Ensure zero values for emitted and paid, and nonzero value for stored -\n', '    require(emitted == 0 && paid == 0 && stored != 0, &#39;Invalid state change&#39;);\n', '  }\n', '\n', '  /*\n', '  Registers a version of an application as the admin under the provider and registry exec id\n', '  @param _app_name: The name of the application under which the version will be registered\n', '  @param _version_name: The name of the version to register\n', '  @param _index: The index file of the application - holds the getters and init functions\n', '  @param _selectors: The selectors of the functions which the app implements\n', '  @param _implementations: The addresses at which each function is located\n', '  */\n', '  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n', '    // Validate input\n', '    require(_app_name != 0 && _version_name != 0 && _index != 0, &#39;Invalid input&#39;);\n', '    require(_selectors.length == _implementations.length && _selectors.length != 0, &#39;Invalid input&#39;);\n', '    // Check contract variables for valid initialization\n', '    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, &#39;Invalid state&#39;);\n', '\n', '    // Execute registerApp through AbstractStorage -\n', '    uint emitted;\n', '    uint paid;\n', '    uint stored;\n', '    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n', '\n', '    // Ensure zero values for emitted and paid, and nonzero value for stored -\n', '    require(emitted == 0 && paid == 0 && stored != 0, &#39;Invalid state change&#39;);\n', '  }\n', '\n', '  // Update instance selectors, index, and addresses\n', '  bytes4 internal constant UPDATE_INST_SEL = bytes4(keccak256(&#39;updateInstance(bytes32,bytes32,bytes32)&#39;));\n', '\n', '  /*\n', '  Updates an application&#39;s implementations, selectors, and index address. Uses default app provider and registry app.\n', '  Uses latest app version by default.\n', '\n', '  @param _exec_id: The execution id of the application instance to be updated\n', '  @return success: The success of the call to the application&#39;s updateInstance function\n', '  */\n', '  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n', '    // Validate input. Only the original deployer can update an application -\n', '    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], &#39;invalid sender or input&#39;);\n', '\n', '    // Get instance metadata from exec id -\n', '    Instance memory inst = instance_info[_exec_id];\n', '\n', '    // Call &#39;exec&#39; in AbstractStorage, passing in the sender&#39;s address, the execution id, and\n', '    // the calldata to update the application -\n', '    if(address(app_storage).call(\n', '      abi.encodeWithSelector(EXEC_SEL,            // &#39;exec&#39; selector\n', '        inst.current_provider,                    // application provider address\n', '        _exec_id,                                 // execution id to update\n', '        abi.encodeWithSelector(UPDATE_INST_SEL,   // calldata for Registry updateInstance function\n', '          inst.app_name,                          // name of the applcation used by the instance\n', '          inst.version_name,                      // name of the current version of the application\n', '          inst.current_registry_exec_id           // registry exec id when the instance was instantiated\n', '        )\n', '      )\n', '    ) == false) {\n', '      // Call failed - emit error message from storage and return &#39;false&#39;\n', '      checkErrors(_exec_id);\n', '      return false;\n', '    }\n', '    // Check returned data to ensure state was correctly changed in AbstractStorage -\n', '    success = checkReturn();\n', '    // If execution failed, revert state and return an error message -\n', '    require(success, &#39;Execution failed&#39;);\n', '\n', '    // If execution was successful, the version was updated. Get the latest version\n', '    // and set the exec id instance info -\n', '    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\n', '    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(\n', '      app_storage,\n', '      inst.current_registry_exec_id,\n', '      inst.current_provider,\n', '      inst.app_name\n', '    );\n', '    // Ensure nonzero latest version -\n', '    require(latest_version != 0, &#39;invalid latest version&#39;);\n', '    // Set current version -\n', '    instance_info[_exec_id].version_name = latest_version;\n', '  }\n', '\n', '  // Update instance script exec contract\n', '  bytes4 internal constant UPDATE_EXEC_SEL = bytes4(keccak256(&#39;updateExec(address)&#39;));\n', '\n', '  /*\n', '  Updates an application&#39;s script executor from this Script Exec to a new address\n', '\n', '  @param _exec_id: The execution id of the application instance to be updated\n', '  @param _new_exec_addr: The new script exec address for this exec id\n', '  @returns success: The success of the call to the application&#39;s updateExec function\n', '  */\n', '  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n', '    // Validate input. Only the original deployer can migrate the script exec address -\n', '    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id] && address(this) != _new_exec_addr && _new_exec_addr != 0, &#39;invalid input&#39;);\n', '\n', '    // Call &#39;exec&#39; in AbstractStorage, passing in the sender&#39;s address, the execution id, and\n', '    // the calldata to migrate the script exec address -\n', '    if(address(app_storage).call(\n', '      abi.encodeWithSelector(EXEC_SEL,                            // &#39;exec&#39; selector\n', '        msg.sender,                                               // sender address\n', '        _exec_id,                                                 // execution id to update\n', '        abi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)   // calldata for Registry updateExec\n', '      )\n', '    ) == false) {\n', '      // Call failed - emit error message from storage and return &#39;false&#39;\n', '      checkErrors(_exec_id);\n', '      return false;\n', '    }\n', '    // Check returned data to ensure state was correctly changed in AbstractStorage -\n', '    success = checkReturn();\n', '    // If execution failed, revert state and return an error message -\n', '    require(success, &#39;Execution failed&#39;);\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'interface StorageInterface {\n', '  function getTarget(bytes32 exec_id, bytes4 selector)\n', '      external view returns (address implementation);\n', '  function getIndex(bytes32 exec_id) external view returns (address index);\n', '  function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\n', '      external payable returns (bytes32 instance_exec_id, bytes32 version);\n', '  function createRegistry(address index, address implementation) external returns (bytes32 exec_id);\n', '  function exec(address sender, bytes32 exec_id, bytes calldata)\n', '      external payable returns (uint emitted, uint paid, uint stored);\n', '}\n', '\n', 'interface RegistryInterface {\n', '  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n', '      external view returns (bytes32 latest_name);\n', '  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n', '      external view returns (address index, bytes4[] selectors, address[] implementations);\n', '}\n', '\n', 'contract ScriptExec {\n', '\n', '  /// DEFAULT VALUES ///\n', '\n', '  address public app_storage;\n', '  address public provider;\n', '  bytes32 public registry_exec_id;\n', '  address public exec_admin;\n', '\n', '  /// APPLICATION INSTANCE METADATA ///\n', '\n', '  struct Instance {\n', '    address current_provider;\n', '    bytes32 current_registry_exec_id;\n', '    bytes32 app_exec_id;\n', '    bytes32 app_name;\n', '    bytes32 version_name;\n', '  }\n', '\n', '  // Maps the execution ids of deployed instances to the address that deployed them -\n', '  mapping (bytes32 => address) public deployed_by;\n', '  // Maps the execution ids of deployed instances to a struct containing their metadata -\n', '  mapping (bytes32 => Instance) public instance_info;\n', '  // Maps an address that deployed app instances to metadata about the deployed instance -\n', '  mapping (address => Instance[]) public deployed_instances;\n', '  // Maps an application name to the exec ids under which it is deployed -\n', '  mapping (bytes32 => bytes32[]) public app_instances;\n', '\n', '  /// EVENTS ///\n', '\n', '  event AppInstanceCreated(address indexed creator, bytes32 indexed execution_id, bytes32 app_name, bytes32 version_name);\n', '  event StorageException(bytes32 indexed execution_id, string message);\n', '\n', '  // Modifier - The sender must be the contract administrator\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == exec_admin);\n', '    _;\n', '  }\n', '\n', '  // Payable function - for abstract storage refunds\n', '  function () public payable { }\n', '\n', '  /*\n', '  Configure various defaults for a script exec contract\n', '  @param _exec_admin: A privileged address, able to set the target provider and registry exec id\n', '  @param _app_storage: The address to which applications will be stored\n', '  @param _provider: The address under which applications have been initialized\n', '  */\n', '  function configure(address _exec_admin, address _app_storage, address _provider) public {\n', '    require(app_storage == 0, "ScriptExec already configured");\n', "    require(_app_storage != 0, 'Invalid input');\n", '    exec_admin = _exec_admin;\n', '    app_storage = _app_storage;\n', '    provider = _provider;\n', '\n', '    if (exec_admin == 0)\n', '      exec_admin = msg.sender;\n', '  }\n', '\n', '  /// APPLICATION EXECUTION ///\n', '\n', "  bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\n", '\n', '  /*\n', '  Executes an application using its execution id and storage address.\n', '\n', '  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\n', '  @param _calldata: The calldata to forward to the application\n', '  @return success: Whether execution succeeded or not\n', '  */\n', '  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success);\n', '\n', "  bytes4 internal constant ERR = bytes4(keccak256('Error(string)'));\n", '\n', '  // Return the bytes4 action requestor stored at the pointer, and cleans the remaining bytes\n', '  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n', '    assembly {\n', '      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n', '      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n', '    }\n', '  }\n', '\n', '  // Checks to see if an error message was returned with the failed call, and emits it if so -\n', '  function checkErrors(bytes32 _exec_id) internal {\n', "    // If the returned data begins with selector 'Error(string)', get the contained message -\n", '    string memory message;\n', '    bytes4 err_sel = ERR;\n', '    assembly {\n', '      // Get pointer to free memory, place returned data at pointer, and update free memory pointer\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, returndatasize)\n', '      mstore(0x40, add(ptr, returndatasize))\n', '\n', '      // Check value at pointer for equality with Error selector -\n', '      if eq(mload(ptr), and(err_sel, 0xffffffff00000000000000000000000000000000000000000000000000000000)) {\n', '        message := add(0x24, ptr)\n', '      }\n', '    }\n', '    // If no returned message exists, emit a default error message. Otherwise, emit the error message\n', '    if (bytes(message).length == 0)\n', '      emit StorageException(_exec_id, "No error recieved");\n', '    else\n', '      emit StorageException(_exec_id, message);\n', '  }\n', '\n', '  // Checks data returned by an application and returns whether or not the execution changed state\n', '  function checkReturn() internal pure returns (bool success) {\n', '    success = false;\n', '    assembly {\n', '      // returndata size must be 0x60 bytes\n', '      if eq(returndatasize, 0x60) {\n', '        // Copy returned data to pointer and check that at least one value is nonzero\n', '        let ptr := mload(0x40)\n', '        returndatacopy(ptr, 0, returndatasize)\n', '        if iszero(iszero(mload(ptr))) { success := 1 }\n', '        if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\n', '        if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\n', '      }\n', '    }\n', '    return success;\n', '  }\n', '\n', '  /// APPLICATION INITIALIZATION ///\n', '\n', '  /*\n', '  Initializes an instance of an application. Uses default app provider and registry app.\n', '  Uses latest app version by default.\n', '  @param _app_name: The name of the application to initialize\n', "  @param _init_calldata: Calldata to be forwarded to the application's initialization function\n", "  @return exec_id: The execution id (within the application's storage) of the created application instance\n", '  @return version: The name of the version of the instance\n', '  */\n', '  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n', "    require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\n", '    (exec_id, version) = StorageInterface(app_storage).createInstance(\n', '      msg.sender, _app_name, provider, registry_exec_id, _init_calldata\n', '    );\n', '    // Set various app metadata values -\n', '    deployed_by[exec_id] = msg.sender;\n', '    app_instances[_app_name].push(exec_id);\n', '    Instance memory inst = Instance(\n', '      provider, registry_exec_id, exec_id, _app_name, version\n', '    );\n', '    instance_info[exec_id] = inst;\n', '    deployed_instances[msg.sender].push(inst);\n', '    // Emit event -\n', '    emit AppInstanceCreated(msg.sender, exec_id, _app_name, version);\n', '  }\n', '\n', '  /// ADMIN FUNCTIONS ///\n', '\n', '  /*\n', '  Allows the exec admin to set the registry exec id from which applications will be initialized -\n', '  @param _exec_id: The new exec id from which applications will be initialized\n', '  */\n', '  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\n', '    registry_exec_id = _exec_id;\n', '  }\n', '\n', '  /*\n', '  Allows the exec admin to set the provider from which applications will be initialized in the given registry exec id\n', '  @param _provider: The address under which applications to initialize are registered\n', '  */\n', '  function setProvider(address _provider) public onlyAdmin() {\n', '    provider = _provider;\n', '  }\n', '\n', '  // Allows the admin to set a new admin address\n', '  function setAdmin(address _admin) public onlyAdmin() {\n', '    require(_admin != 0);\n', '    exec_admin = _admin;\n', '  }\n', '\n', '  /// STORAGE GETTERS ///\n', '\n', '  // Returns a list of execution ids under which the given app name was deployed\n', '  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n', '    return app_instances[_app_name];\n', '  }\n', '\n', '  /*\n', '  Returns the number of instances an address has created\n', '  @param _deployer: The address that deployed the instances\n', '  @return uint: The number of instances deployed by the deployer\n', '  */\n', '  function getDeployedLength(address _deployer) public view returns (uint) {\n', '    return deployed_instances[_deployer].length;\n', '  }\n', '\n', "  // The function selector for a simple registry 'registerApp' function\n", "  bytes4 internal constant REGISTER_APP_SEL = bytes4(keccak256('registerApp(bytes32,address,bytes4[],address[])'));\n", '\n', '  /*\n', '  Returns the index address and implementing address for the simple registry app set as the default\n', '  @return indx: The index address for the registry application - contains getters for the Registry, as well as its init funciton\n', "  @return implementation: The address implementing the registry's functions\n", '  */\n', '  function getRegistryImplementation() public view returns (address index, address implementation) {\n', '    index = StorageInterface(app_storage).getIndex(registry_exec_id);\n', '    implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);\n', '  }\n', '\n', '  /*\n', '  Returns the functions and addresses implementing those functions that make up an application under the give execution id\n', '  @param _exec_id: The execution id that represents the application in storage\n', "  @return index: The index address of the instance - holds the app's getter functions and init functions\n", '  @return functions: A list of function selectors supported by the application\n', '  @return implementations: A list of addresses corresponding to the function selectors, where those selectors are implemented\n', '  */\n', '  function getInstanceImplementation(bytes32 _exec_id) public view\n', '  returns (address index, bytes4[] memory functions, address[] memory implementations) {\n', '    Instance memory app = instance_info[_exec_id];\n', '    index = StorageInterface(app_storage).getIndex(app.current_registry_exec_id);\n', '    (index, functions, implementations) = RegistryInterface(index).getVersionImplementation(\n', '      app_storage, app.current_registry_exec_id, app.current_provider, app.app_name, app.version_name\n', '    );\n', '  }\n', '}\n', '\n', 'contract RegistryExec is ScriptExec {\n', '\n', '  struct Registry {\n', '    address index;\n', '    address implementation;\n', '  }\n', '\n', '  // Maps execution ids to its registry app metadata\n', '  mapping (bytes32 => Registry) public registry_instance_info;\n', '  // Maps address to list of deployed Registry instances\n', '  mapping (address => Registry[]) public deployed_registry_instances;\n', '\n', '  /// EVENTS ///\n', '\n', '  event RegistryInstanceCreated(address indexed creator, bytes32 indexed execution_id, address index, address implementation);\n', '\n', '  /// APPLICATION EXECUTION ///\n', '\n', "  bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\n", '\n', '  /*\n', '  Executes an application using its execution id and storage address.\n', '\n', '  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\n', '  @param _calldata: The calldata to forward to the application\n', '  @return success: Whether execution succeeded or not\n', '  */\n', '  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n', '    // Get function selector from calldata -\n', '    bytes4 sel = getSelector(_calldata);\n', '    // Ensure no registry functions are being called -\n', '    require(\n', '      sel != this.registerApp.selector &&\n', '      sel != this.registerAppVersion.selector &&\n', '      sel != UPDATE_INST_SEL &&\n', '      sel != UPDATE_EXEC_SEL\n', '    );\n', '\n', "    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -\n", '    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n', '      EXEC_SEL, msg.sender, _exec_id, _calldata\n', '    )) == false) {\n', "      // Call failed - emit error message from storage and return 'false'\n", '      checkErrors(_exec_id);\n', '      // Return unspent wei to sender\n', '      address(msg.sender).transfer(address(this).balance);\n', '      return false;\n', '    }\n', '\n', '    // Get returned data\n', '    success = checkReturn();\n', '    // If execution failed,\n', "    require(success, 'Execution failed');\n", '\n', '    // Transfer any returned wei back to the sender\n', '    address(msg.sender).transfer(address(this).balance);\n', '  }\n', '\n', '  // Returns the first 4 bytes of calldata\n', '  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n', '    assembly {\n', '      selector := and(\n', '        mload(add(0x20, _calldata)),\n', '        0xffffffff00000000000000000000000000000000000000000000000000000000\n', '      )\n', '    }\n', '  }\n', '\n', '  /// REGISTRY FUNCTIONS ///\n', '\n', '  /*\n', '  Creates an instance of a registry application and returns its execution id\n', '  @param _index: The index file of the registry app (holds getters and init functions)\n', "  @param _implementation: The file implementing the registry's functionality\n", '  @return exec_id: The execution id under which the registry will store data\n', '  */\n', '  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n', '    // Validate input -\n', "    require(_index != 0 && _implementation != 0, 'Invalid input');\n", '\n', '    // Creates a registry from storage and returns the registry exec id -\n', '    exec_id = StorageInterface(app_storage).createRegistry(_index, _implementation);\n', '\n', '    // Ensure a valid execution id returned from storage -\n', "    require(exec_id != 0, 'Invalid response from storage');\n", '\n', '    // If there is not already a default registry exec id set, set it\n', '    if (registry_exec_id == 0)\n', '      registry_exec_id = exec_id;\n', '\n', '    // Create Registry struct in memory -\n', '    Registry memory reg = Registry(_index, _implementation);\n', '\n', '    // Set various app metadata values -\n', '    deployed_by[exec_id] = msg.sender;\n', '    registry_instance_info[exec_id] = reg;\n', '    deployed_registry_instances[msg.sender].push(reg);\n', '    // Emit event -\n', '    emit RegistryInstanceCreated(msg.sender, exec_id, _index, _implementation);\n', '  }\n', '\n', '  /*\n', '  Registers an application as the admin under the provider and registry exec id\n', '  @param _app_name: The name of the application to register\n', '  @param _index: The index file of the application - holds the getters and init functions\n', '  @param _selectors: The selectors of the functions which the app implements\n', '  @param _implementations: The addresses at which each function is located\n', '  */\n', '  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n', '    // Validate input\n', "    require(_app_name != 0 && _index != 0, 'Invalid input');\n", "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n", '    // Check contract variables for valid initialization\n', "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n", '\n', '    // Execute registerApp through AbstractStorage -\n', '    uint emitted;\n', '    uint paid;\n', '    uint stored;\n', '    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n', '\n', '    // Ensure zero values for emitted and paid, and nonzero value for stored -\n', "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n", '  }\n', '\n', '  /*\n', '  Registers a version of an application as the admin under the provider and registry exec id\n', '  @param _app_name: The name of the application under which the version will be registered\n', '  @param _version_name: The name of the version to register\n', '  @param _index: The index file of the application - holds the getters and init functions\n', '  @param _selectors: The selectors of the functions which the app implements\n', '  @param _implementations: The addresses at which each function is located\n', '  */\n', '  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n', '    // Validate input\n', "    require(_app_name != 0 && _version_name != 0 && _index != 0, 'Invalid input');\n", "    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n", '    // Check contract variables for valid initialization\n', "    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n", '\n', '    // Execute registerApp through AbstractStorage -\n', '    uint emitted;\n', '    uint paid;\n', '    uint stored;\n', '    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n', '\n', '    // Ensure zero values for emitted and paid, and nonzero value for stored -\n', "    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n", '  }\n', '\n', '  // Update instance selectors, index, and addresses\n', "  bytes4 internal constant UPDATE_INST_SEL = bytes4(keccak256('updateInstance(bytes32,bytes32,bytes32)'));\n", '\n', '  /*\n', "  Updates an application's implementations, selectors, and index address. Uses default app provider and registry app.\n", '  Uses latest app version by default.\n', '\n', '  @param _exec_id: The execution id of the application instance to be updated\n', "  @return success: The success of the call to the application's updateInstance function\n", '  */\n', '  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n', '    // Validate input. Only the original deployer can update an application -\n', "    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n", '\n', '    // Get instance metadata from exec id -\n', '    Instance memory inst = instance_info[_exec_id];\n', '\n', "    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\n", '    // the calldata to update the application -\n', '    if(address(app_storage).call(\n', "      abi.encodeWithSelector(EXEC_SEL,            // 'exec' selector\n", '        inst.current_provider,                    // application provider address\n', '        _exec_id,                                 // execution id to update\n', '        abi.encodeWithSelector(UPDATE_INST_SEL,   // calldata for Registry updateInstance function\n', '          inst.app_name,                          // name of the applcation used by the instance\n', '          inst.version_name,                      // name of the current version of the application\n', '          inst.current_registry_exec_id           // registry exec id when the instance was instantiated\n', '        )\n', '      )\n', '    ) == false) {\n', "      // Call failed - emit error message from storage and return 'false'\n", '      checkErrors(_exec_id);\n', '      return false;\n', '    }\n', '    // Check returned data to ensure state was correctly changed in AbstractStorage -\n', '    success = checkReturn();\n', '    // If execution failed, revert state and return an error message -\n', "    require(success, 'Execution failed');\n", '\n', '    // If execution was successful, the version was updated. Get the latest version\n', '    // and set the exec id instance info -\n', '    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\n', '    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(\n', '      app_storage,\n', '      inst.current_registry_exec_id,\n', '      inst.current_provider,\n', '      inst.app_name\n', '    );\n', '    // Ensure nonzero latest version -\n', "    require(latest_version != 0, 'invalid latest version');\n", '    // Set current version -\n', '    instance_info[_exec_id].version_name = latest_version;\n', '  }\n', '\n', '  // Update instance script exec contract\n', "  bytes4 internal constant UPDATE_EXEC_SEL = bytes4(keccak256('updateExec(address)'));\n", '\n', '  /*\n', "  Updates an application's script executor from this Script Exec to a new address\n", '\n', '  @param _exec_id: The execution id of the application instance to be updated\n', '  @param _new_exec_addr: The new script exec address for this exec id\n', "  @returns success: The success of the call to the application's updateExec function\n", '  */\n', '  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n', '    // Validate input. Only the original deployer can migrate the script exec address -\n', "    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id] && address(this) != _new_exec_addr && _new_exec_addr != 0, 'invalid input');\n", '\n', "    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\n", '    // the calldata to migrate the script exec address -\n', '    if(address(app_storage).call(\n', "      abi.encodeWithSelector(EXEC_SEL,                            // 'exec' selector\n", '        msg.sender,                                               // sender address\n', '        _exec_id,                                                 // execution id to update\n', '        abi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)   // calldata for Registry updateExec\n', '      )\n', '    ) == false) {\n', "      // Call failed - emit error message from storage and return 'false'\n", '      checkErrors(_exec_id);\n', '      return false;\n', '    }\n', '    // Check returned data to ensure state was correctly changed in AbstractStorage -\n', '    success = checkReturn();\n', '    // If execution failed, revert state and return an error message -\n', "    require(success, 'Execution failed');\n", '  }\n', '}']
