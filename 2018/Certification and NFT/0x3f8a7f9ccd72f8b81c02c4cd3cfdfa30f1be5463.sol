['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract ERC20Extended is ERC20 {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract ComponentContainerInterface {\n', '    mapping (string => address) components;\n', '\n', '    event ComponentUpdated (string _name, address _componentAddress);\n', '\n', '    function setComponent(string _name, address _providerAddress) internal returns (bool success);\n', '    function getComponentByName(string name) public view returns (address);\n', '\n', '}\n', '\n', 'contract DerivativeInterface is ERC20Extended, Ownable, ComponentContainerInterface {\n', '\n', '    enum DerivativeStatus { New, Active, Paused, Closed }\n', '    enum DerivativeType { Index, Fund }\n', '\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '    DerivativeType public fundType;\n', '\n', '    address[] public tokens;\n', '    DerivativeStatus public status;\n', '\n', '    // invest, withdraw is done in transfer.\n', '    function invest() public payable returns(bool success);\n', '    function changeStatus(DerivativeStatus _status) public returns(bool);\n', '    function getPrice() public view returns(uint);\n', '\n', '    function initialize (address _componentList) internal;\n', '    function updateComponent(string _name) public returns (address);\n', '    function approveComponent(string _name) internal;\n', '}\n', '\n', 'contract ComponentContainer is ComponentContainerInterface {\n', '\n', '    function setComponent(string _name, address _componentAddress) internal returns (bool success) {\n', '        require(_componentAddress != address(0));\n', '        components[_name] = _componentAddress;\n', '        return true;\n', '    }\n', '\n', '    function getComponentByName(string _name) public view returns (address) {\n', '        return components[_name];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', 'contract ComponentListInterface {\n', '    event ComponentUpdated (string _name, string _version, address _componentAddress);\n', '    function setComponent(string _name, address _componentAddress) public returns (bool);\n', '    function getComponent(string _name, string _version) public view returns (address);\n', '    function getLatestComponent(string _name) public view returns(address);\n', '}\n', '\n', 'contract ERC20NoReturn {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public;\n', '    function approve(address spender, uint tokens) public;\n', '    function transferFrom(address from, address to, uint tokens) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract FeeChargerInterface {\n', '    // TODO: change this to mainnet MOT address before deployment.\n', '    // solhint-disable-next-line\n', '    ERC20Extended public MOT = ERC20Extended(0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD);\n', '    // kovan MOT: 0x41Dee9F481a1d2AA74a3f1d0958C1dB6107c686A\n', '    function setMotAddress(address _motAddress) external returns (bool success);\n', '}\n', '\n', '// Abstract class that implements the common functions to all our derivatives\n', 'contract Derivative is DerivativeInterface, ComponentContainer, PausableToken {\n', '\n', '    ERC20Extended internal constant ETH = ERC20Extended(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '    ComponentListInterface internal componentList;\n', '    string public constant MARKET = "MarketProvider";\n', '    string public constant EXCHANGE = "ExchangeProvider";\n', '    string public constant WITHDRAW = "WithdrawProvider";\n', '    string public constant RISK = "RiskProvider";\n', '    string public constant WHITELIST = "WhitelistProvider";\n', '    string public constant FEE = "FeeProvider";\n', '    string public constant REIMBURSABLE = "Reimbursable";\n', '    string public constant REBALANCE = "RebalanceProvider";\n', '\n', '    function initialize (address _componentList) internal {\n', '        require(_componentList != 0x0);\n', '        componentList = ComponentListInterface(_componentList);\n', '    }\n', '\n', '    function updateComponent(string _name) public onlyOwner returns (address) {\n', '        // still latest.\n', '        if (super.getComponentByName(_name) == componentList.getLatestComponent(_name)) {\n', '            return super.getComponentByName(_name);\n', '        }\n', '\n', '        // changed.\n', '        require(super.setComponent(_name, componentList.getLatestComponent(_name)));\n', '        // approve if it&#39;s not Marketplace.\n', '        if (keccak256(abi.encodePacked(_name)) != keccak256(abi.encodePacked(MARKET))) {\n', '            approveComponent(_name);\n', '        }\n', '\n', '        // return latest address.\n', '        return componentList.getLatestComponent(_name);\n', '    }\n', '\n', '\n', '\n', '    function approveComponent(string _name) internal {\n', '        address componentAddress = getComponentByName(_name);\n', '        ERC20NoReturn(FeeChargerInterface(componentAddress).MOT()).approve(componentAddress, 0);\n', '        ERC20NoReturn(FeeChargerInterface(componentAddress).MOT()).approve(componentAddress, 2 ** 256 - 1);\n', '    }\n', '\n', '    function () public payable {\n', '\n', '    }\n', '}\n', '\n', 'contract IndexInterface is DerivativeInterface {\n', '    uint[] public weights;\n', '    bool public supportRebalance;\n', '\n', '    // this should be called until it returns true.\n', '    function rebalance() public returns (bool success);\n', '    function getTokens() public view returns (address[] _tokens, uint[] _weights);\n', '}\n', '\n', 'contract ComponentInterface {\n', '    string public name;\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '}\n', '\n', 'contract ExchangeInterface is ComponentInterface {\n', '    /*\n', '     * @dev Checks if a trading pair is available\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @return boolean whether or not the trading pair is supported by this exchange provider\n', '     */\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\n', '        external view returns(bool supported);\n', '\n', '    /*\n', '     * @dev Buy a single token with ETH.\n', '     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\n', '     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\n', '     * @return boolean whether or not the trade succeeded.\n', '     */\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\n', '     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of tokens to sell.\n', '     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract PriceProviderInterface is ComponentInterface {\n', '    /*\n', '     * @dev Returns the expected price for 1 of sourceAddress.\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', '     * @param uint _amount The amount of tokens which is wanted to buy.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @return returns the expected and slippage rate for the specified conversion\n', '     */\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '}\n', '\n', 'contract OlympusExchangeInterface is ExchangeInterface, PriceProviderInterface, Ownable {\n', '    /*\n', '     * @dev Buy multiple tokens at once with ETH.\n', '     * @param ERC20Extended[] _tokens The tokens to buy, should be an array of ERC20Extended addresses.\n', '     * @param uint[] _amounts Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the sum of this array.\n', '     * @param uint[] _minimumRates The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function buyTokens\n', '        (\n', '        ERC20Extended[] _tokens, uint[] _amounts, uint[] _minimumRates,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell multiple tokens at once with ETH, make sure all of the tokens are approved to be transferred beforehand with the Olympus Exchange address.\n', '     * @param ERC20Extended[] _tokens The tokens to sell, should be an array of ERC20Extended addresses.\n', '     * @param uint[] _amounts Amount of tokens to sell this token. Make sure the value sent to this function is the same as the sum of this array.\n', '     * @param uint[] _minimumRates The minimum amount of ETH to receive for 1 specified ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', '     * @param bytes32 _exchangeId The exchangeId to choose. If it&#39;s an empty string, then the exchange will be chosen automatically.\n', '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellTokens\n', '        (\n', '        ERC20Extended[] _tokens, uint[] _amounts, uint[] _minimumRates,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract RebalanceInterface is ComponentInterface {\n', '    // this should be called until it returns true.\n', '    function recalculateTokensToBuyAfterSale(uint _receivedETHFromSale, uint[] _amountsToBuy) external pure\n', '        returns(uint[] _recalculatedAmountsToBuy);\n', '    function rebalanceGetTokensToSellAndBuy() external returns\n', '        (address[] _tokensToSell, uint[] _amountsToSell, address[] _tokensToBuy, uint[] _amountsToBuy, address[] _tokensWithPriceIssues);\n', '}\n', '\n', 'contract WithdrawInterface is ComponentInterface {\n', '\n', '    function request(address _requester, uint amount) external returns(bool);\n', '    function withdraw(address _requester) external returns(uint eth, uint tokens);\n', '    function start() external;\n', '    function isInProgress() external view returns(bool);\n', '    function unlock() external;\n', '    function getUserRequests() external view returns(address[]);\n', '    function getTotalWithdrawAmount() external view returns(uint);\n', '\n', '    event WithdrawRequest(address _requester, uint amountOfToken);\n', '    event Withdrawed(address _requester,  uint amountOfToken , uint amountOfEther);\n', '}\n', '\n', 'contract WhitelistInterface is ComponentInterface {\n', '\n', '    // sender -> category -> user -> allowed\n', '    mapping (address => mapping(uint8 => mapping(address => bool))) public whitelist;\n', '    // sender -> category -> enabled\n', '    mapping (address => mapping(uint8 => bool)) public enabled;\n', '\n', '    function enable(uint8 _key) external;\n', '    function disable(uint8 _key) external;\n', '    function isAllowed(uint8 _key, address _account) external view returns(bool);\n', '    function setAllowed(address[] accounts, uint8 _key, bool allowed) external returns(bool);\n', '}\n', '\n', 'contract MarketplaceInterface is Ownable {\n', '\n', '    address[] public products;\n', '    mapping(address => address[]) public productMappings;\n', '\n', '    function getAllProducts() external view returns (address[] allProducts);\n', '    function registerProduct() external returns(bool success);\n', '    function getOwnProducts() external view returns (address[] addresses);\n', '\n', '    event Registered(address product, address owner);\n', '}\n', '\n', 'contract ChargeableInterface is ComponentInterface {\n', '\n', '    uint public DENOMINATOR;\n', '    function calculateFee(address _caller, uint _amount) external returns(uint totalFeeAmount);\n', '    function setFeePercentage(uint _fee) external returns (bool succes);\n', '    function getFeePercentage() external view returns (uint feePercentage);\n', '\n', ' }\n', '\n', 'contract ReimbursableInterface is ComponentInterface {\n', '\n', '    // this should be called at the beginning of a function.\n', '    // such as rebalance and withdraw.\n', '    function startGasCalculation() external;\n', '    // this should be called at the last moment of the function.\n', '    function reimburse() external returns (uint);\n', '\n', '}\n', '\n', 'contract RiskControlInterface is ComponentInterface {\n', '    function hasRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate)\n', '        external returns(bool isRisky);\n', '}\n', '\n', 'contract OlympusIndex is IndexInterface, Derivative {\n', '    using SafeMath for uint256;\n', '\n', '    enum WhitelistKeys { Investment, Maintenance }\n', '\n', '    event ChangeStatus(DerivativeStatus status);\n', '    event Invested(address user, uint amount);\n', '    event Reimbursed(uint amount);\n', '    event  RiskEvent(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate, bool risky);\n', '\n', '    uint public constant DENOMINATOR = 100000;\n', '    uint public constant INITIAL_VALUE =  10**18;\n', '    uint[] public weights;\n', '    uint public accumulatedFee = 0;\n', '    uint public maxTransfers = 10;\n', '\n', '    // If whitelist is disabled, that will become onlyOwner\n', '    modifier onlyOwnerOrWhitelisted(WhitelistKeys _key) {\n', '        WhitelistInterface whitelist = WhitelistInterface(getComponentByName(WHITELIST));\n', '        require(\n', '            msg.sender == owner ||\n', '            (whitelist.enabled(address(this), uint8(_key)) && whitelist.isAllowed(uint8(_key), msg.sender) )\n', '        );\n', '        _;\n', '    }\n', '\n', '    // If whitelist is disabled, anyone can do this\n', '    modifier whitelisted(WhitelistKeys _key) {\n', '        require(WhitelistInterface(getComponentByName(WHITELIST)).isAllowed(uint8(_key), msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier withoutRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate) {\n', '        require(!hasRisk(_sender, _receiver, _tokenAddress, _amount, _rate));\n', '        _;\n', '    }\n', '\n', '    modifier checkLength(address[] _tokens, uint[] _weights) {\n', '        require(_tokens.length == _weights.length);\n', '        _;\n', '    }\n', '\n', '    modifier checkWeights(uint[] _weights){\n', '        uint totalWeight;\n', '        for(uint i = 0; i < _weights.length; i++){\n', '            totalWeight += _weights[i];\n', '        }\n', '        require(totalWeight == 100);\n', '        _;\n', '    }\n', '\n', '    constructor (\n', '      string _name,\n', '      string _symbol,\n', '      string _description,\n', '      string _category,\n', '      uint _decimals,\n', '      address[] _tokens,\n', '      uint[] _weights)\n', '      checkLength(_tokens, _weights) checkWeights(_weights) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        totalSupply_ = 0;\n', '        decimals = _decimals;\n', '        description = _description;\n', '        category = _category;\n', '        version = "1.0";\n', '        fundType = DerivativeType.Index;\n', '        tokens = _tokens;\n', '        weights = _weights;\n', '        status = DerivativeStatus.New;\n', '    }\n', '\n', '    // ----------------------------- CONFIG -----------------------------\n', '    function initialize(address _componentList, uint _initialFundFee) onlyOwner external payable {\n', '        require(status == DerivativeStatus.New);\n', '        require(msg.value > 0); // Require some balance for internal opeations as reimbursable\n', '        require(_componentList != 0x0);\n', '\n', '        super.initialize(_componentList);\n', '\n', '        setComponent(MARKET, componentList.getLatestComponent(MARKET));\n', '        setComponent(EXCHANGE, componentList.getLatestComponent(EXCHANGE));\n', '        setComponent(REBALANCE, componentList.getLatestComponent(REBALANCE));\n', '        setComponent(RISK, componentList.getLatestComponent(RISK));\n', '        setComponent(WHITELIST, componentList.getLatestComponent(WHITELIST));\n', '        setComponent(FEE, componentList.getLatestComponent(FEE));\n', '        setComponent(REIMBURSABLE, componentList.getLatestComponent(REIMBURSABLE));\n', '        setComponent(WITHDRAW, componentList.getLatestComponent(WITHDRAW));\n', '\n', '        // approve component for charging fees.\n', '        approveComponents();\n', '\n', '        MarketplaceInterface(componentList.getLatestComponent(MARKET)).registerProduct();\n', '        ChargeableInterface(componentList.getLatestComponent(FEE)).setFeePercentage(_initialFundFee);\n', '\n', '        status = DerivativeStatus.Active;\n', '\n', '        emit ChangeStatus(status);\n', '\n', '        accumulatedFee += msg.value;\n', '    }\n', '\n', '    // Call after you have updated the MARKET provider, not required after initialize\n', '    function registerInNewMarketplace() external onlyOwner returns(bool) {\n', '        require(MarketplaceInterface(getComponentByName(MARKET)).registerProduct());\n', '        return true;\n', '    }\n', '\n', '    // Return tokens and weights\n', '    function getTokens() public view returns (address[] _tokens, uint[] _weights) {\n', '        return (tokens, weights);\n', '    }\n', '    // Return tokens and amounts\n', '    function getTokensAndAmounts() external view returns(address[], uint[]) {\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ERC20Extended(tokens[i]).balanceOf(address(this));\n', '        }\n', '        return (tokens, _amounts);\n', '    }\n', '\n', '    function changeStatus(DerivativeStatus _status) public onlyOwner returns(bool) {\n', '        require(_status != DerivativeStatus.New && status != DerivativeStatus.New && _status != DerivativeStatus.Closed);\n', '        require(status != DerivativeStatus.Closed && _status != DerivativeStatus.Closed);\n', '\n', '        status = _status;\n', '        emit ChangeStatus(status);\n', '        return true;\n', '    }\n', '\n', '    function close() public onlyOwner returns(bool success){\n', '        require(status != DerivativeStatus.New);\n', '        getETHFromTokens(DENOMINATOR); // 100% all the tokens\n', '        status = DerivativeStatus.Closed;\n', '        emit ChangeStatus(status);\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------- DERIVATIVE -----------------------------\n', '\n', '    function invest() public payable\n', '     whenNotPaused\n', '     whitelisted(WhitelistKeys.Investment)\n', '     withoutRisk(msg.sender, address(this), ETH, msg.value, 1)\n', '     returns(bool) {\n', '        require(status == DerivativeStatus.Active, "The Fund is not active");\n', '        require(msg.value >= 10**15, "Minimum value to invest is 0.001 ETH");\n', '         // Current value is already added in the balance, reduce it\n', '        uint _sharePrice;\n', '\n', '        if(totalSupply_ > 0) {\n', '            _sharePrice = getPrice() - ( (msg.value * 10 ** decimals ) / totalSupply_);\n', '         } else {\n', '            _sharePrice = INITIAL_VALUE;\n', '        }\n', '\n', '        ChargeableInterface feeManager = ChargeableInterface(getComponentByName(FEE));\n', '        uint fee = feeManager.calculateFee(msg.sender, msg.value);\n', '\n', '        uint _investorShare = ( ( (msg.value-fee) * DENOMINATOR) / _sharePrice) * 10 ** decimals;\n', '        _investorShare = _investorShare / DENOMINATOR;\n', '\n', '        accumulatedFee += fee;\n', '        balances[msg.sender] += _investorShare;\n', '        totalSupply_ += _investorShare;\n', '\n', '        emit Invested(msg.sender, _investorShare);\n', '        return true;\n', '    }\n', '\n', '    function getPrice() public view returns(uint)  {\n', '        if(totalSupply_ == 0) {\n', '            return INITIAL_VALUE;\n', '        }\n', '\n', '        // Total Value in ETH among its tokens + ETH new added value\n', '        return (\n', '          ((getAssetsValue() + getETHBalance() ) * 10 ** decimals ) / (totalSupply_),\n', '        );\n', '    }\n', '\n', '    function getETHBalance() public view returns(uint){\n', '        return address(this).balance - accumulatedFee;\n', '    }\n', '\n', '    function getAssetsValue() public view returns (uint) {\n', '        // TODO cast to OlympusExchangeInterface\n', '        OlympusExchangeInterface exchangeProvider = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '        uint _totalTokensValue = 0;\n', '        // Iterator\n', '        uint _expectedRate;\n', '        uint _balance;\n', '\n', '        for (uint16 i = 0; i < tokens.length; i++) {\n', '\n', '            _balance = ERC20(tokens[i]).balanceOf(address(this));\n', '\n', '            if(_balance == 0){continue;}\n', '\n', '            (_expectedRate, ) = exchangeProvider.getPrice(ETH, ERC20Extended(tokens[i]), _balance, 0x0);\n', '\n', '            if(_expectedRate == 0){continue;}\n', '            _totalTokensValue += (_balance * 10**18) / _expectedRate;\n', '\n', '        }\n', '        return _totalTokensValue;\n', '    }\n', '\n', '    // ----------------------------- FEES  -----------------------------\n', '    // Owner can send ETH to the Index, to perform some task, this eth belongs to him\n', '    function addOwnerBalance() external payable onlyOwner {\n', '        accumulatedFee += msg.value;\n', '    }\n', '\n', '    function withdrawFee(uint amount) external onlyOwner whenNotPaused returns(bool) {\n', '        require(accumulatedFee >= amount);\n', '        accumulatedFee -= amount;\n', '        msg.sender.transfer(amount);\n', '        return true;\n', '    }\n', '\n', '    function setManagementFee(uint _fee) external onlyOwner {\n', '        ChargeableInterface(getComponentByName(FEE)).setFeePercentage(_fee);\n', '    }\n', '\n', '    function getManagementFee() external view returns(uint) {\n', '        return ChargeableInterface(getComponentByName(FEE)).getFeePercentage();\n', '    }\n', '\n', '    // ----------------------------- WITHDRAW -----------------------------\n', '    function requestWithdraw(uint amount) external\n', '     whitelisted(WhitelistKeys.Investment)\n', '     withoutRisk(msg.sender, address(this), address(this), amount, getPrice())\n', '    {\n', '        WithdrawInterface(getComponentByName(WITHDRAW)).request(msg.sender, amount);\n', '    }\n', '\n', '    function setMaxTransfers(uint _maxTransfers) external onlyOwner {\n', '        maxTransfers = _maxTransfers;\n', '    }\n', '\n', '    function withdraw() external onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns(bool) {\n', '\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        WithdrawInterface withdrawProvider = WithdrawInterface(getComponentByName(WITHDRAW));\n', '        // Check if there is request\n', '        address[] memory _requests = withdrawProvider.getUserRequests();\n', '        if(_requests.length == 0) {\n', '            reimburse();\n', '            return true;\n', '        }\n', '\n', '        uint _transfers = 0;\n', '        uint _eth;\n', '        uint tokens;\n', '\n', '        if (!withdrawProvider.isInProgress()) {\n', '            withdrawProvider.start();\n', '        }\n', '        uint _totalETHToReturn = ( withdrawProvider.getTotalWithdrawAmount() * getPrice()) / 10 ** decimals;\n', '\n', '        if(_totalETHToReturn > getETHBalance()) {\n', '            uint _tokenPercentToSell = (( _totalETHToReturn - getETHBalance()) * DENOMINATOR) / getAssetsValue();\n', '            getETHFromTokens(_tokenPercentToSell);\n', '        }\n', '\n', '        for(uint8 i = 0; i < _requests.length && _transfers < maxTransfers ; i++) {\n', '\n', '\n', '            (_eth, tokens) = withdrawProvider.withdraw(_requests[i]);\n', '            if(tokens == 0) {continue;}\n', '\n', '            balances[_requests[i]] -= tokens;\n', '            totalSupply_ -= tokens;\n', '            address(_requests[i]).transfer(_eth);\n', '            _transfers++;\n', '        }\n', '\n', '        if(!withdrawProvider.isInProgress()) {\n', '            withdrawProvider.unlock();\n', '        }\n', '        reimburse();\n', '        return !withdrawProvider.isInProgress(); // True if completed\n', '    }\n', '\n', '    function withdrawInProgress() external view returns(bool) {\n', '        return  WithdrawInterface(getComponentByName(WITHDRAW)).isInProgress();\n', '    }\n', '\n', '    function reimburse() internal {\n', '        uint reimbursedAmount = ReimbursableInterface(getComponentByName(REIMBURSABLE)).reimburse();\n', '        accumulatedFee -= reimbursedAmount;\n', '        emit Reimbursed(reimbursedAmount);\n', '        msg.sender.transfer(reimbursedAmount);\n', '    }\n', '\n', '    function tokensWithAmount() public view returns( ERC20Extended[] memory) {\n', '        // First check the length\n', '        uint8 length = 0;\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        for (uint8 i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ERC20Extended(tokens[i]).balanceOf(address(this));\n', '            if(_amounts[i] > 0) {length++;}\n', '        }\n', '\n', '        ERC20Extended[] memory _tokensWithAmount = new ERC20Extended[](length);\n', '        // Then create they array\n', '        uint8 index = 0;\n', '        for (uint8 j = 0; j < tokens.length; j++) {\n', '            if(_amounts[j] > 0) {\n', '                _tokensWithAmount[index] = ERC20Extended(tokens[j]);\n', '                index++;\n', '            }\n', '        }\n', '        return _tokensWithAmount;\n', '    }\n', '\n', '    function getETHFromTokens(uint _tokenPercentage ) internal {\n', '        ERC20Extended[] memory _tokensToSell = tokensWithAmount();\n', '        uint[] memory _amounts = new uint[](  _tokensToSell.length);\n', '        uint[] memory _sellRates = new uint[]( _tokensToSell.length);\n', '        OlympusExchangeInterface exchange = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '\n', '        for (uint8 i = 0; i < _tokensToSell.length; i++) {\n', '\n', '            _amounts[i] = (_tokenPercentage * _tokensToSell[i].balanceOf(address(this)) )/DENOMINATOR;\n', '            ( , _sellRates[i] ) = exchange.getPrice(_tokensToSell[i], ETH, _amounts[i], 0x0);\n', '            require(!hasRisk(address(this), exchange, address( _tokensToSell[i]), _amounts[i] , 0));\n', '            _tokensToSell[i].approve(exchange,  0);\n', '            _tokensToSell[i].approve(exchange,  _amounts[i]);\n', '        }\n', '        require(exchange.sellTokens(_tokensToSell, _amounts, _sellRates, address(this), 0x0, 0x0));\n', '\n', '    }\n', '\n', '    // ----------------------------- REBALANCE -----------------------------\n', '\n', '    function buyTokens() external onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns(bool) {\n', '\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        OlympusExchangeInterface exchange = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '\n', '\n', '        if(getETHBalance() == 0) {\n', '            reimburse();\n', '            return true;\n', '        }\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        uint[] memory _rates = new uint[](tokens.length); // Initialize to 0, making sure any rate is fine\n', '        ERC20Extended[] memory _tokensErc20 = new ERC20Extended[](tokens.length); // Initialize to 0, making sure any rate is fine\n', '        uint ethBalance = getETHBalance();\n', '        uint totalAmount = 0;\n', '\n', '        for(uint8 i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ethBalance * weights[i] / 100;\n', '            _tokensErc20[i] = ERC20Extended(tokens[i]);\n', '            (, _rates[i] ) = exchange.getPrice(ETH,  _tokensErc20[i],  _amounts[i], 0x0);\n', '            totalAmount += _amounts[i];\n', '        }\n', '\n', '        require(exchange.buyTokens.value(totalAmount)(_tokensErc20, _amounts, _rates, address(this), 0x0, 0x0));\n', '\n', '        reimburse();\n', '        return true;\n', '    }\n', '\n', '    function rebalance() public onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns (bool success) {\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        RebalanceInterface rebalanceProvider = RebalanceInterface(getComponentByName(REBALANCE));\n', '        OlympusExchangeInterface exchangeProvider = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '        address[] memory tokensToSell;\n', '        uint[] memory amountsToSell;\n', '        address[] memory tokensToBuy;\n', '        uint[] memory amountsToBuy;\n', '        uint8 i;\n', '        uint ETHBalanceBefore = address(this).balance;\n', '\n', '        (tokensToSell, amountsToSell, tokensToBuy, amountsToBuy,) = rebalanceProvider.rebalanceGetTokensToSellAndBuy();\n', '        // Sell Tokens\n', '        for (i = 0; i < tokensToSell.length; i++) {\n', '            ERC20Extended(tokensToSell[i]).approve(address(exchangeProvider), 0);\n', '            ERC20Extended(tokensToSell[i]).approve(address(exchangeProvider), amountsToSell[i]);\n', '            require(exchangeProvider.sellToken(ERC20Extended(tokensToSell[i]), amountsToSell[i], 0, address(this), 0x0, 0x0));\n', '\n', '        }\n', '\n', '        // Buy Tokens\n', '        amountsToBuy = rebalanceProvider.recalculateTokensToBuyAfterSale(address(this).balance - ETHBalanceBefore, amountsToBuy);\n', '        for (i = 0; i < tokensToBuy.length; i++) {\n', '            require(\n', '                exchangeProvider.buyToken.value(amountsToBuy[i])(ERC20Extended(tokensToBuy[i]), amountsToBuy[i], 0, address(this), 0x0, 0x0)\n', '            );\n', '        }\n', '\n', '        reimburse();\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------- WHITELIST -----------------------------\n', '\n', '    function enableWhitelist(WhitelistKeys _key) external onlyOwner returns(bool) {\n', '        WhitelistInterface(getComponentByName(WHITELIST)).enable(uint8(_key));\n', '        return true;\n', '    }\n', '\n', '    function disableWhitelist(WhitelistKeys _key) external onlyOwner returns(bool) {\n', '        WhitelistInterface(getComponentByName(WHITELIST)).disable(uint8(_key));\n', '        return true;\n', '    }\n', '\n', '    function setAllowed(address[] accounts, WhitelistKeys _key,  bool allowed) onlyOwner public returns(bool){\n', '        WhitelistInterface(getComponentByName(WHITELIST)).setAllowed(accounts,uint8(_key), allowed);\n', '        return true;\n', '    }\n', '\n', '    function approveComponents() private {\n', '        approveComponent(EXCHANGE);\n', '        approveComponent(WITHDRAW);\n', '        approveComponent(RISK);\n', '        approveComponent(WHITELIST);\n', '        approveComponent(FEE);\n', '        approveComponent(REIMBURSABLE);\n', '        approveComponent(REBALANCE);\n', '    }\n', '\n', '    function updateAllComponents() public onlyOwner {\n', '        updateComponent(MARKET);\n', '        updateComponent(EXCHANGE);\n', '        updateComponent(WITHDRAW);\n', '        updateComponent(RISK);\n', '        updateComponent(WHITELIST);\n', '        updateComponent(FEE);\n', '        updateComponent(REBALANCE);\n', '        updateComponent(REIMBURSABLE);\n', '    }\n', '\n', '    function hasRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate) public returns(bool) {\n', '        RiskControlInterface riskControl = RiskControlInterface(getComponentByName(RISK));\n', '        bool risk = riskControl.hasRisk(_sender, _receiver, _tokenAddress, _amount, _rate);\n', '        emit RiskEvent (_sender, _receiver, _tokenAddress, _amount, _rate, risk);\n', '        return risk;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract ERC20Extended is ERC20 {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract ComponentContainerInterface {\n', '    mapping (string => address) components;\n', '\n', '    event ComponentUpdated (string _name, address _componentAddress);\n', '\n', '    function setComponent(string _name, address _providerAddress) internal returns (bool success);\n', '    function getComponentByName(string name) public view returns (address);\n', '\n', '}\n', '\n', 'contract DerivativeInterface is ERC20Extended, Ownable, ComponentContainerInterface {\n', '\n', '    enum DerivativeStatus { New, Active, Paused, Closed }\n', '    enum DerivativeType { Index, Fund }\n', '\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '    DerivativeType public fundType;\n', '\n', '    address[] public tokens;\n', '    DerivativeStatus public status;\n', '\n', '    // invest, withdraw is done in transfer.\n', '    function invest() public payable returns(bool success);\n', '    function changeStatus(DerivativeStatus _status) public returns(bool);\n', '    function getPrice() public view returns(uint);\n', '\n', '    function initialize (address _componentList) internal;\n', '    function updateComponent(string _name) public returns (address);\n', '    function approveComponent(string _name) internal;\n', '}\n', '\n', 'contract ComponentContainer is ComponentContainerInterface {\n', '\n', '    function setComponent(string _name, address _componentAddress) internal returns (bool success) {\n', '        require(_componentAddress != address(0));\n', '        components[_name] = _componentAddress;\n', '        return true;\n', '    }\n', '\n', '    function getComponentByName(string _name) public view returns (address) {\n', '        return components[_name];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is StandardToken, Pausable {\n', '\n', '  function transfer(\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function approve(\n', '    address _spender,\n', '    uint256 _value\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool)\n', '  {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.increaseApproval(_spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    whenNotPaused\n', '    returns (bool success)\n', '  {\n', '    return super.decreaseApproval(_spender, _subtractedValue);\n', '  }\n', '}\n', '\n', 'contract ComponentListInterface {\n', '    event ComponentUpdated (string _name, string _version, address _componentAddress);\n', '    function setComponent(string _name, address _componentAddress) public returns (bool);\n', '    function getComponent(string _name, string _version) public view returns (address);\n', '    function getLatestComponent(string _name) public view returns(address);\n', '}\n', '\n', 'contract ERC20NoReturn {\n', '    uint256 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public;\n', '    function approve(address spender, uint tokens) public;\n', '    function transferFrom(address from, address to, uint tokens) public;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract FeeChargerInterface {\n', '    // TODO: change this to mainnet MOT address before deployment.\n', '    // solhint-disable-next-line\n', '    ERC20Extended public MOT = ERC20Extended(0x263c618480DBe35C300D8d5EcDA19bbB986AcaeD);\n', '    // kovan MOT: 0x41Dee9F481a1d2AA74a3f1d0958C1dB6107c686A\n', '    function setMotAddress(address _motAddress) external returns (bool success);\n', '}\n', '\n', '// Abstract class that implements the common functions to all our derivatives\n', 'contract Derivative is DerivativeInterface, ComponentContainer, PausableToken {\n', '\n', '    ERC20Extended internal constant ETH = ERC20Extended(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '    ComponentListInterface internal componentList;\n', '    string public constant MARKET = "MarketProvider";\n', '    string public constant EXCHANGE = "ExchangeProvider";\n', '    string public constant WITHDRAW = "WithdrawProvider";\n', '    string public constant RISK = "RiskProvider";\n', '    string public constant WHITELIST = "WhitelistProvider";\n', '    string public constant FEE = "FeeProvider";\n', '    string public constant REIMBURSABLE = "Reimbursable";\n', '    string public constant REBALANCE = "RebalanceProvider";\n', '\n', '    function initialize (address _componentList) internal {\n', '        require(_componentList != 0x0);\n', '        componentList = ComponentListInterface(_componentList);\n', '    }\n', '\n', '    function updateComponent(string _name) public onlyOwner returns (address) {\n', '        // still latest.\n', '        if (super.getComponentByName(_name) == componentList.getLatestComponent(_name)) {\n', '            return super.getComponentByName(_name);\n', '        }\n', '\n', '        // changed.\n', '        require(super.setComponent(_name, componentList.getLatestComponent(_name)));\n', "        // approve if it's not Marketplace.\n", '        if (keccak256(abi.encodePacked(_name)) != keccak256(abi.encodePacked(MARKET))) {\n', '            approveComponent(_name);\n', '        }\n', '\n', '        // return latest address.\n', '        return componentList.getLatestComponent(_name);\n', '    }\n', '\n', '\n', '\n', '    function approveComponent(string _name) internal {\n', '        address componentAddress = getComponentByName(_name);\n', '        ERC20NoReturn(FeeChargerInterface(componentAddress).MOT()).approve(componentAddress, 0);\n', '        ERC20NoReturn(FeeChargerInterface(componentAddress).MOT()).approve(componentAddress, 2 ** 256 - 1);\n', '    }\n', '\n', '    function () public payable {\n', '\n', '    }\n', '}\n', '\n', 'contract IndexInterface is DerivativeInterface {\n', '    uint[] public weights;\n', '    bool public supportRebalance;\n', '\n', '    // this should be called until it returns true.\n', '    function rebalance() public returns (bool success);\n', '    function getTokens() public view returns (address[] _tokens, uint[] _weights);\n', '}\n', '\n', 'contract ComponentInterface {\n', '    string public name;\n', '    string public description;\n', '    string public category;\n', '    string public version;\n', '}\n', '\n', 'contract ExchangeInterface is ComponentInterface {\n', '    /*\n', '     * @dev Checks if a trading pair is available\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @return boolean whether or not the trading pair is supported by this exchange provider\n', '     */\n', '    function supportsTradingPair(address _srcAddress, address _destAddress, bytes32 _exchangeId)\n', '        external view returns(bool supported);\n', '\n', '    /*\n', '     * @dev Buy a single token with ETH.\n', '     * @param ERC20Extended _token The token to buy, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the _amount.\n', '     * @param uint _minimumRate The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here.\n', '     * @return boolean whether or not the trade succeeded.\n', '     */\n', '    function buyToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell a single token for ETH. Make sure the token is approved beforehand.\n', '     * @param ERC20Extended _token The token to sell, should be an ERC20Extended address.\n', '     * @param uint _amount Amount of tokens to sell.\n', '     * @param uint _minimumRate The minimum amount of ETH to receive for 1 ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellToken\n', '        (\n', '        ERC20Extended _token, uint _amount, uint _minimumRate,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract PriceProviderInterface is ComponentInterface {\n', '    /*\n', '     * @dev Returns the expected price for 1 of sourceAddress.\n', '     * For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n', '     * @param address _sourceAddress The token to sell for the destAddress.\n', '     * @param address _destAddress The token to buy with the source token.\n', '     * @param uint _amount The amount of tokens which is wanted to buy.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @return returns the expected and slippage rate for the specified conversion\n', '     */\n', '    function getPrice(ERC20Extended _sourceAddress, ERC20Extended _destAddress, uint _amount, bytes32 _exchangeId)\n', '        external view returns(uint expectedRate, uint slippageRate);\n', '}\n', '\n', 'contract OlympusExchangeInterface is ExchangeInterface, PriceProviderInterface, Ownable {\n', '    /*\n', '     * @dev Buy multiple tokens at once with ETH.\n', '     * @param ERC20Extended[] _tokens The tokens to buy, should be an array of ERC20Extended addresses.\n', '     * @param uint[] _amounts Amount of ETH used to buy this token. Make sure the value sent to this function is the same as the sum of this array.\n', '     * @param uint[] _minimumRates The minimum amount of tokens to receive for 1 ETH.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function buyTokens\n', '        (\n', '        ERC20Extended[] _tokens, uint[] _amounts, uint[] _minimumRates,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external payable returns(bool success);\n', '\n', '    /*\n', '     * @dev Sell multiple tokens at once with ETH, make sure all of the tokens are approved to be transferred beforehand with the Olympus Exchange address.\n', '     * @param ERC20Extended[] _tokens The tokens to sell, should be an array of ERC20Extended addresses.\n', '     * @param uint[] _amounts Amount of tokens to sell this token. Make sure the value sent to this function is the same as the sum of this array.\n', '     * @param uint[] _minimumRates The minimum amount of ETH to receive for 1 specified ERC20Extended token.\n', '     * @param address _depositAddress The address to send the bought tokens to.\n', "     * @param bytes32 _exchangeId The exchangeId to choose. If it's an empty string, then the exchange will be chosen automatically.\n", '     * @param address _partnerId If the exchange supports a partnerId, you can supply your partnerId here\n', '     * @return boolean boolean whether or not the trade succeeded.\n', '     */\n', '    function sellTokens\n', '        (\n', '        ERC20Extended[] _tokens, uint[] _amounts, uint[] _minimumRates,\n', '        address _depositAddress, bytes32 _exchangeId, address _partnerId\n', '        ) external returns(bool success);\n', '}\n', '\n', 'contract RebalanceInterface is ComponentInterface {\n', '    // this should be called until it returns true.\n', '    function recalculateTokensToBuyAfterSale(uint _receivedETHFromSale, uint[] _amountsToBuy) external pure\n', '        returns(uint[] _recalculatedAmountsToBuy);\n', '    function rebalanceGetTokensToSellAndBuy() external returns\n', '        (address[] _tokensToSell, uint[] _amountsToSell, address[] _tokensToBuy, uint[] _amountsToBuy, address[] _tokensWithPriceIssues);\n', '}\n', '\n', 'contract WithdrawInterface is ComponentInterface {\n', '\n', '    function request(address _requester, uint amount) external returns(bool);\n', '    function withdraw(address _requester) external returns(uint eth, uint tokens);\n', '    function start() external;\n', '    function isInProgress() external view returns(bool);\n', '    function unlock() external;\n', '    function getUserRequests() external view returns(address[]);\n', '    function getTotalWithdrawAmount() external view returns(uint);\n', '\n', '    event WithdrawRequest(address _requester, uint amountOfToken);\n', '    event Withdrawed(address _requester,  uint amountOfToken , uint amountOfEther);\n', '}\n', '\n', 'contract WhitelistInterface is ComponentInterface {\n', '\n', '    // sender -> category -> user -> allowed\n', '    mapping (address => mapping(uint8 => mapping(address => bool))) public whitelist;\n', '    // sender -> category -> enabled\n', '    mapping (address => mapping(uint8 => bool)) public enabled;\n', '\n', '    function enable(uint8 _key) external;\n', '    function disable(uint8 _key) external;\n', '    function isAllowed(uint8 _key, address _account) external view returns(bool);\n', '    function setAllowed(address[] accounts, uint8 _key, bool allowed) external returns(bool);\n', '}\n', '\n', 'contract MarketplaceInterface is Ownable {\n', '\n', '    address[] public products;\n', '    mapping(address => address[]) public productMappings;\n', '\n', '    function getAllProducts() external view returns (address[] allProducts);\n', '    function registerProduct() external returns(bool success);\n', '    function getOwnProducts() external view returns (address[] addresses);\n', '\n', '    event Registered(address product, address owner);\n', '}\n', '\n', 'contract ChargeableInterface is ComponentInterface {\n', '\n', '    uint public DENOMINATOR;\n', '    function calculateFee(address _caller, uint _amount) external returns(uint totalFeeAmount);\n', '    function setFeePercentage(uint _fee) external returns (bool succes);\n', '    function getFeePercentage() external view returns (uint feePercentage);\n', '\n', ' }\n', '\n', 'contract ReimbursableInterface is ComponentInterface {\n', '\n', '    // this should be called at the beginning of a function.\n', '    // such as rebalance and withdraw.\n', '    function startGasCalculation() external;\n', '    // this should be called at the last moment of the function.\n', '    function reimburse() external returns (uint);\n', '\n', '}\n', '\n', 'contract RiskControlInterface is ComponentInterface {\n', '    function hasRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate)\n', '        external returns(bool isRisky);\n', '}\n', '\n', 'contract OlympusIndex is IndexInterface, Derivative {\n', '    using SafeMath for uint256;\n', '\n', '    enum WhitelistKeys { Investment, Maintenance }\n', '\n', '    event ChangeStatus(DerivativeStatus status);\n', '    event Invested(address user, uint amount);\n', '    event Reimbursed(uint amount);\n', '    event  RiskEvent(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate, bool risky);\n', '\n', '    uint public constant DENOMINATOR = 100000;\n', '    uint public constant INITIAL_VALUE =  10**18;\n', '    uint[] public weights;\n', '    uint public accumulatedFee = 0;\n', '    uint public maxTransfers = 10;\n', '\n', '    // If whitelist is disabled, that will become onlyOwner\n', '    modifier onlyOwnerOrWhitelisted(WhitelistKeys _key) {\n', '        WhitelistInterface whitelist = WhitelistInterface(getComponentByName(WHITELIST));\n', '        require(\n', '            msg.sender == owner ||\n', '            (whitelist.enabled(address(this), uint8(_key)) && whitelist.isAllowed(uint8(_key), msg.sender) )\n', '        );\n', '        _;\n', '    }\n', '\n', '    // If whitelist is disabled, anyone can do this\n', '    modifier whitelisted(WhitelistKeys _key) {\n', '        require(WhitelistInterface(getComponentByName(WHITELIST)).isAllowed(uint8(_key), msg.sender));\n', '        _;\n', '    }\n', '\n', '    modifier withoutRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate) {\n', '        require(!hasRisk(_sender, _receiver, _tokenAddress, _amount, _rate));\n', '        _;\n', '    }\n', '\n', '    modifier checkLength(address[] _tokens, uint[] _weights) {\n', '        require(_tokens.length == _weights.length);\n', '        _;\n', '    }\n', '\n', '    modifier checkWeights(uint[] _weights){\n', '        uint totalWeight;\n', '        for(uint i = 0; i < _weights.length; i++){\n', '            totalWeight += _weights[i];\n', '        }\n', '        require(totalWeight == 100);\n', '        _;\n', '    }\n', '\n', '    constructor (\n', '      string _name,\n', '      string _symbol,\n', '      string _description,\n', '      string _category,\n', '      uint _decimals,\n', '      address[] _tokens,\n', '      uint[] _weights)\n', '      checkLength(_tokens, _weights) checkWeights(_weights) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        totalSupply_ = 0;\n', '        decimals = _decimals;\n', '        description = _description;\n', '        category = _category;\n', '        version = "1.0";\n', '        fundType = DerivativeType.Index;\n', '        tokens = _tokens;\n', '        weights = _weights;\n', '        status = DerivativeStatus.New;\n', '    }\n', '\n', '    // ----------------------------- CONFIG -----------------------------\n', '    function initialize(address _componentList, uint _initialFundFee) onlyOwner external payable {\n', '        require(status == DerivativeStatus.New);\n', '        require(msg.value > 0); // Require some balance for internal opeations as reimbursable\n', '        require(_componentList != 0x0);\n', '\n', '        super.initialize(_componentList);\n', '\n', '        setComponent(MARKET, componentList.getLatestComponent(MARKET));\n', '        setComponent(EXCHANGE, componentList.getLatestComponent(EXCHANGE));\n', '        setComponent(REBALANCE, componentList.getLatestComponent(REBALANCE));\n', '        setComponent(RISK, componentList.getLatestComponent(RISK));\n', '        setComponent(WHITELIST, componentList.getLatestComponent(WHITELIST));\n', '        setComponent(FEE, componentList.getLatestComponent(FEE));\n', '        setComponent(REIMBURSABLE, componentList.getLatestComponent(REIMBURSABLE));\n', '        setComponent(WITHDRAW, componentList.getLatestComponent(WITHDRAW));\n', '\n', '        // approve component for charging fees.\n', '        approveComponents();\n', '\n', '        MarketplaceInterface(componentList.getLatestComponent(MARKET)).registerProduct();\n', '        ChargeableInterface(componentList.getLatestComponent(FEE)).setFeePercentage(_initialFundFee);\n', '\n', '        status = DerivativeStatus.Active;\n', '\n', '        emit ChangeStatus(status);\n', '\n', '        accumulatedFee += msg.value;\n', '    }\n', '\n', '    // Call after you have updated the MARKET provider, not required after initialize\n', '    function registerInNewMarketplace() external onlyOwner returns(bool) {\n', '        require(MarketplaceInterface(getComponentByName(MARKET)).registerProduct());\n', '        return true;\n', '    }\n', '\n', '    // Return tokens and weights\n', '    function getTokens() public view returns (address[] _tokens, uint[] _weights) {\n', '        return (tokens, weights);\n', '    }\n', '    // Return tokens and amounts\n', '    function getTokensAndAmounts() external view returns(address[], uint[]) {\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ERC20Extended(tokens[i]).balanceOf(address(this));\n', '        }\n', '        return (tokens, _amounts);\n', '    }\n', '\n', '    function changeStatus(DerivativeStatus _status) public onlyOwner returns(bool) {\n', '        require(_status != DerivativeStatus.New && status != DerivativeStatus.New && _status != DerivativeStatus.Closed);\n', '        require(status != DerivativeStatus.Closed && _status != DerivativeStatus.Closed);\n', '\n', '        status = _status;\n', '        emit ChangeStatus(status);\n', '        return true;\n', '    }\n', '\n', '    function close() public onlyOwner returns(bool success){\n', '        require(status != DerivativeStatus.New);\n', '        getETHFromTokens(DENOMINATOR); // 100% all the tokens\n', '        status = DerivativeStatus.Closed;\n', '        emit ChangeStatus(status);\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------- DERIVATIVE -----------------------------\n', '\n', '    function invest() public payable\n', '     whenNotPaused\n', '     whitelisted(WhitelistKeys.Investment)\n', '     withoutRisk(msg.sender, address(this), ETH, msg.value, 1)\n', '     returns(bool) {\n', '        require(status == DerivativeStatus.Active, "The Fund is not active");\n', '        require(msg.value >= 10**15, "Minimum value to invest is 0.001 ETH");\n', '         // Current value is already added in the balance, reduce it\n', '        uint _sharePrice;\n', '\n', '        if(totalSupply_ > 0) {\n', '            _sharePrice = getPrice() - ( (msg.value * 10 ** decimals ) / totalSupply_);\n', '         } else {\n', '            _sharePrice = INITIAL_VALUE;\n', '        }\n', '\n', '        ChargeableInterface feeManager = ChargeableInterface(getComponentByName(FEE));\n', '        uint fee = feeManager.calculateFee(msg.sender, msg.value);\n', '\n', '        uint _investorShare = ( ( (msg.value-fee) * DENOMINATOR) / _sharePrice) * 10 ** decimals;\n', '        _investorShare = _investorShare / DENOMINATOR;\n', '\n', '        accumulatedFee += fee;\n', '        balances[msg.sender] += _investorShare;\n', '        totalSupply_ += _investorShare;\n', '\n', '        emit Invested(msg.sender, _investorShare);\n', '        return true;\n', '    }\n', '\n', '    function getPrice() public view returns(uint)  {\n', '        if(totalSupply_ == 0) {\n', '            return INITIAL_VALUE;\n', '        }\n', '\n', '        // Total Value in ETH among its tokens + ETH new added value\n', '        return (\n', '          ((getAssetsValue() + getETHBalance() ) * 10 ** decimals ) / (totalSupply_),\n', '        );\n', '    }\n', '\n', '    function getETHBalance() public view returns(uint){\n', '        return address(this).balance - accumulatedFee;\n', '    }\n', '\n', '    function getAssetsValue() public view returns (uint) {\n', '        // TODO cast to OlympusExchangeInterface\n', '        OlympusExchangeInterface exchangeProvider = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '        uint _totalTokensValue = 0;\n', '        // Iterator\n', '        uint _expectedRate;\n', '        uint _balance;\n', '\n', '        for (uint16 i = 0; i < tokens.length; i++) {\n', '\n', '            _balance = ERC20(tokens[i]).balanceOf(address(this));\n', '\n', '            if(_balance == 0){continue;}\n', '\n', '            (_expectedRate, ) = exchangeProvider.getPrice(ETH, ERC20Extended(tokens[i]), _balance, 0x0);\n', '\n', '            if(_expectedRate == 0){continue;}\n', '            _totalTokensValue += (_balance * 10**18) / _expectedRate;\n', '\n', '        }\n', '        return _totalTokensValue;\n', '    }\n', '\n', '    // ----------------------------- FEES  -----------------------------\n', '    // Owner can send ETH to the Index, to perform some task, this eth belongs to him\n', '    function addOwnerBalance() external payable onlyOwner {\n', '        accumulatedFee += msg.value;\n', '    }\n', '\n', '    function withdrawFee(uint amount) external onlyOwner whenNotPaused returns(bool) {\n', '        require(accumulatedFee >= amount);\n', '        accumulatedFee -= amount;\n', '        msg.sender.transfer(amount);\n', '        return true;\n', '    }\n', '\n', '    function setManagementFee(uint _fee) external onlyOwner {\n', '        ChargeableInterface(getComponentByName(FEE)).setFeePercentage(_fee);\n', '    }\n', '\n', '    function getManagementFee() external view returns(uint) {\n', '        return ChargeableInterface(getComponentByName(FEE)).getFeePercentage();\n', '    }\n', '\n', '    // ----------------------------- WITHDRAW -----------------------------\n', '    function requestWithdraw(uint amount) external\n', '     whitelisted(WhitelistKeys.Investment)\n', '     withoutRisk(msg.sender, address(this), address(this), amount, getPrice())\n', '    {\n', '        WithdrawInterface(getComponentByName(WITHDRAW)).request(msg.sender, amount);\n', '    }\n', '\n', '    function setMaxTransfers(uint _maxTransfers) external onlyOwner {\n', '        maxTransfers = _maxTransfers;\n', '    }\n', '\n', '    function withdraw() external onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns(bool) {\n', '\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        WithdrawInterface withdrawProvider = WithdrawInterface(getComponentByName(WITHDRAW));\n', '        // Check if there is request\n', '        address[] memory _requests = withdrawProvider.getUserRequests();\n', '        if(_requests.length == 0) {\n', '            reimburse();\n', '            return true;\n', '        }\n', '\n', '        uint _transfers = 0;\n', '        uint _eth;\n', '        uint tokens;\n', '\n', '        if (!withdrawProvider.isInProgress()) {\n', '            withdrawProvider.start();\n', '        }\n', '        uint _totalETHToReturn = ( withdrawProvider.getTotalWithdrawAmount() * getPrice()) / 10 ** decimals;\n', '\n', '        if(_totalETHToReturn > getETHBalance()) {\n', '            uint _tokenPercentToSell = (( _totalETHToReturn - getETHBalance()) * DENOMINATOR) / getAssetsValue();\n', '            getETHFromTokens(_tokenPercentToSell);\n', '        }\n', '\n', '        for(uint8 i = 0; i < _requests.length && _transfers < maxTransfers ; i++) {\n', '\n', '\n', '            (_eth, tokens) = withdrawProvider.withdraw(_requests[i]);\n', '            if(tokens == 0) {continue;}\n', '\n', '            balances[_requests[i]] -= tokens;\n', '            totalSupply_ -= tokens;\n', '            address(_requests[i]).transfer(_eth);\n', '            _transfers++;\n', '        }\n', '\n', '        if(!withdrawProvider.isInProgress()) {\n', '            withdrawProvider.unlock();\n', '        }\n', '        reimburse();\n', '        return !withdrawProvider.isInProgress(); // True if completed\n', '    }\n', '\n', '    function withdrawInProgress() external view returns(bool) {\n', '        return  WithdrawInterface(getComponentByName(WITHDRAW)).isInProgress();\n', '    }\n', '\n', '    function reimburse() internal {\n', '        uint reimbursedAmount = ReimbursableInterface(getComponentByName(REIMBURSABLE)).reimburse();\n', '        accumulatedFee -= reimbursedAmount;\n', '        emit Reimbursed(reimbursedAmount);\n', '        msg.sender.transfer(reimbursedAmount);\n', '    }\n', '\n', '    function tokensWithAmount() public view returns( ERC20Extended[] memory) {\n', '        // First check the length\n', '        uint8 length = 0;\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        for (uint8 i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ERC20Extended(tokens[i]).balanceOf(address(this));\n', '            if(_amounts[i] > 0) {length++;}\n', '        }\n', '\n', '        ERC20Extended[] memory _tokensWithAmount = new ERC20Extended[](length);\n', '        // Then create they array\n', '        uint8 index = 0;\n', '        for (uint8 j = 0; j < tokens.length; j++) {\n', '            if(_amounts[j] > 0) {\n', '                _tokensWithAmount[index] = ERC20Extended(tokens[j]);\n', '                index++;\n', '            }\n', '        }\n', '        return _tokensWithAmount;\n', '    }\n', '\n', '    function getETHFromTokens(uint _tokenPercentage ) internal {\n', '        ERC20Extended[] memory _tokensToSell = tokensWithAmount();\n', '        uint[] memory _amounts = new uint[](  _tokensToSell.length);\n', '        uint[] memory _sellRates = new uint[]( _tokensToSell.length);\n', '        OlympusExchangeInterface exchange = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '\n', '        for (uint8 i = 0; i < _tokensToSell.length; i++) {\n', '\n', '            _amounts[i] = (_tokenPercentage * _tokensToSell[i].balanceOf(address(this)) )/DENOMINATOR;\n', '            ( , _sellRates[i] ) = exchange.getPrice(_tokensToSell[i], ETH, _amounts[i], 0x0);\n', '            require(!hasRisk(address(this), exchange, address( _tokensToSell[i]), _amounts[i] , 0));\n', '            _tokensToSell[i].approve(exchange,  0);\n', '            _tokensToSell[i].approve(exchange,  _amounts[i]);\n', '        }\n', '        require(exchange.sellTokens(_tokensToSell, _amounts, _sellRates, address(this), 0x0, 0x0));\n', '\n', '    }\n', '\n', '    // ----------------------------- REBALANCE -----------------------------\n', '\n', '    function buyTokens() external onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns(bool) {\n', '\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        OlympusExchangeInterface exchange = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '\n', '\n', '        if(getETHBalance() == 0) {\n', '            reimburse();\n', '            return true;\n', '        }\n', '        uint[] memory _amounts = new uint[](tokens.length);\n', '        uint[] memory _rates = new uint[](tokens.length); // Initialize to 0, making sure any rate is fine\n', '        ERC20Extended[] memory _tokensErc20 = new ERC20Extended[](tokens.length); // Initialize to 0, making sure any rate is fine\n', '        uint ethBalance = getETHBalance();\n', '        uint totalAmount = 0;\n', '\n', '        for(uint8 i = 0; i < tokens.length; i++) {\n', '            _amounts[i] = ethBalance * weights[i] / 100;\n', '            _tokensErc20[i] = ERC20Extended(tokens[i]);\n', '            (, _rates[i] ) = exchange.getPrice(ETH,  _tokensErc20[i],  _amounts[i], 0x0);\n', '            totalAmount += _amounts[i];\n', '        }\n', '\n', '        require(exchange.buyTokens.value(totalAmount)(_tokensErc20, _amounts, _rates, address(this), 0x0, 0x0));\n', '\n', '        reimburse();\n', '        return true;\n', '    }\n', '\n', '    function rebalance() public onlyOwnerOrWhitelisted(WhitelistKeys.Maintenance) whenNotPaused returns (bool success) {\n', '        ReimbursableInterface(getComponentByName(REIMBURSABLE)).startGasCalculation();\n', '        RebalanceInterface rebalanceProvider = RebalanceInterface(getComponentByName(REBALANCE));\n', '        OlympusExchangeInterface exchangeProvider = OlympusExchangeInterface(getComponentByName(EXCHANGE));\n', '        address[] memory tokensToSell;\n', '        uint[] memory amountsToSell;\n', '        address[] memory tokensToBuy;\n', '        uint[] memory amountsToBuy;\n', '        uint8 i;\n', '        uint ETHBalanceBefore = address(this).balance;\n', '\n', '        (tokensToSell, amountsToSell, tokensToBuy, amountsToBuy,) = rebalanceProvider.rebalanceGetTokensToSellAndBuy();\n', '        // Sell Tokens\n', '        for (i = 0; i < tokensToSell.length; i++) {\n', '            ERC20Extended(tokensToSell[i]).approve(address(exchangeProvider), 0);\n', '            ERC20Extended(tokensToSell[i]).approve(address(exchangeProvider), amountsToSell[i]);\n', '            require(exchangeProvider.sellToken(ERC20Extended(tokensToSell[i]), amountsToSell[i], 0, address(this), 0x0, 0x0));\n', '\n', '        }\n', '\n', '        // Buy Tokens\n', '        amountsToBuy = rebalanceProvider.recalculateTokensToBuyAfterSale(address(this).balance - ETHBalanceBefore, amountsToBuy);\n', '        for (i = 0; i < tokensToBuy.length; i++) {\n', '            require(\n', '                exchangeProvider.buyToken.value(amountsToBuy[i])(ERC20Extended(tokensToBuy[i]), amountsToBuy[i], 0, address(this), 0x0, 0x0)\n', '            );\n', '        }\n', '\n', '        reimburse();\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------- WHITELIST -----------------------------\n', '\n', '    function enableWhitelist(WhitelistKeys _key) external onlyOwner returns(bool) {\n', '        WhitelistInterface(getComponentByName(WHITELIST)).enable(uint8(_key));\n', '        return true;\n', '    }\n', '\n', '    function disableWhitelist(WhitelistKeys _key) external onlyOwner returns(bool) {\n', '        WhitelistInterface(getComponentByName(WHITELIST)).disable(uint8(_key));\n', '        return true;\n', '    }\n', '\n', '    function setAllowed(address[] accounts, WhitelistKeys _key,  bool allowed) onlyOwner public returns(bool){\n', '        WhitelistInterface(getComponentByName(WHITELIST)).setAllowed(accounts,uint8(_key), allowed);\n', '        return true;\n', '    }\n', '\n', '    function approveComponents() private {\n', '        approveComponent(EXCHANGE);\n', '        approveComponent(WITHDRAW);\n', '        approveComponent(RISK);\n', '        approveComponent(WHITELIST);\n', '        approveComponent(FEE);\n', '        approveComponent(REIMBURSABLE);\n', '        approveComponent(REBALANCE);\n', '    }\n', '\n', '    function updateAllComponents() public onlyOwner {\n', '        updateComponent(MARKET);\n', '        updateComponent(EXCHANGE);\n', '        updateComponent(WITHDRAW);\n', '        updateComponent(RISK);\n', '        updateComponent(WHITELIST);\n', '        updateComponent(FEE);\n', '        updateComponent(REBALANCE);\n', '        updateComponent(REIMBURSABLE);\n', '    }\n', '\n', '    function hasRisk(address _sender, address _receiver, address _tokenAddress, uint _amount, uint _rate) public returns(bool) {\n', '        RiskControlInterface riskControl = RiskControlInterface(getComponentByName(RISK));\n', '        bool risk = riskControl.hasRisk(_sender, _receiver, _tokenAddress, _amount, _rate);\n', '        emit RiskEvent (_sender, _receiver, _tokenAddress, _amount, _rate, risk);\n', '        return risk;\n', '    }\n', '}']
