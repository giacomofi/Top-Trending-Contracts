['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMathLibrary {\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer module of two numbers, truncating the quotient.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    bool public paused = false;\n', '\n', '    event Pause();\n', '\n', '    event Unpause();\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract Operator is Ownable {\n', '    mapping(address => bool) public operators;\n', '\n', '    event OperatorAddressAdded(address addr);\n', '    event OperatorAddressRemoved(address addr);\n', '\n', '    /**\n', '     * @dev Throws if called by any account that&#39;s not operator.\n', '     */\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev add an address to the operators\n', '     * @param addr address\n', '     * @return true if the address was added to the operators, false if the address was already in the operators\n', '     */\n', '    function addAddressToOperators(address addr) onlyOwner public returns(bool success) {\n', '        if (!operators[addr]) {\n', '            operators[addr] = true;\n', '            emit OperatorAddressAdded(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev add addresses to the operators\n', '     * @param addrs addresses\n', '     * @return true if at least one address was added to the operators,\n', '     * false if all addresses were already in the operators\n', '     */\n', '    function addAddressesToOperators(address[] addrs) onlyOwner public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (addAddressToOperators(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the operators\n', '     * @param addr address\n', '     * @return true if the address was removed from the operators,\n', '     * false if the address wasn&#39;t in the operators in the first place\n', '     */\n', '    function removeAddressFromOperators(address addr) onlyOwner public returns(bool success) {\n', '        if (operators[addr]) {\n', '            operators[addr] = false;\n', '            emit OperatorAddressRemoved(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove addresses from the operators\n', '     * @param addrs addresses\n', '     * @return true if at least one address was removed from the operators,\n', '     * false if all addresses weren&#39;t in the operators in the first place\n', '     */\n', '    function removeAddressesFromOperators(address[] addrs) onlyOwner public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (removeAddressFromOperators(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Whitelist is Operator {\n', '    mapping(address => bool) public whitelist;\n', '\n', '    event WhitelistedAddressAdded(address addr);\n', '    event WhitelistedAddressRemoved(address addr);\n', '\n', '    /**\n', '     * @dev Throws if called by any account that&#39;s not whitelisted.\n', '     */\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev add an address to the whitelist\n', '     * @param addr address\n', '     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '     */\n', '    function addAddressToWhitelist(address addr) onlyOperator public returns(bool success) {\n', '        if (!whitelist[addr]) {\n', '            whitelist[addr] = true;\n', '            emit WhitelistedAddressAdded(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev add addresses to the whitelist\n', '     * @param addrs addresses\n', '     * @return true if at least one address was added to the whitelist,\n', '     * false if all addresses were already in the whitelist\n', '     */\n', '    function addAddressesToWhitelist(address[] addrs) onlyOperator public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (addAddressToWhitelist(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the whitelist\n', '     * @param addr address\n', '     * @return true if the address was removed from the whitelist,\n', '     * false if the address wasn&#39;t in the whitelist in the first place\n', '     */\n', '    function removeAddressFromWhitelist(address addr) onlyOperator public returns(bool success) {\n', '        if (whitelist[addr]) {\n', '            whitelist[addr] = false;\n', '            emit WhitelistedAddressRemoved(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove addresses from the whitelist\n', '     * @param addrs addresses\n', '     * @return true if at least one address was removed from the whitelist,\n', '     * false if all addresses weren&#39;t in the whitelist in the first place\n', '     */\n', '    function removeAddressesFromWhitelist(address[] addrs) onlyOperator public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (removeAddressFromWhitelist(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transferFrom(address from, address to, uint amount) external returns(bool);\n', '}\n', '\n', 'contract Crowdsale is Pausable, Whitelist {\n', '    using SafeMathLibrary for uint;\n', '\n', '    address private EMPTY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n', '\n', '    Token public token;\n', '\n', '    address public beneficiary;\n', '    address public pool;\n', '    \n', '    uint internal decimals = 10 ** 18;\n', '\n', '    struct Funding {\n', '        address[] buyers;\n', '        address[] winners;\n', '        uint32 exchangeRatio;\n', '        uint8 minAccepting;\n', '        uint8 maxAccepting;\n', '        uint8 maxLotteryNumber;\n', '    }\n', '\n', '    struct BuyerStage {\n', '        uint8 funded;\n', '        bool lotteryBonusWon;\n', '        bool ultimateBonusWon;\n', '        bool bonusReleased;\n', '    }\n', '\n', '    struct Bonus {\n', '        uint32 buying;\n', '        uint32 lottery;\n', '        uint32 ultimate;\n', '    }\n', '\n', '    struct Stage {\n', '        Bonus bonus;\n', '        address[] buyers;\n', '        address[] winners;\n', '        address ultimateBonusWinner;\n', '        uint32 openingTime;\n', '        uint16 fundGoal;\n', '        uint16 fundRaised;\n', '        uint16 nextLotteryRaised;\n', '    }\n', '\n', '    Funding private funding;\n', '\n', '    mapping(address => mapping(uint8 => BuyerStage)) private buyers;\n', '\n', '    mapping(uint8 => Stage) private stages;\n', '\n', '    event BuyerFunded(address indexed buyer, uint8 stageIndex, uint8 amount);\n', '    event BuyerLotteryBonusWon(address indexed buyer, uint8 stageIndex, uint8 lotteryNumber, uint16 fundRaised);\n', '    event BuyerUltimateBonusWon(address indexed buyer, uint8 stageIndex);\n', '    event StageOpeningTimeSet(uint8 index);\n', '    event StageGoalReached(uint8 index);\n', '    event FinalGoalReached();\n', '\n', '    constructor (\n', '        address _tokenContractAddress,\n', '        address _beneficiary,\n', '        address _pool\n', '    ) public {\n', '        token = Token(_tokenContractAddress);\n', '        beneficiary = _beneficiary;\n', '        pool = _pool;\n', '\n', '        funding.exchangeRatio = 75000;\n', '        funding.minAccepting = 1;\n', '        funding.maxAccepting = 10;\n', '        funding.maxLotteryNumber = 9;\n', '\n', '        stages[1].openingTime = 1535500800;\n', '        stages[1].fundGoal = 3000;\n', '        stages[1].bonus.buying = 3600000; // 80%\n', '        stages[1].bonus.lottery = 450000; // 10%\n', '        stages[1].bonus.ultimate = 450000; // 10%\n', '\n', '        stages[2].fundGoal = 3000;\n', '        stages[2].bonus.buying = 2250000; // 50%\n', '        stages[2].bonus.lottery = 1125000; // 25%\n', '        stages[2].bonus.ultimate = 1125000; // 25%\n', '\n', '        stages[3].fundGoal = 3000;\n', '        stages[3].bonus.buying = 1350000; // 30%\n', '        stages[3].bonus.lottery = 1575000; // 35%\n', '        stages[3].bonus.ultimate = 1575000; // 35%\n', '\n', '        stages[4].fundGoal = 3000;\n', '        stages[4].bonus.buying = 0; // 0%\n', '        stages[4].bonus.lottery = 2250000; // 50%\n', '        stages[4].bonus.ultimate = 2250000; // 50%\n', '\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            stages[i].ultimateBonusWinner = EMPTY_ADDRESS;\n', '        }\n', '    }\n', '    \n', '    function getStageAverageBonus(uint8 _index) public view returns(\n', '        uint32 buying,\n', '        uint32 lottery,\n', '        uint32 ultimate\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '        buying = stage.bonus.buying > 0 ? stage.bonus.buying / stage.fundGoal : 0;\n', '        if (stageFundGoalReached(_index) == true) {\n', '            lottery = stage.bonus.lottery / uint16(stage.winners.length);\n', '            ultimate = stage.bonus.ultimate + (stage.bonus.lottery - lottery * uint16(stage.winners.length));\n', '        }\n', '    } \n', '\n', '    function getOpenedStageIndex() public view returns(uint8) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (stages[i].openingTime > 0 && now >= stages[i].openingTime && stages[i].fundRaised < stages[i].fundGoal) {\n', '                return i;\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getRandomNumber(uint256 power) private view returns (uint256) {\n', '        uint256 ddb = uint256(blockhash(block.number - 1));\n', '        uint256 r = uint256(keccak256(abi.encodePacked(ddb - 1)));\n', '        while (r == 0) {\n', '            ddb += 256;\n', '            r = uint256(keccak256(abi.encodePacked(ddb - 1)));\n', '        }\n', '        return uint256(keccak256(abi.encodePacked(r, block.difficulty, now))) % power;\n', '    }\n', '\n', '    function getTodayLotteryNumber() public view returns(uint8) {\n', '        return uint8(uint256(keccak256(abi.encodePacked(uint16(now / 1 days)))) % funding.maxLotteryNumber);\n', '    }\n', '\n', '    function getSummary() public view returns(\n', '        uint32 exchangeRatio,\n', '        uint16 fundGoal,\n', '        uint32 bonus,\n', '        uint16 fundRaised,\n', '        uint16 buyersCount,\n', '        uint16 winnersCount,\n', '        uint8 minAccepting,\n', '        uint8 maxAccepting,\n', '        uint8 openedStageIndex,\n', '        uint8 todayLotteryNumber\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            fundGoal += stages[i].fundGoal;\n', '            fundRaised += stages[i].fundRaised;\n', '            bonus += stages[i].bonus.buying + stages[i].bonus.lottery + stages[i].bonus.ultimate;\n', '        }\n', '\n', '        exchangeRatio = funding.exchangeRatio;\n', '        minAccepting = funding.minAccepting;\n', '        maxAccepting = funding.maxAccepting;\n', '        buyersCount = uint16(funding.buyers.length);\n', '        winnersCount = uint16(funding.winners.length);\n', '        openedStageIndex = getOpenedStageIndex();\n', '        todayLotteryNumber = getTodayLotteryNumber();\n', '    }\n', '\n', '    function setStageOpeningTime(uint8 _index, uint32 _openingTime) public onlyOwner whenNotPaused returns(bool) {\n', '        if (stages[_index].openingTime > 0) {\n', '            require(stages[_index].openingTime > now, "Stage has been already opened.");\n', '        }\n', '        stages[_index].openingTime = _openingTime;\n', '        emit StageOpeningTimeSet(_index);\n', '        return true;\n', '    }\n', '\n', '    function getStages() public view returns(\n', '        uint8[4] index,\n', '        uint32[4] openingTime,\n', '        uint32[4] buyingBonus,\n', '        uint32[4] lotteryBonus,\n', '        uint32[4] ultimateBonus,\n', '        uint16[4] fundGoal,\n', '        uint16[4] fundRaised,\n', '        uint16[4] buyersCount,\n', '        uint16[4] winnersCount,\n', '        address[4] ultimateBonusWinner\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            uint8 _i = i - 1;\n', '            index[_i] = i;\n', '            openingTime[_i] = stages[i].openingTime;\n', '            buyingBonus[_i] = stages[i].bonus.buying;\n', '            lotteryBonus[_i] = stages[i].bonus.lottery;\n', '            ultimateBonus[_i] = stages[i].bonus.ultimate;\n', '            fundGoal[_i] = stages[i].fundGoal;\n', '            fundRaised[_i] = stages[i].fundRaised;\n', '            buyersCount[_i] = uint16(stages[i].buyers.length);\n', '            winnersCount[_i] = uint16(stages[i].winners.length);\n', '            ultimateBonusWinner[_i] = stages[i].ultimateBonusWinner == EMPTY_ADDRESS ? address(0) : stages[i].ultimateBonusWinner;\n', '        }\n', '    }\n', '\n', '    function getBuyers(uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        total = uint16(funding.buyers.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = funding.buyers[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getWinners(uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        total = uint16(funding.winners.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = funding.winners[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getStageBuyers(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '\n', '        total = uint16(stage.buyers.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = stage.buyers[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getStageWinners(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '\n', '        total = uint16(stage.winners.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = stage.winners[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getBuyer(address _buyer) public view returns(\n', '        uint8[4] funded,\n', '        uint32[4] buyingBonus,\n', '        uint32[4] lotteryBonus,\n', '        uint32[4] ultimateBonus,\n', '        bool[4] lotteryBonusWon,\n', '        bool[4] ultimateBonusWon,\n', '        bool[4] bonusReleasable,\n', '        bool[4] bonusReleased\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            BuyerStage storage buyerStage = buyers[_buyer][i];\n', '            funded[i - 1] = buyerStage.funded;\n', '            lotteryBonusWon[i - 1] = buyerStage.lotteryBonusWon;\n', '            ultimateBonusWon[i - 1] = buyerStage.ultimateBonusWon;\n', '            bonusReleasable[i - 1] = stageFundGoalReached(i);\n', '            bonusReleased[i - 1] = buyerStage.bonusReleased;\n', '\n', '            uint32 _buyingBonus;\n', '            uint32 _lotteryBonus;\n', '            uint32 _ultimateBonus;\n', '\n', '            (_buyingBonus, _lotteryBonus, _ultimateBonus) = getStageAverageBonus(i);\n', '            \n', '            buyingBonus[i - 1] = buyerStage.funded * _buyingBonus;\n', '\n', '            if (buyerStage.lotteryBonusWon == true) {\n', '                lotteryBonus[i - 1] = _lotteryBonus;\n', '            }\n', '            \n', '            if (buyerStage.ultimateBonusWon == true) {\n', '                ultimateBonus[i - 1] = _ultimateBonus;\n', '            }\n', '        }\n', '    }\n', '\n', '    function finalFundGoalReached() public view returns(bool) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (stageFundGoalReached(i) == false) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function stageFundGoalReached(uint8 _index) public view returns(bool) {\n', '        Stage storage stage = stages[_index];\n', '        return (stage.openingTime > 0 && stage.openingTime <= now && stage.fundRaised >= stage.fundGoal);\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value) public returns(bool) {\n', '        require(msg.sender == address(token));\n', '        return true;\n', '    }\n', '\n', '    function releasableViewOrSend(address _buyer, bool _send) private returns(uint32) {\n', '        uint32 bonus;\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            BuyerStage storage buyerStage = buyers[_buyer][i];\n', '\n', '            if (stageFundGoalReached(i) == false || buyerStage.bonusReleased == true) {\n', '                continue;\n', '            }\n', '            \n', '            uint32 buyingBonus;\n', '            uint32 lotteryBonus;\n', '            uint32 ultimateBonus;\n', '\n', '            (buyingBonus, lotteryBonus, ultimateBonus) = getStageAverageBonus(i);\n', '\n', '            bonus += buyerStage.funded * buyingBonus;\n', '            if (buyerStage.lotteryBonusWon == true) {\n', '                bonus += lotteryBonus;\n', '            }\n', '            if (buyerStage.ultimateBonusWon == true) {\n', '                bonus += ultimateBonus;\n', '            }\n', '            \n', '            if (_send == true) {\n', '                buyerStage.bonusReleased = true;\n', '            }\n', '        }\n', '        \n', '        if (_send == true) {\n', '            require(bonus > 0, "No bonus.");\n', '            token.transferFrom(pool, _buyer, uint256(bonus).mul(decimals));\n', '        }\n', '        \n', '        return bonus;\n', '    }\n', '\n', '    function releasable(address _buyer) public view returns(uint32) {\n', '        return releasableViewOrSend(_buyer, false);\n', '    }\n', '\n', '    function release(address _buyer) private {\n', '        releasableViewOrSend(_buyer, true);\n', '    }\n', '\n', '    function getBuyerFunded(address _buyer) private view returns(uint8) {\n', '        uint8 funded;\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            funded += buyers[_buyer][i].funded;\n', '        }\n', '        return funded;\n', '    }\n', '\n', '    function hasBuyerLotteryBonusWon(address _buyer) private view returns(bool) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (buyers[_buyer][i].lotteryBonusWon) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function buy(address _buyer, uint256 value) private {\n', '        uint8 i = getOpenedStageIndex();\n', '        require(i > 0, "No opening stage found.");\n', '        require(value >= 1 ether, "The amount too low.");\n', '\n', '        Stage storage stage = stages[i];\n', '\n', '        uint16 remain;\n', '        uint16 funded = getBuyerFunded(_buyer);\n', '        uint256 amount = value.div(1 ether);\n', '        uint256 refund = value.sub(amount.mul(1 ether));\n', '\n', '        remain = funding.maxAccepting - funded;\n', '        require(remain > 0, "Total amount too high.");\n', '        if (remain < amount) {\n', '            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\n', '            amount = remain;\n', '        }\n', '\n', '        remain = stage.fundGoal - stage.fundRaised;\n', '        require(remain > 0, "Stage funding goal reached.");\n', '        if (remain < amount) {\n', '            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\n', '            amount = remain;\n', '        }\n', '\n', '        if (refund > 0) {\n', '            require(_buyer.send(refund), "Refund failed.");\n', '        }\n', '\n', '        BuyerStage storage buyerStage = buyers[_buyer][i];\n', '\n', '        if (funded == 0) {\n', '            funding.buyers.push(_buyer);\n', '        }\n', '        if (buyerStage.funded == 0) {\n', '            stage.buyers.push(_buyer);\n', '        }\n', '        buyerStage.funded += uint8(amount);\n', '\n', '        stage.fundRaised += uint16(amount);\n', '\n', '        emit BuyerFunded(_buyer, i, uint8(amount));\n', '\n', '        uint8 todayLotteryNumber = getTodayLotteryNumber();\n', '\n', '        if (stage.nextLotteryRaised == 0) {\n', '            stage.nextLotteryRaised = todayLotteryNumber;\n', '        }\n', '        \n', '        uint8 mod;\n', '        if (stage.fundRaised > 10) {\n', '            mod = uint8(stage.fundRaised % 10);\n', '            if (mod == 0) {\n', '                mod = 10;\n', '            }\n', '        } else {\n', '            mod = uint8(stage.fundRaised);\n', '        }\n', '        if (mod >= todayLotteryNumber && stage.fundRaised >= stage.nextLotteryRaised) {\n', '            if (hasBuyerLotteryBonusWon(_buyer) == false) {\n', '                funding.winners.push(_buyer);\n', '            }\n', '            if (buyerStage.lotteryBonusWon == false) {\n', '                buyerStage.lotteryBonusWon = true;\n', '                stage.winners.push(_buyer);\n', '                emit BuyerLotteryBonusWon(_buyer, i, todayLotteryNumber, stage.fundRaised);\n', '            }\n', '            stage.nextLotteryRaised += 10;\n', '        }\n', '\n', '        if (stage.fundGoal == stage.fundRaised) {\n', '            stage.ultimateBonusWinner = stage.winners[uint16(getRandomNumber(stage.winners.length - 1))];\n', '            buyers[stage.ultimateBonusWinner][i].ultimateBonusWon = true;\n', '\n', '            emit StageGoalReached(i);\n', '            emit BuyerUltimateBonusWon(_buyer, i);\n', '        }\n', '\n', '        if (finalFundGoalReached() == true) {\n', '            emit FinalGoalReached();\n', '        }\n', '\n', '        uint256 tokens = amount * funding.exchangeRatio;\n', '        require(beneficiary.send(amount.mul(1 ether)), "Send failed.");\n', '        require(token.transferFrom(pool, _buyer, tokens.mul(decimals)), "Deliver failed.");\n', '    }\n', '\n', '    function () whenNotPaused onlyWhitelisted public payable {\n', '        require(beneficiary != msg.sender, "The beneficiary cannot buy CATT.");\n', '        if (msg.value == 0) {\n', '            release(msg.sender);\n', '        } else {\n', '            buy(msg.sender, msg.value);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMathLibrary {\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer module of two numbers, truncating the quotient.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    bool public paused = false;\n', '\n', '    event Pause();\n', '\n', '    event Unpause();\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract Operator is Ownable {\n', '    mapping(address => bool) public operators;\n', '\n', '    event OperatorAddressAdded(address addr);\n', '    event OperatorAddressRemoved(address addr);\n', '\n', '    /**\n', "     * @dev Throws if called by any account that's not operator.\n", '     */\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev add an address to the operators\n', '     * @param addr address\n', '     * @return true if the address was added to the operators, false if the address was already in the operators\n', '     */\n', '    function addAddressToOperators(address addr) onlyOwner public returns(bool success) {\n', '        if (!operators[addr]) {\n', '            operators[addr] = true;\n', '            emit OperatorAddressAdded(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev add addresses to the operators\n', '     * @param addrs addresses\n', '     * @return true if at least one address was added to the operators,\n', '     * false if all addresses were already in the operators\n', '     */\n', '    function addAddressesToOperators(address[] addrs) onlyOwner public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (addAddressToOperators(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the operators\n', '     * @param addr address\n', '     * @return true if the address was removed from the operators,\n', "     * false if the address wasn't in the operators in the first place\n", '     */\n', '    function removeAddressFromOperators(address addr) onlyOwner public returns(bool success) {\n', '        if (operators[addr]) {\n', '            operators[addr] = false;\n', '            emit OperatorAddressRemoved(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove addresses from the operators\n', '     * @param addrs addresses\n', '     * @return true if at least one address was removed from the operators,\n', "     * false if all addresses weren't in the operators in the first place\n", '     */\n', '    function removeAddressesFromOperators(address[] addrs) onlyOwner public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (removeAddressFromOperators(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Whitelist is Operator {\n', '    mapping(address => bool) public whitelist;\n', '\n', '    event WhitelistedAddressAdded(address addr);\n', '    event WhitelistedAddressRemoved(address addr);\n', '\n', '    /**\n', "     * @dev Throws if called by any account that's not whitelisted.\n", '     */\n', '    modifier onlyWhitelisted() {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev add an address to the whitelist\n', '     * @param addr address\n', '     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '     */\n', '    function addAddressToWhitelist(address addr) onlyOperator public returns(bool success) {\n', '        if (!whitelist[addr]) {\n', '            whitelist[addr] = true;\n', '            emit WhitelistedAddressAdded(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev add addresses to the whitelist\n', '     * @param addrs addresses\n', '     * @return true if at least one address was added to the whitelist,\n', '     * false if all addresses were already in the whitelist\n', '     */\n', '    function addAddressesToWhitelist(address[] addrs) onlyOperator public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (addAddressToWhitelist(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove an address from the whitelist\n', '     * @param addr address\n', '     * @return true if the address was removed from the whitelist,\n', "     * false if the address wasn't in the whitelist in the first place\n", '     */\n', '    function removeAddressFromWhitelist(address addr) onlyOperator public returns(bool success) {\n', '        if (whitelist[addr]) {\n', '            whitelist[addr] = false;\n', '            emit WhitelistedAddressRemoved(addr);\n', '            success = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev remove addresses from the whitelist\n', '     * @param addrs addresses\n', '     * @return true if at least one address was removed from the whitelist,\n', "     * false if all addresses weren't in the whitelist in the first place\n", '     */\n', '    function removeAddressesFromWhitelist(address[] addrs) onlyOperator public returns(bool success) {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (removeAddressFromWhitelist(addrs[i])) {\n', '                success = true;\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transferFrom(address from, address to, uint amount) external returns(bool);\n', '}\n', '\n', 'contract Crowdsale is Pausable, Whitelist {\n', '    using SafeMathLibrary for uint;\n', '\n', '    address private EMPTY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n', '\n', '    Token public token;\n', '\n', '    address public beneficiary;\n', '    address public pool;\n', '    \n', '    uint internal decimals = 10 ** 18;\n', '\n', '    struct Funding {\n', '        address[] buyers;\n', '        address[] winners;\n', '        uint32 exchangeRatio;\n', '        uint8 minAccepting;\n', '        uint8 maxAccepting;\n', '        uint8 maxLotteryNumber;\n', '    }\n', '\n', '    struct BuyerStage {\n', '        uint8 funded;\n', '        bool lotteryBonusWon;\n', '        bool ultimateBonusWon;\n', '        bool bonusReleased;\n', '    }\n', '\n', '    struct Bonus {\n', '        uint32 buying;\n', '        uint32 lottery;\n', '        uint32 ultimate;\n', '    }\n', '\n', '    struct Stage {\n', '        Bonus bonus;\n', '        address[] buyers;\n', '        address[] winners;\n', '        address ultimateBonusWinner;\n', '        uint32 openingTime;\n', '        uint16 fundGoal;\n', '        uint16 fundRaised;\n', '        uint16 nextLotteryRaised;\n', '    }\n', '\n', '    Funding private funding;\n', '\n', '    mapping(address => mapping(uint8 => BuyerStage)) private buyers;\n', '\n', '    mapping(uint8 => Stage) private stages;\n', '\n', '    event BuyerFunded(address indexed buyer, uint8 stageIndex, uint8 amount);\n', '    event BuyerLotteryBonusWon(address indexed buyer, uint8 stageIndex, uint8 lotteryNumber, uint16 fundRaised);\n', '    event BuyerUltimateBonusWon(address indexed buyer, uint8 stageIndex);\n', '    event StageOpeningTimeSet(uint8 index);\n', '    event StageGoalReached(uint8 index);\n', '    event FinalGoalReached();\n', '\n', '    constructor (\n', '        address _tokenContractAddress,\n', '        address _beneficiary,\n', '        address _pool\n', '    ) public {\n', '        token = Token(_tokenContractAddress);\n', '        beneficiary = _beneficiary;\n', '        pool = _pool;\n', '\n', '        funding.exchangeRatio = 75000;\n', '        funding.minAccepting = 1;\n', '        funding.maxAccepting = 10;\n', '        funding.maxLotteryNumber = 9;\n', '\n', '        stages[1].openingTime = 1535500800;\n', '        stages[1].fundGoal = 3000;\n', '        stages[1].bonus.buying = 3600000; // 80%\n', '        stages[1].bonus.lottery = 450000; // 10%\n', '        stages[1].bonus.ultimate = 450000; // 10%\n', '\n', '        stages[2].fundGoal = 3000;\n', '        stages[2].bonus.buying = 2250000; // 50%\n', '        stages[2].bonus.lottery = 1125000; // 25%\n', '        stages[2].bonus.ultimate = 1125000; // 25%\n', '\n', '        stages[3].fundGoal = 3000;\n', '        stages[3].bonus.buying = 1350000; // 30%\n', '        stages[3].bonus.lottery = 1575000; // 35%\n', '        stages[3].bonus.ultimate = 1575000; // 35%\n', '\n', '        stages[4].fundGoal = 3000;\n', '        stages[4].bonus.buying = 0; // 0%\n', '        stages[4].bonus.lottery = 2250000; // 50%\n', '        stages[4].bonus.ultimate = 2250000; // 50%\n', '\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            stages[i].ultimateBonusWinner = EMPTY_ADDRESS;\n', '        }\n', '    }\n', '    \n', '    function getStageAverageBonus(uint8 _index) public view returns(\n', '        uint32 buying,\n', '        uint32 lottery,\n', '        uint32 ultimate\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '        buying = stage.bonus.buying > 0 ? stage.bonus.buying / stage.fundGoal : 0;\n', '        if (stageFundGoalReached(_index) == true) {\n', '            lottery = stage.bonus.lottery / uint16(stage.winners.length);\n', '            ultimate = stage.bonus.ultimate + (stage.bonus.lottery - lottery * uint16(stage.winners.length));\n', '        }\n', '    } \n', '\n', '    function getOpenedStageIndex() public view returns(uint8) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (stages[i].openingTime > 0 && now >= stages[i].openingTime && stages[i].fundRaised < stages[i].fundGoal) {\n', '                return i;\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getRandomNumber(uint256 power) private view returns (uint256) {\n', '        uint256 ddb = uint256(blockhash(block.number - 1));\n', '        uint256 r = uint256(keccak256(abi.encodePacked(ddb - 1)));\n', '        while (r == 0) {\n', '            ddb += 256;\n', '            r = uint256(keccak256(abi.encodePacked(ddb - 1)));\n', '        }\n', '        return uint256(keccak256(abi.encodePacked(r, block.difficulty, now))) % power;\n', '    }\n', '\n', '    function getTodayLotteryNumber() public view returns(uint8) {\n', '        return uint8(uint256(keccak256(abi.encodePacked(uint16(now / 1 days)))) % funding.maxLotteryNumber);\n', '    }\n', '\n', '    function getSummary() public view returns(\n', '        uint32 exchangeRatio,\n', '        uint16 fundGoal,\n', '        uint32 bonus,\n', '        uint16 fundRaised,\n', '        uint16 buyersCount,\n', '        uint16 winnersCount,\n', '        uint8 minAccepting,\n', '        uint8 maxAccepting,\n', '        uint8 openedStageIndex,\n', '        uint8 todayLotteryNumber\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            fundGoal += stages[i].fundGoal;\n', '            fundRaised += stages[i].fundRaised;\n', '            bonus += stages[i].bonus.buying + stages[i].bonus.lottery + stages[i].bonus.ultimate;\n', '        }\n', '\n', '        exchangeRatio = funding.exchangeRatio;\n', '        minAccepting = funding.minAccepting;\n', '        maxAccepting = funding.maxAccepting;\n', '        buyersCount = uint16(funding.buyers.length);\n', '        winnersCount = uint16(funding.winners.length);\n', '        openedStageIndex = getOpenedStageIndex();\n', '        todayLotteryNumber = getTodayLotteryNumber();\n', '    }\n', '\n', '    function setStageOpeningTime(uint8 _index, uint32 _openingTime) public onlyOwner whenNotPaused returns(bool) {\n', '        if (stages[_index].openingTime > 0) {\n', '            require(stages[_index].openingTime > now, "Stage has been already opened.");\n', '        }\n', '        stages[_index].openingTime = _openingTime;\n', '        emit StageOpeningTimeSet(_index);\n', '        return true;\n', '    }\n', '\n', '    function getStages() public view returns(\n', '        uint8[4] index,\n', '        uint32[4] openingTime,\n', '        uint32[4] buyingBonus,\n', '        uint32[4] lotteryBonus,\n', '        uint32[4] ultimateBonus,\n', '        uint16[4] fundGoal,\n', '        uint16[4] fundRaised,\n', '        uint16[4] buyersCount,\n', '        uint16[4] winnersCount,\n', '        address[4] ultimateBonusWinner\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            uint8 _i = i - 1;\n', '            index[_i] = i;\n', '            openingTime[_i] = stages[i].openingTime;\n', '            buyingBonus[_i] = stages[i].bonus.buying;\n', '            lotteryBonus[_i] = stages[i].bonus.lottery;\n', '            ultimateBonus[_i] = stages[i].bonus.ultimate;\n', '            fundGoal[_i] = stages[i].fundGoal;\n', '            fundRaised[_i] = stages[i].fundRaised;\n', '            buyersCount[_i] = uint16(stages[i].buyers.length);\n', '            winnersCount[_i] = uint16(stages[i].winners.length);\n', '            ultimateBonusWinner[_i] = stages[i].ultimateBonusWinner == EMPTY_ADDRESS ? address(0) : stages[i].ultimateBonusWinner;\n', '        }\n', '    }\n', '\n', '    function getBuyers(uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        total = uint16(funding.buyers.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = funding.buyers[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getWinners(uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        total = uint16(funding.winners.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = funding.winners[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getStageBuyers(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '\n', '        total = uint16(stage.buyers.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = stage.buyers[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getStageWinners(uint8 _index, uint16 _offset, uint8 _limit) public view returns(\n', '        uint16 total,\n', '        uint16 start,\n', '        uint16 end,\n', '        uint8 count,\n', '        address[] items\n', '    ) {\n', '        Stage storage stage = stages[_index];\n', '\n', '        total = uint16(stage.winners.length);\n', '        if (total > 0) {\n', '            start = _offset > total - 1 ? total - 1 : _offset;\n', '            end = (start + _limit > total) ? total - 1 : (start + _limit > 0 ? start + _limit - 1 : 0);\n', '            count = uint8(end - start + 1);\n', '        }\n', '\n', '        if (count > 0) {\n', '            address[] memory _items = new address[](count);\n', '            uint8 j = 0;\n', '            for (uint16 i = start; i <= end; i++) {\n', '                _items[j] = stage.winners[i];\n', '                j++;\n', '            }\n', '            items = _items;\n', '        }\n', '    }\n', '\n', '    function getBuyer(address _buyer) public view returns(\n', '        uint8[4] funded,\n', '        uint32[4] buyingBonus,\n', '        uint32[4] lotteryBonus,\n', '        uint32[4] ultimateBonus,\n', '        bool[4] lotteryBonusWon,\n', '        bool[4] ultimateBonusWon,\n', '        bool[4] bonusReleasable,\n', '        bool[4] bonusReleased\n', '    ) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            BuyerStage storage buyerStage = buyers[_buyer][i];\n', '            funded[i - 1] = buyerStage.funded;\n', '            lotteryBonusWon[i - 1] = buyerStage.lotteryBonusWon;\n', '            ultimateBonusWon[i - 1] = buyerStage.ultimateBonusWon;\n', '            bonusReleasable[i - 1] = stageFundGoalReached(i);\n', '            bonusReleased[i - 1] = buyerStage.bonusReleased;\n', '\n', '            uint32 _buyingBonus;\n', '            uint32 _lotteryBonus;\n', '            uint32 _ultimateBonus;\n', '\n', '            (_buyingBonus, _lotteryBonus, _ultimateBonus) = getStageAverageBonus(i);\n', '            \n', '            buyingBonus[i - 1] = buyerStage.funded * _buyingBonus;\n', '\n', '            if (buyerStage.lotteryBonusWon == true) {\n', '                lotteryBonus[i - 1] = _lotteryBonus;\n', '            }\n', '            \n', '            if (buyerStage.ultimateBonusWon == true) {\n', '                ultimateBonus[i - 1] = _ultimateBonus;\n', '            }\n', '        }\n', '    }\n', '\n', '    function finalFundGoalReached() public view returns(bool) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (stageFundGoalReached(i) == false) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function stageFundGoalReached(uint8 _index) public view returns(bool) {\n', '        Stage storage stage = stages[_index];\n', '        return (stage.openingTime > 0 && stage.openingTime <= now && stage.fundRaised >= stage.fundGoal);\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value) public returns(bool) {\n', '        require(msg.sender == address(token));\n', '        return true;\n', '    }\n', '\n', '    function releasableViewOrSend(address _buyer, bool _send) private returns(uint32) {\n', '        uint32 bonus;\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            BuyerStage storage buyerStage = buyers[_buyer][i];\n', '\n', '            if (stageFundGoalReached(i) == false || buyerStage.bonusReleased == true) {\n', '                continue;\n', '            }\n', '            \n', '            uint32 buyingBonus;\n', '            uint32 lotteryBonus;\n', '            uint32 ultimateBonus;\n', '\n', '            (buyingBonus, lotteryBonus, ultimateBonus) = getStageAverageBonus(i);\n', '\n', '            bonus += buyerStage.funded * buyingBonus;\n', '            if (buyerStage.lotteryBonusWon == true) {\n', '                bonus += lotteryBonus;\n', '            }\n', '            if (buyerStage.ultimateBonusWon == true) {\n', '                bonus += ultimateBonus;\n', '            }\n', '            \n', '            if (_send == true) {\n', '                buyerStage.bonusReleased = true;\n', '            }\n', '        }\n', '        \n', '        if (_send == true) {\n', '            require(bonus > 0, "No bonus.");\n', '            token.transferFrom(pool, _buyer, uint256(bonus).mul(decimals));\n', '        }\n', '        \n', '        return bonus;\n', '    }\n', '\n', '    function releasable(address _buyer) public view returns(uint32) {\n', '        return releasableViewOrSend(_buyer, false);\n', '    }\n', '\n', '    function release(address _buyer) private {\n', '        releasableViewOrSend(_buyer, true);\n', '    }\n', '\n', '    function getBuyerFunded(address _buyer) private view returns(uint8) {\n', '        uint8 funded;\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            funded += buyers[_buyer][i].funded;\n', '        }\n', '        return funded;\n', '    }\n', '\n', '    function hasBuyerLotteryBonusWon(address _buyer) private view returns(bool) {\n', '        for (uint8 i = 1; i <= 4; i++) {\n', '            if (buyers[_buyer][i].lotteryBonusWon) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function buy(address _buyer, uint256 value) private {\n', '        uint8 i = getOpenedStageIndex();\n', '        require(i > 0, "No opening stage found.");\n', '        require(value >= 1 ether, "The amount too low.");\n', '\n', '        Stage storage stage = stages[i];\n', '\n', '        uint16 remain;\n', '        uint16 funded = getBuyerFunded(_buyer);\n', '        uint256 amount = value.div(1 ether);\n', '        uint256 refund = value.sub(amount.mul(1 ether));\n', '\n', '        remain = funding.maxAccepting - funded;\n', '        require(remain > 0, "Total amount too high.");\n', '        if (remain < amount) {\n', '            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\n', '            amount = remain;\n', '        }\n', '\n', '        remain = stage.fundGoal - stage.fundRaised;\n', '        require(remain > 0, "Stage funding goal reached.");\n', '        if (remain < amount) {\n', '            refund = refund.add(amount.sub(uint256(remain)).mul(1 ether));\n', '            amount = remain;\n', '        }\n', '\n', '        if (refund > 0) {\n', '            require(_buyer.send(refund), "Refund failed.");\n', '        }\n', '\n', '        BuyerStage storage buyerStage = buyers[_buyer][i];\n', '\n', '        if (funded == 0) {\n', '            funding.buyers.push(_buyer);\n', '        }\n', '        if (buyerStage.funded == 0) {\n', '            stage.buyers.push(_buyer);\n', '        }\n', '        buyerStage.funded += uint8(amount);\n', '\n', '        stage.fundRaised += uint16(amount);\n', '\n', '        emit BuyerFunded(_buyer, i, uint8(amount));\n', '\n', '        uint8 todayLotteryNumber = getTodayLotteryNumber();\n', '\n', '        if (stage.nextLotteryRaised == 0) {\n', '            stage.nextLotteryRaised = todayLotteryNumber;\n', '        }\n', '        \n', '        uint8 mod;\n', '        if (stage.fundRaised > 10) {\n', '            mod = uint8(stage.fundRaised % 10);\n', '            if (mod == 0) {\n', '                mod = 10;\n', '            }\n', '        } else {\n', '            mod = uint8(stage.fundRaised);\n', '        }\n', '        if (mod >= todayLotteryNumber && stage.fundRaised >= stage.nextLotteryRaised) {\n', '            if (hasBuyerLotteryBonusWon(_buyer) == false) {\n', '                funding.winners.push(_buyer);\n', '            }\n', '            if (buyerStage.lotteryBonusWon == false) {\n', '                buyerStage.lotteryBonusWon = true;\n', '                stage.winners.push(_buyer);\n', '                emit BuyerLotteryBonusWon(_buyer, i, todayLotteryNumber, stage.fundRaised);\n', '            }\n', '            stage.nextLotteryRaised += 10;\n', '        }\n', '\n', '        if (stage.fundGoal == stage.fundRaised) {\n', '            stage.ultimateBonusWinner = stage.winners[uint16(getRandomNumber(stage.winners.length - 1))];\n', '            buyers[stage.ultimateBonusWinner][i].ultimateBonusWon = true;\n', '\n', '            emit StageGoalReached(i);\n', '            emit BuyerUltimateBonusWon(_buyer, i);\n', '        }\n', '\n', '        if (finalFundGoalReached() == true) {\n', '            emit FinalGoalReached();\n', '        }\n', '\n', '        uint256 tokens = amount * funding.exchangeRatio;\n', '        require(beneficiary.send(amount.mul(1 ether)), "Send failed.");\n', '        require(token.transferFrom(pool, _buyer, tokens.mul(decimals)), "Deliver failed.");\n', '    }\n', '\n', '    function () whenNotPaused onlyWhitelisted public payable {\n', '        require(beneficiary != msg.sender, "The beneficiary cannot buy CATT.");\n', '        if (msg.value == 0) {\n', '            release(msg.sender);\n', '        } else {\n', '            buy(msg.sender, msg.value);\n', '        }\n', '    }\n', '}']
