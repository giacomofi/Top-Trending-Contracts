['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title IPFS hash handler\n', ' *\n', ' * @dev IPFS multihash handler. Does a small check to validate that a multihash is\n', ' *   correct by validating the digest size byte of the hash. For example, the IPFS\n', ' *   Multihash "QmPtkU87jX1SnyhjAgUwnirmabAmeASQ4wGfwxviJSA4wf" is the base58\n', ' *   encoded form of the following data:\n', ' *\n', ' *     ┌────┬────┬───────────────────────────────────────────────────────────────────┐\n', ' *     │byte│byte│             variable length hash based on digest size             │\n', ' *     ├────┼────┼───────────────────────────────────────────────────────────────────┤\n', ' *     │0x12│0x20│0x1714c8d0fa5dbe9e6c04059ddac50c3860fb0370d67af53f2bd51a4def656526 │\n', ' *     └────┴────┴───────────────────────────────────────────────────────────────────┘\n', ' *       ▲    ▲                                   ▲\n', ' *       │    └───────────┐                       │\n', ' *   hash function    digest size             hash value\n', ' *\n', ' * we still store the data as `bytes` since it is inherently a variable length structure.\n', ' *\n', ' * @dev See multihash format: https://git.io/vbooc\n', ' */\n', 'contract DependentOnIPFS {\n', '  /**\n', '   * @dev Validate a multihash bytes value\n', '   */\n', '  function isValidIPFSMultihash(bytes _multihashBytes) internal pure returns (bool) {\n', '    require(_multihashBytes.length > 2);\n', '\n', '    uint8 _size;\n', '\n', '    // There isn&#39;t another way to extract only this byte into a uint8\n', '    // solhint-disable no-inline-assembly\n', '    assembly {\n', '      // Seek forward 33 bytes beyond the solidity length value and the hash function byte\n', '      _size := byte(0, mload(add(_multihashBytes, 33)))\n', '    }\n', '\n', '    return (_multihashBytes.length == _size + 2);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Voteable poll with associated IPFS data\n', ' *\n', ' * A poll records votes on a variable number of choices. A poll specifies\n', ' * a window during which users can vote. Information like the poll title and\n', ' * the descriptions for each option are stored on IPFS.\n', ' */\n', 'contract Poll is DependentOnIPFS {\n', '  // There isn&#39;t a way around using time to determine when votes can be cast\n', '  // solhint-disable not-rely-on-time\n', '\n', '  bytes public pollDataMultihash;\n', '  uint16 public numChoices;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  address public author;\n', '  address public pollAdmin;\n', '\n', '  AccountRegistryInterface public registry;\n', '  SigningLogicInterface public signingLogic;\n', '\n', '  mapping(uint256 => uint16) public votes;\n', '\n', '  mapping (bytes32 => bool) public usedSignatures;\n', '\n', '  event VoteCast(address indexed voter, uint16 indexed choice);\n', '\n', '  constructor(\n', '    bytes _ipfsHash,\n', '    uint16 _numChoices,\n', '    uint256 _startTime,\n', '    uint256 _endTime,\n', '    address _author,\n', '    AccountRegistryInterface _registry,\n', '    SigningLogicInterface _signingLogic,\n', '    address _pollAdmin\n', '  ) public {\n', '    require(_startTime >= now && _endTime > _startTime);\n', '    require(isValidIPFSMultihash(_ipfsHash));\n', '\n', '    numChoices = _numChoices;\n', '    startTime = _startTime;\n', '    endTime = _endTime;\n', '    pollDataMultihash = _ipfsHash;\n', '    author = _author;\n', '    registry = _registry;\n', '    signingLogic = _signingLogic;\n', '    pollAdmin = _pollAdmin;\n', '  }\n', '\n', '  function vote(uint16 _choice) external {\n', '    voteForUser(_choice, msg.sender);\n', '  }\n', '\n', '  function voteFor(uint16 _choice, address _voter, bytes32 _nonce, bytes _delegationSig) external onlyPollAdmin {\n', '    require(!usedSignatures[keccak256(abi.encodePacked(_delegationSig))], "Signature not unique");\n', '    usedSignatures[keccak256(abi.encodePacked(_delegationSig))] = true;\n', '    bytes32 _delegationDigest = signingLogic.generateVoteForDelegationSchemaHash(\n', '      _choice,\n', '      _voter,\n', '      _nonce,\n', '      this\n', '    );\n', '    require(_voter == signingLogic.recoverSigner(_delegationDigest, _delegationSig));\n', '    voteForUser(_choice, _voter);\n', '  }\n', '\n', '  /**\n', '   * @dev Cast or change your vote\n', '   * @param _choice The index of the option in the corresponding IPFS document.\n', '   */\n', '  function voteForUser(uint16 _choice, address _voter) internal duringPoll {\n', '    // Choices are indexed from 1 since the mapping returns 0 for "no vote cast"\n', '    require(_choice <= numChoices && _choice > 0);\n', '    uint256 _voterId = registry.accountIdForAddress(_voter);\n', '\n', '    votes[_voterId] = _choice;\n', '    emit VoteCast(_voter, _choice);\n', '  }\n', '\n', '  modifier duringPoll {\n', '    require(now >= startTime && now <= endTime);\n', '    _;\n', '  }\n', '\n', '  modifier onlyPollAdmin {\n', '    require(msg.sender == pollAdmin);\n', '    _;\n', '  }\n', '}\n', '\n', 'interface AccountRegistryInterface {\n', '  function accountIdForAddress(address _address) public view returns (uint256);\n', '  function addressBelongsToAccount(address _address) public view returns (bool);\n', '  function createNewAccount(address _newUser) external;\n', '  function addAddressToAccount(\n', '    address _newAddress,\n', '    address _sender\n', '    ) external;\n', '  function removeAddressFromAccount(address _addressToRemove) external;\n', '}\n', '\n', 'contract SigningLogicInterface {\n', '  function recoverSigner(bytes32 _hash, bytes _sig) external pure returns (address);\n', '  function generateRequestAttestationSchemaHash(\n', '    address _subject,\n', '    address _attester,\n', '    address _requester,\n', '    bytes32 _dataHash,\n', '    uint256[] _typeIds,\n', '    bytes32 _nonce\n', '    ) external view returns (bytes32);\n', '  function generateAttestForDelegationSchemaHash(\n', '    address _subject,\n', '    address _requester,\n', '    uint256 _reward,\n', '    bytes32 _paymentNonce,\n', '    bytes32 _dataHash,\n', '    uint256[] _typeIds,\n', '    bytes32 _requestNonce\n', '    ) external view returns (bytes32);\n', '  function generateContestForDelegationSchemaHash(\n', '    address _requester,\n', '    uint256 _reward,\n', '    bytes32 _paymentNonce\n', '  ) external view returns (bytes32);\n', '  function generateStakeForDelegationSchemaHash(\n', '    address _subject,\n', '    uint256 _value,\n', '    bytes32 _paymentNonce,\n', '    bytes32 _dataHash,\n', '    uint256[] _typeIds,\n', '    bytes32 _requestNonce,\n', '    uint256 _stakeDuration\n', '    ) external view returns (bytes32);\n', '  function generateRevokeStakeForDelegationSchemaHash(\n', '    uint256 _subjectId,\n', '    uint256 _attestationId\n', '    ) external view returns (bytes32);\n', '  function generateAddAddressSchemaHash(\n', '    address _senderAddress,\n', '    bytes32 _nonce\n', '    ) external view returns (bytes32);\n', '  function generateVoteForDelegationSchemaHash(\n', '    uint16 _choice,\n', '    address _voter,\n', '    bytes32 _nonce,\n', '    address _poll\n', '    ) external view returns (bytes32);\n', '  function generateReleaseTokensSchemaHash(\n', '    address _sender,\n', '    address _receiver,\n', '    uint256 _amount,\n', '    bytes32 _uuid\n', '    ) external view returns (bytes32);\n', '  function generateLockupTokensDelegationSchemaHash(\n', '    address _sender,\n', '    uint256 _amount,\n', '    bytes32 _nonce\n', '    ) external view returns (bytes32);\n', '}\n', '\n', '/*\n', ' * @title Bloom voting center\n', ' * @dev The voting center is the home of all polls conducted within the Bloom network.\n', ' *   Anyone can create a new poll and there is no "owner" of the network. The Bloom dApp\n', ' *   assumes that all polls are in the `polls` field so any Bloom poll should be created\n', ' *   through the `createPoll` function.\n', ' */\n', 'contract VotingCenter {\n', '  Poll[] public polls;\n', '\n', '  event PollCreated(address indexed poll, address indexed author);\n', '\n', '  /**\n', '   * @dev create a poll and store the address of the poll in this contract\n', '   * @param _ipfsHash Multihash for IPFS file containing poll information\n', '   * @param _numOptions Number of choices in this poll\n', '   * @param _startTime Time after which a user can cast a vote in the poll\n', '   * @param _endTime Time after which the poll no longer accepts new votes\n', '   * @return The address of the new Poll\n', '   */\n', '  function createPoll(\n', '    bytes _ipfsHash,\n', '    uint16 _numOptions,\n', '    uint256 _startTime,\n', '    uint256 _endTime,\n', '    AccountRegistryInterface _registry,\n', '    SigningLogicInterface _signingLogic,\n', '    address _pollAdmin\n', '  ) public returns (address) {\n', '    Poll newPoll = new Poll(\n', '      _ipfsHash,\n', '      _numOptions,\n', '      _startTime,\n', '      _endTime,\n', '      msg.sender,\n', '      _registry,\n', '      _signingLogic,\n', '      _pollAdmin\n', '      );\n', '    polls.push(newPoll);\n', '\n', '    emit PollCreated(newPoll, msg.sender);\n', '\n', '    return newPoll;\n', '  }\n', '\n', '  function allPolls() view public returns (Poll[]) {\n', '    return polls;\n', '  }\n', '\n', '  function numPolls() view public returns (uint256) {\n', '    return polls.length;\n', '  }\n', '}']