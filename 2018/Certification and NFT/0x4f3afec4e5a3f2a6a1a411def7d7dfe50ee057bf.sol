['pragma solidity ^0.4.19;\n', '\n', '/// @title Contract Resolver Interface\n', '/// @author Digix Holdings Pte Ltd\n', '\n', 'contract ResolverClient {\n', '\n', '  /// The address of the resolver contract for this project\n', '  address public resolver;\n', '  /// The key to identify this contract\n', '  bytes32 public key;\n', '\n', '  /// Make our own address available to us as a constant\n', '  address public CONTRACT_ADDRESS;\n', '\n', '  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n', '  /// @param _contract The resolver key\n', '  modifier if_sender_is(bytes32 _contract) {\n', '    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\n', '    _;\n', '  }\n', '\n', '  /// Function modifier to check resolver&#39;s locking status.\n', '  modifier unless_resolver_is_locked() {\n', '    require(is_locked() == false);\n', '    _;\n', '  }\n', '\n', '  /// @dev Initialize new contract\n', '  /// @param _key the resolver key for this contract\n', '  /// @return _success if the initialization is successful\n', '  function init(bytes32 _key, address _resolver)\n', '           internal\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(_resolver).locked();\n', '    if (_is_locked == false) {\n', '      CONTRACT_ADDRESS = address(this);\n', '      resolver = _resolver;\n', '      key = _key;\n', '      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n', '      _success = true;\n', '    }  else {\n', '      _success = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Destroy the contract and unregister self from the ContractResolver\n', '  /// @dev Can only be called by the owner of ContractResolver\n', '  function destroy()\n', '           public\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(resolver).locked();\n', '    require(!_is_locked);\n', '\n', '    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\n', '    require(msg.sender == _owner_of_contract_resolver);\n', '\n', '    _success = ContractResolver(resolver).unregister_contract(key);\n', '    require(_success);\n', '\n', '    selfdestruct(_owner_of_contract_resolver);\n', '  }\n', '\n', '  /// @dev Check if resolver is locked\n', '  /// @return _locked if the resolver is currently locked\n', '  function is_locked()\n', '           private\n', '           constant\n', '           returns (bool _locked)\n', '  {\n', '    _locked = ContractResolver(resolver).locked();\n', '  }\n', '\n', '  /// @dev Get the address of a contract\n', '  /// @param _key the resolver key to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract)\n', '  {\n', '    _contract = ContractResolver(resolver).get_contract(_key);\n', '  }\n', '}\n', '\n', 'contract ContractResolver {\n', '  address public owner;\n', '  bool public locked;\n', '  function init_register_contract(bytes32 _key, address _contract_address)\n', '           public\n', '           returns (bool _success) {}\n', '\n', '  /// @dev Unregister a contract.  This can only be called from the contract with the key itself\n', '  /// @param _key the bytestring of the contract name\n', '  /// @return _success if the operation is successful\n', '  function unregister_contract(bytes32 _key)\n', '           public\n', '           returns (bool _success) {}\n', '\n', '  /// @dev Get address of a contract\n', '  /// @param _key the bytestring name of the contract to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract) {}\n', '}\n', '\n', 'contract DigixConstants {\n', '    /// general constants\n', '    uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\n', '\n', '    /// asset events\n', '    uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\n', '    uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\n', '    uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\n', '    uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\n', '    uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\n', '    uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\n', '    uint256 constant ASSET_EVENT_MINTED = 7;\n', '    uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\n', '    uint256 constant ASSET_EVENT_RECASTED = 9;\n', '    uint256 constant ASSET_EVENT_REDEEMED = 10;\n', '    uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\n', '    uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\n', '    uint256 constant ASSET_EVENT_REMINTED = 13;\n', '\n', '    /// roles\n', '    uint256 constant ROLE_ZERO_ANYONE = 0;\n', '    uint256 constant ROLE_ROOT = 1;\n', '    uint256 constant ROLE_VENDOR = 2;\n', '    uint256 constant ROLE_XFERAUTH = 3;\n', '    uint256 constant ROLE_POPADMIN = 4;\n', '    uint256 constant ROLE_CUSTODIAN = 5;\n', '    uint256 constant ROLE_AUDITOR = 6;\n', '    uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\n', '    uint256 constant ROLE_KYC_ADMIN = 8;\n', '    uint256 constant ROLE_FEES_ADMIN = 9;\n', '    uint256 constant ROLE_DOCS_UPLOADER = 10;\n', '    uint256 constant ROLE_KYC_RECASTER = 11;\n', '    uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\n', '\n', '    /// states\n', '    uint256 constant STATE_ZERO_UNDEFINED = 0;\n', '    uint256 constant STATE_CREATED = 1;\n', '    uint256 constant STATE_VENDOR_ORDER = 2;\n', '    uint256 constant STATE_TRANSFER = 3;\n', '    uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\n', '    uint256 constant STATE_MINTED = 5;\n', '    uint256 constant STATE_AUDIT_FAILURE = 6;\n', '    uint256 constant STATE_REPLACEMENT_ORDER = 7;\n', '    uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\n', '    uint256 constant STATE_RECASTED = 9;\n', '    uint256 constant STATE_REDEEMED = 10;\n', '    uint256 constant STATE_ADMIN_FAILURE = 11;\n', '\n', '\n', '\n', '    /// interactive contracts\n', '    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = "i:asset:explorer";\n', '    bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = "i:directory";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = "i:mp";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = "i:mpadmin";\n', '    bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = "i:popadmin";\n', '    bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = "i:products";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN = "i:token";\n', '    bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = "i:bulk-wrapper";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = "i:token:config";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = "i:token:information";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = "i:mp:information";\n', '    bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = "i:identity";\n', '\n', '\n', '    /// controller contracts\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS = "c:asset";\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = "c:asset:recast";\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = "c:explorer";\n', '    bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = "c:directory";\n', '    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = "c:mp";\n', '    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = "c:mpadmin";\n', '    bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = "c:products";\n', '\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = "c:token:approval";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = "c:token:config";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = "c:token:info";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = "c:token:transfer";\n', '\n', '    bytes32 constant CONTRACT_CONTROLLER_JOB_ID = "c:jobid";\n', '    bytes32 constant CONTRACT_CONTROLLER_IDENTITY = "c:identity";\n', '\n', '    /// storage contracts\n', '    bytes32 constant CONTRACT_STORAGE_ASSETS = "s:asset";\n', '    bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = "s:asset:events";\n', '    bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = "s:directory";\n', '    bytes32 constant CONTRACT_STORAGE_MARKETPLACE = "s:mp";\n', '    bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = "s:products";\n', '    bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = "s:goldtoken";\n', '    bytes32 constant CONTRACT_STORAGE_JOB_ID = "s:jobid";\n', '    bytes32 constant CONTRACT_STORAGE_IDENTITY = "s:identity";\n', '\n', '    /// service contracts\n', '    bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = "sv:tdemurrage";\n', '    bytes32 constant CONTRACT_SERVICE_MARKETPLACE = "sv:mp";\n', '    bytes32 constant CONTRACT_SERVICE_DIRECTORY = "sv:directory";\n', '\n', '    /// fees distributors\n', '    bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = "fees:distributor:demurrage";\n', '    bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = "fees:distributor:recast";\n', '    bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = "fees:distributor:transfer";\n', '\n', '}\n', '\n', 'contract TokenLoggerCallback is ResolverClient, DigixConstants {\n', '\n', '  event Transfer(address indexed _from,  address indexed _to,  uint256 _value);\n', '  event Approval(address indexed _owner,  address indexed _spender,  uint256 _value);\n', '\n', '  function log_mint(address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\n', '           public\n', '  {\n', '    Transfer(address(0x0), _to, _value);\n', '  }\n', '\n', '  function log_recast_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_recast(address _from, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\n', '           public\n', '  {\n', '    Transfer(_from, address(0x0), _value);\n', '  }\n', '\n', '  function log_demurrage_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_move_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_transfer(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_approve(address _owner, address _spender, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\n', '           public\n', '  {\n', '    Approval(_owner, _spender, _value);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract TokenInfoController {\n', '  function get_total_supply() constant public returns (uint256 _total_supply){}\n', '  function get_allowance(address _account, address _spender) constant public returns (uint256 _allowance){}\n', '  function get_balance(address _user) constant public returns (uint256 _actual_balance){}\n', '}\n', '\n', 'contract TokenTransferController {\n', '  function put_transfer(address _sender, address _recipient, address _spender, uint256 _amount, bool _transfer_from) public returns (bool _success){}\n', '}\n', '\n', 'contract TokenApprovalController {\n', '  function approve(address _account, address _spender, uint256 _amount) public returns (bool _success){}\n', '}\n', '\n', '/// The interface of a contract that can receive tokens from transferAndCall()\n', 'contract TokenReceiver {\n', '  function tokenFallback(address from, uint256 amount, bytes32 data) public returns (bool success);\n', '}\n', '\n', '/// @title DGX2.0 ERC-20 Token. ERC-677 is also implemented https://github.com/ethereum/EIPs/issues/677\n', '/// @author Digix Holdings Pte Ltd\n', 'contract Token is TokenLoggerCallback {\n', '\n', '  string public constant name = "Digix Gold Token";\n', '  string public constant symbol = "DGX";\n', '  uint8 public constant decimals = 9;\n', '\n', '  function Token(address _resolver) public\n', '  {\n', '    require(init(CONTRACT_INTERACTIVE_TOKEN, _resolver));\n', '  }\n', '\n', '  /// @notice show the total supply of gold tokens\n', '  /// @return {\n', '  ///    "totalSupply": "total number of tokens"\n', '  /// }\n', '  function totalSupply()\n', '           constant\n', '           public\n', '           returns (uint256 _total_supply)\n', '  {\n', '    _total_supply = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_total_supply();\n', '  }\n', '\n', '  /// @notice display balance of given account\n', '  /// @param _owner the account to query\n', '  /// @return {\n', '  ///    "balance": "balance of the given account in nanograms"\n', '  /// }\n', '  function balanceOf(address _owner)\n', '           constant\n', '           public\n', '           returns (uint256 balance)\n', '  {\n', '    balance = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_balance(_owner);\n', '  }\n', '\n', '  /// @notice transfer amount to account\n', '  /// @param _to account to send to\n', '  /// @param _value the amount in nanograms to send\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transfer(address _to, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success =\n', '      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(msg.sender, _to, 0x0, _value, false);\n', '  }\n', '\n', '  /// @notice transfer amount to account from account deducting from spender allowance\n', '  /// @param _to account to send to\n', '  /// @param _from account to send from\n', '  /// @param _value the amount in nanograms to send\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success =\n', '      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(_from, _to, msg.sender,\n', '                                                                             _value, true);\n', '  }\n', '\n', '  /// @notice implements transferAndCall() of ERC677\n', '  /// @param _receiver the contract to receive the token\n', '  /// @param _amount the amount of tokens to be transfered\n', '  /// @param _data the data to be passed to the tokenFallback function of the receiving contract\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transferAndCall(address _receiver, uint256 _amount, bytes32 _data)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    transfer(_receiver, _amount);\n', '    success = TokenReceiver(_receiver).tokenFallback(msg.sender, _amount, _data);\n', '    require(success);\n', '  }\n', '\n', '  /// @notice approve given spender to transfer given amount this will set allowance to 0 if current value is non-zero\n', '  /// @param _spender the account that is given an allowance\n', '  /// @param _value the amount in nanograms to approve\n', '  /// @return {\n', '  ///   "success": "returns true if successful"\n', '  /// }\n', '  function approve(address _spender, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success = TokenApprovalController(get_contract(CONTRACT_CONTROLLER_TOKEN_APPROVAL)).approve(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /// @notice check the spending allowance of a given user from a given account\n', '  /// @param _owner the account to spend from\n', '  /// @param _spender the spender\n', '  /// @return {\n', '  ///    "remaining": "the remaining allowance in nanograms"\n', '  /// }\n', '  function allowance(address _owner, address _spender)\n', '           constant\n', '           public\n', '           returns (uint256 remaining)\n', '  {\n', '    remaining = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_allowance(_owner, _spender);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/// @title Contract Resolver Interface\n', '/// @author Digix Holdings Pte Ltd\n', '\n', 'contract ResolverClient {\n', '\n', '  /// The address of the resolver contract for this project\n', '  address public resolver;\n', '  /// The key to identify this contract\n', '  bytes32 public key;\n', '\n', '  /// Make our own address available to us as a constant\n', '  address public CONTRACT_ADDRESS;\n', '\n', '  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n', '  /// @param _contract The resolver key\n', '  modifier if_sender_is(bytes32 _contract) {\n', '    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\n', '    _;\n', '  }\n', '\n', "  /// Function modifier to check resolver's locking status.\n", '  modifier unless_resolver_is_locked() {\n', '    require(is_locked() == false);\n', '    _;\n', '  }\n', '\n', '  /// @dev Initialize new contract\n', '  /// @param _key the resolver key for this contract\n', '  /// @return _success if the initialization is successful\n', '  function init(bytes32 _key, address _resolver)\n', '           internal\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(_resolver).locked();\n', '    if (_is_locked == false) {\n', '      CONTRACT_ADDRESS = address(this);\n', '      resolver = _resolver;\n', '      key = _key;\n', '      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n', '      _success = true;\n', '    }  else {\n', '      _success = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Destroy the contract and unregister self from the ContractResolver\n', '  /// @dev Can only be called by the owner of ContractResolver\n', '  function destroy()\n', '           public\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(resolver).locked();\n', '    require(!_is_locked);\n', '\n', '    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\n', '    require(msg.sender == _owner_of_contract_resolver);\n', '\n', '    _success = ContractResolver(resolver).unregister_contract(key);\n', '    require(_success);\n', '\n', '    selfdestruct(_owner_of_contract_resolver);\n', '  }\n', '\n', '  /// @dev Check if resolver is locked\n', '  /// @return _locked if the resolver is currently locked\n', '  function is_locked()\n', '           private\n', '           constant\n', '           returns (bool _locked)\n', '  {\n', '    _locked = ContractResolver(resolver).locked();\n', '  }\n', '\n', '  /// @dev Get the address of a contract\n', '  /// @param _key the resolver key to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract)\n', '  {\n', '    _contract = ContractResolver(resolver).get_contract(_key);\n', '  }\n', '}\n', '\n', 'contract ContractResolver {\n', '  address public owner;\n', '  bool public locked;\n', '  function init_register_contract(bytes32 _key, address _contract_address)\n', '           public\n', '           returns (bool _success) {}\n', '\n', '  /// @dev Unregister a contract.  This can only be called from the contract with the key itself\n', '  /// @param _key the bytestring of the contract name\n', '  /// @return _success if the operation is successful\n', '  function unregister_contract(bytes32 _key)\n', '           public\n', '           returns (bool _success) {}\n', '\n', '  /// @dev Get address of a contract\n', '  /// @param _key the bytestring name of the contract to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract) {}\n', '}\n', '\n', 'contract DigixConstants {\n', '    /// general constants\n', '    uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\n', '\n', '    /// asset events\n', '    uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\n', '    uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\n', '    uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\n', '    uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\n', '    uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\n', '    uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\n', '    uint256 constant ASSET_EVENT_MINTED = 7;\n', '    uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\n', '    uint256 constant ASSET_EVENT_RECASTED = 9;\n', '    uint256 constant ASSET_EVENT_REDEEMED = 10;\n', '    uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\n', '    uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\n', '    uint256 constant ASSET_EVENT_REMINTED = 13;\n', '\n', '    /// roles\n', '    uint256 constant ROLE_ZERO_ANYONE = 0;\n', '    uint256 constant ROLE_ROOT = 1;\n', '    uint256 constant ROLE_VENDOR = 2;\n', '    uint256 constant ROLE_XFERAUTH = 3;\n', '    uint256 constant ROLE_POPADMIN = 4;\n', '    uint256 constant ROLE_CUSTODIAN = 5;\n', '    uint256 constant ROLE_AUDITOR = 6;\n', '    uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\n', '    uint256 constant ROLE_KYC_ADMIN = 8;\n', '    uint256 constant ROLE_FEES_ADMIN = 9;\n', '    uint256 constant ROLE_DOCS_UPLOADER = 10;\n', '    uint256 constant ROLE_KYC_RECASTER = 11;\n', '    uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\n', '\n', '    /// states\n', '    uint256 constant STATE_ZERO_UNDEFINED = 0;\n', '    uint256 constant STATE_CREATED = 1;\n', '    uint256 constant STATE_VENDOR_ORDER = 2;\n', '    uint256 constant STATE_TRANSFER = 3;\n', '    uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\n', '    uint256 constant STATE_MINTED = 5;\n', '    uint256 constant STATE_AUDIT_FAILURE = 6;\n', '    uint256 constant STATE_REPLACEMENT_ORDER = 7;\n', '    uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\n', '    uint256 constant STATE_RECASTED = 9;\n', '    uint256 constant STATE_REDEEMED = 10;\n', '    uint256 constant STATE_ADMIN_FAILURE = 11;\n', '\n', '\n', '\n', '    /// interactive contracts\n', '    bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = "i:asset:explorer";\n', '    bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = "i:directory";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = "i:mp";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = "i:mpadmin";\n', '    bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = "i:popadmin";\n', '    bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = "i:products";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN = "i:token";\n', '    bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = "i:bulk-wrapper";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = "i:token:config";\n', '    bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = "i:token:information";\n', '    bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = "i:mp:information";\n', '    bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = "i:identity";\n', '\n', '\n', '    /// controller contracts\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS = "c:asset";\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = "c:asset:recast";\n', '    bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = "c:explorer";\n', '    bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = "c:directory";\n', '    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = "c:mp";\n', '    bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = "c:mpadmin";\n', '    bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = "c:products";\n', '\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = "c:token:approval";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = "c:token:config";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = "c:token:info";\n', '    bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = "c:token:transfer";\n', '\n', '    bytes32 constant CONTRACT_CONTROLLER_JOB_ID = "c:jobid";\n', '    bytes32 constant CONTRACT_CONTROLLER_IDENTITY = "c:identity";\n', '\n', '    /// storage contracts\n', '    bytes32 constant CONTRACT_STORAGE_ASSETS = "s:asset";\n', '    bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = "s:asset:events";\n', '    bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = "s:directory";\n', '    bytes32 constant CONTRACT_STORAGE_MARKETPLACE = "s:mp";\n', '    bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = "s:products";\n', '    bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = "s:goldtoken";\n', '    bytes32 constant CONTRACT_STORAGE_JOB_ID = "s:jobid";\n', '    bytes32 constant CONTRACT_STORAGE_IDENTITY = "s:identity";\n', '\n', '    /// service contracts\n', '    bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = "sv:tdemurrage";\n', '    bytes32 constant CONTRACT_SERVICE_MARKETPLACE = "sv:mp";\n', '    bytes32 constant CONTRACT_SERVICE_DIRECTORY = "sv:directory";\n', '\n', '    /// fees distributors\n', '    bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = "fees:distributor:demurrage";\n', '    bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = "fees:distributor:recast";\n', '    bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = "fees:distributor:transfer";\n', '\n', '}\n', '\n', 'contract TokenLoggerCallback is ResolverClient, DigixConstants {\n', '\n', '  event Transfer(address indexed _from,  address indexed _to,  uint256 _value);\n', '  event Approval(address indexed _owner,  address indexed _spender,  uint256 _value);\n', '\n', '  function log_mint(address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS)\n', '           public\n', '  {\n', '    Transfer(address(0x0), _to, _value);\n', '  }\n', '\n', '  function log_recast_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_recast(address _from, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_ASSETS_RECAST)\n', '           public\n', '  {\n', '    Transfer(_from, address(0x0), _value);\n', '  }\n', '\n', '  function log_demurrage_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_SERVICE_TOKEN_DEMURRAGE)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_move_fees(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_CONFIG)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_transfer(address _from, address _to, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_TRANSFER)\n', '           public\n', '  {\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function log_approve(address _owner, address _spender, uint256 _value)\n', '           if_sender_is(CONTRACT_CONTROLLER_TOKEN_APPROVAL)\n', '           public\n', '  {\n', '    Approval(_owner, _spender, _value);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract TokenInfoController {\n', '  function get_total_supply() constant public returns (uint256 _total_supply){}\n', '  function get_allowance(address _account, address _spender) constant public returns (uint256 _allowance){}\n', '  function get_balance(address _user) constant public returns (uint256 _actual_balance){}\n', '}\n', '\n', 'contract TokenTransferController {\n', '  function put_transfer(address _sender, address _recipient, address _spender, uint256 _amount, bool _transfer_from) public returns (bool _success){}\n', '}\n', '\n', 'contract TokenApprovalController {\n', '  function approve(address _account, address _spender, uint256 _amount) public returns (bool _success){}\n', '}\n', '\n', '/// The interface of a contract that can receive tokens from transferAndCall()\n', 'contract TokenReceiver {\n', '  function tokenFallback(address from, uint256 amount, bytes32 data) public returns (bool success);\n', '}\n', '\n', '/// @title DGX2.0 ERC-20 Token. ERC-677 is also implemented https://github.com/ethereum/EIPs/issues/677\n', '/// @author Digix Holdings Pte Ltd\n', 'contract Token is TokenLoggerCallback {\n', '\n', '  string public constant name = "Digix Gold Token";\n', '  string public constant symbol = "DGX";\n', '  uint8 public constant decimals = 9;\n', '\n', '  function Token(address _resolver) public\n', '  {\n', '    require(init(CONTRACT_INTERACTIVE_TOKEN, _resolver));\n', '  }\n', '\n', '  /// @notice show the total supply of gold tokens\n', '  /// @return {\n', '  ///    "totalSupply": "total number of tokens"\n', '  /// }\n', '  function totalSupply()\n', '           constant\n', '           public\n', '           returns (uint256 _total_supply)\n', '  {\n', '    _total_supply = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_total_supply();\n', '  }\n', '\n', '  /// @notice display balance of given account\n', '  /// @param _owner the account to query\n', '  /// @return {\n', '  ///    "balance": "balance of the given account in nanograms"\n', '  /// }\n', '  function balanceOf(address _owner)\n', '           constant\n', '           public\n', '           returns (uint256 balance)\n', '  {\n', '    balance = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_balance(_owner);\n', '  }\n', '\n', '  /// @notice transfer amount to account\n', '  /// @param _to account to send to\n', '  /// @param _value the amount in nanograms to send\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transfer(address _to, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success =\n', '      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(msg.sender, _to, 0x0, _value, false);\n', '  }\n', '\n', '  /// @notice transfer amount to account from account deducting from spender allowance\n', '  /// @param _to account to send to\n', '  /// @param _from account to send from\n', '  /// @param _value the amount in nanograms to send\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success =\n', '      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(_from, _to, msg.sender,\n', '                                                                             _value, true);\n', '  }\n', '\n', '  /// @notice implements transferAndCall() of ERC677\n', '  /// @param _receiver the contract to receive the token\n', '  /// @param _amount the amount of tokens to be transfered\n', '  /// @param _data the data to be passed to the tokenFallback function of the receiving contract\n', '  /// @return {\n', '  ///    "success": "returns true if successful"\n', '  /// }\n', '  function transferAndCall(address _receiver, uint256 _amount, bytes32 _data)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    transfer(_receiver, _amount);\n', '    success = TokenReceiver(_receiver).tokenFallback(msg.sender, _amount, _data);\n', '    require(success);\n', '  }\n', '\n', '  /// @notice approve given spender to transfer given amount this will set allowance to 0 if current value is non-zero\n', '  /// @param _spender the account that is given an allowance\n', '  /// @param _value the amount in nanograms to approve\n', '  /// @return {\n', '  ///   "success": "returns true if successful"\n', '  /// }\n', '  function approve(address _spender, uint256 _value)\n', '           public\n', '           returns (bool success)\n', '  {\n', '    success = TokenApprovalController(get_contract(CONTRACT_CONTROLLER_TOKEN_APPROVAL)).approve(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /// @notice check the spending allowance of a given user from a given account\n', '  /// @param _owner the account to spend from\n', '  /// @param _spender the spender\n', '  /// @return {\n', '  ///    "remaining": "the remaining allowance in nanograms"\n', '  /// }\n', '  function allowance(address _owner, address _spender)\n', '           constant\n', '           public\n', '           returns (uint256 remaining)\n', '  {\n', '    remaining = TokenInfoController(get_contract(CONTRACT_CONTROLLER_TOKEN_INFO)).get_allowance(_owner, _spender);\n', '  }\n', '\n', '}']
