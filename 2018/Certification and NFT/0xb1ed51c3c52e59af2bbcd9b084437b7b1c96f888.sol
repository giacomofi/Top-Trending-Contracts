['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface token { \n', '  function transfer(address, uint) external returns (bool);\n', '  function transferFrom(address, address, uint) external returns (bool); \n', '  function allowance(address, address) external constant returns (uint256);\n', '  function balanceOf(address) external constant returns (uint256);\n', '}\n', '\n', '/** LOGIC DESCRIPTION\n', ' * 11% fees in and out for ETH\n', ' * 11% fees in and out for NOVA\n', ' *\n', ' * ETH fees split: \n', ' * 6% to nova holders\n', ' * 4% to eth holders\n', ' * 1% to fixed address\n', ' * \n', ' * NOVA fees split: \n', ' * 6% to nova holders\n', ' * 4% to eth holders\n', ' * 1% airdrop to a random address based on their nova shares\n', ' * rules: \n', ' * - you need to have both nova and eth to get dividends\n', ' */\n', '\n', 'contract NovaBox is Ownable {\n', '  \n', '  using SafeMath for uint;\n', '  token tokenReward;\n', '\n', '  \n', '  constructor() public {\n', '    tokenReward = token(0x72FBc0fc1446f5AcCC1B083F0852a7ef70a8ec9f);\n', '  }\n', '\n', '  event AirDrop(address to, uint amount, uint randomTicket);\n', '\n', '  // ether contributions\n', '  mapping (address => uint) public contributionsEth;\n', '  // token contributions\n', '  mapping (address => uint) public contributionsToken;\n', '\n', '  // investors list who have deposited BOTH ether and token\n', '  mapping (address => uint) public indexes;\n', '  mapping (uint => address) public addresses;\n', '  uint256 public lastIndex = 0;\n', '\n', '  function addToList(address sender) private {\n', '    // if the sender is not in the list\n', '    if (indexes[sender] == 0) {\n', '      // add the sender to the list\n', '      lastIndex++;\n', '      addresses[lastIndex] = sender;\n', '      indexes[sender] = lastIndex;\n', '    }\n', '  }\n', '  function removeFromList(address sender) private {\n', '    // if the sender is in temp eth list \n', '    if (indexes[sender] > 0) {\n', '      // remove the sender from temp eth list\n', '      addresses[indexes[sender]] = addresses[lastIndex];\n', '      indexes[addresses[lastIndex]] = indexes[sender];\n', '      indexes[sender] = 0;\n', '      delete addresses[lastIndex];\n', '      lastIndex--;\n', '    }\n', '  }\n', '\n', '  // desposit ether\n', '  function () payable public {\n', '    \n', '    uint weiAmount = msg.value;\n', '    address sender = msg.sender;\n', '\n', '    // number of ether sent must be greater than 0\n', '    require(weiAmount > 0);\n', '\n', '    uint _89percent = weiAmount.mul(89).div(100);\n', '    uint _6percent = weiAmount.mul(6).div(100);\n', '    uint _4percent = weiAmount.mul(4).div(100);\n', '    uint _1percent = weiAmount.mul(1).div(100);\n', '\n', '\n', '    \n', '\n', '\n', '    distributeEth(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    ); \n', '    //1% goes to REX Investors\n', '    owner.transfer(_1percent);\n', '\n', '    contributionsEth[sender] = contributionsEth[sender].add(_89percent);\n', '\n', '    // if the sender has also deposited tokens, add sender to list\n', '    if (contributionsToken[sender]>0) addToList(sender);\n', '  }\n', '\n', '  // withdraw ether\n', '  function withdrawEth(uint amount) public {\n', '    address sender = msg.sender;\n', '    require(amount>0 && contributionsEth[sender] >= amount);\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '\n', '    contributionsEth[sender] = contributionsEth[sender].sub(amount);\n', '\n', '    // if the sender has withdrawn all their eth\n', '      // remove the sender from list\n', '    if (contributionsEth[sender] == 0) removeFromList(sender);\n', '\n', '    sender.transfer(_89percent);\n', '    distributeEth(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    );\n', '    owner.transfer(_1percent);\n', '  }\n', '\n', '  // deposit tokens\n', '  function depositTokens(address randomAddr, uint randomTicket) public {\n', '   \n', '\n', '    address sender = msg.sender;\n', '    uint amount = tokenReward.allowance(sender, address(this));\n', '    \n', '    // number of allowed tokens must be greater than 0\n', '    // if it is then transfer the allowed tokens from sender to the contract\n', '    // if not transferred then throw\n', '    require(amount>0 && tokenReward.transferFrom(sender, address(this), amount));\n', '\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '    \n', '    \n', '\n', '    distributeTokens(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '      );\n', '    tokenReward.transfer(randomAddr, _1percent);\n', '    // 1% for Airdrop\n', '    emit AirDrop(randomAddr, _1percent, randomTicket);\n', '\n', '    contributionsToken[sender] = contributionsToken[sender].add(_89percent);\n', '    // if the sender has also contributed ether add sender to list\n', '    if (contributionsEth[sender]>0) addToList(sender);\n', '  }\n', '\n', '  // withdraw tokens\n', '  function withdrawTokens(uint amount, address randomAddr, uint randomTicket) public {\n', '    address sender = msg.sender;\n', '    // requested amount must be greater than 0 and \n', '    // the sender must have contributed tokens no less than `amount`\n', '    require(amount>0 && contributionsToken[sender]>=amount);\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '\n', '    contributionsToken[sender] = contributionsToken[sender].sub(amount);\n', '\n', '    // if sender withdrawn all their tokens, remove them from list\n', '    if (contributionsToken[sender] == 0) removeFromList(sender);\n', '\n', '    tokenReward.transfer(sender, _89percent);\n', '    distributeTokens(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    );\n', '    // airdropToRandom(_1percent);  \n', '    tokenReward.transfer(randomAddr, _1percent);\n', '    emit AirDrop(randomAddr, _1percent, randomTicket);\n', '  }\n', '\n', '  function distributeTokens(uint _6percent, uint _4percent) private {\n', '    uint totalTokens = getTotalTokens();\n', '    uint totalWei = getTotalWei();\n', '\n', '    // loop over investors (`holders`) list\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '\n', '      address holder = addresses[i];\n', '      // `holder` will get part of 6% fee based on their token shares\n', '      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\n', '      // `holder` will get part of 4% fee based on their ether shares\n', '      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\n', '      // Transfer tokens equal to the sum of the fee parts to `holder`\n', '      tokenReward.transfer(holder,_rewardTokens.add(_rewardWei));\n', '    }\n', '  }\n', '\n', '  function distributeEth(uint _6percent, uint _4percent) private {\n', '    uint totalTokens = getTotalTokens();\n', '    uint totalWei = getTotalWei();\n', '\n', '    // loop over investors (`holders`) list\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      address holder = addresses[i];\n', '      // `holder` will get part of 6% fee based on their token shares\n', '      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\n', '      // `holder` will get part of 4% fee based on their ether shares\n', '      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\n', '      // Transfer ether equal to the sum of the fee parts to `holder`\n', '      holder.transfer(_rewardTokens.add(_rewardWei));\n', '    }\n', '  }\n', '\n', '\n', '  // get sum of tokens contributed by the ether investors\n', '  function getTotalTokens() public view returns (uint) {\n', '    uint result;\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      result = result.add(contributionsToken[addresses[i]]);\n', '    }\n', '    return result;\n', '  }\n', '\n', '  // get the sum of wei contributed by the token investors\n', '  function getTotalWei() public view returns (uint) {\n', '    uint result;\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      result = result.add(contributionsEth[addresses[i]]);\n', '    }\n', '    return result;\n', '  }\n', '\n', '\n', '  // get the list of investors\n', '  function getList() public view returns (address[], uint[]) {\n', '    address[] memory _addrs = new address[](lastIndex);\n', '    uint[] memory _contributions = new uint[](lastIndex);\n', '\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      _addrs[i-1] = addresses[i];\n', '      _contributions[i-1] = contributionsToken[addresses[i]];\n', '    }\n', '    return (_addrs, _contributions);\n', '  }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface token { \n', '  function transfer(address, uint) external returns (bool);\n', '  function transferFrom(address, address, uint) external returns (bool); \n', '  function allowance(address, address) external constant returns (uint256);\n', '  function balanceOf(address) external constant returns (uint256);\n', '}\n', '\n', '/** LOGIC DESCRIPTION\n', ' * 11% fees in and out for ETH\n', ' * 11% fees in and out for NOVA\n', ' *\n', ' * ETH fees split: \n', ' * 6% to nova holders\n', ' * 4% to eth holders\n', ' * 1% to fixed address\n', ' * \n', ' * NOVA fees split: \n', ' * 6% to nova holders\n', ' * 4% to eth holders\n', ' * 1% airdrop to a random address based on their nova shares\n', ' * rules: \n', ' * - you need to have both nova and eth to get dividends\n', ' */\n', '\n', 'contract NovaBox is Ownable {\n', '  \n', '  using SafeMath for uint;\n', '  token tokenReward;\n', '\n', '  \n', '  constructor() public {\n', '    tokenReward = token(0x72FBc0fc1446f5AcCC1B083F0852a7ef70a8ec9f);\n', '  }\n', '\n', '  event AirDrop(address to, uint amount, uint randomTicket);\n', '\n', '  // ether contributions\n', '  mapping (address => uint) public contributionsEth;\n', '  // token contributions\n', '  mapping (address => uint) public contributionsToken;\n', '\n', '  // investors list who have deposited BOTH ether and token\n', '  mapping (address => uint) public indexes;\n', '  mapping (uint => address) public addresses;\n', '  uint256 public lastIndex = 0;\n', '\n', '  function addToList(address sender) private {\n', '    // if the sender is not in the list\n', '    if (indexes[sender] == 0) {\n', '      // add the sender to the list\n', '      lastIndex++;\n', '      addresses[lastIndex] = sender;\n', '      indexes[sender] = lastIndex;\n', '    }\n', '  }\n', '  function removeFromList(address sender) private {\n', '    // if the sender is in temp eth list \n', '    if (indexes[sender] > 0) {\n', '      // remove the sender from temp eth list\n', '      addresses[indexes[sender]] = addresses[lastIndex];\n', '      indexes[addresses[lastIndex]] = indexes[sender];\n', '      indexes[sender] = 0;\n', '      delete addresses[lastIndex];\n', '      lastIndex--;\n', '    }\n', '  }\n', '\n', '  // desposit ether\n', '  function () payable public {\n', '    \n', '    uint weiAmount = msg.value;\n', '    address sender = msg.sender;\n', '\n', '    // number of ether sent must be greater than 0\n', '    require(weiAmount > 0);\n', '\n', '    uint _89percent = weiAmount.mul(89).div(100);\n', '    uint _6percent = weiAmount.mul(6).div(100);\n', '    uint _4percent = weiAmount.mul(4).div(100);\n', '    uint _1percent = weiAmount.mul(1).div(100);\n', '\n', '\n', '    \n', '\n', '\n', '    distributeEth(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    ); \n', '    //1% goes to REX Investors\n', '    owner.transfer(_1percent);\n', '\n', '    contributionsEth[sender] = contributionsEth[sender].add(_89percent);\n', '\n', '    // if the sender has also deposited tokens, add sender to list\n', '    if (contributionsToken[sender]>0) addToList(sender);\n', '  }\n', '\n', '  // withdraw ether\n', '  function withdrawEth(uint amount) public {\n', '    address sender = msg.sender;\n', '    require(amount>0 && contributionsEth[sender] >= amount);\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '\n', '    contributionsEth[sender] = contributionsEth[sender].sub(amount);\n', '\n', '    // if the sender has withdrawn all their eth\n', '      // remove the sender from list\n', '    if (contributionsEth[sender] == 0) removeFromList(sender);\n', '\n', '    sender.transfer(_89percent);\n', '    distributeEth(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    );\n', '    owner.transfer(_1percent);\n', '  }\n', '\n', '  // deposit tokens\n', '  function depositTokens(address randomAddr, uint randomTicket) public {\n', '   \n', '\n', '    address sender = msg.sender;\n', '    uint amount = tokenReward.allowance(sender, address(this));\n', '    \n', '    // number of allowed tokens must be greater than 0\n', '    // if it is then transfer the allowed tokens from sender to the contract\n', '    // if not transferred then throw\n', '    require(amount>0 && tokenReward.transferFrom(sender, address(this), amount));\n', '\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '    \n', '    \n', '\n', '    distributeTokens(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '      );\n', '    tokenReward.transfer(randomAddr, _1percent);\n', '    // 1% for Airdrop\n', '    emit AirDrop(randomAddr, _1percent, randomTicket);\n', '\n', '    contributionsToken[sender] = contributionsToken[sender].add(_89percent);\n', '    // if the sender has also contributed ether add sender to list\n', '    if (contributionsEth[sender]>0) addToList(sender);\n', '  }\n', '\n', '  // withdraw tokens\n', '  function withdrawTokens(uint amount, address randomAddr, uint randomTicket) public {\n', '    address sender = msg.sender;\n', '    // requested amount must be greater than 0 and \n', '    // the sender must have contributed tokens no less than `amount`\n', '    require(amount>0 && contributionsToken[sender]>=amount);\n', '\n', '    uint _89percent = amount.mul(89).div(100);\n', '    uint _6percent = amount.mul(6).div(100);\n', '    uint _4percent = amount.mul(4).div(100);\n', '    uint _1percent = amount.mul(1).div(100);\n', '\n', '    contributionsToken[sender] = contributionsToken[sender].sub(amount);\n', '\n', '    // if sender withdrawn all their tokens, remove them from list\n', '    if (contributionsToken[sender] == 0) removeFromList(sender);\n', '\n', '    tokenReward.transfer(sender, _89percent);\n', '    distributeTokens(\n', '      _6percent, // to nova investors\n', '      _4percent  // to eth investors\n', '    );\n', '    // airdropToRandom(_1percent);  \n', '    tokenReward.transfer(randomAddr, _1percent);\n', '    emit AirDrop(randomAddr, _1percent, randomTicket);\n', '  }\n', '\n', '  function distributeTokens(uint _6percent, uint _4percent) private {\n', '    uint totalTokens = getTotalTokens();\n', '    uint totalWei = getTotalWei();\n', '\n', '    // loop over investors (`holders`) list\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '\n', '      address holder = addresses[i];\n', '      // `holder` will get part of 6% fee based on their token shares\n', '      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\n', '      // `holder` will get part of 4% fee based on their ether shares\n', '      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\n', '      // Transfer tokens equal to the sum of the fee parts to `holder`\n', '      tokenReward.transfer(holder,_rewardTokens.add(_rewardWei));\n', '    }\n', '  }\n', '\n', '  function distributeEth(uint _6percent, uint _4percent) private {\n', '    uint totalTokens = getTotalTokens();\n', '    uint totalWei = getTotalWei();\n', '\n', '    // loop over investors (`holders`) list\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      address holder = addresses[i];\n', '      // `holder` will get part of 6% fee based on their token shares\n', '      uint _rewardTokens = contributionsToken[holder].mul(_6percent).div(totalTokens);\n', '      // `holder` will get part of 4% fee based on their ether shares\n', '      uint _rewardWei = contributionsEth[holder].mul(_4percent).div(totalWei);\n', '      // Transfer ether equal to the sum of the fee parts to `holder`\n', '      holder.transfer(_rewardTokens.add(_rewardWei));\n', '    }\n', '  }\n', '\n', '\n', '  // get sum of tokens contributed by the ether investors\n', '  function getTotalTokens() public view returns (uint) {\n', '    uint result;\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      result = result.add(contributionsToken[addresses[i]]);\n', '    }\n', '    return result;\n', '  }\n', '\n', '  // get the sum of wei contributed by the token investors\n', '  function getTotalWei() public view returns (uint) {\n', '    uint result;\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      result = result.add(contributionsEth[addresses[i]]);\n', '    }\n', '    return result;\n', '  }\n', '\n', '\n', '  // get the list of investors\n', '  function getList() public view returns (address[], uint[]) {\n', '    address[] memory _addrs = new address[](lastIndex);\n', '    uint[] memory _contributions = new uint[](lastIndex);\n', '\n', '    for (uint i = 1; i <= lastIndex; i++) {\n', '      _addrs[i-1] = addresses[i];\n', '      _contributions[i-1] = contributionsToken[addresses[i]];\n', '    }\n', '    return (_addrs, _contributions);\n', '  }\n', '\n', '\n', '\n', '}']
