['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract BablosTokenInterface is ERC20 {\n', '  bool public frozen;\n', '  function burn(uint256 _value) public;\n', '  function setSale(address _sale) public;\n', '  function thaw() external;\n', '}\n', '\n', 'contract PriceUpdaterInterface {\n', '  enum Currency { ETH, BTC, WME, WMZ, WMR, WMX }\n', '\n', '  uint public decimalPrecision = 3;\n', '\n', '  mapping(uint => uint) public price;\n', '}\n', '\n', 'contract BablosCrowdsaleWalletInterface {\n', '  enum State {\n', '    // gathering funds\n', '    GATHERING,\n', '    // returning funds to investors\n', '    REFUNDING,\n', '    // funds can be pulled by owners\n', '    SUCCEEDED\n', '  }\n', '\n', '  event StateChanged(State state);\n', '  event Invested(address indexed investor, PriceUpdaterInterface.Currency currency, uint amount, uint tokensReceived);\n', '  event EtherWithdrawan(address indexed to, uint value);\n', '  event RefundSent(address indexed to, uint value);\n', '  event ControllerRetired(address was);\n', '\n', '  /// @dev price updater interface\n', '  PriceUpdaterInterface public priceUpdater;\n', '\n', '  /// @notice total amount of investments in currencies\n', '  mapping(uint => uint) public totalInvested;\n', '\n', '  /// @notice state of the registry\n', '  State public state = State.GATHERING;\n', '\n', '  /// @dev balances of investors in wei\n', '  mapping(address => uint) public weiBalances;\n', '\n', '  /// @dev balances of tokens sold to investors\n', '  mapping(address => uint) public tokenBalances;\n', '\n', '  /// @dev list of unique investors\n', '  address[] public investors;\n', '\n', '  /// @dev token accepted for refunds\n', '  BablosTokenInterface public token;\n', '\n', '  /// @dev operations will be controlled by this address\n', '  address public controller;\n', '\n', "  /// @dev the team's tokens percent\n", '  uint public teamPercent;\n', '\n', '  /// @dev tokens sent to initial PR - they will be substracted, when tokens will be burn\n', '  uint public prTokens;\n', '  \n', '  /// @dev performs only allowed state transitions\n', '  function changeState(State _newState) external;\n', '\n', '  /// @dev records an investment\n', '  /// @param _investor who invested\n', '  /// @param _tokenAmount the amount of token bought, calculation is handled by ICO\n', '  /// @param _currency the currency in which investor invested\n', '  /// @param _amount the invested amount\n', '  function invested(address _investor, uint _tokenAmount, PriceUpdaterInterface.Currency _currency, uint _amount) external payable;\n', '\n', '  /// @dev get total invested in ETH\n', '  function getTotalInvestedEther() external view returns (uint);\n', '\n', '  /// @dev get total invested in EUR\n', '  function getTotalInvestedEur() external view returns (uint);\n', '\n', '  /// @notice withdraw `_value` of ether to his address, can be called if crowdsale succeeded\n', '  /// @param _value amount of wei to withdraw\n', '  function withdrawEther(uint _value) external;\n', '\n', '  /// @notice owner: send `_value` of tokens to his address, can be called if\n', '  /// crowdsale failed and some of the investors refunded the ether\n', '  /// @param _value amount of token-wei to send\n', '  function withdrawTokens(uint _value) external;\n', '\n', '  /// @notice withdraw accumulated balance, called by payee in case crowdsale failed\n', '  /// @dev caller should approve tokens bought during ICO to this contract\n', '  function withdrawPayments() external;\n', '\n', '  /// @dev returns investors count\n', '  function getInvestorsCount() external view returns (uint);\n', '\n', '  /// @dev ability for controller to step down\n', '  function detachController() external;\n', '\n', "  /// @dev unhold holded team's tokens\n", '  function unholdTeamTokens() external;\n', '}\n', '\n', 'contract BablosCrowdsaleWallet is BablosCrowdsaleWalletInterface, Ownable, ReentrancyGuard {\n', '  using SafeMath for uint;\n', '\n', '  modifier requiresState(State _state) {\n', '    require(state == _state);\n', '    _;\n', '  }\n', '\n', '  modifier onlyController() {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '  \n', '  constructor(\n', '    BablosTokenInterface _token, \n', '    address _controller, \n', '    PriceUpdaterInterface _priceUpdater, \n', '    uint _teamPercent, \n', '    uint _prTokens) \n', '      public \n', '  {\n', '    token = _token;\n', '    controller = _controller;\n', '    priceUpdater = _priceUpdater;\n', '    teamPercent = _teamPercent;\n', '    prTokens = _prTokens;\n', '  }\n', '\n', '  function getTotalInvestedEther() external view returns (uint) {\n', '    uint etherPrice = priceUpdater.price(uint(PriceUpdaterInterface.Currency.ETH));\n', '    uint totalInvestedEth = totalInvested[uint(PriceUpdaterInterface.Currency.ETH)];\n', '    uint totalAmount = _totalInvestedNonEther();\n', '    return totalAmount.mul(1 ether).div(etherPrice).add(totalInvestedEth);\n', '  }\n', '\n', '  function getTotalInvestedEur() external view returns (uint) {\n', '    uint totalAmount = _totalInvestedNonEther();\n', '    uint etherAmount = totalInvested[uint(PriceUpdaterInterface.Currency.ETH)]\n', '      .mul(priceUpdater.price(uint(PriceUpdaterInterface.Currency.ETH)))\n', '      .div(1 ether);\n', '    return totalAmount.add(etherAmount);\n', '  }\n', '\n', '  /// @dev total invested in EUR within ETH amount\n', '  function _totalInvestedNonEther() internal view returns (uint) {\n', '    uint totalAmount;\n', '    uint precision = priceUpdater.decimalPrecision();\n', '    // BTC\n', '    uint btcAmount = totalInvested[uint(PriceUpdaterInterface.Currency.BTC)]\n', '      .mul(10 ** precision)\n', '      .div(priceUpdater.price(uint(PriceUpdaterInterface.Currency.BTC)));\n', '    totalAmount = totalAmount.add(btcAmount);\n', '    // WME\n', '    uint wmeAmount = totalInvested[uint(PriceUpdaterInterface.Currency.WME)]\n', '      .mul(10 ** precision)\n', '      .div(priceUpdater.price(uint(PriceUpdaterInterface.Currency.WME)));\n', '    totalAmount = totalAmount.add(wmeAmount);\n', '    // WMZ\n', '    uint wmzAmount = totalInvested[uint(PriceUpdaterInterface.Currency.WMZ)]\n', '      .mul(10 ** precision)\n', '      .div(priceUpdater.price(uint(PriceUpdaterInterface.Currency.WMZ)));\n', '    totalAmount = totalAmount.add(wmzAmount);\n', '    // WMR\n', '    uint wmrAmount = totalInvested[uint(PriceUpdaterInterface.Currency.WMR)]\n', '      .mul(10 ** precision)\n', '      .div(priceUpdater.price(uint(PriceUpdaterInterface.Currency.WMR)));\n', '    totalAmount = totalAmount.add(wmrAmount);\n', '    // WMX\n', '    uint wmxAmount = totalInvested[uint(PriceUpdaterInterface.Currency.WMX)]\n', '      .mul(10 ** precision)\n', '      .div(priceUpdater.price(uint(PriceUpdaterInterface.Currency.WMX)));\n', '    totalAmount = totalAmount.add(wmxAmount);\n', '    return totalAmount;\n', '  }\n', '\n', '  function changeState(State _newState) external onlyController {\n', '    assert(state != _newState);\n', '\n', '    if (State.GATHERING == state) {\n', '      assert(_newState == State.REFUNDING || _newState == State.SUCCEEDED);\n', '    } else {\n', '      assert(false);\n', '    }\n', '\n', '    state = _newState;\n', '    emit StateChanged(state);\n', '  }\n', '\n', '  function invested(\n', '    address _investor,\n', '    uint _tokenAmount,\n', '    PriceUpdaterInterface.Currency _currency,\n', '    uint _amount) \n', '      external \n', '      payable\n', '      onlyController\n', '  {\n', '    require(state == State.GATHERING || state == State.SUCCEEDED);\n', '    uint amount;\n', '    if (_currency == PriceUpdaterInterface.Currency.ETH) {\n', '      amount = msg.value;\n', '      weiBalances[_investor] = weiBalances[_investor].add(amount);\n', '    } else {\n', '      amount = _amount;\n', '    }\n', '    require(amount != 0);\n', '    require(_tokenAmount != 0);\n', '    assert(_investor != controller);\n', '\n', '    // register investor\n', '    if (tokenBalances[_investor] == 0) {\n', '      investors.push(_investor);\n', '    }\n', '\n', '    // register payment\n', '    totalInvested[uint(_currency)] = totalInvested[uint(_currency)].add(amount);\n', '    tokenBalances[_investor] = tokenBalances[_investor].add(_tokenAmount);\n', '\n', '    emit Invested(_investor, _currency, amount, _tokenAmount);\n', '  }\n', '\n', '  function withdrawEther(uint _value)\n', '    external\n', '    onlyOwner\n', '    requiresState(State.SUCCEEDED) \n', '  {\n', '    require(_value > 0 && address(this).balance >= _value);\n', '    owner.transfer(_value);\n', '    emit EtherWithdrawan(owner, _value);\n', '  }\n', '\n', '  function withdrawTokens(uint _value)\n', '    external\n', '    onlyOwner\n', '    requiresState(State.REFUNDING)\n', '  {\n', '    require(_value > 0 && token.balanceOf(address(this)) >= _value);\n', '    token.transfer(owner, _value);\n', '  }\n', '\n', '  function withdrawPayments()\n', '    external\n', '    nonReentrant\n', '    requiresState(State.REFUNDING)\n', '  {\n', '    address payee = msg.sender;\n', '    uint payment = weiBalances[payee];\n', '    uint tokens = tokenBalances[payee];\n', '\n', '    // check that there is some ether to withdraw\n', '    require(payment != 0);\n', '    // check that the contract holds enough ether\n', '    require(address(this).balance >= payment);\n', '    // check that the investor (payee) gives back all tokens bought during ICO\n', '    require(token.allowance(payee, address(this)) >= tokenBalances[payee]);\n', '\n', '    totalInvested[uint(PriceUpdaterInterface.Currency.ETH)] = totalInvested[uint(PriceUpdaterInterface.Currency.ETH)].sub(payment);\n', '    weiBalances[payee] = 0;\n', '    tokenBalances[payee] = 0;\n', '\n', '    token.transferFrom(payee, address(this), tokens);\n', '\n', '    payee.transfer(payment);\n', '    emit RefundSent(payee, payment);\n', '  }\n', '\n', '  function getInvestorsCount() external view returns (uint) { return investors.length; }\n', '\n', '  function detachController() external onlyController {\n', '    address was = controller;\n', '    controller = address(0);\n', '    emit ControllerRetired(was);\n', '  }\n', '\n', '  function unholdTeamTokens() external onlyController {\n', '    uint tokens = token.balanceOf(address(this));\n', '    if (state == State.SUCCEEDED) {\n', '      uint soldTokens = token.totalSupply().sub(token.balanceOf(address(this))).sub(prTokens);\n', '      uint soldPecent = 100 - teamPercent;\n', '      uint teamShares = soldTokens.mul(teamPercent).div(soldPecent).sub(prTokens);\n', '      token.transfer(owner, teamShares);\n', '      token.burn(token.balanceOf(address(this)));\n', '    } else {\n', '      token.approve(owner, tokens);\n', '    }\n', '  }\n', '}']