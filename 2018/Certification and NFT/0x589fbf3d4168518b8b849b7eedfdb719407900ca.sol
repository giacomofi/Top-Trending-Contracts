['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/ERC20-token.sol\n', '\n', '/**\n', ' * @title ERC20 interface \n', ' * \n', ' */\n', 'contract ERC20 {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/OwnableWithAdmin.sol\n', '\n', '/**\n', ' * @title OwnableWithAdmin \n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract OwnableWithAdmin {\n', '  address public owner;\n', '  address public adminOwner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    adminOwner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the admin.\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(msg.sender == adminOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or admin.\n', '   */\n', '  modifier onlyOwnerOrAdmin() {\n', '    require(msg.sender == adminOwner || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current adminOwner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferAdminOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(adminOwner, newOwner);\n', '    adminOwner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string){\n', '      if (i == 0) return "0";\n', '      uint j = i;\n', '      uint length;\n', '      while (j != 0){\n', '          length++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(length);\n', '      uint k = length - 1;\n', '      while (i != 0){\n', '          bstr[k--] = byte(48 + i % 10);\n', '          i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', ' \n', '  \n', '}\n', '\n', '// File: contracts/AirDropLight.sol\n', '\n', '/**\n', ' * @title AirDrop Light Direct Airdrop\n', ' * @notice Contract is not payable.\n', ' * Owner or admin can allocate tokens.\n', ' * Tokens will be released direct. \n', ' *\n', ' *\n', ' */\n', 'contract AirDropLight is OwnableWithAdmin {\n', '  using SafeMath for uint256;\n', '  \n', '  // Amount of tokens claimed\n', '  uint256 public grandTotalClaimed = 0;\n', '\n', '  // The token being sold\n', '  ERC20 public token;\n', '\n', '  // Max amount in one airdrop\n', '  uint256  maxDirect = 10000 * (10**uint256(18));\n', '\n', '  // Recipients\n', '  mapping(address => bool) public recipients;\n', '\n', '  // List of all addresses\n', '  address[] public addresses;\n', '   \n', '  constructor(ERC20 _token) public {\n', '     \n', '    require(_token != address(0));\n', '\n', '    token = _token;\n', '\n', '  }\n', '\n', '  \n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () public {\n', '    //Not payable\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Transfer tokens direct\n', '    * @param _recipients Array of wallets\n', '    * @param _tokenAmount Amount Allocated tokens + 18 decimals\n', '    */\n', '  function transferManyDirect (address[] _recipients, uint256 _tokenAmount) onlyOwnerOrAdmin  public{\n', '    for (uint256 i = 0; i < _recipients.length; i++) {\n', '      transferDirect(_recipients[i],_tokenAmount);\n', '    }    \n', '  }\n', '\n', '        \n', '  /**\n', '    * @dev Transfer tokens direct to recipient without allocation. \n', "    * _recipient can only get one transaction and _tokens can't be above maxDirect value\n", '    *  \n', '    */\n', '  function transferDirect(address _recipient,uint256 _tokens) public{\n', '\n', '    //Check if contract has tokens\n', '    require(token.balanceOf(this)>=_tokens);\n', '    \n', '    //Check max value\n', '    require(_tokens < maxDirect );\n', '\n', '    //Check if _recipient already have got tokens\n', '    require(!recipients[_recipient]); \n', '    recipients[_recipient] = true;\n', '  \n', '    //Transfer tokens\n', '    require(token.transfer(_recipient, _tokens));\n', '\n', '    //Add claimed tokens to grandTotalClaimed\n', '    grandTotalClaimed = grandTotalClaimed.add(_tokens); \n', '     \n', '  }\n', '  \n', '\n', '  // Allow transfer of tokens back to owner or reserve wallet\n', '  function returnTokens() public onlyOwner {\n', '    uint256 balance = token.balanceOf(this);\n', '    require(token.transfer(owner, balance));\n', '  }\n', '\n', '  // Owner can transfer tokens that are sent here by mistake\n', '  function refundTokens(address _recipient, ERC20 _token) public onlyOwner {\n', '    uint256 balance = _token.balanceOf(this);\n', '    require(_token.transfer(_recipient, balance));\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/BYTM/BYTMAirDropLight.sol\n', '\n', '/**\n', ' * @title BYTMAirDropLight\n', ' *  \n', ' *\n', '*/\n', 'contract BYTMAirDropLight is AirDropLight {\n', '  constructor(   \n', '    ERC20 _token\n', '  ) public AirDropLight(_token) {\n', '\n', '     \n', '\n', '  }\n', '}']