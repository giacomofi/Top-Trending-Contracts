['pragma solidity ^0.4.8;\n', '\n', 'contract Rubik {\n', '\n', '    event Submission(address submitter, uint8[] moves);\n', '    event NewLeader(address submitter, uint8[] moves);\n', '\n', '    enum Color {Red, Blue, Yellow, Green, White, Orange}\n', '    Color[9][6] state;\n', '\n', '    address public owner = msg.sender;\n', '\n', '    /* This variable tracks the current winner\n', '     e.g. the player/address who has submitted a valid solution\n', '     having the lowest number of moves\n', '\n', '     Initialize the address to owner so the creator can withdraw\n', '     the funds in case nobody submits a valid solution.\n', '     */\n', '    address public currentWinner = msg.sender;\n', '\n', '    /*\n', '        Keep the track of the number of moves that is\n', '        found in the current winning solution. Set the initial\n', '        value to something very large so that any valid solution\n', '        will override it.\n', '    */\n', '    uint currentWinnerMoveCount = 9000;\n', '\n', '\n', '    /*\n', '      The time when the contest ends. After this time it is not\n', '      possible to submit new solutions and the current winner can\n', '      claim the reward.\n', '\n', '      The the end time to 30 days after the contract has been deployed.\n', '    */\n', '    uint contestEndTime = now + 2592000;\n', '\n', '    uint8 constant FRONT = 0;\n', '    uint8 constant LEFT = 1;\n', '    uint8 constant UP = 2;\n', '    uint8 constant RIGHT = 3;\n', '    uint8 constant DOWN = 4;\n', '    uint8 constant BACK = 5;\n', '\n', '    /*\n', '        Set the initial state for the cube in the constructor.\n', '        This is the puzzle you have to solve.\n', '    */\n', '\n', '    function Rubik() public {\n', '        state[FRONT][0] = Color.Green;\n', '        state[FRONT][1] = Color.Green;\n', '        state[FRONT][2] = Color.Red;\n', '        state[FRONT][3] = Color.Yellow;\n', '        state[FRONT][4] = Color.Red;\n', '        state[FRONT][5] = Color.Green;\n', '        state[FRONT][6] = Color.Red;\n', '        state[FRONT][7] = Color.Yellow;\n', '        state[FRONT][8] = Color.Blue;\n', '\n', '        state[LEFT][0] = Color.White;\n', '        state[LEFT][1] = Color.White;\n', '        state[LEFT][2] = Color.Yellow;\n', '        state[LEFT][3] = Color.Red;\n', '        state[LEFT][4] = Color.Blue;\n', '        state[LEFT][5] = Color.White;\n', '        state[LEFT][6] = Color.Red;\n', '        state[LEFT][7] = Color.Red;\n', '        state[LEFT][8] = Color.Blue;\n', '\n', '        state[UP][0] = Color.Green;\n', '        state[UP][1] = Color.Blue;\n', '        state[UP][2] = Color.Yellow;\n', '        state[UP][3] = Color.White;\n', '        state[UP][4] = Color.Yellow;\n', '        state[UP][5] = Color.Orange;\n', '        state[UP][6] = Color.White;\n', '        state[UP][7] = Color.Blue;\n', '        state[UP][8] = Color.Blue;\n', '\n', '        state[RIGHT][0] = Color.Yellow;\n', '        state[RIGHT][1] = Color.Red;\n', '        state[RIGHT][2] = Color.Orange;\n', '        state[RIGHT][3] = Color.Orange;\n', '        state[RIGHT][4] = Color.Green;\n', '        state[RIGHT][5] = Color.White;\n', '        state[RIGHT][6] = Color.Blue;\n', '        state[RIGHT][7] = Color.Orange;\n', '        state[RIGHT][8] = Color.Orange;\n', '\n', '        state[DOWN][0] = Color.White;\n', '        state[DOWN][1] = Color.Red;\n', '        state[DOWN][2] = Color.Orange;\n', '        state[DOWN][3] = Color.Yellow;\n', '        state[DOWN][4] = Color.White;\n', '        state[DOWN][5] = Color.Yellow;\n', '        state[DOWN][6] = Color.Yellow;\n', '        state[DOWN][7] = Color.Blue;\n', '        state[DOWN][8] = Color.Green;\n', '\n', '        state[BACK][0] = Color.Green;\n', '        state[BACK][1] = Color.Green;\n', '        state[BACK][2] = Color.Red;\n', '        state[BACK][3] = Color.Blue;\n', '        state[BACK][4] = Color.Orange;\n', '        state[BACK][5] = Color.Orange;\n', '        state[BACK][6] = Color.White;\n', '        state[BACK][7] = Color.Green;\n', '        state[BACK][8] = Color.Orange;\n', '    }\n', '\n', '    function getOwner() view public returns (address)  {\n', '       return owner;\n', '    }\n', '\n', '    function getCurrentWinner() view public returns (address)  {\n', '       return currentWinner;\n', '    }\n', '\n', '    function getCurrentWinnerMoveCount() view public returns (uint)  {\n', '       return currentWinnerMoveCount;\n', '    }\n', '\n', '    function getBalance() view public returns (uint256) {\n', '        return this.balance;\n', '    }\n', '\n', '    function getContestEndTime() view public returns (uint256) {\n', '        return contestEndTime;\n', '    }\n', '\n', '    /*\n', '     This function is used to set the reward for the winner.\n', '     Only the owner of the contract is allowed to set the reward\n', '    */\n', '    function addBalance() public payable {\n', '        require(msg.sender == owner);\n', '    }\n', '\n', '\n', '    /*\n', '     Checks that a given side is of correct color.\n', '    */\n', '\n', '    function verifySide(Color[9][6] memory aState, uint8 FACE, Color expectedColor) internal pure returns (bool) {\n', '        return aState[FACE][0] == expectedColor &&\n', '        aState[FACE][1] == expectedColor &&\n', '        aState[FACE][2] == expectedColor &&\n', '        aState[FACE][3] == expectedColor &&\n', '        aState[FACE][4] == expectedColor &&\n', '        aState[FACE][5] == expectedColor &&\n', '        aState[FACE][6] == expectedColor &&\n', '        aState[FACE][7] == expectedColor &&\n', '        aState[FACE][8] == expectedColor;\n', '    }\n', '\n', '\n', '    /*\n', '    Checks if the given state is in solved state.\n', '    The cube is solved if the state equals:\n', '    [[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5]]\n', '    */\n', '\n', '    function isSolved(Color[9][6] memory aState) public pure returns (bool) {\n', '        return verifySide(aState, FRONT, Color.Red) &&\n', '        verifySide(aState, LEFT, Color.Blue) &&\n', '        verifySide(aState, UP, Color.Yellow) &&\n', '        verifySide(aState, RIGHT, Color.Green) &&\n', '        verifySide(aState, DOWN, Color.White) &&\n', '        verifySide(aState, BACK, Color.Orange);\n', '    }\n', '\n', '    function getInitialState() public view returns (Color[9][6])  {\n', '        return state;\n', '    }\n', '\n', '\n', '    /*\n', '     Shuffles a single side of a face. For instance:\n', '\n', '         1 2 3       7 4 1\n', '         4 5 6   ->  8 5 2\n', '         7 8 9       9 6 3\n', '\n', '     Calling only this function does not leave the cube in a valid state as\n', '     also the "sides" of the cubes must move.\n', '    */\n', '\n', '    function shuffleFace(Color[9][6] memory aState, uint FACE) pure internal {\n', '        Color[9] memory swap;\n', '        swap[0] = aState[FACE][0];\n', '        swap[1] = aState[FACE][1];\n', '        swap[2] = aState[FACE][2];\n', '        swap[3] = aState[FACE][3];\n', '        swap[4] = aState[FACE][4];\n', '        swap[5] = aState[FACE][5];\n', '        swap[6] = aState[FACE][6];\n', '        swap[7] = aState[FACE][7];\n', '        swap[8] = aState[FACE][8];\n', '\n', '        aState[FACE][0] = swap[2];\n', '        aState[FACE][1] = swap[5];\n', '        aState[FACE][2] = swap[8];\n', '        aState[FACE][3] = swap[1];\n', '        aState[FACE][4] = swap[4];\n', '        aState[FACE][5] = swap[7];\n', '        aState[FACE][6] = swap[0];\n', '        aState[FACE][7] = swap[3];\n', '        aState[FACE][8] = swap[6];\n', '    }\n', '\n', '    function shuffleDown(Color[9][6] memory aState) pure internal {\n', '        shuffleFace(aState, DOWN);\n', '        Color[12] memory swap;\n', '        swap[0] = aState[FRONT][2];\n', '        swap[1] = aState[FRONT][5];\n', '        swap[2] = aState[FRONT][8];\n', '\n', '        swap[3] = aState[RIGHT][2];\n', '        swap[4] = aState[RIGHT][5];\n', '        swap[5] = aState[RIGHT][8];\n', '\n', '        swap[6] = aState[BACK][6];\n', '        swap[7] = aState[BACK][3];\n', '        swap[8] = aState[BACK][0];\n', '\n', '        swap[9] = aState[LEFT][2];\n', '        swap[10] = aState[LEFT][5];\n', '        swap[11] = aState[LEFT][8];\n', '\n', '        aState[FRONT][2] = swap[9];\n', '        aState[FRONT][5] = swap[10];\n', '        aState[FRONT][8] = swap[11];\n', '\n', '        aState[RIGHT][2] = swap[0];\n', '        aState[RIGHT][5] = swap[1];\n', '        aState[RIGHT][8] = swap[2];\n', '\n', '        aState[BACK][6] = swap[3];\n', '        aState[BACK][3] = swap[4];\n', '        aState[BACK][0] = swap[5];\n', '\n', '        aState[LEFT][2] = swap[6];\n', '        aState[LEFT][5] = swap[7];\n', '        aState[LEFT][8] = swap[8];\n', '    }\n', '\n', '\n', '    function shuffleRight(Color[9][6] memory aState) pure internal {\n', '        shuffleFace(aState, RIGHT);\n', '        Color[12] memory swap;\n', '        swap[0] = aState[UP][8];\n', '        swap[1] = aState[UP][7];\n', '        swap[2] = aState[UP][6];\n', '\n', '        swap[3] = aState[BACK][8];\n', '        swap[4] = aState[BACK][7];\n', '        swap[5] = aState[BACK][6];\n', '\n', '        swap[6] = aState[DOWN][8];\n', '        swap[7] = aState[DOWN][7];\n', '        swap[8] = aState[DOWN][6];\n', '\n', '        swap[9] = aState[FRONT][8];\n', '        swap[10] = aState[FRONT][7];\n', '        swap[11] = aState[FRONT][6];\n', '\n', '        aState[UP][8] = swap[9];\n', '        aState[UP][7] = swap[10];\n', '        aState[UP][6] = swap[11];\n', '\n', '        aState[BACK][8] = swap[0];\n', '        aState[BACK][7] = swap[1];\n', '        aState[BACK][6] = swap[2];\n', '\n', '        aState[DOWN][8] = swap[3];\n', '        aState[DOWN][7] = swap[4];\n', '        aState[DOWN][6] = swap[5];\n', '\n', '        aState[FRONT][8] = swap[6];\n', '        aState[FRONT][7] = swap[7];\n', '        aState[FRONT][6] = swap[8];\n', '    }\n', '\n', '    function shuffleUp(Color[9][6] memory aState) pure internal {\n', '        shuffleFace(aState, UP);\n', '        Color[12] memory swap;\n', '        swap[0] = aState[BACK][2];\n', '        swap[1] = aState[BACK][5];\n', '        swap[2] = aState[BACK][8];\n', '\n', '        swap[3] = aState[RIGHT][6];\n', '        swap[4] = aState[RIGHT][3];\n', '        swap[5] = aState[RIGHT][0];\n', '\n', '        swap[6] = aState[FRONT][6];\n', '        swap[7] = aState[FRONT][3];\n', '        swap[8] = aState[FRONT][0];\n', '\n', '        swap[9] = aState[LEFT][6];\n', '        swap[10] = aState[LEFT][3];\n', '        swap[11] = aState[LEFT][0];\n', '\n', '        aState[BACK][2] = swap[9];\n', '        aState[BACK][5] = swap[10];\n', '        aState[BACK][8] = swap[11];\n', '\n', '        aState[RIGHT][6] = swap[0];\n', '        aState[RIGHT][3] = swap[1];\n', '        aState[RIGHT][0] = swap[2];\n', '\n', '        aState[FRONT][6] = swap[3];\n', '        aState[FRONT][3] = swap[4];\n', '        aState[FRONT][0] = swap[5];\n', '\n', '        aState[LEFT][6] = swap[6];\n', '        aState[LEFT][3] = swap[7];\n', '        aState[LEFT][0] = swap[8];\n', '    }\n', '\n', '\n', '    function shuffleLeft(Color[9][6] memory aState) pure internal {\n', '        shuffleFace(aState, LEFT);\n', '        Color[12] memory swap;\n', '\n', '        swap[0] = aState[UP][0];\n', '        swap[1] = aState[UP][1];\n', '        swap[2] = aState[UP][2];\n', '\n', '        swap[3] = aState[FRONT][0];\n', '        swap[4] = aState[FRONT][1];\n', '        swap[5] = aState[FRONT][2];\n', '\n', '        swap[6] = aState[DOWN][0];\n', '        swap[7] = aState[DOWN][1];\n', '        swap[8] = aState[DOWN][2];\n', '\n', '        swap[9] = aState[BACK][0];\n', '        swap[10] = aState[BACK][1];\n', '        swap[11] = aState[BACK][2];\n', '\n', '        aState[UP][0] = swap[9];\n', '        aState[UP][1] = swap[10];\n', '        aState[UP][2] = swap[11];\n', '\n', '        aState[FRONT][0] = swap[0];\n', '        aState[FRONT][1] = swap[1];\n', '        aState[FRONT][2] = swap[2];\n', '\n', '        aState[DOWN][0] = swap[3];\n', '        aState[DOWN][1] = swap[4];\n', '        aState[DOWN][2] = swap[5];\n', '\n', '        aState[BACK][0] = swap[6];\n', '        aState[BACK][1] = swap[7];\n', '        aState[BACK][2] = swap[8];\n', '    }\n', '\n', '    function shuffleFront(Color[9][6] memory aState) pure internal {\n', '        shuffleFace(aState, FRONT);\n', '        Color[12] memory swap;\n', '\n', '        swap[0] = aState[UP][2];\n', '        swap[1] = aState[UP][5];\n', '        swap[2] = aState[UP][8];\n', '\n', '        swap[3] = aState[RIGHT][0];\n', '        swap[4] = aState[RIGHT][1];\n', '        swap[5] = aState[RIGHT][2];\n', '\n', '        swap[6] = aState[DOWN][6];\n', '        swap[7] = aState[DOWN][3];\n', '        swap[8] = aState[DOWN][0];\n', '\n', '        swap[9] = aState[LEFT][8];\n', '        swap[10] = aState[LEFT][7];\n', '        swap[11] = aState[LEFT][6];\n', '\n', '        aState[UP][2] = swap[9];\n', '        aState[UP][5] = swap[10];\n', '        aState[UP][8] = swap[11];\n', '\n', '        aState[RIGHT][0] = swap[0];\n', '        aState[RIGHT][1] = swap[1];\n', '        aState[RIGHT][2] = swap[2];\n', '\n', '        aState[DOWN][6] = swap[3];\n', '        aState[DOWN][3] = swap[4];\n', '        aState[DOWN][0] = swap[5];\n', '\n', '        aState[LEFT][8] = swap[6];\n', '        aState[LEFT][7] = swap[7];\n', '        aState[LEFT][6] = swap[8];\n', '    }\n', '\n', '    /*\n', '        Returns the state of the cube after performing the given moves.\n', '\n', '        The moves parameter defines a set of moves that are applied to the cube\n', '        in its initial state.\n', '\n', '        Only 5 types of moves are possible.\n', '     */\n', '    function trySolution(uint8[] moves) public view returns (Color[9][6]) {\n', '        Color[9][6] memory aState = state;\n', '\n', '        for (uint i = 0; i < moves.length; i++) {\n', '            if (moves[i] == FRONT) {\n', '                shuffleFront(aState);\n', '            } else if (moves[i] == LEFT) {\n', '                shuffleLeft(aState);\n', '            } else if (moves[i] == UP) {\n', '                shuffleUp(aState);\n', '            } else if (moves[i] == RIGHT) {\n', '                shuffleRight(aState);\n', '            } else if (moves[i] == DOWN) {\n', '                shuffleDown(aState);\n', '            } else {\n', '                //invalid move;\n', '                require(false);\n', '            }\n', '        }\n', '        return aState;\n', '    }\n', '\n', '\n', '    /*\n', '        The function that is used to submit the solution to the blockchain\n', '    */\n', '    function submitSolution(uint8[] moves) public {\n', '\n', '        Submission(msg.sender, moves);\n', "        //don't allow submissions after contest time has passed\n", '        require(now < contestEndTime);\n', '        Color[9][6] memory stateAfterMoves = trySolution(moves);\n', '\n', '        //the cube must be in a solved state\n', '        if (isSolved(stateAfterMoves)) {\n', '\n', '            //the new leader is set if the solution has fewer moves than the current winner\n', '            if(moves.length < currentWinnerMoveCount) {\n', '                currentWinnerMoveCount = moves.length;\n', '                currentWinner = msg.sender;\n', '                NewLeader(msg.sender, moves);\n', '            }\n', '        }\n', '    }\n', '\n', '/*\n', '    The function that allows the winner of the contest to\n', '    claim the reward after the contest has ended\n', '*/\n', '    function claim() public {\n', '        require(now >= contestEndTime);\n', '        require(msg.sender == currentWinner);\n', '        msg.sender.transfer(this.balance);\n', '    }\n', '\n', '}']