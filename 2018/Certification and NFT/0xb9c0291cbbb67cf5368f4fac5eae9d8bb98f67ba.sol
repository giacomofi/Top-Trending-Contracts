['pragma solidity 0.4.24;\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract CanReclaimToken is owned {\n', '\n', '    /**\n', '    * @dev Reclaim all ERC20Basic compatible tokens\n', '    * @param token ERC20Basic The address of the token contract\n', '    */\n', '    function reclaimToken(ERC20Interface token) external only_owner {\n', '        uint256 balance = token.balanceOf(this);\n', '        require(token.approve(owner, balance));\n', '    }\n', '\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'library SafeMath {\n', '    function subToZero(uint a, uint b) internal pure returns (uint) {\n', '        if (a < b) {  // then (a - b) would overflow\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract ixPaymentEvents {\n', '    event UpgradedToPremium(bytes32 indexed democHash);\n', '    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\n', '    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\n', '    event SetCommunityBallotFee(uint amount);\n', '    event SetBasicCentsPricePer30Days(uint amount);\n', '    event SetPremiumMultiplier(uint8 multiplier);\n', '    event DowngradeToBasic(bytes32 indexed democHash);\n', '    event UpgradeToPremium(bytes32 indexed democHash);\n', '    event SetExchangeRate(uint weiPerCent);\n', '    event FreeExtension(bytes32 democHash);\n', '    event SetBallotsPer30Days(uint amount);\n', '    event SetFreeExtension(bytes32 democHash, bool hasFreeExt);\n', '    event SetDenyPremium(bytes32 democHash, bool isPremiumDenied);\n', '    event SetPayTo(address payTo);\n', '    event SetMinorEditsAddr(address minorEditsAddr);\n', '    event SetMinWeiForDInit(uint amount);\n', '}\n', '\n', 'interface hasVersion {\n', '    function getVersion() external pure returns (uint);\n', '}\n', '\n', 'contract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable {\n', '    /* in emergency break glass */\n', '    function emergencySetOwner(address newOwner) external;\n', '\n', '    /* financial calcluations */\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint secs);\n', '    function weiToCents(uint w) public view returns (uint);\n', '    function centsToWei(uint c) public view returns (uint);\n', '\n', '    /* account management */\n', '    function payForDemocracy(bytes32 democHash) external payable;\n', '    function doFreeExtension(bytes32 democHash) external;\n', '    function downgradeToBasic(bytes32 democHash) external;\n', '    function upgradeToPremium(bytes32 democHash) external;\n', '\n', '    /* account status - getters */\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool);\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool);\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool);\n', '\n', '    /* admin utils for accounts */\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\n', '\n', '    /* admin setters global */\n', '    function setPayTo(address) external;\n', '    function setMinorEditsAddr(address) external;\n', '    function setBasicCentsPricePer30Days(uint amount) external;\n', '    function setBasicBallotsPer30Days(uint amount) external;\n', '    function setPremiumMultiplier(uint8 amount) external;\n', '    function setWeiPerCent(uint) external;\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\n', '    function setMinWeiForDInit(uint amount) external;\n', '\n', '    /* global getters */\n', '    function getBasicCentsPricePer30Days() external view returns(uint);\n', '    function getBasicExtraBallotFeeWei() external view returns (uint);\n', '    function getBasicBallotsPer30Days() external view returns (uint);\n', '    function getPremiumMultiplier() external view returns (uint8);\n', '    function getPremiumCentsPricePer30Days() external view returns (uint);\n', '    function getWeiPerCent() external view returns (uint weiPerCent);\n', '    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\n', '    function getMinWeiForDInit() external view returns (uint);\n', '\n', '    /* payments stuff */\n', '    function getPaymentLogN() external view returns (uint);\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\n', '}\n', '\n', 'contract SVPayments is IxPaymentsIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Account {\n', '        bool isPremium;\n', '        uint lastPaymentTs;\n', '        uint paidUpTill;\n', '        uint lastUpgradeTs;  // timestamp of the last time it was upgraded to premium\n', '    }\n', '\n', '    struct PaymentLog {\n', '        bool _external;\n', '        bytes32 _democHash;\n', '        uint _seconds;\n', '        uint _ethValue;\n', '    }\n', '\n', '    // this is an address that&#39;s only allowed to make minor edits\n', '    // e.g. setExchangeRate, setDenyPremium, giveTimeToDemoc\n', '    address public minorEditsAddr;\n', '\n', '    // payment details\n', '    uint basicCentsPricePer30Days = 125000; // $1250/mo\n', '    uint basicBallotsPer30Days = 10;\n', '    uint8 premiumMultiplier = 5;\n', '    uint weiPerCent = 0.000016583747 ether;  // $603, 4th June 2018\n', '\n', '    uint minWeiForDInit = 1;  // minimum 1 wei - match existing behaviour in SVIndex\n', '\n', '    mapping (bytes32 => Account) accounts;\n', '    PaymentLog[] payments;\n', '\n', '    // can set this on freeExtension democs to deny them premium upgrades\n', '    mapping (bytes32 => bool) denyPremium;\n', '    // this is used for non-profits or organisations that have perpetual licenses, etc\n', '    mapping (bytes32 => bool) freeExtension;\n', '\n', '\n', '    /* BREAK GLASS IN CASE OF EMERGENCY */\n', '    // this is included here because something going wrong with payments is possibly\n', '    // the absolute worst case. Note: does this have negligable benefit if the other\n', '    // contracts are compromised? (e.g. by a leaked privkey)\n', '    address public emergencyAdmin;\n', '    function emergencySetOwner(address newOwner) external {\n', '        require(msg.sender == emergencyAdmin, "!emergency-owner");\n', '        owner = newOwner;\n', '    }\n', '    /* END BREAK GLASS */\n', '\n', '\n', '    constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public {\n', '        emergencyAdmin = _emergencyAdmin;\n', '        assert(_emergencyAdmin != address(0));\n', '    }\n', '\n', '    /* base SCs */\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    function() payable public {\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal {\n', '        uint prevPaidTill = accounts[democHash].paidUpTill;\n', '        if (prevPaidTill < now) {\n', '            prevPaidTill = now;\n', '        }\n', '\n', '        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;\n', '        accounts[democHash].lastPaymentTs = now;\n', '    }\n', '\n', '    /* Financial Calculations */\n', '\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint) {\n', '        uint centsPaid = weiToCents(amount);\n', '        // multiply by 10**18 to ensure we make rounding errors insignificant\n', '        uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days;\n', '        uint secondsOffsetPaid = monthsOffsetPaid * (30 days);\n', '        uint additionalSeconds = secondsOffsetPaid / (10 ** 18);\n', '        return additionalSeconds;\n', '    }\n', '\n', '    function weiToCents(uint w) public view returns (uint) {\n', '        return w / weiPerCent;\n', '    }\n', '\n', '    function centsToWei(uint c) public view returns (uint) {\n', '        return c * weiPerCent;\n', '    }\n', '\n', '    /* account management */\n', '\n', '    function payForDemocracy(bytes32 democHash) external payable {\n', '        require(msg.value > 0, "need to send some ether to make payment");\n', '\n', '        uint additionalSeconds = weiBuysHowManySeconds(msg.value);\n', '\n', '        if (accounts[democHash].isPremium) {\n', '            additionalSeconds /= premiumMultiplier;\n', '        }\n', '\n', '        if (additionalSeconds >= 1) {\n', '            _modAccountBalance(democHash, additionalSeconds);\n', '        }\n', '        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));\n', '        emit AccountPayment(democHash, additionalSeconds);\n', '\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function doFreeExtension(bytes32 democHash) external {\n', '        require(freeExtension[democHash], "!free");\n', '        uint newPaidUpTill = now + 60 days;\n', '        accounts[democHash].paidUpTill = newPaidUpTill;\n', '        emit FreeExtension(democHash);\n', '    }\n', '\n', '    function downgradeToBasic(bytes32 democHash) only_editors() external {\n', '        require(accounts[democHash].isPremium, "!premium");\n', '        accounts[democHash].isPremium = false;\n', '        // convert premium minutes to basic\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', '        // if we have time remaining: convert it\n', '        if (timeRemaining > 0) {\n', '            // prevent accounts from downgrading if they have time remaining\n', '            // and upgraded less than 24hrs ago\n', '            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");\n', '            timeRemaining *= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        emit DowngradeToBasic(democHash);\n', '    }\n', '\n', '    function upgradeToPremium(bytes32 democHash) only_editors() external {\n', '        require(denyPremium[democHash] == false, "upgrade-denied");\n', '        require(!accounts[democHash].isPremium, "!basic");\n', '        accounts[democHash].isPremium = true;\n', '        // convert basic minutes to premium minutes\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', '        // if we have time remaning then convert it - otherwise don&#39;t need to do anything\n', '        if (timeRemaining > 0) {\n', '            timeRemaining /= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        accounts[democHash].lastUpgradeTs = now;\n', '        emit UpgradedToPremium(democHash);\n', '    }\n', '\n', '    /* account status - getters */\n', '\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].paidUpTill >= now;\n', '    }\n', '\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {\n', '        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);\n', '    }\n', '\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].isPremium;\n', '    }\n', '\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool) {\n', '        return freeExtension[democHash];\n', '    }\n', '\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {\n', '        isPremium = accounts[democHash].isPremium;\n', '        lastPaymentTs = accounts[democHash].lastPaymentTs;\n', '        paidUpTill = accounts[democHash].paidUpTill;\n', '        hasFreeExtension = freeExtension[democHash];\n', '    }\n', '\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool) {\n', '        return denyPremium[democHash];\n', '    }\n', '\n', '    /* admin utils for accounts */\n', '\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {\n', '        _modAccountBalance(democHash, additionalSeconds);\n', '        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));\n', '        emit GrantedAccountTime(democHash, additionalSeconds, ref);\n', '    }\n', '\n', '    /* admin setters global */\n', '\n', '    function setPayTo(address newPayTo) only_owner() external {\n', '        _setPayTo(newPayTo);\n', '        emit SetPayTo(newPayTo);\n', '    }\n', '\n', '    function setMinorEditsAddr(address a) only_owner() external {\n', '        minorEditsAddr = a;\n', '        emit SetMinorEditsAddr(a);\n', '    }\n', '\n', '    function setBasicCentsPricePer30Days(uint amount) only_owner() external {\n', '        basicCentsPricePer30Days = amount;\n', '        emit SetBasicCentsPricePer30Days(amount);\n', '    }\n', '\n', '    function setBasicBallotsPer30Days(uint amount) only_owner() external {\n', '        basicBallotsPer30Days = amount;\n', '        emit SetBallotsPer30Days(amount);\n', '    }\n', '\n', '    function setPremiumMultiplier(uint8 m) only_owner() external {\n', '        premiumMultiplier = m;\n', '        emit SetPremiumMultiplier(m);\n', '    }\n', '\n', '    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {\n', '        weiPerCent = wpc;\n', '        emit SetExchangeRate(wpc);\n', '    }\n', '\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {\n', '        freeExtension[democHash] = hasFreeExt;\n', '        emit SetFreeExtension(democHash, hasFreeExt);\n', '    }\n', '\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {\n', '        denyPremium[democHash] = isPremiumDenied;\n', '        emit SetDenyPremium(democHash, isPremiumDenied);\n', '    }\n', '\n', '    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {\n', '        minWeiForDInit = amount;\n', '        emit SetMinWeiForDInit(amount);\n', '    }\n', '\n', '    /* global getters */\n', '\n', '    function getBasicCentsPricePer30Days() external view returns (uint) {\n', '        return basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getBasicExtraBallotFeeWei() external view returns (uint) {\n', '        return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days);\n', '    }\n', '\n', '    function getBasicBallotsPer30Days() external view returns (uint) {\n', '        return basicBallotsPer30Days;\n', '    }\n', '\n', '    function getPremiumMultiplier() external view returns (uint8) {\n', '        return premiumMultiplier;\n', '    }\n', '\n', '    function getPremiumCentsPricePer30Days() external view returns (uint) {\n', '        return _premiumPricePer30Days();\n', '    }\n', '\n', '    function _premiumPricePer30Days() internal view returns (uint) {\n', '        return uint(premiumMultiplier) * basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getWeiPerCent() external view returns (uint) {\n', '        return weiPerCent;\n', '    }\n', '\n', '    function getUsdEthExchangeRate() external view returns (uint) {\n', '        // this returns cents per ether\n', '        return 1 ether / weiPerCent;\n', '    }\n', '\n', '    function getMinWeiForDInit() external view returns (uint) {\n', '        return minWeiForDInit;\n', '    }\n', '\n', '    /* payments stuff */\n', '\n', '    function getPaymentLogN() external view returns (uint) {\n', '        return payments.length;\n', '    }\n', '\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) {\n', '        _external = payments[n]._external;\n', '        _democHash = payments[n]._democHash;\n', '        _seconds = payments[n]._seconds;\n', '        _ethValue = payments[n]._ethValue;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', "    // but reentrency is bad, so here's a mutex.\n", '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract CanReclaimToken is owned {\n', '\n', '    /**\n', '    * @dev Reclaim all ERC20Basic compatible tokens\n', '    * @param token ERC20Basic The address of the token contract\n', '    */\n', '    function reclaimToken(ERC20Interface token) external only_owner {\n', '        uint256 balance = token.balanceOf(this);\n', '        require(token.approve(owner, balance));\n', '    }\n', '\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner\'s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'library SafeMath {\n', '    function subToZero(uint a, uint b) internal pure returns (uint) {\n', '        if (a < b) {  // then (a - b) would overflow\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract ixPaymentEvents {\n', '    event UpgradedToPremium(bytes32 indexed democHash);\n', '    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\n', '    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\n', '    event SetCommunityBallotFee(uint amount);\n', '    event SetBasicCentsPricePer30Days(uint amount);\n', '    event SetPremiumMultiplier(uint8 multiplier);\n', '    event DowngradeToBasic(bytes32 indexed democHash);\n', '    event UpgradeToPremium(bytes32 indexed democHash);\n', '    event SetExchangeRate(uint weiPerCent);\n', '    event FreeExtension(bytes32 democHash);\n', '    event SetBallotsPer30Days(uint amount);\n', '    event SetFreeExtension(bytes32 democHash, bool hasFreeExt);\n', '    event SetDenyPremium(bytes32 democHash, bool isPremiumDenied);\n', '    event SetPayTo(address payTo);\n', '    event SetMinorEditsAddr(address minorEditsAddr);\n', '    event SetMinWeiForDInit(uint amount);\n', '}\n', '\n', 'interface hasVersion {\n', '    function getVersion() external pure returns (uint);\n', '}\n', '\n', 'contract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable {\n', '    /* in emergency break glass */\n', '    function emergencySetOwner(address newOwner) external;\n', '\n', '    /* financial calcluations */\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint secs);\n', '    function weiToCents(uint w) public view returns (uint);\n', '    function centsToWei(uint c) public view returns (uint);\n', '\n', '    /* account management */\n', '    function payForDemocracy(bytes32 democHash) external payable;\n', '    function doFreeExtension(bytes32 democHash) external;\n', '    function downgradeToBasic(bytes32 democHash) external;\n', '    function upgradeToPremium(bytes32 democHash) external;\n', '\n', '    /* account status - getters */\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool);\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool);\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool);\n', '\n', '    /* admin utils for accounts */\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\n', '\n', '    /* admin setters global */\n', '    function setPayTo(address) external;\n', '    function setMinorEditsAddr(address) external;\n', '    function setBasicCentsPricePer30Days(uint amount) external;\n', '    function setBasicBallotsPer30Days(uint amount) external;\n', '    function setPremiumMultiplier(uint8 amount) external;\n', '    function setWeiPerCent(uint) external;\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\n', '    function setMinWeiForDInit(uint amount) external;\n', '\n', '    /* global getters */\n', '    function getBasicCentsPricePer30Days() external view returns(uint);\n', '    function getBasicExtraBallotFeeWei() external view returns (uint);\n', '    function getBasicBallotsPer30Days() external view returns (uint);\n', '    function getPremiumMultiplier() external view returns (uint8);\n', '    function getPremiumCentsPricePer30Days() external view returns (uint);\n', '    function getWeiPerCent() external view returns (uint weiPerCent);\n', '    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\n', '    function getMinWeiForDInit() external view returns (uint);\n', '\n', '    /* payments stuff */\n', '    function getPaymentLogN() external view returns (uint);\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\n', '}\n', '\n', 'contract SVPayments is IxPaymentsIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Account {\n', '        bool isPremium;\n', '        uint lastPaymentTs;\n', '        uint paidUpTill;\n', '        uint lastUpgradeTs;  // timestamp of the last time it was upgraded to premium\n', '    }\n', '\n', '    struct PaymentLog {\n', '        bool _external;\n', '        bytes32 _democHash;\n', '        uint _seconds;\n', '        uint _ethValue;\n', '    }\n', '\n', "    // this is an address that's only allowed to make minor edits\n", '    // e.g. setExchangeRate, setDenyPremium, giveTimeToDemoc\n', '    address public minorEditsAddr;\n', '\n', '    // payment details\n', '    uint basicCentsPricePer30Days = 125000; // $1250/mo\n', '    uint basicBallotsPer30Days = 10;\n', '    uint8 premiumMultiplier = 5;\n', '    uint weiPerCent = 0.000016583747 ether;  // $603, 4th June 2018\n', '\n', '    uint minWeiForDInit = 1;  // minimum 1 wei - match existing behaviour in SVIndex\n', '\n', '    mapping (bytes32 => Account) accounts;\n', '    PaymentLog[] payments;\n', '\n', '    // can set this on freeExtension democs to deny them premium upgrades\n', '    mapping (bytes32 => bool) denyPremium;\n', '    // this is used for non-profits or organisations that have perpetual licenses, etc\n', '    mapping (bytes32 => bool) freeExtension;\n', '\n', '\n', '    /* BREAK GLASS IN CASE OF EMERGENCY */\n', '    // this is included here because something going wrong with payments is possibly\n', '    // the absolute worst case. Note: does this have negligable benefit if the other\n', '    // contracts are compromised? (e.g. by a leaked privkey)\n', '    address public emergencyAdmin;\n', '    function emergencySetOwner(address newOwner) external {\n', '        require(msg.sender == emergencyAdmin, "!emergency-owner");\n', '        owner = newOwner;\n', '    }\n', '    /* END BREAK GLASS */\n', '\n', '\n', '    constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public {\n', '        emergencyAdmin = _emergencyAdmin;\n', '        assert(_emergencyAdmin != address(0));\n', '    }\n', '\n', '    /* base SCs */\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    function() payable public {\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal {\n', '        uint prevPaidTill = accounts[democHash].paidUpTill;\n', '        if (prevPaidTill < now) {\n', '            prevPaidTill = now;\n', '        }\n', '\n', '        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;\n', '        accounts[democHash].lastPaymentTs = now;\n', '    }\n', '\n', '    /* Financial Calculations */\n', '\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint) {\n', '        uint centsPaid = weiToCents(amount);\n', '        // multiply by 10**18 to ensure we make rounding errors insignificant\n', '        uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days;\n', '        uint secondsOffsetPaid = monthsOffsetPaid * (30 days);\n', '        uint additionalSeconds = secondsOffsetPaid / (10 ** 18);\n', '        return additionalSeconds;\n', '    }\n', '\n', '    function weiToCents(uint w) public view returns (uint) {\n', '        return w / weiPerCent;\n', '    }\n', '\n', '    function centsToWei(uint c) public view returns (uint) {\n', '        return c * weiPerCent;\n', '    }\n', '\n', '    /* account management */\n', '\n', '    function payForDemocracy(bytes32 democHash) external payable {\n', '        require(msg.value > 0, "need to send some ether to make payment");\n', '\n', '        uint additionalSeconds = weiBuysHowManySeconds(msg.value);\n', '\n', '        if (accounts[democHash].isPremium) {\n', '            additionalSeconds /= premiumMultiplier;\n', '        }\n', '\n', '        if (additionalSeconds >= 1) {\n', '            _modAccountBalance(democHash, additionalSeconds);\n', '        }\n', '        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));\n', '        emit AccountPayment(democHash, additionalSeconds);\n', '\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function doFreeExtension(bytes32 democHash) external {\n', '        require(freeExtension[democHash], "!free");\n', '        uint newPaidUpTill = now + 60 days;\n', '        accounts[democHash].paidUpTill = newPaidUpTill;\n', '        emit FreeExtension(democHash);\n', '    }\n', '\n', '    function downgradeToBasic(bytes32 democHash) only_editors() external {\n', '        require(accounts[democHash].isPremium, "!premium");\n', '        accounts[democHash].isPremium = false;\n', '        // convert premium minutes to basic\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', '        // if we have time remaining: convert it\n', '        if (timeRemaining > 0) {\n', '            // prevent accounts from downgrading if they have time remaining\n', '            // and upgraded less than 24hrs ago\n', '            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");\n', '            timeRemaining *= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        emit DowngradeToBasic(democHash);\n', '    }\n', '\n', '    function upgradeToPremium(bytes32 democHash) only_editors() external {\n', '        require(denyPremium[democHash] == false, "upgrade-denied");\n', '        require(!accounts[democHash].isPremium, "!basic");\n', '        accounts[democHash].isPremium = true;\n', '        // convert basic minutes to premium minutes\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', "        // if we have time remaning then convert it - otherwise don't need to do anything\n", '        if (timeRemaining > 0) {\n', '            timeRemaining /= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        accounts[democHash].lastUpgradeTs = now;\n', '        emit UpgradedToPremium(democHash);\n', '    }\n', '\n', '    /* account status - getters */\n', '\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].paidUpTill >= now;\n', '    }\n', '\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {\n', '        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);\n', '    }\n', '\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].isPremium;\n', '    }\n', '\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool) {\n', '        return freeExtension[democHash];\n', '    }\n', '\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {\n', '        isPremium = accounts[democHash].isPremium;\n', '        lastPaymentTs = accounts[democHash].lastPaymentTs;\n', '        paidUpTill = accounts[democHash].paidUpTill;\n', '        hasFreeExtension = freeExtension[democHash];\n', '    }\n', '\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool) {\n', '        return denyPremium[democHash];\n', '    }\n', '\n', '    /* admin utils for accounts */\n', '\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {\n', '        _modAccountBalance(democHash, additionalSeconds);\n', '        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));\n', '        emit GrantedAccountTime(democHash, additionalSeconds, ref);\n', '    }\n', '\n', '    /* admin setters global */\n', '\n', '    function setPayTo(address newPayTo) only_owner() external {\n', '        _setPayTo(newPayTo);\n', '        emit SetPayTo(newPayTo);\n', '    }\n', '\n', '    function setMinorEditsAddr(address a) only_owner() external {\n', '        minorEditsAddr = a;\n', '        emit SetMinorEditsAddr(a);\n', '    }\n', '\n', '    function setBasicCentsPricePer30Days(uint amount) only_owner() external {\n', '        basicCentsPricePer30Days = amount;\n', '        emit SetBasicCentsPricePer30Days(amount);\n', '    }\n', '\n', '    function setBasicBallotsPer30Days(uint amount) only_owner() external {\n', '        basicBallotsPer30Days = amount;\n', '        emit SetBallotsPer30Days(amount);\n', '    }\n', '\n', '    function setPremiumMultiplier(uint8 m) only_owner() external {\n', '        premiumMultiplier = m;\n', '        emit SetPremiumMultiplier(m);\n', '    }\n', '\n', '    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {\n', '        weiPerCent = wpc;\n', '        emit SetExchangeRate(wpc);\n', '    }\n', '\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {\n', '        freeExtension[democHash] = hasFreeExt;\n', '        emit SetFreeExtension(democHash, hasFreeExt);\n', '    }\n', '\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {\n', '        denyPremium[democHash] = isPremiumDenied;\n', '        emit SetDenyPremium(democHash, isPremiumDenied);\n', '    }\n', '\n', '    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {\n', '        minWeiForDInit = amount;\n', '        emit SetMinWeiForDInit(amount);\n', '    }\n', '\n', '    /* global getters */\n', '\n', '    function getBasicCentsPricePer30Days() external view returns (uint) {\n', '        return basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getBasicExtraBallotFeeWei() external view returns (uint) {\n', '        return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days);\n', '    }\n', '\n', '    function getBasicBallotsPer30Days() external view returns (uint) {\n', '        return basicBallotsPer30Days;\n', '    }\n', '\n', '    function getPremiumMultiplier() external view returns (uint8) {\n', '        return premiumMultiplier;\n', '    }\n', '\n', '    function getPremiumCentsPricePer30Days() external view returns (uint) {\n', '        return _premiumPricePer30Days();\n', '    }\n', '\n', '    function _premiumPricePer30Days() internal view returns (uint) {\n', '        return uint(premiumMultiplier) * basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getWeiPerCent() external view returns (uint) {\n', '        return weiPerCent;\n', '    }\n', '\n', '    function getUsdEthExchangeRate() external view returns (uint) {\n', '        // this returns cents per ether\n', '        return 1 ether / weiPerCent;\n', '    }\n', '\n', '    function getMinWeiForDInit() external view returns (uint) {\n', '        return minWeiForDInit;\n', '    }\n', '\n', '    /* payments stuff */\n', '\n', '    function getPaymentLogN() external view returns (uint) {\n', '        return payments.length;\n', '    }\n', '\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) {\n', '        _external = payments[n]._external;\n', '        _democHash = payments[n]._democHash;\n', '        _seconds = payments[n]._seconds;\n', '        _ethValue = payments[n]._ethValue;\n', '    }\n', '}']
