['pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title EthealWhitelist\n', ' * @author thesved\n', ' * @notice EthealWhitelist contract which handles KYC\n', ' */\n', 'contract EthealWhitelist is Ownable {\n', '    using ECRecovery for bytes32;\n', '\n', '    // signer address for offchain whitelist signing\n', '    address public signer;\n', '\n', '    // storing whitelisted addresses\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    event WhitelistSet(address indexed _address, bool _state);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '    function EthealWhitelist(address _signer) {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    /// @notice set signing address after deployment\n', '    function setSigner(address _signer) public onlyOwner {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    ////////////////\n', '    // Whitelisting: only owner\n', '    ////////////////\n', '\n', '    ///&#160;@notice Set whitelist state for an address.\n', '    function setWhitelist(address _addr, bool _state) public onlyOwner {\n', '        require(_addr != address(0));\n', '        isWhitelisted[_addr] = _state;\n', '        WhitelistSet(_addr, _state);\n', '    }\n', '\n', '    ///&#160;@notice Set whitelist state for multiple addresses\n', '    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\n', '        for (uint256 i = 0; i < _addr.length; i++) {\n', '            setWhitelist(_addr[i], _state);\n', '        }\n', '    }\n', '\n', '    /// @notice offchain whitelist check\n', '    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\n', '        bytes32 hash = keccak256("\\x19Ethereum Signed Message:\\n20",_addr);\n', '        return hash.recover(_sig) == signer;\n', '    }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title EthealWhitelist\n', ' * @author thesved\n', ' * @notice EthealWhitelist contract which handles KYC\n', ' */\n', 'contract EthealWhitelist is Ownable {\n', '    using ECRecovery for bytes32;\n', '\n', '    // signer address for offchain whitelist signing\n', '    address public signer;\n', '\n', '    // storing whitelisted addresses\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    event WhitelistSet(address indexed _address, bool _state);\n', '\n', '    ////////////////\n', '    // Constructor\n', '    ////////////////\n', '    function EthealWhitelist(address _signer) {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    /// @notice set signing address after deployment\n', '    function setSigner(address _signer) public onlyOwner {\n', '        require(_signer != address(0));\n', '\n', '        signer = _signer;\n', '    }\n', '\n', '    ////////////////\n', '    // Whitelisting: only owner\n', '    ////////////////\n', '\n', '    ///\xa0@notice Set whitelist state for an address.\n', '    function setWhitelist(address _addr, bool _state) public onlyOwner {\n', '        require(_addr != address(0));\n', '        isWhitelisted[_addr] = _state;\n', '        WhitelistSet(_addr, _state);\n', '    }\n', '\n', '    ///\xa0@notice Set whitelist state for multiple addresses\n', '    function setManyWhitelist(address[] _addr, bool _state) public onlyOwner {\n', '        for (uint256 i = 0; i < _addr.length; i++) {\n', '            setWhitelist(_addr[i], _state);\n', '        }\n', '    }\n', '\n', '    /// @notice offchain whitelist check\n', '    function isOffchainWhitelisted(address _addr, bytes _sig) public view returns (bool) {\n', '        bytes32 hash = keccak256("\\x19Ethereum Signed Message:\\n20",_addr);\n', '        return hash.recover(_sig) == signer;\n', '    }\n', '}']
