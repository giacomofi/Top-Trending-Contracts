['pragma solidity 0.4.25;\n', '\n', '\n', 'contract Acquis {\n', '    using SafeMath for uint256;\n', '\n', '    address public proprio;             //  Propi&#232;taire du contrat\n', '    address public nouveauProprio;      //  tmp pour la passation &#233;ventuelle de pouvoir\n', '    \n', '    event changementProprio ( address indexed _de, address indexed _a );\n', '    \n', '    modifier proprioSeulement {\n', '        require ( msg.sender == proprio );\n', '        _;\n', '    }\n', '    \n', '    function changerProprio ( address _nouveauProprio ) public proprioSeulement {\n', '        nouveauProprio = _nouveauProprio;\n', '    }\n', '        \n', '    function confirmerNouveauProprio() public {\n', '        require ( msg.sender == nouveauProprio );\n', '        emit changementProprio ( proprio, nouveauProprio );\n', '        proprio = nouveauProprio;\n', '        delete nouveauProprio;\n', '    }\n', '    \n', '}\n', 'interface ReceveurDeTokens {\n', '    \n', '    function recevoirApprobation ( address _de, uint256 _montant, address _token ) external;\n', '    \n', '}\n', 'contract TokenERC20 {\n', '    \n', '    // Variables publiques du token.\n', '    string public nom;\n', '    string public symbole;\n', '    uint8 public decimales = 18;\n', '    // 18 d&#233;cimales par d&#233;faut, fortement recommand&#233;.\n', '    uint256 public sommeTotale;\n', '\n', '    // Cr&#233;ation d&#39;untableau avec tous les comptes.\n', '    mapping ( address => uint256 ) public comptes;\n', '    mapping ( address => mapping ( address => uint256 ) ) public autorisations;\n', '\n', '    // G&#233;n&#232;re un &#233;v&#232;nement publique sur la BlocCha&#238;ne qui notifie les clients.\n', '    event Transfert ( address indexed de, address indexed a, uint256 somme );\n', '\n', '    // Notifie les clients du montant br&#251;l&#233;.\n', '    event Brules ( address indexed from, uint256 value );\n', '\n', '\n', '    /**\n', '     * Constrcteur\n', '     *\n', '     * Initialise le contrat et donne la sommeTotale au proprio du contrat.\n', '     */\n', '            constructor ( uint256 sommeInitiale, string nomToken, string symboleToken ) public {\n', '                \n', '                sommeTotale = sommeInitiale * 10 ** uint256 ( decimales );  // Met &#224; jour la sommeTotale.\n', '                comptes[msg.sender] = sommeTotale;                          // Donne au cr&#233;ateur tous les tokens.\n', '                nom = nomToken;                                             // Nom complet du token.\n', '                symbole = symboleToken;                                     // Symbole du token.\n', '                \n', '            }\n', '\n', '\n', '    /**\n', '     * Transfert interne, ne peut &#234;tre appel&#233; que par ce contrat.\n', '     */\n', '    function _transfert ( address _de, address _a, uint _somme ) internal {\n', '        require ( _de != 0x0);\n', '        require ( comptes[_de] >= _somme );\n', '        require ( comptes[_a] + _somme > comptes[_a] );\n', '        uint balancePrecedente = comptes[_de] + comptes[_a];\n', '        comptes[_de] -= _somme;\n', '        comptes[_a] += _somme;\n', '        emit Transfert ( _de, _a, _somme );\n', '        assert ( comptes[_de] + comptes[_a] == balancePrecedente );\n', '    }\n', '\n', '    /**\n', '     * Transfert de tokens\n', '     *\n', '     * Envoie `_valeur` tokens &#224; `_a` de votre compte.\n', '     *\n', '     * @param _a l&#39;adresse du receveur\n', '     * @param _valeur le montant de l&#39;envoi\n', '     */\n', '    function transfert ( address _a, uint256 _valeur ) public {\n', '        _transfert ( msg.sender, _a, _valeur );\n', '    }\n', '\n', '    /**\n', '     * Transfert de tokens depuis une autre addresse\n', '     *\n', '     * Envoie `_valeur` tokens &#224; `_a` au nom de `_de`\n', '     *\n', '     * @param _de L&#39;adress de l&#39;envoyeur.\n', '     * @param _a L&#39;adresse du receveur.\n', '     * @param _valeur Le montant &#224; envoyer.\n', '     */\n', '    function transferFrom ( address _de, address _a, uint256 _valeur ) public returns ( bool succes ) {\n', '        require ( _valeur <= autorisations[_de][msg.sender] );     // Check allowance\n', '        autorisations[_de][msg.sender] -= _valeur;\n', '        _transfert ( _de, _a, _valeur );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * D&#233;finir une autorisation pour une autre adresse\n', '     *\n', '     * Autorise `_depenseur` &#224; ne pas d&#233;penser plus que `_valeur` tokens en votre nom\n', '     *\n', '     * @param _depenseur L&#39;adresse autoris&#233;e &#224; d&#233;penser.\n', '     * @param _valeur Le montant maximum &#224; d&#233;penser.\n', '     */\n', '    function approuver ( address _depenseur, uint256 _valeur ) public returns ( bool succes ) {\n', '        autorisations[msg.sender][_depenseur] = _valeur;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * D&#233;finir une autorisation pour une autre adresse et le notifier\n', '     *\n', '     * Autorise `_depenseur` &#224; ne pas d&#233;penser plus que `_valeur` tokens en votre nom et le notifie\n', '     *\n', '     * @param _depenseur L&#39;adresse autoris&#233;e &#224; d&#233;penser.\n', '     * @param _valeur Le montant maximum &#224; d&#233;penser.\n', '     * @param _extraData Des donn&#233;es externes &#224; envoyer au contrat.\n', '     */\n', '    function approveAndCall ( address _depenseur, uint256 _valeur, bytes _extraData ) public returns ( bool success ) {\n', '        ReceveurDeTokens depenseur = ReceveurDeTokens ( _depenseur );\n', '        if ( approuver ( _depenseur, _valeur ) ) {\n', '            depenseur.recevoirApprobation ( msg.sender, _valeur, this );\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Destruction de tokens\n', '     *\n', '     * Retire `_valeur` tokens du syst&#232;me de mani&#232;re irr&#233;versible\n', '     *\n', '     * @param _valeur Le montant de tokens &#224; bruler.\n', '     */\n', '    function bruler ( uint256 _valeur ) public returns ( bool succes ) {\n', '        require ( comptes[msg.sender] >= _valeur );   // Check if the sender has enough\n', '        comptes[msg.sender] -= _valeur;            // Subtract from the sender\n', '        sommeTotale -= _valeur;                      // Updates totalSupply\n', '        emit Brules ( msg.sender, _valeur );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destruction de tokens d&#39;un autre compte&#39;\n', '     *\n', '     * Retire `_valeur` tokens du syst&#232;me de mani&#232;re irr&#233;versible au nom de &#39;_de&#39;\n', '     *\n', '     * @param _de L&#39;adresse de l&#39;envoyeur.\n', '     * @param _valeur Le montant de tokens &#224; br&#251;ler.\n', '     */\n', '    function brulerDe ( address _de, uint256 _valeur ) public returns ( bool success ) {\n', '        require ( comptes[_de] >= _valeur );                // Check if the targeted balance is enough\n', '        require ( _valeur <= autorisations[_de][msg.sender] );    // Check allowance\n', '        comptes[_de] -= _valeur;                         // Subtract from the targeted balance\n', '        autorisations[_de][msg.sender] -= _valeur;             // Subtract from the sender&#39;s allowance\n', '        sommeTotale -= _valeur;                              // Update totalSupply\n', '        emit Brules ( _de, _valeur );\n', '        return true;\n', '    }\n', '    \n', '}\n', '/******************************************/\n', '/*       LE TOKEN AVANC&#233; COMMENCE ICI     */\n', '/******************************************/\n', 'contract MonTokenAvance is Acquis, TokenERC20 {\n', '\n', '    uint256 public prixDeVente;\n', '    uint256 public prixDAchat;\n', '\n', '    mapping ( address => bool ) public comptesGeles;\n', '\n', '    /* G&#233;n&#232;re un &#233;v&#232;nement publique sur la BlocCha&#238;ne qui notifie les clients. */\n', '    event ComptesGeles ( address cible, bool gele );\n', '\n', '\n', '    /* Initialise le contrat et donne la sommeTotale au proprio du contrat. */\n', '            constructor ( uint256 sommeInitiale, string nomToken, string symboleToken )\n', '                TokenERC20 ( sommeInitiale, nomToken, symboleToken ) public {\n', '                \n', '                proprio = msg.sender;\n', '                \n', '            }\n', '\n', '        \n', '    /* Transfert interne, ne peut &#234;tre appel&#233; que par ce contrat. */\n', '    function _transfert ( address _de, address _a, uint _valeur ) internal {\n', '        require ( _a != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require ( comptes[_de] >= _valeur );               // Check if the sender has enough\n', '        require ( comptes[_a] + _valeur > comptes[_a]); // Check for overflows\n', '        require ( !comptesGeles[_de] );                     // Check if sender is frozen\n', '        require( !comptesGeles[_a] );                       // Check if recipient is frozen\n', '        comptes[_de] -= _valeur;                         // Subtract from the sender\n', '        comptes[_a] += _valeur;                           // Add the same to the recipient\n', '        emit Transfert ( _de, _a, _valeur );\n', '    }\n', '\n', '\n', '    /// @notice Cr&#233;e un `montantMine` de tokens et l&#39;envoie &#224; `cible`\n', '    /// @param cible Adresse qui re&#231;oit les tokens.\n', '    /// @param montantMine Le montant de tokens &#224; recevoir.\n', '    function minerToken ( address cible, uint256 montantMine ) proprioSeulement public {\n', '        comptes[cible] += montantMine;\n', '        sommeTotale += montantMine;\n', '        emit Transfert ( 0, this, montantMine );\n', '        emit Transfert ( this, cible, montantMine );\n', '    }\n', '\n', '    /// @notice `gelerCompte? Interdit | Autorise` `cible` &#224; envoyer et recevoir des tokens\n', '    /// @param cible L&#39;adresse &#224; geler.\n', '    /// @param gele Bool&#233;en gel&#233;/pas gel&#233;.\n', '    function gelerCompte ( address cible, bool gele ) proprioSeulement public {\n', '        comptesGeles[cible] = gele;\n', '        emit ComptesGeles ( cible, gele );\n', '    }\n', '\n', '    /// @notice Autorise les utilisateurs &#224; acheter des tokens &#224; `nouvPrixDAchat` eth et &#224; vendre des tokens pour `nouvPrixDeVente` eth\n', '    /// @param nouvPrixDeVente Prix auquel les utilisateurs peuvent vendre des tokens au contrat.\n', '    /// @param nouvPrixDAchat Prix auquel les utilisateurs peuvent acheter des tokens.\n', '    function setPrix ( uint256 nouvPrixDeVente, uint256 nouvPrixDAchat ) proprioSeulement public {\n', '        prixDeVente = nouvPrixDeVente;\n', '        prixDAchat = nouvPrixDAchat;\n', '    }\n', '\n', '    /// @notice Acheter des tokens du contrat en envoyant des ethers\n', '    function acheter() payable public {\n', '        uint montant = msg.value / prixDAchat;               // calcule le montant\n', '        _transfert ( this, msg.sender, montant );            // fais le transfert\n', '    }\n', '\n', '    /// @notice Vend `montant` tokens au contrat\n', '    /// @param montant Montant de tokens &#224; vendre.\n', '    function vendre ( uint256 montant ) public {\n', '        require( address ( this ).balance >= montant * prixDeVente );// v&#233;rifie si le contrat a assez d&#39;ethers pour acheter\n', '        _transfert ( msg.sender, this, montant );           // fait le transfert\n', '        msg.sender.transfer ( montant * prixDeVente );      // envoie les ethers au vendeur. Il est important de le faire endernier afin d&#39;&#233;viter toute attaque de r&#233;cursion&#39;\n', '    }\n', '    \n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']