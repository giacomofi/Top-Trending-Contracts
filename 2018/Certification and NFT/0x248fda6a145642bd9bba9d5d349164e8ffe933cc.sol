['pragma solidity ^0.4.24;\n', '\n', 'contract ExchangeAdmin {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyAdmin {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'library StringYokes {\n', '        function zint_bytes32ToString(bytes32 x) public pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '    function zint_convert(string key) public pure returns (bytes32 ret) {\n', '        if (bytes(key).length > 32) revert();\n', '        assembly {\n', '          ret := mload(add(key, 32))\n', '        }\n', '    }\n', '}    \n', 'contract Game is ExchangeAdmin {\n', '    \n', '    bool expired;\n', '    \n', '    struct Better {\n', '        bool used;\n', '        address betterAddress;\n', '        uint contribAmount;\n', '    }\n', '    \n', '    struct Side {\n', '        uint totalPledged;\n', '        bytes32 sideName;\n', '        address[] usedAddresses;\n', '        mapping (address => Better) contribDb;\n', '    }\n', '    string gName;\n', '    bytes32[] sides;\n', '    uint allSidesPledged;\n', '    uint expiry;\n', '    mapping (bytes32 => Side) public sideData;\n', '    mapping (bytes32 => uint) public idToNameRef;\n', '    \n', '    constructor (string gameName, uint gameExpiry, bytes32[] gameSides) public {\n', '        gName = gameName;\n', '        expiry = gameExpiry;\n', '        for (uint i = 0; i<gameSides.length; i++) {\n', '            sideData[gameSides[i]].sideName=gameSides[i];\n', '            idToNameRef[gameSides[i]]=i;\n', '            sides.push(gameSides[i]);\n', '        }\n', '        expired = false;\n', '        allSidesPledged = 0;\n', '    }\n', '    \n', '    function getGameName() view public returns (string) {\n', '        return gName;\n', '    }\n', '    function getGameSides() view public returns (bytes32[]) {\n', '        return sides;\n', '    }\n', '    function isNotExpired() view public returns (bool) {\n', '        return ((now < expiry) && !expired);\n', '    }\n', '    function getNumSides() view public returns (uint) {\n', '        return sides.length;\n', '    }\n', '    function getStrFromId(uint toConv) view public returns (string) {\n', '        return StringYokes.zint_bytes32ToString(sides[toConv]);\n', '    }\n', '    function getIdFromStr(string toConv) view public returns (uint) {\n', '        return idToNameRef[StringYokes.zint_convert(toConv)];\n', '    }\n', '    \n', '    function placeBet(address a, uint value, string betSide) public payable {\n', '        require(isNotExpired());\n', '        bytes32 index = StringYokes.zint_convert(betSide);\n', '        sideData[index].totalPledged+=value;\n', '        allSidesPledged+=value;\n', '        if (sideData[index].contribDb[a].used) {\n', '            value+=sideData[index].contribDb[a].contribAmount;\n', '        }\n', '        else {\n', '            sideData[index].usedAddresses.push(a);\n', '            sideData[index].contribDb[a].used=true;\n', '        }\n', '        sideData[index].contribDb[a].contribAmount+=value;\n', '    }\n', '    \n', '    function allSidesPledgedAmount() public view returns (uint) {\n', '        return allSidesPledged;\n', '    }\n', '    \n', '    function checkSidePledge(uint i) public view returns (uint) {\n', '        return sideData[sides[i]].totalPledged;\n', '    }\n', '    function dish(string winner, address profit) public onlyAdmin payable {\n', '        require(!expired);\n', '        expired = true;\n', '        bytes32 winByte = StringYokes.zint_convert(winner);\n', '        uint totalGameContrib = allSidesPledged;\n', '        uint totalSideContrib = (sideData[winByte].totalPledged);\n', '        for (uint i = 0; i<sideData[winByte].usedAddresses.length; i++) {\n', '            address recip = sideData[winByte].usedAddresses[i];\n', '            uint contribAmount = sideData[winByte].contribDb[recip].contribAmount;\n', '            uint winAddition = (925*1000*contribAmount*(totalGameContrib-totalSideContrib))/(1000000*totalSideContrib);\n', '            recip.transfer(contribAmount+winAddition);\n', '        }\n', '        profit.transfer(address(this).balance);\n', '    }\n', '    function refund() public onlyAdmin payable {\n', '        for (uint i = 0; i<sides.length; i++) {\n', '            for (uint j = 0; j<sideData[sides[i]].usedAddresses.length; j++) {\n', '            address recip = sideData[sides[i]].usedAddresses[j];\n', '            uint contribAmount = sideData[sides[i]].contribDb[recip].contribAmount;\n', '            recip.transfer(contribAmount);\n', '            }\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'contract BEthy is ExchangeAdmin {\n', '    Game[] current;\n', '    uint etherBalance;\n', '    \n', '    mapping (bytes32 => uint) public references;\n', '    \n', '    constructor () public {\n', '    }\n', '    \n', '    function addGame(string gameName, uint gameExpiry, bytes32[] gameSides) onlyAdmin public {\n', '        current.push(new Game(gameName, gameExpiry, gameSides));\n', '        references[StringYokes.zint_convert(gameName)]=current.length-1;\n', '    }\n', '    \n', '    function numGames() view public returns (uint) {\n', '        return current.length;\n', '    }\n', '    \n', '    function getName(uint i) view public returns (string, bool, uint) {\n', '       return (current[i].getGameName(), current[i].isNotExpired(), current[i].allSidesPledgedAmount());\n', '    }\n', '    \n', '    function getSidesById(uint i, uint j) view public returns (string, uint) {\n', '        return (StringYokes.zint_bytes32ToString(current[i].getGameSides()[j]), current[i].checkSidePledge(j));\n', '    }\n', '    \n', '    function getSides(string str, uint j) view public returns (string, uint) {\n', '        return getSidesById(references[StringYokes.zint_convert(str)], j);\n', '    }\n', '    \n', '    function getGameNumSides(uint i) view public returns (uint) {\n', '        return current[i].getNumSides();\n', '    }\n', '    function _byteToString(bytes32 x) public pure returns (string) {\n', '        return StringYokes.zint_bytes32ToString(x);\n', '    }\n', '    function _stringToByte(string x) public pure returns (bytes32) {\n', '        return StringYokes.zint_convert(x);\n', '    }\n', '    \n', '    function () public payable {\n', '        etherBalance+=msg.value;\n', '    }\n', '    \n', '    function getBalance() public view returns (uint) {\n', '        return etherBalance;\n', '    }\n', '    function getAddBal() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function placeBet(uint gameId, string betSide) payable public {\n', '        require(msg.value!=0);\n', '        etherBalance+=msg.value;\n', '        current[gameId].placeBet.value(msg.value)(msg.sender, msg.value, betSide);\n', '    }\n', '    \n', '    function placeBet(string gameId, string betSide) payable public {\n', '        placeBet(references[StringYokes.zint_convert(gameId)], betSide);\n', '    }\n', '    \n', '    function checkGameAmount(uint gameId) public view returns (uint) {\n', '        return current[gameId].allSidesPledgedAmount();\n', '    }\n', '    function checkGameSideAmount(uint gameId, uint sideNum) public view returns (uint) {\n', '        return current[gameId].checkSidePledge(sideNum);\n', '    }\n', '    \n', '    function endGame(uint gameId, string winningSide, address beneficiary) public onlyAdmin {//returns (address[10], uint[10]) {\n', '        current[gameId].dish(winningSide, beneficiary);\n', '    }\n', '    function endGame(uint gameId, uint winningId, address profit) public onlyAdmin {\n', '        endGame(gameId, current[gameId].getStrFromId(winningId), profit);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ExchangeAdmin {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyAdmin {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'library StringYokes {\n', '        function zint_bytes32ToString(bytes32 x) public pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '    function zint_convert(string key) public pure returns (bytes32 ret) {\n', '        if (bytes(key).length > 32) revert();\n', '        assembly {\n', '          ret := mload(add(key, 32))\n', '        }\n', '    }\n', '}    \n', 'contract Game is ExchangeAdmin {\n', '    \n', '    bool expired;\n', '    \n', '    struct Better {\n', '        bool used;\n', '        address betterAddress;\n', '        uint contribAmount;\n', '    }\n', '    \n', '    struct Side {\n', '        uint totalPledged;\n', '        bytes32 sideName;\n', '        address[] usedAddresses;\n', '        mapping (address => Better) contribDb;\n', '    }\n', '    string gName;\n', '    bytes32[] sides;\n', '    uint allSidesPledged;\n', '    uint expiry;\n', '    mapping (bytes32 => Side) public sideData;\n', '    mapping (bytes32 => uint) public idToNameRef;\n', '    \n', '    constructor (string gameName, uint gameExpiry, bytes32[] gameSides) public {\n', '        gName = gameName;\n', '        expiry = gameExpiry;\n', '        for (uint i = 0; i<gameSides.length; i++) {\n', '            sideData[gameSides[i]].sideName=gameSides[i];\n', '            idToNameRef[gameSides[i]]=i;\n', '            sides.push(gameSides[i]);\n', '        }\n', '        expired = false;\n', '        allSidesPledged = 0;\n', '    }\n', '    \n', '    function getGameName() view public returns (string) {\n', '        return gName;\n', '    }\n', '    function getGameSides() view public returns (bytes32[]) {\n', '        return sides;\n', '    }\n', '    function isNotExpired() view public returns (bool) {\n', '        return ((now < expiry) && !expired);\n', '    }\n', '    function getNumSides() view public returns (uint) {\n', '        return sides.length;\n', '    }\n', '    function getStrFromId(uint toConv) view public returns (string) {\n', '        return StringYokes.zint_bytes32ToString(sides[toConv]);\n', '    }\n', '    function getIdFromStr(string toConv) view public returns (uint) {\n', '        return idToNameRef[StringYokes.zint_convert(toConv)];\n', '    }\n', '    \n', '    function placeBet(address a, uint value, string betSide) public payable {\n', '        require(isNotExpired());\n', '        bytes32 index = StringYokes.zint_convert(betSide);\n', '        sideData[index].totalPledged+=value;\n', '        allSidesPledged+=value;\n', '        if (sideData[index].contribDb[a].used) {\n', '            value+=sideData[index].contribDb[a].contribAmount;\n', '        }\n', '        else {\n', '            sideData[index].usedAddresses.push(a);\n', '            sideData[index].contribDb[a].used=true;\n', '        }\n', '        sideData[index].contribDb[a].contribAmount+=value;\n', '    }\n', '    \n', '    function allSidesPledgedAmount() public view returns (uint) {\n', '        return allSidesPledged;\n', '    }\n', '    \n', '    function checkSidePledge(uint i) public view returns (uint) {\n', '        return sideData[sides[i]].totalPledged;\n', '    }\n', '    function dish(string winner, address profit) public onlyAdmin payable {\n', '        require(!expired);\n', '        expired = true;\n', '        bytes32 winByte = StringYokes.zint_convert(winner);\n', '        uint totalGameContrib = allSidesPledged;\n', '        uint totalSideContrib = (sideData[winByte].totalPledged);\n', '        for (uint i = 0; i<sideData[winByte].usedAddresses.length; i++) {\n', '            address recip = sideData[winByte].usedAddresses[i];\n', '            uint contribAmount = sideData[winByte].contribDb[recip].contribAmount;\n', '            uint winAddition = (925*1000*contribAmount*(totalGameContrib-totalSideContrib))/(1000000*totalSideContrib);\n', '            recip.transfer(contribAmount+winAddition);\n', '        }\n', '        profit.transfer(address(this).balance);\n', '    }\n', '    function refund() public onlyAdmin payable {\n', '        for (uint i = 0; i<sides.length; i++) {\n', '            for (uint j = 0; j<sideData[sides[i]].usedAddresses.length; j++) {\n', '            address recip = sideData[sides[i]].usedAddresses[j];\n', '            uint contribAmount = sideData[sides[i]].contribDb[recip].contribAmount;\n', '            recip.transfer(contribAmount);\n', '            }\n', '        }\n', '    }\n', '    \n', '}\n', '\n', 'contract BEthy is ExchangeAdmin {\n', '    Game[] current;\n', '    uint etherBalance;\n', '    \n', '    mapping (bytes32 => uint) public references;\n', '    \n', '    constructor () public {\n', '    }\n', '    \n', '    function addGame(string gameName, uint gameExpiry, bytes32[] gameSides) onlyAdmin public {\n', '        current.push(new Game(gameName, gameExpiry, gameSides));\n', '        references[StringYokes.zint_convert(gameName)]=current.length-1;\n', '    }\n', '    \n', '    function numGames() view public returns (uint) {\n', '        return current.length;\n', '    }\n', '    \n', '    function getName(uint i) view public returns (string, bool, uint) {\n', '       return (current[i].getGameName(), current[i].isNotExpired(), current[i].allSidesPledgedAmount());\n', '    }\n', '    \n', '    function getSidesById(uint i, uint j) view public returns (string, uint) {\n', '        return (StringYokes.zint_bytes32ToString(current[i].getGameSides()[j]), current[i].checkSidePledge(j));\n', '    }\n', '    \n', '    function getSides(string str, uint j) view public returns (string, uint) {\n', '        return getSidesById(references[StringYokes.zint_convert(str)], j);\n', '    }\n', '    \n', '    function getGameNumSides(uint i) view public returns (uint) {\n', '        return current[i].getNumSides();\n', '    }\n', '    function _byteToString(bytes32 x) public pure returns (string) {\n', '        return StringYokes.zint_bytes32ToString(x);\n', '    }\n', '    function _stringToByte(string x) public pure returns (bytes32) {\n', '        return StringYokes.zint_convert(x);\n', '    }\n', '    \n', '    function () public payable {\n', '        etherBalance+=msg.value;\n', '    }\n', '    \n', '    function getBalance() public view returns (uint) {\n', '        return etherBalance;\n', '    }\n', '    function getAddBal() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function placeBet(uint gameId, string betSide) payable public {\n', '        require(msg.value!=0);\n', '        etherBalance+=msg.value;\n', '        current[gameId].placeBet.value(msg.value)(msg.sender, msg.value, betSide);\n', '    }\n', '    \n', '    function placeBet(string gameId, string betSide) payable public {\n', '        placeBet(references[StringYokes.zint_convert(gameId)], betSide);\n', '    }\n', '    \n', '    function checkGameAmount(uint gameId) public view returns (uint) {\n', '        return current[gameId].allSidesPledgedAmount();\n', '    }\n', '    function checkGameSideAmount(uint gameId, uint sideNum) public view returns (uint) {\n', '        return current[gameId].checkSidePledge(sideNum);\n', '    }\n', '    \n', '    function endGame(uint gameId, string winningSide, address beneficiary) public onlyAdmin {//returns (address[10], uint[10]) {\n', '        current[gameId].dish(winningSide, beneficiary);\n', '    }\n', '    function endGame(uint gameId, uint winningId, address profit) public onlyAdmin {\n', '        endGame(gameId, current[gameId].getStrFromId(winningId), profit);\n', '    }\n', '}']
