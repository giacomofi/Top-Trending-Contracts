['pragma solidity ^0.4.19;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract INeoToken{\n', '    function buyToken(address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * @title NeoCrowdsale\n', ' * @dev NeoCrowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract NeoCrowdsale {\n', '  using SafeMath for uint256; \n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '  address public wallet;      // Address where funds are collected\n', '  uint256 public rate;        // How many token units a buyer gets per wei\n', '  uint256 public weiRaised;   // Amount of wei raised\n', '  INeoToken public token;\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  /**\n', '   * @dev Reverts if not in crowdsale time range. \n', '   */\n', '  modifier onlyWhileOpen {\n', '    require(now >= openingTime && now <= closingTime);\n', '    _;\n', '  }\n', '  \n', '  function NeoCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n', '    require(_openingTime >= now);\n', '    require(_closingTime >= _openingTime);\n', '\n', '    openingTime = _openingTime;\n', '    closingTime = _closingTime;\n', '\n', '    // takes an address of the existing token contract as parameter\n', '    token = INeoToken(0x468a553b152f65a482e1669672b0dbcd20f9fb50);\n', '    wallet = 0x0c4BdfE0aEbF69dE4975a957A2d4FE72633BBC1a;\n', '    rate = 15000; // rate per wei\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {\n', '\n', '    uint256 weiAmount = msg.value;\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '    \n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '\n', '    _processPurchase(_beneficiary, tokens);\n', '    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '    _forwardFunds(); \n', '  }\n', '  \n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) public onlyWhileOpen{\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '  \n', '  function _getTokenAmount(uint256 _weiAmount) public view returns (uint256) {\n', '    return _weiAmount.mul(rate);\n', '  }\n', '  \n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    token.buyToken(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '  \n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract INeoToken{\n', '    function buyToken(address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * @title NeoCrowdsale\n', ' * @dev NeoCrowdsale accepting contributions only within a time frame.\n', ' */\n', 'contract NeoCrowdsale {\n', '  using SafeMath for uint256; \n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '  address public wallet;      // Address where funds are collected\n', '  uint256 public rate;        // How many token units a buyer gets per wei\n', '  uint256 public weiRaised;   // Amount of wei raised\n', '  INeoToken public token;\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  /**\n', '   * @dev Reverts if not in crowdsale time range. \n', '   */\n', '  modifier onlyWhileOpen {\n', '    require(now >= openingTime && now <= closingTime);\n', '    _;\n', '  }\n', '  \n', '  function NeoCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n', '    require(_openingTime >= now);\n', '    require(_closingTime >= _openingTime);\n', '\n', '    openingTime = _openingTime;\n', '    closingTime = _closingTime;\n', '\n', '    // takes an address of the existing token contract as parameter\n', '    token = INeoToken(0x468a553b152f65a482e1669672b0dbcd20f9fb50);\n', '    wallet = 0x0c4BdfE0aEbF69dE4975a957A2d4FE72633BBC1a;\n', '    rate = 15000; // rate per wei\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {\n', '\n', '    uint256 weiAmount = msg.value;\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '    \n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '\n', '    _processPurchase(_beneficiary, tokens);\n', '    TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\n', '    _forwardFunds(); \n', '  }\n', '  \n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) public onlyWhileOpen{\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '  \n', '  function _getTokenAmount(uint256 _weiAmount) public view returns (uint256) {\n', '    return _weiAmount.mul(rate);\n', '  }\n', '  \n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '    token.buyToken(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '  \n', '  function _forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '\n', '}']
