['pragma solidity ^0.4.24;\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library addressSet {\n', '    struct _addressSet {\n', '        address[] members;\n', '        mapping(address => uint) memberIndices;\n', '    }\n', '\n', '    function insert(_addressSet storage self, address other) public {\n', '        if (!contains(self, other)) {\n', '            assert(length(self) < 2**256-1);\n', '            self.members.push(other);\n', '            self.memberIndices[other] = length(self);\n', '        }\n', '    }\n', '\n', '    function remove(_addressSet storage self, address other) public {\n', '        if (contains(self, other)) {\n', '            uint replaceIndex = self.memberIndices[other];\n', '            address lastMember = self.members[length(self)-1];\n', '            // overwrite other with the last member and remove last member\n', '            self.members[replaceIndex-1] = lastMember;\n', '            self.members.length--;\n', '            // reflect this change in the indices\n', '            self.memberIndices[lastMember] = replaceIndex;\n', '            delete self.memberIndices[other];\n', '        }\n', '    }\n', '\n', '    function contains(_addressSet storage self, address other) public view returns (bool) {\n', '        return self.memberIndices[other] > 0;\n', '    }\n', '\n', '    function length(_addressSet storage self) public view returns (uint) {\n', '        return self.members.length;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface SnowflakeResolver {\n', '    function callOnSignUp() external returns (bool);\n', '    function onSignUp(string hydroId, uint allowance) external returns (bool);\n', '    function callOnRemoval() external returns (bool);\n', '    function onRemoval(string hydroId) external returns(bool);\n', '}\n', '\n', 'interface ClientRaindrop {\n', '    function getUserByAddress(address _address) external view returns (string userName);\n', '    function isSigned(\n', '        address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s\n', '    ) external pure returns (bool);\n', '}\n', '\n', 'interface ViaContract {\n', '    function snowflakeCall(address resolver, string hydroIdFrom, string hydroIdTo, uint amount, bytes _bytes) external;\n', '    function snowflakeCall(address resolver, string hydroIdFrom, address to, uint amount, bytes _bytes) external;\n', '}\n', '\n', 'contract Snowflake is Ownable {\n', '    using SafeMath for uint;\n', '    using addressSet for addressSet._addressSet;\n', '\n', '    // hydro token wrapper variable\n', '    mapping (string => uint) internal deposits;\n', '\n', '    // signature variables\n', '    uint signatureTimeout;\n', '    mapping (bytes32 => bool) signatureLog;\n', '\n', '    // lookup mappings -- accessible only by wrapper functions\n', '    mapping (string => Identity) internal directory;\n', '    mapping (address => string) internal addressDirectory;\n', '    mapping (bytes32 => string) internal initiatedAddressClaims;\n', '\n', '    // admin/contract variables\n', '    address public clientRaindropAddress;\n', '    address public hydroTokenAddress;\n', '\n', '    addressSet._addressSet resolverWhitelist;\n', '\n', '    constructor() public {\n', '        setSignatureTimeout(7200);\n', '    }\n', '\n', '    // identity structures\n', '    struct Identity {\n', '        address owner;\n', '        addressSet._addressSet addresses;\n', '        addressSet._addressSet resolvers;\n', '        mapping(address => uint) resolverAllowances;\n', '    }\n', '\n', '    // checks whether the given address is owned by a token (does not throw)\n', '    function hasToken(address _address) public view returns (bool) {\n', '        return bytes(addressDirectory[_address]).length != 0;\n', '    }\n', '\n', '    // enforces that a particular address has a token\n', '    modifier _hasToken(address _address, bool check) {\n', '        require(hasToken(_address) == check, "The transaction sender does not have a Snowflake.");\n', '        _;\n', '    }\n', '\n', '    // gets the HydroID for an address (throws if address doesn&#39;t have a HydroID or doesn&#39;t have a snowflake)\n', '    function getHydroId(address _address) public view returns (string hydroId) {\n', '        require(hasToken(_address), "The address does not have a hydroId");\n', '        return addressDirectory[_address];\n', '    }\n', '\n', '    // allows whitelisting of resolvers\n', '    function whitelistResolver(address resolver) public {\n', '        resolverWhitelist.insert(resolver);\n', '        emit ResolverWhitelisted(resolver);\n', '    }\n', '\n', '    function isWhitelisted(address resolver) public view returns(bool) {\n', '        return resolverWhitelist.contains(resolver);\n', '    }\n', '\n', '    function getWhitelistedResolvers() public view returns(address[]) {\n', '        return resolverWhitelist.members;\n', '    }\n', '\n', '    // set the signature timeout\n', '    function setSignatureTimeout(uint newTimeout) public {\n', '        require(newTimeout >= 1800, "Timeout must be at least 30 minutes.");\n', '        require(newTimeout <= 604800, "Timeout must be less than a week.");\n', '        signatureTimeout = newTimeout;\n', '    }\n', '\n', '    // set the raindrop and hydro token addresses\n', '    function setAddresses(address clientRaindrop, address hydroToken) public onlyOwner {\n', '        clientRaindropAddress = clientRaindrop;\n', '        hydroTokenAddress = hydroToken;\n', '    }\n', '\n', '    // token minting\n', '    function mintIdentityToken() public _hasToken(msg.sender, false) {\n', '        _mintIdentityToken(msg.sender);\n', '    }\n', '\n', '    function mintIdentityTokenDelegated(address _address, uint8 v, bytes32 r, bytes32 s)\n', '        public _hasToken(_address, false)\n', '    {\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                _address, keccak256(abi.encodePacked("Create Snowflake", _address)), v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '        _mintIdentityToken(_address);\n', '    }\n', '\n', '    function _mintIdentityToken(address _address) internal {\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        string memory hydroId = clientRaindrop.getUserByAddress(_address);\n', '\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        identity.owner = _address;\n', '        identity.addresses.insert(_address);\n', '\n', '        addressDirectory[_address] = hydroId;\n', '\n', '        emit SnowflakeMinted(hydroId);\n', '    }\n', '\n', '    // wrappers that enable modifying resolvers\n', '    function addResolvers(address[] resolvers, uint[] withdrawAllowances) public _hasToken(msg.sender, true) {\n', '        _addResolvers(addressDirectory[msg.sender], resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function addResolversDelegated(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) public\n', '    {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '        // solium-disable-next-line security/no-block-members\n', '        require(timestamp.add(signatureTimeout) > block.timestamp, "Message was signed too long ago.");\n', '    \n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                directory[hydroId].owner,\n', '                keccak256(abi.encodePacked("Add Resolvers", resolvers, withdrawAllowances, timestamp)),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        _addResolvers(hydroId, resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function _addResolvers(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances\n', '    ) internal {\n', '        require(resolvers.length == withdrawAllowances.length, "Malformed inputs.");\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(resolverWhitelist.contains(resolvers[i]), "The given resolver is not on the whitelist.");\n', '            require(!identity.resolvers.contains(resolvers[i]), "Snowflake has already set this resolver.");\n', '            SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\n', '            identity.resolvers.insert(resolvers[i]);\n', '            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\n', '            if (snowflakeResolver.callOnSignUp()) {\n', '                require(\n', '                    snowflakeResolver.onSignUp(hydroId, withdrawAllowances[i]),\n', '                    "Sign up failure."\n', '                );\n', '            }\n', '            emit ResolverAdded(hydroId, resolvers[i], withdrawAllowances[i]);\n', '        }\n', '    }\n', '\n', '    function changeResolverAllowances(address[] resolvers, uint[] withdrawAllowances) \n', '        public _hasToken(msg.sender, true)\n', '    {\n', '        _changeResolverAllowances(addressDirectory[msg.sender], resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function changeResolverAllowancesDelegated(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) public\n', '    {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '\n', '        bytes32 _hash = keccak256(\n', '            abi.encodePacked("Change Resolver Allowances", resolvers, withdrawAllowances, timestamp)\n', '        );\n', '\n', '        require(signatureLog[_hash] == false, "Signature was already submitted");\n', '        signatureLog[_hash] = true;\n', '\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(clientRaindrop.isSigned(directory[hydroId].owner, _hash, v, r, s), "Permission denied.");\n', '\n', '        _changeResolverAllowances(hydroId, resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function _changeResolverAllowances(string hydroId, address[] resolvers, uint[] withdrawAllowances) internal {\n', '        require(resolvers.length == withdrawAllowances.length, "Malformed inputs.");\n', '\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(identity.resolvers.contains(resolvers[i]), "Snowflake has not set this resolver.");\n', '            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\n', '            emit ResolverAllowanceChanged(hydroId, resolvers[i], withdrawAllowances[i]);\n', '        }\n', '    }\n', '\n', '    function removeResolvers(address[] resolvers, bool force) public _hasToken(msg.sender, true) {\n', '        Identity storage identity = directory[addressDirectory[msg.sender]];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(identity.resolvers.contains(resolvers[i]), "Snowflake has not set this resolver.");\n', '            identity.resolvers.remove(resolvers[i]);\n', '            delete identity.resolverAllowances[resolvers[i]];\n', '            if (!force) {\n', '                SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\n', '                if (snowflakeResolver.callOnRemoval()) {\n', '                    require(\n', '                        snowflakeResolver.onRemoval(addressDirectory[msg.sender]),\n', '                        "Removal failure."\n', '                    );\n', '                }\n', '            }\n', '            emit ResolverRemoved(addressDirectory[msg.sender], resolvers[i]);\n', '        }\n', '    }\n', '\n', '    // functions to read token values (does not throw)\n', '    function getDetails(string hydroId) public view returns (\n', '        address owner,\n', '        address[] resolvers,\n', '        address[] ownedAddresses,\n', '        uint256 balance\n', '    ) {\n', '        Identity storage identity = directory[hydroId];\n', '        return (\n', '            identity.owner,\n', '            identity.resolvers.members,\n', '            identity.addresses.members,\n', '            deposits[hydroId]\n', '        );\n', '    }\n', '\n', '    // check resolver membership (does not throw)\n', '    function hasResolver(string hydroId, address resolver) public view returns (bool) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.resolvers.contains(resolver);\n', '    }\n', '\n', '    // check address ownership (does not throw)\n', '    function ownsAddress(string hydroId, address _address) public view returns (bool) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.addresses.contains(_address);\n', '    }\n', '\n', '    // check resolver allowances (does not throw)\n', '    function getResolverAllowance(string hydroId, address resolver) public view returns (uint withdrawAllowance) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.resolverAllowances[resolver];\n', '    }\n', ' \n', '    // allow contract to receive HYDRO tokens\n', '    function receiveApproval(address sender, uint amount, address _tokenAddress, bytes _bytes) public {\n', '        require(msg.sender == _tokenAddress, "Malformed inputs.");\n', '        require(_tokenAddress == hydroTokenAddress, "Sender is not the HYDRO token smart contract.");\n', '\n', '        address recipient;\n', '        if (_bytes.length == 20) {\n', '            assembly { // solium-disable-line security/no-inline-assembly\n', '                recipient := div(mload(add(add(_bytes, 0x20), 0)), 0x1000000000000000000000000)\n', '            }\n', '        } else {\n', '            recipient = sender;\n', '        }\n', '        require(hasToken(recipient), "Invalid token recipient");\n', '\n', '        ERC20 hydro = ERC20(_tokenAddress);\n', '        require(hydro.transferFrom(sender, address(this), amount), "Unable to transfer token ownership.");\n', '\n', '        deposits[addressDirectory[recipient]] = deposits[addressDirectory[recipient]].add(amount);\n', '\n', '        emit SnowflakeDeposit(addressDirectory[recipient], sender, amount);\n', '    }\n', '\n', '    function snowflakeBalance(string hydroId) public view returns (uint) {\n', '        return deposits[hydroId];\n', '    }\n', '\n', '    // transfer snowflake balance from one snowflake holder to another\n', '    function transferSnowflakeBalance(string hydroIdTo, uint amount) public _hasToken(msg.sender, true) {\n', '        _transfer(addressDirectory[msg.sender], hydroIdTo, amount);\n', '    }\n', '\n', '    // withdraw Snowflake balance to an external address\n', '    function withdrawSnowflakeBalance(address to, uint amount) public _hasToken(msg.sender, true) {\n', '        _withdraw(addressDirectory[msg.sender], to, amount);\n', '    }\n', '\n', '    // allows resolvers to transfer allowance amounts to other snowflakes (throws if unsuccessful)\n', '    function transferSnowflakeBalanceFrom(string hydroIdFrom, string hydroIdTo, uint amount) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _transfer(hydroIdFrom, hydroIdTo, amount);\n', '    }\n', '\n', '    // allows resolvers to withdraw allowance amounts to external addresses (throws if unsuccessful)\n', '    function withdrawSnowflakeBalanceFrom(string hydroIdFrom, address to, uint amount) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, to, amount);\n', '    }\n', '\n', '    // allows resolvers to send withdrawal amounts to arbitrary smart contracts &#39;to&#39; hydroIds (throws if unsuccessful)\n', '    function withdrawSnowflakeBalanceFromVia(\n', '        string hydroIdFrom, address via, string hydroIdTo, uint amount, bytes _bytes\n', '    ) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, via, amount);\n', '        ViaContract viaContract = ViaContract(via);\n', '        viaContract.snowflakeCall(msg.sender, hydroIdFrom, hydroIdTo, amount, _bytes);\n', '    }\n', '\n', '    // allows resolvers to send withdrawal amounts &#39;to&#39; addresses via arbitrary smart contracts \n', '    function withdrawSnowflakeBalanceFromVia(\n', '        string hydroIdFrom, address via, address to, uint amount, bytes _bytes\n', '    ) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, via, amount);\n', '        ViaContract viaContract = ViaContract(via);\n', '        viaContract.snowflakeCall(msg.sender, hydroIdFrom, to, amount, _bytes);\n', '    }\n', '\n', '    function _transfer(string hydroIdFrom, string hydroIdTo, uint amount) internal returns (bool) {\n', '        require(directory[hydroIdTo].owner != address(0), "Must transfer to an HydroID with a Snowflake");\n', '\n', '        require(deposits[hydroIdFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\n', '        deposits[hydroIdTo] = deposits[hydroIdTo].add(amount);\n', '\n', '        emit SnowflakeTransfer(hydroIdFrom, hydroIdTo, amount);\n', '    }\n', '\n', '    function _withdraw(string hydroIdFrom, address to, uint amount) internal {\n', '        require(to != address(this), "Cannot transfer to the Snowflake smart contract itself.");\n', '\n', '        require(deposits[hydroIdFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\n', '        ERC20 hydro = ERC20(hydroTokenAddress);\n', '        require(hydro.transfer(to, amount), "Transfer was unsuccessful");\n', '        emit SnowflakeWithdraw(to, amount);\n', '    }\n', '\n', '    function handleAllowance(string hydroIdFrom, uint amount) internal {\n', '        Identity storage identity = directory[hydroIdFrom];\n', '        require(identity.owner != address(0), "Must withdraw from a HydroID with a Snowflake");\n', '\n', '        // check that resolver-related details are correct\n', '        require(identity.resolvers.contains(msg.sender), "Resolver has not been set by from tokenholder.");\n', '        \n', '        if (identity.resolverAllowances[msg.sender] < amount) {\n', '            emit InsufficientAllowance(hydroIdFrom, msg.sender, identity.resolverAllowances[msg.sender], amount);\n', '            require(false, "Insufficient Allowance");\n', '        }\n', '\n', '        identity.resolverAllowances[msg.sender] = identity.resolverAllowances[msg.sender].sub(amount);\n', '    }\n', '\n', '    // address ownership functions\n', '    // to claim an address, users need to send a transaction from their snowflake address containing a sealed claim\n', '    // sealedClaims are: keccak256(abi.encodePacked(<address>, <secret>, <hydroId>)),\n', '    // where <address> is the address you&#39;d like to claim, and <secret> is a SECRET bytes32 value.\n', '    function initiateClaimDelegated(string hydroId, bytes32 sealedClaim, uint8 v, bytes32 r, bytes32 s) public {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                directory[hydroId].owner, keccak256(abi.encodePacked("Initiate Claim", sealedClaim)), v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        _initiateClaim(hydroId, sealedClaim);\n', '    }\n', '\n', '    function initiateClaim(bytes32 sealedClaim) public _hasToken(msg.sender, true) {\n', '        _initiateClaim(addressDirectory[msg.sender], sealedClaim);\n', '    }\n', '\n', '    function _initiateClaim(string hydroId, bytes32 sealedClaim) internal {\n', '        require(bytes(initiatedAddressClaims[sealedClaim]).length == 0, "This sealed claim has been submitted.");\n', '        initiatedAddressClaims[sealedClaim] = hydroId;\n', '    }\n', '\n', '    function finalizeClaim(bytes32 secret, string hydroId) public {\n', '        bytes32 possibleSealedClaim = keccak256(abi.encodePacked(msg.sender, secret, hydroId));\n', '        require(\n', '            bytes(initiatedAddressClaims[possibleSealedClaim]).length != 0, "This sealed claim hasn&#39;t been submitted."\n', '        );\n', '\n', '        // ensure that the claim wasn&#39;t stolen by another HydroID during initialization\n', '        require(\n', '            keccak256(abi.encodePacked(initiatedAddressClaims[possibleSealedClaim])) ==\n', '            keccak256(abi.encodePacked(hydroId)),\n', '            "Invalid signature."\n', '        );\n', '\n', '        directory[hydroId].addresses.insert(msg.sender);\n', '        addressDirectory[msg.sender] = hydroId;\n', '\n', '        emit AddressClaimed(msg.sender, hydroId);\n', '    }\n', '\n', '    function unclaim(address[] addresses) public _hasToken(msg.sender, true) {\n', '        for (uint i; i < addresses.length; i++) {\n', '            require(addresses[i] != directory[addressDirectory[msg.sender]].owner, "Cannot unclaim owner address.");\n', '            directory[addressDirectory[msg.sender]].addresses.remove(addresses[i]);\n', '            delete addressDirectory[addresses[i]];\n', '            emit AddressUnclaimed(addresses[i], addressDirectory[msg.sender]);\n', '        }\n', '    }\n', '\n', '    // events\n', '    event SnowflakeMinted(string hydroId);\n', '\n', '    event ResolverWhitelisted(address indexed resolver);\n', '\n', '    event ResolverAdded(string hydroId, address resolver, uint withdrawAllowance);\n', '    event ResolverAllowanceChanged(string hydroId, address resolver, uint withdrawAllowance);\n', '    event ResolverRemoved(string hydroId, address resolver);\n', '\n', '    event SnowflakeDeposit(string hydroId, address from, uint amount);\n', '    event SnowflakeTransfer(string hydroIdFrom, string hydroIdTo, uint amount);\n', '    event SnowflakeWithdraw(address to, uint amount);\n', '    event InsufficientAllowance(\n', '        string hydroId, address indexed resolver, uint currentAllowance, uint requestedWithdraw\n', '    );\n', '\n', '    event AddressClaimed(address indexed _address, string hydroId);\n', '    event AddressUnclaimed(address indexed _address, string hydroId);\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library addressSet {\n', '    struct _addressSet {\n', '        address[] members;\n', '        mapping(address => uint) memberIndices;\n', '    }\n', '\n', '    function insert(_addressSet storage self, address other) public {\n', '        if (!contains(self, other)) {\n', '            assert(length(self) < 2**256-1);\n', '            self.members.push(other);\n', '            self.memberIndices[other] = length(self);\n', '        }\n', '    }\n', '\n', '    function remove(_addressSet storage self, address other) public {\n', '        if (contains(self, other)) {\n', '            uint replaceIndex = self.memberIndices[other];\n', '            address lastMember = self.members[length(self)-1];\n', '            // overwrite other with the last member and remove last member\n', '            self.members[replaceIndex-1] = lastMember;\n', '            self.members.length--;\n', '            // reflect this change in the indices\n', '            self.memberIndices[lastMember] = replaceIndex;\n', '            delete self.memberIndices[other];\n', '        }\n', '    }\n', '\n', '    function contains(_addressSet storage self, address other) public view returns (bool) {\n', '        return self.memberIndices[other] > 0;\n', '    }\n', '\n', '    function length(_addressSet storage self) public view returns (uint) {\n', '        return self.members.length;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface SnowflakeResolver {\n', '    function callOnSignUp() external returns (bool);\n', '    function onSignUp(string hydroId, uint allowance) external returns (bool);\n', '    function callOnRemoval() external returns (bool);\n', '    function onRemoval(string hydroId) external returns(bool);\n', '}\n', '\n', 'interface ClientRaindrop {\n', '    function getUserByAddress(address _address) external view returns (string userName);\n', '    function isSigned(\n', '        address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s\n', '    ) external pure returns (bool);\n', '}\n', '\n', 'interface ViaContract {\n', '    function snowflakeCall(address resolver, string hydroIdFrom, string hydroIdTo, uint amount, bytes _bytes) external;\n', '    function snowflakeCall(address resolver, string hydroIdFrom, address to, uint amount, bytes _bytes) external;\n', '}\n', '\n', 'contract Snowflake is Ownable {\n', '    using SafeMath for uint;\n', '    using addressSet for addressSet._addressSet;\n', '\n', '    // hydro token wrapper variable\n', '    mapping (string => uint) internal deposits;\n', '\n', '    // signature variables\n', '    uint signatureTimeout;\n', '    mapping (bytes32 => bool) signatureLog;\n', '\n', '    // lookup mappings -- accessible only by wrapper functions\n', '    mapping (string => Identity) internal directory;\n', '    mapping (address => string) internal addressDirectory;\n', '    mapping (bytes32 => string) internal initiatedAddressClaims;\n', '\n', '    // admin/contract variables\n', '    address public clientRaindropAddress;\n', '    address public hydroTokenAddress;\n', '\n', '    addressSet._addressSet resolverWhitelist;\n', '\n', '    constructor() public {\n', '        setSignatureTimeout(7200);\n', '    }\n', '\n', '    // identity structures\n', '    struct Identity {\n', '        address owner;\n', '        addressSet._addressSet addresses;\n', '        addressSet._addressSet resolvers;\n', '        mapping(address => uint) resolverAllowances;\n', '    }\n', '\n', '    // checks whether the given address is owned by a token (does not throw)\n', '    function hasToken(address _address) public view returns (bool) {\n', '        return bytes(addressDirectory[_address]).length != 0;\n', '    }\n', '\n', '    // enforces that a particular address has a token\n', '    modifier _hasToken(address _address, bool check) {\n', '        require(hasToken(_address) == check, "The transaction sender does not have a Snowflake.");\n', '        _;\n', '    }\n', '\n', "    // gets the HydroID for an address (throws if address doesn't have a HydroID or doesn't have a snowflake)\n", '    function getHydroId(address _address) public view returns (string hydroId) {\n', '        require(hasToken(_address), "The address does not have a hydroId");\n', '        return addressDirectory[_address];\n', '    }\n', '\n', '    // allows whitelisting of resolvers\n', '    function whitelistResolver(address resolver) public {\n', '        resolverWhitelist.insert(resolver);\n', '        emit ResolverWhitelisted(resolver);\n', '    }\n', '\n', '    function isWhitelisted(address resolver) public view returns(bool) {\n', '        return resolverWhitelist.contains(resolver);\n', '    }\n', '\n', '    function getWhitelistedResolvers() public view returns(address[]) {\n', '        return resolverWhitelist.members;\n', '    }\n', '\n', '    // set the signature timeout\n', '    function setSignatureTimeout(uint newTimeout) public {\n', '        require(newTimeout >= 1800, "Timeout must be at least 30 minutes.");\n', '        require(newTimeout <= 604800, "Timeout must be less than a week.");\n', '        signatureTimeout = newTimeout;\n', '    }\n', '\n', '    // set the raindrop and hydro token addresses\n', '    function setAddresses(address clientRaindrop, address hydroToken) public onlyOwner {\n', '        clientRaindropAddress = clientRaindrop;\n', '        hydroTokenAddress = hydroToken;\n', '    }\n', '\n', '    // token minting\n', '    function mintIdentityToken() public _hasToken(msg.sender, false) {\n', '        _mintIdentityToken(msg.sender);\n', '    }\n', '\n', '    function mintIdentityTokenDelegated(address _address, uint8 v, bytes32 r, bytes32 s)\n', '        public _hasToken(_address, false)\n', '    {\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                _address, keccak256(abi.encodePacked("Create Snowflake", _address)), v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '        _mintIdentityToken(_address);\n', '    }\n', '\n', '    function _mintIdentityToken(address _address) internal {\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        string memory hydroId = clientRaindrop.getUserByAddress(_address);\n', '\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        identity.owner = _address;\n', '        identity.addresses.insert(_address);\n', '\n', '        addressDirectory[_address] = hydroId;\n', '\n', '        emit SnowflakeMinted(hydroId);\n', '    }\n', '\n', '    // wrappers that enable modifying resolvers\n', '    function addResolvers(address[] resolvers, uint[] withdrawAllowances) public _hasToken(msg.sender, true) {\n', '        _addResolvers(addressDirectory[msg.sender], resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function addResolversDelegated(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) public\n', '    {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '        // solium-disable-next-line security/no-block-members\n', '        require(timestamp.add(signatureTimeout) > block.timestamp, "Message was signed too long ago.");\n', '    \n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                directory[hydroId].owner,\n', '                keccak256(abi.encodePacked("Add Resolvers", resolvers, withdrawAllowances, timestamp)),\n', '                v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        _addResolvers(hydroId, resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function _addResolvers(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances\n', '    ) internal {\n', '        require(resolvers.length == withdrawAllowances.length, "Malformed inputs.");\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(resolverWhitelist.contains(resolvers[i]), "The given resolver is not on the whitelist.");\n', '            require(!identity.resolvers.contains(resolvers[i]), "Snowflake has already set this resolver.");\n', '            SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\n', '            identity.resolvers.insert(resolvers[i]);\n', '            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\n', '            if (snowflakeResolver.callOnSignUp()) {\n', '                require(\n', '                    snowflakeResolver.onSignUp(hydroId, withdrawAllowances[i]),\n', '                    "Sign up failure."\n', '                );\n', '            }\n', '            emit ResolverAdded(hydroId, resolvers[i], withdrawAllowances[i]);\n', '        }\n', '    }\n', '\n', '    function changeResolverAllowances(address[] resolvers, uint[] withdrawAllowances) \n', '        public _hasToken(msg.sender, true)\n', '    {\n', '        _changeResolverAllowances(addressDirectory[msg.sender], resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function changeResolverAllowancesDelegated(\n', '        string hydroId, address[] resolvers, uint[] withdrawAllowances, uint8 v, bytes32 r, bytes32 s, uint timestamp\n', '    ) public\n', '    {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '\n', '        bytes32 _hash = keccak256(\n', '            abi.encodePacked("Change Resolver Allowances", resolvers, withdrawAllowances, timestamp)\n', '        );\n', '\n', '        require(signatureLog[_hash] == false, "Signature was already submitted");\n', '        signatureLog[_hash] = true;\n', '\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(clientRaindrop.isSigned(directory[hydroId].owner, _hash, v, r, s), "Permission denied.");\n', '\n', '        _changeResolverAllowances(hydroId, resolvers, withdrawAllowances);\n', '    }\n', '\n', '    function _changeResolverAllowances(string hydroId, address[] resolvers, uint[] withdrawAllowances) internal {\n', '        require(resolvers.length == withdrawAllowances.length, "Malformed inputs.");\n', '\n', '        Identity storage identity = directory[hydroId];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(identity.resolvers.contains(resolvers[i]), "Snowflake has not set this resolver.");\n', '            identity.resolverAllowances[resolvers[i]] = withdrawAllowances[i];\n', '            emit ResolverAllowanceChanged(hydroId, resolvers[i], withdrawAllowances[i]);\n', '        }\n', '    }\n', '\n', '    function removeResolvers(address[] resolvers, bool force) public _hasToken(msg.sender, true) {\n', '        Identity storage identity = directory[addressDirectory[msg.sender]];\n', '\n', '        for (uint i; i < resolvers.length; i++) {\n', '            require(identity.resolvers.contains(resolvers[i]), "Snowflake has not set this resolver.");\n', '            identity.resolvers.remove(resolvers[i]);\n', '            delete identity.resolverAllowances[resolvers[i]];\n', '            if (!force) {\n', '                SnowflakeResolver snowflakeResolver = SnowflakeResolver(resolvers[i]);\n', '                if (snowflakeResolver.callOnRemoval()) {\n', '                    require(\n', '                        snowflakeResolver.onRemoval(addressDirectory[msg.sender]),\n', '                        "Removal failure."\n', '                    );\n', '                }\n', '            }\n', '            emit ResolverRemoved(addressDirectory[msg.sender], resolvers[i]);\n', '        }\n', '    }\n', '\n', '    // functions to read token values (does not throw)\n', '    function getDetails(string hydroId) public view returns (\n', '        address owner,\n', '        address[] resolvers,\n', '        address[] ownedAddresses,\n', '        uint256 balance\n', '    ) {\n', '        Identity storage identity = directory[hydroId];\n', '        return (\n', '            identity.owner,\n', '            identity.resolvers.members,\n', '            identity.addresses.members,\n', '            deposits[hydroId]\n', '        );\n', '    }\n', '\n', '    // check resolver membership (does not throw)\n', '    function hasResolver(string hydroId, address resolver) public view returns (bool) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.resolvers.contains(resolver);\n', '    }\n', '\n', '    // check address ownership (does not throw)\n', '    function ownsAddress(string hydroId, address _address) public view returns (bool) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.addresses.contains(_address);\n', '    }\n', '\n', '    // check resolver allowances (does not throw)\n', '    function getResolverAllowance(string hydroId, address resolver) public view returns (uint withdrawAllowance) {\n', '        Identity storage identity = directory[hydroId];\n', '        return identity.resolverAllowances[resolver];\n', '    }\n', ' \n', '    // allow contract to receive HYDRO tokens\n', '    function receiveApproval(address sender, uint amount, address _tokenAddress, bytes _bytes) public {\n', '        require(msg.sender == _tokenAddress, "Malformed inputs.");\n', '        require(_tokenAddress == hydroTokenAddress, "Sender is not the HYDRO token smart contract.");\n', '\n', '        address recipient;\n', '        if (_bytes.length == 20) {\n', '            assembly { // solium-disable-line security/no-inline-assembly\n', '                recipient := div(mload(add(add(_bytes, 0x20), 0)), 0x1000000000000000000000000)\n', '            }\n', '        } else {\n', '            recipient = sender;\n', '        }\n', '        require(hasToken(recipient), "Invalid token recipient");\n', '\n', '        ERC20 hydro = ERC20(_tokenAddress);\n', '        require(hydro.transferFrom(sender, address(this), amount), "Unable to transfer token ownership.");\n', '\n', '        deposits[addressDirectory[recipient]] = deposits[addressDirectory[recipient]].add(amount);\n', '\n', '        emit SnowflakeDeposit(addressDirectory[recipient], sender, amount);\n', '    }\n', '\n', '    function snowflakeBalance(string hydroId) public view returns (uint) {\n', '        return deposits[hydroId];\n', '    }\n', '\n', '    // transfer snowflake balance from one snowflake holder to another\n', '    function transferSnowflakeBalance(string hydroIdTo, uint amount) public _hasToken(msg.sender, true) {\n', '        _transfer(addressDirectory[msg.sender], hydroIdTo, amount);\n', '    }\n', '\n', '    // withdraw Snowflake balance to an external address\n', '    function withdrawSnowflakeBalance(address to, uint amount) public _hasToken(msg.sender, true) {\n', '        _withdraw(addressDirectory[msg.sender], to, amount);\n', '    }\n', '\n', '    // allows resolvers to transfer allowance amounts to other snowflakes (throws if unsuccessful)\n', '    function transferSnowflakeBalanceFrom(string hydroIdFrom, string hydroIdTo, uint amount) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _transfer(hydroIdFrom, hydroIdTo, amount);\n', '    }\n', '\n', '    // allows resolvers to withdraw allowance amounts to external addresses (throws if unsuccessful)\n', '    function withdrawSnowflakeBalanceFrom(string hydroIdFrom, address to, uint amount) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, to, amount);\n', '    }\n', '\n', "    // allows resolvers to send withdrawal amounts to arbitrary smart contracts 'to' hydroIds (throws if unsuccessful)\n", '    function withdrawSnowflakeBalanceFromVia(\n', '        string hydroIdFrom, address via, string hydroIdTo, uint amount, bytes _bytes\n', '    ) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, via, amount);\n', '        ViaContract viaContract = ViaContract(via);\n', '        viaContract.snowflakeCall(msg.sender, hydroIdFrom, hydroIdTo, amount, _bytes);\n', '    }\n', '\n', "    // allows resolvers to send withdrawal amounts 'to' addresses via arbitrary smart contracts \n", '    function withdrawSnowflakeBalanceFromVia(\n', '        string hydroIdFrom, address via, address to, uint amount, bytes _bytes\n', '    ) public {\n', '        handleAllowance(hydroIdFrom, amount);\n', '        _withdraw(hydroIdFrom, via, amount);\n', '        ViaContract viaContract = ViaContract(via);\n', '        viaContract.snowflakeCall(msg.sender, hydroIdFrom, to, amount, _bytes);\n', '    }\n', '\n', '    function _transfer(string hydroIdFrom, string hydroIdTo, uint amount) internal returns (bool) {\n', '        require(directory[hydroIdTo].owner != address(0), "Must transfer to an HydroID with a Snowflake");\n', '\n', '        require(deposits[hydroIdFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\n', '        deposits[hydroIdTo] = deposits[hydroIdTo].add(amount);\n', '\n', '        emit SnowflakeTransfer(hydroIdFrom, hydroIdTo, amount);\n', '    }\n', '\n', '    function _withdraw(string hydroIdFrom, address to, uint amount) internal {\n', '        require(to != address(this), "Cannot transfer to the Snowflake smart contract itself.");\n', '\n', '        require(deposits[hydroIdFrom] >= amount, "Cannot withdraw more than the current deposit balance.");\n', '        deposits[hydroIdFrom] = deposits[hydroIdFrom].sub(amount);\n', '        ERC20 hydro = ERC20(hydroTokenAddress);\n', '        require(hydro.transfer(to, amount), "Transfer was unsuccessful");\n', '        emit SnowflakeWithdraw(to, amount);\n', '    }\n', '\n', '    function handleAllowance(string hydroIdFrom, uint amount) internal {\n', '        Identity storage identity = directory[hydroIdFrom];\n', '        require(identity.owner != address(0), "Must withdraw from a HydroID with a Snowflake");\n', '\n', '        // check that resolver-related details are correct\n', '        require(identity.resolvers.contains(msg.sender), "Resolver has not been set by from tokenholder.");\n', '        \n', '        if (identity.resolverAllowances[msg.sender] < amount) {\n', '            emit InsufficientAllowance(hydroIdFrom, msg.sender, identity.resolverAllowances[msg.sender], amount);\n', '            require(false, "Insufficient Allowance");\n', '        }\n', '\n', '        identity.resolverAllowances[msg.sender] = identity.resolverAllowances[msg.sender].sub(amount);\n', '    }\n', '\n', '    // address ownership functions\n', '    // to claim an address, users need to send a transaction from their snowflake address containing a sealed claim\n', '    // sealedClaims are: keccak256(abi.encodePacked(<address>, <secret>, <hydroId>)),\n', "    // where <address> is the address you'd like to claim, and <secret> is a SECRET bytes32 value.\n", '    function initiateClaimDelegated(string hydroId, bytes32 sealedClaim, uint8 v, bytes32 r, bytes32 s) public {\n', '        require(directory[hydroId].owner != address(0), "Must initiate claim for a HydroID with a Snowflake");\n', '\n', '        ClientRaindrop clientRaindrop = ClientRaindrop(clientRaindropAddress);\n', '        require(\n', '            clientRaindrop.isSigned(\n', '                directory[hydroId].owner, keccak256(abi.encodePacked("Initiate Claim", sealedClaim)), v, r, s\n', '            ),\n', '            "Permission denied."\n', '        );\n', '\n', '        _initiateClaim(hydroId, sealedClaim);\n', '    }\n', '\n', '    function initiateClaim(bytes32 sealedClaim) public _hasToken(msg.sender, true) {\n', '        _initiateClaim(addressDirectory[msg.sender], sealedClaim);\n', '    }\n', '\n', '    function _initiateClaim(string hydroId, bytes32 sealedClaim) internal {\n', '        require(bytes(initiatedAddressClaims[sealedClaim]).length == 0, "This sealed claim has been submitted.");\n', '        initiatedAddressClaims[sealedClaim] = hydroId;\n', '    }\n', '\n', '    function finalizeClaim(bytes32 secret, string hydroId) public {\n', '        bytes32 possibleSealedClaim = keccak256(abi.encodePacked(msg.sender, secret, hydroId));\n', '        require(\n', '            bytes(initiatedAddressClaims[possibleSealedClaim]).length != 0, "This sealed claim hasn\'t been submitted."\n', '        );\n', '\n', "        // ensure that the claim wasn't stolen by another HydroID during initialization\n", '        require(\n', '            keccak256(abi.encodePacked(initiatedAddressClaims[possibleSealedClaim])) ==\n', '            keccak256(abi.encodePacked(hydroId)),\n', '            "Invalid signature."\n', '        );\n', '\n', '        directory[hydroId].addresses.insert(msg.sender);\n', '        addressDirectory[msg.sender] = hydroId;\n', '\n', '        emit AddressClaimed(msg.sender, hydroId);\n', '    }\n', '\n', '    function unclaim(address[] addresses) public _hasToken(msg.sender, true) {\n', '        for (uint i; i < addresses.length; i++) {\n', '            require(addresses[i] != directory[addressDirectory[msg.sender]].owner, "Cannot unclaim owner address.");\n', '            directory[addressDirectory[msg.sender]].addresses.remove(addresses[i]);\n', '            delete addressDirectory[addresses[i]];\n', '            emit AddressUnclaimed(addresses[i], addressDirectory[msg.sender]);\n', '        }\n', '    }\n', '\n', '    // events\n', '    event SnowflakeMinted(string hydroId);\n', '\n', '    event ResolverWhitelisted(address indexed resolver);\n', '\n', '    event ResolverAdded(string hydroId, address resolver, uint withdrawAllowance);\n', '    event ResolverAllowanceChanged(string hydroId, address resolver, uint withdrawAllowance);\n', '    event ResolverRemoved(string hydroId, address resolver);\n', '\n', '    event SnowflakeDeposit(string hydroId, address from, uint amount);\n', '    event SnowflakeTransfer(string hydroIdFrom, string hydroIdTo, uint amount);\n', '    event SnowflakeWithdraw(address to, uint amount);\n', '    event InsufficientAllowance(\n', '        string hydroId, address indexed resolver, uint currentAllowance, uint requestedWithdraw\n', '    );\n', '\n', '    event AddressClaimed(address indexed _address, string hydroId);\n', '    event AddressUnclaimed(address indexed _address, string hydroId);\n', '}']
