['pragma solidity ^0.4.19;\n', '\n', 'contract DigixConstants {\n', '  /// general constants\n', '  uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\n', '\n', '  /// asset events\n', '  uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\n', '  uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\n', '  uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\n', '  uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\n', '  uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\n', '  uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\n', '  uint256 constant ASSET_EVENT_MINTED = 7;\n', '  uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\n', '  uint256 constant ASSET_EVENT_RECASTED = 9;\n', '  uint256 constant ASSET_EVENT_REDEEMED = 10;\n', '  uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\n', '  uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\n', '  uint256 constant ASSET_EVENT_REMINTED = 13;\n', '\n', '  /// roles\n', '  uint256 constant ROLE_ZERO_ANYONE = 0;\n', '  uint256 constant ROLE_ROOT = 1;\n', '  uint256 constant ROLE_VENDOR = 2;\n', '  uint256 constant ROLE_XFERAUTH = 3;\n', '  uint256 constant ROLE_POPADMIN = 4;\n', '  uint256 constant ROLE_CUSTODIAN = 5;\n', '  uint256 constant ROLE_AUDITOR = 6;\n', '  uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\n', '  uint256 constant ROLE_KYC_ADMIN = 8;\n', '  uint256 constant ROLE_FEES_ADMIN = 9;\n', '  uint256 constant ROLE_DOCS_UPLOADER = 10;\n', '  uint256 constant ROLE_KYC_RECASTER = 11;\n', '  uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\n', '\n', '  /// states\n', '  uint256 constant STATE_ZERO_UNDEFINED = 0;\n', '  uint256 constant STATE_CREATED = 1;\n', '  uint256 constant STATE_VENDOR_ORDER = 2;\n', '  uint256 constant STATE_TRANSFER = 3;\n', '  uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\n', '  uint256 constant STATE_MINTED = 5;\n', '  uint256 constant STATE_AUDIT_FAILURE = 6;\n', '  uint256 constant STATE_REPLACEMENT_ORDER = 7;\n', '  uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\n', '  uint256 constant STATE_RECASTED = 9;\n', '  uint256 constant STATE_REDEEMED = 10;\n', '  uint256 constant STATE_ADMIN_FAILURE = 11;\n', '\n', '  /// interactive contracts\n', '  bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = "i:asset:explorer";\n', '  bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = "i:directory";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = "i:mp";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = "i:mpadmin";\n', '  bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = "i:popadmin";\n', '  bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = "i:products";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN = "i:token";\n', '  bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = "i:bulk-wrapper";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = "i:token:config";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = "i:token:information";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = "i:mp:information";\n', '  bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = "i:identity";\n', '\n', '  /// controller contracts\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS = "c:asset";\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = "c:asset:recast";\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = "c:explorer";\n', '  bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = "c:directory";\n', '  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = "c:mp";\n', '  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = "c:mpadmin";\n', '  bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = "c:products";\n', '\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = "c:token:approval";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = "c:token:config";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = "c:token:info";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = "c:token:transfer";\n', '\n', '  bytes32 constant CONTRACT_CONTROLLER_JOB_ID = "c:jobid";\n', '  bytes32 constant CONTRACT_CONTROLLER_IDENTITY = "c:identity";\n', '\n', '  /// storage contracts\n', '  bytes32 constant CONTRACT_STORAGE_ASSETS = "s:asset";\n', '  bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = "s:asset:events";\n', '  bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = "s:directory";\n', '  bytes32 constant CONTRACT_STORAGE_MARKETPLACE = "s:mp";\n', '  bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = "s:products";\n', '  bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = "s:goldtoken";\n', '  bytes32 constant CONTRACT_STORAGE_JOB_ID = "s:jobid";\n', '  bytes32 constant CONTRACT_STORAGE_IDENTITY = "s:identity";\n', '\n', '  /// service contracts\n', '  bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = "sv:tdemurrage";\n', '  bytes32 constant CONTRACT_SERVICE_MARKETPLACE = "sv:mp";\n', '  bytes32 constant CONTRACT_SERVICE_DIRECTORY = "sv:directory";\n', '\n', '  /// fees distributors\n', '  bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = "fees:distributor:demurrage";\n', '  bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = "fees:distributor:recast";\n', '  bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = "fees:distributor:transfer";\n', '}\n', '\n', 'contract ContractResolver {\n', '  address public owner;\n', '  bool public locked;\n', '  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);\n', '  function unregister_contract(bytes32 _key) public returns (bool _success);\n', '  function get_contract(bytes32 _key) public constant returns (address _contract);\n', '}\n', '\n', 'contract ResolverClient {\n', '\n', '  /// The address of the resolver contract for this project\n', '  address public resolver;\n', '  /// The key to identify this contract\n', '  bytes32 public key;\n', '\n', '  /// Make our own address available to us as a constant\n', '  address public CONTRACT_ADDRESS;\n', '\n', '  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n', '  /// @param _contract The resolver key\n', '  modifier if_sender_is(bytes32 _contract) {\n', '    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\n', '    _;\n', '  }\n', '\n', '  /// Function modifier to check resolver&#39;s locking status.\n', '  modifier unless_resolver_is_locked() {\n', '    require(is_locked() == false);\n', '    _;\n', '  }\n', '\n', '  /// @dev Initialize new contract\n', '  /// @param _key the resolver key for this contract\n', '  /// @return _success if the initialization is successful\n', '  function init(bytes32 _key, address _resolver)\n', '           internal\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(_resolver).locked();\n', '    if (_is_locked == false) {\n', '      CONTRACT_ADDRESS = address(this);\n', '      resolver = _resolver;\n', '      key = _key;\n', '      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n', '      _success = true;\n', '    }  else {\n', '      _success = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Destroy the contract and unregister self from the ContractResolver\n', '  /// @dev Can only be called by the owner of ContractResolver\n', '  function destroy()\n', '           public\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(resolver).locked();\n', '    require(!_is_locked);\n', '\n', '    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\n', '    require(msg.sender == _owner_of_contract_resolver);\n', '\n', '    _success = ContractResolver(resolver).unregister_contract(key);\n', '    require(_success);\n', '\n', '    selfdestruct(_owner_of_contract_resolver);\n', '  }\n', '\n', '  /// @dev Check if resolver is locked\n', '  /// @return _locked if the resolver is currently locked\n', '  function is_locked()\n', '           private\n', '           constant\n', '           returns (bool _locked)\n', '  {\n', '    _locked = ContractResolver(resolver).locked();\n', '  }\n', '\n', '  /// @dev Get the address of a contract\n', '  /// @param _key the resolver key to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract)\n', '  {\n', '    _contract = ContractResolver(resolver).get_contract(_key);\n', '  }\n', '}\n', '\n', '/// @title Some useful constants\n', '/// @author Digix Holdings Pte Ltd\n', 'contract Constants {\n', '  address constant NULL_ADDRESS = address(0x0);\n', '  uint256 constant ZERO = uint256(0);\n', '  bytes32 constant EMPTY = bytes32(0x0);\n', '}\n', '\n', '/// @title Condition based access control\n', '/// @author Digix Holdings Pte Ltd\n', 'contract ACConditions is Constants {\n', '\n', '  modifier not_null_address(address _item) {\n', '    require(_item != NULL_ADDRESS);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_address(address _item) {\n', '    require(_item == NULL_ADDRESS);\n', '    _;\n', '  }\n', '\n', '  modifier not_null_uint(uint256 _item) {\n', '    require(_item != ZERO);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_uint(uint256 _item) {\n', '    require(_item == ZERO);\n', '    _;\n', '  }\n', '\n', '  modifier not_empty_bytes(bytes32 _item) {\n', '    require(_item != EMPTY);\n', '    _;\n', '  }\n', '\n', '  modifier if_empty_bytes(bytes32 _item) {\n', '    require(_item == EMPTY);\n', '    _;\n', '  }\n', '\n', '  modifier not_null_string(string _item) {\n', '    bytes memory _i = bytes(_item);\n', '    require(_i.length > 0);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_string(string _item) {\n', '    bytes memory _i = bytes(_item);\n', '    require(_i.length == 0);\n', '    _;\n', '  }\n', '\n', '  modifier require_gas(uint256 _requiredgas) {\n', '    require(msg.gas  >= (_requiredgas - 22000));\n', '    _;\n', '  }\n', '\n', '  function is_contract(address _contract)\n', '           public\n', '           constant\n', '           returns (bool _is_contract)\n', '  {\n', '    uint32 _code_length;\n', '\n', '    assembly {\n', '      _code_length := extcodesize(_contract)\n', '    }\n', '\n', '    if(_code_length > 1) {\n', '      _is_contract = true;\n', '    } else {\n', '      _is_contract = false;\n', '    }\n', '  }\n', '\n', '  modifier if_contract(address _contract) {\n', '    require(is_contract(_contract) == true);\n', '    _;\n', '  }\n', '\n', '  modifier unless_contract(address _contract) {\n', '    require(is_contract(_contract) == false);\n', '    _;\n', '  }\n', '}\n', '\n', 'contract IdentityStorage {\n', '  function read_user(address _user) public constant returns (uint256 _id_expiration, bytes32 _doc);\n', '}\n', '\n', 'contract MarketplaceStorage {\n', '  function read_user(address _user) public constant returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today);\n', '  function read_user_daily_limit(address _user) public constant returns (uint256 _daily_dgx_limit);\n', '  function read_config() public constant returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector);\n', '  function read_dgx_inventory_balance_ng() public constant returns (uint256 _balance);\n', '  function read_total_number_of_purchases() public constant returns (uint256 _total_number_of_purchases);\n', '  function read_total_number_of_user_purchases(address _user) public constant returns (uint256 _total_number_of_user_purchases);\n', '  function read_purchase_at_index(uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\n', '  function read_user_purchase_at_index(address _user, uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\n', '  function read_total_global_purchased_today() public constant returns (uint256 _total_global_purchased_today);\n', '  function read_total_purchased_today(address _user) public constant returns (uint256 _total_purchased_today);\n', '  function read_max_dgx_available_daily() public constant returns (uint256 _max_dgx_available_daily);\n', '  function read_price_floor() public constant returns (uint256 _price_floor_wei_per_dgx_mg);\n', '}\n', '\n', 'contract MarketplaceControllerCommon {\n', '}\n', '\n', 'contract MarketplaceController {\n', '}\n', '\n', 'contract MarketplaceAdminController {\n', '}\n', '\n', 'contract MarketplaceCommon is ResolverClient, ACConditions, DigixConstants {\n', '\n', '  function marketplace_admin_controller()\n', '           internal\n', '           constant\n', '           returns (MarketplaceAdminController _contract)\n', '  {\n', '    _contract = MarketplaceAdminController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN));\n', '  }\n', '\n', '  function marketplace_storage()\n', '           internal\n', '           constant\n', '           returns (MarketplaceStorage _contract)\n', '  {\n', '    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\n', '  }\n', '\n', '  function marketplace_controller()\n', '           internal\n', '           constant\n', '           returns (MarketplaceController _contract)\n', '  {\n', '    _contract = MarketplaceController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE));\n', '  }\n', '}\n', '\n', '/// @title Digix Marketplace Information\n', '/// @author Digix Holdings Pte Ltd\n', '/// @notice This contract is used to read the configuration of the Digix&#39;s Marketplace\n', 'contract MarketplaceInformation is MarketplaceCommon {\n', '\n', '  function MarketplaceInformation(address _resolver) public\n', '  {\n', '    require(init(CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION, _resolver));\n', '  }\n', '\n', '  function identity_storage()\n', '           internal\n', '           constant\n', '           returns (IdentityStorage _contract)\n', '  {\n', '    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\n', '  }\n', '\n', '  /// @dev show user&#39;s current marketplace information and configuration, as well as some global configurations\n', '  /// @param _user the user&#39;s ethereum address\n', '  /// @return {\n', '  ///   "_user_daily_dgx_limit": "the amount of DGX that the user can purchase at any given day",\n', '  ///   "_user_id_expiration": "if KYC approved this will be a non-zero value as Unix timestamp when the submitted ID will expire",\n', '  ///   "_user_total_purchased_today": "The amount of tokens that the user has purchased in the last 24 hours",\n', '  ///   "_config_maximum_block_drift": "The number of ethereum blocks for which a pricefeed is valid for"\n', '  ///   "_config_minimum_purchase_dgx_ng": "The minimum amount of DGX that has to be purchased in one order",\n', '  ///   "_config_payment_collector": "Ethereum address of the collector which collects marketplace ether sent by buyers to buy DGX"\n', '  /// }\n', '  function getUserInfoAndConfig(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _user_daily_dgx_limit, uint256 _user_id_expiration, uint256 _user_total_purchased_today,\n', '                    uint256 _config_global_daily_dgx_ng_limit, uint256 _config_maximum_block_drift,\n', '                    uint256 _config_minimum_purchase_dgx_ng, address _config_payment_collector)\n', '  {\n', '    (_user_daily_dgx_limit, _user_total_purchased_today) =\n', '      marketplace_storage().read_user(_user);\n', '\n', '    (_user_id_expiration,) = identity_storage().read_user(_user);\n', '\n', '    (_config_global_daily_dgx_ng_limit, _config_minimum_purchase_dgx_ng, _config_maximum_block_drift, _config_payment_collector) =\n', '      marketplace_storage().read_config();\n', '  }\n', '\n', '  /// @dev get global marketplace configuration\n', '  /// @return {\n', '  ///     "_global_daily_dgx_ng_limit,": "the default max amount of DGX in nanograms the user can purchase daily",\n', '  ///     "_minimum_purchase_dgx_ng": "The minimum DGX nanograms that can be purchased",\n', '  ///     "_maximum_block_drift": "The number of blocks a pricefeed is valid for",\n', '  ///     "_payment_collector": "The ETH address where the payment should be sent to"\n', '  /// }\n', '  function getConfig()\n', '           public\n', '           constant\n', '           returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\n', '  {\n', '     (_global_daily_dgx_ng_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector) =\n', '       marketplace_storage().read_config();\n', '  }\n', '\n', '  /// @dev show the user&#39;s daily limit on DGX purchase\n', '  /// @param _user the user&#39;s ethereum address\n', '  /// @return {\n', '  ///   "_maximum_purchase_amount_ng": "The amount in DGX nanograms that the user can purchase daily"\n', '  /// }\n', '  function userMaximumPurchaseAmountNg(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _maximum_purchase_amount_ng)\n', '  {\n', '    _maximum_purchase_amount_ng = marketplace_storage().read_user_daily_limit(_user);\n', '  }\n', '\n', '  /// @dev show how many nanograms of DGX is in the Marketplace&#39;s inventory\n', '  /// @return {\n', '  ///   "_available_ng": "The amount in DGX nanograms in the inventory"\n', '  /// }\n', '  function availableDgxNg()\n', '           public\n', '           constant\n', '           returns (uint256 _available_ng)\n', '  {\n', '    _available_ng = marketplace_storage().read_dgx_inventory_balance_ng();\n', '  }\n', '\n', '  /// @dev return the total number of purchases done on marketplace\n', '  /// @return _total_number_of_purchases the total number of purchases on marketplace\n', '  function readTotalNumberOfPurchases()\n', '           public\n', '           constant\n', '           returns (uint256 _total_number_of_purchases)\n', '  {\n', '    _total_number_of_purchases = marketplace_storage().read_total_number_of_purchases();\n', '  }\n', '\n', '  /// @dev read the total number of purchases by a user\n', '  /// @param _user Ethereum address of the user\n', '  /// @return _total_number_of_user_purchases the total number of purchases made by the user on marketplace\n', '  function readTotalNumberOfUserPurchases(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _total_number_of_user_purchases)\n', '  {\n', '    _total_number_of_user_purchases = marketplace_storage().read_total_number_of_user_purchases(_user);\n', '  }\n', '\n', '  /// @dev read the purchase details at an index from all purchases\n', '  /// @param _index the index of the purchase in all purchases (index starts from 0)\n', '  /// @return {\n', '  ///   "_recipient": "DGX was purchases to this Ethereum address",\n', '  ///   "_timestamp": "the time at which the purchase was made",\n', '  ///   "_amount": "the amount of DGX nanograms purchased in this purchase",\n', '  ///   "_price": "the price paid by purchaser in web per dgx milligram"\n', '  /// }\n', '  function readPurchaseAtIndex(uint256 _index)\n', '           public\n', '           constant\n', '           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\n', '  {\n', '    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_purchase_at_index(_index);\n', '  }\n', '\n', '  /// @dev read the purchase details by a user at an index from all the user&#39;s purchases\n', '  /// @param _index the index of the purchase in all purchases by this user (index starts from 0)\n', '  /// @return {\n', '  ///   "_recipient": "DGX was purchases to this Ethereum address",\n', '  ///   "_timestamp": "the time at which the purchase was made",\n', '  ///   "_amount": "the amount of DGX nanograms purchased in this purchase",\n', '  ///   "_price": "the price paid by purchaser in web per dgx milligram"\n', '  /// }\n', '  function readUserPurchaseAtIndex(address _user, uint256 _index)\n', '           public\n', '           constant\n', '           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\n', '  {\n', '    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_user_purchase_at_index(_user, _index);\n', '  }\n', '\n', '  /// @dev read the total amount of DGX purchased today\n', '  /// @return _total_purchased_today the total amount of DGX purchased today at marketplace\n', '  function readGlobalPurchasedToday()\n', '           public\n', '           constant\n', '           returns (uint256 _total_purchased_today)\n', '  {\n', '    _total_purchased_today = marketplace_storage().read_total_global_purchased_today();\n', '  }\n', '\n', '  /// @dev read the amount of DGX purchased today by a user\n', '  /// @param _user Ethereum address of the user\n', '  /// @return _user_total_purchased_today the total amount of DGX purchased today by a user\n', '  function readUserPurchasedToday(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _user_total_purchased_today)\n', '  {\n', '    _user_total_purchased_today = marketplace_storage().read_total_purchased_today(_user);\n', '  }\n', '\n', '  /// @dev read the marketplace configurations\n', '  /// @return {\n', '  ///   "_global_default_user_daily_limit,": "Default maximum number of DGX nanograms that a user can purchase per day",\n', '  ///   "_minimum_purchase_dgx_ng": "minimum number of DGX nanograms that has to be purchased in a single purchase",\n', '  ///   "_maximum_block_drift": "the number of ethereum blocks for which the pricefeed is valid for",\n', '  ///   "_payment_collector": "the ethereum address that will receive the eth paid for a purchase",\n', '  ///   "_max_dgx_available_daily": "maximum number of DGX nanograms that are available for purchase on marketplace in a day",\n', '  ///   "_price_floor_wei_per_dgx_mg": "the price floor, minimum price, below which a purchase is invalid"\n', '  function readMarketplaceConfigs()\n', '           public\n', '           constant\n', '           returns (uint256 _global_default_user_daily_limit,\n', '                    uint256 _minimum_purchase_dgx_ng,\n', '                    uint256 _maximum_block_drift,\n', '                    address _payment_collector,\n', '                    uint256 _max_dgx_available_daily,\n', '                    uint256 _price_floor_wei_per_dgx_mg)\n', '  {\n', '    (_global_default_user_daily_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector)\n', '      = marketplace_storage().read_config();\n', '    _max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily();\n', '    _price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor();\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract DigixConstants {\n', '  /// general constants\n', '  uint256 constant SECONDS_IN_A_DAY = 24 * 60 * 60;\n', '\n', '  /// asset events\n', '  uint256 constant ASSET_EVENT_CREATED_VENDOR_ORDER = 1;\n', '  uint256 constant ASSET_EVENT_CREATED_TRANSFER_ORDER = 2;\n', '  uint256 constant ASSET_EVENT_CREATED_REPLACEMENT_ORDER = 3;\n', '  uint256 constant ASSET_EVENT_FULFILLED_VENDOR_ORDER = 4;\n', '  uint256 constant ASSET_EVENT_FULFILLED_TRANSFER_ORDER = 5;\n', '  uint256 constant ASSET_EVENT_FULFILLED_REPLACEMENT_ORDER = 6;\n', '  uint256 constant ASSET_EVENT_MINTED = 7;\n', '  uint256 constant ASSET_EVENT_MINTED_REPLACEMENT = 8;\n', '  uint256 constant ASSET_EVENT_RECASTED = 9;\n', '  uint256 constant ASSET_EVENT_REDEEMED = 10;\n', '  uint256 constant ASSET_EVENT_FAILED_AUDIT = 11;\n', '  uint256 constant ASSET_EVENT_ADMIN_FAILED = 12;\n', '  uint256 constant ASSET_EVENT_REMINTED = 13;\n', '\n', '  /// roles\n', '  uint256 constant ROLE_ZERO_ANYONE = 0;\n', '  uint256 constant ROLE_ROOT = 1;\n', '  uint256 constant ROLE_VENDOR = 2;\n', '  uint256 constant ROLE_XFERAUTH = 3;\n', '  uint256 constant ROLE_POPADMIN = 4;\n', '  uint256 constant ROLE_CUSTODIAN = 5;\n', '  uint256 constant ROLE_AUDITOR = 6;\n', '  uint256 constant ROLE_MARKETPLACE_ADMIN = 7;\n', '  uint256 constant ROLE_KYC_ADMIN = 8;\n', '  uint256 constant ROLE_FEES_ADMIN = 9;\n', '  uint256 constant ROLE_DOCS_UPLOADER = 10;\n', '  uint256 constant ROLE_KYC_RECASTER = 11;\n', '  uint256 constant ROLE_FEES_DISTRIBUTION_ADMIN = 12;\n', '\n', '  /// states\n', '  uint256 constant STATE_ZERO_UNDEFINED = 0;\n', '  uint256 constant STATE_CREATED = 1;\n', '  uint256 constant STATE_VENDOR_ORDER = 2;\n', '  uint256 constant STATE_TRANSFER = 3;\n', '  uint256 constant STATE_CUSTODIAN_DELIVERY = 4;\n', '  uint256 constant STATE_MINTED = 5;\n', '  uint256 constant STATE_AUDIT_FAILURE = 6;\n', '  uint256 constant STATE_REPLACEMENT_ORDER = 7;\n', '  uint256 constant STATE_REPLACEMENT_DELIVERY = 8;\n', '  uint256 constant STATE_RECASTED = 9;\n', '  uint256 constant STATE_REDEEMED = 10;\n', '  uint256 constant STATE_ADMIN_FAILURE = 11;\n', '\n', '  /// interactive contracts\n', '  bytes32 constant CONTRACT_INTERACTIVE_ASSETS_EXPLORER = "i:asset:explorer";\n', '  bytes32 constant CONTRACT_INTERACTIVE_DIGIX_DIRECTORY = "i:directory";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE = "i:mp";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_ADMIN = "i:mpadmin";\n', '  bytes32 constant CONTRACT_INTERACTIVE_POPADMIN = "i:popadmin";\n', '  bytes32 constant CONTRACT_INTERACTIVE_PRODUCTS_LIST = "i:products";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN = "i:token";\n', '  bytes32 constant CONTRACT_INTERACTIVE_BULK_WRAPPER = "i:bulk-wrapper";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_CONFIG = "i:token:config";\n', '  bytes32 constant CONTRACT_INTERACTIVE_TOKEN_INFORMATION = "i:token:information";\n', '  bytes32 constant CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION = "i:mp:information";\n', '  bytes32 constant CONTRACT_INTERACTIVE_IDENTITY = "i:identity";\n', '\n', '  /// controller contracts\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS = "c:asset";\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS_RECAST = "c:asset:recast";\n', '  bytes32 constant CONTRACT_CONTROLLER_ASSETS_EXPLORER = "c:explorer";\n', '  bytes32 constant CONTRACT_CONTROLLER_DIGIX_DIRECTORY = "c:directory";\n', '  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE = "c:mp";\n', '  bytes32 constant CONTRACT_CONTROLLER_MARKETPLACE_ADMIN = "c:mpadmin";\n', '  bytes32 constant CONTRACT_CONTROLLER_PRODUCTS_LIST = "c:products";\n', '\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_APPROVAL = "c:token:approval";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_CONFIG = "c:token:config";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_INFO = "c:token:info";\n', '  bytes32 constant CONTRACT_CONTROLLER_TOKEN_TRANSFER = "c:token:transfer";\n', '\n', '  bytes32 constant CONTRACT_CONTROLLER_JOB_ID = "c:jobid";\n', '  bytes32 constant CONTRACT_CONTROLLER_IDENTITY = "c:identity";\n', '\n', '  /// storage contracts\n', '  bytes32 constant CONTRACT_STORAGE_ASSETS = "s:asset";\n', '  bytes32 constant CONTRACT_STORAGE_ASSET_EVENTS = "s:asset:events";\n', '  bytes32 constant CONTRACT_STORAGE_DIGIX_DIRECTORY = "s:directory";\n', '  bytes32 constant CONTRACT_STORAGE_MARKETPLACE = "s:mp";\n', '  bytes32 constant CONTRACT_STORAGE_PRODUCTS_LIST = "s:products";\n', '  bytes32 constant CONTRACT_STORAGE_GOLD_TOKEN = "s:goldtoken";\n', '  bytes32 constant CONTRACT_STORAGE_JOB_ID = "s:jobid";\n', '  bytes32 constant CONTRACT_STORAGE_IDENTITY = "s:identity";\n', '\n', '  /// service contracts\n', '  bytes32 constant CONTRACT_SERVICE_TOKEN_DEMURRAGE = "sv:tdemurrage";\n', '  bytes32 constant CONTRACT_SERVICE_MARKETPLACE = "sv:mp";\n', '  bytes32 constant CONTRACT_SERVICE_DIRECTORY = "sv:directory";\n', '\n', '  /// fees distributors\n', '  bytes32 constant CONTRACT_DEMURRAGE_FEES_DISTRIBUTOR = "fees:distributor:demurrage";\n', '  bytes32 constant CONTRACT_RECAST_FEES_DISTRIBUTOR = "fees:distributor:recast";\n', '  bytes32 constant CONTRACT_TRANSFER_FEES_DISTRIBUTOR = "fees:distributor:transfer";\n', '}\n', '\n', 'contract ContractResolver {\n', '  address public owner;\n', '  bool public locked;\n', '  function init_register_contract(bytes32 _key, address _contract_address) public returns (bool _success);\n', '  function unregister_contract(bytes32 _key) public returns (bool _success);\n', '  function get_contract(bytes32 _key) public constant returns (address _contract);\n', '}\n', '\n', 'contract ResolverClient {\n', '\n', '  /// The address of the resolver contract for this project\n', '  address public resolver;\n', '  /// The key to identify this contract\n', '  bytes32 public key;\n', '\n', '  /// Make our own address available to us as a constant\n', '  address public CONTRACT_ADDRESS;\n', '\n', '  /// Function modifier to check if msg.sender corresponds to the resolved address of a given key\n', '  /// @param _contract The resolver key\n', '  modifier if_sender_is(bytes32 _contract) {\n', '    require(msg.sender == ContractResolver(resolver).get_contract(_contract));\n', '    _;\n', '  }\n', '\n', "  /// Function modifier to check resolver's locking status.\n", '  modifier unless_resolver_is_locked() {\n', '    require(is_locked() == false);\n', '    _;\n', '  }\n', '\n', '  /// @dev Initialize new contract\n', '  /// @param _key the resolver key for this contract\n', '  /// @return _success if the initialization is successful\n', '  function init(bytes32 _key, address _resolver)\n', '           internal\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(_resolver).locked();\n', '    if (_is_locked == false) {\n', '      CONTRACT_ADDRESS = address(this);\n', '      resolver = _resolver;\n', '      key = _key;\n', '      require(ContractResolver(resolver).init_register_contract(key, CONTRACT_ADDRESS));\n', '      _success = true;\n', '    }  else {\n', '      _success = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Destroy the contract and unregister self from the ContractResolver\n', '  /// @dev Can only be called by the owner of ContractResolver\n', '  function destroy()\n', '           public\n', '           returns (bool _success)\n', '  {\n', '    bool _is_locked = ContractResolver(resolver).locked();\n', '    require(!_is_locked);\n', '\n', '    address _owner_of_contract_resolver = ContractResolver(resolver).owner();\n', '    require(msg.sender == _owner_of_contract_resolver);\n', '\n', '    _success = ContractResolver(resolver).unregister_contract(key);\n', '    require(_success);\n', '\n', '    selfdestruct(_owner_of_contract_resolver);\n', '  }\n', '\n', '  /// @dev Check if resolver is locked\n', '  /// @return _locked if the resolver is currently locked\n', '  function is_locked()\n', '           private\n', '           constant\n', '           returns (bool _locked)\n', '  {\n', '    _locked = ContractResolver(resolver).locked();\n', '  }\n', '\n', '  /// @dev Get the address of a contract\n', '  /// @param _key the resolver key to look up\n', '  /// @return _contract the address of the contract\n', '  function get_contract(bytes32 _key)\n', '           public\n', '           constant\n', '           returns (address _contract)\n', '  {\n', '    _contract = ContractResolver(resolver).get_contract(_key);\n', '  }\n', '}\n', '\n', '/// @title Some useful constants\n', '/// @author Digix Holdings Pte Ltd\n', 'contract Constants {\n', '  address constant NULL_ADDRESS = address(0x0);\n', '  uint256 constant ZERO = uint256(0);\n', '  bytes32 constant EMPTY = bytes32(0x0);\n', '}\n', '\n', '/// @title Condition based access control\n', '/// @author Digix Holdings Pte Ltd\n', 'contract ACConditions is Constants {\n', '\n', '  modifier not_null_address(address _item) {\n', '    require(_item != NULL_ADDRESS);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_address(address _item) {\n', '    require(_item == NULL_ADDRESS);\n', '    _;\n', '  }\n', '\n', '  modifier not_null_uint(uint256 _item) {\n', '    require(_item != ZERO);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_uint(uint256 _item) {\n', '    require(_item == ZERO);\n', '    _;\n', '  }\n', '\n', '  modifier not_empty_bytes(bytes32 _item) {\n', '    require(_item != EMPTY);\n', '    _;\n', '  }\n', '\n', '  modifier if_empty_bytes(bytes32 _item) {\n', '    require(_item == EMPTY);\n', '    _;\n', '  }\n', '\n', '  modifier not_null_string(string _item) {\n', '    bytes memory _i = bytes(_item);\n', '    require(_i.length > 0);\n', '    _;\n', '  }\n', '\n', '  modifier if_null_string(string _item) {\n', '    bytes memory _i = bytes(_item);\n', '    require(_i.length == 0);\n', '    _;\n', '  }\n', '\n', '  modifier require_gas(uint256 _requiredgas) {\n', '    require(msg.gas  >= (_requiredgas - 22000));\n', '    _;\n', '  }\n', '\n', '  function is_contract(address _contract)\n', '           public\n', '           constant\n', '           returns (bool _is_contract)\n', '  {\n', '    uint32 _code_length;\n', '\n', '    assembly {\n', '      _code_length := extcodesize(_contract)\n', '    }\n', '\n', '    if(_code_length > 1) {\n', '      _is_contract = true;\n', '    } else {\n', '      _is_contract = false;\n', '    }\n', '  }\n', '\n', '  modifier if_contract(address _contract) {\n', '    require(is_contract(_contract) == true);\n', '    _;\n', '  }\n', '\n', '  modifier unless_contract(address _contract) {\n', '    require(is_contract(_contract) == false);\n', '    _;\n', '  }\n', '}\n', '\n', 'contract IdentityStorage {\n', '  function read_user(address _user) public constant returns (uint256 _id_expiration, bytes32 _doc);\n', '}\n', '\n', 'contract MarketplaceStorage {\n', '  function read_user(address _user) public constant returns (uint256 _daily_dgx_limit, uint256 _total_purchased_today);\n', '  function read_user_daily_limit(address _user) public constant returns (uint256 _daily_dgx_limit);\n', '  function read_config() public constant returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector);\n', '  function read_dgx_inventory_balance_ng() public constant returns (uint256 _balance);\n', '  function read_total_number_of_purchases() public constant returns (uint256 _total_number_of_purchases);\n', '  function read_total_number_of_user_purchases(address _user) public constant returns (uint256 _total_number_of_user_purchases);\n', '  function read_purchase_at_index(uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\n', '  function read_user_purchase_at_index(address _user, uint256 _index) public constant returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price);\n', '  function read_total_global_purchased_today() public constant returns (uint256 _total_global_purchased_today);\n', '  function read_total_purchased_today(address _user) public constant returns (uint256 _total_purchased_today);\n', '  function read_max_dgx_available_daily() public constant returns (uint256 _max_dgx_available_daily);\n', '  function read_price_floor() public constant returns (uint256 _price_floor_wei_per_dgx_mg);\n', '}\n', '\n', 'contract MarketplaceControllerCommon {\n', '}\n', '\n', 'contract MarketplaceController {\n', '}\n', '\n', 'contract MarketplaceAdminController {\n', '}\n', '\n', 'contract MarketplaceCommon is ResolverClient, ACConditions, DigixConstants {\n', '\n', '  function marketplace_admin_controller()\n', '           internal\n', '           constant\n', '           returns (MarketplaceAdminController _contract)\n', '  {\n', '    _contract = MarketplaceAdminController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE_ADMIN));\n', '  }\n', '\n', '  function marketplace_storage()\n', '           internal\n', '           constant\n', '           returns (MarketplaceStorage _contract)\n', '  {\n', '    _contract = MarketplaceStorage(get_contract(CONTRACT_STORAGE_MARKETPLACE));\n', '  }\n', '\n', '  function marketplace_controller()\n', '           internal\n', '           constant\n', '           returns (MarketplaceController _contract)\n', '  {\n', '    _contract = MarketplaceController(get_contract(CONTRACT_CONTROLLER_MARKETPLACE));\n', '  }\n', '}\n', '\n', '/// @title Digix Marketplace Information\n', '/// @author Digix Holdings Pte Ltd\n', "/// @notice This contract is used to read the configuration of the Digix's Marketplace\n", 'contract MarketplaceInformation is MarketplaceCommon {\n', '\n', '  function MarketplaceInformation(address _resolver) public\n', '  {\n', '    require(init(CONTRACT_INTERACTIVE_MARKETPLACE_INFORMATION, _resolver));\n', '  }\n', '\n', '  function identity_storage()\n', '           internal\n', '           constant\n', '           returns (IdentityStorage _contract)\n', '  {\n', '    _contract = IdentityStorage(get_contract(CONTRACT_STORAGE_IDENTITY));\n', '  }\n', '\n', "  /// @dev show user's current marketplace information and configuration, as well as some global configurations\n", "  /// @param _user the user's ethereum address\n", '  /// @return {\n', '  ///   "_user_daily_dgx_limit": "the amount of DGX that the user can purchase at any given day",\n', '  ///   "_user_id_expiration": "if KYC approved this will be a non-zero value as Unix timestamp when the submitted ID will expire",\n', '  ///   "_user_total_purchased_today": "The amount of tokens that the user has purchased in the last 24 hours",\n', '  ///   "_config_maximum_block_drift": "The number of ethereum blocks for which a pricefeed is valid for"\n', '  ///   "_config_minimum_purchase_dgx_ng": "The minimum amount of DGX that has to be purchased in one order",\n', '  ///   "_config_payment_collector": "Ethereum address of the collector which collects marketplace ether sent by buyers to buy DGX"\n', '  /// }\n', '  function getUserInfoAndConfig(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _user_daily_dgx_limit, uint256 _user_id_expiration, uint256 _user_total_purchased_today,\n', '                    uint256 _config_global_daily_dgx_ng_limit, uint256 _config_maximum_block_drift,\n', '                    uint256 _config_minimum_purchase_dgx_ng, address _config_payment_collector)\n', '  {\n', '    (_user_daily_dgx_limit, _user_total_purchased_today) =\n', '      marketplace_storage().read_user(_user);\n', '\n', '    (_user_id_expiration,) = identity_storage().read_user(_user);\n', '\n', '    (_config_global_daily_dgx_ng_limit, _config_minimum_purchase_dgx_ng, _config_maximum_block_drift, _config_payment_collector) =\n', '      marketplace_storage().read_config();\n', '  }\n', '\n', '  /// @dev get global marketplace configuration\n', '  /// @return {\n', '  ///     "_global_daily_dgx_ng_limit,": "the default max amount of DGX in nanograms the user can purchase daily",\n', '  ///     "_minimum_purchase_dgx_ng": "The minimum DGX nanograms that can be purchased",\n', '  ///     "_maximum_block_drift": "The number of blocks a pricefeed is valid for",\n', '  ///     "_payment_collector": "The ETH address where the payment should be sent to"\n', '  /// }\n', '  function getConfig()\n', '           public\n', '           constant\n', '           returns (uint256 _global_daily_dgx_ng_limit, uint256 _minimum_purchase_dgx_ng, uint256 _maximum_block_drift, address _payment_collector)\n', '  {\n', '     (_global_daily_dgx_ng_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector) =\n', '       marketplace_storage().read_config();\n', '  }\n', '\n', "  /// @dev show the user's daily limit on DGX purchase\n", "  /// @param _user the user's ethereum address\n", '  /// @return {\n', '  ///   "_maximum_purchase_amount_ng": "The amount in DGX nanograms that the user can purchase daily"\n', '  /// }\n', '  function userMaximumPurchaseAmountNg(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _maximum_purchase_amount_ng)\n', '  {\n', '    _maximum_purchase_amount_ng = marketplace_storage().read_user_daily_limit(_user);\n', '  }\n', '\n', "  /// @dev show how many nanograms of DGX is in the Marketplace's inventory\n", '  /// @return {\n', '  ///   "_available_ng": "The amount in DGX nanograms in the inventory"\n', '  /// }\n', '  function availableDgxNg()\n', '           public\n', '           constant\n', '           returns (uint256 _available_ng)\n', '  {\n', '    _available_ng = marketplace_storage().read_dgx_inventory_balance_ng();\n', '  }\n', '\n', '  /// @dev return the total number of purchases done on marketplace\n', '  /// @return _total_number_of_purchases the total number of purchases on marketplace\n', '  function readTotalNumberOfPurchases()\n', '           public\n', '           constant\n', '           returns (uint256 _total_number_of_purchases)\n', '  {\n', '    _total_number_of_purchases = marketplace_storage().read_total_number_of_purchases();\n', '  }\n', '\n', '  /// @dev read the total number of purchases by a user\n', '  /// @param _user Ethereum address of the user\n', '  /// @return _total_number_of_user_purchases the total number of purchases made by the user on marketplace\n', '  function readTotalNumberOfUserPurchases(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _total_number_of_user_purchases)\n', '  {\n', '    _total_number_of_user_purchases = marketplace_storage().read_total_number_of_user_purchases(_user);\n', '  }\n', '\n', '  /// @dev read the purchase details at an index from all purchases\n', '  /// @param _index the index of the purchase in all purchases (index starts from 0)\n', '  /// @return {\n', '  ///   "_recipient": "DGX was purchases to this Ethereum address",\n', '  ///   "_timestamp": "the time at which the purchase was made",\n', '  ///   "_amount": "the amount of DGX nanograms purchased in this purchase",\n', '  ///   "_price": "the price paid by purchaser in web per dgx milligram"\n', '  /// }\n', '  function readPurchaseAtIndex(uint256 _index)\n', '           public\n', '           constant\n', '           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\n', '  {\n', '    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_purchase_at_index(_index);\n', '  }\n', '\n', "  /// @dev read the purchase details by a user at an index from all the user's purchases\n", '  /// @param _index the index of the purchase in all purchases by this user (index starts from 0)\n', '  /// @return {\n', '  ///   "_recipient": "DGX was purchases to this Ethereum address",\n', '  ///   "_timestamp": "the time at which the purchase was made",\n', '  ///   "_amount": "the amount of DGX nanograms purchased in this purchase",\n', '  ///   "_price": "the price paid by purchaser in web per dgx milligram"\n', '  /// }\n', '  function readUserPurchaseAtIndex(address _user, uint256 _index)\n', '           public\n', '           constant\n', '           returns (address _recipient, uint256 _timestamp, uint256 _amount, uint256 _price)\n', '  {\n', '    (_recipient, _timestamp, _amount, _price) = marketplace_storage().read_user_purchase_at_index(_user, _index);\n', '  }\n', '\n', '  /// @dev read the total amount of DGX purchased today\n', '  /// @return _total_purchased_today the total amount of DGX purchased today at marketplace\n', '  function readGlobalPurchasedToday()\n', '           public\n', '           constant\n', '           returns (uint256 _total_purchased_today)\n', '  {\n', '    _total_purchased_today = marketplace_storage().read_total_global_purchased_today();\n', '  }\n', '\n', '  /// @dev read the amount of DGX purchased today by a user\n', '  /// @param _user Ethereum address of the user\n', '  /// @return _user_total_purchased_today the total amount of DGX purchased today by a user\n', '  function readUserPurchasedToday(address _user)\n', '           public\n', '           constant\n', '           returns (uint256 _user_total_purchased_today)\n', '  {\n', '    _user_total_purchased_today = marketplace_storage().read_total_purchased_today(_user);\n', '  }\n', '\n', '  /// @dev read the marketplace configurations\n', '  /// @return {\n', '  ///   "_global_default_user_daily_limit,": "Default maximum number of DGX nanograms that a user can purchase per day",\n', '  ///   "_minimum_purchase_dgx_ng": "minimum number of DGX nanograms that has to be purchased in a single purchase",\n', '  ///   "_maximum_block_drift": "the number of ethereum blocks for which the pricefeed is valid for",\n', '  ///   "_payment_collector": "the ethereum address that will receive the eth paid for a purchase",\n', '  ///   "_max_dgx_available_daily": "maximum number of DGX nanograms that are available for purchase on marketplace in a day",\n', '  ///   "_price_floor_wei_per_dgx_mg": "the price floor, minimum price, below which a purchase is invalid"\n', '  function readMarketplaceConfigs()\n', '           public\n', '           constant\n', '           returns (uint256 _global_default_user_daily_limit,\n', '                    uint256 _minimum_purchase_dgx_ng,\n', '                    uint256 _maximum_block_drift,\n', '                    address _payment_collector,\n', '                    uint256 _max_dgx_available_daily,\n', '                    uint256 _price_floor_wei_per_dgx_mg)\n', '  {\n', '    (_global_default_user_daily_limit, _minimum_purchase_dgx_ng, _maximum_block_drift, _payment_collector)\n', '      = marketplace_storage().read_config();\n', '    _max_dgx_available_daily = marketplace_storage().read_max_dgx_available_daily();\n', '    _price_floor_wei_per_dgx_mg = marketplace_storage().read_price_floor();\n', '  }\n', '\n', '}']
