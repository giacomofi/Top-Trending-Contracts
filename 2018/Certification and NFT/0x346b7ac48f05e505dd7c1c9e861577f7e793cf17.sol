['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface ERC165 {\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceId The interface identifier, as specified in ERC-165\n', '   * @dev Interface identification is specified in ERC-165. This function\n', '   * uses less than 30,000 gas.\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SupportsInterfaceWithLookup\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract SupportsInterfaceWithLookup is ERC165 {\n', '\n', '  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n', '  /**\n', '   * 0x01ffc9a7 ===\n', "   *   bytes4(keccak256('supportsInterface(bytes4)'))\n", '   */\n', '\n', '  /**\n', "   * @dev a mapping of interface id to whether or not it's supported\n", '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev A contract implementing SupportsInterfaceWithLookup\n', '   * implement ERC165 itself\n', '   */\n', '  constructor()\n', '    public\n', '  {\n', '    _registerInterface(InterfaceId_ERC165);\n', '  }\n', '\n', '  /**\n', '   * @dev implement supportsInterface(bytes4) using a lookup table\n', '   */\n', '  function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceId];\n', '  }\n', '\n', '  /**\n', '   * @dev private method for registering an interface\n', '   */\n', '  function _registerInterface(bytes4 _interfaceId)\n', '    internal\n', '  {\n', '    require(_interfaceId != 0xffffffff);\n', '    supportedInterfaces[_interfaceId] = true;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Contract is Ownable, SupportsInterfaceWithLookup {\n', '    /**\n', '     * @notice this.owner.selector ^ this.renounceOwnership.selector ^ this.transferOwnership.selector\n', '        ^ this.template.selector\n', '     */\n', '    bytes4 public constant InterfaceId_Contract = 0x6125ede5;\n', '\n', '    Template public template;\n', '\n', '    constructor(address _owner) public {\n', '        require(_owner != address(0));\n', '\n', '        template = Template(msg.sender);\n', '        owner = _owner;\n', '\n', '        _registerInterface(InterfaceId_Contract);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Template\n', ' * @notice Template instantiates `Contract`s of the same form.\n', ' */\n', 'contract Template is Ownable, SupportsInterfaceWithLookup {\n', '    /**\n', '     * @notice this.owner.selector ^ this.renounceOwnership.selector ^ this.transferOwnership.selector\n', '        ^ this.bytecodeHash.selector ^ this.price.selector ^ this.beneficiary.selector\n', '        ^ this.name.selector ^ this.description.selector ^ this.setNameAndDescription.selector\n', '        ^ this.instantiate.selector\n', '     */\n', '    bytes4 public constant InterfaceId_Template = 0xd48445ff;\n', '\n', '    mapping(string => string) nameOfLocale;\n', '    mapping(string => string) descriptionOfLocale;\n', '    /**\n', '     * @notice Hash of EVM bytecode to be instantiated.\n', '     */\n', '    bytes32 public bytecodeHash;\n', '    /**\n', '     * @notice Price to pay when instantiating\n', '     */\n', '    uint public price;\n', '    /**\n', '     * @notice Address to receive payment\n', '     */\n', '    address public beneficiary;\n', '\n', '    /**\n', '     * @notice Logged when a new `Contract` instantiated.\n', '     */\n', '    event Instantiated(address indexed creator, address indexed contractAddress);\n', '\n', '    /**\n', '     * @param _bytecodeHash Hash of EVM bytecode\n', '     * @param _price Price of instantiating in wei\n', '     * @param _beneficiary Address to transfer _price when instantiating\n', '     */\n', '    constructor(\n', '        bytes32 _bytecodeHash,\n', '        uint _price,\n', '        address _beneficiary\n', '    ) public {\n', '        bytecodeHash = _bytecodeHash;\n', '        price = _price;\n', '        beneficiary = _beneficiary;\n', '        if (price > 0) {\n', '            require(beneficiary != address(0));\n', '        }\n', '\n', '        _registerInterface(InterfaceId_Template);\n', '    }\n', '\n', '    /**\n', '     * @param _locale IETF language tag(https://en.wikipedia.org/wiki/IETF_language_tag)\n', '     * @return Name in `_locale`.\n', '     */\n', '    function name(string _locale) public view returns (string) {\n', '        return nameOfLocale[_locale];\n', '    }\n', '\n', '    /**\n', '     * @param _locale IETF language tag(https://en.wikipedia.org/wiki/IETF_language_tag)\n', '     * @return Description in `_locale`.\n', '     */\n', '    function description(string _locale) public view returns (string) {\n', '        return descriptionOfLocale[_locale];\n', '    }\n', '\n', '    /**\n', '     * @param _locale IETF language tag(https://en.wikipedia.org/wiki/IETF_language_tag)\n', '     * @param _name Name to set\n', '     * @param _description Description to set\n', '     */\n', '    function setNameAndDescription(string _locale, string _name, string _description) public onlyOwner {\n', '        nameOfLocale[_locale] = _name;\n', '        descriptionOfLocale[_locale] = _description;\n', '    }\n', '\n', '    /**\n', '     * @notice `msg.sender` is passed as first argument for the newly created `Contract`.\n', '     * @param _bytecode Bytecode corresponding to `bytecodeHash`\n', '     * @param _args If arguments where passed to this function, those will be appended to the arguments for `Contract`.\n', "     * @return Newly created contract account's address\n", '     */\n', '    function instantiate(bytes _bytecode, bytes _args) public payable returns (address contractAddress) {\n', '        require(bytecodeHash == keccak256(_bytecode));\n', '        bytes memory calldata = abi.encodePacked(_bytecode, _args);\n', '        assembly {\n', '            contractAddress := create(0, add(calldata, 0x20), mload(calldata))\n', '        }\n', '        if (contractAddress == address(0)) {\n', '            revert("Cannot instantiate contract");\n', '        } else {\n', '            Contract c = Contract(contractAddress);\n', '            // InterfaceId_ERC165\n', '            require(c.supportsInterface(0x01ffc9a7));\n', '            // InterfaceId_Contract\n', '            require(c.supportsInterface(0x6125ede5));\n', '\n', '            if (price > 0) {\n', '                require(msg.value == price);\n', '                beneficiary.transfer(msg.value);\n', '            }\n', '            emit Instantiated(msg.sender, contractAddress);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Registry\n', ' * @notice Registry maintains Contracts by version.\n', ' */\n', 'contract Registry is Ownable {\n', '    bool opened;\n', '    string[] identifiers;\n', '    mapping(string => address) registrantOfIdentifier;\n', '    mapping(string => uint[]) versionsOfIdentifier;\n', '    mapping(string => mapping(uint => Template)) templateOfVersionOfIdentifier;\n', '\n', '    constructor(bool _opened) Ownable() public {\n', '        opened = _opened;\n', '    }\n', '\n', '    /**\n', '     * @notice Open the Registry so that anyone can register.\n', '     */\n', '    function open() onlyOwner public {\n', '        opened = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Registers a new `Template`.\n', '     * @param _identifier If any template was registered for the same identifier, the registrant of the templates must be the same.\n', '     * @param _version If any template was registered for the same identifier, new version must be greater than the old one.\n', '     * @param _template Template to be registered.\n', '     */\n', '    function register(string _identifier, uint _version, Template _template) public {\n', '        require(opened || msg.sender == owner);\n', '\n', '        // InterfaceId_ERC165\n', '        require(_template.supportsInterface(0x01ffc9a7));\n', '        // InterfaceId_Template\n', '        require(_template.supportsInterface(0xd48445ff));\n', '\n', '        address registrant = registrantOfIdentifier[_identifier];\n', '        require(registrant == address(0) || registrant == msg.sender, "identifier already registered by another registrant");\n', '        if (registrant == address(0)) {\n', '            identifiers.push(_identifier);\n', '            registrantOfIdentifier[_identifier] = msg.sender;\n', '        }\n', '\n', '        uint[] storage versions = versionsOfIdentifier[_identifier];\n', '        if (versions.length > 0) {\n', '            require(_version > versions[versions.length - 1], "new version must be greater than old versions");\n', '        }\n', '        versions.push(_version);\n', '        templateOfVersionOfIdentifier[_identifier][_version] = _template;\n', '    }\n', '\n', '    function numberOfIdentifiers() public view returns (uint size) {\n', '        return identifiers.length;\n', '    }\n', '\n', '    function identifierAt(uint _index) public view returns (string identifier) {\n', '        return identifiers[_index];\n', '    }\n', '\n', '    function versionsOf(string _identifier) public view returns (uint[] version) {\n', '        return versionsOfIdentifier[_identifier];\n', '    }\n', '\n', '    function templateOf(string _identifier, uint _version) public view returns (Template template) {\n', '        return templateOfVersionOfIdentifier[_identifier][_version];\n', '    }\n', '\n', '    function latestTemplateOf(string _identifier) public view returns (Template template) {\n', '        uint[] storage versions = versionsOfIdentifier[_identifier];\n', '        return templateOfVersionOfIdentifier[_identifier][versions[versions.length - 1]];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Strategy Registry\n', ' * @notice `Template` to be registered must be a `StrategyTemplate`.\n', ' */\n', 'contract ERC20SaleStrategyRegistry is Registry(false) {\n', '}']