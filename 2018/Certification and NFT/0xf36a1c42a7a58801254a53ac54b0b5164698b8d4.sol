['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/StoreManager.sol\n', '\n', 'interface StoreInterface {\n', '\n', '  function getAppNickname()\n', '  external\n', '  constant returns (bytes32);\n', '\n', '\n', '  function getAppId()\n', '  external\n', '  constant returns (uint);\n', '\n', '\n', '  function getAddressLastUpdate(\n', '    address _address\n', '  )\n', '  external\n', '  constant returns (uint);\n', '\n', '\n', '  function isUpgradable(\n', '    address _address,\n', '    string _uid\n', '  )\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function isUid(\n', '    string _uid\n', '  )\n', '  public\n', '  view\n', '  returns (bool);\n', '\n', '\n', '  function setIdentity(\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external;\n', '\n', '\n', '  function unsetIdentity(\n', '    address _address\n', '  )\n', '  external;\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title StoreManager\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev Sets and removes tweedentities in the store,\n', ' * adding more logic to the simple logic of the store\n', ' */\n', '\n', '\n', 'contract StoreManager\n', 'is Pausable, HasNoEther\n', '{\n', '\n', '  string public fromVersion = "1.0.0";\n', '\n', '  struct Store {\n', '    StoreInterface store;\n', '    address addr;\n', '    bool active;\n', '  }\n', '\n', '  mapping(uint => Store) private __stores;\n', '  uint public totalStores;\n', '\n', '  mapping(uint => bytes32) public appNicknames32;\n', '  mapping(uint => string) public appNicknames;\n', '  mapping(string => uint) private __appIds;\n', '\n', '  address public claimer;\n', '  address public newClaimer;\n', '  mapping(address => bool) public customerService;\n', '  address[] private __customerServiceAddress;\n', '\n', '  uint public upgradable = 0;\n', '  uint public notUpgradableInStore = 1;\n', '  uint public addressNotUpgradable = 2;\n', '\n', '  uint public minimumTimeBeforeUpdate = 1 hours;\n', '\n', '\n', '\n', '  // events\n', '\n', '\n', '  event StoreSet(\n', '    string appNickname,\n', '    address indexed addr\n', '  );\n', '\n', '\n', '  event ClaimerSet(\n', '    address indexed claimer,\n', '    bool isNew\n', '  );\n', '\n', '\n', '  event StoreActive(\n', '    string appNickname,\n', '    address indexed store,\n', '    bool active\n', '  );\n', '\n', '\n', '  event ClaimerSwitch(\n', '    address indexed oldClaimer,\n', '    address indexed newClaimer\n', '  );\n', '\n', '\n', '  event CustomerServiceSet(\n', '    address indexed addr\n', '  );\n', '\n', '\n', '  event IdentityNotUpgradable(\n', '    string appNickname,\n', '    address indexed addr,\n', '    string uid\n', '  );\n', '\n', '\n', '  event MinimumTimeBeforeUpdateChanged(\n', '    uint _newMinimumTime\n', '  );\n', '\n', '  // config\n', '\n', '\n', '  /**\n', '   * @dev Sets a store to be used by the manager\n', '   * @param _appNickname The nickname of the app for which the store&#39;s been configured\n', '   * @param _address The address of the store\n', '   */\n', '  function setAStore(\n', '    string _appNickname,\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(bytes(_appNickname).length > 0);\n', '    bytes32 _appNickname32 = keccak256(_appNickname);\n', '    require(_address != address(0));\n', '    StoreInterface _store = StoreInterface(_address);\n', '    require(_store.getAppNickname() == _appNickname32);\n', '    uint _appId = _store.getAppId();\n', '    require(appNicknames32[_appId] == 0x0);\n', '    appNicknames32[_appId] = _appNickname32;\n', '    appNicknames[_appId] = _appNickname;\n', '    __appIds[_appNickname] = _appId;\n', '\n', '    __stores[_appId] = Store(\n', '      _store,\n', '      _address,\n', '      true\n', '    );\n', '    totalStores++;\n', '    StoreSet(_appNickname, _address);\n', '    StoreActive(_appNickname, _address, true);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets the claimer which will verify the ownership and call to set a tweedentity\n', '   * @param _address Address of the claimer\n', '   */\n', '  function setClaimer(\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0));\n', '    claimer = _address;\n', '    ClaimerSet(_address, false);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets a new claimer during updates\n', '   * @param _address Address of the new claimer\n', '   */\n', '  function setNewClaimer(\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0) && claimer != address(0));\n', '    newClaimer = _address;\n', '    ClaimerSet(_address, true);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Sets new manager\n', '  */\n', '  function switchClaimerAndRemoveOldOne()\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(newClaimer != address(0));\n', '    ClaimerSwitch(claimer, newClaimer);\n', '    claimer = newClaimer;\n', '    newClaimer = address(0);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets a wallet as customer service to perform emergency removal of wrong, abused, squatted tweedentities (due, for example, to hacking of the Twitter account)\n', '   * @param _address The customer service wallet\n', '   * @param _status The status (true is set, false is unset)\n', '   */\n', '  function setCustomerService(\n', '    address _address,\n', '    bool _status\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0));\n', '    customerService[_address] = _status;\n', '    bool found;\n', '    for (uint i = 0; i < __customerServiceAddress.length; i++) {\n', '      if (__customerServiceAddress[i] == _address) {\n', '        found = true;\n', '        break;\n', '      }\n', '    }\n', '    if (!found) {\n', '      __customerServiceAddress.push(_address);\n', '    }\n', '    CustomerServiceSet(_address);\n', '  }\n', '\n', '\n', '\n', '  /**\n', '   * @dev Unable/disable a store\n', '   * @param _appNickname The store to be enabled/disabled\n', '   * @param _active A bool to unable (true) or disable (false)\n', '   */\n', '  function activateStore(\n', '    string _appNickname,\n', '    bool _active\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    uint _appId = __appIds[_appNickname];\n', '    require(__stores[_appId].active != _active);\n', '    __stores[_appId] = Store(\n', '      __stores[_appId].store,\n', '      __stores[_appId].addr,\n', '      _active\n', '    );\n', '    StoreActive(_appNickname, __stores[_appId].addr, _active);\n', '  }\n', '\n', '\n', '\n', '  //modifiers\n', '\n', '\n', '  modifier onlyClaimer() {\n', '    require(msg.sender == claimer || (newClaimer != address(0) && msg.sender == newClaimer));\n', '    _;\n', '  }\n', '\n', '\n', '  modifier onlyCustomerService() {\n', '    require(msg.sender == owner || customerService[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '\n', '  modifier whenStoreSet(\n', '    uint _appId\n', '  ) {\n', '    require(appNicknames32[_appId] != 0x0);\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  // internal getters\n', '\n', '\n', '  function __getStore(\n', '    uint _appId\n', '  )\n', '  internal\n', '  constant returns (StoreInterface)\n', '  {\n', '    return __stores[_appId].store;\n', '  }\n', '\n', '\n', '\n', '  // helpers\n', '\n', '\n', '  function isAddressUpgradable(\n', '    StoreInterface _store,\n', '    address _address\n', '  )\n', '  internal\n', '  constant returns (bool)\n', '  {\n', '    uint lastUpdate = _store.getAddressLastUpdate(_address);\n', '    return lastUpdate == 0 || now >= lastUpdate + minimumTimeBeforeUpdate;\n', '  }\n', '\n', '\n', '  function isUpgradable(\n', '    StoreInterface _store,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  internal\n', '  constant returns (bool)\n', '  {\n', '    if (!_store.isUpgradable(_address, _uid) || !isAddressUpgradable(_store, _address)) {\n', '      return false;\n', '    }\n', '    return true;\n', '  }\n', '\n', '\n', '\n', '  // getters\n', '\n', '\n', '  /**\n', '   * @dev Gets the app-id associated to a nickname\n', '   * @param _appNickname The nickname of a configured app\n', '   */\n', '  function getAppId(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (uint) {\n', '    return __appIds[_appNickname];\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows other contracts to check if a store is set\n', '   * @param _appNickname The nickname of a configured app\n', '   */\n', '  function isStoreSet(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns (bool){\n', '    return __appIds[_appNickname] != 0;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows other contracts to check if a store is active\n', '   * @param _appId The id of a configured app\n', '   */\n', '  function isStoreActive(\n', '    uint _appId\n', '  )\n', '  public\n', '  constant returns (bool){\n', '    return __stores[_appId].active;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Return a numeric code about the upgradability of a couple wallet-uid in a certain app\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   * @param _uid The user-id\n', '   */\n', '  function getUpgradability(\n', '    uint _appId,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external\n', '  constant returns (uint)\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    if (!_store.isUpgradable(_address, _uid)) {\n', '      return notUpgradableInStore;\n', '    } else if (!isAddressUpgradable(_store, _address)) {\n', '      return addressNotUpgradable;\n', '    } else {\n', '      return upgradable;\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of a store\n', '   * @param _appNickname The app nickname\n', '   */\n', '  function getStoreAddress(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (address) {\n', '    return __stores[__appIds[_appNickname]].addr;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of a store\n', '   * @param _appId The app id\n', '   */\n', '  function getStoreAddressById(\n', '    uint _appId\n', '  )\n', '  external\n', '  constant returns (address) {\n', '    return __stores[_appId].addr;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of any customerService account\n', '   */\n', '  function getCustomerServiceAddress()\n', '  external\n', '  constant returns (address[]) {\n', '    return __customerServiceAddress;\n', '  }\n', '\n', '\n', '\n', '  // primary methods\n', '\n', '\n', '  /**\n', '   * @dev Sets a new identity\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   * @param _uid The user-id\n', '   */\n', '  function setIdentity(\n', '    uint _appId,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external\n', '  onlyClaimer\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    require(_address != address(0));\n', '\n', '    StoreInterface _store = __getStore(_appId);\n', '    require(_store.isUid(_uid));\n', '\n', '    if (isUpgradable(_store, _address, _uid)) {\n', '      _store.setIdentity(_address, _uid);\n', '    } else {\n', '      IdentityNotUpgradable(appNicknames[_appId], _address, _uid);\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Unsets an existent identity\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   */\n', '  function unsetIdentity(\n', '    uint _appId,\n', '    address _address\n', '  )\n', '  external\n', '  onlyCustomerService\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    _store.unsetIdentity(_address);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allow the sender to unset its existent identity\n', '   * @param _appId The id of the app\n', '   */\n', '  function unsetMyIdentity(\n', '    uint _appId\n', '  )\n', '  external\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    _store.unsetIdentity(msg.sender);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Update the minimum time before allowing a wallet to update its data\n', '   * @param _newMinimumTime The new minimum time in seconds\n', '   */\n', '  function changeMinimumTimeBeforeUpdate(\n', '    uint _newMinimumTime\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    minimumTimeBeforeUpdate = _newMinimumTime;\n', '    MinimumTimeBeforeUpdateChanged(_newMinimumTime);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/StoreManager.sol\n', '\n', 'interface StoreInterface {\n', '\n', '  function getAppNickname()\n', '  external\n', '  constant returns (bytes32);\n', '\n', '\n', '  function getAppId()\n', '  external\n', '  constant returns (uint);\n', '\n', '\n', '  function getAddressLastUpdate(\n', '    address _address\n', '  )\n', '  external\n', '  constant returns (uint);\n', '\n', '\n', '  function isUpgradable(\n', '    address _address,\n', '    string _uid\n', '  )\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function isUid(\n', '    string _uid\n', '  )\n', '  public\n', '  view\n', '  returns (bool);\n', '\n', '\n', '  function setIdentity(\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external;\n', '\n', '\n', '  function unsetIdentity(\n', '    address _address\n', '  )\n', '  external;\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title StoreManager\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev Sets and removes tweedentities in the store,\n', ' * adding more logic to the simple logic of the store\n', ' */\n', '\n', '\n', 'contract StoreManager\n', 'is Pausable, HasNoEther\n', '{\n', '\n', '  string public fromVersion = "1.0.0";\n', '\n', '  struct Store {\n', '    StoreInterface store;\n', '    address addr;\n', '    bool active;\n', '  }\n', '\n', '  mapping(uint => Store) private __stores;\n', '  uint public totalStores;\n', '\n', '  mapping(uint => bytes32) public appNicknames32;\n', '  mapping(uint => string) public appNicknames;\n', '  mapping(string => uint) private __appIds;\n', '\n', '  address public claimer;\n', '  address public newClaimer;\n', '  mapping(address => bool) public customerService;\n', '  address[] private __customerServiceAddress;\n', '\n', '  uint public upgradable = 0;\n', '  uint public notUpgradableInStore = 1;\n', '  uint public addressNotUpgradable = 2;\n', '\n', '  uint public minimumTimeBeforeUpdate = 1 hours;\n', '\n', '\n', '\n', '  // events\n', '\n', '\n', '  event StoreSet(\n', '    string appNickname,\n', '    address indexed addr\n', '  );\n', '\n', '\n', '  event ClaimerSet(\n', '    address indexed claimer,\n', '    bool isNew\n', '  );\n', '\n', '\n', '  event StoreActive(\n', '    string appNickname,\n', '    address indexed store,\n', '    bool active\n', '  );\n', '\n', '\n', '  event ClaimerSwitch(\n', '    address indexed oldClaimer,\n', '    address indexed newClaimer\n', '  );\n', '\n', '\n', '  event CustomerServiceSet(\n', '    address indexed addr\n', '  );\n', '\n', '\n', '  event IdentityNotUpgradable(\n', '    string appNickname,\n', '    address indexed addr,\n', '    string uid\n', '  );\n', '\n', '\n', '  event MinimumTimeBeforeUpdateChanged(\n', '    uint _newMinimumTime\n', '  );\n', '\n', '  // config\n', '\n', '\n', '  /**\n', '   * @dev Sets a store to be used by the manager\n', "   * @param _appNickname The nickname of the app for which the store's been configured\n", '   * @param _address The address of the store\n', '   */\n', '  function setAStore(\n', '    string _appNickname,\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(bytes(_appNickname).length > 0);\n', '    bytes32 _appNickname32 = keccak256(_appNickname);\n', '    require(_address != address(0));\n', '    StoreInterface _store = StoreInterface(_address);\n', '    require(_store.getAppNickname() == _appNickname32);\n', '    uint _appId = _store.getAppId();\n', '    require(appNicknames32[_appId] == 0x0);\n', '    appNicknames32[_appId] = _appNickname32;\n', '    appNicknames[_appId] = _appNickname;\n', '    __appIds[_appNickname] = _appId;\n', '\n', '    __stores[_appId] = Store(\n', '      _store,\n', '      _address,\n', '      true\n', '    );\n', '    totalStores++;\n', '    StoreSet(_appNickname, _address);\n', '    StoreActive(_appNickname, _address, true);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets the claimer which will verify the ownership and call to set a tweedentity\n', '   * @param _address Address of the claimer\n', '   */\n', '  function setClaimer(\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0));\n', '    claimer = _address;\n', '    ClaimerSet(_address, false);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets a new claimer during updates\n', '   * @param _address Address of the new claimer\n', '   */\n', '  function setNewClaimer(\n', '    address _address\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0) && claimer != address(0));\n', '    newClaimer = _address;\n', '    ClaimerSet(_address, true);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Sets new manager\n', '  */\n', '  function switchClaimerAndRemoveOldOne()\n', '  external\n', '  onlyOwner\n', '  {\n', '    require(newClaimer != address(0));\n', '    ClaimerSwitch(claimer, newClaimer);\n', '    claimer = newClaimer;\n', '    newClaimer = address(0);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Sets a wallet as customer service to perform emergency removal of wrong, abused, squatted tweedentities (due, for example, to hacking of the Twitter account)\n', '   * @param _address The customer service wallet\n', '   * @param _status The status (true is set, false is unset)\n', '   */\n', '  function setCustomerService(\n', '    address _address,\n', '    bool _status\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_address != address(0));\n', '    customerService[_address] = _status;\n', '    bool found;\n', '    for (uint i = 0; i < __customerServiceAddress.length; i++) {\n', '      if (__customerServiceAddress[i] == _address) {\n', '        found = true;\n', '        break;\n', '      }\n', '    }\n', '    if (!found) {\n', '      __customerServiceAddress.push(_address);\n', '    }\n', '    CustomerServiceSet(_address);\n', '  }\n', '\n', '\n', '\n', '  /**\n', '   * @dev Unable/disable a store\n', '   * @param _appNickname The store to be enabled/disabled\n', '   * @param _active A bool to unable (true) or disable (false)\n', '   */\n', '  function activateStore(\n', '    string _appNickname,\n', '    bool _active\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    uint _appId = __appIds[_appNickname];\n', '    require(__stores[_appId].active != _active);\n', '    __stores[_appId] = Store(\n', '      __stores[_appId].store,\n', '      __stores[_appId].addr,\n', '      _active\n', '    );\n', '    StoreActive(_appNickname, __stores[_appId].addr, _active);\n', '  }\n', '\n', '\n', '\n', '  //modifiers\n', '\n', '\n', '  modifier onlyClaimer() {\n', '    require(msg.sender == claimer || (newClaimer != address(0) && msg.sender == newClaimer));\n', '    _;\n', '  }\n', '\n', '\n', '  modifier onlyCustomerService() {\n', '    require(msg.sender == owner || customerService[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '\n', '  modifier whenStoreSet(\n', '    uint _appId\n', '  ) {\n', '    require(appNicknames32[_appId] != 0x0);\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  // internal getters\n', '\n', '\n', '  function __getStore(\n', '    uint _appId\n', '  )\n', '  internal\n', '  constant returns (StoreInterface)\n', '  {\n', '    return __stores[_appId].store;\n', '  }\n', '\n', '\n', '\n', '  // helpers\n', '\n', '\n', '  function isAddressUpgradable(\n', '    StoreInterface _store,\n', '    address _address\n', '  )\n', '  internal\n', '  constant returns (bool)\n', '  {\n', '    uint lastUpdate = _store.getAddressLastUpdate(_address);\n', '    return lastUpdate == 0 || now >= lastUpdate + minimumTimeBeforeUpdate;\n', '  }\n', '\n', '\n', '  function isUpgradable(\n', '    StoreInterface _store,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  internal\n', '  constant returns (bool)\n', '  {\n', '    if (!_store.isUpgradable(_address, _uid) || !isAddressUpgradable(_store, _address)) {\n', '      return false;\n', '    }\n', '    return true;\n', '  }\n', '\n', '\n', '\n', '  // getters\n', '\n', '\n', '  /**\n', '   * @dev Gets the app-id associated to a nickname\n', '   * @param _appNickname The nickname of a configured app\n', '   */\n', '  function getAppId(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (uint) {\n', '    return __appIds[_appNickname];\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows other contracts to check if a store is set\n', '   * @param _appNickname The nickname of a configured app\n', '   */\n', '  function isStoreSet(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns (bool){\n', '    return __appIds[_appNickname] != 0;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows other contracts to check if a store is active\n', '   * @param _appId The id of a configured app\n', '   */\n', '  function isStoreActive(\n', '    uint _appId\n', '  )\n', '  public\n', '  constant returns (bool){\n', '    return __stores[_appId].active;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Return a numeric code about the upgradability of a couple wallet-uid in a certain app\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   * @param _uid The user-id\n', '   */\n', '  function getUpgradability(\n', '    uint _appId,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external\n', '  constant returns (uint)\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    if (!_store.isUpgradable(_address, _uid)) {\n', '      return notUpgradableInStore;\n', '    } else if (!isAddressUpgradable(_store, _address)) {\n', '      return addressNotUpgradable;\n', '    } else {\n', '      return upgradable;\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of a store\n', '   * @param _appNickname The app nickname\n', '   */\n', '  function getStoreAddress(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (address) {\n', '    return __stores[__appIds[_appNickname]].addr;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of a store\n', '   * @param _appId The app id\n', '   */\n', '  function getStoreAddressById(\n', '    uint _appId\n', '  )\n', '  external\n', '  constant returns (address) {\n', '    return __stores[_appId].addr;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Returns the address of any customerService account\n', '   */\n', '  function getCustomerServiceAddress()\n', '  external\n', '  constant returns (address[]) {\n', '    return __customerServiceAddress;\n', '  }\n', '\n', '\n', '\n', '  // primary methods\n', '\n', '\n', '  /**\n', '   * @dev Sets a new identity\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   * @param _uid The user-id\n', '   */\n', '  function setIdentity(\n', '    uint _appId,\n', '    address _address,\n', '    string _uid\n', '  )\n', '  external\n', '  onlyClaimer\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    require(_address != address(0));\n', '\n', '    StoreInterface _store = __getStore(_appId);\n', '    require(_store.isUid(_uid));\n', '\n', '    if (isUpgradable(_store, _address, _uid)) {\n', '      _store.setIdentity(_address, _uid);\n', '    } else {\n', '      IdentityNotUpgradable(appNicknames[_appId], _address, _uid);\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Unsets an existent identity\n', '   * @param _appId The id of the app\n', '   * @param _address The address of the wallet\n', '   */\n', '  function unsetIdentity(\n', '    uint _appId,\n', '    address _address\n', '  )\n', '  external\n', '  onlyCustomerService\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    _store.unsetIdentity(_address);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allow the sender to unset its existent identity\n', '   * @param _appId The id of the app\n', '   */\n', '  function unsetMyIdentity(\n', '    uint _appId\n', '  )\n', '  external\n', '  whenStoreSet(_appId)\n', '  whenNotPaused\n', '  {\n', '    StoreInterface _store = __getStore(_appId);\n', '    _store.unsetIdentity(msg.sender);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Update the minimum time before allowing a wallet to update its data\n', '   * @param _newMinimumTime The new minimum time in seconds\n', '   */\n', '  function changeMinimumTimeBeforeUpdate(\n', '    uint _newMinimumTime\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    minimumTimeBeforeUpdate = _newMinimumTime;\n', '    MinimumTimeBeforeUpdateChanged(_newMinimumTime);\n', '  }\n', '\n', '}']
