['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '  function implementation() public view returns (address);\n', '\n', '  /**\n', '  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '  * This function will return whatever the implementation call returns\n', '  */\n', '  function () payable public {\n', '    address impl = implementation();\n', '    require(impl != address(0));\n', '    bytes memory data = msg.data;\n', '\n', '    assembly {\n', '      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)\n', '      let size := returndatasize\n', '\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address[] public owners;\n', '\n', '  event OwnerAdded(address indexed authorizer, address indexed newOwner, uint256 index);\n', '\n', '  event OwnerRemoved(address indexed authorizer, address indexed oldOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owners.push(msg.sender);\n', '    OwnerAdded(0x0, msg.sender, 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than one owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    bool isOwner = false;\n', '\n', '    for (uint256 i = 0; i < owners.length; i++) {\n', '      if (msg.sender == owners[i]) {\n', '        isOwner = true;\n', '        break;\n', '      }\n', '    }\n', '\n', '    require(isOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows one of the current owners to add a new owner\n', '   * @param newOwner The address give ownership to.\n', '   */\n', '  function addOwner(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    uint256 i = owners.push(newOwner) - 1;\n', '    OwnerAdded(msg.sender, newOwner, i);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows one of the owners to remove other owner\n', '   */\n', '  function removeOwner(uint256 index) onlyOwner public {\n', '    address owner = owners[index];\n', '    owners[index] = owners[owners.length - 1];\n', '    delete owners[owners.length - 1];\n', '    OwnerRemoved(msg.sender, owner);\n', '  }\n', '\n', '  function ownersCount() constant public returns (uint256) {\n', '    return owners.length;\n', '  }\n', '}\n', '\n', '\n', 'contract UpgradableStorage is Ownable {\n', '\n', '  // Address of the current implementation\n', '  address internal _implementation;\n', '\n', '  event NewImplementation(address implementation);\n', '\n', '  /**\n', '  * @dev Tells the address of the current implementation\n', '  * @return address of the current implementation\n', '  */\n', '  function implementation() public view returns (address) {\n', '    return _implementation;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Upgradable\n', ' * @dev This contract represents an upgradable contract\n', ' */\n', 'contract Upgradable is UpgradableStorage {\n', '  function initialize() public payable { }\n', '}\n', '\n', '\n', 'contract KnowledgeProxy is Proxy, UpgradableStorage {\n', '  /**\n', '  * @dev Upgrades the implementation to the requested version\n', '  */\n', '  function upgradeTo(address imp) onlyOwner public payable {\n', '    _implementation = imp;\n', '    Upgradable(this).initialize.value(msg.value)();\n', '\n', '    NewImplementation(imp);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '  function implementation() public view returns (address);\n', '\n', '  /**\n', '  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '  * This function will return whatever the implementation call returns\n', '  */\n', '  function () payable public {\n', '    address impl = implementation();\n', '    require(impl != address(0));\n', '    bytes memory data = msg.data;\n', '\n', '    assembly {\n', '      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)\n', '      let size := returndatasize\n', '\n', '      let ptr := mload(0x40)\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address[] public owners;\n', '\n', '  event OwnerAdded(address indexed authorizer, address indexed newOwner, uint256 index);\n', '\n', '  event OwnerRemoved(address indexed authorizer, address indexed oldOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owners.push(msg.sender);\n', '    OwnerAdded(0x0, msg.sender, 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than one owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    bool isOwner = false;\n', '\n', '    for (uint256 i = 0; i < owners.length; i++) {\n', '      if (msg.sender == owners[i]) {\n', '        isOwner = true;\n', '        break;\n', '      }\n', '    }\n', '\n', '    require(isOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows one of the current owners to add a new owner\n', '   * @param newOwner The address give ownership to.\n', '   */\n', '  function addOwner(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    uint256 i = owners.push(newOwner) - 1;\n', '    OwnerAdded(msg.sender, newOwner, i);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows one of the owners to remove other owner\n', '   */\n', '  function removeOwner(uint256 index) onlyOwner public {\n', '    address owner = owners[index];\n', '    owners[index] = owners[owners.length - 1];\n', '    delete owners[owners.length - 1];\n', '    OwnerRemoved(msg.sender, owner);\n', '  }\n', '\n', '  function ownersCount() constant public returns (uint256) {\n', '    return owners.length;\n', '  }\n', '}\n', '\n', '\n', 'contract UpgradableStorage is Ownable {\n', '\n', '  // Address of the current implementation\n', '  address internal _implementation;\n', '\n', '  event NewImplementation(address implementation);\n', '\n', '  /**\n', '  * @dev Tells the address of the current implementation\n', '  * @return address of the current implementation\n', '  */\n', '  function implementation() public view returns (address) {\n', '    return _implementation;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Upgradable\n', ' * @dev This contract represents an upgradable contract\n', ' */\n', 'contract Upgradable is UpgradableStorage {\n', '  function initialize() public payable { }\n', '}\n', '\n', '\n', 'contract KnowledgeProxy is Proxy, UpgradableStorage {\n', '  /**\n', '  * @dev Upgrades the implementation to the requested version\n', '  */\n', '  function upgradeTo(address imp) onlyOwner public payable {\n', '    _implementation = imp;\n', '    Upgradable(this).initialize.value(msg.value)();\n', '\n', '    NewImplementation(imp);\n', '  }\n', '}']
