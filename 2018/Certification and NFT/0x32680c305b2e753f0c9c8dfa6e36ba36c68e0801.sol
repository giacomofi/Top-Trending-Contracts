['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title EjectableOwnable\n', ' * @dev The EjectableOwnable contract provides the function to remove the ownership of the contract.\n', ' */\n', 'contract EjectableOwnable is Ownable {\n', '\n', '    /**\n', '     * @dev Remove the ownership by setting the owner address to null,\n', '     * after calling this function, all onlyOwner function will be be able to be called by anyone anymore,\n', '     * the contract will achieve truly decentralisation.\n', '    */\n', '    function removeOwnership() onlyOwner public {\n', '        owner = 0x0;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title JointOwnable\n', ' * @dev Extension for the Ownable contract, where the owner can assign another address\n', ' *  to manage some functions of the contract, using the eitherOwner modifier.\n', ' *  Note that onlyOwner modifier would still be accessible only for the original owner.\n', ' */\n', 'contract JointOwnable is Ownable {\n', '\n', '  event AnotherOwnerAssigned(address indexed anotherOwner);\n', '\n', '  address public anotherOwner;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner or anotherOwner.\n', '   */\n', '  modifier eitherOwner() {\n', '    require(msg.sender == owner || msg.sender == anotherOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to assign another owner.\n', '   * @param _anotherOwner The address to another owner.\n', '   */\n', '  function assignAnotherOwner(address _anotherOwner) onlyOwner public {\n', '    require(_anotherOwner != 0);\n', '    AnotherOwnerAssigned(_anotherOwner);\n', '    anotherOwner = _anotherOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send.\n', ' */\n', 'contract PullPayment {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '   * @dev withdraw accumulated balance, called by payee.\n', '   */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(this.balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    assert(payee.send(payment));\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '   * @param dest The destination address of the funds.\n', '   * @param amount The amount to transfer.\n', '   */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '\n', '}\n', '\n', 'contract DungeonStructs {\n', '\n', '    /**\n', '     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\n', '     * A dungeon is consists of an unlimited number of floors for your heroes to challenge,\n', '     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more "challenging" than others,\n', '     * the secret formula for that is left for user to find out.\n', '     *\n', '     * Each dungeon also has a "training area", heroes can perform trainings and upgrade their stat,\n', '     * and some dungeons are more effective in the training, which is also a secret formula!\n', '     *\n', '     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\n', '     * which will be rewarded to the player who successfully challenged the current floor.\n', '     *\n', '     * Each dungeon fits in fits into three 256-bit words.\n', '     */\n', '    struct Dungeon {\n', '\n', '        // The timestamp from the block when this dungeon is created.\n', '        uint32 creationTime;\n', '\n', '        // The status of the dungeon, each dungeon can have 4 status, namely:\n', '        // 0: Active | 1: Challenge Only | 2: Train Only | 3: InActive\n', '        uint16 status;\n', '\n', "        // The dungeon's difficulty, the higher the difficulty,\n", '        // normally, the "rarer" the seedGenes, the higher the diffculty,\n', '        // and the higher the contribution fee it is to challenge and train with the dungeon,\n', '        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\n', "        // A dungeon's difficulty never change.\n", '        uint16 difficulty;\n', '\n', '        // The current floor number, a dungeon is consists of an umlimited number of floors,\n', '        // when there is heroes successfully challenged a floor, the next floor will be\n', '        // automatically generated. 32-bit unsigned integers can have 4 billion floors.\n', '        uint32 floorNumber;\n', '\n', '        // The timestamp from the block when the current floor is generated.\n', '        uint32 floorCreationTime;\n', '\n', '        // Current accumulated rewards, successful challenger will get a large proportion of it.\n', '        uint128 rewards;\n', '\n', '        // The seed genes of the dungeon, it is used as the base gene for first floor,\n', '        // some dungeons are rarer and some are more common, the exact details are,\n', '        // of course, top secret of the game!\n', "        // A dungeon's seedGenes never change.\n", '        uint seedGenes;\n', '\n', '        // The genes for current floor, it encodes the difficulty level of the current floor.\n', '        // We considered whether to store the entire array of genes for all floors, but\n', "        // in order to save some precious gas we're willing to sacrifice some functionalities with that.\n", '        uint floorGenes;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev The main Hero struct. Every hero in the game is represented by this structure.\n', '     */\n', '    struct Hero {\n', '\n', '        // The timestamp from the block when this dungeon is created.\n', '        uint64 creationTime;\n', '\n', '        // The seed of the hero, the gene encodes the power level of the hero.\n', "        // This is another top secret of the game! Hero's gene can be upgraded via\n", '        // training in a dungeon.\n', '        uint genes;\n', '\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title A simplified interface of ERC-721, but without approval functions\n', ' */\n', 'contract ERC721 {\n', '\n', '    // Events\n', '    event Transfer(address indexed from, address indexed to, uint tokenId);\n', '\n', '    // ERC20 compatible functions\n', '    // function name() public view returns (string);\n', '    // function symbol() public view returns (string);\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint);\n', '\n', '    // Functions that define ownership\n', '    function ownerOf(uint _tokenId) external view returns (address);\n', '    function transfer(address _to, uint _tokenId) external;\n', '\n', '}\n', '\n', '/**\n', ' * @title The ERC-721 compliance token contract for the Dungeon tokens.\n', ' * @dev See the DungeonStructs contract to see the details of the Dungeon token data structure.\n', ' */\n', 'contract DungeonToken is ERC721, DungeonStructs, Pausable, JointOwnable {\n', '\n', '    /**\n', '     * @notice Limits the number of dungeons the contract owner can ever create.\n', '     */\n', '    uint public constant DUNGEON_CREATION_LIMIT = 1024;\n', '\n', '    /**\n', '     * @dev The Mint event is fired whenever a new dungeon is created.\n', '     */\n', '    event Mint(address indexed owner, uint newTokenId, uint difficulty, uint seedGenes);\n', '\n', '    /**\n', '     * @dev The NewDungeonFloor event is fired whenever a new dungeon floor is added.\n', '     */\n', '    event NewDungeonFloor(uint timestamp, uint indexed dungeonId, uint32 newFloorNumber, uint128 newRewards , uint newFloorGenes);\n', '\n', '    /**\n', '     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\n', '     *  ownership (Dungeon Master) is assigned, including token creation.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint tokenId);\n', '\n', '    /**\n', '     * @dev Name of token.\n', '     */\n', '    string public constant name = "Dungeon";\n', '\n', '    /**\n', '     * @dev Symbol of token.\n', '     */\n', '    string public constant symbol = "DUNG";\n', '\n', '    /**\n', '     * @dev An array containing the Dungeon struct, which contains all the dungeons in existance.\n', '     *  The ID for each dungeon is the index of this array.\n', '     */\n', '    Dungeon[] public dungeons;\n', '\n', '    /**\n', '     * @dev A mapping from token IDs to the address that owns them.\n', '     */\n', '    mapping(uint => address) tokenIndexToOwner;\n', '\n', '    /**\n', '     * @dev A mapping from owner address to count of tokens that address owns.\n', '     */\n', '    mapping(address => uint) ownershipTokenCount;\n', '\n', '    /**\n', '     * Each non-fungible token owner can own more than one token at one time.\n', '     * Because each token is referenced by its unique ID, however,\n', '     * it can get difficult to keep track of the individual tokens that a user may own.\n', '     * To do this, the contract keeps a record of the IDs of each token that each user owns.\n', '     */\n', '    mapping(address => uint[]) public ownerTokens;\n', '\n', '    /**\n', '     * @notice Returns the total number of tokens currently in existence.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return dungeons.length;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the number of tokens owned by a specific address.\n', '     * @param _owner The owner address to check.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if a given address is the current owner of a particular token.\n', '     * @param _claimant The address we are validating against.\n', '     * @param _tokenId Token ID\n', '     */\n', '    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\n', '        return tokenIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the address currently assigned ownership of a given token.\n', '     */\n', '    function ownerOf(uint _tokenId) external view returns (address) {\n', '        require(tokenIndexToOwner[_tokenId] != address(0));\n', '\n', '        return tokenIndexToOwner[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Assigns ownership of a specific token to an address.\n', '     */\n', '    function _transfer(address _from, address _to, uint _tokenId) internal {\n', '        // Increment the ownershipTokenCount.\n', '        ownershipTokenCount[_to]++;\n', '\n', '        // Transfer ownership.\n', '        tokenIndexToOwner[_tokenId] = _to;\n', '\n', '        // Add the _tokenId to ownerTokens[_to]\n', '        ownerTokens[_to].push(_tokenId);\n', '\n', "        // When creating new token, _from is 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '\n', '            // Remove the _tokenId from ownerTokens[_from]\n', '            uint[] storage fromTokens = ownerTokens[_from];\n', '            bool iFound = false;\n', '\n', '            for (uint i = 0; i < fromTokens.length - 1; i++) {\n', '                if (iFound) {\n', '                    fromTokens[i] = fromTokens[i + 1];\n', '                } else if (fromTokens[i] == _tokenId) {\n', '                    iFound = true;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Emit the Transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @notice External function to transfers a token to another address.\n', '     * @param _to The address of the recipient, can be a user or contract.\n', '     * @param _tokenId The ID of the token to transfer.\n', '     */\n', '    function transfer(address _to, uint _tokenId) whenNotPaused external {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '\n', '        // You can only send your own token.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function that creates a new dungeon and stores it, only contract owners\n', '     *  can create new token, and will be restricted by the DUNGEON_CREATION_LIMIT.\n', '     *  Will generate a Mint event, a  NewDungeonFloor event, and a Transfer event.\n', '     * @param _difficulty The difficulty of the new dungeon.\n', '     * @param _seedGenes The seed genes of the new dungeon.\n', '     * @return The dungeon ID of the new dungeon.\n', '     */\n', '    function createDungeon(uint _difficulty, uint _seedGenes, address _owner) eitherOwner external returns (uint) {\n', '        // Ensure the total supply is within the fixed limit.\n', '        require(totalSupply() < DUNGEON_CREATION_LIMIT);\n', '\n', '        // UPDATE STORAGE\n', '        // Create a new dungeon.\n', '        dungeons.push(Dungeon(uint32(now), 0, uint16(_difficulty), 0, 0, 0, _seedGenes, 0));\n', '\n', '        // Token id is the index in the storage array.\n', '        uint newTokenId = dungeons.length - 1;\n', '\n', '        // Emit the token mint event.\n', '        Mint(_owner, newTokenId, _difficulty, _seedGenes);\n', '\n', '        // Initialize the fist floor with using the seedGenes, this will emit the NewDungeonFloor event.\n', '        addDungeonNewFloor(newTokenId, 0, _seedGenes);\n', '\n', '        // This will assign ownership, and also emit the Transfer event.\n', '        _transfer(0, _owner, newTokenId);\n', '\n', '        return newTokenId;\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to set dungeon status by its ID,\n', '     *  refer to DungeonStructs for more information about dungeon status.\n', '     *  Only contract owners can alter dungeon state.\n', '     */\n', '    function setDungeonStatus(uint _id, uint _newStatus) eitherOwner external {\n', '        require(_id < totalSupply());\n', '\n', '        dungeons[_id].status = uint16(_newStatus);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to add additional dungeon rewards by its ID,\n', '     *  only contract owners can alter dungeon state.\n', '     */\n', '    function addDungeonRewards(uint _id, uint _additinalRewards) eitherOwner external {\n', '        require(_id < totalSupply());\n', '\n', '        dungeons[_id].rewards += uint64(_additinalRewards);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to add another dungeon floor by its ID,\n', '     *  only contract owners can alter dungeon state.\n', '     *  Will generate both a NewDungeonFloor event.\n', '     */\n', '    function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) eitherOwner public {\n', '        require(_id < totalSupply());\n', '\n', '        Dungeon storage dungeon = dungeons[_id];\n', '\n', '        dungeon.floorNumber++;\n', '        dungeon.floorCreationTime = uint32(now);\n', '        dungeon.rewards = uint128(_newRewards);\n', '        dungeon.floorGenes = _newFloorGenes;\n', '\n', '        // Emit the NewDungeonFloor event.\n', '        NewDungeonFloor(now, _id, dungeon.floorNumber, dungeon.rewards, dungeon.floorGenes);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title The ERC-721 compliance token contract for the Hero tokens.\n', ' * @dev See the DungeonStructs contract to see the details of the Hero token data structure.\n', ' */\n', 'contract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable {\n', '\n', '    /**\n', '     * @dev The Mint event is fired whenever a new hero is created.\n', '     */\n', '    event Mint(address indexed owner, uint newTokenId, uint _genes);\n', '\n', '    /**\n', '     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\n', '     *  ownership is assigned, including token creation.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint tokenId);\n', '\n', '    /**\n', '     * @dev Name of token.\n', '     */\n', '    string public constant name = "Hero";\n', '\n', '    /**\n', '     * @dev Symbol of token.\n', '     */\n', '    string public constant symbol = "HERO";\n', '\n', '    /**\n', '     * @dev An array containing the Hero struct, which contains all the heroes in existance.\n', '     *  The ID for each hero is the index of this array.\n', '     */\n', '    Hero[] public heroes;\n', '\n', '    /**\n', '     * @dev A mapping from token IDs to the address that owns them.\n', '     */\n', '    mapping(uint => address) tokenIndexToOwner;\n', '\n', '    /**\n', '     * @dev A mapping from owner address to count of tokens that address owns.\n', '     */\n', '    mapping(address => uint) ownershipTokenCount;\n', '\n', '    /**\n', '     * Each non-fungible token owner can own more than one token at one time.\n', '     * Because each token is referenced by its unique ID, however,\n', '     * it can get difficult to keep track of the individual tokens that a user may own.\n', '     * To do this, the contract keeps a record of the IDs of each token that each user owns.\n', '     */\n', '    mapping(address => uint[]) public ownerTokens;\n', '\n', '    /**\n', '     * @notice Returns the total number of tokens currently in existence.\n', '     */\n', '    function totalSupply() public view returns (uint) {\n', '        return heroes.length;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the number of tokens owned by a specific address.\n', '     * @param _owner The owner address to check.\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return ownershipTokenCount[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if a given address is the current owner of a particular token.\n', '     * @param _claimant The address we are validating against.\n', '     * @param _tokenId Token ID\n', '     */\n', '    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\n', '        return tokenIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the address currently assigned ownership of a given token.\n', '     */\n', '    function ownerOf(uint _tokenId) external view returns (address) {\n', '        require(tokenIndexToOwner[_tokenId] != address(0));\n', '\n', '        return tokenIndexToOwner[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Assigns ownership of a specific token to an address.\n', '     */\n', '    function _transfer(address _from, address _to, uint _tokenId) internal {\n', '        // Increment the ownershipTokenCount.\n', '        ownershipTokenCount[_to]++;\n', '\n', '        // Transfer ownership.\n', '        tokenIndexToOwner[_tokenId] = _to;\n', '\n', '        // Add the _tokenId to ownerTokens[_to]\n', '        ownerTokens[_to].push(_tokenId);\n', '\n', "        // When creating new token, _from is 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            ownershipTokenCount[_from]--;\n', '\n', '            // Remove the _tokenId from ownerTokens[_from]\n', '            uint[] storage fromTokens = ownerTokens[_from];\n', '            bool iFound = false;\n', '\n', '            for (uint i = 0; i < fromTokens.length - 1; i++) {\n', '                if (iFound) {\n', '                    fromTokens[i] = fromTokens[i + 1];\n', '                } else if (fromTokens[i] == _tokenId) {\n', '                    iFound = true;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Emit the Transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @notice External function to transfers a token to another address.\n', '     * @param _to The address of the recipient, can be a user or contract.\n', '     * @param _tokenId The ID of the token to transfer.\n', '     */\n', '    function transfer(address _to, uint _tokenId) whenNotPaused external {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '\n', '        // You can only send your own token.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev An external function that creates a new hero and stores it,\n', '     *  only contract owners can create new token.\n', "     *  method doesn't do any checking and should only be called when the\n", '     *  input data is known to be valid.\n', '     * @param _genes The gene of the new hero.\n', '     * @param _owner The inital owner of this hero.\n', '     * @return The hero ID of the new hero.\n', '     */\n', '    function createHero(uint _genes, address _owner) external returns (uint) {\n', '        // UPDATE STORAGE\n', '        // Create a new hero.\n', '        heroes.push(Hero(uint64(now), _genes));\n', '\n', '        // Token id is the index in the storage array.\n', '        uint newTokenId = heroes.length - 1;\n', '\n', '        // Emit the token mint event.\n', '        Mint(_owner, newTokenId, _genes);\n', '\n', '        // This will assign ownership, and also emit the Transfer event.\n', '        _transfer(0, _owner, newTokenId);\n', '\n', '        return newTokenId;\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to set the hero genes by its ID,\n', '     *  only contract owners can alter hero state.\n', '     */\n', '    function setHeroGenes(uint _id, uint _newGenes) eitherOwner external {\n', '        require(_id < totalSupply());\n', '\n', '        Hero storage hero = heroes[_id];\n', '\n', '        hero.genes = _newGenes;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * SECRET\n', ' */\n', 'contract ChallengeScienceInterface {\n', '\n', '    /**\n', '     * @dev given genes of current floor and dungeon seed, return a genetic combination - may have a random factor\n', '     * @param _floorGenes genes of floor\n', '     * @param _seedGenes seed genes of dungeon\n', '     * @return the resulting genes\n', '     */\n', '    function mixGenes(uint _floorGenes, uint _seedGenes) external pure returns (uint);\n', '\n', '}\n', '\n', '/**\n', ' * SECRET\n', ' */\n', 'contract TrainingScienceInterface {\n', '\n', '    /**\n', '     * @dev given genes of hero and current floor, return a genetic combination - may have a random factor\n', '     * @param _heroGenes genes of hero\n', '     * @param _floorGenes genes of current floor\n', '     * @return the resulting genes\n', '     */\n', '    function mixGenes(uint _heroGenes, uint _floorGenes) external pure returns (uint);\n', '\n', '}\n', '\n', '/**\n', ' * @title DungeonBase\n', ' * @dev Base contract for Ether Dungeon. It implements all necessary sub-classes,\n', ' * holds all the base storage variables, and some commonly used functions.\n', ' */\n', 'contract DungeonBase is EjectableOwnable, Pausable, PullPayment, DungeonStructs {\n', '\n', '    /* ======== TOKEN CONTRACTS ======== */\n', '\n', '    /**\n', '     * @dev The address of the ERC721 token contract managing all Dungeon tokens.\n', '     */\n', '    DungeonToken public dungeonTokenContract;\n', '\n', '    /**\n', '     * @dev The address of the ERC721 token contract managing all Hero tokens.\n', '     */\n', '    HeroToken public heroTokenContract;\n', '\n', '\n', '    /* ======== CLOSED SOURCE CONTRACTS ======== */\n', '\n', '    /**\n', '     * @dev The address of the ChallengeScience contract that handles the floor generation mechanics after challenge success.\n', '     */\n', '    ChallengeScienceInterface challengeScienceContract;\n', '\n', '    /**\n', '     * @dev The address of the TrainingScience contract that handles the hero training mechanics.\n', '     */\n', '    TrainingScienceInterface trainingScienceContract;\n', '\n', '\n', '    /* ======== SETTER FUNCTIONS ======== */\n', '\n', '    /**\n', '     * @dev Set the address of the dungeon token contract.\n', '     * @param _newDungeonTokenContract An address of a DungeonToken contract.\n', '     */\n', '    function setDungeonTokenContract(address _newDungeonTokenContract) onlyOwner external {\n', '        dungeonTokenContract = DungeonToken(_newDungeonTokenContract);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address of the hero token contract.\n', '     * @param _newHeroTokenContract An address of a HeroToken contract.\n', '     */\n', '    function setHeroTokenContract(address _newHeroTokenContract) onlyOwner external {\n', '        heroTokenContract = HeroToken(_newHeroTokenContract);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address of the secret dungeon challenge formula contract.\n', '     * @param _newChallengeScienceAddress An address of a ChallengeScience contract.\n', '     */\n', '    function setChallengeScienceContract(address _newChallengeScienceAddress) onlyOwner external {\n', '        challengeScienceContract = ChallengeScienceInterface(_newChallengeScienceAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the address of the secret hero training formula contract.\n', '     * @param _newTrainingScienceAddress An address of a TrainingScience contract.\n', '     */\n', '    function setTrainingScienceContract(address _newTrainingScienceAddress) onlyOwner external {\n', '        trainingScienceContract = TrainingScienceInterface(_newTrainingScienceAddress);\n', '    }\n', '\n', '\n', '    /* ======== MODIFIERS ======== */\n', '    /**\n', '     * @dev Throws if _dungeonId is not created yet.\n', '     */\n', '    modifier dungeonExists(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if dungeon status do not allow challenge, also check for dungeon existence.\n', '     */\n', '    modifier canChallenge(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        uint status;\n', '        (,status,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        require(status == 0 || status == 1);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if dungeon status do not allow training, also check for dungeon existence.\n', '     */\n', '    modifier canTrain(uint _dungeonId) {\n', '        require(_dungeonId < dungeonTokenContract.totalSupply());\n', '        uint status;\n', '        (,status,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\n', '        require(status == 0 || status == 2);\n', '        _;\n', '    }\n', '\n', '\n', '    /* ======== HELPER FUNCTIONS ======== */\n', '\n', '    /**\n', '     * @dev An internal function to calculate the power of player, or difficulty of a dungeon floor,\n', '     *  if the total heroes power is larger than the current dungeon floor difficulty, the heroes win the challenge.\n', '     */\n', '    function _getGenesPower(uint _genes) internal pure returns (uint) {\n', '        // Calculate total stats power.\n', '        uint statsPower;\n', '\n', '        for (uint i = 0; i < 4; i++) {\n', '            statsPower += _genes % 32;\n', '            _genes /= 32 ** 4;\n', '        }\n', '\n', '        // Calculate total stats power.\n', '        uint equipmentPower;\n', '        bool isSuper = true;\n', '\n', '        for (uint j = 4; j < 12; j++) {\n', '            uint curGene = _genes % 32;\n', '            equipmentPower += curGene;\n', '            _genes /= 32 ** 4;\n', '\n', '            if (equipmentPower != curGene * (j - 3)) {\n', '                isSuper = false;\n', '            }\n', '        }\n', '\n', '        // Calculate super power\n', '        if (isSuper) {\n', '            equipmentPower *= 2;\n', '        }\n', '\n', '        return statsPower + equipmentPower + 12;\n', '    }\n', '\n', '}\n', '\n', 'contract DungeonChallenge is DungeonBase {\n', '\n', '    /**\n', '     * @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\n', '     */\n', '    event DungeonChallenged(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newFloorGenes, uint successRewards, uint masterRewards);\n', '\n', '    /**\n', '     * @notice The actual fee contribution required to call challenge() is calculated by this feeMultiplier,\n', '     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards,\n', '     *  and a large proportion will be claimed by whoever successfully challenged the floor.\n', '     *  1 finney = 0.001 ether\n', '     */\n', '    uint256 public challengeFeeMultiplier = 1 finney;\n', '\n', '    /**\n', "     * @dev The percentage for which successful challenger be rewarded of the dungeons' accumulated rewards.\n", '     *  The remaining rewards subtracted by developer fee will be used as the base rewards for new floor.\n', '     */\n', '    uint public challengeRewardsPercent = 64;\n', '\n', '    /**\n', '     * @dev The developer fee for owner\n', '     *  Note that when Ether Dungeon becomes truly decentralised, contract ownership will be ejected,\n', '     *  and the master rewards will be rewarded to the dungeon owner (Dungeon Masters).\n', '     */\n', '    uint public masterRewardsPercent = 8;\n', '\n', '    /**\n', '     * @dev The main public function to call when a player challenge a dungeon,\n', '     *  it determines whether if the player successfully challenged the current floor.\n', '     *  Will generate a DungeonChallenged event.\n', '     */\n', '    function challenge(uint _dungeonId) external payable whenNotPaused canChallenge(_dungeonId) {\n', '        // Get the dungeon details from the token contract.\n', '        uint difficulty;\n', '        uint seedGenes;\n', '        (,,difficulty,,,,seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        uint requiredFee = difficulty * challengeFeeMultiplier;\n', '        require(msg.value >= requiredFee);\n', '\n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon.\n', '        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - requiredFee);\n', '\n', '        // Split the challenge function into multiple parts because of stack too deep error.\n', '        _challengePart2(_dungeonId, requiredFee);\n', '    }\n', '\n', '    /**\n', '     * Split the challenge function into multiple parts because of stack too deep error.\n', '     */\n', '    function _challengePart2(uint _dungeonId, uint _requiredFee) private {\n', '        uint floorNumber;\n', '        uint rewards;\n', '        uint floorGenes;\n', '        (,,,floorNumber,,rewards,,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', '        // The original dungeon rewards plus the required fee of this callenge call.\n', '        uint _addedRewards = rewards + uint128(_requiredFee);\n', '\n', "        // Get the first hero gene, or initialize first hero with current dungeon's seed genes.\n", '        // TODO: implement multiple heroes in next phase\n', '        uint heroGenes = _getFirstHeroGenesAndInitialize(_dungeonId);\n', '\n', '        bool success = _getChallengeSuccess(heroGenes, floorGenes);\n', '\n', '        uint newFloorGenes;\n', '        uint successRewards;\n', '        uint masterRewards;\n', '\n', '        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.\n', '        if (success) {\n', '            newFloorGenes = _getNewFloorGene(_dungeonId);\n', '            successRewards = _addedRewards * challengeRewardsPercent / 100;\n', '            masterRewards = _addedRewards * masterRewardsPercent / 100;\n', '\n', '            // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.\n', '            uint newRewards = _addedRewards * (100 - challengeRewardsPercent - masterRewardsPercent) / 100;\n', '\n', '            // ** STORAGE UPDATE **\n', '            // Add new floor with the new floor genes and new rewards.\n', '            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);\n', '\n', '            // Mark the challenge rewards available to be withdrawed by the player.\n', '            asyncSend(msg.sender, _addedRewards * challengeRewardsPercent / 100);\n', '\n', '            // Mark the master rewards available to be withdrawed by the dungeon master.\n', '            asyncSend(owner, _addedRewards * masterRewardsPercent / 100);\n', '        }\n', '\n', '        // Emit the DungeonChallenged event.\n', '        DungeonChallenged(now, msg.sender, _dungeonId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);\n', '    }\n', '\n', '    /**\n', '     * Split the challenge function into multiple parts because of stack too deep error.\n', '     */\n', '    function _getFirstHeroGenesAndInitialize(uint _dungeonId) private returns (uint heroGenes) {\n', '        uint seedGenes;\n', '        (,,,,,,seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', '        // Get the first hero of the player.\n', '        uint heroId;\n', '\n', '        if (heroTokenContract.balanceOf(msg.sender) == 0) {\n', '            // Assign the first hero using the seed genes of the dungeon for new player.\n', '            heroId = heroTokenContract.createHero(seedGenes, msg.sender);\n', '        } else {\n', '            heroId = heroTokenContract.ownerTokens(msg.sender, 0);\n', '        }\n', '\n', '        // Get the hero genes from token storage.\n', '        (,heroGenes) = heroTokenContract.heroes(heroId);\n', '    }\n', '\n', '    /**\n', '     * Split the challenge function into multiple parts because of stack too deep error.\n', '     */\n', '    function _getChallengeSuccess(uint heroGenes, uint floorGenes) private pure returns (bool) {\n', '        // Determine if the player challenge successfuly the dungeon or not, and the new floor genes.\n', '        uint heroPower = _getGenesPower(heroGenes);\n', '        uint floorPower = _getGenesPower(floorGenes);\n', '\n', '        return heroPower > floorPower;\n', '    }\n', '\n', '    /**\n', '     * Split the challenge function into multiple parts because of stack too deep error.\n', '     */\n', '    function _getNewFloorGene(uint _dungeonId) private view returns (uint) {\n', '        uint seedGenes;\n', '        uint floorGenes;\n', '        (,,,,,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', '        // Calculate the new floor gene.\n', '        uint floorPower = _getGenesPower(floorGenes);\n', '        uint newFloorGenes = challengeScienceContract.mixGenes(floorGenes, seedGenes);\n', '        uint newFloorPower = _getGenesPower(newFloorGenes);\n', '\n', '        // If the power decreased, rollback to the current floor genes.\n', '        if (newFloorPower < floorPower) {\n', '            newFloorGenes = floorGenes;\n', '        }\n', '\n', '        return newFloorGenes;\n', '    }\n', '\n', '\n', '    /* ======== SETTER FUNCTIONS ======== */\n', '\n', '    /**\n', '     * @dev Updates the fee contribution multiplier required for calling challenge().\n', '     */\n', '    function setChallengeFeeMultiplier(uint _newChallengeFeeMultiplier) external onlyOwner {\n', '        challengeFeeMultiplier = _newChallengeFeeMultiplier;\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the challenge rewards pecentage.\n', '     */\n', '    function setChallengeRewardsPercent(uint _newChallengeRewardsPercent) onlyOwner external {\n', '        challengeRewardsPercent = _newChallengeRewardsPercent;\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the master rewards percentage.\n', '     */\n', '    function setMasterRewardsPercent(uint _newMasterRewardsPercent) onlyOwner external {\n', '        masterRewardsPercent = _newMasterRewardsPercent;\n', '    }\n', '\n', '}\n', '\n', 'contract DungeonTraining is DungeonChallenge {\n', '\n', '    /// @dev The HeroTrained event is fired when user finished a training.\n', '    event HeroTrained(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newHeroGenes);\n', '\n', '    /// @notice The actual fee contribution required to call trainX() is calculated by this feeMultiplier,\n', '    ///  times the dungeon difficulty, times X. The payment is accumulated to the dungeon rewards,\n', '    ///  and a large proportion will be claimed by whoever successfully challenged the floor.\n', '    ///  1 finney = 0.001 ether\n', '    uint256 public trainingFeeMultiplier = 2 finney;\n', '\n', '    /// @dev Updates the fee contribution multiplier required for calling trainX().\n', '    function setTrainingFeeMultiplier(uint _newTrainingFeeMultiplier) external onlyOwner {\n', '        trainingFeeMultiplier = _newTrainingFeeMultiplier;\n', '    }\n', '\n', '    /// @dev The public function to call when a hero train with a dungeon,\n', '    ///  it determines whether whether a training is successfully, and the resulting genes.\n', '    ///  Will generate a DungeonChallenged event.\n', '    function train1(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\n', '        _train(_dungeonId, 1);\n', '    }\n', '\n', '    function train2(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\n', '        _train(_dungeonId, 2);\n', '    }\n', '\n', '    function train3(uint _dungeonId) external payable whenNotPaused canTrain(_dungeonId) {\n', '        _train(_dungeonId, 3);\n', '    }\n', '\n', '    /// @dev An internal function of a hero train with dungeon,\n', '    ///  it determines whether whether a training is successfully, and the resulting genes.\n', '    ///  Will generate a DungeonChallenged event.\n', '    function _train(uint _dungeonId, uint _trainingTimes) private {\n', '        // Get the dungeon details from the token contract.\n', '        uint difficulty;\n', '        uint floorNumber;\n', '        uint rewards;\n', '        uint seedGenes;\n', '        uint floorGenes;\n', '        (,,difficulty,floorNumber,,rewards,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', "        // Check for _trainingTimes abnormality, we probably won't have any feature that train a hero 10 times with a single call.\n", '        require(_trainingTimes < 10);\n', '\n', '        // Checks for payment, any exceeding funds will be transferred back to the player.\n', '        uint requiredFee = difficulty * trainingFeeMultiplier * _trainingTimes;\n', '        require(msg.value >= requiredFee);\n', '\n', '        // Get the first hero of the player.\n', '        // TODO: implement multiple heroes in next phase\n', '        uint heroId;\n', '\n', '        if (heroTokenContract.balanceOf(msg.sender) == 0) {\n', '            // Assign the first hero using the seed genes of the dungeon for new player.\n', '            heroId = heroTokenContract.createHero(seedGenes, msg.sender);\n', '        } else {\n', '            heroId = heroTokenContract.ownerTokens(msg.sender, 0);\n', '        }\n', '\n', '        // ** STORAGE UPDATE **\n', '        // Increment the accumulated rewards for the dungeon.\n', '        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\n', '\n', '        // Calculate any excess funds and make it available to be withdrawed by the player.\n', '        asyncSend(msg.sender, msg.value - requiredFee);\n', '\n', '        // Split the _train function into multiple parts because of stack too deep error.\n', '        _trainPart2(_dungeonId, _trainingTimes, heroId);\n', '    }\n', '\n', '    /**\n', '     * Split the _train function into multiple parts because of stack too deep error.\n', '     */\n', '    function _trainPart2(uint _dungeonId, uint _trainingTimes, uint _heroId) private {\n', '        // Get the dungeon details from the token contract.\n', '        uint floorNumber;\n', '        uint floorGenes;\n', '        (,,,floorNumber,,,,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\n', '\n', '        uint heroGenes;\n', '        (,heroGenes) = heroTokenContract.heroes(_heroId);\n', '\n', '        // Determine if the hero training is successful or not, and the resulting genes.\n', '        uint heroPower = _getGenesPower(heroGenes);\n', '\n', '        uint newHeroGenes = heroGenes;\n', '        uint newHeroPower = heroPower;\n', '\n', '        // Train the hero multiple times according to _trainingTimes,\n', '        // each time if the resulting power is larger, update new hero power.\n', '        for (uint i = 0; i < _trainingTimes; i++) {\n', '            uint tmpHeroGenes = trainingScienceContract.mixGenes(newHeroGenes, floorGenes);\n', '            uint tmpHeroPower = _getGenesPower(tmpHeroGenes);\n', '\n', '            if (tmpHeroPower > newHeroPower) {\n', '                newHeroGenes = tmpHeroGenes;\n', '                newHeroPower = tmpHeroPower;\n', '            }\n', '        }\n', '\n', '        // Prevent reduced power.\n', '        bool success = newHeroPower > heroPower;\n', '\n', '        if (success) {\n', '            // ** STORAGE UPDATE **\n', '            // Set the upgraded hero genes.\n', '            heroTokenContract.setHeroGenes(_heroId, newHeroGenes);\n', '        }\n', '\n', '        // Emit the HeroTrained event.\n', '        HeroTrained(now, msg.sender, _dungeonId, heroGenes, floorNumber, floorGenes, success, newHeroGenes);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title DungeonCoreAlpha\n', ' * @dev Base contract for Ether Dungeon. Holds all common structs, events and base variables.\n', ' *  When Beta launches, DungeonCoreBeta contract will be deployed and DungeonCoreAlpha will be destroyed.\n', ' *  Since all dungeons and heroes are stored as tokens in external contracts, they remains immutable.\n', ' */\n', 'contract DungeonCoreAlpha is Destructible, DungeonTraining {\n', '\n', '    /**\n', '     * Initialize the DungeonCore(Alpha) contract with all the required contract addresses.\n', '     */\n', '    function DungeonCoreAlpha(\n', '        address _dungeonTokenAddress,\n', '        address _heroTokenAddress,\n', '        address _challengeScienceAddress,\n', '        address _trainingScienceAddress\n', '    ) public payable {\n', '        dungeonTokenContract = DungeonToken(_dungeonTokenAddress);\n', '        heroTokenContract = HeroToken(_heroTokenAddress);\n', '        challengeScienceContract = ChallengeScienceInterface(_challengeScienceAddress);\n', '        trainingScienceContract = TrainingScienceInterface(_trainingScienceAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\n', '     * @param _id The ID of the dungeon.\n', '     */\n', '    function getDungeonDetails(uint _id) external view returns (uint creationTime, uint status, uint difficulty, uint floorNumber, uint floorCreationTime, uint rewards, uint seedGenes, uint floorGenes) {\n', '        require(_id < dungeonTokenContract.totalSupply());\n', '\n', '        (creationTime, status, difficulty, floorNumber, floorCreationTime, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_id);\n', '    }\n', '\n', '    /**\n', '     * @dev The external function to get all the relevant information about a specific hero by its ID.\n', '     * @param _id The ID of the hero.\n', '     */\n', '    function getHeroDetails(uint _id) external view returns (uint creationTime, uint genes) {\n', '        require(_id < heroTokenContract.totalSupply());\n', '\n', '        (creationTime, genes) = heroTokenContract.heroes(_id);\n', '    }\n', '\n', '}']