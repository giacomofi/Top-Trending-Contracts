['pragma solidity ^0.4.19;\n', '\n', 'contract Crypland {\n', '\n', '  struct Element {uint worth; uint level; uint cooldown;}\n', '  struct Offer {uint startPrice; uint endPrice; uint startBlock; uint endBlock; bool isOffer;}\n', '\n', '  bool public paused;\n', '  address public owner;\n', '\n', '  Element[][25][4] public elements;\n', '  mapping (uint => mapping (uint => mapping (uint => address))) public addresses;\n', '  mapping (uint => mapping (uint => mapping (uint => Offer))) public offers;\n', '\n', '  event ElementBought(uint indexed group, uint indexed asset, uint indexed unit, address user, uint price, uint level, uint worth);\n', '  event ElementUpgraded(uint indexed group, uint indexed asset, uint indexed unit, address user, uint price, uint level, uint worth);\n', '  event ElementTransferred(uint indexed group, uint indexed asset, uint indexed unit, address user, uint price, uint level, uint worth);\n', '\n', '  event UserUpgraded(address indexed user, uint group, uint asset, uint unit, uint price);\n', '  event UserSold(address indexed user, uint group, uint asset, uint unit, uint price);\n', '  event UserBought(address indexed user, uint group, uint asset, uint unit, uint price);\n', '\n', '  function Crypland() public {\n', '    owner = msg.sender;\n', '    paused = false;\n', '  }\n', '\n', '  modifier whenOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenElementHolder(uint group, uint asset, uint unit) {\n', '    require(group >= 0 && group < 4);\n', '    require(asset >= 0 && asset < 25);\n', '    require(unit >= 0 && unit < elements[group][asset].length);\n', '    require(addresses[group][asset][unit] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  modifier whenNotElementHolder(uint group, uint asset, uint unit) {\n', '    require(group >= 0 && group < 4);\n', '    require(asset >= 0 && asset < 25);\n', '    require(unit >= 0 && unit < elements[group][asset].length);\n', '    require(addresses[group][asset][unit] != msg.sender);\n', '    _;\n', '  }\n', '\n', '  function ownerPause() external whenOwner whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  function ownerUnpause() external whenOwner whenPaused {\n', '    paused = false;\n', '  }\n', '\n', '  function ownerWithdraw(uint amount) external whenOwner {\n', '    owner.transfer(amount);\n', '  }\n', '\n', '  function ownerDestroy() external whenOwner {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function publicGetAsset(uint group, uint asset) view public returns (uint, uint, uint, uint, uint) {\n', '    return (\n', '      calcAssetWorthIndex(asset),\n', '      calcAssetBuyPrice(asset),\n', '      calcAssetUpgradePrice(asset),\n', '      calcAssetMax(asset),\n', '      calcAssetAssigned(group, asset)\n', '    );\n', '  }\n', '\n', '  function publicGetElement(uint group, uint asset, uint unit) view public returns (address, uint, uint, uint, uint, bool) {\n', '    return (\n', '      addresses[group][asset][unit],\n', '      elements[group][asset][unit].level,\n', '      calcElementWorth(group, asset, unit),\n', '      calcElementCooldown(group, asset, unit),\n', '      calcElementCurrentPrice(group, asset, unit),\n', '      offers[group][asset][unit].isOffer\n', '    );\n', '  }\n', '\n', '  function publicGetElementOffer(uint group, uint asset, uint unit) view public returns (uint, uint, uint, uint, uint) {\n', '    return (\n', '      offers[group][asset][unit].startPrice,\n', '      offers[group][asset][unit].endPrice,\n', '      offers[group][asset][unit].startBlock,\n', '      offers[group][asset][unit].endBlock,\n', '      block.number\n', '    );\n', '  }\n', '\n', '  function userAssignElement(uint group, uint asset, address ref) public payable whenNotPaused {\n', '    uint price = calcAssetBuyPrice(asset);\n', '\n', '    require(group >= 0 && group < 4);\n', '    require(asset >= 0 && asset < 23);\n', '    require(calcAssetAssigned(group, asset) < calcAssetMax(asset));\n', '    require(msg.value >= price);\n', '\n', '    if (ref == address(0) || ref == msg.sender) {\n', '      ref = owner;\n', '    }\n', '\n', '    uint paidWorth = uint(block.blockhash(block.number - asset)) % 100 + 1;\n', '    Element memory paidElement = Element(paidWorth, 1, 0);\n', '    uint paidUnit = elements[group][asset].push(paidElement) - 1;\n', '    addresses[group][asset][paidUnit] = msg.sender;\n', '\n', '    uint freeWorth = uint(block.blockhash(block.number - paidWorth)) % 100 + 1;\n', '    Element memory freeElement = Element(freeWorth, 1, 0);\n', '    uint freeUnit = elements[group][23].push(freeElement) - 1;\n', '    addresses[group][23][freeUnit] = msg.sender;\n', '\n', '    uint refWorth = uint(block.blockhash(block.number - freeWorth)) % 100 + 1;\n', '    Element memory refElement = Element(refWorth, 1, 0);\n', '    uint refUnit = elements[group][24].push(refElement) - 1;\n', '    addresses[group][24][refUnit] = ref;\n', '\n', '    ElementBought(group, asset, paidUnit, msg.sender, price, 1, paidWorth);\n', '    ElementBought(group, 23, freeUnit, msg.sender, 0, 1, freeWorth);\n', '    ElementBought(group, 24, refUnit, ref, 0, 1, refWorth);\n', '    UserBought(msg.sender, group, asset, paidUnit, price);\n', '    UserBought(msg.sender, group, 23, freeUnit, 0);\n', '    UserBought(ref, group, 24, refUnit, 0);\n', '  }\n', '\n', '  function userUpgradeElement(uint group, uint asset, uint unit) public payable whenNotPaused whenElementHolder(group, asset, unit) {\n', '    uint price = calcAssetUpgradePrice(asset);\n', '\n', '    require(elements[group][asset][unit].cooldown < block.number);\n', '    require(msg.value >= price);\n', '\n', '    elements[group][asset][unit].level = elements[group][asset][unit].level + 1;\n', '    elements[group][asset][unit].cooldown = block.number + ((elements[group][asset][unit].level - 1) * 120);\n', '    \n', '    ElementUpgraded(group, asset, unit, msg.sender, price, elements[group][asset][unit].level, calcElementWorth(group, asset, unit));\n', '    UserUpgraded(msg.sender, group, asset, unit, price);\n', '  }\n', '\n', '  function userOfferSubmitElement(uint group, uint asset, uint unit, uint startPrice, uint endPrice, uint duration) public whenNotPaused whenElementHolder(group, asset, unit) {\n', '    require(!offers[group][asset][unit].isOffer); \n', '    require(startPrice > 0 && endPrice > 0 && duration > 0 && startPrice >= endPrice);\n', '\n', '    offers[group][asset][unit].isOffer = true;\n', '    offers[group][asset][unit].startPrice = startPrice;\n', '    offers[group][asset][unit].endPrice = endPrice;\n', '    offers[group][asset][unit].startBlock = block.number;\n', '    offers[group][asset][unit].endBlock = block.number + duration;\n', '  }\n', '\n', '  function userOfferCancelElement(uint group, uint asset, uint unit) public whenNotPaused whenElementHolder(group, asset, unit) {\n', '    require(offers[group][asset][unit].isOffer);\n', '    offers[group][asset][unit].isOffer = false;\n', '    offers[group][asset][unit].startPrice = 0;\n', '    offers[group][asset][unit].endPrice = 0;\n', '    offers[group][asset][unit].startBlock = 0;\n', '    offers[group][asset][unit].endBlock = 0;\n', '  }\n', '\n', '  function userOfferAcceptElement(uint group, uint asset, uint unit) public payable whenNotPaused whenNotElementHolder(group, asset, unit) {\n', '    uint price = calcElementCurrentPrice(group, asset, unit);\n', '\n', '    require(offers[group][asset][unit].isOffer);\n', '    require(msg.value >= price);\n', '\n', '    address seller = addresses[group][asset][unit];\n', '\n', '    addresses[group][asset][unit] = msg.sender;\n', '    offers[group][asset][unit].isOffer = false;\n', '\n', '    seller.transfer(price * 97 / 100);\n', '    msg.sender.transfer(msg.value - price);\n', '\n', '    ElementTransferred(group, asset, unit, msg.sender, price, elements[group][asset][unit].level, calcElementWorth(group, asset, unit));\n', '    UserBought(msg.sender, group, asset, unit, price);\n', '    UserSold(seller, group, asset, unit, price);\n', '  }\n', '\n', '  function calcAssetWorthIndex(uint asset) pure internal returns (uint) {\n', '    return asset < 23 ? (24 - asset) : 1;\n', '  }\n', '\n', '  function calcAssetBuyPrice(uint asset) pure internal returns (uint) {\n', '    return asset < 23 ? ((24 - asset) * (25 - asset) * 10**15 / 2) : 0;\n', '  }\n', '\n', '  function calcAssetUpgradePrice(uint asset) pure internal returns (uint) {\n', '    return calcAssetWorthIndex(asset) * 10**15;\n', '  }\n', '\n', '  function calcAssetMax(uint asset) pure internal returns (uint) {\n', '    return asset < 23 ? ((asset + 1) * (asset + 2) / 2) : 2300;\n', '  }\n', '\n', '  function calcAssetAssigned(uint group, uint asset) view internal returns (uint) {\n', '    return elements[group][asset].length;\n', '  }\n', '\n', '  function calcElementWorth(uint group, uint asset, uint unit) view internal returns (uint) {\n', '    return elements[group][asset][unit].worth + ((elements[group][asset][unit].level - 1) * calcAssetWorthIndex(asset));\n', '  }\n', '\n', '  function calcElementCooldown(uint group, uint asset, uint unit) view internal returns (uint) {\n', '    return elements[group][asset][unit].cooldown > block.number ? elements[group][asset][unit].cooldown - block.number : 0;\n', '  }\n', '\n', '  function calcElementCurrentPrice(uint group, uint asset, uint unit) view internal returns (uint) {\n', '    uint price = 0;\n', '    if (offers[group][asset][unit].isOffer) {\n', '      if (block.number >= offers[group][asset][unit].endBlock) {\n', '        price = offers[group][asset][unit].endPrice;\n', '      } else if (block.number <= offers[group][asset][unit].startBlock) {\n', '        price = offers[group][asset][unit].startPrice;\n', '      } else if (offers[group][asset][unit].endPrice == offers[group][asset][unit].startPrice) {\n', '        price = offers[group][asset][unit].endPrice;\n', '      } else {\n', '        uint currentBlockChange = block.number - offers[group][asset][unit].startBlock;\n', '        uint totalBlockChange = offers[group][asset][unit].endBlock - offers[group][asset][unit].startBlock;\n', '        uint totalPriceChange = offers[group][asset][unit].startPrice - offers[group][asset][unit].endPrice;\n', '        uint currentPriceChange = currentBlockChange * totalPriceChange / totalBlockChange;\n', '        price = offers[group][asset][unit].startPrice - currentPriceChange;\n', '      }\n', '    }\n', '\n', '    return price;\n', '  }\n', '}']