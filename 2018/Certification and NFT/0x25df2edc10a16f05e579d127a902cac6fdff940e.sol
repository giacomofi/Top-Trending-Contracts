['/*\n', '\n', 'The Sale contract manages a token sale.\n', '\n', 'The Sale contract primarily does the following:\n', '\n', '\t- allows individuals to buy tokens during a token sale\n', '\t- allows individuals to claim the tokens after a successful token sale\n', '\t- allows individuals to receive an ETH refund after a cancelled token sale\n', '\t- allows an admin to cancel a token sale, after which individuals can request refunds\n', '\t- allows an admin to certify a token sale, after which an admin can withdraw contributed ETH\n', '\t- allows an admin to complete a token sale, after which an individual (following a brief release period) can request their tokens\n', '\t- allows an admin to return contributed ETH to individuals\n', '\t- allows an admin to grant tokens to an individual\n', '\t- allows an admin to withdraw ETH from the token sale\n', '\t- allows an admin to add and remove individuals from a whitelist\n', '\t- allows an admin to pause or activate the token sale\n', '\t\n', 'The sale runs from a start timestamp to a finish timestamp.  After the release timestamp (assuming a successful sale), individuals can claim their tokens.  If the sale is cancelled, individuals can request a refund.  Furthermore, an admin may return ETH and negate purchases to respective individuals as deemed necessary.  Once the sale is certified or completed, ETH can be withdrawn by the company.\n', '\n', 'The contract creator appoints a delegate to perform most administrative tasks.\n', '\n', 'All events are logged for the purpose of transparency.\n', '\n', 'All math uses SafeMath.\n', '\n', 'ETH and tokens (often referred to as "value" and "tokens" in variable names) are really 1/10^18 of their respective parent units.  Basically, the values represent wei and the token equivalent thereof.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract SaleCallbackInterface {\n', '    function handleSaleCompletionCallback(uint256 _tokens) external payable returns (bool);\n', '    function handleSaleClaimCallback(address _recipient, uint256 _tokens) external returns (bool);  \n', '}\n', '\n', 'contract Sale is SafeMath {\n', '    \n', '    address public creator;\t\t    // address of the contract&#39;s creator\n', '    address public delegate;\t\t// address of an entity allowed to perform administrative functions on behalf of the creator\n', '    \n', '    address public marketplace;\t    // address of another smart contract that manages the token and Smart Exchange\n', '    \n', '    uint256 public start;\t\t\t// timestamp that the sale begins\n', '    uint256 public finish;\t\t\t// timestamp that the sale ends\n', '    uint256 public release;\t\t\t// timestamp that sale participants may "claim" their tokens (will be after the finish)\n', '    \n', '    uint256 public pricer;\t\t\t// a multiplier (>= 1) used to determine how many tokens (or, really, 10^18 sub-units of that token) to give purchasers\n', '    uint256 public size;\t\t\t// maximum number of 10^18 sub-units of tokens that can be purchased/granted during the sale\n', '    \n', '    bool public restricted;\t\t    // whether purchasers and recipients of tokens must be whitelisted manually prior to participating in the sale\n', '\n', '    bool public active;\t\t\t    // whether individuals are allowed to purchase tokens -- if false, they cannot.  if true, they can or cannot.  \n', '    \t\t\t\t\t\t\t\t// other factors, like start/finish, size, and others can restrict participation as well, even if active = true.\n', '    \t\t\t\t\t\t\t\t// this also can remain true indefinitely, even if the token sale has been cancelled or has completed.\n', '    \t\t\t\t\t\t\t\t\n', '    \n', '    int8 public progress;\t\t\t// -1 = token sale cancelled, 0 = token sale ongoing, 1 = token sale certified (can withdraw ETH while sale is live), 2 = token sale completed\n', '    \n', '    uint256 public tokens;\t\t\t// number of sub-tokens that have been purchased/granted during the sale.  purchases/grants can be reversed while progress = 0 || progress = 1 resulting in tokens going down\n', '    uint256 public value;\t\t\t// number of sub-ether (wei) that have been contributed during the sale.  purchases can be resversed while progress = 0 || progress = 1 resulting in value going down\n', '    \n', '    uint256 public withdrawls;\t\t// the number of sub-ether (wei) that have been withdrawn by the contract owner\n', '    uint256 public reserves;\t\t// the number of sub-ether (wei) that have been sent to serve as reserve in the marketplace\n', '    \n', '    mapping(address => bool) public participants;\t\t\t// mapping to record who has participated in the sale (purchased/granted)\n', '    address[] public participantIndex;\t\t\t\t\t\t// index of participants\n', '    \n', '    mapping(address => uint256) public participantTokens;\t// sub-tokens purchased/granted to each participant\n', '    mapping(address => uint256) public participantValues;\t// sub-ether contributed by each participant\n', '    \n', '    mapping(address => bool) public participantRefunds;\t    // mapping to record who has been awarded a refund after a cancelled sale\n', '    mapping(address => bool) public participantClaims;\t\t// mapping to record who has claimed their tokens after a completed sale\n', '    \n', '    mapping(address => bool) public whitelist;\t\t\t\t// mapping to record who has been approved to participate in a "restricted" sale\n', '    \n', '    uint256[] public bonuses;\t\t\t\t\t\t\t\t// stores bonus percentages, where even numbered elements store timestamps and odd numbered elements store bonus percentages\n', '    \n', '    bool public mutable;\t\t\t\t\t\t\t\t\t// whether certain properties (like finish and release) of the sale can be updated to increase the liklihood of a successful token sale for all parties involved\n', '    \n', '    modifier ifCreator { require(msg.sender == creator); _; }\t\t// if the caller created the contract...\n', '    modifier ifDelegate { require(msg.sender == delegate); _; }\t\t// if the caller is currently the appointed delegate...\n', '    modifier ifMutable { require(mutable); _; }\t\t\t\t\t\t// if the certain properties of the sale can be changed....\n', '    \n', '    event Created();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract was created\n', '    event Bought(address indexed _buyer, address indexed _recipient, uint256 _tokens, uint256 _value);\t\t// an individual bought tokens\n', '    event Claimed(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual claimed tokens after the completion of the sale and after tokens were scheduled for release\n', '    event Refunded(address indexed _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t// an individual requested a refund of the ETH they contributed after a cancelled token sale\n', '    event Reversed(address indexed _recipient, uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t// an individual was sent the ETH they contributed to the sale and will not receive tokens\n', '    event Granted(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual was granted tokens, without contributing ETH\n', '    event Withdrew(address _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator withdrew ETH from the token sale\n', '    event Completed(uint256 _tokens, uint256 _value, uint256 _reserves);\t\t\t\t\t\t\t\t\t// the contract creator signaled that the sale completed successfuly\n', '    event Certified(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator certified the sale\n', '    event Cancelled(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator cancelled the sale\n', '    event Listed(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was added to the whitelist\n', '    event Delisted(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was removed from the whitelist\n', '    event Paused();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was paused (active = false)\n', '    event Activated();    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was activated (active = true)\n', '\n', '    function Sale() {\n', '        \n', '        creator = msg.sender;\n', '        delegate = msg.sender;\n', '        \n', '        start = 1;\t\t\t\t\t            // contributions may be made as soon as the contract is published\n', '        finish = 1535760000;\t\t\t\t    // the sale continues through 09/01/2018 @ 00:00:00\n', '        release = 1536969600;\t\t\t\t    // tokens will be available to participants starting 09/15/2018 @ 00:00:00\n', '        \n', '        pricer = 100000;\t\t\t\t\t    // each ETH is worth 100,000 tokens\n', '        \n', '        size = 10 ** 18 * pricer * 2000 * 2;\t// 2,000 ETH, plus a 100% buffer to account for the possibility of a 50% decrease in ETH value during the sale\n', '\n', '        restricted = false;                     // the sale accepts contributions from everyone.  \n', '                                                // however, participants who do not submit formal KYC verification before the end of the token sale will have their contributions reverted\n', '    \n', '        bonuses = [1, 20];                      // the bonus during the pre-sale starts at 20%\n', '        \n', '        mutable = true;                         // certain attributes, such as token sale finish and release dates, may be updated to increase the liklihood of a successful token sale for all parties involved\n', '        active = true;                          // the token sale is active from the point the contract is published in the form of a pre-sale         \n', '        \n', '        Created();\n', '        Activated();\n', '    }\n', '    \n', '    // returns the number of sub-tokens the calling account purchased/was granted\n', '    \n', '    function getMyTokenBalance() external constant returns (uint256) {\n', '        return participantTokens[msg.sender];\n', '    }\n', '    \n', '    // allows an individual to buy tokens (which will not be issued immediately)\n', '    // individual instructs the tokens to be delivered to a specific account, which may be different than msg.sender\n', '    \n', '    function buy(address _recipient) public payable {\n', '        \n', '        // _recipient address must not be all 0&#39;s\n', '        \n', '        require(_recipient != address(0x0));\n', '\n', '\t\t// contributor must send more than 1/10 ETH\n', '\t\t\n', '        require(msg.value >= 10 ** 17);\n', '\n', '\t\t// sale must be considered active\n', '\t\t\n', '        require(active);\n', '\n', '\t\t// sale must be ongoing or certified\n', '\n', '        require(progress == 0 || progress == 1);\n', '\n', '\t\t// current timestamp must be greater than or equal to the start of the token sale\n', '\t\t\n', '        require(block.timestamp >= start);\n', '\n', '\t\t// current timestamp must be less than the end of the token sale\n', '\t\t\n', '        require(block.timestamp < finish);\n', '\t\t\n', '\t\t// either the token sale isn&#39;t restricted, or the sender is on the whitelist\n', '\n', '        require((! restricted) || whitelist[msg.sender]);\n', '        \n', '        // either the token sale isn&#39;t restricted, or the recipient is on the whitelist\n', '\n', '        require((! restricted) || whitelist[_recipient]);\n', '        \n', '        // multiply sub-ether by the pricer (which will be a whole number >= 1) to get sub-tokens\n', '\n', '        uint256 baseTokens = safeMul(msg.value, pricer);\n', '        \n', '        // determine how many bonus sub-tokens to award and add that to the base tokens\n', '        \n', '        uint256 totalTokens = safeAdd(baseTokens, safeDiv(safeMul(baseTokens, getBonusPercentage()), 100));\n', '\n', '\t\t// ensure the purchase does not cause the sale to exceed its maximum size\n', '\t\t\n', '        require(safeAdd(tokens, totalTokens) <= size);\n', '        \n', '        // if the recipient is new, add them as a participant\n', '\n', '        if (! participants[_recipient]) {\n', '            participants[_recipient] = true;\n', '            participantIndex.push(_recipient);\n', '        }\n', '        \n', '        // increment the participant&#39;s sub-tokens and sub-ether\n', '\n', '        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], totalTokens);\n', '        participantValues[_recipient] = safeAdd(participantValues[_recipient], msg.value);\n', '\n', '\t\t// increment sale sub-tokens and sub-ether\n', '\n', '        tokens = safeAdd(tokens, totalTokens);\n', '        value = safeAdd(value, msg.value);\n', '        \n', '        // log purchase event\n', '\n', '        Bought(msg.sender, _recipient, totalTokens, msg.value);\n', '    }\n', '    \n', '    // token sale participants call this to claim their tokens after the sale is completed and tokens are scheduled for release\n', '    \n', '    function claim() external {\n', '\t    \n', '\t    // sale must be completed\n', '        \n', '        require(progress == 2);\n', '        \n', '        // tokens must be scheduled for release\n', '        \n', '        require(block.timestamp >= release);\n', '        \n', '        // participant must have tokens to claim\n', '        \n', '        require(participantTokens[msg.sender] > 0);\n', '        \n', '        // participant must not have already claimed tokens\n', '        \n', '        require(! participantClaims[msg.sender]);\n', '        \n', '\t\t// record that the participant claimed their tokens\n', '\n', '        participantClaims[msg.sender] = true;\n', '        \n', '        // log the event\n', '        \n', '        Claimed(msg.sender, participantTokens[msg.sender]);\n', '        \n', '        // call the marketplace contract, which will actually issue the tokens to the participant\n', '        \n', '        SaleCallbackInterface(marketplace).handleSaleClaimCallback(msg.sender, participantTokens[msg.sender]);\n', '    }\n', '    \n', '    // token sale participants call this to request a refund if the sale was cancelled\n', '    \n', '    function refund() external {\n', '        \n', '        // the sale must be cancelled\n', '        \n', '        require(progress == -1);\n', '        \n', '        // the participant must have contributed ETH\n', '        \n', '        require(participantValues[msg.sender] > 0);\n', '        \n', '        // the participant must not have already requested a refund\n', '        \n', '        require(! participantRefunds[msg.sender]);\n', '        \n', '\t\t// record that the participant requested a refund\n', '        \n', '        participantRefunds[msg.sender] = true;\n', '        \n', '        // log the event\n', '        \n', '        Refunded(msg.sender, participantValues[msg.sender]);\n', '        \n', '        // transfer contributed ETH back to the participant\n', '    \n', '        address(msg.sender).transfer(participantValues[msg.sender]);\n', '    }    \n', '    \n', '    // the contract creator calls this to withdraw contributed ETH to a specific address\n', '    \n', '    function withdraw(uint256 _sanity, address _recipient, uint256 _value) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 100010001);\n', '        \n', '        // address must not be 0-value\n', '        \n', '        require(_recipient != address(0x0));\n', '        \n', '        // token sale must be certified or completed\n', '        \n', '        require(progress == 1 || progress == 2);\n', '        \n', '        // the amount of ETH in the contract must be greater than the amount the creator is attempting to withdraw\n', '        \n', '        require(this.balance >= _value);\n', '        \n', '        // increment the amount that&#39;s been withdrawn\n', '        \n', '        withdrawls = safeAdd(withdrawls, _value);\n', '        \n', '        // log the withdrawl\n', '        \n', '        Withdrew(_recipient, _value);\n', '        \n', '        // send the ETH to the recipient\n', '        \n', '        address(_recipient).transfer(_value);\n', '    } \n', '    \n', '    // the contract owner calls this to complete (finalize/wrap up, etc.) the sale\n', '    \n', '    function complete(uint256 _sanity, uint256 _value) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 101010101);\n', '\t    \n', '\t    // the sale must be marked as ongoing or certified (aka, not cancelled -1)\n', '        \n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // the sale can only be completed after the finish time\n', '        \n', '        require(block.timestamp >= finish);\n', '        \n', '        // ETH is withdrawn in the process and sent to the marketplace contract.  ensure the amount that is being withdrawn is greater than the balance in the smart contract.\n', '        \n', '        require(this.balance >= _value);\n', '        \n', '        // mark the sale as completed\n', '        \n', '        progress = 2;\n', '        \n', '        // the amount that is sent to the other contract is added to the ETH reserve.  denote this amount as reserves.\n', '        \n', '        reserves = safeAdd(reserves, _value);\n', '        \n', '        // log the completion of the sale, including the number of sub-tokens created by the sale, the amount of net sub-eth received during the sale, and the amount of sub-eth to be added to the reserve\n', '        \n', '        Completed(tokens, value, _value);\n', '        \n', '        // call the marketplace contract, sending the ETH for the reserve and including the number of sub-tokens \n', '        \n', '        SaleCallbackInterface(marketplace).handleSaleCompletionCallback.value(_value)(tokens);\n', '    }    \n', '    \n', '    // the creator can certify a sale, meaning it cannot be cancelled, and ETH can be withdrawn from the sale by the creator\n', '    \n', '    function certify(uint256 _sanity) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 101011111);\n', '\t    \n', '\t    // the sale must be ongoing\n', '\t    \n', '        require(progress == 0);\n', '        \n', '        // the sale must have started\n', '        \n', '        require(block.timestamp >= start);\n', '        \n', '        // record that the sale is certified\n', '        \n', '        progress = 1;\n', '        \n', '        // log the certification\n', '        \n', '        Certified(tokens, value);\n', '    }\n', '    \n', '    // the creator can cancel a sale \n', '    \n', '    function cancel(uint256 _sanity) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 111110101);\n', '\t    \n', '\t    // the sale must be ongoing\n', '\t    \n', '        require(progress == 0);\n', '        \n', '        // record that the sale is cancelled\n', '        \n', '        progress = -1;\n', '        \n', '        // log the cancellation\n', '        \n', '        Cancelled(tokens, value);\n', '    }    \n', '    \n', '    // called by the delegate to reverse purchases/grants for a particular contributor\n', '    \n', '    function reverse(address _recipient) ifDelegate external {\n', '        \n', '        // the recipient address must not be all 0&#39;s\n', '        \n', '        require(_recipient != address(0x0));\n', '        \n', '        // the sale must be ongoing or certified\n', '        \n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // the recipient must have contributed ETH and/or received tokens\n', '        \n', '        require(participantTokens[_recipient] > 0 || participantValues[_recipient] > 0);\n', '        \n', '        uint256 initialParticipantTokens = participantTokens[_recipient];\n', '        uint256 initialParticipantValue = participantValues[_recipient];\n', '        \n', '        // subtract sub-tokens and sub-ether from sale totals\n', '        \n', '        tokens = safeSub(tokens, initialParticipantTokens);\n', '        value = safeSub(value, initialParticipantValue);\n', '        \n', '        // reset participant sub-tokens and sub-ether\n', '        \n', '        participantTokens[_recipient] = 0;\n', '        participantValues[_recipient] = 0;\n', '        \n', '        // log the reversal, including the initial sub-tokens and initial sub-ether\n', '        \n', '        Reversed(_recipient, initialParticipantTokens, initialParticipantValue);\n', '        \n', '        // if the participant previously sent ETH, return it\n', '        \n', '        if (initialParticipantValue > 0) {\n', '            address(_recipient).transfer(initialParticipantValue);\n', '        }\n', '    }\n', '    \n', '    // called by the delegate to grant tokens to a recipient\n', '    \n', '    function grant(address _recipient, uint256 _tokens) ifDelegate external {\n', '        \n', '       \t// the recipient&#39;s address cannot be 0-value\n', '       \n', '        require(_recipient != address(0x0));\n', '\t\t\n', '\t\t// the sale must be ongoing or certified\n', '\t\t\n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // if the recipient has not participated previously, add them as a participant\n', '        \n', '        if (! participants[_recipient]) {\n', '            participants[_recipient] = true;\n', '            participantIndex.push(_recipient);\n', '        }\n', '        \n', '        // add sub-tokens to the recipient&#39;s balance\n', '        \n', '        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], _tokens);\n', '        \n', '        // add sub-tokens to the sale&#39;s total\n', '        \n', '        tokens = safeAdd(tokens, _tokens);\n', '        \n', '        // log the grant\n', '        \n', '        Granted(_recipient, _tokens);\n', '    }    \n', '    \n', '    // adds a set of addresses to the whitelist\n', '    \n', '    function list(address[] _addresses) ifDelegate external {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelist[_addresses[i]] = true;\n', '            Listed(_addresses[i]);\n', '        }\n', '    }\n', '    \n', '    // removes a set of addresses from the whitelist\n', '    \n', '    function delist(address[] _addresses) ifDelegate external {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelist[_addresses[i]] = false;\n', '            Delisted(_addresses[i]);\n', '        }\n', '    }  \n', '    \n', '\t// pause the sale\n', '    \n', '    function pause() ifDelegate external {\n', '        active = false;\n', '        Paused();\n', '    }\n', '    \n', '    // activate the sale\n', '\n', '    function activate() ifDelegate external {\n', '        active = true;\n', '        Activated();\n', '    }\n', '\n', '    function setDelegate(address _delegate) ifCreator external {\n', '        delegate = _delegate;\n', '    }\n', '    \n', '    function setRestricted(bool _restricted) ifDelegate external {\n', '        restricted = _restricted;\n', '    }\n', '    \n', '    function setMarketplace(address _marketplace) ifCreator ifMutable external {\n', '        marketplace = _marketplace;\n', '    }\n', '    \n', '    function setBonuses(uint256[] _bonuses) ifDelegate ifMutable external {\n', '        bonuses = _bonuses;\n', '    }\n', '    \n', '    function setFinish(uint256 _finish) ifDelegate ifMutable external {\n', '        finish = _finish;\n', '    }\n', '\n', '    function setRelease(uint256 _release) ifDelegate ifMutable external {\n', '        release = _release;\n', '    }     \n', '    \n', '    // get the current bonus percentage, as a whole number\n', '    \n', '    function getBonusPercentage() public constant returns (uint256) {\n', '        \n', '        uint256 finalBonus;\n', '        \n', '        uint256 iterativeTimestamp;\n', '        uint256 iterativeBonus;\n', '        \n', '        // within bonuses, even numbered elements store timestamps and odd numbered elements store bonus percentages\n', '        // timestamps are in order from oldest to newest\n', '        // iterates over the elements and if the timestamp has been surpassed, the bonus percentage is denoted\n', '        // the last bonus percentage that was denoted, if one was denoted at all, is the correct bonus percentage at this time\n', '        \n', '        for (uint256 i = 0; i < bonuses.length; i++) {\n', '            if (i % 2 == 0) {\n', '                iterativeTimestamp = bonuses[i];\n', '            } else {\n', '                iterativeBonus = bonuses[i];\n', '                if (block.timestamp >= iterativeTimestamp) {\n', '                    finalBonus = iterativeBonus;\n', '                }\n', '            }\n', '        } \n', '        \n', '        return finalBonus;\n', '    }    \n', '    \n', '    function() public payable {\n', '        buy(msg.sender);\n', '    }\n', '    \n', '}']
['/*\n', '\n', 'The Sale contract manages a token sale.\n', '\n', 'The Sale contract primarily does the following:\n', '\n', '\t- allows individuals to buy tokens during a token sale\n', '\t- allows individuals to claim the tokens after a successful token sale\n', '\t- allows individuals to receive an ETH refund after a cancelled token sale\n', '\t- allows an admin to cancel a token sale, after which individuals can request refunds\n', '\t- allows an admin to certify a token sale, after which an admin can withdraw contributed ETH\n', '\t- allows an admin to complete a token sale, after which an individual (following a brief release period) can request their tokens\n', '\t- allows an admin to return contributed ETH to individuals\n', '\t- allows an admin to grant tokens to an individual\n', '\t- allows an admin to withdraw ETH from the token sale\n', '\t- allows an admin to add and remove individuals from a whitelist\n', '\t- allows an admin to pause or activate the token sale\n', '\t\n', 'The sale runs from a start timestamp to a finish timestamp.  After the release timestamp (assuming a successful sale), individuals can claim their tokens.  If the sale is cancelled, individuals can request a refund.  Furthermore, an admin may return ETH and negate purchases to respective individuals as deemed necessary.  Once the sale is certified or completed, ETH can be withdrawn by the company.\n', '\n', 'The contract creator appoints a delegate to perform most administrative tasks.\n', '\n', 'All events are logged for the purpose of transparency.\n', '\n', 'All math uses SafeMath.\n', '\n', 'ETH and tokens (often referred to as "value" and "tokens" in variable names) are really 1/10^18 of their respective parent units.  Basically, the values represent wei and the token equivalent thereof.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract SaleCallbackInterface {\n', '    function handleSaleCompletionCallback(uint256 _tokens) external payable returns (bool);\n', '    function handleSaleClaimCallback(address _recipient, uint256 _tokens) external returns (bool);  \n', '}\n', '\n', 'contract Sale is SafeMath {\n', '    \n', "    address public creator;\t\t    // address of the contract's creator\n", '    address public delegate;\t\t// address of an entity allowed to perform administrative functions on behalf of the creator\n', '    \n', '    address public marketplace;\t    // address of another smart contract that manages the token and Smart Exchange\n', '    \n', '    uint256 public start;\t\t\t// timestamp that the sale begins\n', '    uint256 public finish;\t\t\t// timestamp that the sale ends\n', '    uint256 public release;\t\t\t// timestamp that sale participants may "claim" their tokens (will be after the finish)\n', '    \n', '    uint256 public pricer;\t\t\t// a multiplier (>= 1) used to determine how many tokens (or, really, 10^18 sub-units of that token) to give purchasers\n', '    uint256 public size;\t\t\t// maximum number of 10^18 sub-units of tokens that can be purchased/granted during the sale\n', '    \n', '    bool public restricted;\t\t    // whether purchasers and recipients of tokens must be whitelisted manually prior to participating in the sale\n', '\n', '    bool public active;\t\t\t    // whether individuals are allowed to purchase tokens -- if false, they cannot.  if true, they can or cannot.  \n', '    \t\t\t\t\t\t\t\t// other factors, like start/finish, size, and others can restrict participation as well, even if active = true.\n', '    \t\t\t\t\t\t\t\t// this also can remain true indefinitely, even if the token sale has been cancelled or has completed.\n', '    \t\t\t\t\t\t\t\t\n', '    \n', '    int8 public progress;\t\t\t// -1 = token sale cancelled, 0 = token sale ongoing, 1 = token sale certified (can withdraw ETH while sale is live), 2 = token sale completed\n', '    \n', '    uint256 public tokens;\t\t\t// number of sub-tokens that have been purchased/granted during the sale.  purchases/grants can be reversed while progress = 0 || progress = 1 resulting in tokens going down\n', '    uint256 public value;\t\t\t// number of sub-ether (wei) that have been contributed during the sale.  purchases can be resversed while progress = 0 || progress = 1 resulting in value going down\n', '    \n', '    uint256 public withdrawls;\t\t// the number of sub-ether (wei) that have been withdrawn by the contract owner\n', '    uint256 public reserves;\t\t// the number of sub-ether (wei) that have been sent to serve as reserve in the marketplace\n', '    \n', '    mapping(address => bool) public participants;\t\t\t// mapping to record who has participated in the sale (purchased/granted)\n', '    address[] public participantIndex;\t\t\t\t\t\t// index of participants\n', '    \n', '    mapping(address => uint256) public participantTokens;\t// sub-tokens purchased/granted to each participant\n', '    mapping(address => uint256) public participantValues;\t// sub-ether contributed by each participant\n', '    \n', '    mapping(address => bool) public participantRefunds;\t    // mapping to record who has been awarded a refund after a cancelled sale\n', '    mapping(address => bool) public participantClaims;\t\t// mapping to record who has claimed their tokens after a completed sale\n', '    \n', '    mapping(address => bool) public whitelist;\t\t\t\t// mapping to record who has been approved to participate in a "restricted" sale\n', '    \n', '    uint256[] public bonuses;\t\t\t\t\t\t\t\t// stores bonus percentages, where even numbered elements store timestamps and odd numbered elements store bonus percentages\n', '    \n', '    bool public mutable;\t\t\t\t\t\t\t\t\t// whether certain properties (like finish and release) of the sale can be updated to increase the liklihood of a successful token sale for all parties involved\n', '    \n', '    modifier ifCreator { require(msg.sender == creator); _; }\t\t// if the caller created the contract...\n', '    modifier ifDelegate { require(msg.sender == delegate); _; }\t\t// if the caller is currently the appointed delegate...\n', '    modifier ifMutable { require(mutable); _; }\t\t\t\t\t\t// if the certain properties of the sale can be changed....\n', '    \n', '    event Created();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract was created\n', '    event Bought(address indexed _buyer, address indexed _recipient, uint256 _tokens, uint256 _value);\t\t// an individual bought tokens\n', '    event Claimed(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual claimed tokens after the completion of the sale and after tokens were scheduled for release\n', '    event Refunded(address indexed _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t// an individual requested a refund of the ETH they contributed after a cancelled token sale\n', '    event Reversed(address indexed _recipient, uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t// an individual was sent the ETH they contributed to the sale and will not receive tokens\n', '    event Granted(address indexed _recipient, uint256 _tokens);\t\t\t\t\t\t\t\t\t\t\t\t// an individual was granted tokens, without contributing ETH\n', '    event Withdrew(address _recipient, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator withdrew ETH from the token sale\n', '    event Completed(uint256 _tokens, uint256 _value, uint256 _reserves);\t\t\t\t\t\t\t\t\t// the contract creator signaled that the sale completed successfuly\n', '    event Certified(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator certified the sale\n', '    event Cancelled(uint256 _tokens, uint256 _value);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the contract creator cancelled the sale\n', '    event Listed(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was added to the whitelist\n', '    event Delisted(address _participant);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// an individual was removed from the whitelist\n', '    event Paused();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was paused (active = false)\n', '    event Activated();    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// the sale was activated (active = true)\n', '\n', '    function Sale() {\n', '        \n', '        creator = msg.sender;\n', '        delegate = msg.sender;\n', '        \n', '        start = 1;\t\t\t\t\t            // contributions may be made as soon as the contract is published\n', '        finish = 1535760000;\t\t\t\t    // the sale continues through 09/01/2018 @ 00:00:00\n', '        release = 1536969600;\t\t\t\t    // tokens will be available to participants starting 09/15/2018 @ 00:00:00\n', '        \n', '        pricer = 100000;\t\t\t\t\t    // each ETH is worth 100,000 tokens\n', '        \n', '        size = 10 ** 18 * pricer * 2000 * 2;\t// 2,000 ETH, plus a 100% buffer to account for the possibility of a 50% decrease in ETH value during the sale\n', '\n', '        restricted = false;                     // the sale accepts contributions from everyone.  \n', '                                                // however, participants who do not submit formal KYC verification before the end of the token sale will have their contributions reverted\n', '    \n', '        bonuses = [1, 20];                      // the bonus during the pre-sale starts at 20%\n', '        \n', '        mutable = true;                         // certain attributes, such as token sale finish and release dates, may be updated to increase the liklihood of a successful token sale for all parties involved\n', '        active = true;                          // the token sale is active from the point the contract is published in the form of a pre-sale         \n', '        \n', '        Created();\n', '        Activated();\n', '    }\n', '    \n', '    // returns the number of sub-tokens the calling account purchased/was granted\n', '    \n', '    function getMyTokenBalance() external constant returns (uint256) {\n', '        return participantTokens[msg.sender];\n', '    }\n', '    \n', '    // allows an individual to buy tokens (which will not be issued immediately)\n', '    // individual instructs the tokens to be delivered to a specific account, which may be different than msg.sender\n', '    \n', '    function buy(address _recipient) public payable {\n', '        \n', "        // _recipient address must not be all 0's\n", '        \n', '        require(_recipient != address(0x0));\n', '\n', '\t\t// contributor must send more than 1/10 ETH\n', '\t\t\n', '        require(msg.value >= 10 ** 17);\n', '\n', '\t\t// sale must be considered active\n', '\t\t\n', '        require(active);\n', '\n', '\t\t// sale must be ongoing or certified\n', '\n', '        require(progress == 0 || progress == 1);\n', '\n', '\t\t// current timestamp must be greater than or equal to the start of the token sale\n', '\t\t\n', '        require(block.timestamp >= start);\n', '\n', '\t\t// current timestamp must be less than the end of the token sale\n', '\t\t\n', '        require(block.timestamp < finish);\n', '\t\t\n', "\t\t// either the token sale isn't restricted, or the sender is on the whitelist\n", '\n', '        require((! restricted) || whitelist[msg.sender]);\n', '        \n', "        // either the token sale isn't restricted, or the recipient is on the whitelist\n", '\n', '        require((! restricted) || whitelist[_recipient]);\n', '        \n', '        // multiply sub-ether by the pricer (which will be a whole number >= 1) to get sub-tokens\n', '\n', '        uint256 baseTokens = safeMul(msg.value, pricer);\n', '        \n', '        // determine how many bonus sub-tokens to award and add that to the base tokens\n', '        \n', '        uint256 totalTokens = safeAdd(baseTokens, safeDiv(safeMul(baseTokens, getBonusPercentage()), 100));\n', '\n', '\t\t// ensure the purchase does not cause the sale to exceed its maximum size\n', '\t\t\n', '        require(safeAdd(tokens, totalTokens) <= size);\n', '        \n', '        // if the recipient is new, add them as a participant\n', '\n', '        if (! participants[_recipient]) {\n', '            participants[_recipient] = true;\n', '            participantIndex.push(_recipient);\n', '        }\n', '        \n', "        // increment the participant's sub-tokens and sub-ether\n", '\n', '        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], totalTokens);\n', '        participantValues[_recipient] = safeAdd(participantValues[_recipient], msg.value);\n', '\n', '\t\t// increment sale sub-tokens and sub-ether\n', '\n', '        tokens = safeAdd(tokens, totalTokens);\n', '        value = safeAdd(value, msg.value);\n', '        \n', '        // log purchase event\n', '\n', '        Bought(msg.sender, _recipient, totalTokens, msg.value);\n', '    }\n', '    \n', '    // token sale participants call this to claim their tokens after the sale is completed and tokens are scheduled for release\n', '    \n', '    function claim() external {\n', '\t    \n', '\t    // sale must be completed\n', '        \n', '        require(progress == 2);\n', '        \n', '        // tokens must be scheduled for release\n', '        \n', '        require(block.timestamp >= release);\n', '        \n', '        // participant must have tokens to claim\n', '        \n', '        require(participantTokens[msg.sender] > 0);\n', '        \n', '        // participant must not have already claimed tokens\n', '        \n', '        require(! participantClaims[msg.sender]);\n', '        \n', '\t\t// record that the participant claimed their tokens\n', '\n', '        participantClaims[msg.sender] = true;\n', '        \n', '        // log the event\n', '        \n', '        Claimed(msg.sender, participantTokens[msg.sender]);\n', '        \n', '        // call the marketplace contract, which will actually issue the tokens to the participant\n', '        \n', '        SaleCallbackInterface(marketplace).handleSaleClaimCallback(msg.sender, participantTokens[msg.sender]);\n', '    }\n', '    \n', '    // token sale participants call this to request a refund if the sale was cancelled\n', '    \n', '    function refund() external {\n', '        \n', '        // the sale must be cancelled\n', '        \n', '        require(progress == -1);\n', '        \n', '        // the participant must have contributed ETH\n', '        \n', '        require(participantValues[msg.sender] > 0);\n', '        \n', '        // the participant must not have already requested a refund\n', '        \n', '        require(! participantRefunds[msg.sender]);\n', '        \n', '\t\t// record that the participant requested a refund\n', '        \n', '        participantRefunds[msg.sender] = true;\n', '        \n', '        // log the event\n', '        \n', '        Refunded(msg.sender, participantValues[msg.sender]);\n', '        \n', '        // transfer contributed ETH back to the participant\n', '    \n', '        address(msg.sender).transfer(participantValues[msg.sender]);\n', '    }    \n', '    \n', '    // the contract creator calls this to withdraw contributed ETH to a specific address\n', '    \n', '    function withdraw(uint256 _sanity, address _recipient, uint256 _value) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 100010001);\n', '        \n', '        // address must not be 0-value\n', '        \n', '        require(_recipient != address(0x0));\n', '        \n', '        // token sale must be certified or completed\n', '        \n', '        require(progress == 1 || progress == 2);\n', '        \n', '        // the amount of ETH in the contract must be greater than the amount the creator is attempting to withdraw\n', '        \n', '        require(this.balance >= _value);\n', '        \n', "        // increment the amount that's been withdrawn\n", '        \n', '        withdrawls = safeAdd(withdrawls, _value);\n', '        \n', '        // log the withdrawl\n', '        \n', '        Withdrew(_recipient, _value);\n', '        \n', '        // send the ETH to the recipient\n', '        \n', '        address(_recipient).transfer(_value);\n', '    } \n', '    \n', '    // the contract owner calls this to complete (finalize/wrap up, etc.) the sale\n', '    \n', '    function complete(uint256 _sanity, uint256 _value) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 101010101);\n', '\t    \n', '\t    // the sale must be marked as ongoing or certified (aka, not cancelled -1)\n', '        \n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // the sale can only be completed after the finish time\n', '        \n', '        require(block.timestamp >= finish);\n', '        \n', '        // ETH is withdrawn in the process and sent to the marketplace contract.  ensure the amount that is being withdrawn is greater than the balance in the smart contract.\n', '        \n', '        require(this.balance >= _value);\n', '        \n', '        // mark the sale as completed\n', '        \n', '        progress = 2;\n', '        \n', '        // the amount that is sent to the other contract is added to the ETH reserve.  denote this amount as reserves.\n', '        \n', '        reserves = safeAdd(reserves, _value);\n', '        \n', '        // log the completion of the sale, including the number of sub-tokens created by the sale, the amount of net sub-eth received during the sale, and the amount of sub-eth to be added to the reserve\n', '        \n', '        Completed(tokens, value, _value);\n', '        \n', '        // call the marketplace contract, sending the ETH for the reserve and including the number of sub-tokens \n', '        \n', '        SaleCallbackInterface(marketplace).handleSaleCompletionCallback.value(_value)(tokens);\n', '    }    \n', '    \n', '    // the creator can certify a sale, meaning it cannot be cancelled, and ETH can be withdrawn from the sale by the creator\n', '    \n', '    function certify(uint256 _sanity) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 101011111);\n', '\t    \n', '\t    // the sale must be ongoing\n', '\t    \n', '        require(progress == 0);\n', '        \n', '        // the sale must have started\n', '        \n', '        require(block.timestamp >= start);\n', '        \n', '        // record that the sale is certified\n', '        \n', '        progress = 1;\n', '        \n', '        // log the certification\n', '        \n', '        Certified(tokens, value);\n', '    }\n', '    \n', '    // the creator can cancel a sale \n', '    \n', '    function cancel(uint256 _sanity) ifCreator external {\n', '        \n', '        // avoid unintended transaction calls\n', '        \n', '        require(_sanity == 111110101);\n', '\t    \n', '\t    // the sale must be ongoing\n', '\t    \n', '        require(progress == 0);\n', '        \n', '        // record that the sale is cancelled\n', '        \n', '        progress = -1;\n', '        \n', '        // log the cancellation\n', '        \n', '        Cancelled(tokens, value);\n', '    }    \n', '    \n', '    // called by the delegate to reverse purchases/grants for a particular contributor\n', '    \n', '    function reverse(address _recipient) ifDelegate external {\n', '        \n', "        // the recipient address must not be all 0's\n", '        \n', '        require(_recipient != address(0x0));\n', '        \n', '        // the sale must be ongoing or certified\n', '        \n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // the recipient must have contributed ETH and/or received tokens\n', '        \n', '        require(participantTokens[_recipient] > 0 || participantValues[_recipient] > 0);\n', '        \n', '        uint256 initialParticipantTokens = participantTokens[_recipient];\n', '        uint256 initialParticipantValue = participantValues[_recipient];\n', '        \n', '        // subtract sub-tokens and sub-ether from sale totals\n', '        \n', '        tokens = safeSub(tokens, initialParticipantTokens);\n', '        value = safeSub(value, initialParticipantValue);\n', '        \n', '        // reset participant sub-tokens and sub-ether\n', '        \n', '        participantTokens[_recipient] = 0;\n', '        participantValues[_recipient] = 0;\n', '        \n', '        // log the reversal, including the initial sub-tokens and initial sub-ether\n', '        \n', '        Reversed(_recipient, initialParticipantTokens, initialParticipantValue);\n', '        \n', '        // if the participant previously sent ETH, return it\n', '        \n', '        if (initialParticipantValue > 0) {\n', '            address(_recipient).transfer(initialParticipantValue);\n', '        }\n', '    }\n', '    \n', '    // called by the delegate to grant tokens to a recipient\n', '    \n', '    function grant(address _recipient, uint256 _tokens) ifDelegate external {\n', '        \n', "       \t// the recipient's address cannot be 0-value\n", '       \n', '        require(_recipient != address(0x0));\n', '\t\t\n', '\t\t// the sale must be ongoing or certified\n', '\t\t\n', '        require(progress == 0 || progress == 1);\n', '        \n', '        // if the recipient has not participated previously, add them as a participant\n', '        \n', '        if (! participants[_recipient]) {\n', '            participants[_recipient] = true;\n', '            participantIndex.push(_recipient);\n', '        }\n', '        \n', "        // add sub-tokens to the recipient's balance\n", '        \n', '        participantTokens[_recipient] = safeAdd(participantTokens[_recipient], _tokens);\n', '        \n', "        // add sub-tokens to the sale's total\n", '        \n', '        tokens = safeAdd(tokens, _tokens);\n', '        \n', '        // log the grant\n', '        \n', '        Granted(_recipient, _tokens);\n', '    }    \n', '    \n', '    // adds a set of addresses to the whitelist\n', '    \n', '    function list(address[] _addresses) ifDelegate external {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelist[_addresses[i]] = true;\n', '            Listed(_addresses[i]);\n', '        }\n', '    }\n', '    \n', '    // removes a set of addresses from the whitelist\n', '    \n', '    function delist(address[] _addresses) ifDelegate external {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelist[_addresses[i]] = false;\n', '            Delisted(_addresses[i]);\n', '        }\n', '    }  \n', '    \n', '\t// pause the sale\n', '    \n', '    function pause() ifDelegate external {\n', '        active = false;\n', '        Paused();\n', '    }\n', '    \n', '    // activate the sale\n', '\n', '    function activate() ifDelegate external {\n', '        active = true;\n', '        Activated();\n', '    }\n', '\n', '    function setDelegate(address _delegate) ifCreator external {\n', '        delegate = _delegate;\n', '    }\n', '    \n', '    function setRestricted(bool _restricted) ifDelegate external {\n', '        restricted = _restricted;\n', '    }\n', '    \n', '    function setMarketplace(address _marketplace) ifCreator ifMutable external {\n', '        marketplace = _marketplace;\n', '    }\n', '    \n', '    function setBonuses(uint256[] _bonuses) ifDelegate ifMutable external {\n', '        bonuses = _bonuses;\n', '    }\n', '    \n', '    function setFinish(uint256 _finish) ifDelegate ifMutable external {\n', '        finish = _finish;\n', '    }\n', '\n', '    function setRelease(uint256 _release) ifDelegate ifMutable external {\n', '        release = _release;\n', '    }     \n', '    \n', '    // get the current bonus percentage, as a whole number\n', '    \n', '    function getBonusPercentage() public constant returns (uint256) {\n', '        \n', '        uint256 finalBonus;\n', '        \n', '        uint256 iterativeTimestamp;\n', '        uint256 iterativeBonus;\n', '        \n', '        // within bonuses, even numbered elements store timestamps and odd numbered elements store bonus percentages\n', '        // timestamps are in order from oldest to newest\n', '        // iterates over the elements and if the timestamp has been surpassed, the bonus percentage is denoted\n', '        // the last bonus percentage that was denoted, if one was denoted at all, is the correct bonus percentage at this time\n', '        \n', '        for (uint256 i = 0; i < bonuses.length; i++) {\n', '            if (i % 2 == 0) {\n', '                iterativeTimestamp = bonuses[i];\n', '            } else {\n', '                iterativeBonus = bonuses[i];\n', '                if (block.timestamp >= iterativeTimestamp) {\n', '                    finalBonus = iterativeBonus;\n', '                }\n', '            }\n', '        } \n', '        \n', '        return finalBonus;\n', '    }    \n', '    \n', '    function() public payable {\n', '        buy(msg.sender);\n', '    }\n', '    \n', '}']
