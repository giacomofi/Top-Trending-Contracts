['pragma solidity 0.4.24;\n', '\n', 'contract InterbetCore {\n', '\n', '\t/* Global constants */\n', '\tuint constant oddsDecimals = 2; // Max. decimal places of odds\n', '\tuint constant feeRateDecimals = 1; // Max. decimal places of fee rate\n', '\n', '\tuint public minMakerBetFund = 100 * 1 finney; // Minimum fund of a maker bet\n', '\n', '\tuint public maxAllowedTakerBetsPerMakerBet = 100; // Limit the number of taker-bets in 1 maker-bet\n', '\tuint public minAllowedStakeInPercentage = 1; // 100 &#247; maxAllowedTakerBetsPerMakerBet\n', '\n', '\tuint public baseVerifierFee = 1 finney; // Ensure verifier has some minimal profit to cover their gas cost at least\n', '\n', '\t/* Owner and admins */\n', '\taddress private owner;\n', '\tmapping(address => bool) private admins;\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) external onlyOwner {\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tfunction addAdmin(address addr) external onlyOwner {\n', '\t\tadmins[addr] = true;\n', '\t}\n', '\n', '\tfunction removeAdmin(address addr) external onlyOwner {\n', '\t\tadmins[addr] = false;\n', '\t}\n', '\n', '\tmodifier onlyAdmin() {\n', '\t\trequire(admins[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction changeMinMakerBetFund(uint weis) external onlyAdmin {\n', '\t\tminMakerBetFund = mul(weis, 1 wei);\n', '\t}\n', '\n', '\tfunction changeAllowedTakerBetsPerMakerBet(uint maxCount, uint minPercentage) external onlyAdmin {\n', '\t\tmaxAllowedTakerBetsPerMakerBet = maxCount;\n', '\t\tminAllowedStakeInPercentage = minPercentage;\n', '\t}\n', '\n', '\tfunction changeBaseVerifierFee(uint weis) external onlyAdmin {\n', '\t\tbaseVerifierFee = mul(weis, 1 wei);\n', '\t}\n', '\n', '\t/* Events */\n', '\tevent LogUpdateVerifier(address indexed addr, uint oldFeeRate, uint newFeeRate);\n', '\tevent LogMakeBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogAddFund(uint indexed makerBetId, address indexed maker, uint oldTotalFund, uint newTotalFund);\n', '\tevent LogUpdateOdds(uint indexed makerBetId, address indexed maker, uint oldOdds, uint newOdds);\n', '\tevent LogPauseBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogReopenBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogCloseBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogTakeBet(uint indexed makerBetId, address indexed maker, uint indexed takerBetId, address taker);\n', '\tevent LogSettleBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogWithdraw(uint indexed makerBetId, address indexed maker, address indexed addr);\n', '\n', '\t/* Betting Core */\n', '\tenum BetStatus {\n', '\t\tOpen, \n', '\t\tPaused, \n', '\t\tClosed, \n', '\t\tSettled\n', '\t}\n', '\n', '\tenum BetOutcome {\n', '\t\tNotSettled,\n', '\t\tMakerWin,\n', '\t\tTakerWin,\n', '\t\tDraw,\n', '\t\tCanceled\n', '\t}\n', '\n', '\tstruct MakerBet {\n', '\t\tuint makerBetId;\n', '\t\taddress maker;\n', '\t\tuint odds;\n', '\t\tuint totalFund;\n', '\t\tVerifier trustedVerifier;\n', '\t\tuint expiry;\n', '\t\tBetStatus status;\n', '\t\tuint reservedFund;\n', '\t\tuint takerBetsCount;\n', '\t\tuint totalStake;\n', '\t\tTakerBet[] takerBets;\n', '\t\tBetOutcome outcome;\n', '\t\tbool makerFundWithdrawn;\n', '\t\tbool trustedVerifierFeeSent;\n', '\t}\n', '\n', '\tstruct TakerBet {\n', '\t\tuint takerBetId;\n', '\t\taddress taker;\n', '\t\tuint odds;\n', '\t\tuint stake;\n', '        bool settled;\n', '\t}\n', '\n', '\tstruct Verifier {\n', '\t\taddress addr;\n', '\t\tuint feeRate;\n', '\t}\n', '\n', '\tuint public makerBetsCount;\n', '\tmapping(uint => mapping(address => MakerBet)) private makerBets;\n', '\n', '\tmapping(address => Verifier) private verifiers;\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tmakerBetsCount = 0;\n', '\t}\n', '\n', '\tfunction () external payable {\n', '\t\trevert();\n', '\t}\n', '\n', '\t/// Update verifier&#39;s data\n', '\tfunction updateVerifier(uint feeRate) external {\n', '\t\trequire(feeRate >= 0 && feeRate <= ((10 ** feeRateDecimals) * 100));\n', '\n', '\t\tVerifier storage verifier = verifiers[msg.sender];\n', '\n', '\t\tuint oldFeeRate = verifier.feeRate;\n', '\n', '\t\tverifier.addr = msg.sender;\n', '\t\tverifier.feeRate = feeRate;\n', '\n', '\t\temit LogUpdateVerifier(msg.sender, oldFeeRate, feeRate);\n', '\t}\n', '\n', '\t/// Make a bet\n', '\tfunction makeBet(uint makerBetId, uint odds, address trustedVerifier, uint trustedVerifierFeeRate, uint expiry) external payable {\n', '\t\tuint fund = sub(msg.value, baseVerifierFee);\n', '\n', '\t\trequire(fund >= minMakerBetFund);\n', '\t\trequire(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals)));\n', '\t\trequire(expiry > now);\n', '\n', '        MakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\n', '        require(makerBet.makerBetId == 0);\n', '\n', '        Verifier memory verifier = verifiers[trustedVerifier];\n', '\n', '        require(verifier.addr != address(0x0));\n', '        require(trustedVerifierFeeRate == verifier.feeRate);\n', '\n', '\t\tmakerBet.makerBetId = makerBetId;\n', '\t\tmakerBet.maker = msg.sender;\n', '\t\tmakerBet.odds = odds;\n', '\t\tmakerBet.totalFund = fund;\n', '\t\tmakerBet.trustedVerifier = Verifier(verifier.addr, verifier.feeRate);\n', '\t\tmakerBet.expiry = expiry;\n', '\t\tmakerBet.status = BetStatus.Open;\n', '\t\tmakerBet.reservedFund = 0;\n', '\t\tmakerBet.takerBetsCount = 0;\n', '\t\tmakerBet.totalStake = 0;\n', '\n', '\t\tmakerBetsCount++;\n', '\n', '\t\temit LogMakeBet(makerBetId, msg.sender);\n', '\t}\n', '\n', '\t/// Increase total fund of a bet\n', '    function addFund(uint makerBetId) external payable {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(now < makerBet.expiry);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tuint oldTotalFund = makerBet.totalFund;\n', '\n', '    \tmakerBet.totalFund = add(makerBet.totalFund, msg.value);\n', '\n', '    \temit LogAddFund(makerBetId, msg.sender, oldTotalFund, makerBet.totalFund);\n', '    }\n', '\n', '    /// Update odds of a bet\n', '    function updateOdds(uint makerBetId, uint odds) external {\n', '    \trequire(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals)));\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(now < makerBet.expiry);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '    \trequire(odds != makerBet.odds);\n', '\n', '    \tuint oldOdds = makerBet.odds;\n', '\n', '    \tmakerBet.odds = odds;\n', '\n', '    \temit LogUpdateOdds(makerBetId, msg.sender, oldOdds, makerBet.odds);\n', '    }\n', '\n', '    /// Pause a bet\n', '    function pauseBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Paused;\n', '\n', '\t\temit LogPauseBet(makerBetId, msg.sender);\n', '    }\n', '\n', '    /// Reopen a bet\n', '    function reopenBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Open;\n', '\n', '\t\temit LogReopenBet(makerBetId, msg.sender);\n', '    }\n', '\n', '    /// Close a bet and withdraw unused fund\n', '    function closeBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Closed;\n', '\n', '\t\t// refund unused fund to maker\n', '\t\tuint unusedFund = sub(makerBet.totalFund, makerBet.reservedFund);\n', '\n', '\t\tif (unusedFund > 0) {\n', '\t\t\tmakerBet.totalFund = makerBet.reservedFund;\n', '\n', '\t\t\tuint refundAmount = unusedFund;\n', '\t\t\tif (makerBet.totalStake == 0) {\n', '\t\t\t\trefundAmount = add(refundAmount, baseVerifierFee); // Refund base verifier fee too if no taker-bets, because verifier do not need to settle the bet with no takers\n', '\t\t\t\tmakerBet.makerFundWithdrawn = true;\n', '\t\t\t}\n', '\n', '\t\t\tif (!makerBet.maker.send(refundAmount)) {\n', '\t\t\t\tmakerBet.totalFund = add(makerBet.totalFund, unusedFund);\n', '\t            makerBet.status = BetStatus.Paused;\n', '\t            makerBet.makerFundWithdrawn = false;\n', '\t        } else {\n', '\t        \temit LogCloseBet(makerBetId, msg.sender);\n', '\t        }\n', '\t\t} else {\n', '\t\t\temit LogCloseBet(makerBetId, msg.sender);\n', '\t\t}\n', '    }\n', '\n', '    /// Take a bet\n', '\tfunction takeBet(uint makerBetId, address maker, uint odds, uint takerBetId) external payable {\n', '\t\trequire(msg.sender != maker);\n', '\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(msg.sender != makerBet.trustedVerifier.addr);\n', '\n', '\t\trequire(now < makerBet.expiry);\n', '\n', '\t\trequire(makerBet.status == BetStatus.Open);\n', '\n', '\t\trequire(makerBet.odds == odds);\n', '\n', '\t\t// Avoid too many taker-bets in one maker-bet\n', '\t\trequire(makerBet.takerBetsCount < maxAllowedTakerBetsPerMakerBet);\n', '\n', '\t\t// Avoid too many tiny bets\n', '\t\tuint minAllowedStake = mul(mul(makerBet.totalFund, (10 ** oddsDecimals)), minAllowedStakeInPercentage) / sub(odds, (10 ** oddsDecimals)) / 100;\n', '\t\tuint maxAvailableStake = mul(sub(makerBet.totalFund, makerBet.reservedFund), (10 ** oddsDecimals)) / sub(odds, (10 ** oddsDecimals));\n', '\t\tif (maxAvailableStake >= minAllowedStake) {\n', '\t\t\trequire(msg.value >= minAllowedStake);\n', '\t\t} else {\n', '\t\t\trequire(msg.value >= sub(maxAvailableStake, (maxAvailableStake / 10)) && msg.value <= maxAvailableStake);\n', '\t\t}\n', '\n', '        // If remaining fund is not enough, send the money back.\n', '\t\trequire(msg.value <= maxAvailableStake);\n', '\n', '        makerBet.takerBets.length++;\n', '\t\tmakerBet.takerBets[makerBet.takerBetsCount] = TakerBet(takerBetId, msg.sender, odds, msg.value, false);\n', '\t\tmakerBet.reservedFund = add(makerBet.reservedFund, mul(msg.value, sub(odds, (10 ** oddsDecimals))) / (10 ** oddsDecimals));   \n', '\t\tmakerBet.totalStake = add(makerBet.totalStake, msg.value);\n', '\t\tmakerBet.takerBetsCount++;\n', '\n', '\t\temit LogTakeBet(makerBetId, maker, takerBetId, msg.sender);\n', '\t}\n', '\n', '\t/// Payout to maker\n', '\tfunction payMaker(MakerBet storage makerBet) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tif (!makerBet.makerFundWithdrawn) {\n', '\t\t\tmakerBet.makerFundWithdrawn = true;\n', '\n', '\t\t\tuint payout = 0;\n', '\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = sub(add(makerBet.totalFund, makerBet.totalStake), trustedVerifierFeeMakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\tpayout = sub(makerBet.totalFund, makerBet.reservedFund);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\tpayout = makerBet.totalFund;\n', '\t\t\t}\n', '\n', '\t\t\tif (payout > 0) {\n', '\t\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t\t\tif (!makerBet.maker.send(payout)) {\n', '\t                makerBet.makerFundWithdrawn = false;\n', '\t                fullyWithdrawn = false;\n', '\t            }\n', '\t        }\n', '        }\n', '\n', '        return fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Payout to taker\n', '\tfunction payTaker(MakerBet storage makerBet, address taker) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tuint payout = 0;\n', '\n', '\t\tfor (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) {\n', '\t\t\tif (makerBet.takerBets[betIndex].taker == taker) {\n', '\t\t\t\tif (!makerBet.takerBets[betIndex].settled) {\n', '\t\t\t\t\tmakerBet.takerBets[betIndex].settled = true;\n', '\n', '\t\t\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\t\t\tcontinue;\n', '\t\t\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\t\t\tuint netProfit = mul(mul(makerBet.takerBets[betIndex].stake, sub(makerBet.takerBets[betIndex].odds, (10 ** oddsDecimals))), sub(((10 ** feeRateDecimals) * 100), makerBet.trustedVerifier.feeRate)) / (10 ** oddsDecimals) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\t\t\tpayout = add(payout, add(makerBet.takerBets[betIndex].stake, netProfit));\n', '\t\t\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\t\t\tpayout = add(payout, makerBet.takerBets[betIndex].stake);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (payout > 0) {\n', '\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t\tif (!taker.send(payout)) {\n', '\t\t\t\tfullyWithdrawn = false;\n', '\n', '\t\t\t\tfor (uint betIndex2 = 0; betIndex2 < makerBet.takerBetsCount; betIndex2++) {\n', '\t\t\t\t\tif (makerBet.takerBets[betIndex2].taker == taker) {\n', '\t\t\t\t\t\tif (makerBet.takerBets[betIndex2].settled) {\n', '\t\t\t\t\t\t\tmakerBet.takerBets[betIndex2].settled = false;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '            }\n', '        }\n', '\n', '\t\treturn fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Payout to verifier\n', '\tfunction payVerifier(MakerBet storage makerBet) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tif (!makerBet.trustedVerifierFeeSent) {\n', '\t    \tmakerBet.trustedVerifierFeeSent = true;\n', '\n', '\t    \tuint payout = 0;\n', '\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = add(baseVerifierFee, trustedVerifierFeeMakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeTakerWin = mul(makerBet.reservedFund, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = add(baseVerifierFee, trustedVerifierFeeTakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\tpayout = baseVerifierFee;\n', '\t\t\t}\n', '\n', '\t\t\tif (payout > 0) {\n', '\t\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t    \tif (!makerBet.trustedVerifier.addr.send(payout)) {\n', '\t\t    \t\tmakerBet.trustedVerifierFeeSent = false;\n', '\t\t    \t\tfullyWithdrawn = false;\n', '\t\t    \t}\n', '\t    \t}\n', '\t    }\n', '\n', '\t    return fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Settle a bet by trusted verifier\n', '\tfunction settleBet(uint makerBetId, address maker, uint outcome) external {\n', '\t\trequire(outcome == 1 || outcome == 2 || outcome == 3 || outcome == 4);\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(msg.sender == makerBet.trustedVerifier.addr);\n', '\n', '\t\trequire(makerBet.totalStake > 0);\n', '\n', '\t\trequire(makerBet.status != BetStatus.Settled);\n', '\n', '\t\tBetOutcome betOutcome = BetOutcome(outcome);\n', '\t\tmakerBet.outcome = betOutcome;\n', '\t\tmakerBet.status = BetStatus.Settled;\n', '\n', '\t\tpayMaker(makerBet);\n', '\t\tpayVerifier(makerBet);\n', '\n', '\t\temit LogSettleBet(makerBetId, maker);\n', '\t}\n', '\n', '\t/// Manual withdraw fund from a bet after outcome is set\n', '\tfunction withdraw(uint makerBetId, address maker) external {\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(makerBet.outcome != BetOutcome.NotSettled);\n', '\n', '\t\trequire(makerBet.status == BetStatus.Settled);\n', '\n', '\t\tbool fullyWithdrawn = false;\n', '\n', '\t\tif (msg.sender == maker) {\n', '\t\t\tfullyWithdrawn = payMaker(makerBet);\n', '\t\t} else if (msg.sender == makerBet.trustedVerifier.addr) {\n', '\t\t\tfullyWithdrawn = payVerifier(makerBet);\n', '\t\t} else {\n', '\t\t\tfullyWithdrawn = payTaker(makerBet, msg.sender);\n', '\t\t}\n', '\n', '\t\tif (fullyWithdrawn) {\n', '\t\t\temit LogWithdraw(makerBetId, maker, msg.sender);\n', '\t\t}\n', '\t}\n', '\n', '    /* External views */\n', '    function getOwner() external view returns(address) {\n', '        return owner;\n', '    }\n', '\n', '    function isAdmin(address addr) external view returns(bool) {\n', '        return admins[addr];\n', '    }\n', '\n', '    function getVerifier(address addr) external view returns(address, uint) {\n', '    \tVerifier memory verifier = verifiers[addr];\n', '    \treturn (verifier.addr, verifier.feeRate);\n', '    }\n', '\n', '    function getMakerBetBasicInfo(uint makerBetId, address maker) external view returns(uint, address, address, uint, uint) {\n', '    \tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \treturn (makerBet.makerBetId, makerBet.maker, makerBet.trustedVerifier.addr, makerBet.trustedVerifier.feeRate, makerBet.expiry);\n', '    }\n', '\n', '    function getMakerBetDetails(uint makerBetId, address maker) external view returns(uint, BetStatus, uint, uint, uint, uint, uint, BetOutcome, bool, bool) {\n', '\t\tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \treturn (makerBet.makerBetId, makerBet.status, makerBet.odds, makerBet.totalFund, makerBet.reservedFund, makerBet.takerBetsCount, makerBet.totalStake, makerBet.outcome, makerBet.makerFundWithdrawn, makerBet.trustedVerifierFeeSent);\n', '    }\n', '\n', '    function getTakerBet(uint makerBetId, address maker, uint takerBetId, address taker) external view returns(uint, address, uint, uint, bool) {\n', '    \tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \tfor (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) {\n', '\t\t\tTakerBet memory takerBet = makerBet.takerBets[betIndex];\n', '\n', '\t\t\tif (takerBet.takerBetId == takerBetId && takerBet.taker == taker) {\n', '\t\t\t\treturn (takerBet.takerBetId, takerBet.taker, takerBet.odds, takerBet.stake, takerBet.settled);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\n', '\t/* Math utilities */\n', '\tfunction mul(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '\t    if (_a == 0) {\n', '\t      return 0;\n', '\t    }\n', '\n', '\t    c = _a * _b;\n', '\t    assert(c / _a == _b);\n', '\t    return c;\n', '  \t}\n', '\n', '  \tfunction sub(uint256 _a, uint256 _b) private pure returns(uint256) {\n', '    \tassert(_b <= _a);\n', '    \treturn _a - _b;\n', '  \t}\n', '\n', '  \tfunction add(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '   \t\tc = _a + _b;\n', '    \tassert(c >= _a);\n', '    \treturn c;\n', '  \t}\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract InterbetCore {\n', '\n', '\t/* Global constants */\n', '\tuint constant oddsDecimals = 2; // Max. decimal places of odds\n', '\tuint constant feeRateDecimals = 1; // Max. decimal places of fee rate\n', '\n', '\tuint public minMakerBetFund = 100 * 1 finney; // Minimum fund of a maker bet\n', '\n', '\tuint public maxAllowedTakerBetsPerMakerBet = 100; // Limit the number of taker-bets in 1 maker-bet\n', '\tuint public minAllowedStakeInPercentage = 1; // 100 ÷ maxAllowedTakerBetsPerMakerBet\n', '\n', '\tuint public baseVerifierFee = 1 finney; // Ensure verifier has some minimal profit to cover their gas cost at least\n', '\n', '\t/* Owner and admins */\n', '\taddress private owner;\n', '\tmapping(address => bool) private admins;\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) external onlyOwner {\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tfunction addAdmin(address addr) external onlyOwner {\n', '\t\tadmins[addr] = true;\n', '\t}\n', '\n', '\tfunction removeAdmin(address addr) external onlyOwner {\n', '\t\tadmins[addr] = false;\n', '\t}\n', '\n', '\tmodifier onlyAdmin() {\n', '\t\trequire(admins[msg.sender] == true);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction changeMinMakerBetFund(uint weis) external onlyAdmin {\n', '\t\tminMakerBetFund = mul(weis, 1 wei);\n', '\t}\n', '\n', '\tfunction changeAllowedTakerBetsPerMakerBet(uint maxCount, uint minPercentage) external onlyAdmin {\n', '\t\tmaxAllowedTakerBetsPerMakerBet = maxCount;\n', '\t\tminAllowedStakeInPercentage = minPercentage;\n', '\t}\n', '\n', '\tfunction changeBaseVerifierFee(uint weis) external onlyAdmin {\n', '\t\tbaseVerifierFee = mul(weis, 1 wei);\n', '\t}\n', '\n', '\t/* Events */\n', '\tevent LogUpdateVerifier(address indexed addr, uint oldFeeRate, uint newFeeRate);\n', '\tevent LogMakeBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogAddFund(uint indexed makerBetId, address indexed maker, uint oldTotalFund, uint newTotalFund);\n', '\tevent LogUpdateOdds(uint indexed makerBetId, address indexed maker, uint oldOdds, uint newOdds);\n', '\tevent LogPauseBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogReopenBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogCloseBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogTakeBet(uint indexed makerBetId, address indexed maker, uint indexed takerBetId, address taker);\n', '\tevent LogSettleBet(uint indexed makerBetId, address indexed maker);\n', '\tevent LogWithdraw(uint indexed makerBetId, address indexed maker, address indexed addr);\n', '\n', '\t/* Betting Core */\n', '\tenum BetStatus {\n', '\t\tOpen, \n', '\t\tPaused, \n', '\t\tClosed, \n', '\t\tSettled\n', '\t}\n', '\n', '\tenum BetOutcome {\n', '\t\tNotSettled,\n', '\t\tMakerWin,\n', '\t\tTakerWin,\n', '\t\tDraw,\n', '\t\tCanceled\n', '\t}\n', '\n', '\tstruct MakerBet {\n', '\t\tuint makerBetId;\n', '\t\taddress maker;\n', '\t\tuint odds;\n', '\t\tuint totalFund;\n', '\t\tVerifier trustedVerifier;\n', '\t\tuint expiry;\n', '\t\tBetStatus status;\n', '\t\tuint reservedFund;\n', '\t\tuint takerBetsCount;\n', '\t\tuint totalStake;\n', '\t\tTakerBet[] takerBets;\n', '\t\tBetOutcome outcome;\n', '\t\tbool makerFundWithdrawn;\n', '\t\tbool trustedVerifierFeeSent;\n', '\t}\n', '\n', '\tstruct TakerBet {\n', '\t\tuint takerBetId;\n', '\t\taddress taker;\n', '\t\tuint odds;\n', '\t\tuint stake;\n', '        bool settled;\n', '\t}\n', '\n', '\tstruct Verifier {\n', '\t\taddress addr;\n', '\t\tuint feeRate;\n', '\t}\n', '\n', '\tuint public makerBetsCount;\n', '\tmapping(uint => mapping(address => MakerBet)) private makerBets;\n', '\n', '\tmapping(address => Verifier) private verifiers;\n', '\n', '\tconstructor() public {\n', '\t\towner = msg.sender;\n', '\t\tmakerBetsCount = 0;\n', '\t}\n', '\n', '\tfunction () external payable {\n', '\t\trevert();\n', '\t}\n', '\n', "\t/// Update verifier's data\n", '\tfunction updateVerifier(uint feeRate) external {\n', '\t\trequire(feeRate >= 0 && feeRate <= ((10 ** feeRateDecimals) * 100));\n', '\n', '\t\tVerifier storage verifier = verifiers[msg.sender];\n', '\n', '\t\tuint oldFeeRate = verifier.feeRate;\n', '\n', '\t\tverifier.addr = msg.sender;\n', '\t\tverifier.feeRate = feeRate;\n', '\n', '\t\temit LogUpdateVerifier(msg.sender, oldFeeRate, feeRate);\n', '\t}\n', '\n', '\t/// Make a bet\n', '\tfunction makeBet(uint makerBetId, uint odds, address trustedVerifier, uint trustedVerifierFeeRate, uint expiry) external payable {\n', '\t\tuint fund = sub(msg.value, baseVerifierFee);\n', '\n', '\t\trequire(fund >= minMakerBetFund);\n', '\t\trequire(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals)));\n', '\t\trequire(expiry > now);\n', '\n', '        MakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\n', '        require(makerBet.makerBetId == 0);\n', '\n', '        Verifier memory verifier = verifiers[trustedVerifier];\n', '\n', '        require(verifier.addr != address(0x0));\n', '        require(trustedVerifierFeeRate == verifier.feeRate);\n', '\n', '\t\tmakerBet.makerBetId = makerBetId;\n', '\t\tmakerBet.maker = msg.sender;\n', '\t\tmakerBet.odds = odds;\n', '\t\tmakerBet.totalFund = fund;\n', '\t\tmakerBet.trustedVerifier = Verifier(verifier.addr, verifier.feeRate);\n', '\t\tmakerBet.expiry = expiry;\n', '\t\tmakerBet.status = BetStatus.Open;\n', '\t\tmakerBet.reservedFund = 0;\n', '\t\tmakerBet.takerBetsCount = 0;\n', '\t\tmakerBet.totalStake = 0;\n', '\n', '\t\tmakerBetsCount++;\n', '\n', '\t\temit LogMakeBet(makerBetId, msg.sender);\n', '\t}\n', '\n', '\t/// Increase total fund of a bet\n', '    function addFund(uint makerBetId) external payable {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(now < makerBet.expiry);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tuint oldTotalFund = makerBet.totalFund;\n', '\n', '    \tmakerBet.totalFund = add(makerBet.totalFund, msg.value);\n', '\n', '    \temit LogAddFund(makerBetId, msg.sender, oldTotalFund, makerBet.totalFund);\n', '    }\n', '\n', '    /// Update odds of a bet\n', '    function updateOdds(uint makerBetId, uint odds) external {\n', '    \trequire(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals)));\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(now < makerBet.expiry);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '    \trequire(odds != makerBet.odds);\n', '\n', '    \tuint oldOdds = makerBet.odds;\n', '\n', '    \tmakerBet.odds = odds;\n', '\n', '    \temit LogUpdateOdds(makerBetId, msg.sender, oldOdds, makerBet.odds);\n', '    }\n', '\n', '    /// Pause a bet\n', '    function pauseBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Paused;\n', '\n', '\t\temit LogPauseBet(makerBetId, msg.sender);\n', '    }\n', '\n', '    /// Reopen a bet\n', '    function reopenBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Open;\n', '\n', '\t\temit LogReopenBet(makerBetId, msg.sender);\n', '    }\n', '\n', '    /// Close a bet and withdraw unused fund\n', '    function closeBet(uint makerBetId) external {\n', '    \tMakerBet storage makerBet = makerBets[makerBetId][msg.sender];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '    \trequire(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused);\n', '\n', '    \trequire(msg.sender == makerBet.maker);\n', '\n', '\t\tmakerBet.status = BetStatus.Closed;\n', '\n', '\t\t// refund unused fund to maker\n', '\t\tuint unusedFund = sub(makerBet.totalFund, makerBet.reservedFund);\n', '\n', '\t\tif (unusedFund > 0) {\n', '\t\t\tmakerBet.totalFund = makerBet.reservedFund;\n', '\n', '\t\t\tuint refundAmount = unusedFund;\n', '\t\t\tif (makerBet.totalStake == 0) {\n', '\t\t\t\trefundAmount = add(refundAmount, baseVerifierFee); // Refund base verifier fee too if no taker-bets, because verifier do not need to settle the bet with no takers\n', '\t\t\t\tmakerBet.makerFundWithdrawn = true;\n', '\t\t\t}\n', '\n', '\t\t\tif (!makerBet.maker.send(refundAmount)) {\n', '\t\t\t\tmakerBet.totalFund = add(makerBet.totalFund, unusedFund);\n', '\t            makerBet.status = BetStatus.Paused;\n', '\t            makerBet.makerFundWithdrawn = false;\n', '\t        } else {\n', '\t        \temit LogCloseBet(makerBetId, msg.sender);\n', '\t        }\n', '\t\t} else {\n', '\t\t\temit LogCloseBet(makerBetId, msg.sender);\n', '\t\t}\n', '    }\n', '\n', '    /// Take a bet\n', '\tfunction takeBet(uint makerBetId, address maker, uint odds, uint takerBetId) external payable {\n', '\t\trequire(msg.sender != maker);\n', '\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(msg.sender != makerBet.trustedVerifier.addr);\n', '\n', '\t\trequire(now < makerBet.expiry);\n', '\n', '\t\trequire(makerBet.status == BetStatus.Open);\n', '\n', '\t\trequire(makerBet.odds == odds);\n', '\n', '\t\t// Avoid too many taker-bets in one maker-bet\n', '\t\trequire(makerBet.takerBetsCount < maxAllowedTakerBetsPerMakerBet);\n', '\n', '\t\t// Avoid too many tiny bets\n', '\t\tuint minAllowedStake = mul(mul(makerBet.totalFund, (10 ** oddsDecimals)), minAllowedStakeInPercentage) / sub(odds, (10 ** oddsDecimals)) / 100;\n', '\t\tuint maxAvailableStake = mul(sub(makerBet.totalFund, makerBet.reservedFund), (10 ** oddsDecimals)) / sub(odds, (10 ** oddsDecimals));\n', '\t\tif (maxAvailableStake >= minAllowedStake) {\n', '\t\t\trequire(msg.value >= minAllowedStake);\n', '\t\t} else {\n', '\t\t\trequire(msg.value >= sub(maxAvailableStake, (maxAvailableStake / 10)) && msg.value <= maxAvailableStake);\n', '\t\t}\n', '\n', '        // If remaining fund is not enough, send the money back.\n', '\t\trequire(msg.value <= maxAvailableStake);\n', '\n', '        makerBet.takerBets.length++;\n', '\t\tmakerBet.takerBets[makerBet.takerBetsCount] = TakerBet(takerBetId, msg.sender, odds, msg.value, false);\n', '\t\tmakerBet.reservedFund = add(makerBet.reservedFund, mul(msg.value, sub(odds, (10 ** oddsDecimals))) / (10 ** oddsDecimals));   \n', '\t\tmakerBet.totalStake = add(makerBet.totalStake, msg.value);\n', '\t\tmakerBet.takerBetsCount++;\n', '\n', '\t\temit LogTakeBet(makerBetId, maker, takerBetId, msg.sender);\n', '\t}\n', '\n', '\t/// Payout to maker\n', '\tfunction payMaker(MakerBet storage makerBet) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tif (!makerBet.makerFundWithdrawn) {\n', '\t\t\tmakerBet.makerFundWithdrawn = true;\n', '\n', '\t\t\tuint payout = 0;\n', '\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = sub(add(makerBet.totalFund, makerBet.totalStake), trustedVerifierFeeMakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\tpayout = sub(makerBet.totalFund, makerBet.reservedFund);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\tpayout = makerBet.totalFund;\n', '\t\t\t}\n', '\n', '\t\t\tif (payout > 0) {\n', '\t\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t\t\tif (!makerBet.maker.send(payout)) {\n', '\t                makerBet.makerFundWithdrawn = false;\n', '\t                fullyWithdrawn = false;\n', '\t            }\n', '\t        }\n', '        }\n', '\n', '        return fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Payout to taker\n', '\tfunction payTaker(MakerBet storage makerBet, address taker) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tuint payout = 0;\n', '\n', '\t\tfor (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) {\n', '\t\t\tif (makerBet.takerBets[betIndex].taker == taker) {\n', '\t\t\t\tif (!makerBet.takerBets[betIndex].settled) {\n', '\t\t\t\t\tmakerBet.takerBets[betIndex].settled = true;\n', '\n', '\t\t\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\t\t\tcontinue;\n', '\t\t\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\t\t\tuint netProfit = mul(mul(makerBet.takerBets[betIndex].stake, sub(makerBet.takerBets[betIndex].odds, (10 ** oddsDecimals))), sub(((10 ** feeRateDecimals) * 100), makerBet.trustedVerifier.feeRate)) / (10 ** oddsDecimals) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\t\t\tpayout = add(payout, add(makerBet.takerBets[betIndex].stake, netProfit));\n', '\t\t\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\t\t\tpayout = add(payout, makerBet.takerBets[betIndex].stake);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (payout > 0) {\n', '\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t\tif (!taker.send(payout)) {\n', '\t\t\t\tfullyWithdrawn = false;\n', '\n', '\t\t\t\tfor (uint betIndex2 = 0; betIndex2 < makerBet.takerBetsCount; betIndex2++) {\n', '\t\t\t\t\tif (makerBet.takerBets[betIndex2].taker == taker) {\n', '\t\t\t\t\t\tif (makerBet.takerBets[betIndex2].settled) {\n', '\t\t\t\t\t\t\tmakerBet.takerBets[betIndex2].settled = false;\n', '\t\t\t\t\t\t}\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '            }\n', '        }\n', '\n', '\t\treturn fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Payout to verifier\n', '\tfunction payVerifier(MakerBet storage makerBet) private returns (bool fullyWithdrawn) {\n', '\t\tfullyWithdrawn = false;\n', '\n', '\t\tif (!makerBet.trustedVerifierFeeSent) {\n', '\t    \tmakerBet.trustedVerifierFeeSent = true;\n', '\n', '\t    \tuint payout = 0;\n', '\t\t\tif (makerBet.outcome == BetOutcome.MakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = add(baseVerifierFee, trustedVerifierFeeMakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.TakerWin) {\n', '\t\t\t\tuint trustedVerifierFeeTakerWin = mul(makerBet.reservedFund, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);\n', '\t\t\t\tpayout = add(baseVerifierFee, trustedVerifierFeeTakerWin);\n', '\t\t\t} else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) {\n', '\t\t\t\tpayout = baseVerifierFee;\n', '\t\t\t}\n', '\n', '\t\t\tif (payout > 0) {\n', '\t\t\t\tfullyWithdrawn = true;\n', '\n', '\t\t    \tif (!makerBet.trustedVerifier.addr.send(payout)) {\n', '\t\t    \t\tmakerBet.trustedVerifierFeeSent = false;\n', '\t\t    \t\tfullyWithdrawn = false;\n', '\t\t    \t}\n', '\t    \t}\n', '\t    }\n', '\n', '\t    return fullyWithdrawn;\n', '\t}\n', '\n', '\t/// Settle a bet by trusted verifier\n', '\tfunction settleBet(uint makerBetId, address maker, uint outcome) external {\n', '\t\trequire(outcome == 1 || outcome == 2 || outcome == 3 || outcome == 4);\n', '\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(msg.sender == makerBet.trustedVerifier.addr);\n', '\n', '\t\trequire(makerBet.totalStake > 0);\n', '\n', '\t\trequire(makerBet.status != BetStatus.Settled);\n', '\n', '\t\tBetOutcome betOutcome = BetOutcome(outcome);\n', '\t\tmakerBet.outcome = betOutcome;\n', '\t\tmakerBet.status = BetStatus.Settled;\n', '\n', '\t\tpayMaker(makerBet);\n', '\t\tpayVerifier(makerBet);\n', '\n', '\t\temit LogSettleBet(makerBetId, maker);\n', '\t}\n', '\n', '\t/// Manual withdraw fund from a bet after outcome is set\n', '\tfunction withdraw(uint makerBetId, address maker) external {\n', '\t\tMakerBet storage makerBet = makerBets[makerBetId][maker];\n', '\t\trequire(makerBet.makerBetId != 0);\n', '\n', '\t\trequire(makerBet.outcome != BetOutcome.NotSettled);\n', '\n', '\t\trequire(makerBet.status == BetStatus.Settled);\n', '\n', '\t\tbool fullyWithdrawn = false;\n', '\n', '\t\tif (msg.sender == maker) {\n', '\t\t\tfullyWithdrawn = payMaker(makerBet);\n', '\t\t} else if (msg.sender == makerBet.trustedVerifier.addr) {\n', '\t\t\tfullyWithdrawn = payVerifier(makerBet);\n', '\t\t} else {\n', '\t\t\tfullyWithdrawn = payTaker(makerBet, msg.sender);\n', '\t\t}\n', '\n', '\t\tif (fullyWithdrawn) {\n', '\t\t\temit LogWithdraw(makerBetId, maker, msg.sender);\n', '\t\t}\n', '\t}\n', '\n', '    /* External views */\n', '    function getOwner() external view returns(address) {\n', '        return owner;\n', '    }\n', '\n', '    function isAdmin(address addr) external view returns(bool) {\n', '        return admins[addr];\n', '    }\n', '\n', '    function getVerifier(address addr) external view returns(address, uint) {\n', '    \tVerifier memory verifier = verifiers[addr];\n', '    \treturn (verifier.addr, verifier.feeRate);\n', '    }\n', '\n', '    function getMakerBetBasicInfo(uint makerBetId, address maker) external view returns(uint, address, address, uint, uint) {\n', '    \tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \treturn (makerBet.makerBetId, makerBet.maker, makerBet.trustedVerifier.addr, makerBet.trustedVerifier.feeRate, makerBet.expiry);\n', '    }\n', '\n', '    function getMakerBetDetails(uint makerBetId, address maker) external view returns(uint, BetStatus, uint, uint, uint, uint, uint, BetOutcome, bool, bool) {\n', '\t\tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \treturn (makerBet.makerBetId, makerBet.status, makerBet.odds, makerBet.totalFund, makerBet.reservedFund, makerBet.takerBetsCount, makerBet.totalStake, makerBet.outcome, makerBet.makerFundWithdrawn, makerBet.trustedVerifierFeeSent);\n', '    }\n', '\n', '    function getTakerBet(uint makerBetId, address maker, uint takerBetId, address taker) external view returns(uint, address, uint, uint, bool) {\n', '    \tMakerBet memory makerBet = makerBets[makerBetId][maker];\n', '    \tfor (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) {\n', '\t\t\tTakerBet memory takerBet = makerBet.takerBets[betIndex];\n', '\n', '\t\t\tif (takerBet.takerBetId == takerBetId && takerBet.taker == taker) {\n', '\t\t\t\treturn (takerBet.takerBetId, takerBet.taker, takerBet.odds, takerBet.stake, takerBet.settled);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\n', '\t/* Math utilities */\n', '\tfunction mul(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '\t    if (_a == 0) {\n', '\t      return 0;\n', '\t    }\n', '\n', '\t    c = _a * _b;\n', '\t    assert(c / _a == _b);\n', '\t    return c;\n', '  \t}\n', '\n', '  \tfunction sub(uint256 _a, uint256 _b) private pure returns(uint256) {\n', '    \tassert(_b <= _a);\n', '    \treturn _a - _b;\n', '  \t}\n', '\n', '  \tfunction add(uint256 _a, uint256 _b) private pure returns(uint256 c) {\n', '   \t\tc = _a + _b;\n', '    \tassert(c >= _a);\n', '    \treturn c;\n', '  \t}\n', '\n', '}']
