['pragma solidity ^0.4.13;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Fysical is StandardToken {\n', '    using SafeMath for uint256;\n', '\n', "    // To increase consistency and reduce the opportunity for human error, the '*sById' mappings, '*Count' values,\n", "    // 'get*ById' function declarations/implementations, and 'create*' function declarations/implementations have been\n", "    // programmatically-generated based on the each struct's name, member types/names, and the comments sharing a line\n", '    // with a member.\n', '    //\n', "    // This programmatic generation builds 'require' function calls based on the following rules:\n", "    //      - 'string' values must have length > 0\n", "    //      - 'bytes' and uint256[] values may have any length\n", "    //      - 'uint256' values representing a quantity must be > 0 (identifiers and Ethereum block numbers do not represent a quantity)\n", '    //\n', "    // The implementation of 'createProposal' contains one operation not found in the other programmatically-generated\n", "    // 'create*' functions, a call to 'transferTokensToEscrow'.\n", '    //\n', '    // None of the other members or functions have been programmatically generated.\n', '\n', '    // See https://en.wikipedia.org/wiki/Uniform_Resource_Identifier.\n', '    // The risk of preventing support for a future addition to the URI syntax outweighs the benefit of validating URI\n', '    // values within this immutable smart contract, so readers of Uri values should expect values that do not conform\n', '    // to the formal syntax of a URI.\n', '    struct Uri {\n', '        string value;\n', '    }\n', '\n', '    // A set of URIs may describe multiple methods to access a particular resource.\n', '    struct UriSet {\n', "        uint256[] uniqueUriIdsSortedAscending;    // each value must be key in 'urisById'\n", '    }\n', '\n', '    // See https://en.wikipedia.org/wiki/Checksum#Algorithms. The description of the algorithm referred to by each URI\n', "    // in the set should give a reader enough information to interpret the 'value' member of a 'Checksum' object\n", '    // referring to this algorithm object.\n', '    struct ChecksumAlgorithm {\n', "        uint256 descriptionUriSetId;    // must be key in 'uriSetsById'\n", '    }\n', '\n', "    // See https://en.wikipedia.org/wiki/Checksum. The 'resourceByteCount' indicates the number of bytes contained in\n", '    // the resource. Though this is not strictly part of most common Checksum algorithms, its validation may also be\n', "    // useful. The 'value' field should contain the expected output of passing the resource content to the checksum\n", '    // algorithm.\n', '    struct Checksum {\n', "        uint256 algorithmId; // must be key in 'checksumAlgorithmsById'\n", '        uint256 resourceByteCount;\n', '        bytes value;\n', '    }\n', '\n', '    // See https://en.wikipedia.org/wiki/Encryption. The description of the algorithm referred to by each URI\n', '    // in the set should give a reader enough information to access the content of an encrypted resource. The algorithm\n', '    // may be a symmetric encryption algorithm or an asymmetric encryption algorithm\n', '    struct EncryptionAlgorithm {\n', "        uint256 descriptionUriSetId;    // must be key in 'uriSetsById'\n", '    }\n', '\n', '    // For each resource, an Ethereum account may describe a checksum for the encrypted content of a resource and a\n', '    // checksum for the decrypted content of a resource. When the resource is encrypted with a null encryption\n', '    // algorithm, the resource is effectively unencrypted, so these two checksums should be identical\n', '    // (See https://en.wikipedia.org/wiki/Null_encryption).\n', '    struct ChecksumPair {\n', "        uint256 encryptedChecksumId; // must be key in 'checksumsById'\n", "        uint256 decryptedChecksumId; // must be key in 'checksumsById'\n", '    }\n', '\n', "    // A 'Resource' is content accessible with each URI referenced in the 'uriSetId'. This content should be\n", "    // encrypted with the algorithm described by the 'EncryptionAlgorithm' referenced in 'encryptionAlgorithmId'. Each\n", "    // resource referenced in 'metaResourceSetId' should describe the decrypted content in some way.\n", '    //\n', '    // For example, if the decrypted content conforms to a Protocol Buffers schema, the corresponding proto definition\n', '    // file should be included in the meta-resources. Likewise, that proto definition resource should refer to a\n', '    // resource like https://en.wikipedia.org/wiki/Protocol_Buffers among its meta-resources.\n', '    struct Resource {\n', "        uint256 uriSetId;                // must be key in 'uriSetsById'\n", "        uint256 encryptionAlgorithmId;   // must be key in 'encryptionAlgorithmsById'\n", "        uint256 metaResourceSetId;       // must be key in 'resourceSetsById'\n", '    }\n', '\n', '    // See https://en.wikipedia.org/wiki/Public-key_cryptography. This value should be the public key used in an\n', '    // asymmetric encryption operation. It should be useful for encrypting an resource destined for the holder of the\n', '    // corresponding private key or for decrypting a resource encrypted with the corresponding private key.\n', '    struct PublicKey {\n', '        bytes value;\n', '    }\n', '\n', "    // A 'ResourceSet' groups together resources that may be part of a trade proposal involving Fysical tokens. The\n", "    // creator of a 'ResourceSet' must include a public key for use in the encryption operations of creating and\n", '    // accepting a trade proposal. The creator must also specify the encryption algorithm a proposal creator should\n', "    // use along with this resource set creator's public key. Just as a single resource may have meta-resources\n", "    // describing the content of a resource, a 'ResourceSet' may have resources describing the whole resource set.\n", '    //\n', '    // Creators should be careful to not include so many resources that an Ethereum transaction to accept a proposal\n', '    // might run out of gas while storing the corresponding encrypted decryption keys.\n', '    //\n', '    // While developing reasonable filters for un-useful data in this collection, developers should choose a practical\n', '    // maximum depth of traversal through the meta-resources, since an infinite loop is possible.\n', '    struct ResourceSet {\n', '        address creator;\n', "        uint256 creatorPublicKeyId;                     // must be key in 'publicKeysById'\n", "        uint256 proposalEncryptionAlgorithmId;          // must be key in 'encryptionAlgorithmsById'\n", "        uint256[] uniqueResourceIdsSortedAscending;     // each value must be key in 'resourcesById'\n", "        uint256 metaResourceSetId;                      // must be key in 'resourceSetsById'\n", '    }\n', '\n', '    // The creator of a trade proposal may include arbitrary content to be considered part of the agreement the\n', '    // resource set is accepting. This may be useful for license agreements to be enforced within a jurisdiction\n', '    // governing the trade partners. The content available through each URI in the set should be encrypted first with\n', "    // the public key of a resource set's creator and then with the private key of a proposal's creator.\n", '    struct Agreement {\n', "        uint256 uriSetId;           // must be key in 'uriSetsById'\n", "        uint256 checksumPairId;     // must be key in 'checksumPairsById'\n", '    }\n', '\n', "    // Many agreements may be grouped together in an 'AgreementSet'\n", '    struct AgreementSet {\n', "        uint256[] uniqueAgreementIdsSortedAscending; // each value must be key in 'agreementsById'\n", '    }\n', '\n', "    // A 'TokenTransfer' describes a transfer of tokens to occur between two Ethereum accounts.\n", '    struct TokenTransfer {\n', '        address source;\n', '        address destination;\n', '        uint256 tokenCount;\n', '    }\n', '\n', '    // Many token transfers may be grouped together in a "TokenTransferSet\'\n', '    struct TokenTransferSet {\n', "        uint256[] uniqueTokenTransferIdsSortedAscending; // each value must be key in 'tokenTransfersById'\n", '    }\n', '\n', "    // A 'Proposal' describes the conditions for the atomic exchange of Fysical tokens and a keys to decrypt resources\n", '    // in a resource set. The creator must specify the asymmetric encryption algorithm for use when accepting the\n', "    // proposal, along with this creator's public key. The creator may specify arbitrary agreements that should be\n", '    // considered a condition of the trade.\n', '    //\n', "    // During the execution of 'createProposal', the count of tokens specified in each token transfer will be transfered\n", '    // from the specified source account to the account with the Ethereum address of 0. When the proposal state changes\n', '    // to a final state, these tokens will be returned to the source accounts or tranfserred to the destination account.\n', '    //\n', "    // By including a 'minimumBlockNumberForWithdrawal' value later than the current Ethereum block, the proposal\n", '    // creator can give the resource set creator a rough sense of how long the proposal will remain certainly\n', '    // acceptable. This is particularly useful because the execution of an Ethereum transaction to accept a proposal\n', '    // exposes the encrypted decryption keys to the Ethereum network regardless of whether the transaction succeeds.\n', '    // Within the time frame that a proposal acceptance transaction will certainly succeed, the resource creator need\n', '    // not be concerned with the possibility that an acceptance transaction might execute after a proposal withdrawal\n', '    // submitted to the Ethereum network at approximately the same time.\n', '    struct Proposal {\n', '        uint256 minimumBlockNumberForWithdrawal;\n', '        address creator;\n', "        uint256 creatorPublicKeyId;                 // must be key in 'publicKeysById'\n", "        uint256 acceptanceEncryptionAlgorithmId;    // must be key in 'encryptionAlgorithmsById'\n", "        uint256 resourceSetId;                      // must be key in 'resourceSetsById'\n", "        uint256 agreementSetId;                     // must be key in 'agreementSetsById'\n", "        uint256 tokenTransferSetId;                 // must be key in 'tokenTransferSetsById'\n", '    }\n', '\n', "    // When created, the proposal is in the 'Pending' state. All other states are final states, so a proposal may change\n", "    // state exactly one time based on a call to 'withdrawProposal', 'acceptProposal', or 'rejectProposal'.\n", '    enum ProposalState {\n', '        Pending,\n', '        WithdrawnByCreator,\n', '        RejectedByResourceSetCreator,\n', '        AcceptedByResourceSetCreator\n', '    }\n', '\n', '    // solium would warn "Constant name \'name\' doesn\'t follow the UPPER_CASE notation", but this public constant is\n', "    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\n", '    //\n', '    /* solium-disable-next-line */\n', '    string public constant name = "Fysical";\n', '\n', '    // solium would warn "Constant name \'symbol\' doesn\'t follow the UPPER_CASE notation", but this public constant is\n', "    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\n", '    //\n', '    /* solium-disable-next-line */\n', '    string public constant symbol = "FYS";\n', '\n', '    // solium would warn "Constant name \'decimals\' doesn\'t follow the UPPER_CASE notation", but this public constant is\n', "    // recommended by https://theethereum.wiki/w/index.php/ERC20_Token_Standard, so we'll disable warnings for the line.\n", '    //\n', '    /* solium-disable-next-line */\n', '    uint8 public constant decimals = 9;\n', '\n', '    uint256 public constant ONE_BILLION = 1000000000;\n', '    uint256 public constant ONE_QUINTILLION = 1000000000000000000;\n', '\n', '    // See https://en.wikipedia.org/wiki/9,223,372,036,854,775,807\n', '    uint256 public constant MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE = 9223372036854775807;\n', '\n', '    uint256 public constant EMPTY_PUBLIC_KEY_ID = 0;\n', '    uint256 public constant NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID = 0;\n', '    uint256 public constant NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID = 0;\n', '    uint256 public constant NULL_ENCRYPTION_ALGORITHM_ID = 0;\n', '    uint256 public constant EMPTY_RESOURCE_SET_ID = 0;\n', '\n', '    mapping(uint256 => Uri) internal urisById;\n', '    uint256 internal uriCount = 0;\n', '\n', '    mapping(uint256 => UriSet) internal uriSetsById;\n', '    uint256 internal uriSetCount = 0;\n', '\n', '    mapping(uint256 => ChecksumAlgorithm) internal checksumAlgorithmsById;\n', '    uint256 internal checksumAlgorithmCount = 0;\n', '\n', '    mapping(uint256 => Checksum) internal checksumsById;\n', '    uint256 internal checksumCount = 0;\n', '\n', '    mapping(uint256 => EncryptionAlgorithm) internal encryptionAlgorithmsById;\n', '    uint256 internal encryptionAlgorithmCount = 0;\n', '\n', '    mapping(uint256 => ChecksumPair) internal checksumPairsById;\n', '    uint256 internal checksumPairCount = 0;\n', '\n', '    mapping(uint256 => Resource) internal resourcesById;\n', '    uint256 internal resourceCount = 0;\n', '\n', '    mapping(uint256 => PublicKey) internal publicKeysById;\n', '    uint256 internal publicKeyCount = 0;\n', '\n', '    mapping(uint256 => ResourceSet) internal resourceSetsById;\n', '    uint256 internal resourceSetCount = 0;\n', '\n', '    mapping(uint256 => Agreement) internal agreementsById;\n', '    uint256 internal agreementCount = 0;\n', '\n', '    mapping(uint256 => AgreementSet) internal agreementSetsById;\n', '    uint256 internal agreementSetCount = 0;\n', '\n', '    mapping(uint256 => TokenTransfer) internal tokenTransfersById;\n', '    uint256 internal tokenTransferCount = 0;\n', '\n', '    mapping(uint256 => TokenTransferSet) internal tokenTransferSetsById;\n', '    uint256 internal tokenTransferSetCount = 0;\n', '\n', '    mapping(uint256 => Proposal) internal proposalsById;\n', '    uint256 internal proposalCount = 0;\n', '\n', '    mapping(uint256 => ProposalState) internal statesByProposalId;\n', '\n', '    mapping(uint256 => mapping(uint256 => bytes)) internal encryptedDecryptionKeysByProposalIdAndResourceId;\n', '\n', '    mapping(address => mapping(uint256 => bool)) internal checksumPairAssignmentsByCreatorAndResourceId;\n', '\n', '    mapping(address => mapping(uint256 => uint256)) internal checksumPairIdsByCreatorAndResourceId;\n', '\n', '    function Fysical() public {\n', '        assert(ProposalState(0) == ProposalState.Pending);\n', '\n', '        // The total number of Fysical tokens is intended to be one billion, with the ability to express values with\n', '        // nine decimals places of precision. The token values passed in ERC20 functions and operations involving\n', '        // TokenTransfer operations must be counts of nano-Fysical tokens (one billionth of one Fysical token).\n', '        //\n', '        // See the initialization of the total supply in https://theethereum.wiki/w/index.php/ERC20_Token_Standard.\n', '\n', '        assert(0 < ONE_BILLION);\n', '        assert(0 < ONE_QUINTILLION);\n', '        assert(MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE > ONE_BILLION);\n', '        assert(MAXIMUM_64_BIT_SIGNED_INTEGER_VALUE > ONE_QUINTILLION);\n', '        assert(ONE_BILLION == uint256(10)**decimals);\n', '        assert(ONE_QUINTILLION == ONE_BILLION.mul(ONE_BILLION));\n', '\n', '        totalSupply_ = ONE_QUINTILLION;\n', '\n', '        balances[msg.sender] = totalSupply_;\n', '\n', '        // From "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1" on 2018-02-08 (commit cea1db05a3444870132ec3cb7dd78a244cba1805):\n', '        //  "A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created."\n', '        Transfer(0x0, msg.sender, balances[msg.sender]);\n', '\n', "        // This mimics the behavior of the 'createPublicKey' external function.\n", '        assert(EMPTY_PUBLIC_KEY_ID == publicKeyCount);\n', '        publicKeysById[EMPTY_PUBLIC_KEY_ID] = PublicKey(new bytes(0));\n', '        publicKeyCount = publicKeyCount.add(1);\n', '        assert(1 == publicKeyCount);\n', '\n', "        // This mimics the behavior of the 'createUri' external function.\n", '        assert(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID == uriCount);\n', '        urisById[NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID] = Uri("https://en.wikipedia.org/wiki/Null_encryption");\n', '        uriCount = uriCount.add(1);\n', '        assert(1 == uriCount);\n', '\n', "        // This mimics the behavior of the 'createUriSet' external function.\n", '        assert(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID == uriSetCount);\n', '        uint256[] memory uniqueIdsSortedAscending = new uint256[](1);\n', '        uniqueIdsSortedAscending[0] = NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_ID;\n', '        validateIdSet(uniqueIdsSortedAscending, uriCount);\n', '        uriSetsById[NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID] = UriSet(uniqueIdsSortedAscending);\n', '        uriSetCount = uriSetCount.add(1);\n', '        assert(1 == uriSetCount);\n', '\n', "        // This mimics the behavior of the 'createEncryptionAlgorithm' external function.\n", '        assert(NULL_ENCRYPTION_ALGORITHM_ID == encryptionAlgorithmCount);\n', '        encryptionAlgorithmsById[NULL_ENCRYPTION_ALGORITHM_ID] = EncryptionAlgorithm(NULL_ENCRYPTION_ALGORITHM_DESCRIPTION_URI_SET_ID);\n', '        encryptionAlgorithmCount = encryptionAlgorithmCount.add(1);\n', '        assert(1 == encryptionAlgorithmCount);\n', '\n', "        // This mimics the behavior of the 'createResourceSet' external function, but allows for a self-reference in\n", "        // the assignment of the 'metaResourceSetId' member, which the function would prohibit.\n", '        assert(EMPTY_RESOURCE_SET_ID == resourceSetCount);\n', '        resourceSetsById[EMPTY_RESOURCE_SET_ID] = ResourceSet(\n', '            msg.sender,\n', '            EMPTY_PUBLIC_KEY_ID,\n', '            NULL_ENCRYPTION_ALGORITHM_ID,\n', '            new uint256[](0),\n', '            EMPTY_RESOURCE_SET_ID\n', '        );\n', '        resourceSetCount = resourceSetCount.add(1);\n', '        assert(1 == resourceSetCount);\n', '    }\n', '\n', '    function getUriCount() external view returns (uint256) {\n', '        return uriCount;\n', '    }\n', '\n', '    function getUriById(uint256 id) external view returns (string) {\n', '        require(id < uriCount);\n', '\n', '        Uri memory object = urisById[id];\n', '        return object.value;\n', '    }\n', '\n', '    function getUriSetCount() external view returns (uint256) {\n', '        return uriSetCount;\n', '    }\n', '\n', '    function getUriSetById(uint256 id) external view returns (uint256[]) {\n', '        require(id < uriSetCount);\n', '\n', '        UriSet memory object = uriSetsById[id];\n', '        return object.uniqueUriIdsSortedAscending;\n', '    }\n', '\n', '    function getChecksumAlgorithmCount() external view returns (uint256) {\n', '        return checksumAlgorithmCount;\n', '    }\n', '\n', '    function getChecksumAlgorithmById(uint256 id) external view returns (uint256) {\n', '        require(id < checksumAlgorithmCount);\n', '\n', '        ChecksumAlgorithm memory object = checksumAlgorithmsById[id];\n', '        return object.descriptionUriSetId;\n', '    }\n', '\n', '    function getChecksumCount() external view returns (uint256) {\n', '        return checksumCount;\n', '    }\n', '\n', '    function getChecksumById(uint256 id) external view returns (uint256, uint256, bytes) {\n', '        require(id < checksumCount);\n', '\n', '        Checksum memory object = checksumsById[id];\n', '        return (object.algorithmId, object.resourceByteCount, object.value);\n', '    }\n', '\n', '    function getEncryptionAlgorithmCount() external view returns (uint256) {\n', '        return encryptionAlgorithmCount;\n', '    }\n', '\n', '    function getEncryptionAlgorithmById(uint256 id) external view returns (uint256) {\n', '        require(id < encryptionAlgorithmCount);\n', '\n', '        EncryptionAlgorithm memory object = encryptionAlgorithmsById[id];\n', '        return object.descriptionUriSetId;\n', '    }\n', '\n', '    function getChecksumPairCount() external view returns (uint256) {\n', '        return checksumPairCount;\n', '    }\n', '\n', '    function getChecksumPairById(uint256 id) external view returns (uint256, uint256) {\n', '        require(id < checksumPairCount);\n', '\n', '        ChecksumPair memory object = checksumPairsById[id];\n', '        return (object.encryptedChecksumId, object.decryptedChecksumId);\n', '    }\n', '\n', '    function getResourceCount() external view returns (uint256) {\n', '        return resourceCount;\n', '    }\n', '\n', '    function getResourceById(uint256 id) external view returns (uint256, uint256, uint256) {\n', '        require(id < resourceCount);\n', '\n', '        Resource memory object = resourcesById[id];\n', '        return (object.uriSetId, object.encryptionAlgorithmId, object.metaResourceSetId);\n', '    }\n', '\n', '    function getPublicKeyCount() external view returns (uint256) {\n', '        return publicKeyCount;\n', '    }\n', '\n', '    function getPublicKeyById(uint256 id) external view returns (bytes) {\n', '        require(id < publicKeyCount);\n', '\n', '        PublicKey memory object = publicKeysById[id];\n', '        return object.value;\n', '    }\n', '\n', '    function getResourceSetCount() external view returns (uint256) {\n', '        return resourceSetCount;\n', '    }\n', '\n', '    function getResourceSetById(uint256 id) external view returns (address, uint256, uint256, uint256[], uint256) {\n', '        require(id < resourceSetCount);\n', '\n', '        ResourceSet memory object = resourceSetsById[id];\n', '        return (object.creator, object.creatorPublicKeyId, object.proposalEncryptionAlgorithmId, object.uniqueResourceIdsSortedAscending, object.metaResourceSetId);\n', '    }\n', '\n', '    function getAgreementCount() external view returns (uint256) {\n', '        return agreementCount;\n', '    }\n', '\n', '    function getAgreementById(uint256 id) external view returns (uint256, uint256) {\n', '        require(id < agreementCount);\n', '\n', '        Agreement memory object = agreementsById[id];\n', '        return (object.uriSetId, object.checksumPairId);\n', '    }\n', '\n', '    function getAgreementSetCount() external view returns (uint256) {\n', '        return agreementSetCount;\n', '    }\n', '\n', '    function getAgreementSetById(uint256 id) external view returns (uint256[]) {\n', '        require(id < agreementSetCount);\n', '\n', '        AgreementSet memory object = agreementSetsById[id];\n', '        return object.uniqueAgreementIdsSortedAscending;\n', '    }\n', '\n', '    function getTokenTransferCount() external view returns (uint256) {\n', '        return tokenTransferCount;\n', '    }\n', '\n', '    function getTokenTransferById(uint256 id) external view returns (address, address, uint256) {\n', '        require(id < tokenTransferCount);\n', '\n', '        TokenTransfer memory object = tokenTransfersById[id];\n', '        return (object.source, object.destination, object.tokenCount);\n', '    }\n', '\n', '    function getTokenTransferSetCount() external view returns (uint256) {\n', '        return tokenTransferSetCount;\n', '    }\n', '\n', '    function getTokenTransferSetById(uint256 id) external view returns (uint256[]) {\n', '        require(id < tokenTransferSetCount);\n', '\n', '        TokenTransferSet memory object = tokenTransferSetsById[id];\n', '        return object.uniqueTokenTransferIdsSortedAscending;\n', '    }\n', '\n', '    function getProposalCount() external view returns (uint256) {\n', '        return proposalCount;\n', '    }\n', '\n', '    function getProposalById(uint256 id) external view returns (uint256, address, uint256, uint256, uint256, uint256, uint256) {\n', '        require(id < proposalCount);\n', '\n', '        Proposal memory object = proposalsById[id];\n', '        return (object.minimumBlockNumberForWithdrawal, object.creator, object.creatorPublicKeyId, object.acceptanceEncryptionAlgorithmId, object.resourceSetId, object.agreementSetId, object.tokenTransferSetId);\n', '    }\n', '\n', '    function getStateByProposalId(uint256 proposalId) external view returns (ProposalState) {\n', '        require(proposalId < proposalCount);\n', '\n', '        return statesByProposalId[proposalId];\n', '    }\n', '\n', '    // Check to see if an Ethereum account has assigned a checksum for a particular resource.\n', '    function hasAddressAssignedResourceChecksumPair(address address_, uint256 resourceId) external view returns (bool) {\n', '        require(resourceId < resourceCount);\n', '\n', '        return checksumPairAssignmentsByCreatorAndResourceId[address_][resourceId];\n', '    }\n', '\n', '    // Retrieve the checksum assigned assigned to particular resource\n', '    function getChecksumPairIdByAssignerAndResourceId(address assigner, uint256 resourceId) external view returns (uint256) {\n', '        require(resourceId < resourceCount);\n', '        require(checksumPairAssignmentsByCreatorAndResourceId[assigner][resourceId]);\n', '\n', '        return checksumPairIdsByCreatorAndResourceId[assigner][resourceId];\n', '    }\n', '\n', '    // Retrieve the encrypted key to decrypt a resource referenced by an accepted proposal.\n', '    function getEncryptedResourceDecryptionKey(uint256 proposalId, uint256 resourceId) external view returns (bytes) {\n', '        require(proposalId < proposalCount);\n', '        require(ProposalState.AcceptedByResourceSetCreator == statesByProposalId[proposalId]);\n', '        require(resourceId < resourceCount);\n', '\n', '        uint256[] memory validResourceIds = resourceSetsById[proposalsById[proposalId].resourceSetId].uniqueResourceIdsSortedAscending;\n', '        require(0 < validResourceIds.length);\n', '\n', '        if (1 == validResourceIds.length) {\n', '            require(resourceId == validResourceIds[0]);\n', '\n', '        } else {\n', '            uint256 lowIndex = 0;\n', '            uint256 highIndex = validResourceIds.length.sub(1);\n', '            uint256 middleIndex = lowIndex.add(highIndex).div(2);\n', '\n', '            while (resourceId != validResourceIds[middleIndex]) {\n', '                require(lowIndex <= highIndex);\n', '\n', '                if (validResourceIds[middleIndex] < resourceId) {\n', '                    lowIndex = middleIndex.add(1);\n', '                } else {\n', '                    highIndex = middleIndex.sub(1);\n', '                }\n', '\n', '                middleIndex = lowIndex.add(highIndex).div(2);\n', '            }\n', '        }\n', '\n', '        return encryptedDecryptionKeysByProposalIdAndResourceId[proposalId][resourceId];\n', '    }\n', '\n', '    function createUri(\n', '        string value\n', '    ) external returns (uint256)\n', '    {\n', '        require(0 < bytes(value).length);\n', '\n', '        uint256 id = uriCount;\n', '        uriCount = id.add(1);\n', '        urisById[id] = Uri(\n', '            value\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createUriSet(\n', '        uint256[] uniqueUriIdsSortedAscending\n', '    ) external returns (uint256)\n', '    {\n', '        validateIdSet(uniqueUriIdsSortedAscending, uriCount);\n', '\n', '        uint256 id = uriSetCount;\n', '        uriSetCount = id.add(1);\n', '        uriSetsById[id] = UriSet(\n', '            uniqueUriIdsSortedAscending\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createChecksumAlgorithm(\n', '        uint256 descriptionUriSetId\n', '    ) external returns (uint256)\n', '    {\n', '        require(descriptionUriSetId < uriSetCount);\n', '\n', '        uint256 id = checksumAlgorithmCount;\n', '        checksumAlgorithmCount = id.add(1);\n', '        checksumAlgorithmsById[id] = ChecksumAlgorithm(\n', '            descriptionUriSetId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createChecksum(\n', '        uint256 algorithmId,\n', '        uint256 resourceByteCount,\n', '        bytes value\n', '    ) external returns (uint256)\n', '    {\n', '        require(algorithmId < checksumAlgorithmCount);\n', '        require(0 < resourceByteCount);\n', '\n', '        uint256 id = checksumCount;\n', '        checksumCount = id.add(1);\n', '        checksumsById[id] = Checksum(\n', '            algorithmId,\n', '            resourceByteCount,\n', '            value\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createEncryptionAlgorithm(\n', '        uint256 descriptionUriSetId\n', '    ) external returns (uint256)\n', '    {\n', '        require(descriptionUriSetId < uriSetCount);\n', '\n', '        uint256 id = encryptionAlgorithmCount;\n', '        encryptionAlgorithmCount = id.add(1);\n', '        encryptionAlgorithmsById[id] = EncryptionAlgorithm(\n', '            descriptionUriSetId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createChecksumPair(\n', '        uint256 encryptedChecksumId,\n', '        uint256 decryptedChecksumId\n', '    ) external returns (uint256)\n', '    {\n', '        require(encryptedChecksumId < checksumCount);\n', '        require(decryptedChecksumId < checksumCount);\n', '\n', '        uint256 id = checksumPairCount;\n', '        checksumPairCount = id.add(1);\n', '        checksumPairsById[id] = ChecksumPair(\n', '            encryptedChecksumId,\n', '            decryptedChecksumId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createResource(\n', '        uint256 uriSetId,\n', '        uint256 encryptionAlgorithmId,\n', '        uint256 metaResourceSetId\n', '    ) external returns (uint256)\n', '    {\n', '        require(uriSetId < uriSetCount);\n', '        require(encryptionAlgorithmId < encryptionAlgorithmCount);\n', '        require(metaResourceSetId < resourceSetCount);\n', '\n', '        uint256 id = resourceCount;\n', '        resourceCount = id.add(1);\n', '        resourcesById[id] = Resource(\n', '            uriSetId,\n', '            encryptionAlgorithmId,\n', '            metaResourceSetId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createPublicKey(\n', '        bytes value\n', '    ) external returns (uint256)\n', '    {\n', '        uint256 id = publicKeyCount;\n', '        publicKeyCount = id.add(1);\n', '        publicKeysById[id] = PublicKey(\n', '            value\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createResourceSet(\n', '        uint256 creatorPublicKeyId,\n', '        uint256 proposalEncryptionAlgorithmId,\n', '        uint256[] uniqueResourceIdsSortedAscending,\n', '        uint256 metaResourceSetId\n', '    ) external returns (uint256)\n', '    {\n', '        require(creatorPublicKeyId < publicKeyCount);\n', '        require(proposalEncryptionAlgorithmId < encryptionAlgorithmCount);\n', '        validateIdSet(uniqueResourceIdsSortedAscending, resourceCount);\n', '        require(metaResourceSetId < resourceSetCount);\n', '\n', '        uint256 id = resourceSetCount;\n', '        resourceSetCount = id.add(1);\n', '        resourceSetsById[id] = ResourceSet(\n', '            msg.sender,\n', '            creatorPublicKeyId,\n', '            proposalEncryptionAlgorithmId,\n', '            uniqueResourceIdsSortedAscending,\n', '            metaResourceSetId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createAgreement(\n', '        uint256 uriSetId,\n', '        uint256 checksumPairId\n', '    ) external returns (uint256)\n', '    {\n', '        require(uriSetId < uriSetCount);\n', '        require(checksumPairId < checksumPairCount);\n', '\n', '        uint256 id = agreementCount;\n', '        agreementCount = id.add(1);\n', '        agreementsById[id] = Agreement(\n', '            uriSetId,\n', '            checksumPairId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createAgreementSet(\n', '        uint256[] uniqueAgreementIdsSortedAscending\n', '    ) external returns (uint256)\n', '    {\n', '        validateIdSet(uniqueAgreementIdsSortedAscending, agreementCount);\n', '\n', '        uint256 id = agreementSetCount;\n', '        agreementSetCount = id.add(1);\n', '        agreementSetsById[id] = AgreementSet(\n', '            uniqueAgreementIdsSortedAscending\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createTokenTransfer(\n', '        address source,\n', '        address destination,\n', '        uint256 tokenCount\n', '    ) external returns (uint256)\n', '    {\n', '        require(address(0) != source);\n', '        require(address(0) != destination);\n', '        require(0 < tokenCount);\n', '\n', '        uint256 id = tokenTransferCount;\n', '        tokenTransferCount = id.add(1);\n', '        tokenTransfersById[id] = TokenTransfer(\n', '            source,\n', '            destination,\n', '            tokenCount\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createTokenTransferSet(\n', '        uint256[] uniqueTokenTransferIdsSortedAscending\n', '    ) external returns (uint256)\n', '    {\n', '        validateIdSet(uniqueTokenTransferIdsSortedAscending, tokenTransferCount);\n', '\n', '        uint256 id = tokenTransferSetCount;\n', '        tokenTransferSetCount = id.add(1);\n', '        tokenTransferSetsById[id] = TokenTransferSet(\n', '            uniqueTokenTransferIdsSortedAscending\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', '    function createProposal(\n', '        uint256 minimumBlockNumberForWithdrawal,\n', '        uint256 creatorPublicKeyId,\n', '        uint256 acceptanceEncryptionAlgorithmId,\n', '        uint256 resourceSetId,\n', '        uint256 agreementSetId,\n', '        uint256 tokenTransferSetId\n', '    ) external returns (uint256)\n', '    {\n', '        require(creatorPublicKeyId < publicKeyCount);\n', '        require(acceptanceEncryptionAlgorithmId < encryptionAlgorithmCount);\n', '        require(resourceSetId < resourceSetCount);\n', '        require(agreementSetId < agreementSetCount);\n', '        require(tokenTransferSetId < tokenTransferSetCount);\n', '\n', '        transferTokensToEscrow(msg.sender, tokenTransferSetId);\n', '\n', '        uint256 id = proposalCount;\n', '        proposalCount = id.add(1);\n', '        proposalsById[id] = Proposal(\n', '            minimumBlockNumberForWithdrawal,\n', '            msg.sender,\n', '            creatorPublicKeyId,\n', '            acceptanceEncryptionAlgorithmId,\n', '            resourceSetId,\n', '            agreementSetId,\n', '            tokenTransferSetId\n', '        );\n', '\n', '        return id;\n', '    }\n', '\n', "    // Each Ethereum account may assign a 'ChecksumPair' to a resource exactly once. This ensures that each claim that a\n", '    // checksum should match a resource is attached to a particular authority. This operation is not bound to the\n', "    // creation of the resource because the resource's creator may not know the checksum when creating the resource.\n", '    function assignResourceChecksumPair(\n', '        uint256 resourceId,\n', '        uint256 checksumPairId\n', '    ) external\n', '    {\n', '        require(resourceId < resourceCount);\n', '        require(checksumPairId < checksumPairCount);\n', '        require(false == checksumPairAssignmentsByCreatorAndResourceId[msg.sender][resourceId]);\n', '\n', '        checksumPairIdsByCreatorAndResourceId[msg.sender][resourceId] = checksumPairId;\n', '        checksumPairAssignmentsByCreatorAndResourceId[msg.sender][resourceId] = true;\n', '    }\n', '\n', "    // This function moves a proposal to a final state of `WithdrawnByCreator' and returns tokens to the sources\n", "    // described by the proposal's transfers.\n", '    function withdrawProposal(\n', '        uint256 proposalId\n', '    ) external\n', '    {\n', '        require(proposalId < proposalCount);\n', '        require(ProposalState.Pending == statesByProposalId[proposalId]);\n', '\n', '        Proposal memory proposal = proposalsById[proposalId];\n', '        require(msg.sender == proposal.creator);\n', '        require(block.number >= proposal.minimumBlockNumberForWithdrawal);\n', '\n', '        returnTokensFromEscrow(proposal.creator, proposal.tokenTransferSetId);\n', '        statesByProposalId[proposalId] = ProposalState.WithdrawnByCreator;\n', '    }\n', '\n', "    // This function moves a proposal to a final state of `RejectedByResourceSetCreator' and returns tokens to the sources\n", "    // described by the proposal's transfers.\n", '    function rejectProposal(\n', '        uint256 proposalId\n', '    ) external\n', '    {\n', '        require(proposalId < proposalCount);\n', '        require(ProposalState.Pending == statesByProposalId[proposalId]);\n', '\n', '        Proposal memory proposal = proposalsById[proposalId];\n', '        require(msg.sender == resourceSetsById[proposal.resourceSetId].creator);\n', '\n', '        returnTokensFromEscrow(proposal.creator, proposal.tokenTransferSetId);\n', '        statesByProposalId[proposalId] = ProposalState.RejectedByResourceSetCreator;\n', '    }\n', '\n', "    // This function moves a proposal to a final state of `RejectedByResourceSetCreator' and sends tokens to the\n", "    // destinations described by the proposal's transfers.\n", '    //\n', '    // The caller should encrypt each decryption key corresponding\n', "    // to each resource in the proposal's resource set first with the public key of the proposal's creator and then with\n", '    // the private key assoicated with the public key referenced in the resource set. The caller should concatenate\n', "    // these encrypted values and pass the resulting byte array as 'concatenatedResourceDecryptionKeys'.\n", "    // The length of each encrypted decryption key should be provided in the 'concatenatedResourceDecryptionKeyLengths'.\n", "    // The index of each value in 'concatenatedResourceDecryptionKeyLengths' must correspond to an index in the resource\n", '    // set referenced by the proposal.\n', '    function acceptProposal(\n', '        uint256 proposalId,\n', '        bytes concatenatedResourceDecryptionKeys,\n', '        uint256[] concatenatedResourceDecryptionKeyLengths\n', '    ) external\n', '    {\n', '        require(proposalId < proposalCount);\n', '        require(ProposalState.Pending == statesByProposalId[proposalId]);\n', '\n', '        Proposal memory proposal = proposalsById[proposalId];\n', '        require(msg.sender == resourceSetsById[proposal.resourceSetId].creator);\n', '\n', '        storeEncryptedDecryptionKeys(\n', '            proposalId,\n', '            concatenatedResourceDecryptionKeys,\n', '            concatenatedResourceDecryptionKeyLengths\n', '        );\n', '\n', '        transferTokensFromEscrow(proposal.tokenTransferSetId);\n', '\n', '        statesByProposalId[proposalId] = ProposalState.AcceptedByResourceSetCreator;\n', '    }\n', '\n', '    function validateIdSet(uint256[] uniqueIdsSortedAscending, uint256 idCount) private pure {\n', '        if (0 < uniqueIdsSortedAscending.length) {\n', '\n', '            uint256 id = uniqueIdsSortedAscending[0];\n', '            require(id < idCount);\n', '\n', '            uint256 previousId = id;\n', '            for (uint256 index = 1; index < uniqueIdsSortedAscending.length; index = index.add(1)) {\n', '                id = uniqueIdsSortedAscending[index];\n', '                require(id < idCount);\n', '                require(previousId < id);\n', '\n', '                previousId = id;\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferTokensToEscrow(address proposalCreator, uint256 tokenTransferSetId) private {\n', '        assert(tokenTransferSetId < tokenTransferSetCount);\n', '        assert(address(0) != proposalCreator);\n', '\n', '        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\n', '        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\n', '            uint256 tokenTransferId = tokenTransferIds[index];\n', '            assert(tokenTransferId < tokenTransferCount);\n', '\n', '            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\n', '            assert(0 < tokenTransfer.tokenCount);\n', '            assert(address(0) != tokenTransfer.source);\n', '            assert(address(0) != tokenTransfer.destination);\n', '\n', '            require(tokenTransfer.tokenCount <= balances[tokenTransfer.source]);\n', '\n', '            if (tokenTransfer.source != proposalCreator) {\n', '                require(tokenTransfer.tokenCount <= allowed[tokenTransfer.source][proposalCreator]);\n', '\n', '                allowed[tokenTransfer.source][proposalCreator] = allowed[tokenTransfer.source][proposalCreator].sub(tokenTransfer.tokenCount);\n', '            }\n', '\n', '            balances[tokenTransfer.source] = balances[tokenTransfer.source].sub(tokenTransfer.tokenCount);\n', '            balances[address(0)] = balances[address(0)].add(tokenTransfer.tokenCount);\n', '\n', '            Transfer(tokenTransfer.source, address(0), tokenTransfer.tokenCount);\n', '        }\n', '    }\n', '\n', '    function returnTokensFromEscrow(address proposalCreator, uint256 tokenTransferSetId) private {\n', '        assert(tokenTransferSetId < tokenTransferSetCount);\n', '        assert(address(0) != proposalCreator);\n', '\n', '        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\n', '        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\n', '            uint256 tokenTransferId = tokenTransferIds[index];\n', '            assert(tokenTransferId < tokenTransferCount);\n', '\n', '            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\n', '            assert(0 < tokenTransfer.tokenCount);\n', '            assert(address(0) != tokenTransfer.source);\n', '            assert(address(0) != tokenTransfer.destination);\n', '            assert(tokenTransfer.tokenCount <= balances[address(0)]);\n', '\n', '            balances[tokenTransfer.source] = balances[tokenTransfer.source].add(tokenTransfer.tokenCount);\n', '            balances[address(0)] = balances[address(0)].sub(tokenTransfer.tokenCount);\n', '\n', '            Transfer(address(0), tokenTransfer.source, tokenTransfer.tokenCount);\n', '        }\n', '    }\n', '\n', '    function transferTokensFromEscrow(uint256 tokenTransferSetId) private {\n', '        assert(tokenTransferSetId < tokenTransferSetCount);\n', '\n', '        uint256[] memory tokenTransferIds = tokenTransferSetsById[tokenTransferSetId].uniqueTokenTransferIdsSortedAscending;\n', '        for (uint256 index = 0; index < tokenTransferIds.length; index = index.add(1)) {\n', '            uint256 tokenTransferId = tokenTransferIds[index];\n', '            assert(tokenTransferId < tokenTransferCount);\n', '\n', '            TokenTransfer memory tokenTransfer = tokenTransfersById[tokenTransferId];\n', '            assert(0 < tokenTransfer.tokenCount);\n', '            assert(address(0) != tokenTransfer.source);\n', '            assert(address(0) != tokenTransfer.destination);\n', '\n', '            balances[address(0)] = balances[address(0)].sub(tokenTransfer.tokenCount);\n', '            balances[tokenTransfer.destination] = balances[tokenTransfer.destination].add(tokenTransfer.tokenCount);\n', '            Transfer(address(0), tokenTransfer.destination, tokenTransfer.tokenCount);\n', '        }\n', '    }\n', '\n', '    function storeEncryptedDecryptionKeys(\n', '        uint256 proposalId,\n', '        bytes concatenatedEncryptedResourceDecryptionKeys,\n', '        uint256[] encryptedResourceDecryptionKeyLengths\n', '    ) private\n', '    {\n', '        assert(proposalId < proposalCount);\n', '\n', '        uint256 resourceSetId = proposalsById[proposalId].resourceSetId;\n', '        assert(resourceSetId < resourceSetCount);\n', '\n', '        ResourceSet memory resourceSet = resourceSetsById[resourceSetId];\n', '        require(resourceSet.uniqueResourceIdsSortedAscending.length == encryptedResourceDecryptionKeyLengths.length);\n', '\n', '        uint256 concatenatedEncryptedResourceDecryptionKeysIndex = 0;\n', '        for (uint256 resourceIndex = 0; resourceIndex < encryptedResourceDecryptionKeyLengths.length; resourceIndex = resourceIndex.add(1)) {\n', '            bytes memory encryptedResourceDecryptionKey = new bytes(encryptedResourceDecryptionKeyLengths[resourceIndex]);\n', '            require(0 < encryptedResourceDecryptionKey.length);\n', '\n', '            for (uint256 encryptedResourceDecryptionKeyIndex = 0; encryptedResourceDecryptionKeyIndex < encryptedResourceDecryptionKey.length; encryptedResourceDecryptionKeyIndex = encryptedResourceDecryptionKeyIndex.add(1)) {\n', '                require(concatenatedEncryptedResourceDecryptionKeysIndex < concatenatedEncryptedResourceDecryptionKeys.length);\n', '                encryptedResourceDecryptionKey[encryptedResourceDecryptionKeyIndex] = concatenatedEncryptedResourceDecryptionKeys[concatenatedEncryptedResourceDecryptionKeysIndex];\n', '                concatenatedEncryptedResourceDecryptionKeysIndex = concatenatedEncryptedResourceDecryptionKeysIndex.add(1);\n', '            }\n', '\n', '            uint256 resourceId = resourceSet.uniqueResourceIdsSortedAscending[resourceIndex];\n', '            assert(resourceId < resourceCount);\n', '\n', '            encryptedDecryptionKeysByProposalIdAndResourceId[proposalId][resourceId] = encryptedResourceDecryptionKey;\n', '        }\n', '\n', '        require(concatenatedEncryptedResourceDecryptionKeysIndex == concatenatedEncryptedResourceDecryptionKeys.length);\n', '    }\n', '}']