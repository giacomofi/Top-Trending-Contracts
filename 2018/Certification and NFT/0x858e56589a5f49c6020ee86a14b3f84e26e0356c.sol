['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract Functions {\n', '\n', '    bytes32[] public randomHashes;\n', '\n', '    function fillWithHashes() public {\n', '        require(randomHashes.length == 0);\n', '\n', '        for (uint i = block.number - 100; i < block.number; i++) {\n', '            randomHashes.push(blockhash(i));\n', '        }\n', '    }\n', '\n', '    /// @notice Function to calculate initial random seed based on our hashes\n', '    /// @param _randomHashIds are ids in our array of hashes\n', '    /// @param _timestamp is timestamp for that hash\n', '    /// @return uint representation of random seed\n', '    function calculateSeed(uint[] _randomHashIds, uint _timestamp) public view returns (uint) {\n', '        require(_timestamp != 0);\n', '        require(_randomHashIds.length == 10);\n', '\n', '        bytes32 randomSeed = keccak256(\n', '            abi.encodePacked(\n', '            randomHashes[_randomHashIds[0]], randomHashes[_randomHashIds[1]],\n', '            randomHashes[_randomHashIds[2]], randomHashes[_randomHashIds[3]],\n', '            randomHashes[_randomHashIds[4]], randomHashes[_randomHashIds[5]],\n', '            randomHashes[_randomHashIds[6]], randomHashes[_randomHashIds[7]],\n', '            randomHashes[_randomHashIds[8]], randomHashes[_randomHashIds[9]],\n', '            _timestamp\n', '            )\n', '        );\n', '\n', '        return uint(randomSeed);\n', '    }\n', '\n', '    function getRandomHashesLength() public view returns(uint) {\n', '        return randomHashes.length;\n', '    }\n', '\n', '    /// @notice Function which decodes bytes32 to array of integers\n', '    /// @param _potentialAssets are potential assets user would like to have\n', '    /// @return array of assetIds\n', '    function decodeAssets(bytes32[] _potentialAssets) public pure returns (uint[] assets) {\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetsCopy = new uint[](_potentialAssets.length*10);\n', '        uint numberOfAssets = 0;\n', '\n', '        for (uint j = 0; j < _potentialAssets.length; j++) {\n', '            uint input;\n', '            bytes32 pot = _potentialAssets[j];\n', '\n', '            assembly {\n', '                input := pot\n', '            }\n', '\n', '            for (uint i = 10; i > 0; i--) {\n', '                uint mask = (2 << ((i-1) * 24)) / 2;\n', '                uint b = (input & (mask * 16777215)) / mask;\n', '\n', '                if (b != 0) {\n', '                    assetsCopy[numberOfAssets] = b;\n', '                    numberOfAssets++;\n', '                }\n', '            }\n', '        }\n', '\n', '        assets = new uint[](numberOfAssets);\n', '        for (i = 0; i < numberOfAssets; i++) {\n', '            assets[i] = assetsCopy[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random assets from potentialAssets array\n', '    /// @param _finalSeed is final random seed\n', '    /// @param _potentialAssets is bytes32[] array of potential assets\n', '    /// @return uint[] array of randomly picked assets\n', '    function pickRandomAssets(uint _finalSeed, bytes32[] _potentialAssets) public pure returns(uint[] finalPicked) {\n', '        require(_finalSeed != 0);\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetIds = decodeAssets(_potentialAssets);\n', '        uint[] memory pickedIds = new uint[](assetIds.length);\n', '\n', '        uint finalSeedCopy = _finalSeed;\n', '        uint index = 0;\n', '\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\n', '            if (finalSeedCopy % 2 == 0) {\n', '                pickedIds[index] = assetIds[i];\n', '                index++;\n', '            }\n', '        }\n', '\n', '        finalPicked = new uint[](index);\n', '        for (i = 0; i < index; i++) {\n', '            finalPicked[i] = pickedIds[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random assets from potentialAssets array\n', '    /// @param _finalSeed is final random seed\n', '    /// @param _potentialAssets is bytes32[] array of potential assets\n', '    /// @param _width of canvas\n', '    /// @param _height of canvas\n', '    /// @return arrays of randomly picked assets defining ids, coordinates, zoom, rotation and layers\n', '    function getImage(uint _finalSeed, bytes32[] _potentialAssets, uint _width, uint _height) public pure \n', '    returns(uint[] finalPicked, uint[] x, uint[] y, uint[] zoom, uint[] rotation, uint[] layers) {\n', '        require(_finalSeed != 0);\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetIds = decodeAssets(_potentialAssets);\n', '        uint[] memory pickedIds = new uint[](assetIds.length);\n', '        x = new uint[](assetIds.length);\n', '        y = new uint[](assetIds.length);\n', '        zoom = new uint[](assetIds.length);\n', '        rotation = new uint[](assetIds.length);\n', '        layers = new uint[](assetIds.length);\n', '\n', '        uint finalSeedCopy = _finalSeed;\n', '        uint index = 0;\n', '\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\n', '            if (finalSeedCopy % 2 == 0) {\n', '                pickedIds[index] = assetIds[i];\n', '                (x[index], y[index], zoom[index], rotation[index], layers[index]) = pickRandomAssetPosition(finalSeedCopy, _width, _height);\n', '                index++;\n', '            }\n', '        }\n', '\n', '        finalPicked = new uint[](index);\n', '        for (i = 0; i < index; i++) {\n', '            finalPicked[i] = pickedIds[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random position for an asset\n', '    /// @param _randomSeed is random seed for that image\n', '    /// @param _width of canvas\n', '    /// @param _height of canvas\n', '    /// @return tuple of uints representing x,y,zoom,and rotation\n', '    function pickRandomAssetPosition(uint _randomSeed, uint _width, uint _height) public pure \n', '    returns (uint x, uint y, uint zoom, uint rotation, uint layer) {\n', '        \n', '        x = _randomSeed % _width;\n', '        y = _randomSeed % _height;\n', '        zoom = _randomSeed % 200 + 800;\n', '        rotation = _randomSeed % 360;\n', '        // using random number for now\n', '        // if two layers are same, sort by (keccak256(layer, assetId))\n', '        layer = _randomSeed % 1234567; \n', '    }\n', '\n', '    /// @notice Function to calculate final random seed for user\n', '    /// @param _randomSeed is initially given random seed\n', '    /// @param _iterations is number of iterations\n', '    /// @return final seed for user as uint\n', '    function getFinalSeed(uint _randomSeed, uint _iterations) public pure returns (bytes32) {\n', '        require(_randomSeed != 0);\n', '        require(_iterations != 0);\n', '        bytes32 finalSeed = bytes32(_randomSeed);\n', '\n', '        finalSeed = keccak256(abi.encodePacked(_randomSeed, _iterations));\n', '        for (uint i = 0; i < _iterations; i++) {\n', '            finalSeed = keccak256(abi.encodePacked(finalSeed, i));\n', '        }\n', '\n', '        return finalSeed;\n', '    }\n', '\n', '    function toHex(uint _randomSeed) public pure returns (bytes32) {\n', '        return bytes32(_randomSeed);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', 'contract Functions {\n', '\n', '    bytes32[] public randomHashes;\n', '\n', '    function fillWithHashes() public {\n', '        require(randomHashes.length == 0);\n', '\n', '        for (uint i = block.number - 100; i < block.number; i++) {\n', '            randomHashes.push(blockhash(i));\n', '        }\n', '    }\n', '\n', '    /// @notice Function to calculate initial random seed based on our hashes\n', '    /// @param _randomHashIds are ids in our array of hashes\n', '    /// @param _timestamp is timestamp for that hash\n', '    /// @return uint representation of random seed\n', '    function calculateSeed(uint[] _randomHashIds, uint _timestamp) public view returns (uint) {\n', '        require(_timestamp != 0);\n', '        require(_randomHashIds.length == 10);\n', '\n', '        bytes32 randomSeed = keccak256(\n', '            abi.encodePacked(\n', '            randomHashes[_randomHashIds[0]], randomHashes[_randomHashIds[1]],\n', '            randomHashes[_randomHashIds[2]], randomHashes[_randomHashIds[3]],\n', '            randomHashes[_randomHashIds[4]], randomHashes[_randomHashIds[5]],\n', '            randomHashes[_randomHashIds[6]], randomHashes[_randomHashIds[7]],\n', '            randomHashes[_randomHashIds[8]], randomHashes[_randomHashIds[9]],\n', '            _timestamp\n', '            )\n', '        );\n', '\n', '        return uint(randomSeed);\n', '    }\n', '\n', '    function getRandomHashesLength() public view returns(uint) {\n', '        return randomHashes.length;\n', '    }\n', '\n', '    /// @notice Function which decodes bytes32 to array of integers\n', '    /// @param _potentialAssets are potential assets user would like to have\n', '    /// @return array of assetIds\n', '    function decodeAssets(bytes32[] _potentialAssets) public pure returns (uint[] assets) {\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetsCopy = new uint[](_potentialAssets.length*10);\n', '        uint numberOfAssets = 0;\n', '\n', '        for (uint j = 0; j < _potentialAssets.length; j++) {\n', '            uint input;\n', '            bytes32 pot = _potentialAssets[j];\n', '\n', '            assembly {\n', '                input := pot\n', '            }\n', '\n', '            for (uint i = 10; i > 0; i--) {\n', '                uint mask = (2 << ((i-1) * 24)) / 2;\n', '                uint b = (input & (mask * 16777215)) / mask;\n', '\n', '                if (b != 0) {\n', '                    assetsCopy[numberOfAssets] = b;\n', '                    numberOfAssets++;\n', '                }\n', '            }\n', '        }\n', '\n', '        assets = new uint[](numberOfAssets);\n', '        for (i = 0; i < numberOfAssets; i++) {\n', '            assets[i] = assetsCopy[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random assets from potentialAssets array\n', '    /// @param _finalSeed is final random seed\n', '    /// @param _potentialAssets is bytes32[] array of potential assets\n', '    /// @return uint[] array of randomly picked assets\n', '    function pickRandomAssets(uint _finalSeed, bytes32[] _potentialAssets) public pure returns(uint[] finalPicked) {\n', '        require(_finalSeed != 0);\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetIds = decodeAssets(_potentialAssets);\n', '        uint[] memory pickedIds = new uint[](assetIds.length);\n', '\n', '        uint finalSeedCopy = _finalSeed;\n', '        uint index = 0;\n', '\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\n', '            if (finalSeedCopy % 2 == 0) {\n', '                pickedIds[index] = assetIds[i];\n', '                index++;\n', '            }\n', '        }\n', '\n', '        finalPicked = new uint[](index);\n', '        for (i = 0; i < index; i++) {\n', '            finalPicked[i] = pickedIds[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random assets from potentialAssets array\n', '    /// @param _finalSeed is final random seed\n', '    /// @param _potentialAssets is bytes32[] array of potential assets\n', '    /// @param _width of canvas\n', '    /// @param _height of canvas\n', '    /// @return arrays of randomly picked assets defining ids, coordinates, zoom, rotation and layers\n', '    function getImage(uint _finalSeed, bytes32[] _potentialAssets, uint _width, uint _height) public pure \n', '    returns(uint[] finalPicked, uint[] x, uint[] y, uint[] zoom, uint[] rotation, uint[] layers) {\n', '        require(_finalSeed != 0);\n', '        require(_potentialAssets.length > 0);\n', '\n', '        uint[] memory assetIds = decodeAssets(_potentialAssets);\n', '        uint[] memory pickedIds = new uint[](assetIds.length);\n', '        x = new uint[](assetIds.length);\n', '        y = new uint[](assetIds.length);\n', '        zoom = new uint[](assetIds.length);\n', '        rotation = new uint[](assetIds.length);\n', '        layers = new uint[](assetIds.length);\n', '\n', '        uint finalSeedCopy = _finalSeed;\n', '        uint index = 0;\n', '\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\n', '            if (finalSeedCopy % 2 == 0) {\n', '                pickedIds[index] = assetIds[i];\n', '                (x[index], y[index], zoom[index], rotation[index], layers[index]) = pickRandomAssetPosition(finalSeedCopy, _width, _height);\n', '                index++;\n', '            }\n', '        }\n', '\n', '        finalPicked = new uint[](index);\n', '        for (i = 0; i < index; i++) {\n', '            finalPicked[i] = pickedIds[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Function to pick random position for an asset\n', '    /// @param _randomSeed is random seed for that image\n', '    /// @param _width of canvas\n', '    /// @param _height of canvas\n', '    /// @return tuple of uints representing x,y,zoom,and rotation\n', '    function pickRandomAssetPosition(uint _randomSeed, uint _width, uint _height) public pure \n', '    returns (uint x, uint y, uint zoom, uint rotation, uint layer) {\n', '        \n', '        x = _randomSeed % _width;\n', '        y = _randomSeed % _height;\n', '        zoom = _randomSeed % 200 + 800;\n', '        rotation = _randomSeed % 360;\n', '        // using random number for now\n', '        // if two layers are same, sort by (keccak256(layer, assetId))\n', '        layer = _randomSeed % 1234567; \n', '    }\n', '\n', '    /// @notice Function to calculate final random seed for user\n', '    /// @param _randomSeed is initially given random seed\n', '    /// @param _iterations is number of iterations\n', '    /// @return final seed for user as uint\n', '    function getFinalSeed(uint _randomSeed, uint _iterations) public pure returns (bytes32) {\n', '        require(_randomSeed != 0);\n', '        require(_iterations != 0);\n', '        bytes32 finalSeed = bytes32(_randomSeed);\n', '\n', '        finalSeed = keccak256(abi.encodePacked(_randomSeed, _iterations));\n', '        for (uint i = 0; i < _iterations; i++) {\n', '            finalSeed = keccak256(abi.encodePacked(finalSeed, i));\n', '        }\n', '\n', '        return finalSeed;\n', '    }\n', '\n', '    function toHex(uint _randomSeed) public pure returns (bytes32) {\n', '        return bytes32(_randomSeed);\n', '    }\n', '}']
