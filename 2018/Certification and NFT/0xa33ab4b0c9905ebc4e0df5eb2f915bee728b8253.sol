['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '  // Required methods\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint256 _tokenId) public;\n', '  function totalSupply() public view returns (uint256 total);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '\n', 'contract CelebrityToken is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new person comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token is sold.\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721. \n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME = "CryptoCelebrities"; // solhint-disable-line\n', '  string public constant SYMBOL = "CelebrityToken"; // solhint-disable-line\n', '\n', '  uint256 private startingPrice = 0.001 ether;\n', '  uint256 private constant PROMO_CREATION_LIMIT = 5000;\n', '  uint256 private firstStepLimit =  0.053613 ether;\n', '  uint256 private secondStepLimit = 0.564957 ether;\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev A mapping from person IDs to the address that owns them. All persons have\n', '  ///  some valid owner address.\n', '  mapping (uint256 => address) public personIndexToOwner;\n', '\n', '  // @dev A mapping from owner address to count of tokens that address owns.\n', '  //  Used internally inside balanceOf() to resolve ownership count.\n', '  mapping (address => uint256) private ownershipTokenCount;\n', '\n', '  /// @dev A mapping from PersonIDs to an address that has been approved to call\n', '  ///  transferFrom(). Each Person can only have one approved address for transfer\n', '  ///  at any time. A zero value means no approval is outstanding.\n', '  mapping (uint256 => address) public personIndexToApproved;\n', '\n', '  // @dev A mapping from PersonIDs to the price of the token.\n', '  mapping (uint256 => uint256) private personIndexToPrice;\n', '\n', '  // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '  address public ceoAddress;\n', '  address public cooAddress;\n', '\n', '  uint256 public promoCreatedCount;\n', '\n', '  /*** DATATYPES ***/\n', '  struct Person {\n', '    string name;\n', '  }\n', '\n', '  Person[] private persons;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  /// @dev Access modifier for CEO-only functionality\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for COO-only functionality\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  /// Access modifier for contract owner only functionality\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cooAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function CelebrityToken() public {\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    personIndexToApproved[_tokenId] = _to;\n', '\n', '    Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  /// @dev Creates a new promo Person with the given name, with given _price and assignes it to an address.\n', '  function createPromoPerson(address _owner, string _name, uint256 _price) public onlyCOO {\n', '    require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '\n', '    address personOwner = _owner;\n', '    if (personOwner == address(0)) {\n', '      personOwner = cooAddress;\n', '    }\n', '\n', '    if (_price <= 0) {\n', '      _price = startingPrice;\n', '    }\n', '\n', '    promoCreatedCount++;\n', '    _createPerson(_name, personOwner, _price);\n', '  }\n', '\n', '  /// @dev Creates a new Person with the given name.\n', '  function createContractPerson(string _name) public onlyCOO {\n', '    _createPerson(_name, address(this), startingPrice);\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific person.\n', '  /// @param _tokenId The tokenId of the person of interest.\n', '  function getPerson(uint256 _tokenId) public view returns (\n', '    string personName,\n', '    uint256 sellingPrice,\n', '    address owner\n', '  ) {\n', '    Person storage person = persons[_tokenId];\n', '    personName = person.name;\n', '    sellingPrice = personIndexToPrice[_tokenId];\n', '    owner = personIndexToOwner[_tokenId];\n', '  }\n', '\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /// For querying owner of token\n', '  /// @param _tokenId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId)\n', '    public\n', '    view\n', '    returns (address owner)\n', '  {\n', '    owner = personIndexToOwner[_tokenId];\n', '    require(owner != address(0));\n', '  }\n', '\n', '  function payout(address _to) public onlyCLevel {\n', '    _payout(_to);\n', '  }\n', '\n', '  // Allows someone to send ether and obtain the token\n', '  function purchase(uint256 _tokenId) public payable {\n', '    address oldOwner = personIndexToOwner[_tokenId];\n', '    address newOwner = msg.sender;\n', '\n', '    uint256 sellingPrice = personIndexToPrice[_tokenId];\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= sellingPrice);\n', '\n', '    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 94), 100));\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '    // Update prices\n', '    if (sellingPrice < firstStepLimit) {\n', '      // first stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 200), 94);\n', '    } else if (sellingPrice < secondStepLimit) {\n', '      // second stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 120), 94);\n', '    } else {\n', '      // third stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 94);\n', '    }\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '    // Pay previous tokenOwner if owner is not contract\n', '    if (oldOwner != address(this)) {\n', '      oldOwner.transfer(payment); //(1-0.06)\n', '    }\n', '\n', '    TokenSold(_tokenId, sellingPrice, personIndexToPrice[_tokenId], oldOwner, newOwner, persons[_tokenId].name);\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '\n', '  function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '    return personIndexToPrice[_tokenId];\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '  /// @param _newCEO The address of the new CEO\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the COO. Only available to the current COO.\n', '  /// @param _newCOO The address of the new COO\n', '  function setCOO(address _newCOO) public onlyCEO {\n', '    require(_newCOO != address(0));\n', '\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  /// @notice Allow pre-approved user to take ownership of a token\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = personIndexToOwner[_tokenId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _tokenId));\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', '  /// @dev This method MUST NEVER be called by smart contract code. First, it&#39;s fairly\n', '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalPersons = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 personId;\n', '      for (personId = 0; personId <= totalPersons; personId++) {\n', '        if (personIndexToOwner[personId] == _owner) {\n', '          result[resultIndex] = personId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /// For querying totalSupply of token\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return persons.length;\n', '  }\n', '\n', '  /// Owner initates the transfer of the token to another account\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(msg.sender, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// Third-party initiates transfer of token from address _from to address _to\n', '  /// @param _from The address for the token to be transferred from.\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(_from, _tokenId));\n', '    require(_approved(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return personIndexToApproved[_tokenId] == _to;\n', '  }\n', '\n', '  /// For creating Person\n', '  function _createPerson(string _name, address _owner, uint256 _price) private {\n', '    Person memory _person = Person({\n', '      name: _name\n', '    });\n', '    uint256 newPersonId = persons.push(_person) - 1;\n', '\n', '    // It&#39;s probably never going to happen, 4 billion tokens are A LOT, but\n', '    // let&#39;s just be 100% sure we never let this happen.\n', '    require(newPersonId == uint256(uint32(newPersonId)));\n', '\n', '    Birth(newPersonId, _name, _owner);\n', '\n', '    personIndexToPrice[newPersonId] = _price;\n', '\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newPersonId);\n', '  }\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '    return claimant == personIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /// For paying out balance on contract\n', '  function _payout(address _to) private {\n', '    if (_to == address(0)) {\n', '      ceoAddress.transfer(this.balance);\n', '    } else {\n', '      _to.transfer(this.balance);\n', '    }\n', '  }\n', '\n', '  /// @dev Assigns ownership of a specific Person to an address.\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '    // Since the number of persons is capped to 2^32 we can&#39;t overflow this\n', '    ownershipTokenCount[_to]++;\n', '    //transfer ownership\n', '    personIndexToOwner[_tokenId] = _to;\n', '\n', '    // When creating new persons _from is 0x0, but we can&#39;t account that address.\n', '    if (_from != address(0)) {\n', '      ownershipTokenCount[_from]--;\n', '      // clear any previously approved ownership exchange\n', '      delete personIndexToApproved[_tokenId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/// @author Artyom Harutyunyan <artyomharutyunyans@gmail.com>\n', '\n', 'contract CelebrityBreederToken is ERC721 {\n', '  \n', '   /// @dev The Birth event is fired whenever a new person comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token is sold.\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721. \n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '  event Trained(address caller, uint256 tokenId, bool generation);\n', '  event Beaten(address caller, uint256 tokenId, bool generation);\n', '  event SiringPriceEvent(address caller, uint256 tokenId, bool generation, uint price);\n', '  event SellingPriceEvent(address caller, uint256 tokenId, bool generation, uint price);\n', '  event GenesInitialisedEvent(address caller, uint256 tokenId, bool generation, uint genes);\n', '  \n', '  CelebrityToken private CelGen0=CelebrityToken(0xbb5Ed1EdeB5149AF3ab43ea9c7a6963b3C1374F7); //@Artyom Pointing to original CC\n', '  CelebrityBreederToken private CelBetta=CelebrityBreederToken(0xdab64dc4a02225f76fccce35ab9ba53b3735c684); //@Artyom Pointing to betta \n', ' \n', '  string public constant NAME = "CryptoCelebrityBreederCards"; \n', '  string public constant SYMBOL = "CeleBreedCard"; \n', '\n', '  uint256 public breedingFee = 0.01 ether;\n', '  uint256 public initialTraining = 0.00001 ether;\n', '  uint256 public initialBeating = 0.00002 ether;\n', '  uint256 private constant CreationLimitGen0 = 5000;\n', '  uint256 private constant CreationLimitGen1 = 2500000;\n', '  uint256 public constant MaxValue =  100000000 ether;\n', '  \n', '  mapping (uint256 => address) public personIndexToOwnerGen1;\n', '  mapping (address => uint256) private ownershipTokenCountGen1;\n', '  mapping (uint256 => address) public personIndexToApprovedGen1;\n', '  mapping (uint256 => uint256) private personIndexToPriceGen1;\n', '  mapping (uint256 => address) public ExternalAllowdContractGen0;\n', '  mapping (uint256 => address) public ExternalAllowdContractGen1; \n', '  mapping (uint256 => uint256) public personIndexToSiringPrice0;\n', '  mapping (uint256 => uint256) public personIndexToSiringPrice1;\n', '  address public CeoAddress; \n', '  address public DevAddress;\n', '  \n', '   struct Person {\n', '    string name;\n', '    string surname; \n', '    uint64 genes; \n', '    uint64 birthTime;\n', '    uint32 fatherId;\n', '    uint32 motherId;\n', '    uint32 readyToBreedWithId;\n', '    uint32 trainedcount;\n', '    uint32 beatencount;\n', '    bool readyToBreedWithGen;\n', '    bool gender;\n', '    bool fatherGeneration;\n', '    bool motherGeneration;\n', '  }\n', '  \n', '  Person[] private PersonsGen0;\n', '  Person[] private PersonsGen1;\n', '  \n', '    modifier onlyCEO() {\n', '    require(msg.sender == CeoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyDEV() {\n', '    require(msg.sender == DevAddress);\n', '    _;\n', '  }\n', '  \n', '   modifier onlyPlayers() {\n', '    require(ownershipTokenCountGen1[msg.sender]>0 || CelGen0.balanceOf(msg.sender)>0);\n', '    _;\n', '  }\n', '\n', '  /// Access modifier for contract owner only functionality\n', ' /* modifier onlyTopLevel() {\n', '    require(\n', '      msg.sender == CeoAddress ||\n', '      msg.sender == DevAddress\n', '    );\n', '    _;\n', '  }\n', '  */\n', '  function masscreate(uint256 fromindex, uint256 toindex) external onlyCEO{ \n', '      string memory name; string memory surname; uint64 genes;  bool gender;\n', '      for(uint256 i=fromindex;i<=toindex;i++)\n', '      {\n', '          ( name, surname, genes, , ,  , , ,  gender)=CelBetta.getPerson(i,false);\n', '         _birthPerson(name, surname ,genes, gender, false);\n', '      }\n', '  }\n', '  function CelebrityBreederToken() public { \n', '      CeoAddress= msg.sender;\n', '      DevAddress= msg.sender;\n', '  }\n', '    function setBreedingFee(uint256 newfee) external onlyCEO{\n', '      breedingFee=newfee;\n', '  }\n', '  function allowexternalContract(address _to, uint256 _tokenId,bool _tokengeneration) public { \n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId, _tokengeneration));\n', '    \n', '    if(_tokengeneration) {\n', '        if(_addressNotNull(_to)) {\n', '            ExternalAllowdContractGen1[_tokenId]=_to;\n', '        }\n', '        else {\n', '             delete ExternalAllowdContractGen1[_tokenId];\n', '        }\n', '    }\n', '    else {\n', '       if(_addressNotNull(_to)) {\n', '            ExternalAllowdContractGen0[_tokenId]=_to;\n', '        }\n', '        else {\n', '             delete ExternalAllowdContractGen0[_tokenId];\n', '        }\n', '    }\n', '\n', '  }\n', '  \n', '  \n', '  //@Artyom Required for ERC-721 compliance.\n', '  function approve(address _to, uint256 _tokenId) public { //@Artyom only gen1\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId, true));\n', '\n', '    personIndexToApprovedGen1[_tokenId] = _to;\n', '\n', '    Approval(msg.sender, _to, _tokenId);\n', '  }\n', '  // @Artyom Required for ERC-721 compliance.\n', '  //@Artyom only gen1\n', '   function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipTokenCountGen1[_owner];\n', '  }\n', '  \n', '    function getPerson(uint256 _tokenId,bool generation) public view returns ( string name, string surname, uint64 genes,uint64 birthTime, uint32 readyToBreedWithId, uint32 trainedcount,uint32 beatencount,bool readyToBreedWithGen, bool gender) {\n', '    Person person;\n', '    if(generation==false) {\n', '        person = PersonsGen0[_tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_tokenId];\n', '    }\n', '         \n', '    name = person.name;\n', '    surname=person.surname;\n', '    genes=person.genes;\n', '    birthTime=person.birthTime;\n', '    readyToBreedWithId=person.readyToBreedWithId;\n', '    trainedcount=person.trainedcount;\n', '    beatencount=person.beatencount;\n', '    readyToBreedWithGen=person.readyToBreedWithGen;\n', '    gender=person.gender;\n', '\n', '  }\n', '   function getPersonParents(uint256 _tokenId, bool generation) public view returns ( uint32 fatherId, uint32 motherId, bool fatherGeneration, bool motherGeneration) {\n', '    Person person;\n', '    if(generation==false) {\n', '        person = PersonsGen0[_tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_tokenId];\n', '    }\n', '         \n', '    fatherId=person.fatherId;\n', '    motherId=person.motherId;\n', '    fatherGeneration=person.fatherGeneration;\n', '    motherGeneration=person.motherGeneration;\n', '  }\n', '  // @Artyom Required for ERC-721 compliance.\n', '   function implementsERC721() public pure returns (bool) { \n', '    return true;\n', '  }\n', '\n', '  // @Artyom Required for ERC-721 compliance.\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '// @Artyom Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId) public view returns (address owner)\n', '  {\n', '    owner = personIndexToOwnerGen1[_tokenId];\n', '    require(_addressNotNull(owner));\n', '  }\n', '  \n', '  //@Artyom only gen1\n', '   function purchase(uint256 _tokenId) public payable {\n', '    address oldOwner = personIndexToOwnerGen1[_tokenId];\n', '    address newOwner = msg.sender;\n', '\n', '    uint256 sellingPrice = personIndexToPriceGen1[_tokenId];\n', '    personIndexToPriceGen1[_tokenId]=MaxValue;\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= sellingPrice);\n', '\n', '   // uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 94), 100));\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '    // Pay previous tokenOwner if owner is not contract\n', '    if (oldOwner != address(this)) {\n', '    //  oldOwner.transfer(payment); //(1-0.06) //old code for holding some percents\n', '    oldOwner.transfer(sellingPrice);\n', '    }\n', '    blankbreedingdata(_tokenId,true);\n', '\n', '    TokenSold(_tokenId, sellingPrice, personIndexToPriceGen1[_tokenId], oldOwner, newOwner, PersonsGen1[_tokenId].name);\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '  \n', '   //@Artyom only gen1\n', '   function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '    return personIndexToPriceGen1[_tokenId];\n', '  }\n', '\n', ' \n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_addressNotNull(_newCEO));\n', '\n', '    CeoAddress = _newCEO;\n', '  }\n', '\n', ' //@Artyom only gen1\n', ' function setprice(uint256 _tokenId, uint256 _price) public {\n', '    require(_owns(msg.sender, _tokenId, true));\n', '    if(_price<=0 || _price>=MaxValue) {\n', '        personIndexToPriceGen1[_tokenId]=MaxValue;\n', '    }\n', '    else {\n', '        personIndexToPriceGen1[_tokenId]=_price;\n', '    }\n', '    SellingPriceEvent(msg.sender,_tokenId,true,_price);\n', ' }\n', ' \n', '  function setDEV(address _newDEV) external onlyDEV {\n', '    require(_addressNotNull(_newDEV));\n', '\n', '    DevAddress = _newDEV;\n', '  }\n', '  \n', '    // @Artyom Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '\n', '  // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = personIndexToOwnerGen1[_tokenId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approvedGen1(newOwner, _tokenId));\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '  \n', '  //@Artyom only gen1\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } \n', '    else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalPersons = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 personId;\n', '      for (personId = 0; personId <= totalPersons; personId++) {\n', '        if (personIndexToOwnerGen1[personId] == _owner) {\n', '          result[resultIndex] = personId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '   function totalSupply() public view returns (uint256 total) {\n', '    return PersonsGen1.length;\n', '  }\n', '\n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '  function transfer( address _to, uint256 _tokenId) public {\n', '    require(_owns(msg.sender, _tokenId, true));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '    require(_owns(_from, _tokenId, true));\n', '    require(_approvedGen1(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '  \n', '   function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approvedGen1(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return personIndexToApprovedGen1[_tokenId] == _to;\n', '  }\n', '  //@Artyom only gen0\n', '   function createPersonGen0(string _name, string _surname,uint64 _genes, bool _gender) external onlyCEO returns(uint256) {\n', '    return _birthPerson(_name, _surname ,_genes, _gender, false);\n', '  }\n', '  function SetGene(uint256 tokenId,bool generation, uint64 newgene) public {\n', '     require(_owns(msg.sender, tokenId, generation) || msg.sender==CeoAddress);\n', '     require(newgene<=9999999999 && newgene>=10);\n', '     Person person; //@Artyom reference\n', '    if (generation==false) { \n', '        person = PersonsGen0[tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[tokenId];\n', '    }\n', '    require(person.genes<=90);\n', '     \n', '    uint64 _gene=newgene;\n', '    uint64 _pointCount=0;\n', '   \n', '   \n', '      for(uint i=0;i<10;i++) {\n', '           _pointCount+=_gene%10;\n', '           _gene=_gene/10;\n', '      }\n', '    //  log(_pointCount,person.genes);\n', '    require(_pointCount==person.genes);\n', '           \n', '    person.genes=newgene;\n', '    GenesInitialisedEvent(msg.sender,tokenId,generation,newgene);\n', '}\n', ' \n', '   function breed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool  _withpersongeneration, string _boyname, string _girlname) public payable { //@Artyom mother\n', '       require(_owns(msg.sender, _mypersonid, _mypersongeneration));\n', '       require(CreationLimitGen1>totalSupply()+1);\n', '    \n', '    //Mother\n', '    Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) { \n', '        person = PersonsGen0[_mypersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        require(person.gender==false); //@Artyom checking gender for gen1 to be mother in this case\n', '    }\n', '\n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    \n', '    uint64 genes1=person.genes;\n', '    //Father\n', '        if(_withpersongeneration==false) { \n', '        person = PersonsGen0[_withpersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_withpersonid];\n', '       \n', '    }\n', '     \n', '   \n', '     require(readyTobreed(_mypersonid, _mypersongeneration, _withpersonid,  _withpersongeneration));\n', '     require(breedingFee<=msg.value);\n', '   \n', '    \n', '    delete person.readyToBreedWithId;\n', '    person.readyToBreedWithGen=false;\n', '    \n', '   // uint64 genes2=person.genes;\n', '    \n', '       uint64 _generatedGen;\n', '       bool _gender; \n', '       (_generatedGen,_gender)=_generateGene(genes1,person.genes,_mypersonid,_withpersonid); \n', '       \n', '     if(_gender) {\n', '       _girlname=_boyname; //@Artyom if gender is true/1 then it should take the boyname\n', '     }\n', '       uint newid=_birthPerson(_girlname, person.surname, _generatedGen, _gender, true);\n', '            PersonsGen1[newid].fatherGeneration=_withpersongeneration; // @ Artyom, did here because stack too deep for function\n', '            PersonsGen1[newid].motherGeneration=_mypersongeneration;\n', '            PersonsGen1[newid].fatherId=uint32(_withpersonid); \n', '            PersonsGen1[newid].motherId=uint32(_mypersonid);\n', '        \n', '        \n', '       _payout();\n', '  }\n', '  \n', '    function breedOnAuction(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool  _withpersongeneration, string _boyname, string _girlname) public payable { //@Artyom mother\n', '       require(_owns(msg.sender, _mypersonid, _mypersongeneration));\n', '       require(CreationLimitGen1>totalSupply()+1);\n', '       require(!(_mypersonid==_withpersonid && _mypersongeneration==_withpersongeneration));// @Artyom not to breed with self\n', '       require(!((_mypersonid==0 && _mypersongeneration==false) || (_withpersonid==0 && _withpersongeneration==false))); //Not to touch Satoshi\n', '    //Mother\n', '    Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) { \n', '        person = PersonsGen0[_mypersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        require(person.gender==false); //@Artyom checking gender for gen1 to be mother in this case\n', '    }\n', '    \n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    \n', '    address owneroffather;\n', '    uint256 _siringprice;\n', '    uint64 genes1=person.genes;\n', '    //Father\n', '        if(_withpersongeneration==false) { \n', '        person = PersonsGen0[_withpersonid];\n', '        _siringprice=personIndexToSiringPrice0[_withpersonid];\n', '        owneroffather=CelGen0.ownerOf(_withpersonid);\n', '    }\n', '    else {\n', '        person = PersonsGen1[_withpersonid];\n', '        _siringprice=personIndexToSiringPrice1[_withpersonid];\n', '        owneroffather= personIndexToOwnerGen1[_withpersonid];\n', '    }\n', '     \n', '   require(_siringprice>0 && _siringprice<MaxValue);\n', '   require((breedingFee+_siringprice)<=msg.value);\n', '    \n', '    \n', '//    uint64 genes2=;\n', '    \n', '       uint64 _generatedGen;\n', '       bool _gender; \n', '       (_generatedGen,_gender)=_generateGene(genes1,person.genes,_mypersonid,_withpersonid); \n', '       \n', '     if(_gender) {\n', '       _girlname=_boyname; //@Artyom if gender is true/1 then it should take the boyname\n', '     }\n', '       uint newid=_birthPerson(_girlname, person.surname, _generatedGen, _gender, true);\n', '            PersonsGen1[newid].fatherGeneration=_withpersongeneration; // @ Artyom, did here because stack too deep for function\n', '            PersonsGen1[newid].motherGeneration=_mypersongeneration;\n', '            PersonsGen1[newid].fatherId=uint32(_withpersonid); \n', '            PersonsGen1[newid].motherId=uint32(_mypersonid);\n', '        \n', '        \n', '        owneroffather.transfer(_siringprice);\n', '       _payout();\n', '  }\n', ' \n', '  \n', '  \n', '  function prepareToBreed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool _withpersongeneration, uint256 _siringprice) external { //@Artyom father\n', '      require(_owns(msg.sender, _mypersonid, _mypersongeneration)); \n', '      \n', '       Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) {\n', '        person = PersonsGen0[_mypersonid];\n', '        personIndexToSiringPrice0[_mypersonid]=_siringprice;\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        \n', '        require(person.gender==true);//@Artyom for gen1 checking genders to be male\n', '        personIndexToSiringPrice1[_mypersonid]=_siringprice;\n', '    }\n', '      require(person.genes>90);//@Artyom if its unlocked\n', '\n', '       person.readyToBreedWithId=uint32(_withpersonid); \n', '       person.readyToBreedWithGen=_withpersongeneration;\n', '       SiringPriceEvent(msg.sender,_mypersonid,_mypersongeneration,_siringprice);\n', '      \n', '  }\n', '  \n', '  function readyTobreed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool _withpersongeneration) public view returns(bool) {\n', '\n', 'if (_mypersonid==_withpersonid && _mypersongeneration==_withpersongeneration) //Not to fuck Themselves \n', 'return false;\n', '\n', 'if((_mypersonid==0 && _mypersongeneration==false) || (_withpersonid==0 && _withpersongeneration==false)) //Not to touch Satoshi\n', 'return false;\n', '\n', '    Person withperson; //@Artyom reference\n', '    if(_withpersongeneration==false) {\n', '        withperson = PersonsGen0[_withpersonid];\n', '    }\n', '    else {\n', '        withperson = PersonsGen1[_withpersonid];\n', '    }\n', '   \n', '   \n', '   if(withperson.readyToBreedWithGen==_mypersongeneration) {\n', '       if(withperson.readyToBreedWithId==_mypersonid) {\n', '       return true;\n', '   }\n', '   }\n', '  \n', '    \n', '    return false;\n', '    \n', '  }\n', '  function _birthPerson(string _name, string _surname, uint64 _genes, bool _gender, bool _generation) private returns(uint256) { // about this steps   \n', '    Person memory _person = Person({\n', '        name: _name,\n', '        surname: _surname,\n', '        genes: _genes,\n', '        birthTime: uint64(now),\n', '        fatherId: 0,\n', '        motherId: 0,\n', '        readyToBreedWithId: 0,\n', '        trainedcount: 0,\n', '        beatencount: 0,\n', '        readyToBreedWithGen: false,\n', '        gender: _gender,\n', '        fatherGeneration: false,\n', '        motherGeneration: false\n', '\n', '        \n', '    });\n', '    \n', '    uint256 newPersonId;\n', '    if(_generation==false) {\n', '         newPersonId = PersonsGen0.push(_person) - 1;\n', '    }\n', '    else {\n', '         newPersonId = PersonsGen1.push(_person) - 1;\n', '         personIndexToPriceGen1[newPersonId] = MaxValue; //@Artyom indicating not for sale\n', '          // per ERC721 draft-This will assign ownership, and also emit the Transfer event as\n', '        _transfer(address(0), msg.sender, newPersonId);\n', '        \n', '\n', '    }\n', '\n', '    Birth(newPersonId, _name, msg.sender);\n', '    return newPersonId;\n', '  }\n', '  function _generateGene(uint64 _genes1,uint64 _genes2,uint256 _mypersonid,uint256 _withpersonid) private returns(uint64,bool) {\n', '       uint64 _gene;\n', '       uint64 _gene1;\n', '       uint64 _gene2;\n', '       uint64 _rand;\n', '       uint256 _finalGene=0;\n', '       bool gender=false;\n', '\n', '       for(uint i=0;i<10;i++) {\n', '           _gene1 =_genes1%10;\n', '           _gene2=_genes2%10;\n', '           _genes1=_genes1/10;\n', '           _genes2=_genes2/10;\n', '           _rand=uint64(keccak256(block.blockhash(block.number), i, now,_mypersonid,_withpersonid))%10000;\n', '           \n', '          _gene=(_gene1+_gene2)/2;\n', '           \n', '           if(_rand<26) {\n', '               _gene-=3;\n', '           }\n', '            else if(_rand<455) {\n', '                _gene-=2;\n', '           }\n', '            else if(_rand<3173) {\n', '                _gene-=1;\n', '           }\n', '            else if(_rand<6827) {\n', '                \n', '           }\n', '            else if(_rand<9545) {\n', '                _gene+=1;\n', '           }\n', '            else if(_rand<9974) {\n', '                _gene+=2;\n', '           }\n', '            else if(_rand<10000) {\n', '                _gene+=3;\n', '           }\n', '           \n', '           if(_gene>12) //@Artyom to avoid negative overflow\n', '           _gene=0;\n', '           if(_gene>9)\n', '           _gene=9;\n', '           \n', '           _finalGene+=(uint(10)**i)*_gene;\n', '       }\n', '      \n', '      if(uint64(keccak256(block.blockhash(block.number), 11, now,_mypersonid,_withpersonid))%2>0)\n', '      gender=true;\n', '      \n', '      return(uint64(_finalGene),gender);  \n', '  } \n', '  function _owns(address claimant, uint256 _tokenId,bool _tokengeneration) private view returns (bool) {\n', '   if(_tokengeneration) {\n', '        return ((claimant == personIndexToOwnerGen1[_tokenId]) || (claimant==ExternalAllowdContractGen1[_tokenId]));\n', '   }\n', '   else {\n', '       return ((claimant == CelGen0.personIndexToOwner(_tokenId)) || (claimant==ExternalAllowdContractGen0[_tokenId]));\n', '   }\n', '  }\n', '      \n', '  function _payout() private {\n', '    DevAddress.transfer((this.balance/10)*3);\n', '    CeoAddress.transfer((this.balance/10)*7); \n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '   function _transfer(address _from, address _to, uint256 _tokenId) private {\n', '    // Since the number of persons is capped to 2^32 we can&#39;t overflow this\n', '    ownershipTokenCountGen1[_to]++;\n', '    //transfer ownership\n', '    personIndexToOwnerGen1[_tokenId] = _to;\n', '\n', '    // When creating new persons _from is 0x0, but we can&#39;t account that address.\n', '    if (_addressNotNull(_from)) {\n', '      ownershipTokenCountGen1[_from]--;\n', '      // clear any previously approved ownership exchange\n', '     blankbreedingdata(_tokenId,true);\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '  function blankbreedingdata(uint256 _personid, bool _persongeneration) private{\n', '      Person person;\n', '      if(_persongeneration==false) { \n', '        person = PersonsGen0[_personid];\n', '        delete ExternalAllowdContractGen0[_personid];\n', '        delete personIndexToSiringPrice0[_personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_personid];\n', '        delete ExternalAllowdContractGen1[_personid];\n', '        delete personIndexToSiringPrice1[_personid];\n', '    \tdelete personIndexToApprovedGen1[_personid];\n', '    }\n', '     delete person.readyToBreedWithId;\n', '     delete person.readyToBreedWithGen; \n', '  }\n', '    function train(uint256 personid, bool persongeneration, uint8 gene) external payable onlyPlayers {\n', '        \n', '        require(gene>=0 && gene<10);\n', '        uint256 trainingPrice=checkTrainingPrice(personid,persongeneration);\n', '        require(msg.value >= trainingPrice);\n', '         Person person; \n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '     require(person.genes>90);//@Artyom if its unlocked\n', '     uint gensolo=person.genes/(uint(10)**gene);\n', '    gensolo=gensolo%10;\n', '    require(gensolo<9); //@Artyom not to train after 9\n', '    \n', '          person.genes+=uint64(10)**gene;\n', '          person.trainedcount++;\n', '\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, trainingPrice);\n', '    msg.sender.transfer(purchaseExcess);\n', '    _payout();\n', '    Trained(msg.sender, personid, persongeneration);\n', '    }\n', '    \n', '     function beat(uint256 personid, bool persongeneration, uint8 gene) external payable onlyPlayers {\n', '        require(gene>=0 && gene<10);\n', '        uint256 beatingPrice=checkBeatingPrice(personid,persongeneration);\n', '        require(msg.value >= beatingPrice);\n', '         Person person; \n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    uint gensolo=person.genes/(uint(10)**gene);\n', '    gensolo=gensolo%10;\n', '    require(gensolo>0);\n', '          person.genes-=uint64(10)**gene;\n', '          person.beatencount++;\n', '\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, beatingPrice);\n', '    msg.sender.transfer(purchaseExcess);\n', '    _payout();\n', '    Beaten(msg.sender, personid, persongeneration);    \n', '    }\n', '    \n', '    \n', '    function checkTrainingPrice(uint256 personid, bool persongeneration) view returns (uint256) {\n', '         Person person;\n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '    uint256 _trainingprice= (uint(2)**person.trainedcount) * initialTraining;\n', '    if (_trainingprice > 5 ether)\n', '    _trainingprice=5 ether;\n', '    \n', '    return _trainingprice;\n', '    }\n', '    function checkBeatingPrice(uint256 personid, bool persongeneration) view returns (uint256) {\n', '         Person person;\n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    uint256 _beatingprice=(uint(2)**person.beatencount) * initialBeating;\n', '     if (_beatingprice > 7 ether)\n', '    _beatingprice=7 ether;\n', '    return _beatingprice;\n', '    } \n', '  \n', '}']
['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'contract ERC721 {\n', '  // Required methods\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '  function implementsERC721() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address addr);\n', '  function takeOwnership(uint256 _tokenId) public;\n', '  function totalSupply() public view returns (uint256 total);\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 tokenId);\n', '  event Approval(address indexed owner, address indexed approved, uint256 tokenId);\n', '\n', '  // Optional\n', '  // function name() public view returns (string name);\n', '  // function symbol() public view returns (string symbol);\n', '  // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\n', '  // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\n', '}\n', '\n', '\n', 'contract CelebrityToken is ERC721 {\n', '\n', '  /*** EVENTS ***/\n', '\n', '  /// @dev The Birth event is fired whenever a new person comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token is sold.\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721. \n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '\n', '  /*** CONSTANTS ***/\n', '\n', '  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '  string public constant NAME = "CryptoCelebrities"; // solhint-disable-line\n', '  string public constant SYMBOL = "CelebrityToken"; // solhint-disable-line\n', '\n', '  uint256 private startingPrice = 0.001 ether;\n', '  uint256 private constant PROMO_CREATION_LIMIT = 5000;\n', '  uint256 private firstStepLimit =  0.053613 ether;\n', '  uint256 private secondStepLimit = 0.564957 ether;\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev A mapping from person IDs to the address that owns them. All persons have\n', '  ///  some valid owner address.\n', '  mapping (uint256 => address) public personIndexToOwner;\n', '\n', '  // @dev A mapping from owner address to count of tokens that address owns.\n', '  //  Used internally inside balanceOf() to resolve ownership count.\n', '  mapping (address => uint256) private ownershipTokenCount;\n', '\n', '  /// @dev A mapping from PersonIDs to an address that has been approved to call\n', '  ///  transferFrom(). Each Person can only have one approved address for transfer\n', '  ///  at any time. A zero value means no approval is outstanding.\n', '  mapping (uint256 => address) public personIndexToApproved;\n', '\n', '  // @dev A mapping from PersonIDs to the price of the token.\n', '  mapping (uint256 => uint256) private personIndexToPrice;\n', '\n', '  // The addresses of the accounts (or contracts) that can execute actions within each roles.\n', '  address public ceoAddress;\n', '  address public cooAddress;\n', '\n', '  uint256 public promoCreatedCount;\n', '\n', '  /*** DATATYPES ***/\n', '  struct Person {\n', '    string name;\n', '  }\n', '\n', '  Person[] private persons;\n', '\n', '  /*** ACCESS MODIFIERS ***/\n', '  /// @dev Access modifier for CEO-only functionality\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev Access modifier for COO-only functionality\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  /// Access modifier for contract owner only functionality\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cooAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /*** CONSTRUCTOR ***/\n', '  function CelebrityToken() public {\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '  }\n', '\n', '  /*** PUBLIC FUNCTIONS ***/\n', '  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function approve(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    personIndexToApproved[_tokenId] = _to;\n', '\n', '    Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// For querying balance of a particular account\n', '  /// @param _owner The address for balance query\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  /// @dev Creates a new promo Person with the given name, with given _price and assignes it to an address.\n', '  function createPromoPerson(address _owner, string _name, uint256 _price) public onlyCOO {\n', '    require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '\n', '    address personOwner = _owner;\n', '    if (personOwner == address(0)) {\n', '      personOwner = cooAddress;\n', '    }\n', '\n', '    if (_price <= 0) {\n', '      _price = startingPrice;\n', '    }\n', '\n', '    promoCreatedCount++;\n', '    _createPerson(_name, personOwner, _price);\n', '  }\n', '\n', '  /// @dev Creates a new Person with the given name.\n', '  function createContractPerson(string _name) public onlyCOO {\n', '    _createPerson(_name, address(this), startingPrice);\n', '  }\n', '\n', '  /// @notice Returns all the relevant information about a specific person.\n', '  /// @param _tokenId The tokenId of the person of interest.\n', '  function getPerson(uint256 _tokenId) public view returns (\n', '    string personName,\n', '    uint256 sellingPrice,\n', '    address owner\n', '  ) {\n', '    Person storage person = persons[_tokenId];\n', '    personName = person.name;\n', '    sellingPrice = personIndexToPrice[_tokenId];\n', '    owner = personIndexToOwner[_tokenId];\n', '  }\n', '\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /// For querying owner of token\n', '  /// @param _tokenId The tokenID for owner inquiry\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId)\n', '    public\n', '    view\n', '    returns (address owner)\n', '  {\n', '    owner = personIndexToOwner[_tokenId];\n', '    require(owner != address(0));\n', '  }\n', '\n', '  function payout(address _to) public onlyCLevel {\n', '    _payout(_to);\n', '  }\n', '\n', '  // Allows someone to send ether and obtain the token\n', '  function purchase(uint256 _tokenId) public payable {\n', '    address oldOwner = personIndexToOwner[_tokenId];\n', '    address newOwner = msg.sender;\n', '\n', '    uint256 sellingPrice = personIndexToPrice[_tokenId];\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= sellingPrice);\n', '\n', '    uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 94), 100));\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '    // Update prices\n', '    if (sellingPrice < firstStepLimit) {\n', '      // first stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 200), 94);\n', '    } else if (sellingPrice < secondStepLimit) {\n', '      // second stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 120), 94);\n', '    } else {\n', '      // third stage\n', '      personIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 115), 94);\n', '    }\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '    // Pay previous tokenOwner if owner is not contract\n', '    if (oldOwner != address(this)) {\n', '      oldOwner.transfer(payment); //(1-0.06)\n', '    }\n', '\n', '    TokenSold(_tokenId, sellingPrice, personIndexToPrice[_tokenId], oldOwner, newOwner, persons[_tokenId].name);\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '\n', '  function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '    return personIndexToPrice[_tokenId];\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n', '  /// @param _newCEO The address of the new CEO\n', '  function setCEO(address _newCEO) public onlyCEO {\n', '    require(_newCEO != address(0));\n', '\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  /// @dev Assigns a new address to act as the COO. Only available to the current COO.\n', '  /// @param _newCOO The address of the new COO\n', '  function setCOO(address _newCOO) public onlyCEO {\n', '    require(_newCOO != address(0));\n', '\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  /// @notice Allow pre-approved user to take ownership of a token\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = personIndexToOwner[_tokenId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approved(newOwner, _tokenId));\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '\n', '  /// @param _owner The owner whose celebrity tokens we are interested in.\n', "  /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n", '  ///  expensive (it walks the entire Persons array looking for persons belonging to owner),\n', '  ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n', '  ///  not contract-to-contract calls.\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalPersons = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 personId;\n', '      for (personId = 0; personId <= totalPersons; personId++) {\n', '        if (personIndexToOwner[personId] == _owner) {\n', '          result[resultIndex] = personId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /// For querying totalSupply of token\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() public view returns (uint256 total) {\n', '    return persons.length;\n', '  }\n', '\n', '  /// Owner initates the transfer of the token to another account\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(msg.sender, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// Third-party initiates transfer of token from address _from to address _to\n', '  /// @param _from The address for the token to be transferred from.\n', '  /// @param _to The address for the token to be transferred to.\n', '  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n', '  /// @dev Required for ERC-721 compliance.\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) public {\n', '    require(_owns(_from, _tokenId));\n', '    require(_approved(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /*** PRIVATE FUNCTIONS ***/\n', '  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '  function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approved(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return personIndexToApproved[_tokenId] == _to;\n', '  }\n', '\n', '  /// For creating Person\n', '  function _createPerson(string _name, address _owner, uint256 _price) private {\n', '    Person memory _person = Person({\n', '      name: _name\n', '    });\n', '    uint256 newPersonId = persons.push(_person) - 1;\n', '\n', "    // It's probably never going to happen, 4 billion tokens are A LOT, but\n", "    // let's just be 100% sure we never let this happen.\n", '    require(newPersonId == uint256(uint32(newPersonId)));\n', '\n', '    Birth(newPersonId, _name, _owner);\n', '\n', '    personIndexToPrice[newPersonId] = _price;\n', '\n', '    // This will assign ownership, and also emit the Transfer event as\n', '    // per ERC721 draft\n', '    _transfer(address(0), _owner, newPersonId);\n', '  }\n', '\n', '  /// Check for token ownership\n', '  function _owns(address claimant, uint256 _tokenId) private view returns (bool) {\n', '    return claimant == personIndexToOwner[_tokenId];\n', '  }\n', '\n', '  /// For paying out balance on contract\n', '  function _payout(address _to) private {\n', '    if (_to == address(0)) {\n', '      ceoAddress.transfer(this.balance);\n', '    } else {\n', '      _to.transfer(this.balance);\n', '    }\n', '  }\n', '\n', '  /// @dev Assigns ownership of a specific Person to an address.\n', '  function _transfer(address _from, address _to, uint256 _tokenId) private {\n', "    // Since the number of persons is capped to 2^32 we can't overflow this\n", '    ownershipTokenCount[_to]++;\n', '    //transfer ownership\n', '    personIndexToOwner[_tokenId] = _to;\n', '\n', "    // When creating new persons _from is 0x0, but we can't account that address.\n", '    if (_from != address(0)) {\n', '      ownershipTokenCount[_from]--;\n', '      // clear any previously approved ownership exchange\n', '      delete personIndexToApproved[_tokenId];\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '}\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/// @author Artyom Harutyunyan <artyomharutyunyans@gmail.com>\n', '\n', 'contract CelebrityBreederToken is ERC721 {\n', '  \n', '   /// @dev The Birth event is fired whenever a new person comes into existence.\n', '  event Birth(uint256 tokenId, string name, address owner);\n', '\n', '  /// @dev The TokenSold event is fired whenever a token is sold.\n', '  event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name);\n', '\n', '  /// @dev Transfer event as defined in current draft of ERC721. \n', '  ///  ownership is assigned, including births.\n', '  event Transfer(address from, address to, uint256 tokenId);\n', '  event Trained(address caller, uint256 tokenId, bool generation);\n', '  event Beaten(address caller, uint256 tokenId, bool generation);\n', '  event SiringPriceEvent(address caller, uint256 tokenId, bool generation, uint price);\n', '  event SellingPriceEvent(address caller, uint256 tokenId, bool generation, uint price);\n', '  event GenesInitialisedEvent(address caller, uint256 tokenId, bool generation, uint genes);\n', '  \n', '  CelebrityToken private CelGen0=CelebrityToken(0xbb5Ed1EdeB5149AF3ab43ea9c7a6963b3C1374F7); //@Artyom Pointing to original CC\n', '  CelebrityBreederToken private CelBetta=CelebrityBreederToken(0xdab64dc4a02225f76fccce35ab9ba53b3735c684); //@Artyom Pointing to betta \n', ' \n', '  string public constant NAME = "CryptoCelebrityBreederCards"; \n', '  string public constant SYMBOL = "CeleBreedCard"; \n', '\n', '  uint256 public breedingFee = 0.01 ether;\n', '  uint256 public initialTraining = 0.00001 ether;\n', '  uint256 public initialBeating = 0.00002 ether;\n', '  uint256 private constant CreationLimitGen0 = 5000;\n', '  uint256 private constant CreationLimitGen1 = 2500000;\n', '  uint256 public constant MaxValue =  100000000 ether;\n', '  \n', '  mapping (uint256 => address) public personIndexToOwnerGen1;\n', '  mapping (address => uint256) private ownershipTokenCountGen1;\n', '  mapping (uint256 => address) public personIndexToApprovedGen1;\n', '  mapping (uint256 => uint256) private personIndexToPriceGen1;\n', '  mapping (uint256 => address) public ExternalAllowdContractGen0;\n', '  mapping (uint256 => address) public ExternalAllowdContractGen1; \n', '  mapping (uint256 => uint256) public personIndexToSiringPrice0;\n', '  mapping (uint256 => uint256) public personIndexToSiringPrice1;\n', '  address public CeoAddress; \n', '  address public DevAddress;\n', '  \n', '   struct Person {\n', '    string name;\n', '    string surname; \n', '    uint64 genes; \n', '    uint64 birthTime;\n', '    uint32 fatherId;\n', '    uint32 motherId;\n', '    uint32 readyToBreedWithId;\n', '    uint32 trainedcount;\n', '    uint32 beatencount;\n', '    bool readyToBreedWithGen;\n', '    bool gender;\n', '    bool fatherGeneration;\n', '    bool motherGeneration;\n', '  }\n', '  \n', '  Person[] private PersonsGen0;\n', '  Person[] private PersonsGen1;\n', '  \n', '    modifier onlyCEO() {\n', '    require(msg.sender == CeoAddress);\n', '    _;\n', '  }\n', '\n', '  modifier onlyDEV() {\n', '    require(msg.sender == DevAddress);\n', '    _;\n', '  }\n', '  \n', '   modifier onlyPlayers() {\n', '    require(ownershipTokenCountGen1[msg.sender]>0 || CelGen0.balanceOf(msg.sender)>0);\n', '    _;\n', '  }\n', '\n', '  /// Access modifier for contract owner only functionality\n', ' /* modifier onlyTopLevel() {\n', '    require(\n', '      msg.sender == CeoAddress ||\n', '      msg.sender == DevAddress\n', '    );\n', '    _;\n', '  }\n', '  */\n', '  function masscreate(uint256 fromindex, uint256 toindex) external onlyCEO{ \n', '      string memory name; string memory surname; uint64 genes;  bool gender;\n', '      for(uint256 i=fromindex;i<=toindex;i++)\n', '      {\n', '          ( name, surname, genes, , ,  , , ,  gender)=CelBetta.getPerson(i,false);\n', '         _birthPerson(name, surname ,genes, gender, false);\n', '      }\n', '  }\n', '  function CelebrityBreederToken() public { \n', '      CeoAddress= msg.sender;\n', '      DevAddress= msg.sender;\n', '  }\n', '    function setBreedingFee(uint256 newfee) external onlyCEO{\n', '      breedingFee=newfee;\n', '  }\n', '  function allowexternalContract(address _to, uint256 _tokenId,bool _tokengeneration) public { \n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId, _tokengeneration));\n', '    \n', '    if(_tokengeneration) {\n', '        if(_addressNotNull(_to)) {\n', '            ExternalAllowdContractGen1[_tokenId]=_to;\n', '        }\n', '        else {\n', '             delete ExternalAllowdContractGen1[_tokenId];\n', '        }\n', '    }\n', '    else {\n', '       if(_addressNotNull(_to)) {\n', '            ExternalAllowdContractGen0[_tokenId]=_to;\n', '        }\n', '        else {\n', '             delete ExternalAllowdContractGen0[_tokenId];\n', '        }\n', '    }\n', '\n', '  }\n', '  \n', '  \n', '  //@Artyom Required for ERC-721 compliance.\n', '  function approve(address _to, uint256 _tokenId) public { //@Artyom only gen1\n', '    // Caller must own token.\n', '    require(_owns(msg.sender, _tokenId, true));\n', '\n', '    personIndexToApprovedGen1[_tokenId] = _to;\n', '\n', '    Approval(msg.sender, _to, _tokenId);\n', '  }\n', '  // @Artyom Required for ERC-721 compliance.\n', '  //@Artyom only gen1\n', '   function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return ownershipTokenCountGen1[_owner];\n', '  }\n', '  \n', '    function getPerson(uint256 _tokenId,bool generation) public view returns ( string name, string surname, uint64 genes,uint64 birthTime, uint32 readyToBreedWithId, uint32 trainedcount,uint32 beatencount,bool readyToBreedWithGen, bool gender) {\n', '    Person person;\n', '    if(generation==false) {\n', '        person = PersonsGen0[_tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_tokenId];\n', '    }\n', '         \n', '    name = person.name;\n', '    surname=person.surname;\n', '    genes=person.genes;\n', '    birthTime=person.birthTime;\n', '    readyToBreedWithId=person.readyToBreedWithId;\n', '    trainedcount=person.trainedcount;\n', '    beatencount=person.beatencount;\n', '    readyToBreedWithGen=person.readyToBreedWithGen;\n', '    gender=person.gender;\n', '\n', '  }\n', '   function getPersonParents(uint256 _tokenId, bool generation) public view returns ( uint32 fatherId, uint32 motherId, bool fatherGeneration, bool motherGeneration) {\n', '    Person person;\n', '    if(generation==false) {\n', '        person = PersonsGen0[_tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_tokenId];\n', '    }\n', '         \n', '    fatherId=person.fatherId;\n', '    motherId=person.motherId;\n', '    fatherGeneration=person.fatherGeneration;\n', '    motherGeneration=person.motherGeneration;\n', '  }\n', '  // @Artyom Required for ERC-721 compliance.\n', '   function implementsERC721() public pure returns (bool) { \n', '    return true;\n', '  }\n', '\n', '  // @Artyom Required for ERC-721 compliance.\n', '  function name() public pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '// @Artyom Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId) public view returns (address owner)\n', '  {\n', '    owner = personIndexToOwnerGen1[_tokenId];\n', '    require(_addressNotNull(owner));\n', '  }\n', '  \n', '  //@Artyom only gen1\n', '   function purchase(uint256 _tokenId) public payable {\n', '    address oldOwner = personIndexToOwnerGen1[_tokenId];\n', '    address newOwner = msg.sender;\n', '\n', '    uint256 sellingPrice = personIndexToPriceGen1[_tokenId];\n', '    personIndexToPriceGen1[_tokenId]=MaxValue;\n', '\n', '    // Making sure token owner is not sending to self\n', '    require(oldOwner != newOwner);\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure sent amount is greater than or equal to the sellingPrice\n', '    require(msg.value >= sellingPrice);\n', '\n', '   // uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 94), 100));\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '\n', '    // Pay previous tokenOwner if owner is not contract\n', '    if (oldOwner != address(this)) {\n', '    //  oldOwner.transfer(payment); //(1-0.06) //old code for holding some percents\n', '    oldOwner.transfer(sellingPrice);\n', '    }\n', '    blankbreedingdata(_tokenId,true);\n', '\n', '    TokenSold(_tokenId, sellingPrice, personIndexToPriceGen1[_tokenId], oldOwner, newOwner, PersonsGen1[_tokenId].name);\n', '\n', '    msg.sender.transfer(purchaseExcess);\n', '  }\n', '  \n', '   //@Artyom only gen1\n', '   function priceOf(uint256 _tokenId) public view returns (uint256 price) {\n', '    return personIndexToPriceGen1[_tokenId];\n', '  }\n', '\n', ' \n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_addressNotNull(_newCEO));\n', '\n', '    CeoAddress = _newCEO;\n', '  }\n', '\n', ' //@Artyom only gen1\n', ' function setprice(uint256 _tokenId, uint256 _price) public {\n', '    require(_owns(msg.sender, _tokenId, true));\n', '    if(_price<=0 || _price>=MaxValue) {\n', '        personIndexToPriceGen1[_tokenId]=MaxValue;\n', '    }\n', '    else {\n', '        personIndexToPriceGen1[_tokenId]=_price;\n', '    }\n', '    SellingPriceEvent(msg.sender,_tokenId,true,_price);\n', ' }\n', ' \n', '  function setDEV(address _newDEV) external onlyDEV {\n', '    require(_addressNotNull(_newDEV));\n', '\n', '    DevAddress = _newDEV;\n', '  }\n', '  \n', '    // @Artyom Required for ERC-721 compliance.\n', '  function symbol() public pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '\n', '  // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '  function takeOwnership(uint256 _tokenId) public {\n', '    address newOwner = msg.sender;\n', '    address oldOwner = personIndexToOwnerGen1[_tokenId];\n', '\n', '    // Safety check to prevent against an unexpected 0x0 default.\n', '    require(_addressNotNull(newOwner));\n', '\n', '    // Making sure transfer is approved\n', '    require(_approvedGen1(newOwner, _tokenId));\n', '\n', '    _transfer(oldOwner, newOwner, _tokenId);\n', '  }\n', '  \n', '  //@Artyom only gen1\n', '  function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) {\n', '    uint256 tokenCount = balanceOf(_owner);\n', '    if (tokenCount == 0) {\n', '        // Return an empty array\n', '      return new uint256[](0);\n', '    } \n', '    else {\n', '      uint256[] memory result = new uint256[](tokenCount);\n', '      uint256 totalPersons = totalSupply();\n', '      uint256 resultIndex = 0;\n', '\n', '      uint256 personId;\n', '      for (personId = 0; personId <= totalPersons; personId++) {\n', '        if (personIndexToOwnerGen1[personId] == _owner) {\n', '          result[resultIndex] = personId;\n', '          resultIndex++;\n', '        }\n', '      }\n', '      return result;\n', '    }\n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '   function totalSupply() public view returns (uint256 total) {\n', '    return PersonsGen1.length;\n', '  }\n', '\n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '  function transfer( address _to, uint256 _tokenId) public {\n', '    require(_owns(msg.sender, _tokenId, true));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '    require(_owns(_from, _tokenId, true));\n', '    require(_approvedGen1(_to, _tokenId));\n', '    require(_addressNotNull(_to));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '  \n', '   function _addressNotNull(address _to) private pure returns (bool) {\n', '    return _to != address(0);\n', '  }\n', '\n', '  /// For checking approval of transfer for address _to\n', '  function _approvedGen1(address _to, uint256 _tokenId) private view returns (bool) {\n', '    return personIndexToApprovedGen1[_tokenId] == _to;\n', '  }\n', '  //@Artyom only gen0\n', '   function createPersonGen0(string _name, string _surname,uint64 _genes, bool _gender) external onlyCEO returns(uint256) {\n', '    return _birthPerson(_name, _surname ,_genes, _gender, false);\n', '  }\n', '  function SetGene(uint256 tokenId,bool generation, uint64 newgene) public {\n', '     require(_owns(msg.sender, tokenId, generation) || msg.sender==CeoAddress);\n', '     require(newgene<=9999999999 && newgene>=10);\n', '     Person person; //@Artyom reference\n', '    if (generation==false) { \n', '        person = PersonsGen0[tokenId];\n', '    }\n', '    else {\n', '        person = PersonsGen1[tokenId];\n', '    }\n', '    require(person.genes<=90);\n', '     \n', '    uint64 _gene=newgene;\n', '    uint64 _pointCount=0;\n', '   \n', '   \n', '      for(uint i=0;i<10;i++) {\n', '           _pointCount+=_gene%10;\n', '           _gene=_gene/10;\n', '      }\n', '    //  log(_pointCount,person.genes);\n', '    require(_pointCount==person.genes);\n', '           \n', '    person.genes=newgene;\n', '    GenesInitialisedEvent(msg.sender,tokenId,generation,newgene);\n', '}\n', ' \n', '   function breed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool  _withpersongeneration, string _boyname, string _girlname) public payable { //@Artyom mother\n', '       require(_owns(msg.sender, _mypersonid, _mypersongeneration));\n', '       require(CreationLimitGen1>totalSupply()+1);\n', '    \n', '    //Mother\n', '    Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) { \n', '        person = PersonsGen0[_mypersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        require(person.gender==false); //@Artyom checking gender for gen1 to be mother in this case\n', '    }\n', '\n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    \n', '    uint64 genes1=person.genes;\n', '    //Father\n', '        if(_withpersongeneration==false) { \n', '        person = PersonsGen0[_withpersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_withpersonid];\n', '       \n', '    }\n', '     \n', '   \n', '     require(readyTobreed(_mypersonid, _mypersongeneration, _withpersonid,  _withpersongeneration));\n', '     require(breedingFee<=msg.value);\n', '   \n', '    \n', '    delete person.readyToBreedWithId;\n', '    person.readyToBreedWithGen=false;\n', '    \n', '   // uint64 genes2=person.genes;\n', '    \n', '       uint64 _generatedGen;\n', '       bool _gender; \n', '       (_generatedGen,_gender)=_generateGene(genes1,person.genes,_mypersonid,_withpersonid); \n', '       \n', '     if(_gender) {\n', '       _girlname=_boyname; //@Artyom if gender is true/1 then it should take the boyname\n', '     }\n', '       uint newid=_birthPerson(_girlname, person.surname, _generatedGen, _gender, true);\n', '            PersonsGen1[newid].fatherGeneration=_withpersongeneration; // @ Artyom, did here because stack too deep for function\n', '            PersonsGen1[newid].motherGeneration=_mypersongeneration;\n', '            PersonsGen1[newid].fatherId=uint32(_withpersonid); \n', '            PersonsGen1[newid].motherId=uint32(_mypersonid);\n', '        \n', '        \n', '       _payout();\n', '  }\n', '  \n', '    function breedOnAuction(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool  _withpersongeneration, string _boyname, string _girlname) public payable { //@Artyom mother\n', '       require(_owns(msg.sender, _mypersonid, _mypersongeneration));\n', '       require(CreationLimitGen1>totalSupply()+1);\n', '       require(!(_mypersonid==_withpersonid && _mypersongeneration==_withpersongeneration));// @Artyom not to breed with self\n', '       require(!((_mypersonid==0 && _mypersongeneration==false) || (_withpersonid==0 && _withpersongeneration==false))); //Not to touch Satoshi\n', '    //Mother\n', '    Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) { \n', '        person = PersonsGen0[_mypersonid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        require(person.gender==false); //@Artyom checking gender for gen1 to be mother in this case\n', '    }\n', '    \n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    \n', '    address owneroffather;\n', '    uint256 _siringprice;\n', '    uint64 genes1=person.genes;\n', '    //Father\n', '        if(_withpersongeneration==false) { \n', '        person = PersonsGen0[_withpersonid];\n', '        _siringprice=personIndexToSiringPrice0[_withpersonid];\n', '        owneroffather=CelGen0.ownerOf(_withpersonid);\n', '    }\n', '    else {\n', '        person = PersonsGen1[_withpersonid];\n', '        _siringprice=personIndexToSiringPrice1[_withpersonid];\n', '        owneroffather= personIndexToOwnerGen1[_withpersonid];\n', '    }\n', '     \n', '   require(_siringprice>0 && _siringprice<MaxValue);\n', '   require((breedingFee+_siringprice)<=msg.value);\n', '    \n', '    \n', '//    uint64 genes2=;\n', '    \n', '       uint64 _generatedGen;\n', '       bool _gender; \n', '       (_generatedGen,_gender)=_generateGene(genes1,person.genes,_mypersonid,_withpersonid); \n', '       \n', '     if(_gender) {\n', '       _girlname=_boyname; //@Artyom if gender is true/1 then it should take the boyname\n', '     }\n', '       uint newid=_birthPerson(_girlname, person.surname, _generatedGen, _gender, true);\n', '            PersonsGen1[newid].fatherGeneration=_withpersongeneration; // @ Artyom, did here because stack too deep for function\n', '            PersonsGen1[newid].motherGeneration=_mypersongeneration;\n', '            PersonsGen1[newid].fatherId=uint32(_withpersonid); \n', '            PersonsGen1[newid].motherId=uint32(_mypersonid);\n', '        \n', '        \n', '        owneroffather.transfer(_siringprice);\n', '       _payout();\n', '  }\n', ' \n', '  \n', '  \n', '  function prepareToBreed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool _withpersongeneration, uint256 _siringprice) external { //@Artyom father\n', '      require(_owns(msg.sender, _mypersonid, _mypersongeneration)); \n', '      \n', '       Person person; //@Artyom reference\n', '    if(_mypersongeneration==false) {\n', '        person = PersonsGen0[_mypersonid];\n', '        personIndexToSiringPrice0[_mypersonid]=_siringprice;\n', '    }\n', '    else {\n', '        person = PersonsGen1[_mypersonid];\n', '        \n', '        require(person.gender==true);//@Artyom for gen1 checking genders to be male\n', '        personIndexToSiringPrice1[_mypersonid]=_siringprice;\n', '    }\n', '      require(person.genes>90);//@Artyom if its unlocked\n', '\n', '       person.readyToBreedWithId=uint32(_withpersonid); \n', '       person.readyToBreedWithGen=_withpersongeneration;\n', '       SiringPriceEvent(msg.sender,_mypersonid,_mypersongeneration,_siringprice);\n', '      \n', '  }\n', '  \n', '  function readyTobreed(uint256 _mypersonid, bool _mypersongeneration, uint256 _withpersonid, bool _withpersongeneration) public view returns(bool) {\n', '\n', 'if (_mypersonid==_withpersonid && _mypersongeneration==_withpersongeneration) //Not to fuck Themselves \n', 'return false;\n', '\n', 'if((_mypersonid==0 && _mypersongeneration==false) || (_withpersonid==0 && _withpersongeneration==false)) //Not to touch Satoshi\n', 'return false;\n', '\n', '    Person withperson; //@Artyom reference\n', '    if(_withpersongeneration==false) {\n', '        withperson = PersonsGen0[_withpersonid];\n', '    }\n', '    else {\n', '        withperson = PersonsGen1[_withpersonid];\n', '    }\n', '   \n', '   \n', '   if(withperson.readyToBreedWithGen==_mypersongeneration) {\n', '       if(withperson.readyToBreedWithId==_mypersonid) {\n', '       return true;\n', '   }\n', '   }\n', '  \n', '    \n', '    return false;\n', '    \n', '  }\n', '  function _birthPerson(string _name, string _surname, uint64 _genes, bool _gender, bool _generation) private returns(uint256) { // about this steps   \n', '    Person memory _person = Person({\n', '        name: _name,\n', '        surname: _surname,\n', '        genes: _genes,\n', '        birthTime: uint64(now),\n', '        fatherId: 0,\n', '        motherId: 0,\n', '        readyToBreedWithId: 0,\n', '        trainedcount: 0,\n', '        beatencount: 0,\n', '        readyToBreedWithGen: false,\n', '        gender: _gender,\n', '        fatherGeneration: false,\n', '        motherGeneration: false\n', '\n', '        \n', '    });\n', '    \n', '    uint256 newPersonId;\n', '    if(_generation==false) {\n', '         newPersonId = PersonsGen0.push(_person) - 1;\n', '    }\n', '    else {\n', '         newPersonId = PersonsGen1.push(_person) - 1;\n', '         personIndexToPriceGen1[newPersonId] = MaxValue; //@Artyom indicating not for sale\n', '          // per ERC721 draft-This will assign ownership, and also emit the Transfer event as\n', '        _transfer(address(0), msg.sender, newPersonId);\n', '        \n', '\n', '    }\n', '\n', '    Birth(newPersonId, _name, msg.sender);\n', '    return newPersonId;\n', '  }\n', '  function _generateGene(uint64 _genes1,uint64 _genes2,uint256 _mypersonid,uint256 _withpersonid) private returns(uint64,bool) {\n', '       uint64 _gene;\n', '       uint64 _gene1;\n', '       uint64 _gene2;\n', '       uint64 _rand;\n', '       uint256 _finalGene=0;\n', '       bool gender=false;\n', '\n', '       for(uint i=0;i<10;i++) {\n', '           _gene1 =_genes1%10;\n', '           _gene2=_genes2%10;\n', '           _genes1=_genes1/10;\n', '           _genes2=_genes2/10;\n', '           _rand=uint64(keccak256(block.blockhash(block.number), i, now,_mypersonid,_withpersonid))%10000;\n', '           \n', '          _gene=(_gene1+_gene2)/2;\n', '           \n', '           if(_rand<26) {\n', '               _gene-=3;\n', '           }\n', '            else if(_rand<455) {\n', '                _gene-=2;\n', '           }\n', '            else if(_rand<3173) {\n', '                _gene-=1;\n', '           }\n', '            else if(_rand<6827) {\n', '                \n', '           }\n', '            else if(_rand<9545) {\n', '                _gene+=1;\n', '           }\n', '            else if(_rand<9974) {\n', '                _gene+=2;\n', '           }\n', '            else if(_rand<10000) {\n', '                _gene+=3;\n', '           }\n', '           \n', '           if(_gene>12) //@Artyom to avoid negative overflow\n', '           _gene=0;\n', '           if(_gene>9)\n', '           _gene=9;\n', '           \n', '           _finalGene+=(uint(10)**i)*_gene;\n', '       }\n', '      \n', '      if(uint64(keccak256(block.blockhash(block.number), 11, now,_mypersonid,_withpersonid))%2>0)\n', '      gender=true;\n', '      \n', '      return(uint64(_finalGene),gender);  \n', '  } \n', '  function _owns(address claimant, uint256 _tokenId,bool _tokengeneration) private view returns (bool) {\n', '   if(_tokengeneration) {\n', '        return ((claimant == personIndexToOwnerGen1[_tokenId]) || (claimant==ExternalAllowdContractGen1[_tokenId]));\n', '   }\n', '   else {\n', '       return ((claimant == CelGen0.personIndexToOwner(_tokenId)) || (claimant==ExternalAllowdContractGen0[_tokenId]));\n', '   }\n', '  }\n', '      \n', '  function _payout() private {\n', '    DevAddress.transfer((this.balance/10)*3);\n', '    CeoAddress.transfer((this.balance/10)*7); \n', '  }\n', '  \n', '   // @Artyom Required for ERC-721 compliance.\n', '   //@Artyom only gen1\n', '   function _transfer(address _from, address _to, uint256 _tokenId) private {\n', "    // Since the number of persons is capped to 2^32 we can't overflow this\n", '    ownershipTokenCountGen1[_to]++;\n', '    //transfer ownership\n', '    personIndexToOwnerGen1[_tokenId] = _to;\n', '\n', "    // When creating new persons _from is 0x0, but we can't account that address.\n", '    if (_addressNotNull(_from)) {\n', '      ownershipTokenCountGen1[_from]--;\n', '      // clear any previously approved ownership exchange\n', '     blankbreedingdata(_tokenId,true);\n', '    }\n', '\n', '    // Emit the transfer event.\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '  function blankbreedingdata(uint256 _personid, bool _persongeneration) private{\n', '      Person person;\n', '      if(_persongeneration==false) { \n', '        person = PersonsGen0[_personid];\n', '        delete ExternalAllowdContractGen0[_personid];\n', '        delete personIndexToSiringPrice0[_personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[_personid];\n', '        delete ExternalAllowdContractGen1[_personid];\n', '        delete personIndexToSiringPrice1[_personid];\n', '    \tdelete personIndexToApprovedGen1[_personid];\n', '    }\n', '     delete person.readyToBreedWithId;\n', '     delete person.readyToBreedWithGen; \n', '  }\n', '    function train(uint256 personid, bool persongeneration, uint8 gene) external payable onlyPlayers {\n', '        \n', '        require(gene>=0 && gene<10);\n', '        uint256 trainingPrice=checkTrainingPrice(personid,persongeneration);\n', '        require(msg.value >= trainingPrice);\n', '         Person person; \n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '     require(person.genes>90);//@Artyom if its unlocked\n', '     uint gensolo=person.genes/(uint(10)**gene);\n', '    gensolo=gensolo%10;\n', '    require(gensolo<9); //@Artyom not to train after 9\n', '    \n', '          person.genes+=uint64(10)**gene;\n', '          person.trainedcount++;\n', '\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, trainingPrice);\n', '    msg.sender.transfer(purchaseExcess);\n', '    _payout();\n', '    Trained(msg.sender, personid, persongeneration);\n', '    }\n', '    \n', '     function beat(uint256 personid, bool persongeneration, uint8 gene) external payable onlyPlayers {\n', '        require(gene>=0 && gene<10);\n', '        uint256 beatingPrice=checkBeatingPrice(personid,persongeneration);\n', '        require(msg.value >= beatingPrice);\n', '         Person person; \n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '    require(person.genes>90);//@Artyom if its unlocked\n', '    uint gensolo=person.genes/(uint(10)**gene);\n', '    gensolo=gensolo%10;\n', '    require(gensolo>0);\n', '          person.genes-=uint64(10)**gene;\n', '          person.beatencount++;\n', '\n', '    uint256 purchaseExcess = SafeMath.sub(msg.value, beatingPrice);\n', '    msg.sender.transfer(purchaseExcess);\n', '    _payout();\n', '    Beaten(msg.sender, personid, persongeneration);    \n', '    }\n', '    \n', '    \n', '    function checkTrainingPrice(uint256 personid, bool persongeneration) view returns (uint256) {\n', '         Person person;\n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    \n', '    uint256 _trainingprice= (uint(2)**person.trainedcount) * initialTraining;\n', '    if (_trainingprice > 5 ether)\n', '    _trainingprice=5 ether;\n', '    \n', '    return _trainingprice;\n', '    }\n', '    function checkBeatingPrice(uint256 personid, bool persongeneration) view returns (uint256) {\n', '         Person person;\n', '    if(persongeneration==false) {\n', '        person = PersonsGen0[personid];\n', '    }\n', '    else {\n', '        person = PersonsGen1[personid];\n', '    }\n', '    uint256 _beatingprice=(uint(2)**person.beatencount) * initialBeating;\n', '     if (_beatingprice > 7 ether)\n', '    _beatingprice=7 ether;\n', '    return _beatingprice;\n', '    } \n', '  \n', '}']
