['pragma solidity ^0.4.17;\n', '\n', 'contract TinyProxy {\n', '  address public receiver;\n', '  uint public gasBudget;\n', '\n', '  function TinyProxy(address toAddr, uint proxyGas) public {\n', '    receiver = toAddr;\n', '    gasBudget = proxyGas;\n', '  }\n', '\n', '  event FundsReceived(uint amount);\n', '  event FundsReleased(address to, uint amount);\n', '\n', '  function () payable public {\n', '    emit FundsReceived(msg.value);\n', '  }\n', '\n', '  function release() public {\n', '    uint balance = address(this).balance;\n', '    if(gasBudget > 0){\n', '      require(receiver.call.gas(gasBudget).value(balance)());\n', '    } else {\n', '      require(receiver.send(balance));\n', '    }\n', '    emit FundsReleased(receiver, balance);\n', '  }\n', '}\n', '\n', 'contract TinyProxyFactory {\n', '  mapping(address => mapping(uint => address)) public proxyFor;\n', '  mapping(address => address[]) public userProxies;\n', '\n', '  event ProxyDeployed(address to, uint gas);\n', '  function make(address to, uint gas, bool track) public returns(address proxy){\n', '    proxy = proxyFor[to][gas];\n', '    if(proxy == 0x0) {\n', '      proxy = new TinyProxy(to, gas);\n', '      proxyFor[to][gas] = proxy;\n', '      emit ProxyDeployed(to, gas);\n', '    }\n', '    if(track) {\n', '      userProxies[msg.sender].push(proxy);\n', '    }\n', '    return proxy;\n', '  }\n', '\n', '  function untrack(uint index) public {\n', '    uint lastProxy = userProxies[msg.sender].length - 1;\n', '    userProxies[msg.sender][index] = userProxies[msg.sender][lastProxy];\n', '    delete userProxies[msg.sender][lastProxy];\n', '  }\n', '}']
['pragma solidity ^0.4.17;\n', '\n', 'contract TinyProxy {\n', '  address public receiver;\n', '  uint public gasBudget;\n', '\n', '  function TinyProxy(address toAddr, uint proxyGas) public {\n', '    receiver = toAddr;\n', '    gasBudget = proxyGas;\n', '  }\n', '\n', '  event FundsReceived(uint amount);\n', '  event FundsReleased(address to, uint amount);\n', '\n', '  function () payable public {\n', '    emit FundsReceived(msg.value);\n', '  }\n', '\n', '  function release() public {\n', '    uint balance = address(this).balance;\n', '    if(gasBudget > 0){\n', '      require(receiver.call.gas(gasBudget).value(balance)());\n', '    } else {\n', '      require(receiver.send(balance));\n', '    }\n', '    emit FundsReleased(receiver, balance);\n', '  }\n', '}\n', '\n', 'contract TinyProxyFactory {\n', '  mapping(address => mapping(uint => address)) public proxyFor;\n', '  mapping(address => address[]) public userProxies;\n', '\n', '  event ProxyDeployed(address to, uint gas);\n', '  function make(address to, uint gas, bool track) public returns(address proxy){\n', '    proxy = proxyFor[to][gas];\n', '    if(proxy == 0x0) {\n', '      proxy = new TinyProxy(to, gas);\n', '      proxyFor[to][gas] = proxy;\n', '      emit ProxyDeployed(to, gas);\n', '    }\n', '    if(track) {\n', '      userProxies[msg.sender].push(proxy);\n', '    }\n', '    return proxy;\n', '  }\n', '\n', '  function untrack(uint index) public {\n', '    uint lastProxy = userProxies[msg.sender].length - 1;\n', '    userProxies[msg.sender][index] = userProxies[msg.sender][lastProxy];\n', '    delete userProxies[msg.sender][lastProxy];\n', '  }\n', '}']
