['pragma solidity 0.4.24;\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract EnsOwnerProxy is hasAdmins {\n', '    bytes32 public ensNode;\n', '    ENSIface public ens;\n', '    PublicResolver public resolver;\n', '\n', '    /**\n', '     * @param _ensNode The node to administer\n', '     * @param _ens The ENS Registrar\n', '     * @param _resolver The ENS Resolver\n', '     */\n', '    constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\n', '        ensNode = _ensNode;\n', '        ens = _ens;\n', '        resolver = _resolver;\n', '    }\n', '\n', '    function setAddr(address addr) only_admin() external {\n', '        _setAddr(addr);\n', '    }\n', '\n', '    function _setAddr(address addr) internal {\n', '        resolver.setAddr(ensNode, addr);\n', '    }\n', '\n', '    function returnToOwner() only_owner() external {\n', '        ens.setOwner(ensNode, owner);\n', '    }\n', '\n', '    function fwdToENS(bytes data) only_owner() external {\n', '        require(address(ens).call(data), "fwding to ens failed");\n', '    }\n', '\n', '    function fwdToResolver(bytes data) only_owner() external {\n', '        require(address(resolver).call(data), "fwding to resolver failed");\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface SvEnsIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'interface ENSIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'contract PublicResolver {\n', '\n', '    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n', '    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n', '    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n', '    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n', '    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n', '    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n', '    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n', '\n', '    event AddrChanged(bytes32 indexed node, address a);\n', '    event ContentChanged(bytes32 indexed node, bytes32 hash);\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n', '    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n', '    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n', '\n', '    struct PublicKey {\n', '        bytes32 x;\n', '        bytes32 y;\n', '    }\n', '\n', '    struct Record {\n', '        address addr;\n', '        bytes32 content;\n', '        string name;\n', '        PublicKey pubkey;\n', '        mapping(string=>string) text;\n', '        mapping(uint256=>bytes) abis;\n', '    }\n', '\n', '    ENSIface ens;\n', '\n', '    mapping (bytes32 => Record) records;\n', '\n', '    modifier only_owner(bytes32 node) {\n', '        require(ens.owner(node) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor.\n', '     * @param ensAddr The ENS registrar contract.\n', '     */\n', '    constructor(ENSIface ensAddr) public {\n', '        ens = ensAddr;\n', '    }\n', '\n', '    /**\n', '     * Sets the address associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param addr The address to set.\n', '     */\n', '    function setAddr(bytes32 node, address addr) public only_owner(node) {\n', '        records[node].addr = addr;\n', '        emit AddrChanged(node, addr);\n', '    }\n', '\n', '    /**\n', '     * Sets the content hash associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The node to update.\n', '     * @param hash The content hash to set\n', '     */\n', '    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n', '        records[node].content = hash;\n', '        emit ContentChanged(node, hash);\n', '    }\n', '\n', '    /**\n', '     * Sets the name associated with an ENS node, for reverse records.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param name The name to set.\n', '     */\n', '    function setName(bytes32 node, string name) public only_owner(node) {\n', '        records[node].name = name;\n', '        emit NameChanged(node, name);\n', '    }\n', '\n', '    /**\n', '     * Sets the ABI associated with an ENS node.\n', '     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n', '     * the empty string.\n', '     * @param node The node to update.\n', '     * @param contentType The content type of the ABI\n', '     * @param data The ABI data.\n', '     */\n', '    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n', '        // Content types must be powers of 2\n', '        require(((contentType - 1) & contentType) == 0);\n', '\n', '        records[node].abis[contentType] = data;\n', '        emit ABIChanged(node, contentType);\n', '    }\n', '\n', '    /**\n', '     * Sets the SECP256k1 public key associated with an ENS node.\n', '     * @param node The ENS node to query\n', '     * @param x the X coordinate of the curve point for the public key.\n', '     * @param y the Y coordinate of the curve point for the public key.\n', '     */\n', '    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n', '        records[node].pubkey = PublicKey(x, y);\n', '        emit PubkeyChanged(node, x, y);\n', '    }\n', '\n', '    /**\n', '     * Sets the text data associated with an ENS node and key.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param key The key to set.\n', '     * @param value The text data value to set.\n', '     */\n', '    function setText(bytes32 node, string key, string value) public only_owner(node) {\n', '        records[node].text[key] = value;\n', '        emit TextChanged(node, key, key);\n', '    }\n', '\n', '    /**\n', '     * Returns the text data associated with an ENS node and key.\n', '     * @param node The ENS node to query.\n', '     * @param key The text data key to query.\n', '     * @return The associated text data.\n', '     */\n', '    function text(bytes32 node, string key) public view returns (string) {\n', '        return records[node].text[key];\n', '    }\n', '\n', '    /**\n', '     * Returns the SECP256k1 public key associated with an ENS node.\n', '     * Defined in EIP 619.\n', '     * @param node The ENS node to query\n', '     * @return x, y the X and Y coordinates of the curve point for the public key.\n', '     */\n', '    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n', '        return (records[node].pubkey.x, records[node].pubkey.y);\n', '    }\n', '\n', '    /**\n', '     * Returns the ABI associated with an ENS node.\n', '     * Defined in EIP205.\n', '     * @param node The ENS node to query\n', '     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n', '     * @return contentType The content type of the return value\n', '     * @return data The ABI data\n', '     */\n', '    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n', '        Record storage record = records[node];\n', '        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n', '            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n', '                data = record.abis[contentType];\n', '                return;\n', '            }\n', '        }\n', '        contentType = 0;\n', '    }\n', '\n', '    /**\n', '     * Returns the name associated with an ENS node, for reverse records.\n', '     * Defined in EIP181.\n', '     * @param node The ENS node to query.\n', '     * @return The associated name.\n', '     */\n', '    function name(bytes32 node) public view returns (string) {\n', '        return records[node].name;\n', '    }\n', '\n', '    /**\n', '     * Returns the content hash associated with an ENS node.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The ENS node to query.\n', '     * @return The associated content hash.\n', '     */\n', '    function content(bytes32 node) public view returns (bytes32) {\n', '        return records[node].content;\n', '    }\n', '\n', '    /**\n', '     * Returns the address associated with an ENS node.\n', '     * @param node The ENS node to query.\n', '     * @return The associated address.\n', '     */\n', '    function addr(bytes32 node) public view returns (address) {\n', '        return records[node].addr;\n', '    }\n', '\n', '    /**\n', '     * Returns true if the resolver implements the interface specified by the provided hash.\n', '     * @param interfaceID The ID of the interface to check for.\n', '     * @return True if the contract implements the requested interface.\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n', '        return interfaceID == ADDR_INTERFACE_ID ||\n', '        interfaceID == CONTENT_INTERFACE_ID ||\n', '        interfaceID == NAME_INTERFACE_ID ||\n', '        interfaceID == ABI_INTERFACE_ID ||\n', '        interfaceID == PUBKEY_INTERFACE_ID ||\n', '        interfaceID == TEXT_INTERFACE_ID ||\n', '        interfaceID == INTERFACE_META_ID;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', "    // but reentrency is bad, so here's a mutex.\n", '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner\'s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract EnsOwnerProxy is hasAdmins {\n', '    bytes32 public ensNode;\n', '    ENSIface public ens;\n', '    PublicResolver public resolver;\n', '\n', '    /**\n', '     * @param _ensNode The node to administer\n', '     * @param _ens The ENS Registrar\n', '     * @param _resolver The ENS Resolver\n', '     */\n', '    constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\n', '        ensNode = _ensNode;\n', '        ens = _ens;\n', '        resolver = _resolver;\n', '    }\n', '\n', '    function setAddr(address addr) only_admin() external {\n', '        _setAddr(addr);\n', '    }\n', '\n', '    function _setAddr(address addr) internal {\n', '        resolver.setAddr(ensNode, addr);\n', '    }\n', '\n', '    function returnToOwner() only_owner() external {\n', '        ens.setOwner(ensNode, owner);\n', '    }\n', '\n', '    function fwdToENS(bytes data) only_owner() external {\n', '        require(address(ens).call(data), "fwding to ens failed");\n', '    }\n', '\n', '    function fwdToResolver(bytes data) only_owner() external {\n', '        require(address(resolver).call(data), "fwding to resolver failed");\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface SvEnsIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'interface ENSIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'contract PublicResolver {\n', '\n', '    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n', '    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n', '    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n', '    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n', '    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n', '    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n', '    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n', '\n', '    event AddrChanged(bytes32 indexed node, address a);\n', '    event ContentChanged(bytes32 indexed node, bytes32 hash);\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n', '    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n', '    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n', '\n', '    struct PublicKey {\n', '        bytes32 x;\n', '        bytes32 y;\n', '    }\n', '\n', '    struct Record {\n', '        address addr;\n', '        bytes32 content;\n', '        string name;\n', '        PublicKey pubkey;\n', '        mapping(string=>string) text;\n', '        mapping(uint256=>bytes) abis;\n', '    }\n', '\n', '    ENSIface ens;\n', '\n', '    mapping (bytes32 => Record) records;\n', '\n', '    modifier only_owner(bytes32 node) {\n', '        require(ens.owner(node) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor.\n', '     * @param ensAddr The ENS registrar contract.\n', '     */\n', '    constructor(ENSIface ensAddr) public {\n', '        ens = ensAddr;\n', '    }\n', '\n', '    /**\n', '     * Sets the address associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param addr The address to set.\n', '     */\n', '    function setAddr(bytes32 node, address addr) public only_owner(node) {\n', '        records[node].addr = addr;\n', '        emit AddrChanged(node, addr);\n', '    }\n', '\n', '    /**\n', '     * Sets the content hash associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The node to update.\n', '     * @param hash The content hash to set\n', '     */\n', '    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n', '        records[node].content = hash;\n', '        emit ContentChanged(node, hash);\n', '    }\n', '\n', '    /**\n', '     * Sets the name associated with an ENS node, for reverse records.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param name The name to set.\n', '     */\n', '    function setName(bytes32 node, string name) public only_owner(node) {\n', '        records[node].name = name;\n', '        emit NameChanged(node, name);\n', '    }\n', '\n', '    /**\n', '     * Sets the ABI associated with an ENS node.\n', '     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n', '     * the empty string.\n', '     * @param node The node to update.\n', '     * @param contentType The content type of the ABI\n', '     * @param data The ABI data.\n', '     */\n', '    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n', '        // Content types must be powers of 2\n', '        require(((contentType - 1) & contentType) == 0);\n', '\n', '        records[node].abis[contentType] = data;\n', '        emit ABIChanged(node, contentType);\n', '    }\n', '\n', '    /**\n', '     * Sets the SECP256k1 public key associated with an ENS node.\n', '     * @param node The ENS node to query\n', '     * @param x the X coordinate of the curve point for the public key.\n', '     * @param y the Y coordinate of the curve point for the public key.\n', '     */\n', '    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n', '        records[node].pubkey = PublicKey(x, y);\n', '        emit PubkeyChanged(node, x, y);\n', '    }\n', '\n', '    /**\n', '     * Sets the text data associated with an ENS node and key.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param key The key to set.\n', '     * @param value The text data value to set.\n', '     */\n', '    function setText(bytes32 node, string key, string value) public only_owner(node) {\n', '        records[node].text[key] = value;\n', '        emit TextChanged(node, key, key);\n', '    }\n', '\n', '    /**\n', '     * Returns the text data associated with an ENS node and key.\n', '     * @param node The ENS node to query.\n', '     * @param key The text data key to query.\n', '     * @return The associated text data.\n', '     */\n', '    function text(bytes32 node, string key) public view returns (string) {\n', '        return records[node].text[key];\n', '    }\n', '\n', '    /**\n', '     * Returns the SECP256k1 public key associated with an ENS node.\n', '     * Defined in EIP 619.\n', '     * @param node The ENS node to query\n', '     * @return x, y the X and Y coordinates of the curve point for the public key.\n', '     */\n', '    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n', '        return (records[node].pubkey.x, records[node].pubkey.y);\n', '    }\n', '\n', '    /**\n', '     * Returns the ABI associated with an ENS node.\n', '     * Defined in EIP205.\n', '     * @param node The ENS node to query\n', '     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n', '     * @return contentType The content type of the return value\n', '     * @return data The ABI data\n', '     */\n', '    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n', '        Record storage record = records[node];\n', '        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n', '            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n', '                data = record.abis[contentType];\n', '                return;\n', '            }\n', '        }\n', '        contentType = 0;\n', '    }\n', '\n', '    /**\n', '     * Returns the name associated with an ENS node, for reverse records.\n', '     * Defined in EIP181.\n', '     * @param node The ENS node to query.\n', '     * @return The associated name.\n', '     */\n', '    function name(bytes32 node) public view returns (string) {\n', '        return records[node].name;\n', '    }\n', '\n', '    /**\n', '     * Returns the content hash associated with an ENS node.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The ENS node to query.\n', '     * @return The associated content hash.\n', '     */\n', '    function content(bytes32 node) public view returns (bytes32) {\n', '        return records[node].content;\n', '    }\n', '\n', '    /**\n', '     * Returns the address associated with an ENS node.\n', '     * @param node The ENS node to query.\n', '     * @return The associated address.\n', '     */\n', '    function addr(bytes32 node) public view returns (address) {\n', '        return records[node].addr;\n', '    }\n', '\n', '    /**\n', '     * Returns true if the resolver implements the interface specified by the provided hash.\n', '     * @param interfaceID The ID of the interface to check for.\n', '     * @return True if the contract implements the requested interface.\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n', '        return interfaceID == ADDR_INTERFACE_ID ||\n', '        interfaceID == CONTENT_INTERFACE_ID ||\n', '        interfaceID == NAME_INTERFACE_ID ||\n', '        interfaceID == ABI_INTERFACE_ID ||\n', '        interfaceID == PUBKEY_INTERFACE_ID ||\n', '        interfaceID == TEXT_INTERFACE_ID ||\n', '        interfaceID == INTERFACE_META_ID;\n', '    }\n', '}']
