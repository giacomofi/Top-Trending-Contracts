['pragma solidity ^0.4.18;\n', '\n', '\n', ' \n', '\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '\n', '        c = a + b;\n', '\n', '        require(c >= a);\n', '\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '\n', '        require(b <= a);\n', '\n', '        c = a - b;\n', '\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '\n', '        c = a * b;\n', '\n', '        require(a == 0 || c / a == b);\n', '\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '\n', '        require(b > 0);\n', '\n', '        c = a / b;\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '/*\n', '\n', 'This is a King Of The Hill contract which requires Proof of Work (hashpower) to set the king\n', '\n', 'This global non-owned contract proxy-mints 0xBTC through a personally-owned mintHelper contract (MintHelper.sol)\n', '\n', '*/\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', 'contract ERC918Interface {\n', '\n', '  function epochCount() public constant returns (uint);\n', '\n', '  function totalSupply() public constant returns (uint);\n', '  function getMiningDifficulty() public constant returns (uint);\n', '  function getMiningTarget() public constant returns (uint);\n', '  function getMiningReward() public constant returns (uint);\n', '  function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '\n', '  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '\n', '  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '}\n', '\n', '\n', '\n', 'contract proxyMinterInterface\n', '{\n', '  function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '}\n', '\n', '\n', 'contract MiningKing   {\n', '\n', '\n', '  using SafeMath for uint;\n', '\n', '\n', '   address public miningKing;\n', '\n', '   address public minedToken;\n', '\n', '\n', '   event TransferKing(address from, address to);\n', '\n', '   // 0xBTC is 0xb6ed7644c69416d67b522e20bc294a9a9b405b31;\n', '  constructor(address mintableToken) public  {\n', '    minedToken = mintableToken;\n', '  }\n', '\n', '\n', '  //do not allow ether to enter\n', '  function() public payable {\n', '      revert();\n', '  }\n', '\n', '  function getKing() public returns (address king)\n', '  {\n', '    return miningKing;\n', '  }\n', '\n', '   function transferKing(address newKing) public   {\n', '\n', '       require(msg.sender == miningKing);\n', '\n', '       miningKing = newKing;\n', '\n', '       TransferKing(msg.sender, newKing);\n', '\n', '   }\n', '\n', '\n', '/**\n', 'Set the king to the Ethereum Address which is encoded as 160 bits of the 256 bit mining nonce\n', '\n', '\n', '**/\n', '\n', '//proxyMintWithKing\n', '   function mintForwarder(uint256 nonce, bytes32 challenge_digest, address proxyMinter) returns (bool)\n', '   {\n', '\n', '      bytes memory nonceBytes = uintToBytesForAddress(nonce);\n', '\n', '      address newKing = bytesToAddress(nonceBytes);\n', '\n', '      uint previousEpochCount = ERC918Interface(minedToken).epochCount();\n', '\n', '      //Forward to another contract, typically a pool&#39;s owned  mint contract\n', '      require(proxyMinterInterface(proxyMinter).proxyMint(nonce, challenge_digest));\n', '\n', '     //make sure that the minedToken really was proxy minted through the proxyMint delegate call chain\n', '      require(  ERC918Interface(minedToken).epochCount() == previousEpochCount.add(1) );\n', '\n', '      miningKing = newKing;\n', '\n', '      return true;\n', '   }\n', '\n', '\n', '\n', ' function uintToBytesForAddress(uint256 x) constant returns (bytes b) {\n', '\n', '      b = new bytes(20);\n', '      for (uint i = 0; i < 20; i++) {\n', '          b[i] = byte(uint8(x / (2**(8*(31 - i)))));\n', '      }\n', '\n', '      return b;\n', '    }\n', '\n', '\n', ' function bytesToAddress (bytes b) constant returns (address) {\n', '     uint result = 0;\n', '     for (uint i = b.length-1; i+1 > 0; i--) {\n', '       uint c = uint(b[i]);\n', '       uint to_inc = c * ( 16 ** ((b.length - i-1) * 2));\n', '       result += to_inc;\n', '     }\n', '     return address(result);\n', ' }\n', '\n', '\n', '\n', '\n', '}']