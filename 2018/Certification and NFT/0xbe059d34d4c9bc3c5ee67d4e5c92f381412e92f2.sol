['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      "\\x19Ethereum Signed Message:\\n32",\n', '      hash\n', '    );\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Arbitrator is Ownable {\n', '\n', '  mapping(address => bool) private aribitratorWhitelist;\n', '  address private primaryArbitrator;\n', '\n', '  event ArbitratorAdded(address indexed newArbitrator);\n', '  event ArbitratorRemoved(address indexed newArbitrator);\n', '  event ChangePrimaryArbitratorWallet(address indexed newPrimaryWallet);\n', '\n', '  constructor() public {\n', '    primaryArbitrator = msg.sender;\n', '  }\n', '\n', '  modifier onlyArbitrator() {\n', '    require(aribitratorWhitelist[msg.sender] == true || msg.sender == primaryArbitrator);\n', '    _;\n', '  }\n', '\n', '  function changePrimaryArbitrator(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit ChangePrimaryArbitratorWallet(walletAddress);\n', '    primaryArbitrator = walletAddress;\n', '  }\n', '\n', '  function addArbitrator(address newArbitrator) public onlyOwner {\n', '    require(newArbitrator != address(0));\n', '    emit ArbitratorAdded(newArbitrator);\n', '    aribitratorWhitelist[newArbitrator] = true;\n', '  }\n', '\n', '  function deleteArbitrator(address arbitrator) public onlyOwner {\n', '    require(arbitrator != address(0));\n', '    require(arbitrator != msg.sender); //ensure owner isn&#39;t removed\n', '    emit ArbitratorRemoved(arbitrator);\n', '    delete aribitratorWhitelist[arbitrator];\n', '  }\n', '\n', '  //Mainly for front-end administration\n', '  function isArbitrator(address arbitratorCheck) external view returns(bool) {\n', '    return (aribitratorWhitelist[arbitratorCheck] || arbitratorCheck == primaryArbitrator);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ApprovedWithdrawer is Ownable {\n', '\n', '  mapping(address => bool) private withdrawerWhitelist;\n', '  address private primaryWallet;\n', '\n', '  event WalletApproved(address indexed newAddress);\n', '  event WalletRemoved(address indexed removedAddress);\n', '  event ChangePrimaryApprovedWallet(address indexed newPrimaryWallet);\n', '\n', '  constructor() public {\n', '    primaryWallet = msg.sender;\n', '  }\n', '\n', '  modifier onlyApprovedWallet(address _to) {\n', '    require(withdrawerWhitelist[_to] == true || primaryWallet == _to);\n', '    _;\n', '  }\n', '\n', '  function changePrimaryApprovedWallet(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit ChangePrimaryApprovedWallet(walletAddress);\n', '    primaryWallet = walletAddress;\n', '  }\n', '\n', '  function addApprovedWalletAddress(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit WalletApproved(walletAddress);\n', '    withdrawerWhitelist[walletAddress] = true;\n', '  }\n', '\n', '  function deleteApprovedWalletAddress(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    require(walletAddress != msg.sender); //ensure owner isn&#39;t removed\n', '    emit WalletRemoved(walletAddress);\n', '    delete withdrawerWhitelist[walletAddress];\n', '  }\n', '\n', '  //Mainly for front-end administration\n', '  function isApprovedWallet(address walletCheck) external view returns(bool) {\n', '    return (withdrawerWhitelist[walletCheck] || walletCheck == primaryWallet);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title CoinSparrow\n', ' */\n', '\n', '\n', 'contract CoinSparrow  is Ownable, Arbitrator, ApprovedWithdrawer, Pausable {\n', '\n', '  //Who wouldn&#39;t?\n', '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * ------------------------------------\n', '   * SET UP SOME CONSTANTS FOR JOB STATUS\n', '   * ------------------------------------\n', '   */\n', '\n', '  //Some of these are not used in the contract, but are for reference and are used in the front-end&#39;s database.\n', '  uint8 constant private STATUS_JOB_NOT_EXIST = 1; //Not used in contract. Here for reference (used externally)\n', '  uint8 constant private STATUS_JOB_CREATED = 2; //Job has been created. Set by createJobEscrow()\n', '  uint8 constant private STATUS_JOB_STARTED = 3; //Contractor flags job as started. Set by jobStarted()\n', '  uint8 constant private STATUS_HIRER_REQUEST_CANCEL = 4; //Hirer requested cancellation on started job.\n', '                                                  //Set by requestMutualJobCancelation()\n', '  uint8 constant private STATUS_JOB_COMPLETED = 5; //Contractor flags job as completed. Set by jobCompleted()\n', '  uint8 constant private STATUS_JOB_IN_DISPUTE = 6; //Either party raised dispute. Set by requestDispute()\n', '  uint8 constant private STATUS_HIRER_CANCELLED = 7; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_CONTRACTOR_CANCELLED = 8; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED = 9; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED_BY_CONTRACTOR = 10; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_CONTRACTOR_REQUEST_CANCEL = 11; //Contractor requested cancellation on started job.\n', '                                                        //Set by requestMutualJobCancelation()\n', '  uint8 constant private STATUS_MUTUAL_CANCELLATION_PROCESSED = 12; //Not used in contract. Here for reference\n', '\n', '  //Deployment script will check for existing CoinSparrow contracts, and only\n', '  //deploy if this value is > than existing version.\n', '  //TODO: to be implemented\n', '  uint8 constant private COINSPARROW_CONTRACT_VERSION = 1;\n', '\n', '  /**\n', '   * ------\n', '   * EVENTS\n', '   * ------\n', '   */\n', '\n', '  event JobCreated(bytes32 _jobHash, address _who, uint256 _value);\n', '  event ContractorStartedJob(bytes32 _jobHash, address _who);\n', '  event ContractorCompletedJob(bytes32 _jobHash, address _who);\n', '  event HirerRequestedCancel(bytes32 _jobHash, address _who);\n', '  event ContractorRequestedCancel(bytes32 _jobHash, address _who);\n', '  event CancelledByHirer(bytes32 _jobHash, address _who);\n', '  event CancelledByContractor(bytes32 _jobHash, address _who);\n', '  event MutuallyAgreedCancellation(\n', '    bytes32 _jobHash,\n', '    address _who,\n', '    uint256 _hirerAmount,\n', '    uint256 _contractorAmount\n', '  );\n', '  event DisputeRequested(bytes32 _jobHash, address _who);\n', '  event DisputeResolved(\n', '    bytes32 _jobHash,\n', '    address _who,\n', '    uint256 _hirerAmount,\n', '    uint256 _contractorAmount\n', '  );\n', '  event HirerReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event AddFeesToCoinSparrowPool(bytes32 _jobHash, uint256 _value);\n', '  event ContractorReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event HirerLastResortRefund(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event WithdrawFeesFromCoinSparrowPool(address _whoCalled, address _to, uint256 _amount);\n', '  event LogFallbackFunctionCalled(address _from, uint256 _amount);\n', '\n', '\n', '  /**\n', '   * ----------\n', '   * STRUCTURES\n', '   * ----------\n', '   */\n', '\n', '  /**\n', '   * @dev Structure to hold live Escrow data - current status, times etc.\n', '   */\n', '  struct JobEscrow {\n', '    // Set so we know the job has already been created. Set when job created in createJobEscrow()\n', '    bool exists;\n', '    // The timestamp after which the hirer can cancel the task if the contractor has not yet flagged as job started.\n', '    // Set in createJobEscrow(). If the Contractor has not called jobStarted() within this time, then the hirer\n', '    // can call hirerCancel() to get a full refund (minus gas fees)\n', '    uint32 hirerCanCancelAfter;\n', '    //Job&#39;s current status (see STATUS_JOB_* constants above). Updated in multiple functions\n', '    uint8 status;\n', '    //timestamp for job completion. Set when jobCompleted() is called.\n', '    uint32 jobCompleteDate;\n', '    //num agreed seconds it will take to complete the job, once flagged as STATUS_JOB_STARTED. Set in createJobEscrow()\n', '    uint32 secondsToComplete;\n', '    //timestamp calculated for agreed completion date. Set when jobStarted() is called.\n', '    uint32 agreedCompletionDate;\n', '  }\n', '\n', '  /**\n', '   * ------------------\n', '   * CONTRACT VARIABLES\n', '   * ------------------\n', '   */\n', '\n', '\n', '  //Total Wei currently held in Escrow\n', '  uint256 private totalInEscrow;\n', '  //Amount of Wei available to CoinSparrow to withdraw\n', '  uint256 private feesAvailableForWithdraw;\n', '\n', '  /*\n', '   * Set max limit for how much (in wei) contract will accept. Can be modified by owner using setMaxSend()\n', '   * This ensures that arbitrarily large amounts of ETH can&#39;t be sent.\n', '   * Front end will check this value before processing new jobs\n', '   */\n', '  uint256 private MAX_SEND;\n', '\n', '  /*\n', '   * Mapping of active jobs. Key is a hash of the job data:\n', '   * JobEscrow = keccak256(_jobId,_hirer,_contractor, _value, _fee)\n', '   * Once job is complete, and refunds released, the\n', '   * mapping for that job is deleted to conserve space.\n', '   */\n', '  mapping(bytes32 => JobEscrow) private jobEscrows;\n', '\n', '  /*\n', '   * mapping of Hirer&#39;s funds in Escrow for each job.\n', '   * This is referenced when any ETH transactions occur\n', '   */\n', '  mapping(address => mapping(bytes32 => uint256)) private hirerEscrowMap;\n', '\n', '  /**\n', '   * ---------\n', '   * MODIFIERS\n', '   * ---------\n', '   */\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Hirer can execute\n', '   * @param _hirer Address of the hirer to check against msg.sender\n', '   */\n', '\n', '  modifier onlyHirer(address _hirer) {\n', '    require(msg.sender == _hirer);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Contractor can execute\n', '   * @param _contractor Address of the contractor to check against msg.sender\n', '   */\n', '\n', '  modifier onlyContractor(address _contractor) {\n', '    require(msg.sender == _contractor);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Contractor can execute\n', '   * @param _contractor Address of the contractor to check against msg.sender\n', '   */\n', '\n', '  modifier onlyHirerOrContractor(address _hirer, address _contractor) {\n', '    require(msg.sender == _hirer || msg.sender == _contractor);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * ----------------------\n', '   * CONTRACT FUNCTIONALITY\n', '   * ----------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Constructor function for the contract\n', '   * @param _maxSend Maximum Wei the contract will accept in a transaction\n', '   */\n', '\n', '  constructor(uint256 _maxSend) public {\n', '    require(_maxSend > 0);\n', '    //a bit of protection. Set a limit, so users can&#39;t send stupid amounts of ETH\n', '    MAX_SEND = _maxSend;\n', '  }\n', '\n', '  /**\n', '   * @dev fallback function for the contract. Log event so ETH can be tracked and returned\n', '   */\n', '\n', '  function() payable {\n', '    //Log who sent, and how much so it can be returned\n', '    emit LogFallbackFunctionCalled(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new escrow and add it to the `jobEscrows` mapping.\n', '   * Also updates/creates a reference to the job, and amount in Escrow for the job in hirerEscrowMap\n', '   * jobHash is created by hashing _jobId, _seller, _buyer, _value and _fee params.\n', '   * These params must be supplied on future contract calls.\n', '   * A hash of the job parameters (_jobId, _hirer, _contractor, _value, _fee) is created and used\n', '   * to access job data held in the contract. All functions that interact with a job in Escrow\n', '   * require these parameters.\n', '   * Pausable - only runs whenNotPaused. Can pause to prevent taking any more\n', '   *            ETH if there is a problem with the Smart Contract.\n', '   *            Parties can still access/transfer their existing ETH held in Escrow, complete jobs etc.\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _jobStartedWindowInSeconds time within which the contractor must flag as job started\n', '   *                                   if job hasn&#39;t started AFTER this time, hirer can cancel contract.\n', '   *                                   Hirer cannot cancel contract before this time.\n', '   * @param _secondsToComplete agreed time to complete job once it&#39;s flagged as STATUS_JOB_STARTED\n', '   */\n', '  function createJobEscrow(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint32 _jobStartedWindowInSeconds,\n', '    uint32 _secondsToComplete\n', '  ) payable external whenNotPaused onlyHirer(_hirer)\n', '  {\n', '\n', '    // Check sent eth against _value and also make sure is not 0\n', '    require(msg.value == _value && msg.value > 0);\n', '\n', '    //CoinSparrow&#39;s Fee should be less than the Job Value, because anything else would be daft.\n', '    require(_fee < _value);\n', '\n', '    //Check the amount sent is below the acceptable threshold\n', '    require(msg.value <= MAX_SEND);\n', '\n', '    //needs to be more than 0 seconds\n', '    require(_jobStartedWindowInSeconds > 0);\n', '\n', '    //needs to be more than 0 seconds\n', '    require(_secondsToComplete > 0);\n', '\n', '    //generate the job hash. Used to reference the job in all future function calls/transactions.\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //Check that the job does not already exist.\n', '    require(!jobEscrows[jobHash].exists);\n', '\n', '    //create the job and store it in the mapping\n', '    jobEscrows[jobHash] = JobEscrow(\n', '      true,\n', '      uint32(block.timestamp) + _jobStartedWindowInSeconds,\n', '      STATUS_JOB_CREATED,\n', '      0,\n', '      _secondsToComplete,\n', '      0);\n', '\n', '    //update total held in escrow\n', '    totalInEscrow = totalInEscrow.add(msg.value);\n', '\n', '    //Update hirer&#39;s job => value mapping\n', '    hirerEscrowMap[msg.sender][jobHash] = msg.value;\n', '\n', '    //Let the world know.\n', '    emit JobCreated(jobHash, msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * -----------------------\n', '   * RELEASE FUNDS FUNCTIONS\n', '   * -----------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Release funds to contractor. Can only be called by Hirer. Can be called at any time as long as the\n', '   * job exists in the contract (for example, two parties may have agreed job is complete external to the\n', '   * CoinSparrow website). Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerReleaseFunds(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //check hirer has funds in the Smart Contract assigned to this job\n', '    require(hirerEscrowMap[msg.sender][jobHash] > 0);\n', '\n', '    //get the value from the stored hirer => job => value mapping\n', '    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '     //Log event\n', '    emit HirerReleased(\n', '      jobHash,\n', '      msg.sender,\n', '      _contractor,\n', '      jobValue);\n', '\n', '     //Log event\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    //no longer required. Remove to save storage. Also prevents reentrancy\n', '    delete jobEscrows[jobHash];\n', '    //no longer required. Remove to save storage. Also prevents reentrancy\n', '    delete hirerEscrowMap[msg.sender][jobHash];\n', '\n', '    //add to CoinSparrow&#39;s fee pool\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //Finally, transfer the funds, minus CoinSparrow fees\n', '    _contractor.transfer(jobValue.sub(_fee));\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Release funds to contractor in the event that the Hirer is unresponsive after job has been flagged as complete.\n', '   * Can only be called by the contractor, and only 4 weeks after the job has been flagged as complete.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function contractorReleaseFunds(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //check job is actually completed\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_COMPLETED);\n', '    //can only self-release 4 weeks after completion\n', '    require(block.timestamp > jobEscrows[jobHash].jobCompleteDate + 4 weeks);\n', '\n', '    //get value for job\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    emit ContractorReleased(\n', '      jobHash,\n', '      _hirer,\n', '      _contractor,\n', '      jobValue); //Log event\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\n', '    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\n', '\n', '    //add fees to coinsparrow pool\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //transfer funds to contractor, minus fees\n', '    _contractor.transfer(jobValue.sub(_fee));\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Can be called by the hirer to claim a full refund, if job has been started but contractor has not\n', '   * completed within 4 weeks after agreed completion date, and becomes unresponsive.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerLastResortRefund(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    \n', '    //check job is started\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\n', '    //can only self-refund 4 weeks after agreed completion date\n', '    require(block.timestamp > jobEscrows[jobHash].agreedCompletionDate + 4 weeks);\n', '\n', '    //get value for job\n', '    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    emit HirerLastResortRefund(\n', '      jobHash,\n', '      _hirer,\n', '      _contractor,\n', '      jobValue); //Log event\n', '\n', '    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\n', '    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //transfer funds to hirer\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * ---------------------------\n', '   * UPDATE JOB STATUS FUNCTIONS\n', '   * ---------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Flags job started, and Stops the hirer from cancelling the job.\n', '   * Can only be called the contractor when job starts.\n', '   * Used to mark the job as started. After this point, hirer must request cancellation\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function jobStarted(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    //check job status.\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\n', '    jobEscrows[jobHash].status = STATUS_JOB_STARTED; //set status\n', '    jobEscrows[jobHash].hirerCanCancelAfter = 0;\n', '    jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete;\n', '    emit ContractorStartedJob(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Flags job completed to inform hirer. Also sets flag to allow contractor to get their funds 4 weeks after\n', '   * completion in the event that the hirer is unresponsive and doesn&#39;t release the funds.\n', '   * Can only be called the contractor when job complete.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function jobCompleted(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    require(jobEscrows[jobHash].exists); //check the job exists in the contract\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED); //check job status.\n', '    jobEscrows[jobHash].status = STATUS_JOB_COMPLETED;\n', '    jobEscrows[jobHash].jobCompleteDate = uint32(block.timestamp);\n', '    emit ContractorCompletedJob(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * --------------------------\n', '   * JOB CANCELLATION FUNCTIONS\n', '   * --------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Cancels the job and returns the ether to the hirer.\n', '   * Can only be called the contractor. Can be called at any time during the process\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function contractorCancel(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '    emit CancelledByContractor(jobHash, msg.sender);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Cancels the job and returns the ether to the hirer.\n', '   * Can only be called the hirer.\n', '   * Can only be called if the job start window was missed by the contractor\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerCancel(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(jobEscrows[jobHash].hirerCanCancelAfter > 0);\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\n', '    require(jobEscrows[jobHash].hirerCanCancelAfter < block.timestamp);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[msg.sender][jobHash];\n', '    emit CancelledByHirer(jobHash, msg.sender);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the hirer or contractor to request mutual cancellation once job has started\n', '   * Can only be called when status = STATUS_JOB_STARTED\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function requestMutualJobCancellation(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirerOrContractor(_hirer, _contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\n', '\n', '    if (msg.sender == _hirer) {\n', '      jobEscrows[jobHash].status = STATUS_HIRER_REQUEST_CANCEL;\n', '      emit HirerRequestedCancel(jobHash, msg.sender);\n', '    }\n', '    if (msg.sender == _contractor) {\n', '      jobEscrows[jobHash].status = STATUS_CONTRACTOR_REQUEST_CANCEL;\n', '      emit ContractorRequestedCancel(jobHash, msg.sender);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Called when both hirer and contractor have agreed on cancellation conditions, and amount each will receive\n', '   * can be called by hirer or contractor once % amount has been signed by both parties.\n', '   * Both parties sign a hash of the % agreed upon. The signatures of both parties must be sent and verified\n', '   * before the transaction is processed, to ensure that the % processed is valid.\n', '   * can be called at any time\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _contractorPercent percentage the contractor will be paid\n', '   * @param _hirerMsgSig Signed message from hiring party agreeing on _contractorPercent\n', '   * @param _contractorMsgSig Signed message from contractor agreeing on _contractorPercent\n', '   */\n', '  function processMutuallyAgreedJobCancellation(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint8 _contractorPercent,\n', '    bytes _hirerMsgSig,\n', '    bytes _contractorMsgSig\n', '  ) external\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(msg.sender == _hirer || msg.sender == _contractor);\n', '    require(_contractorPercent <= 100 && _contractorPercent >= 0);\n', '\n', '    //Checks the signature of both parties to ensure % is correct.\n', '    //Attempts to prevent the party calling the function from modifying the pre-agreed %\n', '    require(\n', '      checkRefundSignature(_contractorPercent,_hirerMsgSig,_hirer)&&\n', '      checkRefundSignature(_contractorPercent,_contractorMsgSig,_contractor));\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '\n', '    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\n', '    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\n', '\n', '    emit MutuallyAgreedCancellation(\n', '      jobHash,\n', '      msg.sender,\n', '      hirerAmount,\n', '      contractorAmount);\n', '\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    if (contractorAmount > 0) {\n', '      _contractor.transfer(contractorAmount);\n', '    }\n', '    if (hirerAmount > 0) {\n', '      _hirer.transfer(hirerAmount);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * -------------------------\n', '   * DISPUTE RELATED FUNCTIONS\n', '   * -------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Called by hirer or contractor to raise a dispute during started, completed or canellation request statuses\n', '   * Once called, funds are locked until arbitrator can resolve the dispute. Assigned arbitrator\n', '   * will review all information relating to the job, and decide on a fair course of action.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function requestDispute(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirerOrContractor(_hirer, _contractor)\n', '  {\n', '\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    require(\n', '      jobEscrows[jobHash].status == STATUS_JOB_STARTED||\n', '      jobEscrows[jobHash].status == STATUS_JOB_COMPLETED||\n', '      jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL||\n', '      jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL);\n', '\n', '    jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE;\n', '\n', '    emit DisputeRequested(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the arbitrator to resolve a dispute\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _contractorPercent percentage the contractor will receive\n', '   */\n', '\n', '  function resolveDispute(\n', '\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint8 _contractorPercent\n', '  ) external onlyArbitrator\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_IN_DISPUTE);\n', '    require(_contractorPercent <= 100);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '    // Add the the pot for localethereum to withdraw\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '\n', '    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\n', '    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\n', '    emit DisputeResolved(\n', '      jobHash,\n', '      msg.sender,\n', '      hirerAmount,\n', '      contractorAmount);\n', '\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    _contractor.transfer(contractorAmount);\n', '    _hirer.transfer(hirerAmount);\n', '\n', '  }\n', '\n', '  /**\n', '   * ------------------------\n', '   * ADMINISTRATIVE FUNCTIONS\n', '   * ------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Allows owner to transfer funds from the collected fees pool to an approved wallet address\n', '   * @param _to receiver wallet address\n', '   * @param _amount amount to withdraw and transfer\n', '   */\n', '  function withdrawFees(address _to, uint256 _amount) onlyOwner onlyApprovedWallet(_to) external {\n', '    /**\n', '     * Withdraw fees collected by the contract. Only the owner can call this.\n', '     * Can only be sent to an approved wallet address\n', '     */\n', '    require(_amount > 0);\n', '    require(_amount <= feesAvailableForWithdraw && feesAvailableForWithdraw > 0);\n', '\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.sub(_amount);\n', '\n', '    emit WithdrawFeesFromCoinSparrowPool(msg.sender,_to, _amount);\n', '\n', '    _to.transfer(_amount);\n', '  }\n', '\n', '  /**\n', '   * @dev returns how much has been collected in fees, and how much is available to withdraw\n', '   * @return feesAvailableForWithdraw amount available for CoinSparrow to withdraw\n', '   */\n', '\n', '  function howManyFees() external view returns (uint256) {\n', '    return feesAvailableForWithdraw;\n', '  }\n', '\n', '  /**\n', '   * @dev returns how much is currently held in escrow\n', '   * @return totalInEscrow amount currently held in escrow\n', '   */\n', '\n', '  function howMuchInEscrow() external view returns (uint256) {\n', '    return totalInEscrow;\n', '  }\n', '\n', '  /**\n', '   * @dev modify the maximum amount of ETH the contract will allow in a transaction (when creating a new job)\n', '   * @param _maxSend amount in Wei\n', '   */\n', '\n', '  function setMaxSend(uint256 _maxSend) onlyOwner external {\n', '    require(_maxSend > 0);\n', '    MAX_SEND = _maxSend;\n', '  }\n', '\n', '  /**\n', '   * @dev return the current maximum amount the contract will allow in a transaction\n', '   * @return MAX_SEND current maximum value\n', '   */\n', '\n', '  function getMaxSend() external view returns (uint256) {\n', '    return MAX_SEND;\n', '  }\n', '\n', '  /**\n', '   * @dev returns THIS contract instance&#39;s version\n', '   * @return COINSPARROW_CONTRACT_VERSION version number of THIS instance of the contract\n', '   */\n', '\n', '  function getContractVersion() external pure returns(uint8) {\n', '    return COINSPARROW_CONTRACT_VERSION;\n', '  }\n', '\n', '  /**\n', '   * -------------------------\n', '   * JOB INFORMATION FUNCTIONS\n', '   * -------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev returns the status of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return status job&#39;s current status\n', '   */\n', '\n', '  function getJobStatus(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint8)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint8 status = STATUS_JOB_NOT_EXIST;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      status = jobEscrows[jobHash].status;\n', '    }\n', '    return status;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the date after which the Hirer can cancel the job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return hirerCanCancelAfter timestamp for date after which the hirer can cancel\n', '   */\n', '\n', '  function getJobCanCancelAfter(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 hirerCanCancelAfter = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      hirerCanCancelAfter = jobEscrows[jobHash].hirerCanCancelAfter;\n', '    }\n', '    return hirerCanCancelAfter;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the number of seconds for job completion\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return secondsToComplete number of seconds to complete job\n', '   */\n', '\n', '  function getSecondsToComplete(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 secondsToComplete = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      secondsToComplete = jobEscrows[jobHash].secondsToComplete;\n', '    }\n', '    return secondsToComplete;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the agreed completion date of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return agreedCompletionDate timestamp for agreed completion date\n', '   */\n', '\n', '  function getAgreedCompletionDate(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 agreedCompletionDate = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      agreedCompletionDate = jobEscrows[jobHash].agreedCompletionDate;\n', '    }\n', '    return agreedCompletionDate;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the actual completion date of the job of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return jobCompleteDate timestamp for actual completion date\n', '   */\n', '\n', '  function getActualCompletionDate(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 jobCompleteDate = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      jobCompleteDate = jobEscrows[jobHash].jobCompleteDate;\n', '    }\n', '    return jobCompleteDate;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the value for the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return amount job&#39;s value\n', '   */\n', '\n', '  function getJobValue(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns(uint256)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint256 amount = 0;\n', '    if (jobEscrows[jobHash].exists) {\n', '      amount = hirerEscrowMap[_hirer][jobHash];\n', '    }\n', '    return amount;\n', '  }\n', '\n', '  /**\n', '   * @dev Helper function to pre-validate mutual cancellation signatures. Used by front-end app\n', '   * to let each party know that the other has signed off the agreed %\n', '   * @param _contractorPercent percentage agreed upon\n', '   * @param _sigMsg signed message to be validated\n', '   * @param _signer wallet address of the message signer to validate against\n', '   * @return bool whether or not the signature is valid\n', '   */\n', '  function validateRefundSignature(\n', '    uint8 _contractorPercent,\n', '    bytes _sigMsg,\n', '    address _signer) external pure returns(bool)\n', '  {\n', '\n', '    return checkRefundSignature(_contractorPercent,_sigMsg,_signer);\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Executes the actual signature verification.\n', '   * @param _contractorPercent percentage agreed upon\n', '   * @param _sigMsg signed message to be validated\n', '   * @param _signer wallet address of the message signer to validate against\n', '   * @return bool whether or not the signature is valid\n', '   */\n', '  function checkRefundSignature(\n', '    uint8 _contractorPercent,\n', '    bytes _sigMsg,\n', '    address _signer) private pure returns(bool)\n', '  {\n', '    bytes32 percHash = keccak256(abi.encodePacked(_contractorPercent));\n', '    bytes32 msgHash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32",percHash));\n', '\n', '    address addr = ECRecovery.recover(msgHash,_sigMsg);\n', '    return addr == _signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Generates the sha256 jobHash based on job parameters. Used in several functions\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return bytes32 the calculated jobHash value\n', '   */\n', '  function getJobHash(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  )  private pure returns(bytes32)\n', '  {\n', '    return keccak256(abi.encodePacked(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee));\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      "\\x19Ethereum Signed Message:\\n32",\n', '      hash\n', '    );\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Arbitrator is Ownable {\n', '\n', '  mapping(address => bool) private aribitratorWhitelist;\n', '  address private primaryArbitrator;\n', '\n', '  event ArbitratorAdded(address indexed newArbitrator);\n', '  event ArbitratorRemoved(address indexed newArbitrator);\n', '  event ChangePrimaryArbitratorWallet(address indexed newPrimaryWallet);\n', '\n', '  constructor() public {\n', '    primaryArbitrator = msg.sender;\n', '  }\n', '\n', '  modifier onlyArbitrator() {\n', '    require(aribitratorWhitelist[msg.sender] == true || msg.sender == primaryArbitrator);\n', '    _;\n', '  }\n', '\n', '  function changePrimaryArbitrator(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit ChangePrimaryArbitratorWallet(walletAddress);\n', '    primaryArbitrator = walletAddress;\n', '  }\n', '\n', '  function addArbitrator(address newArbitrator) public onlyOwner {\n', '    require(newArbitrator != address(0));\n', '    emit ArbitratorAdded(newArbitrator);\n', '    aribitratorWhitelist[newArbitrator] = true;\n', '  }\n', '\n', '  function deleteArbitrator(address arbitrator) public onlyOwner {\n', '    require(arbitrator != address(0));\n', "    require(arbitrator != msg.sender); //ensure owner isn't removed\n", '    emit ArbitratorRemoved(arbitrator);\n', '    delete aribitratorWhitelist[arbitrator];\n', '  }\n', '\n', '  //Mainly for front-end administration\n', '  function isArbitrator(address arbitratorCheck) external view returns(bool) {\n', '    return (aribitratorWhitelist[arbitratorCheck] || arbitratorCheck == primaryArbitrator);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ApprovedWithdrawer is Ownable {\n', '\n', '  mapping(address => bool) private withdrawerWhitelist;\n', '  address private primaryWallet;\n', '\n', '  event WalletApproved(address indexed newAddress);\n', '  event WalletRemoved(address indexed removedAddress);\n', '  event ChangePrimaryApprovedWallet(address indexed newPrimaryWallet);\n', '\n', '  constructor() public {\n', '    primaryWallet = msg.sender;\n', '  }\n', '\n', '  modifier onlyApprovedWallet(address _to) {\n', '    require(withdrawerWhitelist[_to] == true || primaryWallet == _to);\n', '    _;\n', '  }\n', '\n', '  function changePrimaryApprovedWallet(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit ChangePrimaryApprovedWallet(walletAddress);\n', '    primaryWallet = walletAddress;\n', '  }\n', '\n', '  function addApprovedWalletAddress(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', '    emit WalletApproved(walletAddress);\n', '    withdrawerWhitelist[walletAddress] = true;\n', '  }\n', '\n', '  function deleteApprovedWalletAddress(address walletAddress) public onlyOwner {\n', '    require(walletAddress != address(0));\n', "    require(walletAddress != msg.sender); //ensure owner isn't removed\n", '    emit WalletRemoved(walletAddress);\n', '    delete withdrawerWhitelist[walletAddress];\n', '  }\n', '\n', '  //Mainly for front-end administration\n', '  function isApprovedWallet(address walletCheck) external view returns(bool) {\n', '    return (withdrawerWhitelist[walletCheck] || walletCheck == primaryWallet);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title CoinSparrow\n', ' */\n', '\n', '\n', 'contract CoinSparrow  is Ownable, Arbitrator, ApprovedWithdrawer, Pausable {\n', '\n', "  //Who wouldn't?\n", '  using SafeMath for uint256;\n', '\n', '  /**\n', '   * ------------------------------------\n', '   * SET UP SOME CONSTANTS FOR JOB STATUS\n', '   * ------------------------------------\n', '   */\n', '\n', "  //Some of these are not used in the contract, but are for reference and are used in the front-end's database.\n", '  uint8 constant private STATUS_JOB_NOT_EXIST = 1; //Not used in contract. Here for reference (used externally)\n', '  uint8 constant private STATUS_JOB_CREATED = 2; //Job has been created. Set by createJobEscrow()\n', '  uint8 constant private STATUS_JOB_STARTED = 3; //Contractor flags job as started. Set by jobStarted()\n', '  uint8 constant private STATUS_HIRER_REQUEST_CANCEL = 4; //Hirer requested cancellation on started job.\n', '                                                  //Set by requestMutualJobCancelation()\n', '  uint8 constant private STATUS_JOB_COMPLETED = 5; //Contractor flags job as completed. Set by jobCompleted()\n', '  uint8 constant private STATUS_JOB_IN_DISPUTE = 6; //Either party raised dispute. Set by requestDispute()\n', '  uint8 constant private STATUS_HIRER_CANCELLED = 7; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_CONTRACTOR_CANCELLED = 8; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED = 9; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_FINISHED_FUNDS_RELEASED_BY_CONTRACTOR = 10; //Not used in contract. Here for reference\n', '  uint8 constant private STATUS_CONTRACTOR_REQUEST_CANCEL = 11; //Contractor requested cancellation on started job.\n', '                                                        //Set by requestMutualJobCancelation()\n', '  uint8 constant private STATUS_MUTUAL_CANCELLATION_PROCESSED = 12; //Not used in contract. Here for reference\n', '\n', '  //Deployment script will check for existing CoinSparrow contracts, and only\n', '  //deploy if this value is > than existing version.\n', '  //TODO: to be implemented\n', '  uint8 constant private COINSPARROW_CONTRACT_VERSION = 1;\n', '\n', '  /**\n', '   * ------\n', '   * EVENTS\n', '   * ------\n', '   */\n', '\n', '  event JobCreated(bytes32 _jobHash, address _who, uint256 _value);\n', '  event ContractorStartedJob(bytes32 _jobHash, address _who);\n', '  event ContractorCompletedJob(bytes32 _jobHash, address _who);\n', '  event HirerRequestedCancel(bytes32 _jobHash, address _who);\n', '  event ContractorRequestedCancel(bytes32 _jobHash, address _who);\n', '  event CancelledByHirer(bytes32 _jobHash, address _who);\n', '  event CancelledByContractor(bytes32 _jobHash, address _who);\n', '  event MutuallyAgreedCancellation(\n', '    bytes32 _jobHash,\n', '    address _who,\n', '    uint256 _hirerAmount,\n', '    uint256 _contractorAmount\n', '  );\n', '  event DisputeRequested(bytes32 _jobHash, address _who);\n', '  event DisputeResolved(\n', '    bytes32 _jobHash,\n', '    address _who,\n', '    uint256 _hirerAmount,\n', '    uint256 _contractorAmount\n', '  );\n', '  event HirerReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event AddFeesToCoinSparrowPool(bytes32 _jobHash, uint256 _value);\n', '  event ContractorReleased(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event HirerLastResortRefund(bytes32 _jobHash, address _hirer, address _contractor, uint256 _value);\n', '  event WithdrawFeesFromCoinSparrowPool(address _whoCalled, address _to, uint256 _amount);\n', '  event LogFallbackFunctionCalled(address _from, uint256 _amount);\n', '\n', '\n', '  /**\n', '   * ----------\n', '   * STRUCTURES\n', '   * ----------\n', '   */\n', '\n', '  /**\n', '   * @dev Structure to hold live Escrow data - current status, times etc.\n', '   */\n', '  struct JobEscrow {\n', '    // Set so we know the job has already been created. Set when job created in createJobEscrow()\n', '    bool exists;\n', '    // The timestamp after which the hirer can cancel the task if the contractor has not yet flagged as job started.\n', '    // Set in createJobEscrow(). If the Contractor has not called jobStarted() within this time, then the hirer\n', '    // can call hirerCancel() to get a full refund (minus gas fees)\n', '    uint32 hirerCanCancelAfter;\n', "    //Job's current status (see STATUS_JOB_* constants above). Updated in multiple functions\n", '    uint8 status;\n', '    //timestamp for job completion. Set when jobCompleted() is called.\n', '    uint32 jobCompleteDate;\n', '    //num agreed seconds it will take to complete the job, once flagged as STATUS_JOB_STARTED. Set in createJobEscrow()\n', '    uint32 secondsToComplete;\n', '    //timestamp calculated for agreed completion date. Set when jobStarted() is called.\n', '    uint32 agreedCompletionDate;\n', '  }\n', '\n', '  /**\n', '   * ------------------\n', '   * CONTRACT VARIABLES\n', '   * ------------------\n', '   */\n', '\n', '\n', '  //Total Wei currently held in Escrow\n', '  uint256 private totalInEscrow;\n', '  //Amount of Wei available to CoinSparrow to withdraw\n', '  uint256 private feesAvailableForWithdraw;\n', '\n', '  /*\n', '   * Set max limit for how much (in wei) contract will accept. Can be modified by owner using setMaxSend()\n', "   * This ensures that arbitrarily large amounts of ETH can't be sent.\n", '   * Front end will check this value before processing new jobs\n', '   */\n', '  uint256 private MAX_SEND;\n', '\n', '  /*\n', '   * Mapping of active jobs. Key is a hash of the job data:\n', '   * JobEscrow = keccak256(_jobId,_hirer,_contractor, _value, _fee)\n', '   * Once job is complete, and refunds released, the\n', '   * mapping for that job is deleted to conserve space.\n', '   */\n', '  mapping(bytes32 => JobEscrow) private jobEscrows;\n', '\n', '  /*\n', "   * mapping of Hirer's funds in Escrow for each job.\n", '   * This is referenced when any ETH transactions occur\n', '   */\n', '  mapping(address => mapping(bytes32 => uint256)) private hirerEscrowMap;\n', '\n', '  /**\n', '   * ---------\n', '   * MODIFIERS\n', '   * ---------\n', '   */\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Hirer can execute\n', '   * @param _hirer Address of the hirer to check against msg.sender\n', '   */\n', '\n', '  modifier onlyHirer(address _hirer) {\n', '    require(msg.sender == _hirer);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Contractor can execute\n', '   * @param _contractor Address of the contractor to check against msg.sender\n', '   */\n', '\n', '  modifier onlyContractor(address _contractor) {\n', '    require(msg.sender == _contractor);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to ensure only the Contractor can execute\n', '   * @param _contractor Address of the contractor to check against msg.sender\n', '   */\n', '\n', '  modifier onlyHirerOrContractor(address _hirer, address _contractor) {\n', '    require(msg.sender == _hirer || msg.sender == _contractor);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * ----------------------\n', '   * CONTRACT FUNCTIONALITY\n', '   * ----------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Constructor function for the contract\n', '   * @param _maxSend Maximum Wei the contract will accept in a transaction\n', '   */\n', '\n', '  constructor(uint256 _maxSend) public {\n', '    require(_maxSend > 0);\n', "    //a bit of protection. Set a limit, so users can't send stupid amounts of ETH\n", '    MAX_SEND = _maxSend;\n', '  }\n', '\n', '  /**\n', '   * @dev fallback function for the contract. Log event so ETH can be tracked and returned\n', '   */\n', '\n', '  function() payable {\n', '    //Log who sent, and how much so it can be returned\n', '    emit LogFallbackFunctionCalled(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new escrow and add it to the `jobEscrows` mapping.\n', '   * Also updates/creates a reference to the job, and amount in Escrow for the job in hirerEscrowMap\n', '   * jobHash is created by hashing _jobId, _seller, _buyer, _value and _fee params.\n', '   * These params must be supplied on future contract calls.\n', '   * A hash of the job parameters (_jobId, _hirer, _contractor, _value, _fee) is created and used\n', '   * to access job data held in the contract. All functions that interact with a job in Escrow\n', '   * require these parameters.\n', '   * Pausable - only runs whenNotPaused. Can pause to prevent taking any more\n', '   *            ETH if there is a problem with the Smart Contract.\n', '   *            Parties can still access/transfer their existing ETH held in Escrow, complete jobs etc.\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _jobStartedWindowInSeconds time within which the contractor must flag as job started\n', "   *                                   if job hasn't started AFTER this time, hirer can cancel contract.\n", '   *                                   Hirer cannot cancel contract before this time.\n', "   * @param _secondsToComplete agreed time to complete job once it's flagged as STATUS_JOB_STARTED\n", '   */\n', '  function createJobEscrow(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint32 _jobStartedWindowInSeconds,\n', '    uint32 _secondsToComplete\n', '  ) payable external whenNotPaused onlyHirer(_hirer)\n', '  {\n', '\n', '    // Check sent eth against _value and also make sure is not 0\n', '    require(msg.value == _value && msg.value > 0);\n', '\n', "    //CoinSparrow's Fee should be less than the Job Value, because anything else would be daft.\n", '    require(_fee < _value);\n', '\n', '    //Check the amount sent is below the acceptable threshold\n', '    require(msg.value <= MAX_SEND);\n', '\n', '    //needs to be more than 0 seconds\n', '    require(_jobStartedWindowInSeconds > 0);\n', '\n', '    //needs to be more than 0 seconds\n', '    require(_secondsToComplete > 0);\n', '\n', '    //generate the job hash. Used to reference the job in all future function calls/transactions.\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //Check that the job does not already exist.\n', '    require(!jobEscrows[jobHash].exists);\n', '\n', '    //create the job and store it in the mapping\n', '    jobEscrows[jobHash] = JobEscrow(\n', '      true,\n', '      uint32(block.timestamp) + _jobStartedWindowInSeconds,\n', '      STATUS_JOB_CREATED,\n', '      0,\n', '      _secondsToComplete,\n', '      0);\n', '\n', '    //update total held in escrow\n', '    totalInEscrow = totalInEscrow.add(msg.value);\n', '\n', "    //Update hirer's job => value mapping\n", '    hirerEscrowMap[msg.sender][jobHash] = msg.value;\n', '\n', '    //Let the world know.\n', '    emit JobCreated(jobHash, msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * -----------------------\n', '   * RELEASE FUNDS FUNCTIONS\n', '   * -----------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Release funds to contractor. Can only be called by Hirer. Can be called at any time as long as the\n', '   * job exists in the contract (for example, two parties may have agreed job is complete external to the\n', '   * CoinSparrow website). Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerReleaseFunds(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //check hirer has funds in the Smart Contract assigned to this job\n', '    require(hirerEscrowMap[msg.sender][jobHash] > 0);\n', '\n', '    //get the value from the stored hirer => job => value mapping\n', '    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '     //Log event\n', '    emit HirerReleased(\n', '      jobHash,\n', '      msg.sender,\n', '      _contractor,\n', '      jobValue);\n', '\n', '     //Log event\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    //no longer required. Remove to save storage. Also prevents reentrancy\n', '    delete jobEscrows[jobHash];\n', '    //no longer required. Remove to save storage. Also prevents reentrancy\n', '    delete hirerEscrowMap[msg.sender][jobHash];\n', '\n', "    //add to CoinSparrow's fee pool\n", '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //Finally, transfer the funds, minus CoinSparrow fees\n', '    _contractor.transfer(jobValue.sub(_fee));\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Release funds to contractor in the event that the Hirer is unresponsive after job has been flagged as complete.\n', '   * Can only be called by the contractor, and only 4 weeks after the job has been flagged as complete.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function contractorReleaseFunds(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //check job is actually completed\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_COMPLETED);\n', '    //can only self-release 4 weeks after completion\n', '    require(block.timestamp > jobEscrows[jobHash].jobCompleteDate + 4 weeks);\n', '\n', '    //get value for job\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    emit ContractorReleased(\n', '      jobHash,\n', '      _hirer,\n', '      _contractor,\n', '      jobValue); //Log event\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\n', '    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\n', '\n', '    //add fees to coinsparrow pool\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //transfer funds to contractor, minus fees\n', '    _contractor.transfer(jobValue.sub(_fee));\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Can be called by the hirer to claim a full refund, if job has been started but contractor has not\n', '   * completed within 4 weeks after agreed completion date, and becomes unresponsive.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerLastResortRefund(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    \n', '    //check job is started\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\n', '    //can only self-refund 4 weeks after agreed completion date\n', '    require(block.timestamp > jobEscrows[jobHash].agreedCompletionDate + 4 weeks);\n', '\n', '    //get value for job\n', '    uint256 jobValue = hirerEscrowMap[msg.sender][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    emit HirerLastResortRefund(\n', '      jobHash,\n', '      _hirer,\n', '      _contractor,\n', '      jobValue); //Log event\n', '\n', '    delete jobEscrows[jobHash]; //no longer required. Remove to save storage.\n', '    delete  hirerEscrowMap[_hirer][jobHash]; //no longer required. Remove to save storage.\n', '\n', '    //update total in escrow\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    //transfer funds to hirer\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * ---------------------------\n', '   * UPDATE JOB STATUS FUNCTIONS\n', '   * ---------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Flags job started, and Stops the hirer from cancelling the job.\n', '   * Can only be called the contractor when job starts.\n', '   * Used to mark the job as started. After this point, hirer must request cancellation\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function jobStarted(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    //check job status.\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\n', '    jobEscrows[jobHash].status = STATUS_JOB_STARTED; //set status\n', '    jobEscrows[jobHash].hirerCanCancelAfter = 0;\n', '    jobEscrows[jobHash].agreedCompletionDate = uint32(block.timestamp) + jobEscrows[jobHash].secondsToComplete;\n', '    emit ContractorStartedJob(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Flags job completed to inform hirer. Also sets flag to allow contractor to get their funds 4 weeks after\n', "   * completion in the event that the hirer is unresponsive and doesn't release the funds.\n", '   * Can only be called the contractor when job complete.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function jobCompleted(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    require(jobEscrows[jobHash].exists); //check the job exists in the contract\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED); //check job status.\n', '    jobEscrows[jobHash].status = STATUS_JOB_COMPLETED;\n', '    jobEscrows[jobHash].jobCompleteDate = uint32(block.timestamp);\n', '    emit ContractorCompletedJob(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * --------------------------\n', '   * JOB CANCELLATION FUNCTIONS\n', '   * --------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Cancels the job and returns the ether to the hirer.\n', '   * Can only be called the contractor. Can be called at any time during the process\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function contractorCancel(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyContractor(_contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '    emit CancelledByContractor(jobHash, msg.sender);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Cancels the job and returns the ether to the hirer.\n', '   * Can only be called the hirer.\n', '   * Can only be called if the job start window was missed by the contractor\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function hirerCancel(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirer(_hirer)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(jobEscrows[jobHash].hirerCanCancelAfter > 0);\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_CREATED);\n', '    require(jobEscrows[jobHash].hirerCanCancelAfter < block.timestamp);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[msg.sender][jobHash];\n', '    emit CancelledByHirer(jobHash, msg.sender);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '\n', '    _hirer.transfer(jobValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the hirer or contractor to request mutual cancellation once job has started\n', '   * Can only be called when status = STATUS_JOB_STARTED\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function requestMutualJobCancellation(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirerOrContractor(_hirer, _contractor)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_STARTED);\n', '\n', '    if (msg.sender == _hirer) {\n', '      jobEscrows[jobHash].status = STATUS_HIRER_REQUEST_CANCEL;\n', '      emit HirerRequestedCancel(jobHash, msg.sender);\n', '    }\n', '    if (msg.sender == _contractor) {\n', '      jobEscrows[jobHash].status = STATUS_CONTRACTOR_REQUEST_CANCEL;\n', '      emit ContractorRequestedCancel(jobHash, msg.sender);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Called when both hirer and contractor have agreed on cancellation conditions, and amount each will receive\n', '   * can be called by hirer or contractor once % amount has been signed by both parties.\n', '   * Both parties sign a hash of the % agreed upon. The signatures of both parties must be sent and verified\n', '   * before the transaction is processed, to ensure that the % processed is valid.\n', '   * can be called at any time\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _contractorPercent percentage the contractor will be paid\n', '   * @param _hirerMsgSig Signed message from hiring party agreeing on _contractorPercent\n', '   * @param _contractorMsgSig Signed message from contractor agreeing on _contractorPercent\n', '   */\n', '  function processMutuallyAgreedJobCancellation(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint8 _contractorPercent,\n', '    bytes _hirerMsgSig,\n', '    bytes _contractorMsgSig\n', '  ) external\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(msg.sender == _hirer || msg.sender == _contractor);\n', '    require(_contractorPercent <= 100 && _contractorPercent >= 0);\n', '\n', '    //Checks the signature of both parties to ensure % is correct.\n', '    //Attempts to prevent the party calling the function from modifying the pre-agreed %\n', '    require(\n', '      checkRefundSignature(_contractorPercent,_hirerMsgSig,_hirer)&&\n', '      checkRefundSignature(_contractorPercent,_contractorMsgSig,_contractor));\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '\n', '    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\n', '    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\n', '\n', '    emit MutuallyAgreedCancellation(\n', '      jobHash,\n', '      msg.sender,\n', '      hirerAmount,\n', '      contractorAmount);\n', '\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    if (contractorAmount > 0) {\n', '      _contractor.transfer(contractorAmount);\n', '    }\n', '    if (hirerAmount > 0) {\n', '      _hirer.transfer(hirerAmount);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * -------------------------\n', '   * DISPUTE RELATED FUNCTIONS\n', '   * -------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Called by hirer or contractor to raise a dispute during started, completed or canellation request statuses\n', '   * Once called, funds are locked until arbitrator can resolve the dispute. Assigned arbitrator\n', '   * will review all information relating to the job, and decide on a fair course of action.\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   */\n', '  function requestDispute(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  ) external onlyHirerOrContractor(_hirer, _contractor)\n', '  {\n', '\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '    require(\n', '      jobEscrows[jobHash].status == STATUS_JOB_STARTED||\n', '      jobEscrows[jobHash].status == STATUS_JOB_COMPLETED||\n', '      jobEscrows[jobHash].status == STATUS_HIRER_REQUEST_CANCEL||\n', '      jobEscrows[jobHash].status == STATUS_CONTRACTOR_REQUEST_CANCEL);\n', '\n', '    jobEscrows[jobHash].status = STATUS_JOB_IN_DISPUTE;\n', '\n', '    emit DisputeRequested(jobHash, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the arbitrator to resolve a dispute\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @param _contractorPercent percentage the contractor will receive\n', '   */\n', '\n', '  function resolveDispute(\n', '\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee,\n', '    uint8 _contractorPercent\n', '  ) external onlyArbitrator\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    //check the job exists in the contract\n', '    require(jobEscrows[jobHash].exists);\n', '\n', '    require(jobEscrows[jobHash].status == STATUS_JOB_IN_DISPUTE);\n', '    require(_contractorPercent <= 100);\n', '\n', '    uint256 jobValue = hirerEscrowMap[_hirer][jobHash];\n', '\n', '    //Check values in contract and sent are valid\n', '    require(jobValue > 0 && jobValue == _value);\n', '\n', '    //check fee amount is valid\n', '    require(jobValue >= jobValue.sub(_fee));\n', '\n', '    //check there is enough in escrow\n', '    require(totalInEscrow >= jobValue && totalInEscrow > 0);\n', '\n', '    totalInEscrow = totalInEscrow.sub(jobValue);\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.add(_fee);\n', '    // Add the the pot for localethereum to withdraw\n', '\n', '    delete jobEscrows[jobHash];\n', '    delete  hirerEscrowMap[_hirer][jobHash];\n', '\n', '    uint256 contractorAmount = jobValue.sub(_fee).mul(_contractorPercent).div(100);\n', '    uint256 hirerAmount = jobValue.sub(_fee).mul(100 - _contractorPercent).div(100);\n', '    emit DisputeResolved(\n', '      jobHash,\n', '      msg.sender,\n', '      hirerAmount,\n', '      contractorAmount);\n', '\n', '    emit AddFeesToCoinSparrowPool(jobHash, _fee);\n', '\n', '    _contractor.transfer(contractorAmount);\n', '    _hirer.transfer(hirerAmount);\n', '\n', '  }\n', '\n', '  /**\n', '   * ------------------------\n', '   * ADMINISTRATIVE FUNCTIONS\n', '   * ------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev Allows owner to transfer funds from the collected fees pool to an approved wallet address\n', '   * @param _to receiver wallet address\n', '   * @param _amount amount to withdraw and transfer\n', '   */\n', '  function withdrawFees(address _to, uint256 _amount) onlyOwner onlyApprovedWallet(_to) external {\n', '    /**\n', '     * Withdraw fees collected by the contract. Only the owner can call this.\n', '     * Can only be sent to an approved wallet address\n', '     */\n', '    require(_amount > 0);\n', '    require(_amount <= feesAvailableForWithdraw && feesAvailableForWithdraw > 0);\n', '\n', '    feesAvailableForWithdraw = feesAvailableForWithdraw.sub(_amount);\n', '\n', '    emit WithdrawFeesFromCoinSparrowPool(msg.sender,_to, _amount);\n', '\n', '    _to.transfer(_amount);\n', '  }\n', '\n', '  /**\n', '   * @dev returns how much has been collected in fees, and how much is available to withdraw\n', '   * @return feesAvailableForWithdraw amount available for CoinSparrow to withdraw\n', '   */\n', '\n', '  function howManyFees() external view returns (uint256) {\n', '    return feesAvailableForWithdraw;\n', '  }\n', '\n', '  /**\n', '   * @dev returns how much is currently held in escrow\n', '   * @return totalInEscrow amount currently held in escrow\n', '   */\n', '\n', '  function howMuchInEscrow() external view returns (uint256) {\n', '    return totalInEscrow;\n', '  }\n', '\n', '  /**\n', '   * @dev modify the maximum amount of ETH the contract will allow in a transaction (when creating a new job)\n', '   * @param _maxSend amount in Wei\n', '   */\n', '\n', '  function setMaxSend(uint256 _maxSend) onlyOwner external {\n', '    require(_maxSend > 0);\n', '    MAX_SEND = _maxSend;\n', '  }\n', '\n', '  /**\n', '   * @dev return the current maximum amount the contract will allow in a transaction\n', '   * @return MAX_SEND current maximum value\n', '   */\n', '\n', '  function getMaxSend() external view returns (uint256) {\n', '    return MAX_SEND;\n', '  }\n', '\n', '  /**\n', "   * @dev returns THIS contract instance's version\n", '   * @return COINSPARROW_CONTRACT_VERSION version number of THIS instance of the contract\n', '   */\n', '\n', '  function getContractVersion() external pure returns(uint8) {\n', '    return COINSPARROW_CONTRACT_VERSION;\n', '  }\n', '\n', '  /**\n', '   * -------------------------\n', '   * JOB INFORMATION FUNCTIONS\n', '   * -------------------------\n', '   */\n', '\n', '  /**\n', '   * @dev returns the status of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', "   * @return status job's current status\n", '   */\n', '\n', '  function getJobStatus(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint8)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint8 status = STATUS_JOB_NOT_EXIST;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      status = jobEscrows[jobHash].status;\n', '    }\n', '    return status;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the date after which the Hirer can cancel the job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return hirerCanCancelAfter timestamp for date after which the hirer can cancel\n', '   */\n', '\n', '  function getJobCanCancelAfter(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 hirerCanCancelAfter = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      hirerCanCancelAfter = jobEscrows[jobHash].hirerCanCancelAfter;\n', '    }\n', '    return hirerCanCancelAfter;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the number of seconds for job completion\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return secondsToComplete number of seconds to complete job\n', '   */\n', '\n', '  function getSecondsToComplete(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 secondsToComplete = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      secondsToComplete = jobEscrows[jobHash].secondsToComplete;\n', '    }\n', '    return secondsToComplete;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the agreed completion date of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return agreedCompletionDate timestamp for agreed completion date\n', '   */\n', '\n', '  function getAgreedCompletionDate(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 agreedCompletionDate = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      agreedCompletionDate = jobEscrows[jobHash].agreedCompletionDate;\n', '    }\n', '    return agreedCompletionDate;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the actual completion date of the job of the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return jobCompleteDate timestamp for actual completion date\n', '   */\n', '\n', '  function getActualCompletionDate(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns (uint32)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint32 jobCompleteDate = 0;\n', '\n', '    if (jobEscrows[jobHash].exists) {\n', '      jobCompleteDate = jobEscrows[jobHash].jobCompleteDate;\n', '    }\n', '    return jobCompleteDate;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the value for the requested job\n', '   * Following parameters are used to regenerate the jobHash:\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', "   * @return amount job's value\n", '   */\n', '\n', '  function getJobValue(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee) external view returns(uint256)\n', '  {\n', '    //get job Hash\n', '    bytes32 jobHash = getJobHash(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee);\n', '\n', '    uint256 amount = 0;\n', '    if (jobEscrows[jobHash].exists) {\n', '      amount = hirerEscrowMap[_hirer][jobHash];\n', '    }\n', '    return amount;\n', '  }\n', '\n', '  /**\n', '   * @dev Helper function to pre-validate mutual cancellation signatures. Used by front-end app\n', '   * to let each party know that the other has signed off the agreed %\n', '   * @param _contractorPercent percentage agreed upon\n', '   * @param _sigMsg signed message to be validated\n', '   * @param _signer wallet address of the message signer to validate against\n', '   * @return bool whether or not the signature is valid\n', '   */\n', '  function validateRefundSignature(\n', '    uint8 _contractorPercent,\n', '    bytes _sigMsg,\n', '    address _signer) external pure returns(bool)\n', '  {\n', '\n', '    return checkRefundSignature(_contractorPercent,_sigMsg,_signer);\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Executes the actual signature verification.\n', '   * @param _contractorPercent percentage agreed upon\n', '   * @param _sigMsg signed message to be validated\n', '   * @param _signer wallet address of the message signer to validate against\n', '   * @return bool whether or not the signature is valid\n', '   */\n', '  function checkRefundSignature(\n', '    uint8 _contractorPercent,\n', '    bytes _sigMsg,\n', '    address _signer) private pure returns(bool)\n', '  {\n', '    bytes32 percHash = keccak256(abi.encodePacked(_contractorPercent));\n', '    bytes32 msgHash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32",percHash));\n', '\n', '    address addr = ECRecovery.recover(msgHash,_sigMsg);\n', '    return addr == _signer;\n', '  }\n', '\n', '  /**\n', '   * @dev Generates the sha256 jobHash based on job parameters. Used in several functions\n', '   * @param _jobId The unique ID of the job, from the CoinSparrow database\n', '   * @param _hirer The wallet address of the hiring (buying) party\n', '   * @param _contractor The wallet address of the contractor (selling) party\n', '   * @param _value The ether amount being held in escrow. I.e. job cost - amount hirer is paying contractor\n', '   * @param _fee CoinSparrow fee for this job. Pre-calculated\n', '   * @return bytes32 the calculated jobHash value\n', '   */\n', '  function getJobHash(\n', '    bytes16 _jobId,\n', '    address _hirer,\n', '    address _contractor,\n', '    uint256 _value,\n', '    uint256 _fee\n', '  )  private pure returns(bytes32)\n', '  {\n', '    return keccak256(abi.encodePacked(\n', '      _jobId,\n', '      _hirer,\n', '      _contractor,\n', '      _value,\n', '      _fee));\n', '  }\n', '\n', '}']
