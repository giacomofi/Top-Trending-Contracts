['pragma solidity ^0.4.20;\n', '\n', '// ETH in, tokens out to lottery winner.\n', '\n', 'contract PoWMLottery {\n', '    using SafeMath for uint256;\n', '    \n', '    // Contract setup\n', '    bool public isLotteryOpen = false;\n', '    address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B);\n', '    POWM maths = POWM(POWM_address);\n', '    address owner;\n', '    \n', '    // Datasets\n', '    mapping (uint256 => address) public gamblers;\n', '    mapping (address => uint256) public token_buyins;\n', '    mapping (address => uint256) public last_round_bought;\n', '    \n', '    uint256 public num_tickets_current_round = 0;\n', '    uint256 public current_round = 0;\n', '    uint256 public numTokensInLottery = 0;\n', '    \n', '    address masternode_referrer;\n', '    \n', '    // Can&#39;t buy more than 25 tokens.\n', '    uint256 public MAX_TOKEN_BUYIN = 25;\n', '    \n', '    function PoWMLottery() public {\n', '        current_round = 1;\n', '        owner = msg.sender;\n', '        masternode_referrer = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function donateToLottery() public payable returns(uint256) {\n', '        uint256 tokens_before = maths.myTokens();\n', '        maths.buy.value(msg.value)(masternode_referrer);\n', '        uint256 tokens_after = maths.myTokens();\n', '        numTokensInLottery = maths.myTokens();\n', '        return tokens_after - tokens_before;\n', '    }\n', '\n', '    /**\n', '     * Buys tickets. Fails if > 25 tickets are attempted to buy.\n', '     */\n', '    function buyTickets() public payable {\n', '        require(isLotteryOpen == true);\n', '        require(last_round_bought[msg.sender] != current_round);\n', '        \n', '        // Buy the tokens.\n', '        // Should be between 0 and 25.\n', '        uint256 tokens_before = maths.myTokens();\n', '        maths.buy.value(msg.value)(masternode_referrer);\n', '        uint256 tokens_after = maths.myTokens();\n', '        uint256 tokens_bought = SafeMath.sub(tokens_after, tokens_before).div(1e18);\n', '        require(tokens_bought >= 1 && tokens_bought <= MAX_TOKEN_BUYIN);\n', '        numTokensInLottery = maths.myTokens();\n', '        \n', '        // Set last_round_bought = current round and token_buyins value\n', '        // Uses a for loop to put up to 25 tickets in.\n', '        uint8 i = 0;\n', '        while (i < tokens_bought) {\n', '            i++;\n', '            \n', '            gamblers[num_tickets_current_round] = msg.sender;\n', '            num_tickets_current_round++;\n', '        }\n', '\n', '        token_buyins[msg.sender] = tokens_bought;\n', '        last_round_bought[msg.sender] = current_round;\n', '    }\n', '    \n', '    function setMaxTokenBuyin(uint256 tokens) public onlyOwner {\n', '        require(isLotteryOpen == false);\n', '        require(tokens > 0);\n', '        \n', '        MAX_TOKEN_BUYIN = tokens;\n', '    }\n', '    \n', '    function openLottery() onlyOwner public {\n', '        require(isLotteryOpen == false);\n', '        current_round++;\n', '        isLotteryOpen = true;\n', '        num_tickets_current_round = 0;\n', '    }\n', '    \n', '    // We need to be payable in order to receive dividends.\n', '    function () public payable {}\n', '    \n', '    function closeLotteryAndPickWinner() onlyOwner public {\n', '        require(isLotteryOpen == true);\n', '        isLotteryOpen = false;\n', '        \n', '        // Pick winner as a pseudo-random hash of the timestamp among all the current winners\n', '        // YES we know this isn&#39;t /truly/ random but unless the prize is worth more than the block mining reward\n', '        //  it doesn&#39;t fucking matter.\n', '        uint256 winning_number = uint256(keccak256(block.blockhash(block.number - 1))) % num_tickets_current_round;\n', '        address winner = gamblers[winning_number];\n', '        masternode_referrer = winner;\n', '        \n', '        // ERC20 transfer & clear out our tokens.\n', '        uint256 exact_tokens = maths.myTokens();\n', '        maths.transfer(winner, exact_tokens);\n', '        numTokensInLottery = 0;\n', '        \n', '        // transfer any divs we got\n', '        winner.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '// Function prototypes for PoWM\n', 'contract POWM {\n', '    function buy(address _referredBy) public payable returns(uint256) {}\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) returns(bool) {}\n', '    function myTokens() public view returns(uint256) {}\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '// ETH in, tokens out to lottery winner.\n', '\n', 'contract PoWMLottery {\n', '    using SafeMath for uint256;\n', '    \n', '    // Contract setup\n', '    bool public isLotteryOpen = false;\n', '    address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B);\n', '    POWM maths = POWM(POWM_address);\n', '    address owner;\n', '    \n', '    // Datasets\n', '    mapping (uint256 => address) public gamblers;\n', '    mapping (address => uint256) public token_buyins;\n', '    mapping (address => uint256) public last_round_bought;\n', '    \n', '    uint256 public num_tickets_current_round = 0;\n', '    uint256 public current_round = 0;\n', '    uint256 public numTokensInLottery = 0;\n', '    \n', '    address masternode_referrer;\n', '    \n', "    // Can't buy more than 25 tokens.\n", '    uint256 public MAX_TOKEN_BUYIN = 25;\n', '    \n', '    function PoWMLottery() public {\n', '        current_round = 1;\n', '        owner = msg.sender;\n', '        masternode_referrer = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function donateToLottery() public payable returns(uint256) {\n', '        uint256 tokens_before = maths.myTokens();\n', '        maths.buy.value(msg.value)(masternode_referrer);\n', '        uint256 tokens_after = maths.myTokens();\n', '        numTokensInLottery = maths.myTokens();\n', '        return tokens_after - tokens_before;\n', '    }\n', '\n', '    /**\n', '     * Buys tickets. Fails if > 25 tickets are attempted to buy.\n', '     */\n', '    function buyTickets() public payable {\n', '        require(isLotteryOpen == true);\n', '        require(last_round_bought[msg.sender] != current_round);\n', '        \n', '        // Buy the tokens.\n', '        // Should be between 0 and 25.\n', '        uint256 tokens_before = maths.myTokens();\n', '        maths.buy.value(msg.value)(masternode_referrer);\n', '        uint256 tokens_after = maths.myTokens();\n', '        uint256 tokens_bought = SafeMath.sub(tokens_after, tokens_before).div(1e18);\n', '        require(tokens_bought >= 1 && tokens_bought <= MAX_TOKEN_BUYIN);\n', '        numTokensInLottery = maths.myTokens();\n', '        \n', '        // Set last_round_bought = current round and token_buyins value\n', '        // Uses a for loop to put up to 25 tickets in.\n', '        uint8 i = 0;\n', '        while (i < tokens_bought) {\n', '            i++;\n', '            \n', '            gamblers[num_tickets_current_round] = msg.sender;\n', '            num_tickets_current_round++;\n', '        }\n', '\n', '        token_buyins[msg.sender] = tokens_bought;\n', '        last_round_bought[msg.sender] = current_round;\n', '    }\n', '    \n', '    function setMaxTokenBuyin(uint256 tokens) public onlyOwner {\n', '        require(isLotteryOpen == false);\n', '        require(tokens > 0);\n', '        \n', '        MAX_TOKEN_BUYIN = tokens;\n', '    }\n', '    \n', '    function openLottery() onlyOwner public {\n', '        require(isLotteryOpen == false);\n', '        current_round++;\n', '        isLotteryOpen = true;\n', '        num_tickets_current_round = 0;\n', '    }\n', '    \n', '    // We need to be payable in order to receive dividends.\n', '    function () public payable {}\n', '    \n', '    function closeLotteryAndPickWinner() onlyOwner public {\n', '        require(isLotteryOpen == true);\n', '        isLotteryOpen = false;\n', '        \n', '        // Pick winner as a pseudo-random hash of the timestamp among all the current winners\n', "        // YES we know this isn't /truly/ random but unless the prize is worth more than the block mining reward\n", "        //  it doesn't fucking matter.\n", '        uint256 winning_number = uint256(keccak256(block.blockhash(block.number - 1))) % num_tickets_current_round;\n', '        address winner = gamblers[winning_number];\n', '        masternode_referrer = winner;\n', '        \n', '        // ERC20 transfer & clear out our tokens.\n', '        uint256 exact_tokens = maths.myTokens();\n', '        maths.transfer(winner, exact_tokens);\n', '        numTokensInLottery = 0;\n', '        \n', '        // transfer any divs we got\n', '        winner.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '// Function prototypes for PoWM\n', 'contract POWM {\n', '    function buy(address _referredBy) public payable returns(uint256) {}\n', '    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) returns(bool) {}\n', '    function myTokens() public view returns(uint256) {}\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
