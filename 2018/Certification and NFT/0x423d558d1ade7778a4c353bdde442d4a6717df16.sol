['pragma solidity 0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20\n', '{\n', '    function totalSupply()public view returns(uint total_Supply);\n', '    function balanceOf(address who)public view returns(uint256);\n', '    function allowance(address owner, address spender)public view returns(uint);\n', '    function transferFrom(address from, address to, uint value)public returns(bool ok);\n', '    function approve(address spender, uint value)public returns(bool ok);\n', '    function transfer(address to, uint value)public returns(bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '\n', 'contract YettaToken is ERC20\n', '{\n', '    using SafeMath for uint256;\n', '\n', '   \n', '    uint256 constant public TOKEN_DECIMALS = 10 ** 8;\n', '    uint256 constant public ETH_DECIMALS = 10 ** 18;\n', '    uint256 public TotalCrowdsaleSupply = 25000000; //25 Million\n', '    uint256 public TotalOwnerSupply = 60000000;     //60 Million  \n', '    uint256 public BonusPoolSupply = 15000000;  //15 Million\n', '   \n', '\n', '    // Name of the token\n', '    string public constant name = "Yetta Token";\n', '\n', '    // Symbol of token\n', '    string public constant symbol = "YET";\n', '\n', '    uint8 public constant decimals = 8;\n', '\n', '    // 100 Million total supply // muliplies dues to decimal precision\n', '    uint public TotalTokenSupply = 100000000 * TOKEN_DECIMALS;  //100 Million\n', '\n', '    // Owner of this contract\n', '    address public owner;\n', '    \n', '    address public bonusPool = 0xf6148aD4C8b2138B9029301310074F391ea4529D;\n', '    address public YettaCrowdSale;\n', '    bool public mintedCrowdsale;\n', '    \n', '     bool public lockstatus; \n', ' \n', '     uint public Currenttask;\n', '     string public Currentproposal;\n', ' \n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping(uint =>mapping(address => bool)) Task;\n', '    mapping(uint =>bool) public acceptProp;\n', '    mapping(uint =>uint256) public agreed;\n', '    mapping(uint =>uint256) public disagreed;\n', '  \n', '    mapping(address => uint) balances;\n', ' \n', '    enum VotingStages {\n', '        VOTING_NOTSTARTED,\n', '        VOTING_OPEN,\n', '        VOTING_CLOSED\n', '    }\n', '\n', '    VotingStages public votingstage;\n', '\n', '    modifier atStage(VotingStages _stage) {\n', '        require(votingstage == _stage);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    constructor() public\n', '    {\n', '       \n', '        owner = msg.sender;\n', '        lockstatus = true;\n', '        votingstage = VotingStages.VOTING_NOTSTARTED;\n', '        balances[owner] = TotalOwnerSupply.mul(TOKEN_DECIMALS);\n', '         balances[bonusPool] = BonusPoolSupply.mul(TOKEN_DECIMALS);\n', '        emit Transfer(0, owner, balances[owner]);\n', '        emit Transfer(0, bonusPool, balances[bonusPool]);\n', '    }\n', '    \n', '    function Bonus_PoolTransfer(address receiver, uint256 tokenQuantity) external onlyOwner {\n', '      \n', '             require( receiver != 0x0);\n', '             require(balances[bonusPool] >= tokenQuantity && tokenQuantity >= 0);\n', '             balances[bonusPool] = (balances[bonusPool]).sub(tokenQuantity);\n', '             balances[receiver] = balances[receiver].add(tokenQuantity);\n', '            \n', '             emit Transfer(0, receiver, tokenQuantity);\n', '    }\n', '    \n', '    function mint_Crowdsale(address _YettaCrowdSale) public onlyOwner{\n', '        require(!mintedCrowdsale);\n', '        YettaCrowdSale = _YettaCrowdSale;\n', '        balances[YettaCrowdSale] = balances[YettaCrowdSale].add(TotalCrowdsaleSupply.mul(TOKEN_DECIMALS));\n', '        mintedCrowdsale = true;\n', '        emit Transfer(0,YettaCrowdSale,  balances[YettaCrowdSale]);\n', '    }\n', '\n', '   function startVoting(uint newtask, string _currentproposal) external onlyOwner\n', '    {\n', '        votingstage = VotingStages.VOTING_OPEN;\n', '        Currenttask = newtask;\n', '        Currentproposal = _currentproposal;\n', '    }\n', '    \n', '    // Function to check that if Investor already voted for a particular task or not, \n', '    //if voted:  true, else: false\n', '     function VotedForProposal(uint _task, address spender) public constant returns(bool)\n', '    {\n', '        require(spender != 0x0);\n', '        return Task[_task][spender];\n', '    }\n', '\n', '     function submitVote(uint _task, bool proposal) public atStage(VotingStages.VOTING_OPEN){\n', '        require(Currenttask == _task);\n', '        require(balanceOf(msg.sender)>0); \n', '        require(Task[_task][msg.sender] ==false); // Checks if already voted for a particular task\n', '         if(proposal == true){\n', '            agreed[_task] = agreed[_task].add(balanceOf(msg.sender));\n', '            Task[_task][msg.sender] = true;\n', '        }\n', '        else{\n', '            disagreed[_task] = disagreed[_task].add(balanceOf(msg.sender));\n', '            Task[_task][msg.sender] = true;\n', '        }\n', '       \n', '            }\n', '            \n', '    function finaliseVoting(uint _currenttask) external onlyOwner atStage(VotingStages.VOTING_OPEN){\n', '            require(Currenttask == _currenttask);\n', '                if(agreed[_currenttask] <  disagreed[_currenttask]){\n', '                    \n', '                    acceptProp[_currenttask]=false;\n', '                    \n', '                }\n', '                \n', '                else{\n', '                   \n', '                     acceptProp[_currenttask]=true;\n', '                }\n', '                votingstage = VotingStages.VOTING_CLOSED;\n', '            }\n', '\n', '\n', '/* YET tokens will be unlocked after completion of the Yetta Blockchain\n', 'ICO so users could upgrade to the new platform to continue participation in\n', 'governance of the Yetta Blockchain project. */\n', '    function removeLocking(bool RunningStatusLock) external onlyOwner\n', '    {\n', '        lockstatus = RunningStatusLock;\n', '    }\n', '\n', '    // what is the total supply YET token\n', '    function totalSupply() public view returns(uint256 total_Supply) {\n', '        total_Supply = TotalTokenSupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address token_Owner)public constant returns(uint256 balance) {\n', '        return balances[token_Owner];\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(address from_address, address to_address, uint256 tokens)public returns(bool success)\n', '    {\n', '        require(to_address != 0x0);\n', '        require(balances[from_address] >= tokens && allowed[from_address][msg.sender] >= tokens && tokens >= 0);\n', '        balances[from_address] = (balances[from_address]).sub(tokens);\n', '        allowed[from_address][msg.sender] = (allowed[from_address][msg.sender]).sub(tokens);\n', '        balances[to_address] = (balances[to_address]).add(tokens);\n', '        emit Transfer(from_address, to_address, tokens);\n', '        return true;\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address spender, uint256 tokens)public returns(bool success)\n', '    {\n', '        require(spender != 0x0);\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address token_Owner, address spender) public constant returns(uint256 remaining)\n', '    {\n', '        require(token_Owner != 0x0 && spender != 0x0);\n', '        return allowed[token_Owner][spender];\n', '    }\n', '\n', '    // Transfer the balance from owner&#39;s account to another account\n', '    function transfer(address to_address, uint256 tokens)public returns(bool success)\n', '    {\n', '        if ( msg.sender == owner) {\n', '            require( to_address != 0x0);\n', '            require(balances[owner] >= tokens && tokens >= 0);\n', '            balances[owner] = balances[owner].sub(tokens);\n', '            balances[to_address] = (balances[to_address]).add(tokens);\n', '            emit Transfer(msg.sender, to_address, tokens);\n', '            return true;\n', '        }\n', '        else\n', '        if (!lockstatus && msg.sender != owner) {\n', '        require( to_address != 0x0);\n', '        require(balances[msg.sender] >= tokens && tokens >= 0);\n', '        balances[msg.sender] = (balances[msg.sender]).sub(tokens);\n', '        balances[to_address] = (balances[to_address]).add(tokens);\n', '        emit Transfer(msg.sender, to_address, tokens);\n', '        return true;\n', '        }\n', '        else{\n', '            revert();\n', '        } \n', '    }\n', '    \n', '     function transferby(address _to,uint256 _amount) external onlyOwner returns(bool success) {\n', '        require( _to != 0x0); \n', '        require( balances[YettaCrowdSale] >= _amount && _amount > 0);\n', '        balances[YettaCrowdSale] = ( balances[YettaCrowdSale]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        emit Transfer(address(this), _to, _amount);\n', '        return true;\n', '    }\n', '}']