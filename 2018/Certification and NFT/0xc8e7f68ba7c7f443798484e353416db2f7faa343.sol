['pragma solidity ^0.4.24;\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract Crowdfund is Owned {\n', '     using SafeMath for uint;\n', '     \n', '    //mapping\n', '    mapping(address => uint256) public Holdings;\n', '    mapping(uint256 => address) public ContributorsList;\n', '    uint256 listPointer;\n', '    uint256 totalethfunded;\n', '    mapping(address => bool) public isInList;\n', '    bool crowdSaleOpen;\n', '    bool crowdSaleFail;\n', '    uint256 CFTsToSend;\n', '    \n', '    constructor() public{\n', '        crowdSaleOpen = true;\n', '    }\n', '    \n', '    modifier onlyWhenOpen() {\n', '        require(crowdSaleOpen == true);\n', '        _;\n', '    }\n', '    function amountOfCFTtoSend(address Holder)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 amount = CFTsToSend.mul( Holdings[Holder]).div(1 ether).div(totalethfunded);\n', '        return ( amount)  ;\n', '    }\n', '    function setAmountCFTsBought(uint256 amount) onlyOwner public{\n', '        CFTsToSend = amount;\n', '    }\n', '    function() external payable onlyWhenOpen {\n', '        require(msg.value > 0);\n', '        Holdings[msg.sender].add(msg.value);\n', '        if(isInList[msg.sender] == false){\n', '            ContributorsList[listPointer] = msg.sender;\n', '            listPointer++;\n', '            isInList[msg.sender] = true;\n', '        }\n', '    }\n', '    function balanceToOwner() onlyOwner public{\n', '        require(crowdSaleOpen == false);\n', '        totalethfunded = address(this).balance;\n', '        owner.transfer(address(this).balance);\n', '    }\n', '    function CloseCrowdfund() onlyOwner public{\n', '        crowdSaleOpen = false;\n', '    }\n', '    function failCrowdfund() onlyOwner public{\n', '        crowdSaleFail = true;\n', '    }\n', '    function retreiveEthuponFail () public {\n', '        require(crowdSaleFail == true);\n', '        require(Holdings[msg.sender] > 0);\n', '        uint256 getEthback = Holdings[msg.sender];\n', '        Holdings[msg.sender] = 0;\n', '        msg.sender.transfer(getEthback);\n', '    }\n', '}']