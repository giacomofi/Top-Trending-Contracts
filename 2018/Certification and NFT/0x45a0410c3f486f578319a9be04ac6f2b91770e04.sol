['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/idv/CvcValidatorRegistryInterface.sol\n', '\n', '/**\n', ' * @title CvcValidatorRegistryInterface\n', ' * @dev This contract defines Validator Registry interface.\n', ' */\n', 'contract CvcValidatorRegistryInterface {\n', '\n', '    /**\n', '    * @dev Adds a new Validator record or updates the existing one.\n', '    * @param _name Validator name.\n', '    * @param _description Validator description.\n', '    */\n', '    function set(address _idv, string _name, string _description) external;\n', '\n', '    /**\n', '    * @dev Returns Validator entry.\n', '    * @param _idv Validator address.\n', '    * @return name Validator name.\n', '    * @return description Validator description.\n', '    */\n', '    function get(address _idv) external view returns (string name, string description);\n', '\n', '    /**\n', '    * @dev Verifies whether Validator is registered.\n', '    * @param _idv Validator address.\n', '    * @return bool\n', '    */\n', '    function exists(address _idv) external view returns (bool);\n', '}\n', '\n', '// File: contracts/upgradeability/EternalStorage.sol\n', '\n', '/**\n', ' * @title EternalStorage\n', ' * @dev This contract defines the generic storage structure\n', ' * so that it could be re-used to implement any domain specific storage functionality\n', ' */\n', 'contract EternalStorage {\n', '\n', '    mapping(bytes32 => uint256) internal uintStorage;\n', '    mapping(bytes32 => string) internal stringStorage;\n', '    mapping(bytes32 => address) internal addressStorage;\n', '    mapping(bytes32 => bytes) internal bytesStorage;\n', '    mapping(bytes32 => bool) internal boolStorage;\n', '    mapping(bytes32 => int256) internal intStorage;\n', '    mapping(bytes32 => bytes32) internal bytes32Storage;\n', '\n', '}\n', '\n', '// File: contracts/upgradeability/ImplementationStorage.sol\n', '\n', '/**\n', ' * @title ImplementationStorage\n', ' * @dev This contract stores proxy implementation address.\n', ' */\n', 'contract ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "cvc.proxy.implementation", and is validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    */\n', '    constructor() public {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("cvc.proxy.implementation"));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/upgradeability/Initializable.sol\n', '\n', '/**\n', ' * @title Initializable\n', ' * @dev This contract provides basic initialization control\n', ' */\n', 'contract Initializable is EternalStorage, ImplementationStorage {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    mapping(bytes32 => bool) initialized;\n', '    **/\n', '\n', '    /**\n', '     * @dev Throws if called before contract was initialized.\n', '     */\n', '    modifier onlyInitialized() {\n', '        // require(initialized[implementation()]);\n', '        require(boolStorage[keccak256(abi.encodePacked(implementation(), "initialized"))], "Contract is not initialized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Controls the initialization state, allowing to call an initialization function only once.\n', '     */\n', '    modifier initializes() {\n', '        address impl = implementation();\n', '        // require(!initialized[implementation()]);\n', '        require(!boolStorage[keccak256(abi.encodePacked(impl, "initialized"))], "Contract is already initialized");\n', '        _;\n', '        // initialized[implementation()] = true;\n', '        boolStorage[keccak256(abi.encodePacked(impl, "initialized"))] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/upgradeability/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev This contract has an owner address providing basic authorization control\n', ' */\n', 'contract Ownable is EternalStorage {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    address owner;\n', '    **/\n', '\n', '    /**\n', '     * @dev Event to show ownership has been transferred\n', '     * @param previousOwner representing the address of the previous owner\n', '     * @param newOwner representing the address of the new owner\n', '     */\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner(), "Message sender must be contract admin");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Tells the address of the owner\n', '     * @return the address of the owner\n', '     */\n', '    function owner() public view returns (address) {\n', '        // return owner;\n', '        return addressStorage[keccak256("owner")];\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner the address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Contract owner cannot be zero address");\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets a new owner address\n', '     */\n', '    function setOwner(address newOwner) internal {\n', '        emit OwnershipTransferred(owner(), newOwner);\n', '        // owner = newOwner;\n', '        addressStorage[keccak256("owner")] = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/idv/CvcValidatorRegistry.sol\n', '\n', '/**\n', ' * @title CvcValidatorRegistry\n', ' * @dev This contract is a registry for Identity Validators (IDV). It is part of the marketplace access control mechanism.\n', ' * Only registered and authorized Identity Validators can perform certain actions on marketplace.\n', ' */\n', 'contract CvcValidatorRegistry is EternalStorage, Initializable, Ownable, CvcValidatorRegistryInterface {\n', '\n', '    /**\n', '    Data structures and storage layout:\n', '    struct Validator {\n', '        string name;\n', '        string description;\n', '    }\n', '    mapping(address => Validator) validators;\n', '    **/\n', '\n', '    /**\n', '    * @dev Constructor: invokes initialization function\n', '    */\n', '    constructor() public {\n', '        initialize(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Registers a new Validator or updates the existing one.\n', '    * @param _idv Validator address.\n', '    * @param _name Validator name.\n', '    * @param _description Validator description.\n', '    */\n', '    function set(address _idv, string _name, string _description) external onlyInitialized onlyOwner {\n', '        require(_idv != address(0), "Cannot register IDV with zero address");\n', '        require(bytes(_name).length > 0, "Cannot register IDV with empty name");\n', '\n', '        setValidatorName(_idv, _name);\n', '        setValidatorDescription(_idv, _description);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns Validator data.\n', '    * @param _idv Validator address.\n', '    * @return name Validator name.\n', '    * @return description Validator description.\n', '    */\n', '    function get(address _idv) external view onlyInitialized returns (string name, string description) {\n', '        name = getValidatorName(_idv);\n', '        description = getValidatorDescription(_idv);\n', '    }\n', '\n', '    /**\n', '    * @dev Verifies whether Validator is registered.\n', '    * @param _idv Validator address.\n', '    * @return bool\n', '    */\n', '    function exists(address _idv) external view onlyInitialized returns (bool) {\n', '        return bytes(getValidatorName(_idv)).length > 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Contract initialization method.\n', '    * @param _owner Owner address\n', '    */\n', '    function initialize(address _owner) public initializes {\n', '        setOwner(_owner);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns Validator name.\n', '    * @param _idv Validator address.\n', '    * @return string\n', '    */\n', '    function getValidatorName(address _idv) private view returns (string) {\n', '        // return validators[_idv].name;\n', '        return stringStorage[keccak256(abi.encodePacked("validators.", _idv, ".name"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Saves Validator name.\n', '    * @param _idv Validator address.\n', '    * @param _name Validator name.\n', '    */\n', '    function setValidatorName(address _idv, string _name) private {\n', '        // validators[_idv].name = _name;\n', '        stringStorage[keccak256(abi.encodePacked("validators.", _idv, ".name"))] = _name;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns Validator description.\n', '    * @param _idv Validator address.\n', '    * @return string\n', '    */\n', '    function getValidatorDescription(address _idv) private view returns (string) {\n', '        // return validators[_idv].description;\n', '        return stringStorage[keccak256(abi.encodePacked("validators.", _idv, ".description"))];\n', '    }\n', '\n', '    /**\n', '    * @dev Saves Validator description.\n', '    * @param _idv Validator address.\n', '    * @param _description Validator description.\n', '    */\n', '    function setValidatorDescription(address _idv, string _description) private {\n', '        // validators[_idv].description = _description;\n', '        stringStorage[keccak256(abi.encodePacked("validators.", _idv, ".description"))] = _description;\n', '    }\n', '\n', '}']