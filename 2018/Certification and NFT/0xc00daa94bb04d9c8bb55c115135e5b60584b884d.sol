['pragma solidity ^0.4.16;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure  returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    require(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '  function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  \n', '  using SafeMath for uint;\n', '  \n', '  mapping(address => uint) balances;\n', '\n', '  function transfer(address _to, uint _value) public{\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public {\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public{\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public{\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' *  TTC token contract. Implements\n', ' */\n', 'contract TTC is StandardToken, Ownable {\n', '  string public constant name = "TTC";\n', '  string public constant symbol = "TTC";\n', '  uint public constant decimals = 18;\n', '\n', '\n', '  // Constructor\n', '  function TTC() public {\n', '      totalSupply = 1000000000000000000000000000;\n', '      balances[msg.sender] = totalSupply; // Send all tokens to owner\n', '  }\n', '\n', '  /**\n', '   *  Burn away the specified amount of SkinCoin tokens\n', '   */\n', '  function burn(uint _value) onlyOwner public returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    totalSupply = totalSupply.sub(_value);\n', '    Transfer(msg.sender, 0x0, _value);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is Ownable{\n', '    \n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; \n', '        uint coinSent;\n', '        uint coinReadyToSend;\n', '    }\n', '\n', '    /*\n', '    * Constants\n', '    */\n', '\n', '    /**\n', '    * ICO Phases.\n', '    *\n', '    * - PreStart:   tokens are not yet sold/issued\n', '    * - PreIco:     new tokens sold/issued at the discounted price\n', '    * - PauseIco:   tokens are not sold/issued\n', '    * - MainIco     new tokens sold/issued at the regular price\n', '    * - AfterIco:   tokens are not sold/issued\n', '    */\n', '    enum Phases {PreStart, PreIco, PauseIco, MainIco, AfterIco}\n', '\n', '    /* Maximum number of TTC to pre ico sell */\n', '    uint public constant PRE_MAX_CAP = 25000000000000000000000000; // 25,000,000 TTC\n', '\n', '    /* Maximum number of TTC to main ico sell */\n', '    uint public constant MAIN_MAX_CAP = 125000000000000000000000000; // 125,000,000 TTC\n', '\n', '    /* Minimum amount to invest */\n', '    uint public constant MIN_INVEST_ETHER = 100 finney;\n', '\n', '    /* Crowdsale period */\n', '    uint private constant PRE_START_TIME = 1520820000;  // 2018-03-12 10:00 AM (UTC + 08:00)\n', '    uint private constant PRE_END_TIME = 1521079200;    // 2018-03-15 10:00 AM (UTC + 08:00)\n', '    uint private constant MAIN_START_TIME = 1522029600; // 2018-03-26 10:00 AM (UTC + 08:00)\n', '    uint private constant MAIN_END_TIME = 1524189600;   // 2018-04-20 10:00 AM (UTC + 08:00)\n', '\n', '    /* Number of TTC per Ether */\n', '    uint public constant PRE_COIN_PER_ETHER_ICO = 5000000000000000000000; // 5,000 TTC\n', '    uint public constant MAIN_COIN_PER_ETHER_ICO = 4000000000000000000000; // 4,000 TTC\n', '\n', '    /*\n', '    * Variables\n', '    */\n', '    /* TTC contract reference */\n', '    TTC public coin;\n', '\n', '    /*Maximum Ether for one address during pre ico or main ico */\n', '    uint public maximumCoinsPerAddress = 10 ether;\n', '    \n', '    /* Multisig contract that will receive the Ether during pre ico*/\n', '    address public preMultisigEther;\n', '    /* Number of Ether received during pre ico */\n', '    uint public preEtherReceived;\n', '    /* Number of TTC sent to Ether contributors during pre ico */\n', '    uint public preCoinSentToEther;\n', '\n', '    /* Multisig contract that will receive the Ether during main ico*/\n', '    address public mainMultisigEther;\n', '    /* Number of Ether received during main ico */\n', '    uint public mainEtherReceived;\n', '    /* Number of TTC sent to Ether contributors during main ico */\n', '    uint public mainCoinSentToEther;\n', '\n', '    /* Backers Ether indexed by their Ethereum address */\n', '    mapping(address => Backer) public preBackers;\n', '    address[] internal preReadyToSendAddress;\n', '    mapping(address => Backer) public mainBackers;\n', '    address[] internal mainReadyToSendAddress;\n', '\n', '    /* White List */\n', '    mapping(address => bool) public whiteList;\n', '\n', '    /* Current Phase */\n', '    Phases public phase = Phases.PreStart;\n', '\n', '    /*\n', '    * Modifiers\n', '    */\n', '\n', '    modifier respectTimeFrame() {\n', '        require((now >= PRE_START_TIME) && (now < PRE_END_TIME ) || (now >= MAIN_START_TIME) && (now < MAIN_END_TIME ));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Event\n', '    */\n', '    event LogReceivedETH(address addr, uint value);\n', '    event LogCoinsEmited(address indexed from, uint amount);\n', '\n', '    /*\n', '     * Constructor\n', '    */\n', '    function Crowdsale() public{\n', '        \n', '    }\n', '\n', '    /**\n', '    *   Allow to set TTC address\n', '    */\n', '    function setTTCAddress(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        coin = TTC(_addr);\n', '    }\n', '\n', '    /**\n', '     * Allow to change the team multisig address in the case of emergency.\n', '     */\n', '    function setMultisigPre(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        preMultisigEther = _addr;\n', '    }\n', '\n', '    /**\n', '     * Allow to change the team multisig address in the case of emergency.\n', '     */\n', '    function setMultisigMain(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        mainMultisigEther = _addr;\n', '    }\n', '\n', '    /**\n', '    *   Allow to change the maximum Coin one address can buy during the ico\n', '    */\n', '    function setMaximumCoinsPerAddress(uint _cnt) onlyOwner public{\n', '        maximumCoinsPerAddress = _cnt;\n', '    }\n', '\n', '    /* \n', '     * The fallback function corresponds to a donation in ETH\n', '     */\n', '    function() respectTimeFrame  payable public{\n', '        require(whiteList[msg.sender]);\n', '        receiveETH(msg.sender);\n', '    }\n', '\n', '    /*\n', '     *  Receives a donation in Ether\n', '    */\n', '    function receiveETH(address _beneficiary) internal {\n', '        require(msg.value >= MIN_INVEST_ETHER) ; \n', '        adjustPhaseBasedOnTime();\n', '        uint coinToSend ;\n', '\n', '        if(phase == Phases.PreIco) {\n', '            Backer storage preBacker = preBackers[_beneficiary];\n', '            require(preBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\n', '\n', '            coinToSend = msg.value.mul(PRE_COIN_PER_ETHER_ICO).div(1 ether); \n', '            require(coinToSend.add(preCoinSentToEther) <= PRE_MAX_CAP) ;\n', '\n', '            preBacker.coinSent = preBacker.coinSent.add(coinToSend);\n', '            preBacker.weiReceived = preBacker.weiReceived.add(msg.value);   \n', '            preBacker.coinReadyToSend = preBacker.coinReadyToSend.add(coinToSend);\n', '            preReadyToSendAddress.push(_beneficiary);\n', '\n', '            // Update the total wei collected during the crowdfunding\n', '            preEtherReceived = preEtherReceived.add(msg.value); \n', '            preCoinSentToEther = preCoinSentToEther.add(coinToSend);\n', '\n', '            // Send events\n', '            LogReceivedETH(_beneficiary, preEtherReceived); \n', '\n', '        }else if (phase == Phases.MainIco){\n', '            Backer storage mainBacker = mainBackers[_beneficiary];\n', '            require(mainBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\n', '\n', '            coinToSend = msg.value.mul(MAIN_COIN_PER_ETHER_ICO).div(1 ether);   \n', '            require(coinToSend.add(mainCoinSentToEther) <= MAIN_MAX_CAP) ;\n', '\n', '            mainBacker.coinSent = mainBacker.coinSent.add(coinToSend);\n', '            mainBacker.weiReceived = mainBacker.weiReceived.add(msg.value);   \n', '            mainBacker.coinReadyToSend = mainBacker.coinReadyToSend.add(coinToSend);\n', '            mainReadyToSendAddress.push(_beneficiary);\n', '\n', '            // Update the total wei collected during the crowdfunding\n', '            mainEtherReceived = mainEtherReceived.add(msg.value); \n', '            mainCoinSentToEther = mainCoinSentToEther.add(coinToSend);\n', '\n', '            // Send events\n', '            LogReceivedETH(_beneficiary, mainEtherReceived); \n', '        }\n', '    }\n', '\n', '    /*\n', '    *   Adjust phase base on time\n', '    */\n', '    function adjustPhaseBasedOnTime() internal {\n', '\n', '        if (now < PRE_START_TIME) {\n', '            if (phase != Phases.PreStart) {\n', '                phase = Phases.PreStart;\n', '            }\n', '        } else if (now >= PRE_START_TIME && now < PRE_END_TIME) {\n', '            if (phase != Phases.PreIco) {\n', '                phase = Phases.PreIco;\n', '            }\n', '        } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) {\n', '            if (phase != Phases.PauseIco) {\n', '                phase = Phases.PauseIco;\n', '            }\n', '        }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) {\n', '            if (phase != Phases.MainIco) {\n', '                phase = Phases.MainIco;\n', '            }\n', '        }else {\n', '            if (phase != Phases.AfterIco){\n', '                phase = Phases.AfterIco;\n', '            }\n', '        }\n', '    }\n', '    \n', '\n', '    /*\n', '    *   Durign the pre ico, should be called by owner to send TTC to beneficiary address\n', '    */\n', '    function preSendTTC() onlyOwner public {\n', '        for(uint i=0; i < preReadyToSendAddress.length ; i++){\n', '            address backerAddress = preReadyToSendAddress[i];\n', '            uint coinReadyToSend = preBackers[backerAddress].coinReadyToSend;\n', '            if ( coinReadyToSend > 0) {\n', '                preBackers[backerAddress].coinReadyToSend = 0;\n', '                coin.transfer(backerAddress, coinReadyToSend);\n', '                LogCoinsEmited(backerAddress, coinReadyToSend);\n', '            }\n', '        }\n', '        delete preReadyToSendAddress;\n', '        require(preMultisigEther.send(this.balance)) ; \n', '    }\n', '\n', '    /*\n', '    *   Durign the main ico, should be called by owner to send TTC to beneficiary address\n', '    */\n', '    function mainSendTTC() onlyOwner public{\n', '        for(uint i=0; i < mainReadyToSendAddress.length ; i++){\n', '            address backerAddress = mainReadyToSendAddress[i];\n', '            uint coinReadyToSend = mainBackers[backerAddress].coinReadyToSend;\n', '            if ( coinReadyToSend > 0) {\n', '                mainBackers[backerAddress].coinReadyToSend = 0;\n', '                coin.transfer(backerAddress, coinReadyToSend);\n', '                LogCoinsEmited(backerAddress, coinReadyToSend);\n', '            }\n', '        }\n', '        delete mainReadyToSendAddress;\n', '        require(mainMultisigEther.send(this.balance)) ; \n', '\n', '    }\n', '\n', '    /*\n', '    *  White list, only address in white list can buy TTC\n', '    */\n', '    function addWhiteList(address[] _whiteList) onlyOwner public{\n', '        for (uint i =0;i<_whiteList.length;i++){\n', '            whiteList[_whiteList[i]] = true;\n', '        }   \n', '    }\n', '\n', '    /*  \n', '     * Finalize the crowdsale, should be called after the refund period\n', '    */\n', '    function finalize() onlyOwner public {\n', '        adjustPhaseBasedOnTime();\n', '        require(phase == Phases.AfterIco);\n', '        require(this.balance > 0);\n', '        require(mainMultisigEther.send(this.balance)) ; \n', '        uint remains = coin.balanceOf(this);\n', '        if (remains > 0) { \n', '            coin.transfer(owner,remains);\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Manually back TTC owner address.\n', '     */\n', '    function backTTCOwner() onlyOwner public {\n', '        coin.transferOwnership(owner);\n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer remains to owner in case if impossible to do min invest\n', '     */\n', '    function getPreRemainCoins() onlyOwner public {\n', '        uint preRemains = PRE_MAX_CAP - preCoinSentToEther;\n', '        Backer storage backer = preBackers[owner];\n', '        coin.transfer(owner, preRemains); \n', '        backer.coinSent = backer.coinSent.add(preRemains);\n', '        preCoinSentToEther = preCoinSentToEther.add(preRemains);\n', '        \n', '        LogCoinsEmited(this ,preRemains);\n', '        LogReceivedETH(owner, preEtherReceived); \n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer remains to owner in case if impossible to do min invest\n', '     */\n', '    function getMainRemainCoins() onlyOwner public {\n', '        uint mainRemains = MAIN_MAX_CAP - mainCoinSentToEther;\n', '        Backer storage backer = mainBackers[owner];\n', '        coin.transfer(owner, mainRemains); \n', '        backer.coinSent = backer.coinSent.add(mainRemains);\n', '        mainCoinSentToEther = mainCoinSentToEther.add(mainRemains);\n', '\n', '        LogCoinsEmited(this ,mainRemains);\n', '        LogReceivedETH(owner, mainEtherReceived); \n', '    }\n', '\n', '    /**\n', '    *   Refund to specific address \n', '    */\n', '    function refund(address _beneficiary) onlyOwner public {\n', '\n', '        uint valueToSend = 0;\n', '        Backer storage preBacker = preBackers[_beneficiary];\n', '        if (preBacker.coinReadyToSend > 0){ \n', '            uint preValueToSend = preBacker.coinReadyToSend.mul(1 ether).div(PRE_COIN_PER_ETHER_ICO);\n', '            preBacker.coinSent = preBacker.coinSent.sub(preBacker.coinReadyToSend);\n', '            preBacker.weiReceived = preBacker.weiReceived.sub(preValueToSend);   \n', '            preEtherReceived = preEtherReceived.sub(preValueToSend); \n', '            preCoinSentToEther = preCoinSentToEther.sub(preBacker.coinReadyToSend);\n', '            preBacker.coinReadyToSend = 0;\n', '            valueToSend = valueToSend + preValueToSend;\n', '\n', '        }\n', '\n', '        Backer storage mainBacker = mainBackers[_beneficiary];\n', '        if (mainBacker.coinReadyToSend > 0){ \n', '            uint mainValueToSend = mainBacker.coinReadyToSend.mul(1 ether).div(MAIN_COIN_PER_ETHER_ICO);\n', '            mainBacker.coinSent = mainBacker.coinSent.sub(mainBacker.coinReadyToSend);\n', '            mainBacker.weiReceived = mainBacker.weiReceived.sub(mainValueToSend);   \n', '            mainEtherReceived = mainEtherReceived.sub(mainValueToSend); \n', '            mainCoinSentToEther = mainCoinSentToEther.sub(mainBacker.coinReadyToSend);\n', '            mainBacker.coinReadyToSend = 0;\n', '            valueToSend = valueToSend + mainValueToSend;\n', '\n', '        }\n', '        if (valueToSend > 0){\n', '            require(_beneficiary.send(valueToSend));\n', '        }\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '    *   Refund to all address\n', '    */  \n', '    function refundAll() onlyOwner public {\n', '\n', '        for(uint i=0; i < preReadyToSendAddress.length ; i++){\n', '            refund(preReadyToSendAddress[i]);\n', '\n', '        }\n', '        \n', '        for(uint j=0; j < mainReadyToSendAddress.length ; j++){\n', '            refund(mainReadyToSendAddress[j]);\n', '\n', '        }\n', '\n', '        delete preReadyToSendAddress;\n', '        delete mainReadyToSendAddress;\n', '\n', '    }\n', '    \n', '\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure  returns (uint) {\n', '    uint c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    require(b > 0);\n', '    uint c = a / b;\n', '    require(a == b * c + a % b);\n', '    return c;\n', '  }\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '  function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function transfer(address to, uint value) public;\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public;\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  \n', '  using SafeMath for uint;\n', '  \n', '  mapping(address => uint) balances;\n', '\n', '  function transfer(address _to, uint _value) public{\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) public constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', '\n', 'contract StandardToken is BasicToken, ERC20 {\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint _value) public {\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) public{\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public{\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' *  TTC token contract. Implements\n', ' */\n', 'contract TTC is StandardToken, Ownable {\n', '  string public constant name = "TTC";\n', '  string public constant symbol = "TTC";\n', '  uint public constant decimals = 18;\n', '\n', '\n', '  // Constructor\n', '  function TTC() public {\n', '      totalSupply = 1000000000000000000000000000;\n', '      balances[msg.sender] = totalSupply; // Send all tokens to owner\n', '  }\n', '\n', '  /**\n', '   *  Burn away the specified amount of SkinCoin tokens\n', '   */\n', '  function burn(uint _value) onlyOwner public returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    totalSupply = totalSupply.sub(_value);\n', '    Transfer(msg.sender, 0x0, _value);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract Crowdsale is Ownable{\n', '    \n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; \n', '        uint coinSent;\n', '        uint coinReadyToSend;\n', '    }\n', '\n', '    /*\n', '    * Constants\n', '    */\n', '\n', '    /**\n', '    * ICO Phases.\n', '    *\n', '    * - PreStart:   tokens are not yet sold/issued\n', '    * - PreIco:     new tokens sold/issued at the discounted price\n', '    * - PauseIco:   tokens are not sold/issued\n', '    * - MainIco     new tokens sold/issued at the regular price\n', '    * - AfterIco:   tokens are not sold/issued\n', '    */\n', '    enum Phases {PreStart, PreIco, PauseIco, MainIco, AfterIco}\n', '\n', '    /* Maximum number of TTC to pre ico sell */\n', '    uint public constant PRE_MAX_CAP = 25000000000000000000000000; // 25,000,000 TTC\n', '\n', '    /* Maximum number of TTC to main ico sell */\n', '    uint public constant MAIN_MAX_CAP = 125000000000000000000000000; // 125,000,000 TTC\n', '\n', '    /* Minimum amount to invest */\n', '    uint public constant MIN_INVEST_ETHER = 100 finney;\n', '\n', '    /* Crowdsale period */\n', '    uint private constant PRE_START_TIME = 1520820000;  // 2018-03-12 10:00 AM (UTC + 08:00)\n', '    uint private constant PRE_END_TIME = 1521079200;    // 2018-03-15 10:00 AM (UTC + 08:00)\n', '    uint private constant MAIN_START_TIME = 1522029600; // 2018-03-26 10:00 AM (UTC + 08:00)\n', '    uint private constant MAIN_END_TIME = 1524189600;   // 2018-04-20 10:00 AM (UTC + 08:00)\n', '\n', '    /* Number of TTC per Ether */\n', '    uint public constant PRE_COIN_PER_ETHER_ICO = 5000000000000000000000; // 5,000 TTC\n', '    uint public constant MAIN_COIN_PER_ETHER_ICO = 4000000000000000000000; // 4,000 TTC\n', '\n', '    /*\n', '    * Variables\n', '    */\n', '    /* TTC contract reference */\n', '    TTC public coin;\n', '\n', '    /*Maximum Ether for one address during pre ico or main ico */\n', '    uint public maximumCoinsPerAddress = 10 ether;\n', '    \n', '    /* Multisig contract that will receive the Ether during pre ico*/\n', '    address public preMultisigEther;\n', '    /* Number of Ether received during pre ico */\n', '    uint public preEtherReceived;\n', '    /* Number of TTC sent to Ether contributors during pre ico */\n', '    uint public preCoinSentToEther;\n', '\n', '    /* Multisig contract that will receive the Ether during main ico*/\n', '    address public mainMultisigEther;\n', '    /* Number of Ether received during main ico */\n', '    uint public mainEtherReceived;\n', '    /* Number of TTC sent to Ether contributors during main ico */\n', '    uint public mainCoinSentToEther;\n', '\n', '    /* Backers Ether indexed by their Ethereum address */\n', '    mapping(address => Backer) public preBackers;\n', '    address[] internal preReadyToSendAddress;\n', '    mapping(address => Backer) public mainBackers;\n', '    address[] internal mainReadyToSendAddress;\n', '\n', '    /* White List */\n', '    mapping(address => bool) public whiteList;\n', '\n', '    /* Current Phase */\n', '    Phases public phase = Phases.PreStart;\n', '\n', '    /*\n', '    * Modifiers\n', '    */\n', '\n', '    modifier respectTimeFrame() {\n', '        require((now >= PRE_START_TIME) && (now < PRE_END_TIME ) || (now >= MAIN_START_TIME) && (now < MAIN_END_TIME ));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Event\n', '    */\n', '    event LogReceivedETH(address addr, uint value);\n', '    event LogCoinsEmited(address indexed from, uint amount);\n', '\n', '    /*\n', '     * Constructor\n', '    */\n', '    function Crowdsale() public{\n', '        \n', '    }\n', '\n', '    /**\n', '    *   Allow to set TTC address\n', '    */\n', '    function setTTCAddress(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        coin = TTC(_addr);\n', '    }\n', '\n', '    /**\n', '     * Allow to change the team multisig address in the case of emergency.\n', '     */\n', '    function setMultisigPre(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        preMultisigEther = _addr;\n', '    }\n', '\n', '    /**\n', '     * Allow to change the team multisig address in the case of emergency.\n', '     */\n', '    function setMultisigMain(address _addr) onlyOwner public {\n', '        require(_addr != address(0));\n', '        mainMultisigEther = _addr;\n', '    }\n', '\n', '    /**\n', '    *   Allow to change the maximum Coin one address can buy during the ico\n', '    */\n', '    function setMaximumCoinsPerAddress(uint _cnt) onlyOwner public{\n', '        maximumCoinsPerAddress = _cnt;\n', '    }\n', '\n', '    /* \n', '     * The fallback function corresponds to a donation in ETH\n', '     */\n', '    function() respectTimeFrame  payable public{\n', '        require(whiteList[msg.sender]);\n', '        receiveETH(msg.sender);\n', '    }\n', '\n', '    /*\n', '     *  Receives a donation in Ether\n', '    */\n', '    function receiveETH(address _beneficiary) internal {\n', '        require(msg.value >= MIN_INVEST_ETHER) ; \n', '        adjustPhaseBasedOnTime();\n', '        uint coinToSend ;\n', '\n', '        if(phase == Phases.PreIco) {\n', '            Backer storage preBacker = preBackers[_beneficiary];\n', '            require(preBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\n', '\n', '            coinToSend = msg.value.mul(PRE_COIN_PER_ETHER_ICO).div(1 ether); \n', '            require(coinToSend.add(preCoinSentToEther) <= PRE_MAX_CAP) ;\n', '\n', '            preBacker.coinSent = preBacker.coinSent.add(coinToSend);\n', '            preBacker.weiReceived = preBacker.weiReceived.add(msg.value);   \n', '            preBacker.coinReadyToSend = preBacker.coinReadyToSend.add(coinToSend);\n', '            preReadyToSendAddress.push(_beneficiary);\n', '\n', '            // Update the total wei collected during the crowdfunding\n', '            preEtherReceived = preEtherReceived.add(msg.value); \n', '            preCoinSentToEther = preCoinSentToEther.add(coinToSend);\n', '\n', '            // Send events\n', '            LogReceivedETH(_beneficiary, preEtherReceived); \n', '\n', '        }else if (phase == Phases.MainIco){\n', '            Backer storage mainBacker = mainBackers[_beneficiary];\n', '            require(mainBacker.weiReceived.add(msg.value) <= maximumCoinsPerAddress);\n', '\n', '            coinToSend = msg.value.mul(MAIN_COIN_PER_ETHER_ICO).div(1 ether);   \n', '            require(coinToSend.add(mainCoinSentToEther) <= MAIN_MAX_CAP) ;\n', '\n', '            mainBacker.coinSent = mainBacker.coinSent.add(coinToSend);\n', '            mainBacker.weiReceived = mainBacker.weiReceived.add(msg.value);   \n', '            mainBacker.coinReadyToSend = mainBacker.coinReadyToSend.add(coinToSend);\n', '            mainReadyToSendAddress.push(_beneficiary);\n', '\n', '            // Update the total wei collected during the crowdfunding\n', '            mainEtherReceived = mainEtherReceived.add(msg.value); \n', '            mainCoinSentToEther = mainCoinSentToEther.add(coinToSend);\n', '\n', '            // Send events\n', '            LogReceivedETH(_beneficiary, mainEtherReceived); \n', '        }\n', '    }\n', '\n', '    /*\n', '    *   Adjust phase base on time\n', '    */\n', '    function adjustPhaseBasedOnTime() internal {\n', '\n', '        if (now < PRE_START_TIME) {\n', '            if (phase != Phases.PreStart) {\n', '                phase = Phases.PreStart;\n', '            }\n', '        } else if (now >= PRE_START_TIME && now < PRE_END_TIME) {\n', '            if (phase != Phases.PreIco) {\n', '                phase = Phases.PreIco;\n', '            }\n', '        } else if (now >= PRE_END_TIME && now < MAIN_START_TIME) {\n', '            if (phase != Phases.PauseIco) {\n', '                phase = Phases.PauseIco;\n', '            }\n', '        }else if (now >= MAIN_START_TIME && now < MAIN_END_TIME) {\n', '            if (phase != Phases.MainIco) {\n', '                phase = Phases.MainIco;\n', '            }\n', '        }else {\n', '            if (phase != Phases.AfterIco){\n', '                phase = Phases.AfterIco;\n', '            }\n', '        }\n', '    }\n', '    \n', '\n', '    /*\n', '    *   Durign the pre ico, should be called by owner to send TTC to beneficiary address\n', '    */\n', '    function preSendTTC() onlyOwner public {\n', '        for(uint i=0; i < preReadyToSendAddress.length ; i++){\n', '            address backerAddress = preReadyToSendAddress[i];\n', '            uint coinReadyToSend = preBackers[backerAddress].coinReadyToSend;\n', '            if ( coinReadyToSend > 0) {\n', '                preBackers[backerAddress].coinReadyToSend = 0;\n', '                coin.transfer(backerAddress, coinReadyToSend);\n', '                LogCoinsEmited(backerAddress, coinReadyToSend);\n', '            }\n', '        }\n', '        delete preReadyToSendAddress;\n', '        require(preMultisigEther.send(this.balance)) ; \n', '    }\n', '\n', '    /*\n', '    *   Durign the main ico, should be called by owner to send TTC to beneficiary address\n', '    */\n', '    function mainSendTTC() onlyOwner public{\n', '        for(uint i=0; i < mainReadyToSendAddress.length ; i++){\n', '            address backerAddress = mainReadyToSendAddress[i];\n', '            uint coinReadyToSend = mainBackers[backerAddress].coinReadyToSend;\n', '            if ( coinReadyToSend > 0) {\n', '                mainBackers[backerAddress].coinReadyToSend = 0;\n', '                coin.transfer(backerAddress, coinReadyToSend);\n', '                LogCoinsEmited(backerAddress, coinReadyToSend);\n', '            }\n', '        }\n', '        delete mainReadyToSendAddress;\n', '        require(mainMultisigEther.send(this.balance)) ; \n', '\n', '    }\n', '\n', '    /*\n', '    *  White list, only address in white list can buy TTC\n', '    */\n', '    function addWhiteList(address[] _whiteList) onlyOwner public{\n', '        for (uint i =0;i<_whiteList.length;i++){\n', '            whiteList[_whiteList[i]] = true;\n', '        }   \n', '    }\n', '\n', '    /*  \n', '     * Finalize the crowdsale, should be called after the refund period\n', '    */\n', '    function finalize() onlyOwner public {\n', '        adjustPhaseBasedOnTime();\n', '        require(phase == Phases.AfterIco);\n', '        require(this.balance > 0);\n', '        require(mainMultisigEther.send(this.balance)) ; \n', '        uint remains = coin.balanceOf(this);\n', '        if (remains > 0) { \n', '            coin.transfer(owner,remains);\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Manually back TTC owner address.\n', '     */\n', '    function backTTCOwner() onlyOwner public {\n', '        coin.transferOwnership(owner);\n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer remains to owner in case if impossible to do min invest\n', '     */\n', '    function getPreRemainCoins() onlyOwner public {\n', '        uint preRemains = PRE_MAX_CAP - preCoinSentToEther;\n', '        Backer storage backer = preBackers[owner];\n', '        coin.transfer(owner, preRemains); \n', '        backer.coinSent = backer.coinSent.add(preRemains);\n', '        preCoinSentToEther = preCoinSentToEther.add(preRemains);\n', '        \n', '        LogCoinsEmited(this ,preRemains);\n', '        LogReceivedETH(owner, preEtherReceived); \n', '    }\n', '\n', '\n', '    /**\n', '     * Transfer remains to owner in case if impossible to do min invest\n', '     */\n', '    function getMainRemainCoins() onlyOwner public {\n', '        uint mainRemains = MAIN_MAX_CAP - mainCoinSentToEther;\n', '        Backer storage backer = mainBackers[owner];\n', '        coin.transfer(owner, mainRemains); \n', '        backer.coinSent = backer.coinSent.add(mainRemains);\n', '        mainCoinSentToEther = mainCoinSentToEther.add(mainRemains);\n', '\n', '        LogCoinsEmited(this ,mainRemains);\n', '        LogReceivedETH(owner, mainEtherReceived); \n', '    }\n', '\n', '    /**\n', '    *   Refund to specific address \n', '    */\n', '    function refund(address _beneficiary) onlyOwner public {\n', '\n', '        uint valueToSend = 0;\n', '        Backer storage preBacker = preBackers[_beneficiary];\n', '        if (preBacker.coinReadyToSend > 0){ \n', '            uint preValueToSend = preBacker.coinReadyToSend.mul(1 ether).div(PRE_COIN_PER_ETHER_ICO);\n', '            preBacker.coinSent = preBacker.coinSent.sub(preBacker.coinReadyToSend);\n', '            preBacker.weiReceived = preBacker.weiReceived.sub(preValueToSend);   \n', '            preEtherReceived = preEtherReceived.sub(preValueToSend); \n', '            preCoinSentToEther = preCoinSentToEther.sub(preBacker.coinReadyToSend);\n', '            preBacker.coinReadyToSend = 0;\n', '            valueToSend = valueToSend + preValueToSend;\n', '\n', '        }\n', '\n', '        Backer storage mainBacker = mainBackers[_beneficiary];\n', '        if (mainBacker.coinReadyToSend > 0){ \n', '            uint mainValueToSend = mainBacker.coinReadyToSend.mul(1 ether).div(MAIN_COIN_PER_ETHER_ICO);\n', '            mainBacker.coinSent = mainBacker.coinSent.sub(mainBacker.coinReadyToSend);\n', '            mainBacker.weiReceived = mainBacker.weiReceived.sub(mainValueToSend);   \n', '            mainEtherReceived = mainEtherReceived.sub(mainValueToSend); \n', '            mainCoinSentToEther = mainCoinSentToEther.sub(mainBacker.coinReadyToSend);\n', '            mainBacker.coinReadyToSend = 0;\n', '            valueToSend = valueToSend + mainValueToSend;\n', '\n', '        }\n', '        if (valueToSend > 0){\n', '            require(_beneficiary.send(valueToSend));\n', '        }\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '    *   Refund to all address\n', '    */  \n', '    function refundAll() onlyOwner public {\n', '\n', '        for(uint i=0; i < preReadyToSendAddress.length ; i++){\n', '            refund(preReadyToSendAddress[i]);\n', '\n', '        }\n', '        \n', '        for(uint j=0; j < mainReadyToSendAddress.length ; j++){\n', '            refund(mainReadyToSendAddress[j]);\n', '\n', '        }\n', '\n', '        delete preReadyToSendAddress;\n', '        delete mainReadyToSendAddress;\n', '\n', '    }\n', '    \n', '\n', '}']
