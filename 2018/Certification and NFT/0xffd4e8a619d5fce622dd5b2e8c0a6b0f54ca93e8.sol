['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '   OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function takeOwnership(uint256 _tokenId) public;\n', '}\n', '\n', '\n', '/// @title CryptoCelebritiesMarket\n', '/// @dev Contains models, variables, and internal methods for sales.\n', 'contract CelebrityMarket is Pausable{\n', '\n', '    ERC721 ccContract;\n', '\n', '    // Represents a sale item on an NFT\n', '    struct Sale {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) at beginning of a sale item\n', '        uint256 salePrice;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '    }\n', '\n', '    // Owner of this contract\n', '    address public owner;\n', '\n', '    // Map from token ID to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    event SaleCreated(address seller,uint256 tokenId, uint256 salePrice, uint256 startedAt);\n', '    event SaleSuccessful(address seller, uint256 tokenId, uint256 totalPrice, address winner);\n', '    event SaleCancelled(address seller, uint256 tokenId);\n', '    event SaleUpdated(address seller, uint256 tokenId, uint256 oldPrice, uint256 newPrice);\n', '    \n', '    /// @dev Constructor registers the nft address (CCAddress)\n', '    /// @param _ccAddress - Address of the CryptoCelebrities contract\n', '    function CelebrityMarket(address _ccAddress) public {\n', '        ccContract = ERC721(_ccAddress);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev DON&#39;T give me your money.\n', '    function() external {}\n', '\n', '\n', '    /// @dev Remove all Ether from the contract, which is the owner&#39;s cuts\n', '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        require(\n', '            msg.sender == owner\n', '        );\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _tokenId - ID of token to sell, sender must be owner.\n', '    /// @param _salePrice - Sale Price of item (in wei).\n', '    function createSale(\n', '        uint256 _tokenId,\n', '        uint256 _salePrice\n', '    )\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(_owns(msg.sender, _tokenId));\n', '        _escrow(_tokenId);\n', '        Sale memory sale = Sale(\n', '            msg.sender,\n', '            _salePrice,\n', '            uint64(now)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', '    /// @dev Update sale price of a sale item that hasn&#39;t been completed yet.\n', '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    /// @param _newPrice - new sale price\n', '    function updateSalePrice(uint256 _tokenId, uint256 _newPrice)\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _updateSalePrice(_tokenId, _newPrice, seller);\n', '    }\n', '\n', '    /// @dev Allows to buy a sale item, completing the sale and transferring\n', '    /// ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to buy.\n', '    function buy(uint256 _tokenId)\n', '        public\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '        _buy(_tokenId, msg.value);\n', '        _transfer(msg.sender, _tokenId);\n', '    }\n', '\n', '    /// @dev Cancels a sale that hasn&#39;t been completed yet.\n', '    ///  Returns the NFT to original owner.\n', '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    function cancelSale(uint256 _tokenId)\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /// @dev Cancels a sale when the contract is paused.\n', '    ///  Only the owner may do this, and NFTs are returned to\n', '    ///  the seller. This should only be used in emergencies.\n', '    /// @param _tokenId - ID of the NFT on sale to cancel.\n', '    function cancelSaleWhenPaused(uint256 _tokenId)\n', '        whenPaused\n', '        onlyOwner\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        _cancelSale(_tokenId, sale.seller);\n', '    }\n', '\n', '    /// @dev Returns sale info for an NFT on sale.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function getSale(uint256 _tokenId)\n', '        public\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 salePrice,\n', '        uint256 startedAt\n', '    ) {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.salePrice,\n', '            sale.startedAt\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the current price of a sale item.\n', '    /// @param _tokenId - ID of the token price we are checking.\n', '    function getSalePrice(uint256 _tokenId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return sale.salePrice;\n', '    }\n', '\n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (ccContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /// @dev Escrows the CCToken, assigning ownership to this contract.\n', '    /// Throws if the escrow fails.\n', '    /// @param _tokenId - ID of token whose approval to verify.\n', '    function _escrow(uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        ccContract.takeOwnership(_tokenId);\n', '    }\n', '\n', '    /// @dev Transfers a CCToken owned by this contract to another address.\n', '    /// Returns true if the transfer succeeds.\n', '    /// @param _receiver - Address to transfer NFT to.\n', '    /// @param _tokenId - ID of token to transfer.\n', '    function _transfer(address _receiver, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        ccContract.transfer(_receiver, _tokenId);\n', '    }\n', '\n', '    /// @dev Adds a sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    /// @param _tokenId The ID of the token to be put on sale.\n', '    /// @param _sale Sale to add.\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '\n', '        tokenIdToSale[_tokenId] = _sale;\n', '        \n', '        SaleCreated(\n', '            address(_sale.seller),\n', '            uint256(_tokenId),\n', '            uint256(_sale.salePrice),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /// @dev Cancels a sale unconditionally.\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        _removeSale(_tokenId);\n', '        _transfer(_seller, _tokenId);\n', '        SaleCancelled(_seller, _tokenId);\n', '    }\n', '\n', '    /// @dev updates sale price of item\n', '    function _updateSalePrice(uint256 _tokenId, uint256 _newPrice, address _seller) internal {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        uint256 oldPrice = sale.salePrice;\n', '        sale.salePrice = _newPrice;\n', '        SaleUpdated(_seller, _tokenId, oldPrice, _newPrice);\n', '    }\n', '\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _buy(uint256 _tokenId, uint256 _amount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        // Explicitly check that this sale is currently live.\n', '        // (Because of how Ethereum mappings work, we can&#39;t just count\n', '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return an sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the incoming bid is higher than the current\n', '        // price\n', '        uint256 price = sale.salePrice;\n', '\n', '        require(_amount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', '        // to the sender so we can&#39;t have a reentrancy attack.\n', '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', '            //  Calculate the market owner&#39;s cut.\n', '            // (NOTE: _computeCut() is guaranteed to return a\n', '            //  value <= price, so this subtraction can&#39;t go negative.)\n', '            uint256 ownerCut = _computeCut(price);\n', '            uint256 sellerProceeds = price - ownerCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the sale item\n', '            // before calling transfer(), and the only thing the seller\n', '            // can DoS is the sale of their own asset! (And if it&#39;s an\n', '            // accident, they can call cancelSale(). )\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 amountExcess = _amount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the sale is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(amountExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(seller, _tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    /// @dev Removes a sale item from the list of open sales.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /// @dev Returns true if the NFT is on sale.\n', '    /// @param _sale - Sale to check.\n', '    function _isOnSale(Sale storage _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', '    /// @dev Computes owner&#39;s cut of a sale.\n', '    /// @param _price - Sale price of NFT.\n', '    function _computeCut(uint256 _price) internal pure returns (uint256) {\n', '        return uint256(SafeMath.div(SafeMath.mul(_price, 6), 100));\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '   OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 interface\n', ' * @dev see https://github.com/ethereum/eips/issues/721\n', ' */\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function transfer(address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function takeOwnership(uint256 _tokenId) public;\n', '}\n', '\n', '\n', '/// @title CryptoCelebritiesMarket\n', '/// @dev Contains models, variables, and internal methods for sales.\n', 'contract CelebrityMarket is Pausable{\n', '\n', '    ERC721 ccContract;\n', '\n', '    // Represents a sale item on an NFT\n', '    struct Sale {\n', '        // Current owner of NFT\n', '        address seller;\n', '        // Price (in wei) at beginning of a sale item\n', '        uint256 salePrice;\n', '        // Time when sale started\n', '        // NOTE: 0 if this sale has been concluded\n', '        uint64 startedAt;\n', '    }\n', '\n', '    // Owner of this contract\n', '    address public owner;\n', '\n', '    // Map from token ID to their corresponding sale.\n', '    mapping (uint256 => Sale) tokenIdToSale;\n', '\n', '    event SaleCreated(address seller,uint256 tokenId, uint256 salePrice, uint256 startedAt);\n', '    event SaleSuccessful(address seller, uint256 tokenId, uint256 totalPrice, address winner);\n', '    event SaleCancelled(address seller, uint256 tokenId);\n', '    event SaleUpdated(address seller, uint256 tokenId, uint256 oldPrice, uint256 newPrice);\n', '    \n', '    /// @dev Constructor registers the nft address (CCAddress)\n', '    /// @param _ccAddress - Address of the CryptoCelebrities contract\n', '    function CelebrityMarket(address _ccAddress) public {\n', '        ccContract = ERC721(_ccAddress);\n', '        owner = msg.sender;\n', '    }\n', '\n', "    /// @dev DON'T give me your money.\n", '    function() external {}\n', '\n', '\n', "    /// @dev Remove all Ether from the contract, which is the owner's cuts\n", '    ///  as well as any Ether sent directly to the contract address.\n', '    ///  Always transfers to the NFT contract, but can be called either by\n', '    ///  the owner or the NFT contract.\n', '    function withdrawBalance() external {\n', '        require(\n', '            msg.sender == owner\n', '        );\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /// @dev Creates and begins a new sale.\n', '    /// @param _tokenId - ID of token to sell, sender must be owner.\n', '    /// @param _salePrice - Sale Price of item (in wei).\n', '    function createSale(\n', '        uint256 _tokenId,\n', '        uint256 _salePrice\n', '    )\n', '        public\n', '        whenNotPaused\n', '    {\n', '        require(_owns(msg.sender, _tokenId));\n', '        _escrow(_tokenId);\n', '        Sale memory sale = Sale(\n', '            msg.sender,\n', '            _salePrice,\n', '            uint64(now)\n', '        );\n', '        _addSale(_tokenId, sale);\n', '    }\n', '\n', "    /// @dev Update sale price of a sale item that hasn't been completed yet.\n", '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    /// @param _newPrice - new sale price\n', '    function updateSalePrice(uint256 _tokenId, uint256 _newPrice)\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _updateSalePrice(_tokenId, _newPrice, seller);\n', '    }\n', '\n', '    /// @dev Allows to buy a sale item, completing the sale and transferring\n', '    /// ownership of the NFT if enough Ether is supplied.\n', '    /// @param _tokenId - ID of token to buy.\n', '    function buy(uint256 _tokenId)\n', '        public\n', '        payable\n', '        whenNotPaused\n', '    {\n', '        // _bid will throw if the bid or funds transfer fails\n', '        _buy(_tokenId, msg.value);\n', '        _transfer(msg.sender, _tokenId);\n', '    }\n', '\n', "    /// @dev Cancels a sale that hasn't been completed yet.\n", '    ///  Returns the NFT to original owner.\n', '    /// @notice This is a state-modifying function that can\n', '    ///  be called while the contract is paused.\n', '    /// @param _tokenId - ID of token on sale\n', '    function cancelSale(uint256 _tokenId)\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        address seller = sale.seller;\n', '        require(msg.sender == seller);\n', '        _cancelSale(_tokenId, seller);\n', '    }\n', '\n', '    /// @dev Cancels a sale when the contract is paused.\n', '    ///  Only the owner may do this, and NFTs are returned to\n', '    ///  the seller. This should only be used in emergencies.\n', '    /// @param _tokenId - ID of the NFT on sale to cancel.\n', '    function cancelSaleWhenPaused(uint256 _tokenId)\n', '        whenPaused\n', '        onlyOwner\n', '        public\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        _cancelSale(_tokenId, sale.seller);\n', '    }\n', '\n', '    /// @dev Returns sale info for an NFT on sale.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function getSale(uint256 _tokenId)\n', '        public\n', '        view\n', '        returns\n', '    (\n', '        address seller,\n', '        uint256 salePrice,\n', '        uint256 startedAt\n', '    ) {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return (\n', '            sale.seller,\n', '            sale.salePrice,\n', '            sale.startedAt\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the current price of a sale item.\n', '    /// @param _tokenId - ID of the token price we are checking.\n', '    function getSalePrice(uint256 _tokenId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        require(_isOnSale(sale));\n', '        return sale.salePrice;\n', '    }\n', '\n', '    /// @dev Returns true if the claimant owns the token.\n', '    /// @param _claimant - Address claiming to own the token.\n', '    /// @param _tokenId - ID of token whose ownership to verify.\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return (ccContract.ownerOf(_tokenId) == _claimant);\n', '    }\n', '\n', '    /// @dev Escrows the CCToken, assigning ownership to this contract.\n', '    /// Throws if the escrow fails.\n', '    /// @param _tokenId - ID of token whose approval to verify.\n', '    function _escrow(uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        ccContract.takeOwnership(_tokenId);\n', '    }\n', '\n', '    /// @dev Transfers a CCToken owned by this contract to another address.\n', '    /// Returns true if the transfer succeeds.\n', '    /// @param _receiver - Address to transfer NFT to.\n', '    /// @param _tokenId - ID of token to transfer.\n', '    function _transfer(address _receiver, uint256 _tokenId) internal {\n', '        // it will throw if transfer fails\n', '        ccContract.transfer(_receiver, _tokenId);\n', '    }\n', '\n', '    /// @dev Adds a sale to the list of open sales. Also fires the\n', '    ///  SaleCreated event.\n', '    /// @param _tokenId The ID of the token to be put on sale.\n', '    /// @param _sale Sale to add.\n', '    function _addSale(uint256 _tokenId, Sale _sale) internal {\n', '\n', '        tokenIdToSale[_tokenId] = _sale;\n', '        \n', '        SaleCreated(\n', '            address(_sale.seller),\n', '            uint256(_tokenId),\n', '            uint256(_sale.salePrice),\n', '            uint256(_sale.startedAt)\n', '        );\n', '    }\n', '\n', '    /// @dev Cancels a sale unconditionally.\n', '    function _cancelSale(uint256 _tokenId, address _seller) internal {\n', '        _removeSale(_tokenId);\n', '        _transfer(_seller, _tokenId);\n', '        SaleCancelled(_seller, _tokenId);\n', '    }\n', '\n', '    /// @dev updates sale price of item\n', '    function _updateSalePrice(uint256 _tokenId, uint256 _newPrice, address _seller) internal {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '        uint256 oldPrice = sale.salePrice;\n', '        sale.salePrice = _newPrice;\n', '        SaleUpdated(_seller, _tokenId, oldPrice, _newPrice);\n', '    }\n', '\n', '    /// @dev Computes the price and transfers winnings.\n', '    /// Does NOT transfer ownership of token.\n', '    function _buy(uint256 _tokenId, uint256 _amount)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Get a reference to the sale struct\n', '        Sale storage sale = tokenIdToSale[_tokenId];\n', '\n', '        // Explicitly check that this sale is currently live.\n', "        // (Because of how Ethereum mappings work, we can't just count\n", '        // on the lookup above failing. An invalid _tokenId will just\n', '        // return an sale object that is all zeros.)\n', '        require(_isOnSale(sale));\n', '\n', '        // Check that the incoming bid is higher than the current\n', '        // price\n', '        uint256 price = sale.salePrice;\n', '\n', '        require(_amount >= price);\n', '\n', '        // Grab a reference to the seller before the sale struct\n', '        // gets deleted.\n', '        address seller = sale.seller;\n', '\n', '        // The bid is good! Remove the sale before sending the fees\n', "        // to the sender so we can't have a reentrancy attack.\n", '        _removeSale(_tokenId);\n', '\n', '        // Transfer proceeds to seller (if there are any!)\n', '        if (price > 0) {\n', "            //  Calculate the market owner's cut.\n", '            // (NOTE: _computeCut() is guaranteed to return a\n', "            //  value <= price, so this subtraction can't go negative.)\n", '            uint256 ownerCut = _computeCut(price);\n', '            uint256 sellerProceeds = price - ownerCut;\n', '\n', '            // NOTE: Doing a transfer() in the middle of a complex\n', '            // method like this is generally discouraged because of\n', '            // reentrancy attacks and DoS attacks if the seller is\n', '            // a contract with an invalid fallback function. We explicitly\n', '            // guard against reentrancy attacks by removing the sale item\n', '            // before calling transfer(), and the only thing the seller\n', "            // can DoS is the sale of their own asset! (And if it's an\n", '            // accident, they can call cancelSale(). )\n', '            seller.transfer(sellerProceeds);\n', '        }\n', '\n', '        // Calculate any excess funds included with the bid. If the excess\n', '        // is anything worth worrying about, transfer it back to bidder.\n', '        // NOTE: We checked above that the bid amount is greater than or\n', '        // equal to the price so this cannot underflow.\n', '        uint256 amountExcess = _amount - price;\n', '\n', '        // Return the funds. Similar to the previous transfer, this is\n', '        // not susceptible to a re-entry attack because the sale is\n', '        // removed before any transfers occur.\n', '        msg.sender.transfer(amountExcess);\n', '\n', '        // Tell the world!\n', '        SaleSuccessful(seller, _tokenId, price, msg.sender);\n', '\n', '        return price;\n', '    }\n', '\n', '    /// @dev Removes a sale item from the list of open sales.\n', '    /// @param _tokenId - ID of NFT on sale.\n', '    function _removeSale(uint256 _tokenId) internal {\n', '        delete tokenIdToSale[_tokenId];\n', '    }\n', '\n', '    /// @dev Returns true if the NFT is on sale.\n', '    /// @param _sale - Sale to check.\n', '    function _isOnSale(Sale storage _sale) internal view returns (bool) {\n', '        return (_sale.startedAt > 0);\n', '    }\n', '\n', "    /// @dev Computes owner's cut of a sale.\n", '    /// @param _price - Sale price of NFT.\n', '    function _computeCut(uint256 _price) internal pure returns (uint256) {\n', '        return uint256(SafeMath.div(SafeMath.mul(_price, 6), 100));\n', '    }\n', '\n', '}']
