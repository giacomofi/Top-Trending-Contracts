['pragma solidity ^0.4.16;\n', '\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', '\n', 'contract owned {\n', '    function owned() public { owner = msg.sender; }\n', '    address owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract PublicSaleManager is owned {\n', '\n', '    mapping (address => bool) _earlyList;\n', '    mapping (address => bool) _whiteList;\n', '    mapping (address => uint256) _bonus;\n', '    mapping (address => uint256) _contributedETH;\n', '\n', '    address _tokenAddress = 0xAF815e887b039Fc06a8ddDcC7Ec4f57757616Cd2;\n', '    address _deadAddress = 0x000000000000000000000000000000000000dead;\n', '    uint256 _conversionRate = 0;\n', '    uint256 _startTime = 0;\n', '\n', '    uint256 _totalSold = 0;\n', '    uint256 _totalBonus = 0;\n', '\n', '    uint256 _regularPersonalCap = 1e20; // 100 ETH\n', '    uint256 _higherPersonalCap = 2e20; // 200 ETH\n', '    uint256 _minimumAmount = 2e17; // 0.2 ETH\n', '\n', '    bool _is_stopped = false;\n', '\n', '    function addWhitelist(address[] addressList) public onlyOwner {\n', '        // Whitelist is managed manually and addresses are added in batch.\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            _whiteList[addressList[i]] = true;\n', '        }\n', '    }\n', '    \n', '    function addEarlylist(address[] addressList) public onlyOwner {\n', '        // Whitelist is managed manually and addresses are added in batch.\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            _earlyList[addressList[i]] = true;\n', '        }\n', '    }\n', '\n', '    function start(uint32 conversionRate) public onlyOwner {\n', '        require(_startTime == 0);\n', '        require(conversionRate > 1);\n', '\n', '        // Starts the public sale.\n', '        _startTime = now;\n', '\n', '        // Sets the conversion rate.\n', '        _conversionRate = conversionRate;\n', '    }\n', '\n', '    function stop() public onlyOwner {\n', '        _is_stopped = true;\n', '    }\n', '\n', '    function burnUnsold() public onlyOwner {\n', '        require(now >= _startTime + (31 days));\n', '\n', '        // Transfers all un-sold tokens to 0x000...dead.\n', '        ERC20(_tokenAddress).transfer(_deadAddress, ERC20(_tokenAddress).balanceOf(this) - _totalBonus);\n', '    }\n', '\n', '    function withdrawEther(address toAddress, uint256 amount) public onlyOwner {\n', '        toAddress.transfer(amount);\n', '    }\n', '\n', '    function buyTokens() payable public {\n', '        require(_is_stopped == false);\n', '\n', '        // Validates whitelist.\n', '        require(_whiteList[msg.sender] == true || _earlyList[msg.sender] == true);\n', '\n', '        if (_earlyList[msg.sender]) {\n', '            require(msg.value + _contributedETH[msg.sender] <= _higherPersonalCap);\n', '        } else {\n', '            require(msg.value + _contributedETH[msg.sender] <= _regularPersonalCap);\n', '        }\n', '\n', '        require(msg.value >= _minimumAmount);\n', '\n', '        // Validates time.\n', '        require(now > _startTime);\n', '        require(now < _startTime + (31 days));\n', '\n', '        // Calculates the purchase amount.\n', '        uint256 purchaseAmount = msg.value * _conversionRate;\n', '        require(_conversionRate > 0 && purchaseAmount / _conversionRate == msg.value);\n', '\n', '        // Calculates the bonus amount.\n', '        uint256 bonus = 0;\n', '        if (_totalSold + purchaseAmount < 5e26) {\n', '            // 10% bonus for the first 500 million OGT.\n', '            bonus = purchaseAmount / 10;\n', '        } else if (_totalSold + purchaseAmount < 10e26) {\n', '            // 5% bonus for the first 1 billion OGT.\n', '            bonus = purchaseAmount / 20;\n', '        }\n', '\n', '        // Checks that we still have enough balance.\n', '        require(ERC20(_tokenAddress).balanceOf(this) >= _totalBonus + purchaseAmount + bonus);\n', '\n', '        // Transfers the non-bonus part.\n', '        ERC20(_tokenAddress).transfer(msg.sender, purchaseAmount);\n', '        _contributedETH[msg.sender] += msg.value;\n', '\n', '        // Records the bonus.\n', '        _bonus[msg.sender] += bonus;\n', '\n', '        _totalBonus += bonus;\n', '        _totalSold += (purchaseAmount + bonus);\n', '    }\n', '\n', '    function claimBonus() public {\n', '        // Validates whitelist.\n', '        require(_whiteList[msg.sender] == true || _earlyList[msg.sender] == true);\n', '        \n', '        // Validates bonus.\n', '        require(_bonus[msg.sender] > 0);\n', '\n', '        // Transfers the bonus if it&#39;s after 90 days.\n', '        if (now > _startTime + (90 days)) {\n', '            ERC20(_tokenAddress).transfer(msg.sender, _bonus[msg.sender]);\n', '            _bonus[msg.sender] = 0;\n', '        }\n', '    }\n', '\n', '    function checkBonus(address purchaser) public constant returns (uint256 balance) {\n', '        return _bonus[purchaser];\n', '    }\n', '\n', '    function checkTotalSold() public constant returns (uint256 balance) {\n', '        return _totalSold;\n', '    }\n', '\n', '    function checkContributedETH(address purchaser) public constant returns (uint256 balance) {\n', '        return _contributedETH[purchaser];\n', '    }\n', '\n', '    function checkPersonalRemaining(address purchaser) public constant returns (uint256 balance) {\n', '        if (_earlyList[purchaser]) {\n', '            return _higherPersonalCap - _contributedETH[purchaser];\n', '        } else if (_whiteList[purchaser]) {\n', '            return _regularPersonalCap - _contributedETH[purchaser];\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', '\n', 'contract owned {\n', '    function owned() public { owner = msg.sender; }\n', '    address owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', 'contract PublicSaleManager is owned {\n', '\n', '    mapping (address => bool) _earlyList;\n', '    mapping (address => bool) _whiteList;\n', '    mapping (address => uint256) _bonus;\n', '    mapping (address => uint256) _contributedETH;\n', '\n', '    address _tokenAddress = 0xAF815e887b039Fc06a8ddDcC7Ec4f57757616Cd2;\n', '    address _deadAddress = 0x000000000000000000000000000000000000dead;\n', '    uint256 _conversionRate = 0;\n', '    uint256 _startTime = 0;\n', '\n', '    uint256 _totalSold = 0;\n', '    uint256 _totalBonus = 0;\n', '\n', '    uint256 _regularPersonalCap = 1e20; // 100 ETH\n', '    uint256 _higherPersonalCap = 2e20; // 200 ETH\n', '    uint256 _minimumAmount = 2e17; // 0.2 ETH\n', '\n', '    bool _is_stopped = false;\n', '\n', '    function addWhitelist(address[] addressList) public onlyOwner {\n', '        // Whitelist is managed manually and addresses are added in batch.\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            _whiteList[addressList[i]] = true;\n', '        }\n', '    }\n', '    \n', '    function addEarlylist(address[] addressList) public onlyOwner {\n', '        // Whitelist is managed manually and addresses are added in batch.\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            _earlyList[addressList[i]] = true;\n', '        }\n', '    }\n', '\n', '    function start(uint32 conversionRate) public onlyOwner {\n', '        require(_startTime == 0);\n', '        require(conversionRate > 1);\n', '\n', '        // Starts the public sale.\n', '        _startTime = now;\n', '\n', '        // Sets the conversion rate.\n', '        _conversionRate = conversionRate;\n', '    }\n', '\n', '    function stop() public onlyOwner {\n', '        _is_stopped = true;\n', '    }\n', '\n', '    function burnUnsold() public onlyOwner {\n', '        require(now >= _startTime + (31 days));\n', '\n', '        // Transfers all un-sold tokens to 0x000...dead.\n', '        ERC20(_tokenAddress).transfer(_deadAddress, ERC20(_tokenAddress).balanceOf(this) - _totalBonus);\n', '    }\n', '\n', '    function withdrawEther(address toAddress, uint256 amount) public onlyOwner {\n', '        toAddress.transfer(amount);\n', '    }\n', '\n', '    function buyTokens() payable public {\n', '        require(_is_stopped == false);\n', '\n', '        // Validates whitelist.\n', '        require(_whiteList[msg.sender] == true || _earlyList[msg.sender] == true);\n', '\n', '        if (_earlyList[msg.sender]) {\n', '            require(msg.value + _contributedETH[msg.sender] <= _higherPersonalCap);\n', '        } else {\n', '            require(msg.value + _contributedETH[msg.sender] <= _regularPersonalCap);\n', '        }\n', '\n', '        require(msg.value >= _minimumAmount);\n', '\n', '        // Validates time.\n', '        require(now > _startTime);\n', '        require(now < _startTime + (31 days));\n', '\n', '        // Calculates the purchase amount.\n', '        uint256 purchaseAmount = msg.value * _conversionRate;\n', '        require(_conversionRate > 0 && purchaseAmount / _conversionRate == msg.value);\n', '\n', '        // Calculates the bonus amount.\n', '        uint256 bonus = 0;\n', '        if (_totalSold + purchaseAmount < 5e26) {\n', '            // 10% bonus for the first 500 million OGT.\n', '            bonus = purchaseAmount / 10;\n', '        } else if (_totalSold + purchaseAmount < 10e26) {\n', '            // 5% bonus for the first 1 billion OGT.\n', '            bonus = purchaseAmount / 20;\n', '        }\n', '\n', '        // Checks that we still have enough balance.\n', '        require(ERC20(_tokenAddress).balanceOf(this) >= _totalBonus + purchaseAmount + bonus);\n', '\n', '        // Transfers the non-bonus part.\n', '        ERC20(_tokenAddress).transfer(msg.sender, purchaseAmount);\n', '        _contributedETH[msg.sender] += msg.value;\n', '\n', '        // Records the bonus.\n', '        _bonus[msg.sender] += bonus;\n', '\n', '        _totalBonus += bonus;\n', '        _totalSold += (purchaseAmount + bonus);\n', '    }\n', '\n', '    function claimBonus() public {\n', '        // Validates whitelist.\n', '        require(_whiteList[msg.sender] == true || _earlyList[msg.sender] == true);\n', '        \n', '        // Validates bonus.\n', '        require(_bonus[msg.sender] > 0);\n', '\n', "        // Transfers the bonus if it's after 90 days.\n", '        if (now > _startTime + (90 days)) {\n', '            ERC20(_tokenAddress).transfer(msg.sender, _bonus[msg.sender]);\n', '            _bonus[msg.sender] = 0;\n', '        }\n', '    }\n', '\n', '    function checkBonus(address purchaser) public constant returns (uint256 balance) {\n', '        return _bonus[purchaser];\n', '    }\n', '\n', '    function checkTotalSold() public constant returns (uint256 balance) {\n', '        return _totalSold;\n', '    }\n', '\n', '    function checkContributedETH(address purchaser) public constant returns (uint256 balance) {\n', '        return _contributedETH[purchaser];\n', '    }\n', '\n', '    function checkPersonalRemaining(address purchaser) public constant returns (uint256 balance) {\n', '        if (_earlyList[purchaser]) {\n', '            return _higherPersonalCap - _contributedETH[purchaser];\n', '        } else if (_whiteList[purchaser]) {\n', '            return _regularPersonalCap - _contributedETH[purchaser];\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}']
