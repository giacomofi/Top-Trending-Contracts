['pragma solidity ^0.4.24;\n', '\n', '// (c) copyright SecureVote 2018\n', '// github.com/secure-vote/sv-light-smart-contracts\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract TokenAbbreviationLookup is hasAdmins {\n', '\n', '    event RecordAdded(bytes32 abbreviation, bytes32 democHash, bool hidden);\n', '\n', '    struct Record {\n', '        bytes32 democHash;\n', '        bool hidden;\n', '    }\n', '\n', '    struct EditRec {\n', '        bytes32 abbreviation;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (bytes32 => Record) public lookup;\n', '\n', '    EditRec[] public edits;\n', '\n', '    function nEdits() external view returns (uint) {\n', '        return edits.length;\n', '    }\n', '\n', '    function lookupAllSince(uint pastTs) external view returns (bytes32[] memory abrvs, bytes32[] memory democHashes, bool[] memory hiddens) {\n', '        bytes32 abrv;\n', '        for (uint i = 0; i < edits.length; i++) {\n', '            if (edits[i].timestamp >= pastTs) {\n', '                abrv = edits[i].abbreviation;\n', '                Record storage r = lookup[abrv];\n', '                abrvs = MemArrApp.appendBytes32(abrvs, abrv);\n', '                democHashes = MemArrApp.appendBytes32(democHashes, r.democHash);\n', '                hiddens = MemArrApp.appendBool(hiddens, r.hidden);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addRecord(bytes32 abrv, bytes32 democHash, bool hidden) only_admin() external {\n', '        lookup[abrv] = Record(democHash, hidden);\n', '        edits.push(EditRec(abrv, now));\n', '        emit RecordAdded(abrv, democHash, hidden);\n', '    }\n', '\n', '}\n', '\n', 'library MemArrApp {\n', '\n', '    // A simple library to allow appending to memory arrays.\n', '\n', '    function appendUint256(uint256[] memory arr, uint256 val) internal pure returns (uint256[] memory toRet) {\n', '        toRet = new uint256[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint128(uint128[] memory arr, uint128 val) internal pure returns (uint128[] memory toRet) {\n', '        toRet = new uint128[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint64(uint64[] memory arr, uint64 val) internal pure returns (uint64[] memory toRet) {\n', '        toRet = new uint64[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint32(uint32[] memory arr, uint32 val) internal pure returns (uint32[] memory toRet) {\n', '        toRet = new uint32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint16(uint16[] memory arr, uint16 val) internal pure returns (uint16[] memory toRet) {\n', '        toRet = new uint16[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBool(bool[] memory arr, bool val) internal pure returns (bool[] memory toRet) {\n', '        toRet = new bool[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32(bytes32[] memory arr, bytes32 val) internal pure returns (bytes32[] memory toRet) {\n', '        toRet = new bytes32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32Pair(bytes32[2][] memory arr, bytes32[2] val) internal pure returns (bytes32[2][] memory toRet) {\n', '        toRet = new bytes32[2][](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes(bytes[] memory arr, bytes val) internal pure returns (bytes[] memory toRet) {\n', '        toRet = new bytes[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendAddress(address[] memory arr, address val) internal pure returns (address[] memory toRet) {\n', '        toRet = new address[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// (c) copyright SecureVote 2018\n', '// github.com/secure-vote/sv-light-smart-contracts\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner\'s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract TokenAbbreviationLookup is hasAdmins {\n', '\n', '    event RecordAdded(bytes32 abbreviation, bytes32 democHash, bool hidden);\n', '\n', '    struct Record {\n', '        bytes32 democHash;\n', '        bool hidden;\n', '    }\n', '\n', '    struct EditRec {\n', '        bytes32 abbreviation;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping (bytes32 => Record) public lookup;\n', '\n', '    EditRec[] public edits;\n', '\n', '    function nEdits() external view returns (uint) {\n', '        return edits.length;\n', '    }\n', '\n', '    function lookupAllSince(uint pastTs) external view returns (bytes32[] memory abrvs, bytes32[] memory democHashes, bool[] memory hiddens) {\n', '        bytes32 abrv;\n', '        for (uint i = 0; i < edits.length; i++) {\n', '            if (edits[i].timestamp >= pastTs) {\n', '                abrv = edits[i].abbreviation;\n', '                Record storage r = lookup[abrv];\n', '                abrvs = MemArrApp.appendBytes32(abrvs, abrv);\n', '                democHashes = MemArrApp.appendBytes32(democHashes, r.democHash);\n', '                hiddens = MemArrApp.appendBool(hiddens, r.hidden);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addRecord(bytes32 abrv, bytes32 democHash, bool hidden) only_admin() external {\n', '        lookup[abrv] = Record(democHash, hidden);\n', '        edits.push(EditRec(abrv, now));\n', '        emit RecordAdded(abrv, democHash, hidden);\n', '    }\n', '\n', '}\n', '\n', 'library MemArrApp {\n', '\n', '    // A simple library to allow appending to memory arrays.\n', '\n', '    function appendUint256(uint256[] memory arr, uint256 val) internal pure returns (uint256[] memory toRet) {\n', '        toRet = new uint256[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint128(uint128[] memory arr, uint128 val) internal pure returns (uint128[] memory toRet) {\n', '        toRet = new uint128[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint64(uint64[] memory arr, uint64 val) internal pure returns (uint64[] memory toRet) {\n', '        toRet = new uint64[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint32(uint32[] memory arr, uint32 val) internal pure returns (uint32[] memory toRet) {\n', '        toRet = new uint32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendUint16(uint16[] memory arr, uint16 val) internal pure returns (uint16[] memory toRet) {\n', '        toRet = new uint16[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBool(bool[] memory arr, bool val) internal pure returns (bool[] memory toRet) {\n', '        toRet = new bool[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32(bytes32[] memory arr, bytes32 val) internal pure returns (bytes32[] memory toRet) {\n', '        toRet = new bytes32[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes32Pair(bytes32[2][] memory arr, bytes32[2] val) internal pure returns (bytes32[2][] memory toRet) {\n', '        toRet = new bytes32[2][](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendBytes(bytes[] memory arr, bytes val) internal pure returns (bytes[] memory toRet) {\n', '        toRet = new bytes[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '    function appendAddress(address[] memory arr, address val) internal pure returns (address[] memory toRet) {\n', '        toRet = new address[](arr.length + 1);\n', '\n', '        for (uint256 i = 0; i < arr.length; i++) {\n', '            toRet[i] = arr[i];\n', '        }\n', '\n', '        toRet[arr.length] = val;\n', '    }\n', '\n', '}']
