['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' *  @notice the token contract used as reward \n', ' */\n', 'interface token {\n', '    /*\n', '     *  @notice exposes the transfer method of the token contract\n', '     *  @param _receiver address receiving tokens\n', '     *  @param _amount number of tokens being transferred       \n', '     */    \n', '    function transfer(address _receiver, uint _amount) returns (bool success);\n', '}\n', '\n', '/*\n', ' * is owned\n', ' */\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() { \n', '        require (msg.sender == owner); \n', '        _; \n', '    }\n', '\n', '    function ownerTransferOwnership(address newOwner) onlyOwner\n', '    {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '/* \n', '*  BOSTokenCrowdfund contract\n', '*  Funds sent to this address transfer a customized ERC20 token to msg.sender for the duration of the crowdfund\n', '*  Deployment order:\n', '*  1. BOSToken, BOSTokenCrowdfund\n', '*  2. Send tokens to this\n', '*  3. -- crowdfund is open --\n', '*/\n', 'contract BOSTokenCrowdfund is owned, SafeMath {\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /**\n', '     * check only allowPublicWithdraw\n', '     */\n', '    modifier onlyAllowPublicWithdraw() { \n', '        require (allowPublicWithdraw); \n', '        _; \n', '    }\n', '\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    /* 0.000004 ETH per token base price */\n', '    uint public sellPrice = 0.000004 ether;\n', '    /* total amount of ether raised */\n', '    uint public amountRaised;\n', '    /* address of token used as reward */\n', '    token public tokenReward;\n', '    /* crowdsale is open */\n', '    bool public crowdsaleClosed = false;\n', '    /* map balance of address */\n', '    mapping (address => uint) public balanceOf;\n', '    /* allow public withdraw */\n', '    bool public allowPublicWithdraw = false;\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    /* log events */\n', '    event LogFundTransfer(address indexed Backer, uint indexed Amount, bool indexed IsContribution);\n', '\n', '    /*\n', '     *  @param _fundingGoalInEthers the funding goal of the crowdfund\n', '     *  @param _durationInMinutes the length of the crowdfund in minutes\n', '     *  @param _addressOfTokenUsedAsReward the token address   \n', '     */  \n', '    function BOSTokenCrowdfund(\n', '        /* token */\n', '        token _addressOfTokenUsedAsReward\n', '    ) {\n', '        tokenReward = token(_addressOfTokenUsedAsReward);\n', '    }\n', '\n', '    /*\n', '     *  @notice public function\n', '     *  default function is payable\n', '     *  responsible for transfer of tokens based on price, msg.sender and msg.value\n', '     *  tracks investment total of msg.sender\n', '     *  refunds any spare change\n', '     */      \n', '    function () payable\n', '    {\n', '        require (!crowdsaleClosed);\n', '        /* do not allow creating 0 */\n', '        require (msg.value > 0);\n', '\n', '        uint tokens = SafeMath.safeMul(SafeMath.safeDiv(msg.value, sellPrice), 1 ether);\n', '        if(tokenReward.transfer(msg.sender, tokens)) {\n', '            LogFundTransfer(msg.sender, msg.value, true); \n', '        } else {\n', '            throw;\n', '        }\n', '\n', '        /* add to amountRaised */\n', '        amountRaised = SafeMath.safeAdd(amountRaised, msg.value);\n', '        /* track ETH balanceOf address in case emergency refund is required */\n', '        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], msg.value);\n', '    }\n', '\n', '    /*\n', '     *  @notice public function\n', '     *  emergency manual refunds\n', '     */     \n', '    function publicWithdraw() public\n', '        onlyAllowPublicWithdraw\n', '    {\n', '        /* manual refunds */\n', '        calcRefund(msg.sender);\n', '    }\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    /*\n', '     *  @notice internal function\n', '     *  @param _addressToRefund the address being refunded\n', '     *  accessed via public functions publicWithdraw\n', '     *  calculates refund amount available for an address\n', '     */\n', '    function calcRefund(address _addressToRefund) internal\n', '    {\n', '        /* assigns var amount to balance of _addressToRefund */\n', '        uint amount = balanceOf[_addressToRefund];\n', '        /* sets balance to 0 */\n', '        balanceOf[_addressToRefund] = 0;\n', '        /* is there any balance? */\n', '        if (amount > 0) {\n', '            /* call to untrusted address */\n', '            _addressToRefund.transfer(amount);\n', '            /* log event */\n', '            LogFundTransfer(_addressToRefund, amount, false);\n', '        }\n', '    }\n', '\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    /*\n', '     *  @notice public function\n', '     *  onlyOwner\n', '     *  moves ether to _to address\n', '     */\n', '    function withdrawAmountTo (uint256 _amount, address _to) public\n', '        onlyOwner\n', '    {\n', '        _to.transfer(_amount);\n', '        LogFundTransfer(_to, _amount, false);\n', '    }\n', '\n', '    /**\n', '     *  @notice owner restricted function\n', '     *  @param status boolean\n', '     *  sets contract crowdsaleClosed\n', '     */\n', '    function ownerSetCrowdsaleClosed (bool status) public onlyOwner\n', '    {\n', '        crowdsaleClosed = status;\n', '    }\n', '\n', '    /**\n', '     *  @notice owner restricted function\n', '     *  @param status boolean\n', '     *  sets contract allowPublicWithdraw\n', '     */\n', '    function ownerSetAllowPublicWithdraw (bool status) public onlyOwner\n', '    {\n', '        allowPublicWithdraw = status;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', ' *  @notice the token contract used as reward \n', ' */\n', 'interface token {\n', '    /*\n', '     *  @notice exposes the transfer method of the token contract\n', '     *  @param _receiver address receiving tokens\n', '     *  @param _amount number of tokens being transferred       \n', '     */    \n', '    function transfer(address _receiver, uint _amount) returns (bool success);\n', '}\n', '\n', '/*\n', ' * is owned\n', ' */\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() { \n', '        require (msg.sender == owner); \n', '        _; \n', '    }\n', '\n', '    function ownerTransferOwnership(address newOwner) onlyOwner\n', '    {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '/* \n', '*  BOSTokenCrowdfund contract\n', '*  Funds sent to this address transfer a customized ERC20 token to msg.sender for the duration of the crowdfund\n', '*  Deployment order:\n', '*  1. BOSToken, BOSTokenCrowdfund\n', '*  2. Send tokens to this\n', '*  3. -- crowdfund is open --\n', '*/\n', 'contract BOSTokenCrowdfund is owned, SafeMath {\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '\n', '    /**\n', '     * check only allowPublicWithdraw\n', '     */\n', '    modifier onlyAllowPublicWithdraw() { \n', '        require (allowPublicWithdraw); \n', '        _; \n', '    }\n', '\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    /* 0.000004 ETH per token base price */\n', '    uint public sellPrice = 0.000004 ether;\n', '    /* total amount of ether raised */\n', '    uint public amountRaised;\n', '    /* address of token used as reward */\n', '    token public tokenReward;\n', '    /* crowdsale is open */\n', '    bool public crowdsaleClosed = false;\n', '    /* map balance of address */\n', '    mapping (address => uint) public balanceOf;\n', '    /* allow public withdraw */\n', '    bool public allowPublicWithdraw = false;\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    /* log events */\n', '    event LogFundTransfer(address indexed Backer, uint indexed Amount, bool indexed IsContribution);\n', '\n', '    /*\n', '     *  @param _fundingGoalInEthers the funding goal of the crowdfund\n', '     *  @param _durationInMinutes the length of the crowdfund in minutes\n', '     *  @param _addressOfTokenUsedAsReward the token address   \n', '     */  \n', '    function BOSTokenCrowdfund(\n', '        /* token */\n', '        token _addressOfTokenUsedAsReward\n', '    ) {\n', '        tokenReward = token(_addressOfTokenUsedAsReward);\n', '    }\n', '\n', '    /*\n', '     *  @notice public function\n', '     *  default function is payable\n', '     *  responsible for transfer of tokens based on price, msg.sender and msg.value\n', '     *  tracks investment total of msg.sender\n', '     *  refunds any spare change\n', '     */      \n', '    function () payable\n', '    {\n', '        require (!crowdsaleClosed);\n', '        /* do not allow creating 0 */\n', '        require (msg.value > 0);\n', '\n', '        uint tokens = SafeMath.safeMul(SafeMath.safeDiv(msg.value, sellPrice), 1 ether);\n', '        if(tokenReward.transfer(msg.sender, tokens)) {\n', '            LogFundTransfer(msg.sender, msg.value, true); \n', '        } else {\n', '            throw;\n', '        }\n', '\n', '        /* add to amountRaised */\n', '        amountRaised = SafeMath.safeAdd(amountRaised, msg.value);\n', '        /* track ETH balanceOf address in case emergency refund is required */\n', '        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], msg.value);\n', '    }\n', '\n', '    /*\n', '     *  @notice public function\n', '     *  emergency manual refunds\n', '     */     \n', '    function publicWithdraw() public\n', '        onlyAllowPublicWithdraw\n', '    {\n', '        /* manual refunds */\n', '        calcRefund(msg.sender);\n', '    }\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    /*\n', '     *  @notice internal function\n', '     *  @param _addressToRefund the address being refunded\n', '     *  accessed via public functions publicWithdraw\n', '     *  calculates refund amount available for an address\n', '     */\n', '    function calcRefund(address _addressToRefund) internal\n', '    {\n', '        /* assigns var amount to balance of _addressToRefund */\n', '        uint amount = balanceOf[_addressToRefund];\n', '        /* sets balance to 0 */\n', '        balanceOf[_addressToRefund] = 0;\n', '        /* is there any balance? */\n', '        if (amount > 0) {\n', '            /* call to untrusted address */\n', '            _addressToRefund.transfer(amount);\n', '            /* log event */\n', '            LogFundTransfer(_addressToRefund, amount, false);\n', '        }\n', '    }\n', '\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    /*\n', '     *  @notice public function\n', '     *  onlyOwner\n', '     *  moves ether to _to address\n', '     */\n', '    function withdrawAmountTo (uint256 _amount, address _to) public\n', '        onlyOwner\n', '    {\n', '        _to.transfer(_amount);\n', '        LogFundTransfer(_to, _amount, false);\n', '    }\n', '\n', '    /**\n', '     *  @notice owner restricted function\n', '     *  @param status boolean\n', '     *  sets contract crowdsaleClosed\n', '     */\n', '    function ownerSetCrowdsaleClosed (bool status) public onlyOwner\n', '    {\n', '        crowdsaleClosed = status;\n', '    }\n', '\n', '    /**\n', '     *  @notice owner restricted function\n', '     *  @param status boolean\n', '     *  sets contract allowPublicWithdraw\n', '     */\n', '    function ownerSetAllowPublicWithdraw (bool status) public onlyOwner\n', '    {\n', '        allowPublicWithdraw = status;\n', '    }\n', '}']
