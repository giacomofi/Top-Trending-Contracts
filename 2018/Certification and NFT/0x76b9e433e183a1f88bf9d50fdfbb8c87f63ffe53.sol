['pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        owner = _owner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    \n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function Crowdsale() payable owned() {\n', '        totalSupply = 10000000 * 1 ether;\n', '        balanceOf[this] = 5500000 * 1 ether;\n', '        balanceOf[owner] = totalSupply - balanceOf[this];\n', '        Transfer(this, owner, balanceOf[owner]);\n', '    }\n', '\n', '    function () payable {\n', '        require(balanceOf[this] > 0);\n', '        uint256 tokensPerOneEther = 1000;\n', '        //uint256 tokens = tokensPerOneEther * msg.value / 1000000000000000000;\n', '        uint256 tokens = tokensPerOneEther * msg.value ;\n', '        if (tokens > balanceOf[this]) {\n', '            tokens = balanceOf[this];\n', '            uint valueWei = tokens * 1000000000000000000 / tokensPerOneEther;\n', '            msg.sender.transfer(msg.value - valueWei);\n', '        }\n', '        require(tokens > 0);\n', '        balanceOf[msg.sender] += tokens;\n', '        balanceOf[this] -= tokens;\n', '        Transfer(this, msg.sender, tokens);\n', '    }\n', '}\n', '\n', 'contract EnterRentToken is Crowdsale {\n', '    \n', '    string  public standard    = &#39;Token 1.3&#39;;\n', '    string  public name        = &#39;Enter Rent Token&#39;;\n', '    string  public symbol      = "ERT";\n', '    uint8   public decimals    = 18;\n', '\n', '    function EnterRentToken() payable Crowdsale() {}\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EnterRentCrowdsale is EnterRentToken {\n', '\n', '    function EnterRentCrowdsale() payable EnterRentToken() {}\n', '    \n', '   function withdraw() public onlyOwner {\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '    \n', '\n', '    function killMe() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
['pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        owner = _owner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    \n', '    uint256 public totalSupply;\n', '    mapping (address => uint256) public balanceOf;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function Crowdsale() payable owned() {\n', '        totalSupply = 10000000 * 1 ether;\n', '        balanceOf[this] = 5500000 * 1 ether;\n', '        balanceOf[owner] = totalSupply - balanceOf[this];\n', '        Transfer(this, owner, balanceOf[owner]);\n', '    }\n', '\n', '    function () payable {\n', '        require(balanceOf[this] > 0);\n', '        uint256 tokensPerOneEther = 1000;\n', '        //uint256 tokens = tokensPerOneEther * msg.value / 1000000000000000000;\n', '        uint256 tokens = tokensPerOneEther * msg.value ;\n', '        if (tokens > balanceOf[this]) {\n', '            tokens = balanceOf[this];\n', '            uint valueWei = tokens * 1000000000000000000 / tokensPerOneEther;\n', '            msg.sender.transfer(msg.value - valueWei);\n', '        }\n', '        require(tokens > 0);\n', '        balanceOf[msg.sender] += tokens;\n', '        balanceOf[this] -= tokens;\n', '        Transfer(this, msg.sender, tokens);\n', '    }\n', '}\n', '\n', 'contract EnterRentToken is Crowdsale {\n', '    \n', "    string  public standard    = 'Token 1.3';\n", "    string  public name        = 'Enter Rent Token';\n", '    string  public symbol      = "ERT";\n', '    uint8   public decimals    = 18;\n', '\n', '    function EnterRentToken() payable Crowdsale() {}\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract EnterRentCrowdsale is EnterRentToken {\n', '\n', '    function EnterRentCrowdsale() payable EnterRentToken() {}\n', '    \n', '   function withdraw() public onlyOwner {\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '    \n', '\n', '    function killMe() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
