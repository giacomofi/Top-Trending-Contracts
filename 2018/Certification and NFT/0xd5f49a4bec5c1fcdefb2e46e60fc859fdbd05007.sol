['/*\n', '\n', '  Copyright 2018 HydroProtocol.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract ERC20 {\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '}\n', '\n', 'contract Exchange {\n', '    function fillOrder(address[5], uint[6], uint, bool, uint8, bytes32, bytes32) public returns (uint);\n', '}\n', '\n', 'contract WETH {\n', '    function deposit() public payable;\n', '    function withdraw(uint) public;\n', '}\n', '\n', 'contract HydroSwap {\n', '    address exchangeAddress;\n', '    address tokenProxyAddress;\n', '    address wethAddress;\n', '\n', '    uint256 constant MAX_UINT = 2 ** 256 - 1;\n', '\n', '    event LogSwapSuccess(bytes32 indexed id);\n', '\n', '    constructor(address _exchangeAddress, address _tokenProxyAddress, address _wethAddress) public {\n', '        exchangeAddress = _exchangeAddress;\n', '        tokenProxyAddress = _tokenProxyAddress;\n', '        wethAddress = _wethAddress;\n', '    }\n', '\n', '    function swap(\n', '        bytes32 id,\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        external\n', '        payable\n', '        returns (uint256 takerTokenFilledAmount)\n', '    {\n', '        address makerTokenAddress = orderAddresses[2];\n', '        address takerTokenAddress = orderAddresses[3];\n', '        uint makerTokenAmount = orderValues[0];\n', '        uint takerTokenAmount = orderValues[1];\n', '\n', '        if (takerTokenAddress == wethAddress) {\n', '            require(takerTokenAmount == msg.value, "WRONG_ETH_AMOUNT");\n', '            WETH(wethAddress).deposit.value(takerTokenAmount)();\n', '        } else {\n', '            require(ERC20(takerTokenAddress).transferFrom(msg.sender, this, takerTokenAmount), "TOKEN_TRANSFER_FROM_ERROR");\n', '        }\n', '\n', '        require(ERC20(takerTokenAddress).approve(tokenProxyAddress, takerTokenAmount), "TOKEN_APPROVE_ERROR");\n', '\n', '        require(\n', '            Exchange(exchangeAddress).fillOrder(orderAddresses, orderValues, takerTokenAmount, true, v, r, s) == takerTokenAmount,\n', '            "FILL_ORDER_ERROR"\n', '        );\n', '\n', '        if (makerTokenAddress == wethAddress) {\n', '            WETH(wethAddress).withdraw(makerTokenAmount);\n', '            msg.sender.transfer(makerTokenAmount);\n', '        } else {\n', '            require(ERC20(makerTokenAddress).transfer(msg.sender, makerTokenAmount), "TOKEN_TRANSFER_ERROR");\n', '        }\n', '\n', '        emit LogSwapSuccess(id);\n', '\n', '        return takerTokenAmount;\n', '    }\n', '\n', '    // Need payable fallback function to accept the WETH withdraw funds.\n', '    function() public payable {} \n', '}']
['/*\n', '\n', '  Copyright 2018 HydroProtocol.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract ERC20 {\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '}\n', '\n', 'contract Exchange {\n', '    function fillOrder(address[5], uint[6], uint, bool, uint8, bytes32, bytes32) public returns (uint);\n', '}\n', '\n', 'contract WETH {\n', '    function deposit() public payable;\n', '    function withdraw(uint) public;\n', '}\n', '\n', 'contract HydroSwap {\n', '    address exchangeAddress;\n', '    address tokenProxyAddress;\n', '    address wethAddress;\n', '\n', '    uint256 constant MAX_UINT = 2 ** 256 - 1;\n', '\n', '    event LogSwapSuccess(bytes32 indexed id);\n', '\n', '    constructor(address _exchangeAddress, address _tokenProxyAddress, address _wethAddress) public {\n', '        exchangeAddress = _exchangeAddress;\n', '        tokenProxyAddress = _tokenProxyAddress;\n', '        wethAddress = _wethAddress;\n', '    }\n', '\n', '    function swap(\n', '        bytes32 id,\n', '        address[5] orderAddresses,\n', '        uint[6] orderValues,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        external\n', '        payable\n', '        returns (uint256 takerTokenFilledAmount)\n', '    {\n', '        address makerTokenAddress = orderAddresses[2];\n', '        address takerTokenAddress = orderAddresses[3];\n', '        uint makerTokenAmount = orderValues[0];\n', '        uint takerTokenAmount = orderValues[1];\n', '\n', '        if (takerTokenAddress == wethAddress) {\n', '            require(takerTokenAmount == msg.value, "WRONG_ETH_AMOUNT");\n', '            WETH(wethAddress).deposit.value(takerTokenAmount)();\n', '        } else {\n', '            require(ERC20(takerTokenAddress).transferFrom(msg.sender, this, takerTokenAmount), "TOKEN_TRANSFER_FROM_ERROR");\n', '        }\n', '\n', '        require(ERC20(takerTokenAddress).approve(tokenProxyAddress, takerTokenAmount), "TOKEN_APPROVE_ERROR");\n', '\n', '        require(\n', '            Exchange(exchangeAddress).fillOrder(orderAddresses, orderValues, takerTokenAmount, true, v, r, s) == takerTokenAmount,\n', '            "FILL_ORDER_ERROR"\n', '        );\n', '\n', '        if (makerTokenAddress == wethAddress) {\n', '            WETH(wethAddress).withdraw(makerTokenAmount);\n', '            msg.sender.transfer(makerTokenAmount);\n', '        } else {\n', '            require(ERC20(makerTokenAddress).transfer(msg.sender, makerTokenAmount), "TOKEN_TRANSFER_ERROR");\n', '        }\n', '\n', '        emit LogSwapSuccess(id);\n', '\n', '        return takerTokenAmount;\n', '    }\n', '\n', '    // Need payable fallback function to accept the WETH withdraw funds.\n', '    function() public payable {} \n', '}']
