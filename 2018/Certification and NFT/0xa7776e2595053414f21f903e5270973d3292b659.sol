['pragma solidity ^ 0.4.17;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) pure internal returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) \n', '            owner = newOwner;\n', '    }\n', '\n', '    function kill() public {\n', '        if (msg.sender == owner) \n', '            selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '    bool public stopped;\n', '\n', '    modifier stopInEmergency {\n', '        if (stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyInEmergency {\n', '        if (!stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Called by the owner in emergency, triggers stopped state\n', '    function emergencyStop() external onlyOwner() {\n', '        stopped = true;\n', '    }\n', '\n', '    // Called by the owner to end of emergency, returns to normal state\n', '    function release() external onlyOwner() onlyInEmergency {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', 'contract WhiteList is Ownable {\n', '\n', '    function isWhiteListedAndAffiliate(address _user) external view returns (bool, address);\n', '}\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends tokens to contributors\n', 'contract Crowdsale is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensToSend; // amount of tokens  sent  \n', '        bool claimed;\n', '        bool refunded; // true if user has been refunded       \n', '    }\n', '\n', '    Token public token; // Token contract reference   \n', '    address public multisig; // Multisig contract that will receive the ETH    \n', '    address public team; // Address at which the team tokens will be sent   \n', '    uint public teamTokens; // tokens for the team.     \n', '    uint public ethReceivedPresale; // Number of ETH received in presale\n', '    uint public ethReceivedMain; // Number of ETH received in public sale\n', '    uint public totalTokensSent; // Number of tokens sent to ETH contributors\n', '    uint public totalAffiliateTokensSent;\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of tokens to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minInvestETH; // Minimum amount to invest   \n', '    bool public crowdsaleClosed; // Is crowdsale still in progress\n', '    Step public currentStep;  // to allow for controled steps of the campaign \n', '    uint public refundCount;  // number of refunds\n', '    uint public totalRefunded; // total amount of refunds    \n', '    uint public tokenPriceWei;  // price of token in wei\n', '    WhiteList public whiteList; // white list address\n', '    uint public numOfBlocksInMinute;// number of blocks in one minute * 100. eg. \n', '    uint public claimCount; // number of claims\n', '    uint public totalClaimed; // Total number of tokens claimed\n', '    \n', '\n', '    mapping(address => Backer) public backers; //backer list\n', '    mapping(address => uint) public affiliates; // affiliates list\n', '    address[] public backersIndex; // to be able to itarate through backers for verification.  \n', '    mapping(address => uint) public claimed;  // Tokens claimed by contibutors\n', '\n', '    \n', '    // @notice to verify if action is not performed out of the campaing range\n', '    modifier respectTimeFrame() {\n', '        if ((block.number < startBlock) || (block.number > endBlock)) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {\n', '        Unknown,\n', '        FundingPreSale,     // presale mode\n', '        FundingPublicSale,  // public mode\n', '        Refunding,  // in case campaign failed during this step contributors will be able to receive refunds\n', '        Claiming    // set this step to enable claiming of tokens. \n', '    }\n', '\n', '    // Events\n', '    event ReceivedETH(address indexed backer, address indexed affiliate, uint amount, uint tokenAmount, uint affiliateTokenAmount);\n', '    event RefundETH(address backer, uint amount);\n', '    event TokensClaimed(address backer, uint count);\n', '\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initilizes all constnat and initial values.\n', '    function Crowdsale(WhiteList _whiteListAddress) public {\n', '        multisig = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88; \n', '        team = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88;                                         \n', '        startBlock = 0; // Should wait for the call of the function start\n', '        endBlock = 0; // Should wait for the call of the function start                  \n', '        tokenPriceWei = 108110000000000;\n', '        maxCap = 210000000e18;         \n', '        minCap = 21800000e18;        \n', '        totalTokensSent = 0;  //TODO: add tokens sold in private sale\n', '        setStep(Step.FundingPreSale);\n', '        numOfBlocksInMinute = 416;    \n', '        whiteList = WhiteList(_whiteListAddress);    \n', '        teamTokens = 45000000e18;\n', '    }\n', '\n', '    // @notice to populate website with status of the sale \n', '    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) {            \n', '    \n', '        return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent, tokenPriceWei, currentStep, stopped, crowdsaleClosed);\n', '    }\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\n', '        token = _tokenAddress;\n', '        return true;\n', '    }\n', '\n', '    // @notice set the step of the campaign \n', '    // @param _step {Step}\n', '    function setStep(Step _step) public onlyOwner() {\n', '        currentStep = _step;\n', '        \n', '        if (currentStep == Step.FundingPreSale) {  // for presale \n', '          \n', '            minInvestETH = 1 ether/5;                             \n', '        }else if (currentStep == Step.FundingPublicSale) { // for public sale           \n', '            minInvestETH = 1 ether/10;               \n', '        }      \n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\n', '    function () external payable {           \n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale    \n', '    function start(uint _block) external onlyOwner() {   \n', '\n', '        require(_block < 335462);  // 4.16*60*24*56 days = 335462     \n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice Due to changing average of block time\n', '    // this function will allow on adjusting duration of campaign closer to the end \n', '    function adjustDuration(uint _block) external onlyOwner() {\n', '\n', '        require(_block < 389376);  // 4.16*60*24*65 days = 389376     \n', '        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address contributor\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\n', '\n', '        uint affiliateTokens;\n', '\n', '        var(isWhiteListed, affiliate) = whiteList.isWhiteListedAndAffiliate(_backer);\n', '\n', '        require(isWhiteListed);      // ensure that user is whitelisted\n', '    \n', '        require(currentStep == Step.FundingPreSale || currentStep == Step.FundingPublicSale); // ensure that this is correct step\n', '        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\n', '          \n', '        uint tokensToSend = determinePurchase();\n', '\n', '        if (affiliate != address(0)) {\n', '            affiliateTokens = (tokensToSend * 5) / 100; // give 5% of tokens to affiliate\n', '            affiliates[affiliate] += affiliateTokens;\n', '            Backer storage referrer = backers[affiliate];\n', '            referrer.tokensToSend = referrer.tokensToSend.add(affiliateTokens);\n', '        }\n', '        \n', '        require(totalTokensSent.add(tokensToSend.add(affiliateTokens)) < maxCap); // Ensure that max cap hasn&#39;t been reached  \n', '            \n', '        Backer storage backer = backers[_backer];\n', '    \n', '        if (backer.tokensToSend == 0)      \n', '            backersIndex.push(_backer);\n', '           \n', '        backer.tokensToSend = backer.tokensToSend.add(tokensToSend); // save contributors tokens to be sent\n', '        backer.weiReceived = backer.weiReceived.add(msg.value);  // save how much was the contribution\n', '        totalTokensSent += tokensToSend + affiliateTokens;     // update the total amount of tokens sent\n', '        totalAffiliateTokensSent += affiliateTokens;\n', '    \n', '        if (Step.FundingPublicSale == currentStep)  // Update the total Ether recived\n', '            ethReceivedMain = ethReceivedMain.add(msg.value);\n', '        else\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value);     \n', '       \n', '        multisig.transfer(this.balance);   // transfer funds to multisignature wallet             \n', '    \n', '        ReceivedETH(_backer, affiliate, msg.value, tokensToSend, affiliateTokens); // Register event\n', '        return true;\n', '    }\n', '\n', '    // @notice determine if purchase is valid and return proper number of tokens\n', '    // @return tokensToSend {uint} proper number of tokens based on the timline     \n', '    function determinePurchase() internal view  returns (uint) {\n', '       \n', '        require(msg.value >= minInvestETH);                        // ensure that min contributions amount is met  \n', '        uint tokenAmount = msg.value.mul(1e18) / tokenPriceWei;    // calculate amount of tokens\n', '\n', '        uint tokensToSend;  \n', '\n', '        if (currentStep == Step.FundingPreSale)\n', '            tokensToSend = calculateNoOfTokensToSend(tokenAmount); \n', '        else\n', '            tokensToSend = tokenAmount;\n', '                                                                                                       \n', '        return tokensToSend;\n', '    }\n', '\n', '    // @notice This function will return number of tokens based on time intervals in the campaign\n', '    // @param _tokenAmount {uint} amount of tokens to allocate for the contribution\n', '    function calculateNoOfTokensToSend(uint _tokenAmount) internal view  returns (uint) {\n', '              \n', '        if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 14) / 100)        // less equal then/equal 14 days\n', '            return  _tokenAmount + (_tokenAmount * 40) / 100;  // 40% bonus\n', '        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 28) / 100)   // less equal  28 days\n', '            return  _tokenAmount + (_tokenAmount * 30) / 100; // 30% bonus\n', '        else\n', '            return  _tokenAmount + (_tokenAmount * 20) / 100;   // remainder of the campaign 20% bonus\n', '          \n', '    }\n', '\n', '    // @notice erase contribution from the database and do manual refund for disapproved users\n', '    // @param _backer {address} address of user to be erased\n', '    function eraseContribution(address _backer) external onlyOwner() {\n', '\n', '        Backer storage backer = backers[_backer];        \n', '        backer.refunded = true;\n', '        totalTokensSent = totalTokensSent.sub(backer.tokensToSend);        \n', '    }\n', '\n', '    // @notice allow on manual addition of contributors\n', '    // @param _backer {address} of contributor to be added\n', '    // @parm _amountTokens {uint} tokens to be added\n', '    function addManualContributor(address _backer, uint _amountTokens) external onlyOwner() {\n', '\n', '        Backer storage backer = backers[_backer];        \n', '        backer.tokensToSend = backer.tokensToSend.add(_amountTokens);\n', '        if (backer.tokensToSend == 0)      \n', '            backersIndex.push(_backer);\n', '        totalTokensSent = totalTokensSent.add(_amountTokens);\n', '    }\n', '\n', '\n', '    // @notice contributors can claim tokens after public ICO is finished\n', '    // tokens are only claimable when token address is available and lock-up period reached. \n', '    function claimTokens() external {\n', '        claimTokensForUser(msg.sender);\n', '    }\n', '\n', '    // @notice this function can be called by admin to claim user&#39;s token in case of difficulties\n', '    // @param _backer {address} user address to claim tokens for\n', '    function adminClaimTokenForUser(address _backer) external onlyOwner() {\n', '        claimTokensForUser(_backer);\n', '    }\n', '\n', '    // @notice in case refunds are needed, money can be returned to the contract\n', '    // and contract switched to mode refunding\n', '    function prepareRefund() public payable onlyOwner() {\n', '        \n', '        require(msg.value == ethReceivedMain + ethReceivedPresale); // make sure that proper amount of ether is sent\n', '        currentStep == Step.Refunding;\n', '    }\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors   \n', '    function numberOfBackers() public view returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', ' \n', '    // @notice called to send tokens to contributors after ICO and lockup period. \n', '    // @param _backer {address} address of beneficiary\n', '    // @return true if successful\n', '    function claimTokensForUser(address _backer) internal returns(bool) {       \n', '\n', '        require(currentStep == Step.Claiming);\n', '                  \n', '        Backer storage backer = backers[_backer];\n', '\n', '        require(!backer.refunded);      // if refunded, don&#39;t allow for another refund           \n', '        require(!backer.claimed);       // if tokens claimed, don&#39;t allow refunding            \n', '        require(backer.tokensToSend != 0);   // only continue if there are any tokens to send           \n', '\n', '        claimCount++;\n', '        claimed[_backer] = backer.tokensToSend;  // save claimed tokens\n', '        backer.claimed = true;\n', '        totalClaimed += backer.tokensToSend;\n', '        \n', '        if (!token.transfer(_backer, backer.tokensToSend)) \n', '            revert(); // send claimed tokens to contributor account\n', '\n', '        TokensClaimed(_backer, backer.tokensToSend);  \n', '    }\n', '\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    // it will fail if minimum cap is not reached\n', '    function finalize() external onlyOwner() {\n', '\n', '        require(!crowdsaleClosed);        \n', '        // purchasing precise number of tokens might be impractical, thus subtract 1000 tokens so finalizition is possible\n', '        // near the end \n', '        require(block.number >= endBlock || totalTokensSent >= maxCap.sub(1000));                 \n', '        require(totalTokensSent >= minCap);  // ensure that minimum was reached\n', '\n', '        crowdsaleClosed = true;  \n', '        \n', '        if (!token.transfer(team, teamTokens)) // transfer all remaing tokens to team address\n', '            revert();\n', '\n', '        if (!token.burn(this, maxCap - totalTokensSent)) // burn all unsold tokens\n', '            revert();  \n', '        token.unlock();                      \n', '    }\n', '\n', '    // @notice Failsafe drain\n', '    function drain() external onlyOwner() {\n', '        multisig.transfer(this.balance);               \n', '    }\n', '\n', '    // @notice Failsafe token transfer\n', '    function tokenDrian() external onlyOwner() {\n', '        if (block.number > endBlock) {\n', '            if (!token.transfer(team, token.balanceOf(this))) \n', '                revert();\n', '        }\n', '    }\n', '    \n', '    // @notice it will allow contributors to get refund in case campaign failed\n', '    function refund() external stopInEmergency returns (bool) {\n', '\n', '        require(currentStep == Step.Refunding);         \n', '       \n', '        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.                                  \n', '                                    // contract needs to be funded through fundContract() \n', '\n', '        Backer storage backer = backers[msg.sender];\n', '\n', '        require(backer.weiReceived > 0);  // esnure that user has sent contribution\n', '        require(!backer.refunded);         // ensure that user hasn&#39;t been refunded yet\n', '        require(!backer.claimed);       // if tokens claimed, don&#39;t allow refunding   \n', '       \n', '        backer.refunded = true;  // save refund status to true\n', '    \n', '        refundCount++;\n', '        totalRefunded = totalRefunded.add(backer.weiReceived);\n', '        msg.sender.transfer(backer.weiReceived);  // send back the contribution \n', '        RefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '   \n', '    function transfer(address to, uint value) public returns(bool ok);  \n', '}\n', '\n', '\n', '// The token\n', 'contract Token is ERC20, Ownable {\n', '\n', '    function returnTokens(address _member, uint256 _value) public returns(bool);\n', '    function unlock() public;\n', '    function balanceOf(address _owner) public view returns(uint balance);\n', '    function burn( address _member, uint256 _value) public returns(bool);\n', '}']
['pragma solidity ^ 0.4.17;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) pure internal returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) \n', '            owner = newOwner;\n', '    }\n', '\n', '    function kill() public {\n', '        if (msg.sender == owner) \n', '            selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '    bool public stopped;\n', '\n', '    modifier stopInEmergency {\n', '        if (stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyInEmergency {\n', '        if (!stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Called by the owner in emergency, triggers stopped state\n', '    function emergencyStop() external onlyOwner() {\n', '        stopped = true;\n', '    }\n', '\n', '    // Called by the owner to end of emergency, returns to normal state\n', '    function release() external onlyOwner() onlyInEmergency {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', 'contract WhiteList is Ownable {\n', '\n', '    function isWhiteListedAndAffiliate(address _user) external view returns (bool, address);\n', '}\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends tokens to contributors\n', 'contract Crowdsale is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensToSend; // amount of tokens  sent  \n', '        bool claimed;\n', '        bool refunded; // true if user has been refunded       \n', '    }\n', '\n', '    Token public token; // Token contract reference   \n', '    address public multisig; // Multisig contract that will receive the ETH    \n', '    address public team; // Address at which the team tokens will be sent   \n', '    uint public teamTokens; // tokens for the team.     \n', '    uint public ethReceivedPresale; // Number of ETH received in presale\n', '    uint public ethReceivedMain; // Number of ETH received in public sale\n', '    uint public totalTokensSent; // Number of tokens sent to ETH contributors\n', '    uint public totalAffiliateTokensSent;\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of tokens to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minInvestETH; // Minimum amount to invest   \n', '    bool public crowdsaleClosed; // Is crowdsale still in progress\n', '    Step public currentStep;  // to allow for controled steps of the campaign \n', '    uint public refundCount;  // number of refunds\n', '    uint public totalRefunded; // total amount of refunds    \n', '    uint public tokenPriceWei;  // price of token in wei\n', '    WhiteList public whiteList; // white list address\n', '    uint public numOfBlocksInMinute;// number of blocks in one minute * 100. eg. \n', '    uint public claimCount; // number of claims\n', '    uint public totalClaimed; // Total number of tokens claimed\n', '    \n', '\n', '    mapping(address => Backer) public backers; //backer list\n', '    mapping(address => uint) public affiliates; // affiliates list\n', '    address[] public backersIndex; // to be able to itarate through backers for verification.  \n', '    mapping(address => uint) public claimed;  // Tokens claimed by contibutors\n', '\n', '    \n', '    // @notice to verify if action is not performed out of the campaing range\n', '    modifier respectTimeFrame() {\n', '        if ((block.number < startBlock) || (block.number > endBlock)) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {\n', '        Unknown,\n', '        FundingPreSale,     // presale mode\n', '        FundingPublicSale,  // public mode\n', '        Refunding,  // in case campaign failed during this step contributors will be able to receive refunds\n', '        Claiming    // set this step to enable claiming of tokens. \n', '    }\n', '\n', '    // Events\n', '    event ReceivedETH(address indexed backer, address indexed affiliate, uint amount, uint tokenAmount, uint affiliateTokenAmount);\n', '    event RefundETH(address backer, uint amount);\n', '    event TokensClaimed(address backer, uint count);\n', '\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initilizes all constnat and initial values.\n', '    function Crowdsale(WhiteList _whiteListAddress) public {\n', '        multisig = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88; \n', '        team = 0x49447Ea549CCfFDEF2E9a9290709d6114346df88;                                         \n', '        startBlock = 0; // Should wait for the call of the function start\n', '        endBlock = 0; // Should wait for the call of the function start                  \n', '        tokenPriceWei = 108110000000000;\n', '        maxCap = 210000000e18;         \n', '        minCap = 21800000e18;        \n', '        totalTokensSent = 0;  //TODO: add tokens sold in private sale\n', '        setStep(Step.FundingPreSale);\n', '        numOfBlocksInMinute = 416;    \n', '        whiteList = WhiteList(_whiteListAddress);    \n', '        teamTokens = 45000000e18;\n', '    }\n', '\n', '    // @notice to populate website with status of the sale \n', '    function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) {            \n', '    \n', '        return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent, tokenPriceWei, currentStep, stopped, crowdsaleClosed);\n', '    }\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contract\n', '    // @return res {bool}\n', '    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\n', '        token = _tokenAddress;\n', '        return true;\n', '    }\n', '\n', '    // @notice set the step of the campaign \n', '    // @param _step {Step}\n', '    function setStep(Step _step) public onlyOwner() {\n', '        currentStep = _step;\n', '        \n', '        if (currentStep == Step.FundingPreSale) {  // for presale \n', '          \n', '            minInvestETH = 1 ether/5;                             \n', '        }else if (currentStep == Step.FundingPublicSale) { // for public sale           \n', '            minInvestETH = 1 ether/10;               \n', '        }      \n', '    }\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\n', '    function () external payable {           \n', '        contribute(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale    \n', '    function start(uint _block) external onlyOwner() {   \n', '\n', '        require(_block < 335462);  // 4.16*60*24*56 days = 335462     \n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice Due to changing average of block time\n', '    // this function will allow on adjusting duration of campaign closer to the end \n', '    function adjustDuration(uint _block) external onlyOwner() {\n', '\n', '        require(_block < 389376);  // 4.16*60*24*65 days = 389376     \n', '        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address contributor\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\n', '\n', '        uint affiliateTokens;\n', '\n', '        var(isWhiteListed, affiliate) = whiteList.isWhiteListedAndAffiliate(_backer);\n', '\n', '        require(isWhiteListed);      // ensure that user is whitelisted\n', '    \n', '        require(currentStep == Step.FundingPreSale || currentStep == Step.FundingPublicSale); // ensure that this is correct step\n', '        require(msg.value >= minInvestETH);   // ensure that min contributions amount is met\n', '          \n', '        uint tokensToSend = determinePurchase();\n', '\n', '        if (affiliate != address(0)) {\n', '            affiliateTokens = (tokensToSend * 5) / 100; // give 5% of tokens to affiliate\n', '            affiliates[affiliate] += affiliateTokens;\n', '            Backer storage referrer = backers[affiliate];\n', '            referrer.tokensToSend = referrer.tokensToSend.add(affiliateTokens);\n', '        }\n', '        \n', "        require(totalTokensSent.add(tokensToSend.add(affiliateTokens)) < maxCap); // Ensure that max cap hasn't been reached  \n", '            \n', '        Backer storage backer = backers[_backer];\n', '    \n', '        if (backer.tokensToSend == 0)      \n', '            backersIndex.push(_backer);\n', '           \n', '        backer.tokensToSend = backer.tokensToSend.add(tokensToSend); // save contributors tokens to be sent\n', '        backer.weiReceived = backer.weiReceived.add(msg.value);  // save how much was the contribution\n', '        totalTokensSent += tokensToSend + affiliateTokens;     // update the total amount of tokens sent\n', '        totalAffiliateTokensSent += affiliateTokens;\n', '    \n', '        if (Step.FundingPublicSale == currentStep)  // Update the total Ether recived\n', '            ethReceivedMain = ethReceivedMain.add(msg.value);\n', '        else\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value);     \n', '       \n', '        multisig.transfer(this.balance);   // transfer funds to multisignature wallet             \n', '    \n', '        ReceivedETH(_backer, affiliate, msg.value, tokensToSend, affiliateTokens); // Register event\n', '        return true;\n', '    }\n', '\n', '    // @notice determine if purchase is valid and return proper number of tokens\n', '    // @return tokensToSend {uint} proper number of tokens based on the timline     \n', '    function determinePurchase() internal view  returns (uint) {\n', '       \n', '        require(msg.value >= minInvestETH);                        // ensure that min contributions amount is met  \n', '        uint tokenAmount = msg.value.mul(1e18) / tokenPriceWei;    // calculate amount of tokens\n', '\n', '        uint tokensToSend;  \n', '\n', '        if (currentStep == Step.FundingPreSale)\n', '            tokensToSend = calculateNoOfTokensToSend(tokenAmount); \n', '        else\n', '            tokensToSend = tokenAmount;\n', '                                                                                                       \n', '        return tokensToSend;\n', '    }\n', '\n', '    // @notice This function will return number of tokens based on time intervals in the campaign\n', '    // @param _tokenAmount {uint} amount of tokens to allocate for the contribution\n', '    function calculateNoOfTokensToSend(uint _tokenAmount) internal view  returns (uint) {\n', '              \n', '        if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 14) / 100)        // less equal then/equal 14 days\n', '            return  _tokenAmount + (_tokenAmount * 40) / 100;  // 40% bonus\n', '        else if (block.number <= startBlock + (numOfBlocksInMinute * 60 * 24 * 28) / 100)   // less equal  28 days\n', '            return  _tokenAmount + (_tokenAmount * 30) / 100; // 30% bonus\n', '        else\n', '            return  _tokenAmount + (_tokenAmount * 20) / 100;   // remainder of the campaign 20% bonus\n', '          \n', '    }\n', '\n', '    // @notice erase contribution from the database and do manual refund for disapproved users\n', '    // @param _backer {address} address of user to be erased\n', '    function eraseContribution(address _backer) external onlyOwner() {\n', '\n', '        Backer storage backer = backers[_backer];        \n', '        backer.refunded = true;\n', '        totalTokensSent = totalTokensSent.sub(backer.tokensToSend);        \n', '    }\n', '\n', '    // @notice allow on manual addition of contributors\n', '    // @param _backer {address} of contributor to be added\n', '    // @parm _amountTokens {uint} tokens to be added\n', '    function addManualContributor(address _backer, uint _amountTokens) external onlyOwner() {\n', '\n', '        Backer storage backer = backers[_backer];        \n', '        backer.tokensToSend = backer.tokensToSend.add(_amountTokens);\n', '        if (backer.tokensToSend == 0)      \n', '            backersIndex.push(_backer);\n', '        totalTokensSent = totalTokensSent.add(_amountTokens);\n', '    }\n', '\n', '\n', '    // @notice contributors can claim tokens after public ICO is finished\n', '    // tokens are only claimable when token address is available and lock-up period reached. \n', '    function claimTokens() external {\n', '        claimTokensForUser(msg.sender);\n', '    }\n', '\n', "    // @notice this function can be called by admin to claim user's token in case of difficulties\n", '    // @param _backer {address} user address to claim tokens for\n', '    function adminClaimTokenForUser(address _backer) external onlyOwner() {\n', '        claimTokensForUser(_backer);\n', '    }\n', '\n', '    // @notice in case refunds are needed, money can be returned to the contract\n', '    // and contract switched to mode refunding\n', '    function prepareRefund() public payable onlyOwner() {\n', '        \n', '        require(msg.value == ethReceivedMain + ethReceivedPresale); // make sure that proper amount of ether is sent\n', '        currentStep == Step.Refunding;\n', '    }\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors   \n', '    function numberOfBackers() public view returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', ' \n', '    // @notice called to send tokens to contributors after ICO and lockup period. \n', '    // @param _backer {address} address of beneficiary\n', '    // @return true if successful\n', '    function claimTokensForUser(address _backer) internal returns(bool) {       \n', '\n', '        require(currentStep == Step.Claiming);\n', '                  \n', '        Backer storage backer = backers[_backer];\n', '\n', "        require(!backer.refunded);      // if refunded, don't allow for another refund           \n", "        require(!backer.claimed);       // if tokens claimed, don't allow refunding            \n", '        require(backer.tokensToSend != 0);   // only continue if there are any tokens to send           \n', '\n', '        claimCount++;\n', '        claimed[_backer] = backer.tokensToSend;  // save claimed tokens\n', '        backer.claimed = true;\n', '        totalClaimed += backer.tokensToSend;\n', '        \n', '        if (!token.transfer(_backer, backer.tokensToSend)) \n', '            revert(); // send claimed tokens to contributor account\n', '\n', '        TokensClaimed(_backer, backer.tokensToSend);  \n', '    }\n', '\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    // it will fail if minimum cap is not reached\n', '    function finalize() external onlyOwner() {\n', '\n', '        require(!crowdsaleClosed);        \n', '        // purchasing precise number of tokens might be impractical, thus subtract 1000 tokens so finalizition is possible\n', '        // near the end \n', '        require(block.number >= endBlock || totalTokensSent >= maxCap.sub(1000));                 \n', '        require(totalTokensSent >= minCap);  // ensure that minimum was reached\n', '\n', '        crowdsaleClosed = true;  \n', '        \n', '        if (!token.transfer(team, teamTokens)) // transfer all remaing tokens to team address\n', '            revert();\n', '\n', '        if (!token.burn(this, maxCap - totalTokensSent)) // burn all unsold tokens\n', '            revert();  \n', '        token.unlock();                      \n', '    }\n', '\n', '    // @notice Failsafe drain\n', '    function drain() external onlyOwner() {\n', '        multisig.transfer(this.balance);               \n', '    }\n', '\n', '    // @notice Failsafe token transfer\n', '    function tokenDrian() external onlyOwner() {\n', '        if (block.number > endBlock) {\n', '            if (!token.transfer(team, token.balanceOf(this))) \n', '                revert();\n', '        }\n', '    }\n', '    \n', '    // @notice it will allow contributors to get refund in case campaign failed\n', '    function refund() external stopInEmergency returns (bool) {\n', '\n', '        require(currentStep == Step.Refunding);         \n', '       \n', '        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.                                  \n', '                                    // contract needs to be funded through fundContract() \n', '\n', '        Backer storage backer = backers[msg.sender];\n', '\n', '        require(backer.weiReceived > 0);  // esnure that user has sent contribution\n', "        require(!backer.refunded);         // ensure that user hasn't been refunded yet\n", "        require(!backer.claimed);       // if tokens claimed, don't allow refunding   \n", '       \n', '        backer.refunded = true;  // save refund status to true\n', '    \n', '        refundCount++;\n', '        totalRefunded = totalRefunded.add(backer.weiReceived);\n', '        msg.sender.transfer(backer.weiReceived);  // send back the contribution \n', '        RefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '   \n', '    function transfer(address to, uint value) public returns(bool ok);  \n', '}\n', '\n', '\n', '// The token\n', 'contract Token is ERC20, Ownable {\n', '\n', '    function returnTokens(address _member, uint256 _value) public returns(bool);\n', '    function unlock() public;\n', '    function balanceOf(address _owner) public view returns(uint balance);\n', '    function burn( address _member, uint256 _value) public returns(bool);\n', '}']
