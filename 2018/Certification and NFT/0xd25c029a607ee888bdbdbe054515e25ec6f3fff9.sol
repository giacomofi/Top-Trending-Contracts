['pragma solidity ^0.4.24;\n', '// produced by the Solididy File Flattener (c) David Appleton 2018\n', '// contact : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ddb9bcabb89dbcb6b2b0bfbcf3beb2b0">[email&#160;protected]</a>\n', '// released under Apache 2.0 licence\n', 'contract ErrorReporter {\n', '\n', '    /**\n', '      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n', '      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n', '      **/\n', '    event Failure(uint error, uint info, uint detail);\n', '\n', '    enum Error {\n', '        NO_ERROR,\n', '        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n', '        UNAUTHORIZED,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW,\n', '        DIVISION_BY_ZERO,\n', '        BAD_INPUT,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_TRANSFER_FAILED,\n', '        MARKET_NOT_SUPPORTED,\n', '        SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_RATE_CALCULATION_FAILED,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_OUT_FAILED,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INSUFFICIENT_BALANCE,\n', '        INVALID_COLLATERAL_RATIO,\n', '        MISSING_ASSET_PRICE,\n', '        EQUITY_INSUFFICIENT_BALANCE,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        ASSET_NOT_PRICED,\n', '        INVALID_LIQUIDATION_DISCOUNT,\n', '        INVALID_COMBINED_RISK_PARAMETERS,\n', '        ZERO_ORACLE_ADDRESS,\n', '        CONTRACT_PAUSED\n', '    }\n', '\n', '    /*\n', '     * Note: FailureInfo (but not Error) is kept in alphabetical order\n', '     *       This is because FailureInfo grows significantly faster, and\n', '     *       the order of Error has some meaning, while the order of FailureInfo\n', '     *       is entirely arbitrary.\n', '     */\n', '    enum FailureInfo {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        BORROW_CONTRACT_PAUSED,\n', '        BORROW_MARKET_NOT_SUPPORTED,\n', '        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n', '        BORROW_TRANSFER_OUT_FAILED,\n', '        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n', '        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n', '        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n', '        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n', '        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n', '        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n', '        LIQUIDATE_CONTRACT_PAUSED,\n', '        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_CONTRACT_PAUSED,\n', '        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_ASSET_PRICE_CHECK_ORACLE,\n', '        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_ORACLE_OWNER_CHECK,\n', '        SET_ORIGINATION_FEE_OWNER_CHECK,\n', '        SET_PAUSED_OWNER_CHECK,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_VALIDATION,\n', '        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_CONTRACT_PAUSED,\n', '        SUPPLY_MARKET_NOT_SUPPORTED,\n', '        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        SUPPLY_TRANSFER_IN_FAILED,\n', '        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n', '        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SUPPORT_MARKET_PRICE_CHECK,\n', '        SUSPEND_MARKET_OWNER_CHECK,\n', '        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n', '        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n', '        WITHDRAW_CONTRACT_PAUSED,\n', '        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n', '    }\n', '\n', '\n', '    /**\n', '      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n', '      */\n', '    function fail(Error err, FailureInfo info) internal returns (uint) {\n', '        emit Failure(uint(err), uint(info), 0);\n', '\n', '        return uint(err);\n', '    }\n', '\n', '\n', '    /**\n', '      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n', '      */\n', '    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n', '        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n', '\n', '        return uint(Error.OPAQUE_ERROR);\n', '    }\n', '\n', '}\n', 'contract InterestRateModel {\n', '\n', '    /**\n', '      * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the supply interest rate per block scaled by 10e18\n', '      */\n', '    function getSupplyRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n', '\n', '    /**\n', '      * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n', '      */\n', '    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n', '}\n', 'contract CarefulMath is ErrorReporter {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, returns an error on overflow.\n', '    */\n', '    function mul(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (a == 0) {\n', '            return (Error.NO_ERROR, 0);\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b == 0) {\n', '            return (Error.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, a / b);\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b <= a) {\n', '            return (Error.NO_ERROR, a - b);\n', '        } else {\n', '            return (Error.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, returns an error on overflow.\n', '    */\n', '    function add(uint a, uint b) internal pure returns (Error, uint) {\n', '        uint c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (Error.NO_ERROR, c);\n', '        } else {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev add a and b and then subtract c\n', '    */\n', '    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n', '        (Error err0, uint sum) = add(a, b);\n', '\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return sub(sum, c);\n', '    }\n', '}\n', 'contract Exponential is ErrorReporter, CarefulMath {\n', '\n', '    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n', '    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n', '    // the optimizer MAY replace the expression 10**18 with its calculated value.\n', '    uint constant expScale = 10**18;\n', '\n', '    // See TODO on expScale\n', '    uint constant halfExpScale = expScale/2;\n', '\n', '    struct Exp {\n', '        uint mantissa;\n', '    }\n', '\n', '    uint constant mantissaOne = 10**18;\n', '    uint constant mantissaOneTenth = 10**17;\n', '\n', '    /**\n', '    * @dev Creates an exponential from numerator and denominator values.\n', '    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '    *            or if `denom` is zero.\n', '    */\n', '    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledNumerator) = mul(num, expScale);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err1, uint rational) = div(scaledNumerator, denom);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two exponentials, returning a new exponential.\n', '    */\n', '    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = add(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two exponentials, returning a new exponential.\n', '    */\n', '    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '    * @dev Multiply an Exp by a scalar, returning a new Exp.\n', '    */\n', '    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '    /**\n', '    * @dev Divide an Exp by a scalar, returning a new Exp.\n', '    */\n', '    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '    /**\n', '    * @dev Divide a scalar by an Exp, returning a new Exp.\n', '    */\n', '    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\n', '        /*\n', '            We are doing this as:\n', '            getExp(mul(expScale, scalar), divisor.mantissa)\n', '\n', '            How it works:\n', '            Exp = a / b;\n', '            Scalar = s;\n', '            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (Error err0, uint numerator) = mul(expScale, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two exponentials, returning a new exponential.\n', '    */\n', '    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '\n', '        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n', '        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == Error.NO_ERROR);\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '      * @dev Divides two exponentials, returning a new exponential.\n', '      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n', '      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n', '      */\n', '    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        return getExp(a.mantissa, b.mantissa);\n', '    }\n', '\n', '    /**\n', '      * @dev Truncates the given exp to a whole number value.\n', '      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n', '      */\n', '    function truncate(Exp memory exp) pure internal returns (uint) {\n', '        // Note: We are not using careful math here as we&#39;re performing a division that cannot fail\n', '        return exp.mantissa / 10**18;\n', '    }\n', '\n', '    /**\n', '      * @dev Checks if first Exp is less than second Exp.\n', '      */\n', '    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n', '    }\n', '\n', '    /**\n', '      * @dev Checks if left Exp <= right Exp.\n', '      */\n', '    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa <= right.mantissa;\n', '    }\n', '\n', '    /**\n', '      * @dev returns true if Exp is exactly zero\n', '      */\n', '    function isZeroExp(Exp memory value) pure internal returns (bool) {\n', '        return value.mantissa == 0;\n', '    }\n', '}\n', '\n', 'contract StandardInterestRateModel is Exponential {\n', '\n', '    uint constant oneMinusSpreadBasisPoints = 9000;\n', '    uint constant blocksPerYear = 2102400;\n', '    uint constant mantissaFivePercent = 5 * 10**16;\n', '\n', '    enum IRError {\n', '        NO_ERROR,\n', '        FAILED_TO_ADD_CASH_PLUS_BORROWS,\n', '        FAILED_TO_GET_EXP,\n', '        FAILED_TO_MUL_PRODUCT_TIMES_BORROW_RATE\n', '    }\n', '\n', '    /*\n', '     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp\n', '     */\n', '    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n', '        if (borrows == 0) {\n', '            // Utilization rate is zero when there&#39;s no borrows\n', '            return (IRError.NO_ERROR, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err0, uint cashPlusBorrows) = add(cash, borrows);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (IRError.NO_ERROR, utilizationRate);\n', '    }\n', '\n', '    /*\n', '     * @dev Calculates the utilization and borrow rates for use by get{Supply,Borrow}Rate functions\n', '     */\n', '    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory, Exp memory) {\n', '        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\n', '        }\n', '\n', '        // Borrow Rate is 5% + UtilizationRate * 45%\n', '        // 45% of utilizationRate, is `rate * 45 / 100`\n', '        (Error err1, Exp memory utilizationRateMuled) = mulScalar(utilizationRate, 45);\n', '        // `mulScalar` only overflows when the product is >= 2^256.\n', '        // utilizationRate is a real number on the interval [0,1], which means that\n', '        // utilizationRate.mantissa is in the interval [0e18,1e18], which means that 45 times\n', '        // that is in the interval [0e18,45e18]. That interval has no intersection with 2^256, and therefore\n', '        // this can never overflow. As such, we assert.\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        (Error err2, Exp memory utilizationRateScaled) = divScalar(utilizationRateMuled, 100);\n', '        // 100 is a constant, and therefore cannot be zero, which is the only error case of divScalar.\n', '        assert(err2 == Error.NO_ERROR);\n', '\n', '        // Add the 5% for (5% + 45% * Ua)\n', '        (Error err3, Exp memory annualBorrowRate) = addExp(utilizationRateScaled, Exp({mantissa: mantissaFivePercent}));\n', '        // `addExp` only fails when the addition of mantissas overflow.\n', '        // As per above, utilizationRateMuled is capped at 45e18,\n', '        // and utilizationRateScaled is capped at 4.5e17. mantissaFivePercent = 0.5e17, and thus the addition\n', '        // is capped at 5e17, which is less than 2^256.\n', '        assert(err3 == Error.NO_ERROR);\n', '\n', '        return (IRError.NO_ERROR, utilizationRate, annualBorrowRate);\n', '    }\n', '\n', '    /**\n', '      * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param _asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the supply interest rate per block scaled by 10e18\n', '      */\n', '    function getSupplyRate(address _asset, uint cash, uint borrows) public view returns (uint, uint) {\n', '        _asset; // pragma ignore unused argument\n', '\n', '        (IRError err0, Exp memory utilizationRate0, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (uint(err0), 0);\n', '        }\n', '\n', '        // We&#39;re going to multiply the utilization rate by the spread&#39;s numerator\n', '        (Error err1, Exp memory utilizationRate1) = mulScalar(utilizationRate0, oneMinusSpreadBasisPoints);\n', '        // mulScalar only overflows when product is greater than or equal to 2^256.\n', '        // utilization rate&#39;s mantissa is a number between [0e18,1e18]. That means that\n', '        // utilizationRate1 is a value between [0e18,9e21]. This is strictly less than 2^256.\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        // Next multiply this product times the borrow rate\n', '        (Error err2, Exp memory supplyRate0) = mulExp(utilizationRate1, annualBorrowRate);\n', '        // If the product of the mantissas for mulExp are both less than 2^256,\n', '        // then this operation will never fail. TODO: Verify.\n', '        // We know that borrow rate is in the interval [0, 4e17] from above.\n', '        // We know that utilizationRate1 is in the interval [0, 9e21] from directly above.\n', '        // As such, the multiplication is in the interval of [0, 3.6e39]. This is strictly\n', '        // less than 2^256 (which is about 10e77).\n', '        assert(err2 == Error.NO_ERROR);\n', '\n', '        // And then divide down by the spread&#39;s denominator (basis points divisor)\n', '        // as well as by blocks per year.\n', '        (Error err3, Exp memory supplyRate1) = divScalar(supplyRate0, 10000 * blocksPerYear); // basis points * blocks per year\n', '        // divScalar only fails when divisor is zero. This is clearly not the case.\n', '        assert(err3 == Error.NO_ERROR);\n', '\n', '        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n', '        return (uint(IRError.NO_ERROR), supplyRate1.mantissa);\n', '    }\n', '\n', '    /**\n', '      * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param _asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n', '      */\n', '    function getBorrowRate(address _asset, uint cash, uint borrows) public view returns (uint, uint) {\n', '        _asset; // pragma ignore unused argument\n', '\n', '        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (uint(err0), 0);\n', '        }\n', '\n', '        // And then divide down by blocks per year.\n', '        (Error err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n', '        // divScalar only fails when divisor is zero. This is clearly not the case.\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        _utilizationRate; // pragma ignore unused variable\n', '\n', '        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n', '        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n', '    }\n', '}']