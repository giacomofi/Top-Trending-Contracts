['/**\n', ' * https://github.com/drlecks/Ethereum-Contracts/tree/master/Hodl\n', ' */\n', '\n', '\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '    //How many decimals to show.\n', '    uint256 public decimals;\n', '    \n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name  \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract OwnableContract {\n', ' \n', '    address superOwner;\n', '\t\t\n', '\tconstructor() public { \n', '        superOwner = msg.sender;  \n', '    }\n', '\t\n', '\tmodifier onlyOwner() {\n', '        require(msg.sender == superOwner);\n', '        _;\n', '    } \n', '    \n', '    function viewSuperOwner() public view returns (address owner) {\n', '        return superOwner;\n', '    }\n', '    \n', '\tfunction changeOwner(address newOwner) onlyOwner public {\n', '        superOwner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract BlockableContract is OwnableContract{\n', ' \n', '    bool public blockedContract;\n', '\t\n', '\tconstructor() public { \n', '        blockedContract = false;  \n', '    }\n', '\t\n', '\tmodifier contractActive() {\n', '        require(!blockedContract);\n', '        _;\n', '    } \n', '\t\n', '\tfunction doBlockContract() onlyOwner public {\n', '        blockedContract = true;\n', '    }\n', '    \n', '    function unBlockContract() onlyOwner public {\n', '        blockedContract = false;\n', '    }\n', '}\n', '\n', 'contract Hodl is BlockableContract{\n', '    \n', '    struct Safe{\n', '        uint256 id;\n', '        address user;\n', '        address tokenAddress;\n', '        uint256 amount;\n', '        uint256 time;\n', '    }\n', '    \n', '    /**\n', '    * @dev safes variables\n', '    */\n', '    mapping( address => uint256[]) public _userSafes;\n', '    mapping( uint256 => Safe) private _safes;\n', '    uint256 private _currentIndex;\n', '    \n', '    mapping( address => uint256) public _totalSaved;\n', '     \n', '    /**\n', '    * @dev owner variables\n', '    */\n', '    uint256 public comission; //0..100\n', '    mapping( address => uint256) private _systemReserves;\n', '    address[] public _listedReserves;\n', '     \n', '    /**\n', '    * constructor\n', '    */\n', '    constructor() public { \n', '        _currentIndex = 1;\n', '        comission = 10;\n', '    }\n', '    \n', '    /**\n', '    * fallback function to receive donation eth\n', '    */\n', '    function () public payable {\n', '        require(msg.value>0);\n', '        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);\n', '    }\n', '    \n', '    /**\n', '    * how many safes has the user\n', '    */\n', '    function GetUserSafesLength(address a) public view returns (uint256 length) {\n', '        return _userSafes[a].length;\n', '    }\n', '    \n', '    /**\n', '    * how many tokens are reservedfor owner as comission\n', '    */\n', '    function GetReserveAmount(address tokenAddress) public view returns (uint256 amount){\n', '        return _systemReserves[tokenAddress];\n', '    }\n', '    \n', '    /**\n', '    * returns safe&#39;s values&#39;\n', '    */\n', '    function Getsafe(uint256 _id) public view\n', '        returns (uint256 id, address user, address tokenAddress, uint256 amount, uint256 time)\n', '    {\n', '        Safe storage s = _safes[_id];\n', '        return(s.id, s.user, s.tokenAddress, s.amount, s.time);\n', '    }\n', '    \n', '    \n', '    /**\n', '    * add new hodl safe (ETH)\n', '    */\n', '    function HodlEth(uint256 time) public contractActive payable {\n', '        require(msg.value > 0);\n', '        require(time>now);\n', '        \n', '        _userSafes[msg.sender].push(_currentIndex);\n', '        _safes[_currentIndex] = Safe(_currentIndex, msg.sender, 0x0, msg.value, time); \n', '        \n', '        _totalSaved[0x0] = add(_totalSaved[0x0], msg.value);\n', '        \n', '        _currentIndex++;\n', '    }\n', '    \n', '    /**\n', '    * add new hodl safe (ERC20 token)\n', '    */\n', '    function ClaimHodlToken(address tokenAddress, uint256 amount, uint256 time) public contractActive {\n', '        require(tokenAddress != 0x0);\n', '        require(amount>0);\n', '        require(time>now);\n', '          \n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require( token.transferFrom(msg.sender, address(this), amount) );\n', '        \n', '        _userSafes[msg.sender].push(_currentIndex);\n', '        _safes[_currentIndex] = Safe(_currentIndex, msg.sender, tokenAddress, amount, time);\n', '        \n', '        _totalSaved[tokenAddress] = add(_totalSaved[tokenAddress], amount);\n', '        \n', '        _currentIndex++;\n', '    }\n', '    \n', '    /**\n', '    * user, claim back a hodl safe\n', '    */\n', '    function UserRetireHodl(uint256 id) public {\n', '        Safe storage s = _safes[id];\n', '        \n', '        require(s.id != 0);\n', '        require(s.user == msg.sender);\n', '        \n', '        RetireHodl(id);\n', '    }\n', '    \n', '    /**\n', '    * private retire hodl safe action\n', '    */\n', '    function RetireHodl(uint256 id) private {\n', '        Safe storage s = _safes[id]; \n', '        require(s.id != 0); \n', '        \n', '        if(s.time < now) //hodl complete\n', '        {\n', '            if(s.tokenAddress == 0x0) \n', '                PayEth(s.user, s.amount);\n', '            else  \n', '                PayToken(s.user, s.tokenAddress, s.amount);\n', '        }\n', '        else //hodl in progress\n', '        {\n', '            uint256 realComission = mul(s.amount, comission) / 100;\n', '            uint256 realAmount = sub(s.amount, realComission);\n', '            \n', '            if(s.tokenAddress == 0x0) \n', '                PayEth(s.user, realAmount);\n', '            else  \n', '                PayToken(s.user, s.tokenAddress, realAmount);\n', '                \n', '            StoreComission(s.tokenAddress, realComission);\n', '        }\n', '        \n', '        DeleteSafe(s);\n', '    }\n', '    \n', '    /**\n', '    * private pay eth to address\n', '    */\n', '    function PayEth(address user, uint256 amount) private {\n', '        require(address(this).balance >= amount);\n', '        user.transfer(amount);\n', '    }\n', '    \n', '    /**\n', '    * private pay token to address\n', '    */\n', '    function PayToken(address user, address tokenAddress, uint256 amount) private{\n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require(token.balanceOf(address(this)) >= amount);\n', '        token.transfer(user, amount);\n', '    }\n', '    \n', '    /**\n', '    * store comission from unfinished hodl\n', '    */\n', '    function StoreComission(address tokenAddress, uint256 amount) private {\n', '        _systemReserves[tokenAddress] = add(_systemReserves[tokenAddress], amount);\n', '        \n', '        bool isNew = true;\n', '        for(uint256 i = 0; i < _listedReserves.length; i++) {\n', '            if(_listedReserves[i] == tokenAddress) {\n', '                isNew = false;\n', '                break;\n', '            }\n', '        } \n', '        \n', '        if(isNew) _listedReserves.push(tokenAddress); \n', '    }\n', '    \n', '    /**\n', '    * delete safe values in storage\n', '    */\n', '    function DeleteSafe(Safe s) private  {\n', '        _totalSaved[s.tokenAddress] = sub(_totalSaved[s.tokenAddress], s.amount);\n', '        delete _safes[s.id];\n', '        \n', '        uint256[] storage vector = _userSafes[msg.sender];\n', '        uint256 size = vector.length; \n', '        for(uint256 i = 0; i < size; i++) {\n', '            if(vector[i] == s.id) {\n', '                vector[i] = vector[size-1];\n', '                vector.length--;\n', '                break;\n', '            }\n', '        } \n', '    }\n', '    \n', '    \n', '    //OWNER\n', '    \n', '    /**\n', '    * owner retire hodl safe\n', '    */\n', '    function OwnerRetireHodl(uint256 id) public onlyOwner {\n', '        Safe storage s = _safes[id]; \n', '        require(s.id != 0); \n', '        RetireHodl(id);\n', '    }\n', '\n', '    /**\n', '    * owner, change comission value\n', '    */\n', '    function ChangeComission(uint256 newComission) onlyOwner public {\n', '        comission = newComission;\n', '    }\n', '    \n', '    /**\n', '    * owner withdraw eth reserved from comissions \n', '    */\n', '    function WithdrawReserve(address tokenAddress) onlyOwner public\n', '    {\n', '        require(_systemReserves[tokenAddress] > 0);\n', '        \n', '        uint256 amount = _systemReserves[tokenAddress];\n', '        _systemReserves[tokenAddress] = 0;\n', '        \n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require(token.balanceOf(address(this)) >= amount);\n', '        token.transfer(msg.sender, amount);\n', '    }\n', '    \n', '    /**\n', '    * owner withdraw token reserved from comission\n', '    */\n', '    function WithdrawAllReserves() onlyOwner public {\n', '        //eth\n', '        uint256 x = _systemReserves[0x0];\n', '        if(x > 0 && x <= address(this).balance) {\n', '            _systemReserves[0x0] = 0;\n', '            msg.sender.transfer( _systemReserves[0x0] );\n', '        }\n', '         \n', '        //tokens\n', '        address ta;\n', '        EIP20Interface token;\n', '        for(uint256 i = 0; i < _listedReserves.length; i++) {\n', '            ta = _listedReserves[i];\n', '            if(_systemReserves[ta] > 0)\n', '            { \n', '                x = _systemReserves[ta];\n', '                _systemReserves[ta] = 0;\n', '                \n', '                token = EIP20Interface(ta);\n', '                token.transfer(msg.sender, x);\n', '            }\n', '        } \n', '        \n', '        _listedReserves.length = 0; \n', '    }\n', '    \n', '    /**\n', '    * owner remove free eth\n', '    */\n', '    function WithdrawSpecialEth(uint256 amount) onlyOwner public\n', '    {\n', '        require(amount > 0); \n', '        uint256 freeBalance = address(this).balance - _totalSaved[0x0];\n', '        require(freeBalance >= amount); \n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    /**\n', '    * owner remove free token\n', '    */\n', '    function WithdrawSpecialToken(address tokenAddress, uint256 amount) onlyOwner public\n', '    {\n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        uint256 freeBalance = token.balanceOf(address(this)) - _totalSaved[tokenAddress];\n', '        require(freeBalance >= amount);\n', '        token.transfer(msg.sender, amount);\n', '    } \n', '    \n', '    \n', '    //AUX\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '    \n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    \n', '}']
['/**\n', ' * https://github.com/drlecks/Ethereum-Contracts/tree/master/Hodl\n', ' */\n', '\n', '\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '    //How many decimals to show.\n', '    uint256 public decimals;\n', '    \n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name  \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract OwnableContract {\n', ' \n', '    address superOwner;\n', '\t\t\n', '\tconstructor() public { \n', '        superOwner = msg.sender;  \n', '    }\n', '\t\n', '\tmodifier onlyOwner() {\n', '        require(msg.sender == superOwner);\n', '        _;\n', '    } \n', '    \n', '    function viewSuperOwner() public view returns (address owner) {\n', '        return superOwner;\n', '    }\n', '    \n', '\tfunction changeOwner(address newOwner) onlyOwner public {\n', '        superOwner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract BlockableContract is OwnableContract{\n', ' \n', '    bool public blockedContract;\n', '\t\n', '\tconstructor() public { \n', '        blockedContract = false;  \n', '    }\n', '\t\n', '\tmodifier contractActive() {\n', '        require(!blockedContract);\n', '        _;\n', '    } \n', '\t\n', '\tfunction doBlockContract() onlyOwner public {\n', '        blockedContract = true;\n', '    }\n', '    \n', '    function unBlockContract() onlyOwner public {\n', '        blockedContract = false;\n', '    }\n', '}\n', '\n', 'contract Hodl is BlockableContract{\n', '    \n', '    struct Safe{\n', '        uint256 id;\n', '        address user;\n', '        address tokenAddress;\n', '        uint256 amount;\n', '        uint256 time;\n', '    }\n', '    \n', '    /**\n', '    * @dev safes variables\n', '    */\n', '    mapping( address => uint256[]) public _userSafes;\n', '    mapping( uint256 => Safe) private _safes;\n', '    uint256 private _currentIndex;\n', '    \n', '    mapping( address => uint256) public _totalSaved;\n', '     \n', '    /**\n', '    * @dev owner variables\n', '    */\n', '    uint256 public comission; //0..100\n', '    mapping( address => uint256) private _systemReserves;\n', '    address[] public _listedReserves;\n', '     \n', '    /**\n', '    * constructor\n', '    */\n', '    constructor() public { \n', '        _currentIndex = 1;\n', '        comission = 10;\n', '    }\n', '    \n', '    /**\n', '    * fallback function to receive donation eth\n', '    */\n', '    function () public payable {\n', '        require(msg.value>0);\n', '        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);\n', '    }\n', '    \n', '    /**\n', '    * how many safes has the user\n', '    */\n', '    function GetUserSafesLength(address a) public view returns (uint256 length) {\n', '        return _userSafes[a].length;\n', '    }\n', '    \n', '    /**\n', '    * how many tokens are reservedfor owner as comission\n', '    */\n', '    function GetReserveAmount(address tokenAddress) public view returns (uint256 amount){\n', '        return _systemReserves[tokenAddress];\n', '    }\n', '    \n', '    /**\n', "    * returns safe's values'\n", '    */\n', '    function Getsafe(uint256 _id) public view\n', '        returns (uint256 id, address user, address tokenAddress, uint256 amount, uint256 time)\n', '    {\n', '        Safe storage s = _safes[_id];\n', '        return(s.id, s.user, s.tokenAddress, s.amount, s.time);\n', '    }\n', '    \n', '    \n', '    /**\n', '    * add new hodl safe (ETH)\n', '    */\n', '    function HodlEth(uint256 time) public contractActive payable {\n', '        require(msg.value > 0);\n', '        require(time>now);\n', '        \n', '        _userSafes[msg.sender].push(_currentIndex);\n', '        _safes[_currentIndex] = Safe(_currentIndex, msg.sender, 0x0, msg.value, time); \n', '        \n', '        _totalSaved[0x0] = add(_totalSaved[0x0], msg.value);\n', '        \n', '        _currentIndex++;\n', '    }\n', '    \n', '    /**\n', '    * add new hodl safe (ERC20 token)\n', '    */\n', '    function ClaimHodlToken(address tokenAddress, uint256 amount, uint256 time) public contractActive {\n', '        require(tokenAddress != 0x0);\n', '        require(amount>0);\n', '        require(time>now);\n', '          \n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require( token.transferFrom(msg.sender, address(this), amount) );\n', '        \n', '        _userSafes[msg.sender].push(_currentIndex);\n', '        _safes[_currentIndex] = Safe(_currentIndex, msg.sender, tokenAddress, amount, time);\n', '        \n', '        _totalSaved[tokenAddress] = add(_totalSaved[tokenAddress], amount);\n', '        \n', '        _currentIndex++;\n', '    }\n', '    \n', '    /**\n', '    * user, claim back a hodl safe\n', '    */\n', '    function UserRetireHodl(uint256 id) public {\n', '        Safe storage s = _safes[id];\n', '        \n', '        require(s.id != 0);\n', '        require(s.user == msg.sender);\n', '        \n', '        RetireHodl(id);\n', '    }\n', '    \n', '    /**\n', '    * private retire hodl safe action\n', '    */\n', '    function RetireHodl(uint256 id) private {\n', '        Safe storage s = _safes[id]; \n', '        require(s.id != 0); \n', '        \n', '        if(s.time < now) //hodl complete\n', '        {\n', '            if(s.tokenAddress == 0x0) \n', '                PayEth(s.user, s.amount);\n', '            else  \n', '                PayToken(s.user, s.tokenAddress, s.amount);\n', '        }\n', '        else //hodl in progress\n', '        {\n', '            uint256 realComission = mul(s.amount, comission) / 100;\n', '            uint256 realAmount = sub(s.amount, realComission);\n', '            \n', '            if(s.tokenAddress == 0x0) \n', '                PayEth(s.user, realAmount);\n', '            else  \n', '                PayToken(s.user, s.tokenAddress, realAmount);\n', '                \n', '            StoreComission(s.tokenAddress, realComission);\n', '        }\n', '        \n', '        DeleteSafe(s);\n', '    }\n', '    \n', '    /**\n', '    * private pay eth to address\n', '    */\n', '    function PayEth(address user, uint256 amount) private {\n', '        require(address(this).balance >= amount);\n', '        user.transfer(amount);\n', '    }\n', '    \n', '    /**\n', '    * private pay token to address\n', '    */\n', '    function PayToken(address user, address tokenAddress, uint256 amount) private{\n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require(token.balanceOf(address(this)) >= amount);\n', '        token.transfer(user, amount);\n', '    }\n', '    \n', '    /**\n', '    * store comission from unfinished hodl\n', '    */\n', '    function StoreComission(address tokenAddress, uint256 amount) private {\n', '        _systemReserves[tokenAddress] = add(_systemReserves[tokenAddress], amount);\n', '        \n', '        bool isNew = true;\n', '        for(uint256 i = 0; i < _listedReserves.length; i++) {\n', '            if(_listedReserves[i] == tokenAddress) {\n', '                isNew = false;\n', '                break;\n', '            }\n', '        } \n', '        \n', '        if(isNew) _listedReserves.push(tokenAddress); \n', '    }\n', '    \n', '    /**\n', '    * delete safe values in storage\n', '    */\n', '    function DeleteSafe(Safe s) private  {\n', '        _totalSaved[s.tokenAddress] = sub(_totalSaved[s.tokenAddress], s.amount);\n', '        delete _safes[s.id];\n', '        \n', '        uint256[] storage vector = _userSafes[msg.sender];\n', '        uint256 size = vector.length; \n', '        for(uint256 i = 0; i < size; i++) {\n', '            if(vector[i] == s.id) {\n', '                vector[i] = vector[size-1];\n', '                vector.length--;\n', '                break;\n', '            }\n', '        } \n', '    }\n', '    \n', '    \n', '    //OWNER\n', '    \n', '    /**\n', '    * owner retire hodl safe\n', '    */\n', '    function OwnerRetireHodl(uint256 id) public onlyOwner {\n', '        Safe storage s = _safes[id]; \n', '        require(s.id != 0); \n', '        RetireHodl(id);\n', '    }\n', '\n', '    /**\n', '    * owner, change comission value\n', '    */\n', '    function ChangeComission(uint256 newComission) onlyOwner public {\n', '        comission = newComission;\n', '    }\n', '    \n', '    /**\n', '    * owner withdraw eth reserved from comissions \n', '    */\n', '    function WithdrawReserve(address tokenAddress) onlyOwner public\n', '    {\n', '        require(_systemReserves[tokenAddress] > 0);\n', '        \n', '        uint256 amount = _systemReserves[tokenAddress];\n', '        _systemReserves[tokenAddress] = 0;\n', '        \n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        require(token.balanceOf(address(this)) >= amount);\n', '        token.transfer(msg.sender, amount);\n', '    }\n', '    \n', '    /**\n', '    * owner withdraw token reserved from comission\n', '    */\n', '    function WithdrawAllReserves() onlyOwner public {\n', '        //eth\n', '        uint256 x = _systemReserves[0x0];\n', '        if(x > 0 && x <= address(this).balance) {\n', '            _systemReserves[0x0] = 0;\n', '            msg.sender.transfer( _systemReserves[0x0] );\n', '        }\n', '         \n', '        //tokens\n', '        address ta;\n', '        EIP20Interface token;\n', '        for(uint256 i = 0; i < _listedReserves.length; i++) {\n', '            ta = _listedReserves[i];\n', '            if(_systemReserves[ta] > 0)\n', '            { \n', '                x = _systemReserves[ta];\n', '                _systemReserves[ta] = 0;\n', '                \n', '                token = EIP20Interface(ta);\n', '                token.transfer(msg.sender, x);\n', '            }\n', '        } \n', '        \n', '        _listedReserves.length = 0; \n', '    }\n', '    \n', '    /**\n', '    * owner remove free eth\n', '    */\n', '    function WithdrawSpecialEth(uint256 amount) onlyOwner public\n', '    {\n', '        require(amount > 0); \n', '        uint256 freeBalance = address(this).balance - _totalSaved[0x0];\n', '        require(freeBalance >= amount); \n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    /**\n', '    * owner remove free token\n', '    */\n', '    function WithdrawSpecialToken(address tokenAddress, uint256 amount) onlyOwner public\n', '    {\n', '        EIP20Interface token = EIP20Interface(tokenAddress);\n', '        uint256 freeBalance = token.balanceOf(address(this)) - _totalSaved[tokenAddress];\n', '        require(freeBalance >= amount);\n', '        token.transfer(msg.sender, amount);\n', '    } \n', '    \n', '    \n', '    //AUX\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '    \n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    \n', '    \n', '}']
