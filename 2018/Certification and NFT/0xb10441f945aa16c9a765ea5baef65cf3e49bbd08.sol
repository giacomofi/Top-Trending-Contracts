['pragma solidity ^0.4.8;\n', '\n', '\n', 'library BobbySafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract BobbyERC20Base {\n', '\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    //是否暂停智能合约的运行\n', '    bool public paused = false;\n', '\n', '    constructor(address cfoAddr) public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = cfoAddr;\n', '    }\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyCEO whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    //ERC20指定接口\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '    //extend event\n', '    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\n', '    event Unlock(address indexed user, uint wad);                       //解禁代币\n', '\n', '    function name() public view returns (string n);\n', '    function symbol() public view returns (string s);\n', '    function decimals() public view returns (uint8 d);\n', '    function totalSupply() public view returns (uint256 t);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '    using BobbySafeMath for uint256;\n', '\n', '    uint private _Thousand = 1000;\n', '    uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '    //代币基本信息\n', '    string private _name = "BOBBY";     //代币名称\n', '    string private _symbol = "BOBBY";   //代币标识\n', '    uint8 private _decimals = 9;        //小数点后位数\n', '    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '    struct LockedToken {\n', '        uint256 total;          // 数量\n', '        uint256 duration;       // 解锁总时长\n', '        uint256 periods;        // 解锁期数\n', '\n', '        uint256 balance;         // 剩余未解锁数量\n', '        uint256 unlockLast;      // 上次解锁时间\n', '    }\n', '\n', '    //解封用户代币结构\n', '    struct UserToken {\n', '        uint index;                     //放在数组中的下标\n', '        address addr;                   //用户账号\n', '        uint256 tokens;                 //通证数量\n', '        LockedToken[] lockedTokens;     //锁定的token\n', '    }\n', '\n', '    mapping(address=>UserToken) private _userMap;           //用户映射\n', '    address[] private _userArray;                           //用户数组,from 1\n', '\n', '    uint32 private actionTransfer = 0;\n', '    uint32 private actionGrant = 1;\n', '    uint32 private actionUnlock = 2;\n', '\n', '    struct LogEntry {\n', '        uint256 time;\n', '        uint32  action;       // 0 转账 1 发放 2 解锁\n', '        address from;\n', '        address to;\n', '        uint256 v1;\n', '        uint256 v2;\n', '        uint256 v3;\n', '    }\n', '\n', '    LogEntry[] private _logs;\n', '\n', '    function _addUser(address addrUser) private returns (UserToken storage) {\n', '        _userMap[addrUser].index = _userArray.length;\n', '        _userMap[addrUser].addr = addrUser;\n', '        _userMap[addrUser].tokens = 0;\n', '        _userArray.push(addrUser);\n', '        return _userMap[addrUser];\n', '    }\n', '\n', '    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\n', '\n', '        //placeholder\n', '        _userArray.push(address(0));\n', '\n', '        UserToken storage userCFO = _addUser(cfoAddr);\n', '        userCFO.tokens = _totalSupply;\n', '    }\n', '\n', '    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '    function name() public view returns (string n){\n', '        n = _name;\n', '    }\n', '\n', '    //返回合约标识符\n', '    function symbol() public view returns (string s){\n', '        s = _symbol;\n', '    }\n', '\n', '    //返回合约小数位\n', '    function decimals() public view returns (uint8 d){\n', '        d = _decimals;\n', '    }\n', '\n', '    //返回合约总供给额\n', '    function totalSupply() public view returns (uint256 t){\n', '        t = _totalSupply;\n', '    }\n', '\n', '    //查询账户_owner的账户余额\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        UserToken storage user = _userMap[_owner];\n', '        if (0 == user.index) {\n', '            balance = 0;\n', '            return;\n', '        }\n', '\n', '        balance = user.tokens;\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            balance = balance.add((user.lockedTokens[index]).balance);\n', '        }\n', '    }\n', '\n', '    function _checkUnlock(address addrUser) private {\n', '        UserToken storage user = _userMap[addrUser];\n', '        if (0 == user.index) {\n', '            return;\n', '        }\n', '\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            LockedToken storage locked = user.lockedTokens[index];\n', '            if(locked.balance <= 0){\n', '                continue;\n', '            }\n', '\n', '            uint256 diff = now.sub(locked.unlockLast);\n', '            uint256 unlockUnit = locked.total.div(locked.periods);\n', '            uint256 periodDuration = locked.duration.div(locked.periods);\n', '            uint256 unlockedPeriods = locked.total.sub(locked.balance).div(unlockUnit);\n', '            uint256 periodsToUnlock = diff.div(periodDuration);\n', '\n', '            if(periodsToUnlock > 0) {\n', '                uint256 tokenToUnlock = 0;\n', '                if(unlockedPeriods + periodsToUnlock >= locked.periods) {\n', '                    tokenToUnlock = locked.balance;\n', '                }else{\n', '                    tokenToUnlock = unlockUnit.mul(periodsToUnlock);\n', '                }\n', '\n', '                if (tokenToUnlock >= locked.balance) {\n', '                    tokenToUnlock = locked.balance;\n', '                }\n', '\n', '                locked.balance = locked.balance.sub(tokenToUnlock);\n', '                user.tokens = user.tokens.add(tokenToUnlock);\n', '                locked.unlockLast = locked.unlockLast.add(periodDuration.mul(periodsToUnlock));\n', '\n', '                emit Unlock(addrUser, tokenToUnlock);\n', '                log(actionUnlock, addrUser, 0, tokenToUnlock, 0, 0);\n', '            }\n', '        }\n', '    }   \n', '\n', '    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '        require(msg.sender != _to);\n', '\n', '        //检查是否有可以解锁的token\n', '        _checkUnlock(msg.sender);\n', '\n', '        require(_userMap[msg.sender].tokens >= _value);\n', '        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\n', '\n', '        UserToken storage userTo = _userMap[_to];\n', '        if(0 == userTo.index){\n', '            userTo = _addUser(_to);\n', '        }\n', '        userTo.tokens = userTo.tokens.add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        log(actionTransfer, msg.sender, _to, _value, 0, 0);\n', '\n', '        success = true;\n', '    }\n', '\n', '    function transferFrom(address, address, uint256) public whenNotPaused returns (bool success){\n', '        success = true;\n', '    }\n', '\n', '    function approve(address, uint256) public whenNotPaused returns (bool success){\n', '        success = true;\n', '    }\n', '\n', '    function allowance(address, address) public view returns (uint256 remaining){\n', '        remaining = 0;\n', '    }\n', '\n', '    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public whenNotPaused returns (bool success){\n', '        require(msg.sender != _to);\n', '\n', '        //检查是否有可以解锁的token\n', '        _checkUnlock(msg.sender);\n', '\n', '        require(_userMap[msg.sender].tokens >= _value);\n', '        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\n', '        \n', '        UserToken storage userTo = _userMap[_to];\n', '        if(0 == userTo.index){\n', '            userTo = _addUser(_to);\n', '        }\n', '\n', '        LockedToken memory locked;\n', '        locked.total = _value;\n', '        locked.duration = _duration.mul(30 days);\n', '        // locked.duration = _duration.mul(1 minutes); //for test\n', '        locked.periods = _periods;\n', '        locked.balance = _value;\n', '        locked.unlockLast = now;\n', '        userTo.lockedTokens.push(locked);\n', '\n', '        emit Grant(msg.sender, _to, _value);\n', '        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\n', '\n', '        success = true;\n', '    }\n', '\n', '    function getUserAddr(uint256 _index) public view returns(address addr){\n', '        require(_index < _userArray.length);\n', '        addr = _userArray[_index];\n', '    }\n', '\n', '    function getUserSize() public view returns(uint256 size){\n', '        size = _userArray.length;\n', '    }\n', '\n', '\n', '    function getLockSize(address addr) public view returns (uint256 len) {\n', '        UserToken storage user = _userMap[addr];\n', '        len = user.lockedTokens.length;\n', '    }\n', '\n', '    function getLock(address addr, uint256 index) public view returns (uint256 total, uint256 duration, uint256 periods, uint256 balance, uint256 unlockLast) {\n', '        UserToken storage user = _userMap[addr];\n', '        require(index < user.lockedTokens.length);\n', '        total = user.lockedTokens[index].total;\n', '        duration = user.lockedTokens[index].duration;\n', '        periods = user.lockedTokens[index].periods;\n', '        balance = user.lockedTokens[index].balance;\n', '        unlockLast = user.lockedTokens[index].unlockLast;\n', '    }\n', '\n', '    function getLockInfo(address addr) public view returns (uint256[] totals, uint256[] durations, uint256[] periodses, uint256[] balances, uint256[] unlockLasts) {\n', '        UserToken storage user = _userMap[addr];\n', '        uint256 len = user.lockedTokens.length;\n', '        totals = new uint256[](len);\n', '        durations = new uint256[](len);\n', '        periodses = new uint256[](len);\n', '        balances = new uint256[](len);\n', '        unlockLasts = new uint256[](len);\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            totals[index] = user.lockedTokens[index].total;\n', '            durations[index] = user.lockedTokens[index].duration;\n', '            periodses[index] = user.lockedTokens[index].periods;\n', '            balances[index] = user.lockedTokens[index].balance;\n', '            unlockLasts[index] = user.lockedTokens[index].unlockLast;\n', '        }\n', '    }\n', '\n', '    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\n', '        LogEntry memory entry;\n', '        entry.action = action;\n', '        entry.time = now;\n', '        entry.from = from;\n', '        entry.to = to;\n', '        entry.v1 = _v1;\n', '        entry.v2 = _v2;\n', '        entry.v3 = _v3;\n', '        _logs.push(entry);\n', '    }\n', '\n', '    function getLogSize() public view returns(uint256 size){\n', '        size = _logs.length;\n', '    }\n', '\n', '    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\n', '        require(_index < _logs.length);\n', '        require(_index >= 0);\n', '        LogEntry storage entry = _logs[_index];\n', '        action = entry.action;\n', '        time = entry.time;\n', '        from = entry.from;\n', '        to = entry.to;\n', '        _v1 = entry.v1;\n', '        _v2 = entry.v2;\n', '        _v3 = entry.v3;\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', 'library BobbySafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract BobbyERC20Base {\n', '\n', '    address public ceoAddress;\n', '    address public cfoAddress;\n', '\n', '    //是否暂停智能合约的运行\n', '    bool public paused = false;\n', '\n', '    constructor(address cfoAddr) public {\n', '        ceoAddress = msg.sender;\n', '        cfoAddress = cfoAddr;\n', '    }\n', '\n', '    modifier onlyCEO() {\n', '        require(msg.sender == ceoAddress);\n', '        _;\n', '    }\n', '\n', '    function setCEO(address _newCEO) public onlyCEO {\n', '        require(_newCEO != address(0));\n', '        ceoAddress = _newCEO;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyCEO whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyCEO whenPaused {\n', '        paused = false;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '\n', '    //ERC20指定接口\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '\n', '    //extend event\n', '    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\n', '    event Unlock(address indexed user, uint wad);                       //解禁代币\n', '\n', '    function name() public view returns (string n);\n', '    function symbol() public view returns (string s);\n', '    function decimals() public view returns (uint8 d);\n', '    function totalSupply() public view returns (uint256 t);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '}\n', '\n', '//Erc智能合约\n', 'contract ERC20 is ERC20Interface, BobbyERC20Base {\n', '    using BobbySafeMath for uint256;\n', '\n', '    uint private _Thousand = 1000;\n', '    uint private _Billion = _Thousand * _Thousand * _Thousand;\n', '\n', '    //代币基本信息\n', '    string private _name = "BOBBY";     //代币名称\n', '    string private _symbol = "BOBBY";   //代币标识\n', '    uint8 private _decimals = 9;        //小数点后位数\n', '    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\n', '\n', '    struct LockedToken {\n', '        uint256 total;          // 数量\n', '        uint256 duration;       // 解锁总时长\n', '        uint256 periods;        // 解锁期数\n', '\n', '        uint256 balance;         // 剩余未解锁数量\n', '        uint256 unlockLast;      // 上次解锁时间\n', '    }\n', '\n', '    //解封用户代币结构\n', '    struct UserToken {\n', '        uint index;                     //放在数组中的下标\n', '        address addr;                   //用户账号\n', '        uint256 tokens;                 //通证数量\n', '        LockedToken[] lockedTokens;     //锁定的token\n', '    }\n', '\n', '    mapping(address=>UserToken) private _userMap;           //用户映射\n', '    address[] private _userArray;                           //用户数组,from 1\n', '\n', '    uint32 private actionTransfer = 0;\n', '    uint32 private actionGrant = 1;\n', '    uint32 private actionUnlock = 2;\n', '\n', '    struct LogEntry {\n', '        uint256 time;\n', '        uint32  action;       // 0 转账 1 发放 2 解锁\n', '        address from;\n', '        address to;\n', '        uint256 v1;\n', '        uint256 v2;\n', '        uint256 v3;\n', '    }\n', '\n', '    LogEntry[] private _logs;\n', '\n', '    function _addUser(address addrUser) private returns (UserToken storage) {\n', '        _userMap[addrUser].index = _userArray.length;\n', '        _userMap[addrUser].addr = addrUser;\n', '        _userMap[addrUser].tokens = 0;\n', '        _userArray.push(addrUser);\n', '        return _userMap[addrUser];\n', '    }\n', '\n', '    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\n', '    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\n', '\n', '        //placeholder\n', '        _userArray.push(address(0));\n', '\n', '        UserToken storage userCFO = _addUser(cfoAddr);\n', '        userCFO.tokens = _totalSupply;\n', '    }\n', '\n', '    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\n', '    function name() public view returns (string n){\n', '        n = _name;\n', '    }\n', '\n', '    //返回合约标识符\n', '    function symbol() public view returns (string s){\n', '        s = _symbol;\n', '    }\n', '\n', '    //返回合约小数位\n', '    function decimals() public view returns (uint8 d){\n', '        d = _decimals;\n', '    }\n', '\n', '    //返回合约总供给额\n', '    function totalSupply() public view returns (uint256 t){\n', '        t = _totalSupply;\n', '    }\n', '\n', '    //查询账户_owner的账户余额\n', '    function balanceOf(address _owner) public view returns (uint256 balance){\n', '        UserToken storage user = _userMap[_owner];\n', '        if (0 == user.index) {\n', '            balance = 0;\n', '            return;\n', '        }\n', '\n', '        balance = user.tokens;\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            balance = balance.add((user.lockedTokens[index]).balance);\n', '        }\n', '    }\n', '\n', '    function _checkUnlock(address addrUser) private {\n', '        UserToken storage user = _userMap[addrUser];\n', '        if (0 == user.index) {\n', '            return;\n', '        }\n', '\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            LockedToken storage locked = user.lockedTokens[index];\n', '            if(locked.balance <= 0){\n', '                continue;\n', '            }\n', '\n', '            uint256 diff = now.sub(locked.unlockLast);\n', '            uint256 unlockUnit = locked.total.div(locked.periods);\n', '            uint256 periodDuration = locked.duration.div(locked.periods);\n', '            uint256 unlockedPeriods = locked.total.sub(locked.balance).div(unlockUnit);\n', '            uint256 periodsToUnlock = diff.div(periodDuration);\n', '\n', '            if(periodsToUnlock > 0) {\n', '                uint256 tokenToUnlock = 0;\n', '                if(unlockedPeriods + periodsToUnlock >= locked.periods) {\n', '                    tokenToUnlock = locked.balance;\n', '                }else{\n', '                    tokenToUnlock = unlockUnit.mul(periodsToUnlock);\n', '                }\n', '\n', '                if (tokenToUnlock >= locked.balance) {\n', '                    tokenToUnlock = locked.balance;\n', '                }\n', '\n', '                locked.balance = locked.balance.sub(tokenToUnlock);\n', '                user.tokens = user.tokens.add(tokenToUnlock);\n', '                locked.unlockLast = locked.unlockLast.add(periodDuration.mul(periodsToUnlock));\n', '\n', '                emit Unlock(addrUser, tokenToUnlock);\n', '                log(actionUnlock, addrUser, 0, tokenToUnlock, 0, 0);\n', '            }\n', '        }\n', '    }   \n', '\n', '    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success){\n', '        require(msg.sender != _to);\n', '\n', '        //检查是否有可以解锁的token\n', '        _checkUnlock(msg.sender);\n', '\n', '        require(_userMap[msg.sender].tokens >= _value);\n', '        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\n', '\n', '        UserToken storage userTo = _userMap[_to];\n', '        if(0 == userTo.index){\n', '            userTo = _addUser(_to);\n', '        }\n', '        userTo.tokens = userTo.tokens.add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        log(actionTransfer, msg.sender, _to, _value, 0, 0);\n', '\n', '        success = true;\n', '    }\n', '\n', '    function transferFrom(address, address, uint256) public whenNotPaused returns (bool success){\n', '        success = true;\n', '    }\n', '\n', '    function approve(address, uint256) public whenNotPaused returns (bool success){\n', '        success = true;\n', '    }\n', '\n', '    function allowance(address, address) public view returns (uint256 remaining){\n', '        remaining = 0;\n', '    }\n', '\n', '    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public whenNotPaused returns (bool success){\n', '        require(msg.sender != _to);\n', '\n', '        //检查是否有可以解锁的token\n', '        _checkUnlock(msg.sender);\n', '\n', '        require(_userMap[msg.sender].tokens >= _value);\n', '        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\n', '        \n', '        UserToken storage userTo = _userMap[_to];\n', '        if(0 == userTo.index){\n', '            userTo = _addUser(_to);\n', '        }\n', '\n', '        LockedToken memory locked;\n', '        locked.total = _value;\n', '        locked.duration = _duration.mul(30 days);\n', '        // locked.duration = _duration.mul(1 minutes); //for test\n', '        locked.periods = _periods;\n', '        locked.balance = _value;\n', '        locked.unlockLast = now;\n', '        userTo.lockedTokens.push(locked);\n', '\n', '        emit Grant(msg.sender, _to, _value);\n', '        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\n', '\n', '        success = true;\n', '    }\n', '\n', '    function getUserAddr(uint256 _index) public view returns(address addr){\n', '        require(_index < _userArray.length);\n', '        addr = _userArray[_index];\n', '    }\n', '\n', '    function getUserSize() public view returns(uint256 size){\n', '        size = _userArray.length;\n', '    }\n', '\n', '\n', '    function getLockSize(address addr) public view returns (uint256 len) {\n', '        UserToken storage user = _userMap[addr];\n', '        len = user.lockedTokens.length;\n', '    }\n', '\n', '    function getLock(address addr, uint256 index) public view returns (uint256 total, uint256 duration, uint256 periods, uint256 balance, uint256 unlockLast) {\n', '        UserToken storage user = _userMap[addr];\n', '        require(index < user.lockedTokens.length);\n', '        total = user.lockedTokens[index].total;\n', '        duration = user.lockedTokens[index].duration;\n', '        periods = user.lockedTokens[index].periods;\n', '        balance = user.lockedTokens[index].balance;\n', '        unlockLast = user.lockedTokens[index].unlockLast;\n', '    }\n', '\n', '    function getLockInfo(address addr) public view returns (uint256[] totals, uint256[] durations, uint256[] periodses, uint256[] balances, uint256[] unlockLasts) {\n', '        UserToken storage user = _userMap[addr];\n', '        uint256 len = user.lockedTokens.length;\n', '        totals = new uint256[](len);\n', '        durations = new uint256[](len);\n', '        periodses = new uint256[](len);\n', '        balances = new uint256[](len);\n', '        unlockLasts = new uint256[](len);\n', '        for (uint index = 0; index < user.lockedTokens.length; index++) {\n', '            totals[index] = user.lockedTokens[index].total;\n', '            durations[index] = user.lockedTokens[index].duration;\n', '            periodses[index] = user.lockedTokens[index].periods;\n', '            balances[index] = user.lockedTokens[index].balance;\n', '            unlockLasts[index] = user.lockedTokens[index].unlockLast;\n', '        }\n', '    }\n', '\n', '    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\n', '        LogEntry memory entry;\n', '        entry.action = action;\n', '        entry.time = now;\n', '        entry.from = from;\n', '        entry.to = to;\n', '        entry.v1 = _v1;\n', '        entry.v2 = _v2;\n', '        entry.v3 = _v3;\n', '        _logs.push(entry);\n', '    }\n', '\n', '    function getLogSize() public view returns(uint256 size){\n', '        size = _logs.length;\n', '    }\n', '\n', '    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\n', '        require(_index < _logs.length);\n', '        require(_index >= 0);\n', '        LogEntry storage entry = _logs[_index];\n', '        action = entry.action;\n', '        time = entry.time;\n', '        from = entry.from;\n', '        to = entry.to;\n', '        _v1 = entry.v1;\n', '        _v2 = entry.v2;\n', '        _v3 = entry.v3;\n', '    }\n', '}']
