['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Statable {\n', '    uint8 public state; // { 0 = pre event , 1 = during event, 2 = post event, 3 = refunding\n', '    modifier requireState(uint8 _state) {\n', '        require(state == _state);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Fighter is Ownable, Statable {\n', '    using SafeMath for uint256;\n', '    uint256 public minBetAmount = 0;\n', '\n', '    string name;\n', '\n', '    constructor(string contractName, uint256 _minBetAmount) public {\n', '        name = contractName;\n', '        minBetAmount = _minBetAmount;\n', '        state = 0;\n', '    }\n', '\n', '    function changeState(uint8 _state) public onlyOwner {\n', '        state = _state;\n', '    }\n', '\n', '    function getAddress() public view returns (address) {\n', '        return address(this);\n', '    }\n', '\n', '    function() public payable requireState(0) {\n', '        require(msg.value >= minBetAmount);\n', '        MasterFighter(address(owner)).addBet(msg.value, msg.sender);\n', '    }\n', '\n', '    function transferMoneyToOwner() public onlyOwner requireState(1) {\n', '        if (address(this).balance > 0) {\n', '            MasterFighter(address(owner)).deposit.value(address(this).balance)();\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract MasterFighter is Ownable, Statable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public percentRake = 5;\n', '    uint256 public constant minBetAmount = 0.01 ether;\n', '\n', '    bool public hasWithdrawnRake = false;\n', '\n', '    address winningFighter;\n', '\n', '    address[] public fighterAddressess;\n', '\n', '    struct Bet {\n', '        uint256 stake;\n', '        bool withdrawn;\n', '    }\n', '\n', '    mapping(address => mapping(address => Bet)) public bets;\n', '    mapping(address => address[]) public bettersForFighter;\n', '    mapping(address => uint256) public totalForFighter;\n', '\n', '    uint256 public amount;\n', '\n', '    event StateChanged(uint8 _state);\n', '    event ReceivedMoney(address _betterAddress, address _fighterAddress, uint256 _stake);\n', '\n', '    function deposit() public payable requireState(1) {\n', '    }\n', '\n', '    constructor() public {\n', '        state = 0;\n', '        addFighter(new Fighter("Khabib", minBetAmount));\n', '        addFighter(new Fighter("McGregor", minBetAmount));\n', '    }\n', '\n', '    function getTotalBettersForFighter(address _address) external view returns (uint256) {\n', '        return bettersForFighter[_address].length;\n', '    }\n', '\n', '    function startEvent() external onlyOwner requireState(0) {\n', '        state = 1;\n', '        for (uint8 i = 0; i < fighterAddressess.length; i++) {\n', '            Fighter(fighterAddressess[i]).changeState(state);\n', '            Fighter(fighterAddressess[i]).transferMoneyToOwner();\n', '        }\n', '        emit StateChanged(state);\n', '    }\n', '\n', '    function refundEverybody() external onlyOwner requireState(1) {\n', '        state = 3;\n', '        emit StateChanged(state);\n', '    }\n', '\n', '    function addFighter(address _address) private requireState(0) {\n', '        fighterAddressess.push(Fighter(_address));\n', '    }\n', '\n', '    function checkValidFighter(address _address) private view returns (bool) {\n', '        for (uint8 i = 0; i < fighterAddressess.length; i++) {\n', '            if (_address == fighterAddressess[i]) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function addBet(uint256 _stake, address _betterAddress) external {\n', '        require(checkValidFighter(msg.sender));\n', '        if (bets[msg.sender][_betterAddress].stake > 0) {\n', '            bets[msg.sender][_betterAddress].stake = bets[msg.sender][_betterAddress].stake.add(_stake);\n', '        } else {\n', '            bettersForFighter[msg.sender].push(_betterAddress);\n', '            bets[msg.sender][_betterAddress] = Bet(_stake, false);\n', '        }\n', '        amount = amount.add(_stake);\n', '        totalForFighter[msg.sender] = totalForFighter[msg.sender].add(_stake);\n', '        emit ReceivedMoney(_betterAddress, msg.sender, _stake);\n', '    }\n', '\n', '    function totalWagered() public constant returns (uint256) {\n', '        return amount;\n', '    }\n', '\n', '    function totalRake() public constant returns (uint256) {\n', '        return totalWagered().mul(percentRake).div(100);\n', '    }\n', '\n', '    function totalPrizePool() public constant returns (uint256) {\n', '        return totalWagered().sub(totalRake());\n', '    }\n', '\n', '    function declareWininingFighter(address _fighterAddress) external onlyOwner requireState(1) {\n', '        require(checkValidFighter(_fighterAddress));\n', '        state = 2;\n', '        winningFighter = _fighterAddress;\n', '        emit StateChanged(state);\n', '    }\n', '\n', '    function withdrawRake() external onlyOwner requireState(2) {\n', '        require(!hasWithdrawnRake);\n', '        hasWithdrawnRake = true;\n', '        owner.transfer(totalRake());\n', '    }\n', '\n', '    function withdraw(address _betterAddress) public requireState(2) {\n', '        require(bets[winningFighter][_betterAddress].stake > 0);\n', '        require(!bets[winningFighter][_betterAddress].withdrawn);\n', '        address(_betterAddress).transfer(totalPrizePool().mul(bets[winningFighter][_betterAddress].stake).div(totalForFighter[winningFighter]));\n', '        bets[winningFighter][_betterAddress].withdrawn = true;\n', '    }\n', '\n', '    function refund(address _betterAddress) external requireState(3) {\n', '        uint256 stake = 0;\n', '        for (uint8 i = 0; i < fighterAddressess.length; i++) {\n', '            if (bets[fighterAddressess[i]][_betterAddress].stake > 0 && !bets[fighterAddressess[i]][_betterAddress].withdrawn) {\n', '                bets[fighterAddressess[i]][_betterAddress].withdrawn = true;\n', '                stake = stake.add(bets[fighterAddressess[i]][_betterAddress].stake);\n', '            }\n', '        }\n', '        if (stake > 0) {\n', '            address(_betterAddress).transfer(stake);\n', '        }\n', '    }\n', '\n', '}']