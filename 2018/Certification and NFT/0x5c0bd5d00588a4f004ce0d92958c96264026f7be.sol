['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract EthPlot is Ownable {\n', '\n', '    /// @dev Represents a single plot (rectangle) which is owned by someone. Additionally, it contains an array\n', '    /// of holes which point to other PlotOwnership structs which overlap this one (and purchased a chunk of this one)\n', '    /// 4 24 bit numbers for + 1 address = 256 bits for storage efficiency\n', '    struct PlotOwnership {\n', '\n', '        // Coordinates of the plot rectangle\n', '        uint24 x;\n', '        uint24 y;\n', '        uint24 w;\n', '        uint24 h;\n', '\n', '        // The owner of the plot\n', '        address owner;\n', '    }\n', '\n', '    /// @dev Represents the data which a specific plot ownership has\n', '    struct PlotData {\n', '        string ipfsHash;\n', '        string url;\n', '    }\n', '\n', '    //----------------------State---------------------//\n', '\n', '    // The actual coordinates and owners of plots. This array will contain all of the owned plots, with the more recent (and valid)\n', '    // ownership plots at the top. The other state variables point to indexes in this array\n', '    PlotOwnership[] private ownership;\n', '\n', '    // Maps from the index in the ownership array to the data for this particular plot (its image and website)\n', '    mapping(uint256 => PlotData) private data;\n', '\n', '    // Maps plot ID to a boolean that represents whether or not\n', '    // the image of the plot might be illegal and need to be blocked\n', '    // in the UI of Eth Plot. Defaults to false.\n', '    mapping (uint256 => bool) private plotBlockedTags;\n', '\n', '    // Maps plot ID to the plot&#39;s current price price. If price is 0, the plot is not for sale. Price is Wei per pixel.\n', '    mapping(uint256 => uint256) private plotIdToPrice;\n', '\n', '    // Maps plot ID to other plots IDs which which have purchased sections of this plot (a hole).\n', '    // Once a plot has been completely re-purchased, these holes will completely tile over the plot.\n', '    mapping(uint256 => uint256[]) private holes;\n', '    \n', '    //----------------------Constants---------------------//\n', '    uint24 constant private GRID_WIDTH = 250;\n', '    uint24 constant private GRID_HEIGHT = 250;\n', '    uint256 constant private INITIAL_PLOT_PRICE = 20000 * 1000000000; // 20000 gwei (approx. $0.01)\n', '\n', '    // This is the maximum area of a single purchase block. This needs to be limited for the\n', '    // algorithm which figures out payment to function\n', '    uint256 constant private MAXIMUM_PURCHASE_AREA = 1000;\n', '      \n', '    //----------------------Events---------------------//\n', '\n', '    /// @notice Inicates that a user has updated the price of their plot\n', '    /// @param plotId The index in the ownership array which was updated\n', '    /// @param newPriceInWeiPerPixel The new price of the plotId\n', '    /// @param owner The current owner of the plot\n', '    event PlotPriceUpdated(uint256 plotId, uint256 newPriceInWeiPerPixel, address indexed owner);\n', '\n', '    /// @notice Indicates that a new plot has been purchased and added to the ownership array\n', '    /// @param newPlotId The id (index in the ownership array) of the new plot\n', '    /// @param totalPrice The total price paid in wei to all the plots which used to own this area\n', '    /// @param buyer The account which made the purchase \n', '    event PlotPurchased(uint256 newPlotId, uint256 totalPrice, address indexed buyer);\n', '\n', '    /// @notice Indicates that a section of a plot was purchased. Multiple PlotSectionSold events could be emitted from\n', '    /// a single purchase transaction\n', '    /// @param plotId The id (index in the ownership array) of the plot which had a section of it purchased\n', '    /// @param totalPrice The total price which was paid for this section\n', '    /// @param buyer The buyer of the section of the plot\n', '    /// @param seller The owner of the plot which was purchased. This is who will receive totalPrice in their account\n', '    event PlotSectionSold(uint256 plotId, uint256 totalPrice, address indexed buyer, address indexed seller);\n', '\n', '    /// @notice Creates a new instance of the EthPlot contract. It assigns an initial ownership plot consisting of the entire grid\n', '    /// to the creator of the contract who will also receive any transaction fees.\n', '    constructor() public payable {\n', '        // Initialize the contract with a single block which the admin owns\n', '        ownership.push(PlotOwnership(0, 0, GRID_WIDTH, GRID_HEIGHT, owner));\n', '        data[0] = PlotData("Qmb51AikiN8p6JsEcCZgrV4d7C6d6uZnCmfmaT15VooUyv/img.svg", "https://www.ethplot.com/");\n', '        plotIdToPrice[0] = INITIAL_PLOT_PRICE;\n', '    }\n', '\n', '    //---------------------- External  and Public Functions ---------------------//\n', '\n', '    /// @notice Purchases a new plot with at the location (`purchase[0]`,`purchase[1]`) and dimensions `purchase[2]`x`purchase[2]`.\n', '    /// The new plot will have the data stored at ipfs hash `ipfsHash` and a website of `url`\n', '    /// @dev This function is the way you purchase new plots from the chain. The data is specified in a somewhat unique format to\n', '    /// make the execution of the contract as efficient as possible. Essentially, the caller needs to send in an array of sub-plots which\n', '    /// form a complete tiling of the purchased area. These sub-plots represent sections of the already existing plots this purchase is\n', '    /// happening on top of. The contract will validate all of this data before allowing the purchase to proceed.\n', '    /// @param purchase An array of exactly 4 values which represent the [x,y,width,height] of the plot to purchase\n', '    /// @param purchasedAreas An array of at least 4 values. Each set of 4 values represents a sub-plot which must be purchased for this\n', '    /// plot to be created. If the new plot to purchase overlaps in a non-rectangle pattern, multiple rectangular sub-plots from that\n', '    /// plot can be specified. The sub-plots must be from existing plots in descending order of that plot&#39;s index\n', '    /// @param areaIndices An area of indices into the ownership array which represent which plot the rectangles in purchasedAreas are\n', '    /// coming from. Must be equal to 1/4 the length of purchasedAreas\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    /// @param initialBuyoutPriceInWeiPerPixel The price per pixel a future buyer would have to pay to purchase an area of this plot.\n', '    /// Set a price of 0 to mark that this plot is not for sale\n', '    function purchaseAreaWithData(\n', '        uint24[] purchase,\n', '        uint24[] purchasedAreas,\n', '        uint256[] areaIndices,\n', '        string ipfsHash,\n', '        string url,\n', '        uint256 initialBuyoutPriceInWeiPerPixel) external payable {\n', '        \n', '        // Validate that all of the data makes sense and is valid, then payout the plot sellers\n', '        uint256 initialPurchasePrice = validatePurchaseAndDistributeFunds(purchase, purchasedAreas, areaIndices);\n', '\n', '        // After we&#39;ve validated that this purchase is valid, actually put the new plot and info in storage locations\n', '        uint256 newPlotIndex = addPlotAndData(purchase, ipfsHash, url, initialBuyoutPriceInWeiPerPixel);\n', '\n', '        // Now that purchase is completed, update plots that have new holes due to this purchase\n', '        for (uint256 i = 0; i < areaIndices.length; i++) {\n', '            holes[areaIndices[i]].push(newPlotIndex);\n', '        }\n', '\n', '        // Finally, emit an event to indicate that this purchase happened\n', '        emit PlotPurchased(newPlotIndex, initialPurchasePrice, msg.sender);\n', '    }\n', '\n', '    /// @notice Updates the price per pixel of a plot which the message sender owns. A price of 0 means the plot is not for sale\n', '    /// @param plotIndex The index in the ownership array which we are updating. msg.sender must be the owner of this plot\n', '    /// @param newPriceInWeiPerPixel The new price of the plot\n', '    function updatePlotPrice(uint256 plotIndex, uint256 newPriceInWeiPerPixel) external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        require(msg.sender == ownership[plotIndex].owner);\n', '\n', '        plotIdToPrice[plotIndex] = newPriceInWeiPerPixel;\n', '        emit PlotPriceUpdated(plotIndex, newPriceInWeiPerPixel, msg.sender);\n', '    }\n', '\n', '    /// @notice Updates the data for a specific plot. This is only allowed by the plot&#39;s owner\n', '    /// @param plotIndex The index in the ownership array which we are updating. msg.sender must be the owner of this plot\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    function updatePlotData(uint256 plotIndex, string ipfsHash, string url) external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        require(msg.sender == ownership[plotIndex].owner);\n', '\n', '        data[plotIndex] = PlotData(ipfsHash, url);\n', '    }\n', '\n', '    // ---------------------- Public Admin Functions ---------------------//\n', '    \n', '    /// @notice Withdraws the fees which have been collected back to the contract owner, who is the only person that can call this\n', '    /// @param transferTo Who the transfer should go to. This must be the admin, but we pass it as a parameter to prevent a frontrunning\n', '    /// issue if we change ownership of the contract.\n', '    function withdraw(address transferTo) onlyOwner external {\n', '        // Prevent https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running\n', '        require(transferTo == owner);\n', '\n', '        uint256 currentBalance = address(this).balance;\n', '        owner.transfer(currentBalance);\n', '    }\n', '\n', '    /// @notice Sets whether or not the image data in a plot should be blocked from the EthPlot UI. This is used to take down\n', '    /// illegal content if needed. The image data is not actually deleted, just no longer visible in the UI\n', '    /// @param plotIndex The index in the ownership array where the illegal data is located\n', '    /// @param plotBlocked Whether or not this data should be blocked\n', '    function togglePlotBlockedTag(uint256 plotIndex, bool plotBlocked) onlyOwner external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        plotBlockedTags[plotIndex] = plotBlocked;\n', '    }\n', '\n', '    // ---------------------- Public View Functions ---------------------//\n', '\n', '    /// @notice Gets the information for a specific plot based on its index.\n', '    /// @dev Due to stack too deep issues, to get all the info about a plot, you must also call getPlotData in conjunction with this\n', '    /// @param plotIndex The index in the ownership array to get the plot info for\n', '    /// @return The coordinates of this plot, the owner address, and the current buyout price of it (0 if not for sale)\n', '    function getPlotInfo(uint256 plotIndex) public view returns (uint24 x, uint24 y, uint24 w , uint24 h, address owner, uint256 price) {\n', '        require(plotIndex < ownership.length);\n', '        return (\n', '            ownership[plotIndex].x,\n', '            ownership[plotIndex].y,\n', '            ownership[plotIndex].w,\n', '            ownership[plotIndex].h,\n', '            ownership[plotIndex].owner,\n', '            plotIdToPrice[plotIndex]);\n', '    }\n', '\n', '    /// @notice Gets the data stored with a specific plot. This includes the website, ipfs hash, and the blocked status of the image\n', '    /// @dev Due to stack too deep issues, to get all the info about a plot, you must also call getPlotInfo in conjunction with this\n', '    /// @param plotIndex The index in the ownership array to get the plot data for\n', '    /// @return The ipfsHash of the plot&#39;s image, the website associated with the plot, and whether or not its image is blocked\n', '    function getPlotData(uint256 plotIndex) public view returns (string ipfsHash, string url, bool plotBlocked) {\n', '        require(plotIndex < ownership.length);\n', '        return (data[plotIndex].url, data[plotIndex].ipfsHash, plotBlockedTags[plotIndex]);\n', '    }\n', '    \n', '    /// @notice Gets the length of the ownership array which represents the number of owned plots which exist\n', '    /// @return The number of plots which are owned on the grid\n', '    function ownershipLength() public view returns (uint256) {\n', '        return ownership.length;\n', '    }\n', '    \n', '    //---------------------- Private Functions ---------------------//\n', '\n', '    /// @notice This function does a lot of the heavy lifting for validating that all of the data passed in to the purchase function is ok.\n', '    /// @dev It works by first validating all of the inputs and converting purchase and purchasedAreas into rectangles for easier manipulation.\n', '    /// Next, it validates that all of the rectangles in purchasedArea are within the area to purchase, and that they form a complete tiling of\n', '    /// the purchase we are making with zero overlap. Next, to prevent stack too deep errors, it delegates the work of validating that these sub-plots\n', '    /// are actually for sale, are valid, and pays out the previous owners of the area.\n', '    /// @param purchase An array of exactly 4 values which represent the [x,y,width,height] of the plot to purchase\n', '    /// @param purchasedAreas An array of at least 4 values. Each set of 4 values represents a sub-plot which must be purchased for this\n', '    /// plot to be created.\n', '    /// @param areaIndices An area of indices into the ownership array which represent which plot the rectangles in purchasedAreas are from\n', '    /// @return The amount spent to purchase all of the subplots specified in purchasedAreas\n', '    function validatePurchaseAndDistributeFunds(uint24[] purchase, uint24[] purchasedAreas, uint256[] areaIndices) private returns (uint256) {\n', '        // Validate that we were given a valid area to purchase\n', '        require(purchase.length == 4);\n', '        Geometry.Rect memory plotToPurchase = Geometry.Rect(purchase[0], purchase[1], purchase[2], purchase[3]);\n', '        \n', '        require(plotToPurchase.x < GRID_WIDTH && plotToPurchase.x >= 0);\n', '        require(plotToPurchase.y < GRID_HEIGHT && plotToPurchase.y >= 0);\n', '\n', '        // No need for SafeMath here because we know plotToPurchase.x & plotToPurchase.y are less than 250 (~2^8)\n', '        require(plotToPurchase.w > 0 && plotToPurchase.w + plotToPurchase.x <= GRID_WIDTH);\n', '        require(plotToPurchase.h > 0 && plotToPurchase.h + plotToPurchase.y <= GRID_HEIGHT);\n', '        require(plotToPurchase.w * plotToPurchase.h < MAXIMUM_PURCHASE_AREA);\n', '\n', '        // Validate the purchasedAreas and the purchasedArea&#39;s indices\n', '        require(purchasedAreas.length >= 4);\n', '        require(areaIndices.length > 0);\n', '        require(purchasedAreas.length % 4 == 0);\n', '        require(purchasedAreas.length / 4 == areaIndices.length);\n', '\n', '        // Build up an array of subPlots which represent all of the sub-plots we are purchasing\n', '        Geometry.Rect[] memory subPlots = new Geometry.Rect[](areaIndices.length);\n', '\n', '        uint256 totalArea = 0;\n', '        uint256 i = 0;\n', '        uint256 j = 0;\n', '        for (i = 0; i < areaIndices.length; i++) {\n', '            // Define the rectangle and add it to our collection of them\n', '            Geometry.Rect memory rect = Geometry.Rect(\n', '                purchasedAreas[(i * 4)], purchasedAreas[(i * 4) + 1], purchasedAreas[(i * 4) + 2], purchasedAreas[(i * 4) + 3]);\n', '            subPlots[i] = rect;\n', '\n', '            require(rect.w > 0);\n', '            require(rect.h > 0);\n', '\n', '            // Compute the area of this rect and add it to the total area\n', '            totalArea = SafeMath.add(totalArea, SafeMath.mul(rect.w,rect.h));\n', '\n', '            // Verify that this rectangle is within the bounds of the area we are trying to purchase\n', '            require(Geometry.rectContainedInside(rect, plotToPurchase));\n', '        }\n', '\n', '        require(totalArea == plotToPurchase.w * plotToPurchase.h);\n', '\n', '        // Next, make sure all of these do not overlap\n', '        for (i = 0; i < subPlots.length; i++) {\n', '            for (j = i + 1; j < subPlots.length; j++) {\n', '                require(!Geometry.doRectanglesOverlap(subPlots[i], subPlots[j]));\n', '            }\n', '        }\n', '\n', '        // If we have a matching area, the subPlots are all contained within what we&#39;re purchasing, and none of them overlap,\n', '        // we know we have a complete tiling of the plotToPurchase. Next, validate we can purchase all of these and distribute funds\n', '        uint256 remainingBalance = checkHolesAndDistributePurchaseFunds(subPlots, areaIndices);\n', '        uint256 purchasePrice = SafeMath.sub(msg.value, remainingBalance);\n', '        return purchasePrice;\n', '    }\n', '\n', '    /// @notice Checks that the sub-plots which we are purchasing are all valid and then distributes funds to the owners of those sub-plots\n', '    /// @dev Since we know that the subPlots are contained within plotToPurchase, and that they don&#39;t overlap, we just need go through each one\n', '    /// and make sure that it is for sale and owned by the appropriate person as specified in areaIndices. We then can calculate how much to\n', '    /// pay out for the sub-plot as well.\n', '    /// @param subPlots Array of sub-plots which tiles the plotToPurchase completely\n', '    /// @param areaIndices Array of indices into the ownership array which correspond to who owns the subPlot at the same index of subPlots.\n', '    /// The array must be the same length as subPlots and go in descending order\n', '    /// @return The balance still remaining from the original msg.value after paying out all of the owners of the subPlots\n', '    function checkHolesAndDistributePurchaseFunds(Geometry.Rect[] memory subPlots, uint256[] memory areaIndices) private returns (uint256) {\n', '\n', '        // Initialize the remaining balance to the value which was passed in here\n', '        uint256 remainingBalance = msg.value;\n', '\n', '        // In order to minimize calls to transfer(), aggregate how much is owed to a single plot owner for all of their subPlots (this is \n', '        // useful in the case that the buyer is overlaping with a single plot in a non-rectangular manner)\n', '        uint256 owedToSeller = 0;\n', '\n', '        for (uint256 areaIndicesIndex = 0; areaIndicesIndex < areaIndices.length; areaIndicesIndex++) {\n', '\n', '            // Get information about the plot at this index\n', '            uint256 ownershipIndex = areaIndices[areaIndicesIndex];\n', '            Geometry.Rect memory currentOwnershipRect = Geometry.Rect(\n', '                ownership[ownershipIndex].x, ownership[ownershipIndex].y, ownership[ownershipIndex].w, ownership[ownershipIndex].h);\n', '\n', '            // This is a plot the caller has declared they were going to buy. We need to verify that the subPlot is fully contained inside \n', '            // the current ownership plot we are dealing with (we already know the subPlot is inside the plot to purchase)\n', '            require(Geometry.rectContainedInside(subPlots[areaIndicesIndex], currentOwnershipRect));\n', '\n', '            // Next, verify that none of the holes of this plot ownership overlap with what we are trying to purchase\n', '            for (uint256 holeIndex = 0; holeIndex < holes[ownershipIndex].length; holeIndex++) {\n', '                PlotOwnership memory holePlot = ownership[holes[ownershipIndex][holeIndex]];\n', '                Geometry.Rect memory holeRect = Geometry.Rect(holePlot.x, holePlot.y, holePlot.w, holePlot.h);\n', '\n', '                require(!Geometry.doRectanglesOverlap(subPlots[areaIndicesIndex], holeRect));\n', '            }\n', '\n', '            // Finally, add the price of this rect to the totalPrice computation\n', '            uint256 sectionPrice = getPriceOfPlot(subPlots[areaIndicesIndex], ownershipIndex);\n', '            remainingBalance = SafeMath.sub(remainingBalance, sectionPrice);\n', '            owedToSeller = SafeMath.add(owedToSeller, sectionPrice);\n', '\n', '            // If this is the last one to look at, or if the next ownership index is different, payout this owner\n', '            if (areaIndicesIndex == areaIndices.length - 1 || ownershipIndex != areaIndices[areaIndicesIndex + 1]) {\n', '\n', '                // Update the balances and emit an event to indicate the chunks of this plot which were sold\n', '                address(ownership[ownershipIndex].owner).transfer(owedToSeller);\n', '                emit PlotSectionSold(ownershipIndex, owedToSeller, msg.sender, ownership[ownershipIndex].owner);\n', '                owedToSeller = 0;\n', '            }\n', '        }\n', '        \n', '        return remainingBalance;\n', '    }\n', '\n', '    /// @notice Given a rect to purchase and the plot index, return the total price to be paid. Requires that the plot is for sale\n', '    /// @param subPlotToPurchase The subplot of plotIndex which we want to compute the price of\n', '    /// @param plotIndex The index in the ownership array for this plot\n', '    /// @return The price that must be paid for this subPlot\n', '    function getPriceOfPlot(Geometry.Rect memory subPlotToPurchase, uint256 plotIndex) private view returns (uint256) {\n', '\n', '        // Verify that this plot exists in the plot price mapping with a price.\n', '        uint256 plotPricePerPixel = plotIdToPrice[plotIndex];\n', '        require(plotPricePerPixel > 0);\n', '\n', '        return SafeMath.mul(SafeMath.mul(subPlotToPurchase.w, subPlotToPurchase.h), plotPricePerPixel);\n', '    }\n', '\n', '    /// @notice Stores the plot information and data for a newly purchased plot.\n', '    /// @dev All parameters are assumed to be validated before calling\n', '    /// @param purchase The coordinates of the plot to purchase\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    /// @param initialBuyoutPriceInWeiPerPixel The price per pixel a future buyer would have to pay to purchase an area of this plot.\n', '    /// @return The index in the plotOwnership array where this plot was placed\n', '    function addPlotAndData(uint24[] purchase, string ipfsHash, string url, uint256 initialBuyoutPriceInWeiPerPixel) private returns (uint256) {\n', '        uint256 newPlotIndex = ownership.length;\n', '\n', '        // Add the new ownership to the array\n', '        ownership.push(PlotOwnership(purchase[0], purchase[1], purchase[2], purchase[3], msg.sender));\n', '\n', '        // Take in the input data for the actual grid!\n', '        data[newPlotIndex] = PlotData(ipfsHash, url);\n', '\n', '        // Set an initial purchase price for the new plot if it&#39;s greater than 0\n', '        if (initialBuyoutPriceInWeiPerPixel > 0) {\n', '            plotIdToPrice[newPlotIndex] = initialBuyoutPriceInWeiPerPixel;\n', '        }\n', '\n', '        return newPlotIndex;\n', '    }\n', '}\n', '\n', 'library Geometry {\n', '    struct Rect {\n', '        uint24 x;\n', '        uint24 y;\n', '        uint24 w;\n', '        uint24 h;\n', '    }\n', '\n', '    function doRectanglesOverlap(Rect memory a, Rect memory b) internal pure returns (bool) {\n', '        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;\n', '    }\n', '\n', '    // It is assumed that we will have called doRectanglesOverlap before calling this method and we will know they overlap\n', '    function computeRectOverlap(Rect memory a, Rect memory b) internal pure returns (Rect memory) {\n', '        Rect memory result = Rect(0, 0, 0, 0);\n', '\n', '        // Take the greater of the x and y values;\n', '        result.x = a.x > b.x ? a.x : b.x;\n', '        result.y = a.y > b.y ? a.y : b.y;\n', '\n', '        // Take the lesser of the x2 and y2 values\n', '        uint24 resultX2 = a.x + a.w < b.x + b.w ? a.x + a.w : b.x + b.w;\n', '        uint24 resultY2 = a.y + a.h < b.y + b.h ? a.y + a.h : b.y + b.h;\n', '\n', '        // Set our width and height here\n', '        result.w = resultX2 - result.x;\n', '        result.h = resultY2 - result.y;\n', '\n', '        return result;\n', '    }\n', '\n', '    function rectContainedInside(Rect memory inner, Rect memory outer) internal pure returns (bool) {\n', '        return inner.x >= outer.x && inner.y >= outer.y && inner.x + inner.w <= outer.x + outer.w && inner.y + inner.h <= outer.y + outer.h;\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract EthPlot is Ownable {\n', '\n', '    /// @dev Represents a single plot (rectangle) which is owned by someone. Additionally, it contains an array\n', '    /// of holes which point to other PlotOwnership structs which overlap this one (and purchased a chunk of this one)\n', '    /// 4 24 bit numbers for + 1 address = 256 bits for storage efficiency\n', '    struct PlotOwnership {\n', '\n', '        // Coordinates of the plot rectangle\n', '        uint24 x;\n', '        uint24 y;\n', '        uint24 w;\n', '        uint24 h;\n', '\n', '        // The owner of the plot\n', '        address owner;\n', '    }\n', '\n', '    /// @dev Represents the data which a specific plot ownership has\n', '    struct PlotData {\n', '        string ipfsHash;\n', '        string url;\n', '    }\n', '\n', '    //----------------------State---------------------//\n', '\n', '    // The actual coordinates and owners of plots. This array will contain all of the owned plots, with the more recent (and valid)\n', '    // ownership plots at the top. The other state variables point to indexes in this array\n', '    PlotOwnership[] private ownership;\n', '\n', '    // Maps from the index in the ownership array to the data for this particular plot (its image and website)\n', '    mapping(uint256 => PlotData) private data;\n', '\n', '    // Maps plot ID to a boolean that represents whether or not\n', '    // the image of the plot might be illegal and need to be blocked\n', '    // in the UI of Eth Plot. Defaults to false.\n', '    mapping (uint256 => bool) private plotBlockedTags;\n', '\n', "    // Maps plot ID to the plot's current price price. If price is 0, the plot is not for sale. Price is Wei per pixel.\n", '    mapping(uint256 => uint256) private plotIdToPrice;\n', '\n', '    // Maps plot ID to other plots IDs which which have purchased sections of this plot (a hole).\n', '    // Once a plot has been completely re-purchased, these holes will completely tile over the plot.\n', '    mapping(uint256 => uint256[]) private holes;\n', '    \n', '    //----------------------Constants---------------------//\n', '    uint24 constant private GRID_WIDTH = 250;\n', '    uint24 constant private GRID_HEIGHT = 250;\n', '    uint256 constant private INITIAL_PLOT_PRICE = 20000 * 1000000000; // 20000 gwei (approx. $0.01)\n', '\n', '    // This is the maximum area of a single purchase block. This needs to be limited for the\n', '    // algorithm which figures out payment to function\n', '    uint256 constant private MAXIMUM_PURCHASE_AREA = 1000;\n', '      \n', '    //----------------------Events---------------------//\n', '\n', '    /// @notice Inicates that a user has updated the price of their plot\n', '    /// @param plotId The index in the ownership array which was updated\n', '    /// @param newPriceInWeiPerPixel The new price of the plotId\n', '    /// @param owner The current owner of the plot\n', '    event PlotPriceUpdated(uint256 plotId, uint256 newPriceInWeiPerPixel, address indexed owner);\n', '\n', '    /// @notice Indicates that a new plot has been purchased and added to the ownership array\n', '    /// @param newPlotId The id (index in the ownership array) of the new plot\n', '    /// @param totalPrice The total price paid in wei to all the plots which used to own this area\n', '    /// @param buyer The account which made the purchase \n', '    event PlotPurchased(uint256 newPlotId, uint256 totalPrice, address indexed buyer);\n', '\n', '    /// @notice Indicates that a section of a plot was purchased. Multiple PlotSectionSold events could be emitted from\n', '    /// a single purchase transaction\n', '    /// @param plotId The id (index in the ownership array) of the plot which had a section of it purchased\n', '    /// @param totalPrice The total price which was paid for this section\n', '    /// @param buyer The buyer of the section of the plot\n', '    /// @param seller The owner of the plot which was purchased. This is who will receive totalPrice in their account\n', '    event PlotSectionSold(uint256 plotId, uint256 totalPrice, address indexed buyer, address indexed seller);\n', '\n', '    /// @notice Creates a new instance of the EthPlot contract. It assigns an initial ownership plot consisting of the entire grid\n', '    /// to the creator of the contract who will also receive any transaction fees.\n', '    constructor() public payable {\n', '        // Initialize the contract with a single block which the admin owns\n', '        ownership.push(PlotOwnership(0, 0, GRID_WIDTH, GRID_HEIGHT, owner));\n', '        data[0] = PlotData("Qmb51AikiN8p6JsEcCZgrV4d7C6d6uZnCmfmaT15VooUyv/img.svg", "https://www.ethplot.com/");\n', '        plotIdToPrice[0] = INITIAL_PLOT_PRICE;\n', '    }\n', '\n', '    //---------------------- External  and Public Functions ---------------------//\n', '\n', '    /// @notice Purchases a new plot with at the location (`purchase[0]`,`purchase[1]`) and dimensions `purchase[2]`x`purchase[2]`.\n', '    /// The new plot will have the data stored at ipfs hash `ipfsHash` and a website of `url`\n', '    /// @dev This function is the way you purchase new plots from the chain. The data is specified in a somewhat unique format to\n', '    /// make the execution of the contract as efficient as possible. Essentially, the caller needs to send in an array of sub-plots which\n', '    /// form a complete tiling of the purchased area. These sub-plots represent sections of the already existing plots this purchase is\n', '    /// happening on top of. The contract will validate all of this data before allowing the purchase to proceed.\n', '    /// @param purchase An array of exactly 4 values which represent the [x,y,width,height] of the plot to purchase\n', '    /// @param purchasedAreas An array of at least 4 values. Each set of 4 values represents a sub-plot which must be purchased for this\n', '    /// plot to be created. If the new plot to purchase overlaps in a non-rectangle pattern, multiple rectangular sub-plots from that\n', "    /// plot can be specified. The sub-plots must be from existing plots in descending order of that plot's index\n", '    /// @param areaIndices An area of indices into the ownership array which represent which plot the rectangles in purchasedAreas are\n', '    /// coming from. Must be equal to 1/4 the length of purchasedAreas\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    /// @param initialBuyoutPriceInWeiPerPixel The price per pixel a future buyer would have to pay to purchase an area of this plot.\n', '    /// Set a price of 0 to mark that this plot is not for sale\n', '    function purchaseAreaWithData(\n', '        uint24[] purchase,\n', '        uint24[] purchasedAreas,\n', '        uint256[] areaIndices,\n', '        string ipfsHash,\n', '        string url,\n', '        uint256 initialBuyoutPriceInWeiPerPixel) external payable {\n', '        \n', '        // Validate that all of the data makes sense and is valid, then payout the plot sellers\n', '        uint256 initialPurchasePrice = validatePurchaseAndDistributeFunds(purchase, purchasedAreas, areaIndices);\n', '\n', "        // After we've validated that this purchase is valid, actually put the new plot and info in storage locations\n", '        uint256 newPlotIndex = addPlotAndData(purchase, ipfsHash, url, initialBuyoutPriceInWeiPerPixel);\n', '\n', '        // Now that purchase is completed, update plots that have new holes due to this purchase\n', '        for (uint256 i = 0; i < areaIndices.length; i++) {\n', '            holes[areaIndices[i]].push(newPlotIndex);\n', '        }\n', '\n', '        // Finally, emit an event to indicate that this purchase happened\n', '        emit PlotPurchased(newPlotIndex, initialPurchasePrice, msg.sender);\n', '    }\n', '\n', '    /// @notice Updates the price per pixel of a plot which the message sender owns. A price of 0 means the plot is not for sale\n', '    /// @param plotIndex The index in the ownership array which we are updating. msg.sender must be the owner of this plot\n', '    /// @param newPriceInWeiPerPixel The new price of the plot\n', '    function updatePlotPrice(uint256 plotIndex, uint256 newPriceInWeiPerPixel) external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        require(msg.sender == ownership[plotIndex].owner);\n', '\n', '        plotIdToPrice[plotIndex] = newPriceInWeiPerPixel;\n', '        emit PlotPriceUpdated(plotIndex, newPriceInWeiPerPixel, msg.sender);\n', '    }\n', '\n', "    /// @notice Updates the data for a specific plot. This is only allowed by the plot's owner\n", '    /// @param plotIndex The index in the ownership array which we are updating. msg.sender must be the owner of this plot\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    function updatePlotData(uint256 plotIndex, string ipfsHash, string url) external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        require(msg.sender == ownership[plotIndex].owner);\n', '\n', '        data[plotIndex] = PlotData(ipfsHash, url);\n', '    }\n', '\n', '    // ---------------------- Public Admin Functions ---------------------//\n', '    \n', '    /// @notice Withdraws the fees which have been collected back to the contract owner, who is the only person that can call this\n', '    /// @param transferTo Who the transfer should go to. This must be the admin, but we pass it as a parameter to prevent a frontrunning\n', '    /// issue if we change ownership of the contract.\n', '    function withdraw(address transferTo) onlyOwner external {\n', '        // Prevent https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running\n', '        require(transferTo == owner);\n', '\n', '        uint256 currentBalance = address(this).balance;\n', '        owner.transfer(currentBalance);\n', '    }\n', '\n', '    /// @notice Sets whether or not the image data in a plot should be blocked from the EthPlot UI. This is used to take down\n', '    /// illegal content if needed. The image data is not actually deleted, just no longer visible in the UI\n', '    /// @param plotIndex The index in the ownership array where the illegal data is located\n', '    /// @param plotBlocked Whether or not this data should be blocked\n', '    function togglePlotBlockedTag(uint256 plotIndex, bool plotBlocked) onlyOwner external {\n', '        require(plotIndex >= 0);\n', '        require(plotIndex < ownership.length);\n', '        plotBlockedTags[plotIndex] = plotBlocked;\n', '    }\n', '\n', '    // ---------------------- Public View Functions ---------------------//\n', '\n', '    /// @notice Gets the information for a specific plot based on its index.\n', '    /// @dev Due to stack too deep issues, to get all the info about a plot, you must also call getPlotData in conjunction with this\n', '    /// @param plotIndex The index in the ownership array to get the plot info for\n', '    /// @return The coordinates of this plot, the owner address, and the current buyout price of it (0 if not for sale)\n', '    function getPlotInfo(uint256 plotIndex) public view returns (uint24 x, uint24 y, uint24 w , uint24 h, address owner, uint256 price) {\n', '        require(plotIndex < ownership.length);\n', '        return (\n', '            ownership[plotIndex].x,\n', '            ownership[plotIndex].y,\n', '            ownership[plotIndex].w,\n', '            ownership[plotIndex].h,\n', '            ownership[plotIndex].owner,\n', '            plotIdToPrice[plotIndex]);\n', '    }\n', '\n', '    /// @notice Gets the data stored with a specific plot. This includes the website, ipfs hash, and the blocked status of the image\n', '    /// @dev Due to stack too deep issues, to get all the info about a plot, you must also call getPlotInfo in conjunction with this\n', '    /// @param plotIndex The index in the ownership array to get the plot data for\n', "    /// @return The ipfsHash of the plot's image, the website associated with the plot, and whether or not its image is blocked\n", '    function getPlotData(uint256 plotIndex) public view returns (string ipfsHash, string url, bool plotBlocked) {\n', '        require(plotIndex < ownership.length);\n', '        return (data[plotIndex].url, data[plotIndex].ipfsHash, plotBlockedTags[plotIndex]);\n', '    }\n', '    \n', '    /// @notice Gets the length of the ownership array which represents the number of owned plots which exist\n', '    /// @return The number of plots which are owned on the grid\n', '    function ownershipLength() public view returns (uint256) {\n', '        return ownership.length;\n', '    }\n', '    \n', '    //---------------------- Private Functions ---------------------//\n', '\n', '    /// @notice This function does a lot of the heavy lifting for validating that all of the data passed in to the purchase function is ok.\n', '    /// @dev It works by first validating all of the inputs and converting purchase and purchasedAreas into rectangles for easier manipulation.\n', '    /// Next, it validates that all of the rectangles in purchasedArea are within the area to purchase, and that they form a complete tiling of\n', '    /// the purchase we are making with zero overlap. Next, to prevent stack too deep errors, it delegates the work of validating that these sub-plots\n', '    /// are actually for sale, are valid, and pays out the previous owners of the area.\n', '    /// @param purchase An array of exactly 4 values which represent the [x,y,width,height] of the plot to purchase\n', '    /// @param purchasedAreas An array of at least 4 values. Each set of 4 values represents a sub-plot which must be purchased for this\n', '    /// plot to be created.\n', '    /// @param areaIndices An area of indices into the ownership array which represent which plot the rectangles in purchasedAreas are from\n', '    /// @return The amount spent to purchase all of the subplots specified in purchasedAreas\n', '    function validatePurchaseAndDistributeFunds(uint24[] purchase, uint24[] purchasedAreas, uint256[] areaIndices) private returns (uint256) {\n', '        // Validate that we were given a valid area to purchase\n', '        require(purchase.length == 4);\n', '        Geometry.Rect memory plotToPurchase = Geometry.Rect(purchase[0], purchase[1], purchase[2], purchase[3]);\n', '        \n', '        require(plotToPurchase.x < GRID_WIDTH && plotToPurchase.x >= 0);\n', '        require(plotToPurchase.y < GRID_HEIGHT && plotToPurchase.y >= 0);\n', '\n', '        // No need for SafeMath here because we know plotToPurchase.x & plotToPurchase.y are less than 250 (~2^8)\n', '        require(plotToPurchase.w > 0 && plotToPurchase.w + plotToPurchase.x <= GRID_WIDTH);\n', '        require(plotToPurchase.h > 0 && plotToPurchase.h + plotToPurchase.y <= GRID_HEIGHT);\n', '        require(plotToPurchase.w * plotToPurchase.h < MAXIMUM_PURCHASE_AREA);\n', '\n', "        // Validate the purchasedAreas and the purchasedArea's indices\n", '        require(purchasedAreas.length >= 4);\n', '        require(areaIndices.length > 0);\n', '        require(purchasedAreas.length % 4 == 0);\n', '        require(purchasedAreas.length / 4 == areaIndices.length);\n', '\n', '        // Build up an array of subPlots which represent all of the sub-plots we are purchasing\n', '        Geometry.Rect[] memory subPlots = new Geometry.Rect[](areaIndices.length);\n', '\n', '        uint256 totalArea = 0;\n', '        uint256 i = 0;\n', '        uint256 j = 0;\n', '        for (i = 0; i < areaIndices.length; i++) {\n', '            // Define the rectangle and add it to our collection of them\n', '            Geometry.Rect memory rect = Geometry.Rect(\n', '                purchasedAreas[(i * 4)], purchasedAreas[(i * 4) + 1], purchasedAreas[(i * 4) + 2], purchasedAreas[(i * 4) + 3]);\n', '            subPlots[i] = rect;\n', '\n', '            require(rect.w > 0);\n', '            require(rect.h > 0);\n', '\n', '            // Compute the area of this rect and add it to the total area\n', '            totalArea = SafeMath.add(totalArea, SafeMath.mul(rect.w,rect.h));\n', '\n', '            // Verify that this rectangle is within the bounds of the area we are trying to purchase\n', '            require(Geometry.rectContainedInside(rect, plotToPurchase));\n', '        }\n', '\n', '        require(totalArea == plotToPurchase.w * plotToPurchase.h);\n', '\n', '        // Next, make sure all of these do not overlap\n', '        for (i = 0; i < subPlots.length; i++) {\n', '            for (j = i + 1; j < subPlots.length; j++) {\n', '                require(!Geometry.doRectanglesOverlap(subPlots[i], subPlots[j]));\n', '            }\n', '        }\n', '\n', "        // If we have a matching area, the subPlots are all contained within what we're purchasing, and none of them overlap,\n", '        // we know we have a complete tiling of the plotToPurchase. Next, validate we can purchase all of these and distribute funds\n', '        uint256 remainingBalance = checkHolesAndDistributePurchaseFunds(subPlots, areaIndices);\n', '        uint256 purchasePrice = SafeMath.sub(msg.value, remainingBalance);\n', '        return purchasePrice;\n', '    }\n', '\n', '    /// @notice Checks that the sub-plots which we are purchasing are all valid and then distributes funds to the owners of those sub-plots\n', "    /// @dev Since we know that the subPlots are contained within plotToPurchase, and that they don't overlap, we just need go through each one\n", '    /// and make sure that it is for sale and owned by the appropriate person as specified in areaIndices. We then can calculate how much to\n', '    /// pay out for the sub-plot as well.\n', '    /// @param subPlots Array of sub-plots which tiles the plotToPurchase completely\n', '    /// @param areaIndices Array of indices into the ownership array which correspond to who owns the subPlot at the same index of subPlots.\n', '    /// The array must be the same length as subPlots and go in descending order\n', '    /// @return The balance still remaining from the original msg.value after paying out all of the owners of the subPlots\n', '    function checkHolesAndDistributePurchaseFunds(Geometry.Rect[] memory subPlots, uint256[] memory areaIndices) private returns (uint256) {\n', '\n', '        // Initialize the remaining balance to the value which was passed in here\n', '        uint256 remainingBalance = msg.value;\n', '\n', '        // In order to minimize calls to transfer(), aggregate how much is owed to a single plot owner for all of their subPlots (this is \n', '        // useful in the case that the buyer is overlaping with a single plot in a non-rectangular manner)\n', '        uint256 owedToSeller = 0;\n', '\n', '        for (uint256 areaIndicesIndex = 0; areaIndicesIndex < areaIndices.length; areaIndicesIndex++) {\n', '\n', '            // Get information about the plot at this index\n', '            uint256 ownershipIndex = areaIndices[areaIndicesIndex];\n', '            Geometry.Rect memory currentOwnershipRect = Geometry.Rect(\n', '                ownership[ownershipIndex].x, ownership[ownershipIndex].y, ownership[ownershipIndex].w, ownership[ownershipIndex].h);\n', '\n', '            // This is a plot the caller has declared they were going to buy. We need to verify that the subPlot is fully contained inside \n', '            // the current ownership plot we are dealing with (we already know the subPlot is inside the plot to purchase)\n', '            require(Geometry.rectContainedInside(subPlots[areaIndicesIndex], currentOwnershipRect));\n', '\n', '            // Next, verify that none of the holes of this plot ownership overlap with what we are trying to purchase\n', '            for (uint256 holeIndex = 0; holeIndex < holes[ownershipIndex].length; holeIndex++) {\n', '                PlotOwnership memory holePlot = ownership[holes[ownershipIndex][holeIndex]];\n', '                Geometry.Rect memory holeRect = Geometry.Rect(holePlot.x, holePlot.y, holePlot.w, holePlot.h);\n', '\n', '                require(!Geometry.doRectanglesOverlap(subPlots[areaIndicesIndex], holeRect));\n', '            }\n', '\n', '            // Finally, add the price of this rect to the totalPrice computation\n', '            uint256 sectionPrice = getPriceOfPlot(subPlots[areaIndicesIndex], ownershipIndex);\n', '            remainingBalance = SafeMath.sub(remainingBalance, sectionPrice);\n', '            owedToSeller = SafeMath.add(owedToSeller, sectionPrice);\n', '\n', '            // If this is the last one to look at, or if the next ownership index is different, payout this owner\n', '            if (areaIndicesIndex == areaIndices.length - 1 || ownershipIndex != areaIndices[areaIndicesIndex + 1]) {\n', '\n', '                // Update the balances and emit an event to indicate the chunks of this plot which were sold\n', '                address(ownership[ownershipIndex].owner).transfer(owedToSeller);\n', '                emit PlotSectionSold(ownershipIndex, owedToSeller, msg.sender, ownership[ownershipIndex].owner);\n', '                owedToSeller = 0;\n', '            }\n', '        }\n', '        \n', '        return remainingBalance;\n', '    }\n', '\n', '    /// @notice Given a rect to purchase and the plot index, return the total price to be paid. Requires that the plot is for sale\n', '    /// @param subPlotToPurchase The subplot of plotIndex which we want to compute the price of\n', '    /// @param plotIndex The index in the ownership array for this plot\n', '    /// @return The price that must be paid for this subPlot\n', '    function getPriceOfPlot(Geometry.Rect memory subPlotToPurchase, uint256 plotIndex) private view returns (uint256) {\n', '\n', '        // Verify that this plot exists in the plot price mapping with a price.\n', '        uint256 plotPricePerPixel = plotIdToPrice[plotIndex];\n', '        require(plotPricePerPixel > 0);\n', '\n', '        return SafeMath.mul(SafeMath.mul(subPlotToPurchase.w, subPlotToPurchase.h), plotPricePerPixel);\n', '    }\n', '\n', '    /// @notice Stores the plot information and data for a newly purchased plot.\n', '    /// @dev All parameters are assumed to be validated before calling\n', '    /// @param purchase The coordinates of the plot to purchase\n', '    /// @param ipfsHash The hash of the image data for this plot stored in ipfs\n', '    /// @param url The website / url which should be associated with this plot\n', '    /// @param initialBuyoutPriceInWeiPerPixel The price per pixel a future buyer would have to pay to purchase an area of this plot.\n', '    /// @return The index in the plotOwnership array where this plot was placed\n', '    function addPlotAndData(uint24[] purchase, string ipfsHash, string url, uint256 initialBuyoutPriceInWeiPerPixel) private returns (uint256) {\n', '        uint256 newPlotIndex = ownership.length;\n', '\n', '        // Add the new ownership to the array\n', '        ownership.push(PlotOwnership(purchase[0], purchase[1], purchase[2], purchase[3], msg.sender));\n', '\n', '        // Take in the input data for the actual grid!\n', '        data[newPlotIndex] = PlotData(ipfsHash, url);\n', '\n', "        // Set an initial purchase price for the new plot if it's greater than 0\n", '        if (initialBuyoutPriceInWeiPerPixel > 0) {\n', '            plotIdToPrice[newPlotIndex] = initialBuyoutPriceInWeiPerPixel;\n', '        }\n', '\n', '        return newPlotIndex;\n', '    }\n', '}\n', '\n', 'library Geometry {\n', '    struct Rect {\n', '        uint24 x;\n', '        uint24 y;\n', '        uint24 w;\n', '        uint24 h;\n', '    }\n', '\n', '    function doRectanglesOverlap(Rect memory a, Rect memory b) internal pure returns (bool) {\n', '        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;\n', '    }\n', '\n', '    // It is assumed that we will have called doRectanglesOverlap before calling this method and we will know they overlap\n', '    function computeRectOverlap(Rect memory a, Rect memory b) internal pure returns (Rect memory) {\n', '        Rect memory result = Rect(0, 0, 0, 0);\n', '\n', '        // Take the greater of the x and y values;\n', '        result.x = a.x > b.x ? a.x : b.x;\n', '        result.y = a.y > b.y ? a.y : b.y;\n', '\n', '        // Take the lesser of the x2 and y2 values\n', '        uint24 resultX2 = a.x + a.w < b.x + b.w ? a.x + a.w : b.x + b.w;\n', '        uint24 resultY2 = a.y + a.h < b.y + b.h ? a.y + a.h : b.y + b.h;\n', '\n', '        // Set our width and height here\n', '        result.w = resultX2 - result.x;\n', '        result.h = resultY2 - result.y;\n', '\n', '        return result;\n', '    }\n', '\n', '    function rectContainedInside(Rect memory inner, Rect memory outer) internal pure returns (bool) {\n', '        return inner.x >= outer.x && inner.y >= outer.y && inner.x + inner.w <= outer.x + outer.w && inner.y + inner.h <= outer.y + outer.h;\n', '    }\n', '}']
