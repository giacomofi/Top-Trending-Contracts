['pragma solidity ^0.4.24;\n', '\n', '// This contract is heavily inspired by uPort from https://github.com/uport-project/uport-identity/blob/develop/contracts/TxRelay.sol\n', 'contract TxRelay {\n', '\n', '    // Note: This is a local nonce.\n', '    // Different from the nonce defined w/in protocol.\n', '    mapping(address => uint) public nonce;\n', '\n', '    // This is for debug purpose\n', '    event Log(address from, string message);\n', '    event MetaTxRelayed(address indexed claimedSender, address indexed addressFromSig);\n', '\n', '    /*\n', '     * @dev Relays meta transactions\n', '     * @param sigV, sigR, sigS ECDSA signature on some data to be forwarded\n', '     * @param destination Location the meta-tx should be forwarded to\n', '     * @param data The bytes necessary to call the function in the destination contract.\n', '     */\n', '    function relayMetaTx(\n', '        uint8 sigV,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        address destination,\n', '        bytes data\n', '    ) public {\n', '\n', '        address claimedSender = getAddressFromData(data);\n', '        // use EIP 191\n', '        // 0x19 :: version :: relay :: sender :: nonce :: destination :: data\n', '        bytes32 h = keccak256(\n', '            abi.encodePacked(byte(0x19), byte(0), this, claimedSender, nonce[claimedSender], destination, data)\n', '        );\n', '        address addressFromSig = getAddressFromSig(h, sigV, sigR, sigS);\n', '\n', '        // address recovered from signature must match with claimed sender\n', '        require(claimedSender == addressFromSig, "address recovered from signature must match with claimed sender");\n', '\n', '        //if we are going to do tx, update nonce\n', '        nonce[claimedSender]++;\n', '\n', '        // invoke method on behalf of sender\n', '        require(destination.call(data), "can not invoke destination function");\n', '\n', '        emit MetaTxRelayed(claimedSender, addressFromSig);\n', '    }\n', '\n', '    /*\n', '     * @dev Gets an address encoded as the first argument in transaction data\n', '     * @param b The byte array that should have an address as first argument\n', '     * @returns a The address retrieved from the array\n', '     (Optimization based on work by tjade273)\n', '     */\n', '    function getAddressFromData(bytes b) public pure returns (address a) {\n', '        if (b.length < 36) return address(0);\n', '        assembly {\n', '            let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n', '            a := and(mask, mload(add(b, 36)))\n', '            // 36 is the offset of the first parameter of the data, if encoded properly.\n', '            // 32 bytes for the length of the bytes array, and 4 bytes for the function signature.\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Gets an address from msgHash and signature\n', '     * @param msgHash EIP 191\n', '     * @param sigV, sigR, sigS ECDSA signature on some data to be forwarded\n', '     * @returns a The address retrieved\n', '     */\n', '    function getAddressFromSig(\n', '        bytes32 msgHash,\n', '        uint8 sigV,\n', '        bytes32 sigR,\n', '        bytes32 sigS\n', '    ) public pure returns (address a) {\n', '        return ecrecover(msgHash, sigV, sigR, sigS);\n', '    }\n', '}']