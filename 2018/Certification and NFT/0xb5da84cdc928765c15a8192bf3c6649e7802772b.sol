['pragma solidity ^0.4.13;\n', '\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    /// @notice Count NFTs tracked by this contract\n', '    /// @return A count of valid NFTs tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '\n', '    /// @notice Enumerate NFTs assigned to an owner\n', '    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid NFTs.\n', '    /// @param _owner An address where we are interested in NFTs owned by them\n', '    /// @param _index A counter less than `balanceOf(_owner)`\n', '    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n', '}\n', '\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param _data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract LicenseAccessControl {\n', '  /**\n', '   * @notice ContractUpgrade is the event that will be emitted if we set a new contract address\n', '   */\n', '  event ContractUpgrade(address newContract);\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  /**\n', '   * @notice CEO&#39;s address FOOBAR\n', '   */\n', '  address public ceoAddress;\n', '\n', '  /**\n', '   * @notice CFO&#39;s address\n', '   */\n', '  address public cfoAddress;\n', '\n', '  /**\n', '   * @notice COO&#39;s address\n', '   */\n', '  address public cooAddress;\n', '\n', '  /**\n', '   * @notice withdrawal address\n', '   */\n', '  address public withdrawalAddress;\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the CEO\n', '   */\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the CFO\n', '   */\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the COO\n', '   */\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by C-level execs\n', '   */\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cfoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by CEO or CFO\n', '   */\n', '  modifier onlyCEOOrCFO() {\n', '    require(\n', '      msg.sender == cfoAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by CEO or COO\n', '   */\n', '  modifier onlyCEOOrCOO() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new CEO\n', '   * @param _newCEO - the address of the new CEO\n', '   */\n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new CFO\n', '   * @param _newCFO - the address of the new CFO\n', '   */\n', '  function setCFO(address _newCFO) external onlyCEO {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new COO\n', '   * @param _newCOO - the address of the new COO\n', '   */\n', '  function setCOO(address _newCOO) external onlyCEO {\n', '    require(_newCOO != address(0));\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new withdrawalAddress\n', '   * @param _newWithdrawalAddress - the address where we&#39;ll send the funds\n', '   */\n', '  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\n', '    require(_newWithdrawalAddress != address(0));\n', '    withdrawalAddress = _newWithdrawalAddress;\n', '  }\n', '\n', '  /**\n', '   * @notice Withdraw the balance to the withdrawalAddress\n', '   * @dev We set a withdrawal address seperate from the CFO because this allows us to withdraw to a cold wallet.\n', '   */\n', '  function withdrawBalance() external onlyCEOOrCFO {\n', '    require(withdrawalAddress != address(0));\n', '    withdrawalAddress.transfer(this.balance);\n', '  }\n', '\n', '  /** Pausable functionality adapted from OpenZeppelin **/\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice called by any C-level to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '    Paused();\n', '  }\n', '\n', '  /**\n', '   * @notice called by the CEO to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '    Unpaused();\n', '  }\n', '}\n', '\n', 'contract LicenseBase is LicenseAccessControl {\n', '  /**\n', '   * @notice Issued is emitted when a new license is issued\n', '   */\n', '  event LicenseIssued(\n', '    address indexed owner,\n', '    address indexed purchaser,\n', '    uint256 licenseId,\n', '    uint256 productId,\n', '    uint256 attributes,\n', '    uint256 issuedTime,\n', '    uint256 expirationTime,\n', '    address affiliate\n', '  );\n', '\n', '  event LicenseRenewal(\n', '    address indexed owner,\n', '    address indexed purchaser,\n', '    uint256 licenseId,\n', '    uint256 productId,\n', '    uint256 expirationTime\n', '  );\n', '\n', '  struct License {\n', '    uint256 productId;\n', '    uint256 attributes;\n', '    uint256 issuedTime;\n', '    uint256 expirationTime;\n', '    address affiliate;\n', '  }\n', '\n', '  /**\n', '   * @notice All licenses in existence.\n', '   * @dev The ID of each license is an index in this array.\n', '   */\n', '  License[] licenses;\n', '\n', '  /** internal **/\n', '  function _isValidLicense(uint256 _licenseId) internal view returns (bool) {\n', '    return licenseProductId(_licenseId) != 0;\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', '   * @notice Get a license&#39;s productId\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseProductId(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].productId;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a license&#39;s attributes\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseAttributes(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].attributes;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a license&#39;s issueTime\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseIssuedTime(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].issuedTime;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a license&#39;s issueTime\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseExpirationTime(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].expirationTime;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a the affiliate credited for the sale of this license\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseAffiliate(uint256 _licenseId) public view returns (address) {\n', '    return licenses[_licenseId].affiliate;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a license&#39;s info\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseInfo(uint256 _licenseId)\n', '    public view returns (uint256, uint256, uint256, uint256, address)\n', '  {\n', '    return (\n', '      licenseProductId(_licenseId),\n', '      licenseAttributes(_licenseId),\n', '      licenseIssuedTime(_licenseId),\n', '      licenseExpirationTime(_licenseId),\n', '      licenseAffiliate(_licenseId)\n', '    );\n', '  }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract AffiliateProgram is Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  event AffiliateCredit(\n', '    // The address of the affiliate\n', '    address affiliate,\n', '    // The store&#39;s ID of what was sold (e.g. a tokenId)\n', '    uint256 productId,\n', '    // The amount owed this affiliate in this sale\n', '    uint256 amount\n', '  );\n', '\n', '  event Withdraw(address affiliate, address to, uint256 amount);\n', '  event Whitelisted(address affiliate, uint256 amount);\n', '  event RateChanged(uint256 rate, uint256 amount);\n', '\n', '  // @notice A mapping from affiliate address to their balance\n', '  mapping (address => uint256) public balances;\n', '\n', '  // @notice A mapping from affiliate address to the time of last deposit\n', '  mapping (address => uint256) public lastDepositTimes;\n', '\n', '  // @notice The last deposit globally\n', '  uint256 public lastDepositTime;\n', '\n', '  // @notice The maximum rate for any affiliate\n', '  // @dev The hard-coded maximum affiliate rate (in basis points)\n', '  // All rates are measured in basis points (1/100 of a percent)\n', '  // Values 0-10,000 map to 0%-100%\n', '  uint256 private constant hardCodedMaximumRate = 5000;\n', '\n', '  // @notice The commission exiration time\n', '  // @dev Affiliate commissions expire if they are unclaimed after this amount of time\n', '  uint256 private constant commissionExpiryTime = 30 days;\n', '\n', '  // @notice The baseline affiliate rate (in basis points) for non-whitelisted referrals\n', '  uint256 public baselineRate = 0;\n', '\n', '  // @notice A mapping from whitelisted referrals to their individual rates\n', '  mapping (address => uint256) public whitelistRates;\n', '\n', '  // @notice The maximum rate for any affiliate\n', '  // @dev overrides individual rates. This can be used to clip the rate used in bulk, if necessary\n', '  uint256 public maximumRate = 5000;\n', '\n', '  // @notice The address of the store selling products\n', '  address public storeAddress;\n', '\n', '  // @notice The contract is retired\n', '  // @dev If we decide to retire this program, this value will be set to true\n', '  // and then the contract cannot be unpaused\n', '  bool public retired = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the store or the owner\n', '   */\n', '  modifier onlyStoreOrOwner() {\n', '    require(\n', '      msg.sender == storeAddress ||\n', '      msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev AffiliateProgram constructor - keeps the address of it&#39;s parent store\n', '   * and pauses the contract\n', '   */\n', '  function AffiliateProgram(address _storeAddress) public {\n', '    require(_storeAddress != address(0));\n', '    storeAddress = _storeAddress;\n', '    paused = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Exposes that this contract thinks it is an AffiliateProgram\n', '   */\n', '  function isAffiliateProgram() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice returns the commission rate for a sale\n', '   *\n', '   * @dev rateFor returns the rate which should be used to calculate the comission\n', '   *  for this affiliate/sale combination, in basis points (1/100th of a percent).\n', '   *\n', '   *  We may want to completely blacklist a particular address (e.g. a known bad actor affilite).\n', '   *  To that end, if the whitelistRate is exactly 1bp, we use that as a signal for blacklisting\n', '   *  and return a rate of zero. The upside is that we can completely turn off\n', '   *  sending transactions to a particular address when this is needed. The\n', '   *  downside is that you can&#39;t issued 1/100th of a percent commission.\n', '   *  However, since this is such a small amount its an acceptable tradeoff.\n', '   *\n', '   *  This implementation does not use the _productId, _pruchaseId,\n', '   *  _purchaseAmount, but we include them here as part of the protocol, because\n', '   *  they could be useful in more advanced affiliate programs.\n', '   *\n', '   * @param _affiliate - the address of the affiliate to check for\n', '   */\n', '  function rateFor(\n', '    address _affiliate,\n', '    uint256 /*_productId*/,\n', '    uint256 /*_purchaseId*/,\n', '    uint256 /*_purchaseAmount*/)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    uint256 whitelistedRate = whitelistRates[_affiliate];\n', '    if(whitelistedRate > 0) {\n', '      // use 1 bp as a blacklist signal\n', '      if(whitelistedRate == 1) {\n', '        return 0;\n', '      } else {\n', '        return Math.min256(whitelistedRate, maximumRate);\n', '      }\n', '    } else {\n', '      return Math.min256(baselineRate, maximumRate);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice cutFor returns the affiliate cut for a sale\n', '   * @dev cutFor returns the cut (amount in wei) to give in comission to the affiliate\n', '   *\n', '   * @param _affiliate - the address of the affiliate to check for\n', '   * @param _productId - the productId in the sale\n', '   * @param _purchaseId - the purchaseId in the sale\n', '   * @param _purchaseAmount - the purchaseAmount\n', '   */\n', '  function cutFor(\n', '    address _affiliate,\n', '    uint256 _productId,\n', '    uint256 _purchaseId,\n', '    uint256 _purchaseAmount)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    uint256 rate = rateFor(\n', '      _affiliate,\n', '      _productId,\n', '      _purchaseId,\n', '      _purchaseAmount);\n', '    require(rate <= hardCodedMaximumRate);\n', '    return (_purchaseAmount.mul(rate)).div(10000);\n', '  }\n', '\n', '  /**\n', '   * @notice credit an affiliate for a purchase\n', '   * @dev credit accepts eth and credits the affiliate&#39;s balance for the amount\n', '   *\n', '   * @param _affiliate - the address of the affiliate to credit\n', '   * @param _purchaseId - the purchaseId of the sale\n', '   */\n', '  function credit(\n', '    address _affiliate,\n', '    uint256 _purchaseId)\n', '    public\n', '    onlyStoreOrOwner\n', '    whenNotPaused\n', '    payable\n', '  {\n', '    require(msg.value > 0);\n', '    require(_affiliate != address(0));\n', '    balances[_affiliate] += msg.value;\n', '    lastDepositTimes[_affiliate] = now; // solium-disable-line security/no-block-members\n', '    lastDepositTime = now; // solium-disable-line security/no-block-members\n', '    AffiliateCredit(_affiliate, _purchaseId, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev _performWithdraw performs a withdrawal from address _from and\n', '   * transfers it to _to. This can be different because we allow the owner\n', '   * to withdraw unclaimed funds after a period of time.\n', '   *\n', '   * @param _from - the address to subtract balance from\n', '   * @param _to - the address to transfer ETH to\n', '   */\n', '  function _performWithdraw(address _from, address _to) private {\n', '    require(balances[_from] > 0);\n', '    uint256 balanceValue = balances[_from];\n', '    balances[_from] = 0;\n', '    _to.transfer(balanceValue);\n', '    Withdraw(_from, _to, balanceValue);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw\n', '   * @dev withdraw the msg.sender&#39;s balance\n', '   */\n', '  function withdraw() public whenNotPaused {\n', '    _performWithdraw(msg.sender, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw from a specific account\n', '   * @dev withdrawFrom allows the owner to withdraw an affiliate&#39;s unclaimed\n', '   * ETH, after the alotted time.\n', '   *\n', '   * This function can be called even if the contract is paused\n', '   *\n', '   * @param _affiliate - the address of the affiliate\n', '   * @param _to - the address to send ETH to\n', '   */\n', '  function withdrawFrom(address _affiliate, address _to) onlyOwner public {\n', '    // solium-disable-next-line security/no-block-members\n', '    require(now > lastDepositTimes[_affiliate].add(commissionExpiryTime));\n', '    _performWithdraw(_affiliate, _to);\n', '  }\n', '\n', '  /**\n', '   * @notice retire the contract (dangerous)\n', '   * @dev retire - withdraws the entire balance and marks the contract as retired, which\n', '   * prevents unpausing.\n', '   *\n', '   * If no new comissions have been deposited for the alotted time,\n', '   * then the owner may pause the program and retire this contract.\n', '   * This may only be performed once as the contract cannot be unpaused.\n', '   *\n', '   * We do this as an alternative to selfdestruct, because certain operations\n', '   * can still be performed after the contract has been selfdestructed, such as\n', '   * the owner withdrawing ETH accidentally sent here.\n', '   */\n', '  function retire(address _to) onlyOwner whenPaused public {\n', '    // solium-disable-next-line security/no-block-members\n', '    require(now > lastDepositTime.add(commissionExpiryTime));\n', '    _to.transfer(this.balance);\n', '    retired = true;\n', '  }\n', '\n', '  /**\n', '   * @notice whitelist an affiliate address\n', '   * @dev whitelist - white listed affiliates can receive a different\n', '   *   rate than the general public (whitelisted accounts would generally get a\n', '   *   better rate).\n', '   * @param _affiliate - the affiliate address to whitelist\n', '   * @param _rate - the rate, in basis-points (1/100th of a percent) to give this affiliate in each sale. NOTE: a rate of exactly 1 is the signal to blacklist this affiliate. That is, a rate of 1 will set the commission to 0.\n', '   */\n', '  function whitelist(address _affiliate, uint256 _rate) onlyOwner public {\n', '    require(_rate <= hardCodedMaximumRate);\n', '    whitelistRates[_affiliate] = _rate;\n', '    Whitelisted(_affiliate, _rate);\n', '  }\n', '\n', '  /**\n', '   * @notice set the rate for non-whitelisted affiliates\n', '   * @dev setBaselineRate - sets the baseline rate for any affiliate that is not whitelisted\n', '   * @param _newRate - the rate, in bp (1/100th of a percent) to give any non-whitelisted affiliate. Set to zero to "turn off"\n', '   */\n', '  function setBaselineRate(uint256 _newRate) onlyOwner public {\n', '    require(_newRate <= hardCodedMaximumRate);\n', '    baselineRate = _newRate;\n', '    RateChanged(0, _newRate);\n', '  }\n', '\n', '  /**\n', '   * @notice set the maximum rate for any affiliate\n', '   * @dev setMaximumRate - Set the maximum rate for any affiliate, including whitelists. That is, this overrides individual rates.\n', '   * @param _newRate - the rate, in bp (1/100th of a percent)\n', '   */\n', '  function setMaximumRate(uint256 _newRate) onlyOwner public {\n', '    require(_newRate <= hardCodedMaximumRate);\n', '    maximumRate = _newRate;\n', '    RateChanged(1, _newRate);\n', '  }\n', '\n', '  /**\n', '   * @notice unpause the contract\n', '   * @dev called by the owner to unpause, returns to normal state. Will not\n', '   * unpause if the contract is retired.\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    require(!retired);\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '\n', '}\n', '\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function transfer(address _to, uint256 _tokenId) external;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function setApprovalForAll(address _to, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', 'contract LicenseInventory is LicenseBase {\n', '  using SafeMath for uint256;\n', '\n', '  event ProductCreated(\n', '    uint256 id,\n', '    uint256 price,\n', '    uint256 available,\n', '    uint256 supply,\n', '    uint256 interval,\n', '    bool renewable\n', '  );\n', '  event ProductInventoryAdjusted(uint256 productId, uint256 available);\n', '  event ProductPriceChanged(uint256 productId, uint256 price);\n', '  event ProductRenewableChanged(uint256 productId, bool renewable);\n', '\n', '\n', '  /**\n', '   * @notice Product defines a product\n', '   * * renewable: There may come a time when we which to disable the ability to renew a subscription. For example, a plan we no longer wish to support. Obviously care needs to be taken with how we communicate this to customers, but contract-wise, we want to support the ability to discontinue renewal of certain plans.\n', '  */\n', '  struct Product {\n', '    uint256 id;\n', '    uint256 price;\n', '    uint256 available;\n', '    uint256 supply;\n', '    uint256 sold;\n', '    uint256 interval;\n', '    bool renewable;\n', '  }\n', '\n', '  // @notice All products in existence\n', '  uint256[] public allProductIds;\n', '\n', '  // @notice A mapping from product ids to Products\n', '  mapping (uint256 => Product) public products;\n', '\n', '  /*** internal ***/\n', '\n', '  /**\n', '   * @notice _productExists checks to see if a product exists\n', '   */\n', '  function _productExists(uint256 _productId) internal view returns (bool) {\n', '    return products[_productId].id != 0;\n', '  }\n', '\n', '  function _productDoesNotExist(uint256 _productId) internal view returns (bool) {\n', '    return products[_productId].id == 0;\n', '  }\n', '\n', '  function _createProduct(\n', '    uint256 _productId,\n', '    uint256 _initialPrice,\n', '    uint256 _initialInventoryQuantity,\n', '    uint256 _supply,\n', '    uint256 _interval)\n', '    internal\n', '  {\n', '    require(_productDoesNotExist(_productId));\n', '    require(_initialInventoryQuantity <= _supply);\n', '\n', '    Product memory _product = Product({\n', '      id: _productId,\n', '      price: _initialPrice,\n', '      available: _initialInventoryQuantity,\n', '      supply: _supply,\n', '      sold: 0,\n', '      interval: _interval,\n', '      renewable: _interval == 0 ? false : true\n', '    });\n', '\n', '    products[_productId] = _product;\n', '    allProductIds.push(_productId);\n', '\n', '    ProductCreated(\n', '      _product.id,\n', '      _product.price,\n', '      _product.available,\n', '      _product.supply,\n', '      _product.interval,\n', '      _product.renewable\n', '      );\n', '  }\n', '\n', '  function _incrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    internal\n', '  {\n', '    require(_productExists(_productId));\n', '    uint256 newInventoryLevel = products[_productId].available.add(_inventoryAdjustment);\n', '\n', '    // A supply of "0" means "unlimited". Otherwise we need to ensure that we&#39;re not over-creating this product\n', '    if(products[_productId].supply > 0) {\n', '      // you have to take already sold into account\n', '      require(products[_productId].sold.add(newInventoryLevel) <= products[_productId].supply);\n', '    }\n', '\n', '    products[_productId].available = newInventoryLevel;\n', '  }\n', '\n', '  function _decrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    internal\n', '  {\n', '    require(_productExists(_productId));\n', '    uint256 newInventoryLevel = products[_productId].available.sub(_inventoryAdjustment);\n', '    // unnecessary because we&#39;re using SafeMath and an unsigned int\n', '    // require(newInventoryLevel >= 0);\n', '    products[_productId].available = newInventoryLevel;\n', '  }\n', '\n', '  function _clearInventory(uint256 _productId) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].available = 0;\n', '  }\n', '\n', '  function _setPrice(uint256 _productId, uint256 _price) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].price = _price;\n', '  }\n', '\n', '  function _setRenewable(uint256 _productId, bool _isRenewable) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].renewable = _isRenewable;\n', '  }\n', '\n', '  function _purchaseOneUnitInStock(uint256 _productId) internal {\n', '    require(_productExists(_productId));\n', '    require(availableInventoryOf(_productId) > 0);\n', '\n', '    // lower inventory\n', '    _decrementInventory(_productId, 1);\n', '\n', '    // record that one was sold\n', '    products[_productId].sold = products[_productId].sold.add(1);\n', '  }\n', '\n', '  function _requireRenewableProduct(uint256 _productId) internal view {\n', '    // productId must exist\n', '    require(_productId != 0);\n', '    // You can only renew a subscription product\n', '    require(isSubscriptionProduct(_productId));\n', '    // The product must currently be renewable\n', '    require(renewableOf(_productId));\n', '  }\n', '\n', '  /*** public ***/\n', '\n', '  /** executives-only **/\n', '\n', '  /**\n', '   * @notice createProduct creates a new product in the system\n', '   * @param _productId - the id of the product to use (cannot be changed)\n', '   * @param _initialPrice - the starting price (price can be changed)\n', '   * @param _initialInventoryQuantity - the initial inventory (inventory can be changed)\n', '   * @param _supply - the total supply - use `0` for "unlimited" (cannot be changed)\n', '   */\n', '  function createProduct(\n', '    uint256 _productId,\n', '    uint256 _initialPrice,\n', '    uint256 _initialInventoryQuantity,\n', '    uint256 _supply,\n', '    uint256 _interval)\n', '    external\n', '    onlyCEOOrCOO\n', '  {\n', '    _createProduct(\n', '      _productId,\n', '      _initialPrice,\n', '      _initialInventoryQuantity,\n', '      _supply,\n', '      _interval);\n', '  }\n', '\n', '  /**\n', '   * @notice incrementInventory - increments the inventory of a product\n', '   * @param _productId - the product id\n', '   * @param _inventoryAdjustment - the amount to increment\n', '   */\n', '  function incrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _incrementInventory(_productId, _inventoryAdjustment);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice decrementInventory removes inventory levels for a product\n', '  * @param _productId - the product id\n', '  * @param _inventoryAdjustment - the amount to decrement\n', '  */\n', '  function decrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _decrementInventory(_productId, _inventoryAdjustment);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice clearInventory clears the inventory of a product.\n', '  * @dev decrementInventory verifies inventory levels, whereas this method\n', '  * simply sets the inventory to zero. This is useful, for example, if an\n', '  * executive wants to take a product off the market quickly. There could be a\n', '  * race condition with decrementInventory where a product is sold, which could\n', '  * cause the admins decrement to fail (because it may try to decrement more\n', '  * than available).\n', '  *\n', '  * @param _productId - the product id\n', '  */\n', '  function clearInventory(uint256 _productId)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _clearInventory(_productId);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice setPrice - sets the price of a product\n', '  * @param _productId - the product id\n', '  * @param _price - the product price\n', '  */\n', '  function setPrice(uint256 _productId, uint256 _price)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _setPrice(_productId, _price);\n', '    ProductPriceChanged(_productId, _price);\n', '  }\n', '\n', '  /**\n', '  * @notice setRenewable - sets if a product is renewable\n', '  * @param _productId - the product id\n', '  * @param _newRenewable - the new renewable setting\n', '  */\n', '  function setRenewable(uint256 _productId, bool _newRenewable)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _setRenewable(_productId, _newRenewable);\n', '    ProductRenewableChanged(_productId, _newRenewable);\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', '  * @notice The price of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function priceOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].price;\n', '  }\n', '\n', '  /**\n', '  * @notice The available inventory of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function availableInventoryOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].available;\n', '  }\n', '\n', '  /**\n', '  * @notice The total supply of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function totalSupplyOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].supply;\n', '  }\n', '\n', '  /**\n', '  * @notice The total sold of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function totalSold(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].sold;\n', '  }\n', '\n', '  /**\n', '  * @notice The renewal interval of a product in seconds\n', '  * @param _productId - the product id\n', '  */\n', '  function intervalOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].interval;\n', '  }\n', '\n', '  /**\n', '  * @notice Is this product renewable?\n', '  * @param _productId - the product id\n', '  */\n', '  function renewableOf(uint256 _productId) public view returns (bool) {\n', '    return products[_productId].renewable;\n', '  }\n', '\n', '\n', '  /**\n', '  * @notice The product info for a product\n', '  * @param _productId - the product id\n', '  */\n', '  function productInfo(uint256 _productId)\n', '    public\n', '    view\n', '    returns (uint256, uint256, uint256, uint256, bool)\n', '  {\n', '    return (\n', '      priceOf(_productId),\n', '      availableInventoryOf(_productId),\n', '      totalSupplyOf(_productId),\n', '      intervalOf(_productId),\n', '      renewableOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice Get all product ids\n', '  */\n', '  function getAllProductIds() public view returns (uint256[]) {\n', '    return allProductIds;\n', '  }\n', '\n', '  /**\n', '   * @notice returns the total cost to renew a product for a number of cycles\n', '   * @dev If a product is a subscription, the interval defines the period of\n', '   * time, in seconds, users can subscribe for. E.g. 1 month or 1 year.\n', '   * _numCycles is the number of these intervals we want to use in the\n', '   * calculation of the price.\n', '   *\n', '   * We require that the end user send precisely the amount required (instead\n', '   * of dealing with excess refunds). This method is public so that clients can\n', '   * read the exact amount our contract expects to receive.\n', '   *\n', '   * @param _productId - the product we&#39;re calculating for\n', '   * @param _numCycles - the number of cycles to calculate for\n', '   */\n', '  function costForProductCycles(uint256 _productId, uint256 _numCycles)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return priceOf(_productId).mul(_numCycles);\n', '  }\n', '\n', '  /**\n', '   * @notice returns if this product is a subscription or not\n', '   * @dev Some products are subscriptions and others are not. An interval of 0\n', '   * means the product is not a subscription\n', '   * @param _productId - the product we&#39;re checking\n', '   */\n', '  function isSubscriptionProduct(uint256 _productId) public view returns (bool) {\n', '    return intervalOf(_productId) > 0;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ERC165 {\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract LicenseOwnership is LicenseInventory, ERC721, ERC165, ERC721Metadata, ERC721Enumerable {\n', '  using SafeMath for uint256;\n', '\n', '  // Total amount of tokens\n', '  uint256 private totalTokens;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) private tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) private tokenApprovals;\n', '\n', '  // Mapping from owner address to operator address to approval\n', '  mapping (address => mapping (address => bool)) private operatorApprovals;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) private ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) private ownedTokensIndex;\n', '\n', '  /*** Constants ***/\n', '  // Configure these for your own deployment\n', '  string public constant NAME = "Dottabot";\n', '  string public constant SYMBOL = "DOTTA";\n', '  string public tokenMetadataBaseURI = "https://api.dottabot.com/";\n', '\n', '  /**\n', '   * @notice token&#39;s name\n', '   */\n', '  function name() external pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /**\n', '   * @notice symbols&#39;s name\n', '   */\n', '  function symbol() external pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  function implementsERC721() external pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string infoUrl)\n', '  {\n', '    return Strings.strConcat(\n', '      tokenMetadataBaseURI,\n', '      Strings.uint2str(_tokenId));\n', '  }\n', '\n', '  function supportsInterface(\n', '    bytes4 interfaceID) // solium-disable-line dotta/underscore-function-arguments\n', '    external view returns (bool)\n', '  {\n', '    return\n', '      interfaceID == this.supportsInterface.selector || // ERC165\n', '      interfaceID == 0x5b5e139f || // ERC721Metadata\n', '      interfaceID == 0x6466353c || // ERC-721 on 3/7/2018\n', '      interfaceID == 0x780e9d63; // ERC721Enumerable\n', '  }\n', '\n', '  function setTokenMetadataBaseURI(string _newBaseURI) external onlyCEOOrCOO {\n', '    tokenMetadataBaseURI = _newBaseURI;\n', '  }\n', '\n', '  /**\n', '  * @notice Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the total amount of tokens stored by the contract\n', '  * @return uint256 representing the total amount of tokens\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalTokens;\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate valid NFTs\n', '  * @dev Our Licenses are kept in an array and each new License-token is just\n', '  * the next element in the array. This method is required for ERC721Enumerable\n', '  * which may support more complicated storage schemes. However, in our case the\n', '  * _index is the tokenId\n', '  * @param _index A counter less than `totalSupply()`\n', '  * @return The token identifier for the `_index`th NFT\n', '  */\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return _index;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokens[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the list of tokens owned by a given address\n', '  * @param _owner address to query the tokens of\n', '  * @return uint256[] representing the list of tokens owned by the passed address\n', '  */\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate NFTs assigned to an owner\n', '  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  *  `_owner` is the zero address, representing invalid NFTs.\n', '  * @param _owner An address where we are interested in NFTs owned by them\n', '  * @param _index A counter less than `balanceOf(_owner)`\n', '  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the approved address to take ownership of a given token ID\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved to take ownership of the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\n', '   * Checks both for specific approval and operator approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether transfer by msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\n', '    return\n', '      ownerOf(_tokenId) == msg.sender ||\n', '      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\n', '      isApprovedForAll(ownerOf(_tokenId), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved for the given token ID or not\n', '   * @param _asker address of asking for approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether the msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\n', '    return getApproved(_tokenId) == _asker;\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\n', '  {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of a given token ID to another address\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _tokenId)\n', '    external\n', '    whenNotPaused\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of the given token ID\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId)\n', '    external\n', '    whenNotPaused\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    if (getApproved(_tokenId) != 0 || _to != 0) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Enable or disable approval for a third party ("operator") to manage all your assets\n', '  * @dev Emits the ApprovalForAll event\n', '  * @param _to Address to add to the set of authorized operators.\n', '  * @param _approved True if the operators is approved, false to revoke approval\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved)\n', '    external\n', '    whenNotPaused\n', '  {\n', '    if(_approved) {\n', '      approveAll(_to);\n', '    } else {\n', '      disapproveAll(_to);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of any tokens owned by this account\n', '  * @param _to address to be approved for the given token ID\n', '  */\n', '  function approveAll(address _to)\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != msg.sender);\n', '    require(_to != address(0));\n', '    operatorApprovals[msg.sender][_to] = true;\n', '    ApprovalForAll(msg.sender, _to, true);\n', '  }\n', '\n', '  /**\n', '  * @notice Removes approval for another address to claim for the ownership of any\n', '  *  tokens owned by this account.\n', '  * @dev Note that this only removes the operator approval and\n', '  *  does not clear any independent, specific approvals of token transfers to this address\n', '  * @param _to address to be disapproved for the given token ID\n', '  */\n', '  function disapproveAll(address _to)\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != msg.sender);\n', '    delete operatorApprovals[msg.sender][_to];\n', '    ApprovalForAll(msg.sender, _to, false);\n', '  }\n', '\n', '  /**\n', '  * @notice Claims the ownership of a given token ID\n', '  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _tokenId)\n', '   external\n', '   whenNotPaused\n', '  {\n', '    require(isSenderApprovedFor(_tokenId));\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfer a token owned by another address, for which the calling address has\n', '  *  previously been granted transfer approval by the owner.\n', '  * @param _from The address that owns the token\n', '  * @param _to The address that will take ownership of the token. Can be any address, including the caller\n', '  * @param _tokenId The ID of the token to be transferred\n', '  */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(isSenderApprovedFor(_tokenId));\n', '    require(ownerOf(_tokenId) == _from);\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of an NFT from one address to another address\n', '  * @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  * operator, or the approved address for this NFT. Throws if `_from` is\n', '  * not the current owner. Throws if `_to` is the zero address. Throws if\n', '  * `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  * `onERC721Received` on `_to` and throws if the return value is not\n', '  * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  * @param _from The current owner of the NFT\n', '  * @param _to The new owner\n', '  * @param _tokenId The NFT to transfer\n', '  * @param _data Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != address(0));\n', '    require(_isValidLicense(_tokenId));\n', '    transferFrom(_from, _to, _tokenId);\n', '    if (_isContract(_to)) {\n', '      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\n', '        _from, _tokenId, _data\n', '      );\n', '      require(tokenReceiverResponse == bytes4(keccak256("onERC721Received(address,uint256,bytes)")));\n', '    }\n', '  }\n', '\n', '  /*\n', '   * @notice Transfers the ownership of an NFT from one address to another address\n', '   * @dev This works identically to the other function with an extra data parameter,\n', '   *  except this function just sets data to ""\n', '   * @param _from The current owner of the NFT\n', '   * @param _to The new owner\n', '   * @param _tokenId The NFT to transfer\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    whenNotPaused\n', '  {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    _addToken(_to, _tokenId);\n', '    Transfer(0x0, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\n', '  * @param _from address which you want to send tokens from\n', '  * @param _to address which you want to transfer the token to\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    require(_to != ownerOf(_tokenId));\n', '    require(ownerOf(_tokenId) == _from);\n', '    require(_isValidLicense(_tokenId));\n', '\n', '    _clearApproval(_from, _tokenId);\n', '    _removeToken(_from, _tokenId);\n', '    _addToken(_to, _tokenId);\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval of a given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApproval(address _owner, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    tokenApprovals[_tokenId] = 0;\n', '    Approval(_owner, 0, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function _addToken(address _to, uint256 _tokenId) private {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    uint256 length = balanceOf(_to);\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '    totalTokens = totalTokens.add(1);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function _removeToken(address _from, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _from);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    tokenOwner[_tokenId] = 0;\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '    totalTokens = totalTokens.sub(1);\n', '  }\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', 'contract LicenseSale is LicenseOwnership {\n', '  AffiliateProgram public affiliateProgram;\n', '\n', '  /**\n', '   * @notice We credit affiliates for renewals that occur within this time of\n', '   * original purchase. E.g. If this is set to 1 year, and someone subscribes to\n', '   * a monthly plan, the affiliate will receive credits for that whole year, as\n', '   * the user renews their plan\n', '   */\n', '  uint256 public renewalsCreditAffiliatesFor = 1 years;\n', '\n', '  /** internal **/\n', '  function _performPurchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes,\n', '    address _affiliate)\n', '    internal returns (uint)\n', '  {\n', '    _purchaseOneUnitInStock(_productId);\n', '    return _createLicense(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      _attributes,\n', '      _affiliate\n', '      );\n', '  }\n', '\n', '  function _createLicense(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes,\n', '    address _affiliate)\n', '    internal\n', '    returns (uint)\n', '  {\n', '    // You cannot create a subscription license with zero cycles\n', '    if(isSubscriptionProduct(_productId)) {\n', '      require(_numCycles != 0);\n', '    }\n', '\n', '    // Non-subscription products have an expiration time of 0, meaning "no-expiration"\n', '    uint256 expirationTime = isSubscriptionProduct(_productId) ?\n', '      now.add(intervalOf(_productId).mul(_numCycles)) : // solium-disable-line security/no-block-members\n', '      0;\n', '\n', '    License memory _license = License({\n', '      productId: _productId,\n', '      attributes: _attributes,\n', '      issuedTime: now, // solium-disable-line security/no-block-members\n', '      expirationTime: expirationTime,\n', '      affiliate: _affiliate\n', '    });\n', '\n', '    uint256 newLicenseId = licenses.push(_license) - 1; // solium-disable-line zeppelin/no-arithmetic-operations\n', '    LicenseIssued(\n', '      _assignee,\n', '      msg.sender,\n', '      newLicenseId,\n', '      _license.productId,\n', '      _license.attributes,\n', '      _license.issuedTime,\n', '      _license.expirationTime,\n', '      _license.affiliate);\n', '    _mint(_assignee, newLicenseId);\n', '    return newLicenseId;\n', '  }\n', '\n', '  function _handleAffiliate(\n', '    address _affiliate,\n', '    uint256 _productId,\n', '    uint256 _licenseId,\n', '    uint256 _purchaseAmount)\n', '    internal\n', '  {\n', '    uint256 affiliateCut = affiliateProgram.cutFor(\n', '      _affiliate,\n', '      _productId,\n', '      _licenseId,\n', '      _purchaseAmount);\n', '    if(affiliateCut > 0) {\n', '      require(affiliateCut < _purchaseAmount);\n', '      affiliateProgram.credit.value(affiliateCut)(_affiliate, _licenseId);\n', '    }\n', '  }\n', '\n', '  function _performRenewal(uint256 _tokenId, uint256 _numCycles) internal {\n', '    // You cannot renew a non-expiring license\n', '    // ... but in what scenario can this happen?\n', '    // require(licenses[_tokenId].expirationTime != 0);\n', '    uint256 productId = licenseProductId(_tokenId);\n', '\n', '    // If our expiration is in the future, renewing adds time to that future expiration\n', '    // If our expiration has passed already, then we use `now` as the base.\n', '    uint256 renewalBaseTime = Math.max256(now, licenses[_tokenId].expirationTime);\n', '\n', '    // We assume that the payment has been validated outside of this function\n', '    uint256 newExpirationTime = renewalBaseTime.add(intervalOf(productId).mul(_numCycles));\n', '\n', '    licenses[_tokenId].expirationTime = newExpirationTime;\n', '\n', '    LicenseRenewal(\n', '      ownerOf(_tokenId),\n', '      msg.sender,\n', '      _tokenId,\n', '      productId,\n', '      newExpirationTime\n', '    );\n', '  }\n', '\n', '  function _affiliateProgramIsActive() internal view returns (bool) {\n', '    return\n', '      affiliateProgram != address(0) &&\n', '      affiliateProgram.storeAddress() == address(this) &&\n', '      !affiliateProgram.paused();\n', '  }\n', '\n', '  /** executives **/\n', '  function setAffiliateProgramAddress(address _address) external onlyCEO {\n', '    AffiliateProgram candidateContract = AffiliateProgram(_address);\n', '    require(candidateContract.isAffiliateProgram());\n', '    affiliateProgram = candidateContract;\n', '  }\n', '\n', '  function setRenewalsCreditAffiliatesFor(uint256 _newTime) external onlyCEO {\n', '    renewalsCreditAffiliatesFor = _newTime;\n', '  }\n', '\n', '  function createPromotionalPurchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes\n', '    )\n', '    external\n', '    onlyCEOOrCOO\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    return _performPurchase(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      _attributes,\n', '      address(0));\n', '  }\n', '\n', '  function createPromotionalRenewal(\n', '    uint256 _tokenId,\n', '    uint256 _numCycles\n', '    )\n', '    external\n', '    onlyCEOOrCOO\n', '    whenNotPaused\n', '  {\n', '    uint256 productId = licenseProductId(_tokenId);\n', '    _requireRenewableProduct(productId);\n', '\n', '    return _performRenewal(_tokenId, _numCycles);\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', '  * @notice Makes a purchase of a product.\n', '  * @dev Requires that the value sent is exactly the price of the product\n', '  * @param _productId - the product to purchase\n', '  * @param _numCycles - the number of cycles being purchased. This number should be `1` for non-subscription products and the number of cycles for subscriptions.\n', '  * @param _assignee - the address to assign the purchase to (doesn&#39;t have to be msg.sender)\n', '  * @param _affiliate - the address to of the affiliate - use address(0) if none\n', '  */\n', '  function purchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    address _affiliate\n', '    )\n', '    external\n', '    payable\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    require(_productId != 0);\n', '    require(_numCycles != 0);\n', '    require(_assignee != address(0));\n', '    // msg.value can be zero: free products are supported\n', '\n', '    // Don&#39;t bother dealing with excess payments. Ensure the price paid is\n', '    // accurate. No more, no less.\n', '    require(msg.value == costForProductCycles(_productId, _numCycles));\n', '\n', '    // Non-subscription products should send a _numCycle of 1 -- you can&#39;t buy a\n', '    // multiple quantity of a non-subscription product with this function\n', '    if(!isSubscriptionProduct(_productId)) {\n', '      require(_numCycles == 1);\n', '    }\n', '\n', '    // this can, of course, be gamed by malicious miners. But it&#39;s adequate for our application\n', '    // Feel free to add your own strategies for product attributes\n', '    // solium-disable-next-line security/no-block-members, zeppelin/no-arithmetic-operations\n', '    uint256 attributes = uint256(keccak256(block.blockhash(block.number-1)))^_productId^(uint256(_assignee));\n', '    uint256 licenseId = _performPurchase(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      attributes,\n', '      _affiliate);\n', '\n', '    if(\n', '      priceOf(_productId) > 0 &&\n', '      _affiliate != address(0) &&\n', '      _affiliateProgramIsActive()\n', '    ) {\n', '      _handleAffiliate(\n', '        _affiliate,\n', '        _productId,\n', '        licenseId,\n', '        msg.value);\n', '    }\n', '\n', '    return licenseId;\n', '  }\n', '\n', '  /**\n', '   * @notice Renews a subscription\n', '   */\n', '  function renew(\n', '    uint256 _tokenId,\n', '    uint256 _numCycles\n', '    )\n', '    external\n', '    payable\n', '    whenNotPaused\n', '  {\n', '    require(_numCycles != 0);\n', '    require(ownerOf(_tokenId) != address(0));\n', '\n', '    uint256 productId = licenseProductId(_tokenId);\n', '    _requireRenewableProduct(productId);\n', '\n', '    // No excess payments. Ensure the price paid is exactly accurate. No more,\n', '    // no less.\n', '    uint256 renewalCost = costForProductCycles(productId, _numCycles);\n', '    require(msg.value == renewalCost);\n', '\n', '    _performRenewal(_tokenId, _numCycles);\n', '\n', '    if(\n', '      renewalCost > 0 &&\n', '      licenseAffiliate(_tokenId) != address(0) &&\n', '      _affiliateProgramIsActive() &&\n', '      licenseIssuedTime(_tokenId).add(renewalsCreditAffiliatesFor) > now\n', '    ) {\n', '      _handleAffiliate(\n', '        licenseAffiliate(_tokenId),\n', '        productId,\n', '        _tokenId,\n', '        msg.value);\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract LicenseCore is LicenseSale {\n', '  address public newContractAddress;\n', '\n', '  function LicenseCore() public {\n', '    paused = true;\n', '\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    withdrawalAddress = msg.sender;\n', '  }\n', '\n', '  function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n', '    newContractAddress = _v2Address;\n', '    ContractUpgrade(_v2Address);\n', '  }\n', '\n', '  function() external {\n', '    assert(false);\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    require(newContractAddress == address(0));\n', '    super.unpause();\n', '  }\n', '}\n', '\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '      bytes memory _ba = bytes(_a);\n', '      bytes memory _bb = bytes(_b);\n', '      bytes memory _bc = bytes(_c);\n', '      bytes memory _bd = bytes(_d);\n', '      bytes memory _be = bytes(_e);\n', '      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '      bytes memory babcde = bytes(abcde);\n', '      uint k = 0;\n', '      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '      return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function uint2str(uint i) internal pure returns (string) {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    /// @notice Count NFTs tracked by this contract\n', '    /// @return A count of valid NFTs tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '\n', '    /// @notice Enumerate NFTs assigned to an owner\n', '    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid NFTs.\n', '    /// @param _owner An address where we are interested in NFTs owned by them\n', '    /// @param _index A counter less than `balanceOf(_owner)`\n', '    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\n', '}\n', '\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address\n', '    /// @param _tokenId The NFT identifier which is being transfered\n', '    /// @param _data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n', '}\n', '\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract LicenseAccessControl {\n', '  /**\n', '   * @notice ContractUpgrade is the event that will be emitted if we set a new contract address\n', '   */\n', '  event ContractUpgrade(address newContract);\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  /**\n', "   * @notice CEO's address FOOBAR\n", '   */\n', '  address public ceoAddress;\n', '\n', '  /**\n', "   * @notice CFO's address\n", '   */\n', '  address public cfoAddress;\n', '\n', '  /**\n', "   * @notice COO's address\n", '   */\n', '  address public cooAddress;\n', '\n', '  /**\n', '   * @notice withdrawal address\n', '   */\n', '  address public withdrawalAddress;\n', '\n', '  bool public paused = false;\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the CEO\n', '   */\n', '  modifier onlyCEO() {\n', '    require(msg.sender == ceoAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the CFO\n', '   */\n', '  modifier onlyCFO() {\n', '    require(msg.sender == cfoAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the COO\n', '   */\n', '  modifier onlyCOO() {\n', '    require(msg.sender == cooAddress);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by C-level execs\n', '   */\n', '  modifier onlyCLevel() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress ||\n', '      msg.sender == cfoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by CEO or CFO\n', '   */\n', '  modifier onlyCEOOrCFO() {\n', '    require(\n', '      msg.sender == cfoAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by CEO or COO\n', '   */\n', '  modifier onlyCEOOrCOO() {\n', '    require(\n', '      msg.sender == cooAddress ||\n', '      msg.sender == ceoAddress\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new CEO\n', '   * @param _newCEO - the address of the new CEO\n', '   */\n', '  function setCEO(address _newCEO) external onlyCEO {\n', '    require(_newCEO != address(0));\n', '    ceoAddress = _newCEO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new CFO\n', '   * @param _newCFO - the address of the new CFO\n', '   */\n', '  function setCFO(address _newCFO) external onlyCEO {\n', '    require(_newCFO != address(0));\n', '    cfoAddress = _newCFO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new COO\n', '   * @param _newCOO - the address of the new COO\n', '   */\n', '  function setCOO(address _newCOO) external onlyCEO {\n', '    require(_newCOO != address(0));\n', '    cooAddress = _newCOO;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets a new withdrawalAddress\n', "   * @param _newWithdrawalAddress - the address where we'll send the funds\n", '   */\n', '  function setWithdrawalAddress(address _newWithdrawalAddress) external onlyCEO {\n', '    require(_newWithdrawalAddress != address(0));\n', '    withdrawalAddress = _newWithdrawalAddress;\n', '  }\n', '\n', '  /**\n', '   * @notice Withdraw the balance to the withdrawalAddress\n', '   * @dev We set a withdrawal address seperate from the CFO because this allows us to withdraw to a cold wallet.\n', '   */\n', '  function withdrawBalance() external onlyCEOOrCFO {\n', '    require(withdrawalAddress != address(0));\n', '    withdrawalAddress.transfer(this.balance);\n', '  }\n', '\n', '  /** Pausable functionality adapted from OpenZeppelin **/\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice called by any C-level to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyCLevel whenNotPaused {\n', '    paused = true;\n', '    Paused();\n', '  }\n', '\n', '  /**\n', '   * @notice called by the CEO to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyCEO whenPaused {\n', '    paused = false;\n', '    Unpaused();\n', '  }\n', '}\n', '\n', 'contract LicenseBase is LicenseAccessControl {\n', '  /**\n', '   * @notice Issued is emitted when a new license is issued\n', '   */\n', '  event LicenseIssued(\n', '    address indexed owner,\n', '    address indexed purchaser,\n', '    uint256 licenseId,\n', '    uint256 productId,\n', '    uint256 attributes,\n', '    uint256 issuedTime,\n', '    uint256 expirationTime,\n', '    address affiliate\n', '  );\n', '\n', '  event LicenseRenewal(\n', '    address indexed owner,\n', '    address indexed purchaser,\n', '    uint256 licenseId,\n', '    uint256 productId,\n', '    uint256 expirationTime\n', '  );\n', '\n', '  struct License {\n', '    uint256 productId;\n', '    uint256 attributes;\n', '    uint256 issuedTime;\n', '    uint256 expirationTime;\n', '    address affiliate;\n', '  }\n', '\n', '  /**\n', '   * @notice All licenses in existence.\n', '   * @dev The ID of each license is an index in this array.\n', '   */\n', '  License[] licenses;\n', '\n', '  /** internal **/\n', '  function _isValidLicense(uint256 _licenseId) internal view returns (bool) {\n', '    return licenseProductId(_licenseId) != 0;\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', "   * @notice Get a license's productId\n", '   * @param _licenseId the license id\n', '   */\n', '  function licenseProductId(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].productId;\n', '  }\n', '\n', '  /**\n', "   * @notice Get a license's attributes\n", '   * @param _licenseId the license id\n', '   */\n', '  function licenseAttributes(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].attributes;\n', '  }\n', '\n', '  /**\n', "   * @notice Get a license's issueTime\n", '   * @param _licenseId the license id\n', '   */\n', '  function licenseIssuedTime(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].issuedTime;\n', '  }\n', '\n', '  /**\n', "   * @notice Get a license's issueTime\n", '   * @param _licenseId the license id\n', '   */\n', '  function licenseExpirationTime(uint256 _licenseId) public view returns (uint256) {\n', '    return licenses[_licenseId].expirationTime;\n', '  }\n', '\n', '  /**\n', '   * @notice Get a the affiliate credited for the sale of this license\n', '   * @param _licenseId the license id\n', '   */\n', '  function licenseAffiliate(uint256 _licenseId) public view returns (address) {\n', '    return licenses[_licenseId].affiliate;\n', '  }\n', '\n', '  /**\n', "   * @notice Get a license's info\n", '   * @param _licenseId the license id\n', '   */\n', '  function licenseInfo(uint256 _licenseId)\n', '    public view returns (uint256, uint256, uint256, uint256, address)\n', '  {\n', '    return (\n', '      licenseProductId(_licenseId),\n', '      licenseAttributes(_licenseId),\n', '      licenseIssuedTime(_licenseId),\n', '      licenseExpirationTime(_licenseId),\n', '      licenseAffiliate(_licenseId)\n', '    );\n', '  }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract AffiliateProgram is Pausable {\n', '  using SafeMath for uint256;\n', '\n', '  event AffiliateCredit(\n', '    // The address of the affiliate\n', '    address affiliate,\n', "    // The store's ID of what was sold (e.g. a tokenId)\n", '    uint256 productId,\n', '    // The amount owed this affiliate in this sale\n', '    uint256 amount\n', '  );\n', '\n', '  event Withdraw(address affiliate, address to, uint256 amount);\n', '  event Whitelisted(address affiliate, uint256 amount);\n', '  event RateChanged(uint256 rate, uint256 amount);\n', '\n', '  // @notice A mapping from affiliate address to their balance\n', '  mapping (address => uint256) public balances;\n', '\n', '  // @notice A mapping from affiliate address to the time of last deposit\n', '  mapping (address => uint256) public lastDepositTimes;\n', '\n', '  // @notice The last deposit globally\n', '  uint256 public lastDepositTime;\n', '\n', '  // @notice The maximum rate for any affiliate\n', '  // @dev The hard-coded maximum affiliate rate (in basis points)\n', '  // All rates are measured in basis points (1/100 of a percent)\n', '  // Values 0-10,000 map to 0%-100%\n', '  uint256 private constant hardCodedMaximumRate = 5000;\n', '\n', '  // @notice The commission exiration time\n', '  // @dev Affiliate commissions expire if they are unclaimed after this amount of time\n', '  uint256 private constant commissionExpiryTime = 30 days;\n', '\n', '  // @notice The baseline affiliate rate (in basis points) for non-whitelisted referrals\n', '  uint256 public baselineRate = 0;\n', '\n', '  // @notice A mapping from whitelisted referrals to their individual rates\n', '  mapping (address => uint256) public whitelistRates;\n', '\n', '  // @notice The maximum rate for any affiliate\n', '  // @dev overrides individual rates. This can be used to clip the rate used in bulk, if necessary\n', '  uint256 public maximumRate = 5000;\n', '\n', '  // @notice The address of the store selling products\n', '  address public storeAddress;\n', '\n', '  // @notice The contract is retired\n', '  // @dev If we decide to retire this program, this value will be set to true\n', '  // and then the contract cannot be unpaused\n', '  bool public retired = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function only callable by the store or the owner\n', '   */\n', '  modifier onlyStoreOrOwner() {\n', '    require(\n', '      msg.sender == storeAddress ||\n', '      msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', "   * @dev AffiliateProgram constructor - keeps the address of it's parent store\n", '   * and pauses the contract\n', '   */\n', '  function AffiliateProgram(address _storeAddress) public {\n', '    require(_storeAddress != address(0));\n', '    storeAddress = _storeAddress;\n', '    paused = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Exposes that this contract thinks it is an AffiliateProgram\n', '   */\n', '  function isAffiliateProgram() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice returns the commission rate for a sale\n', '   *\n', '   * @dev rateFor returns the rate which should be used to calculate the comission\n', '   *  for this affiliate/sale combination, in basis points (1/100th of a percent).\n', '   *\n', '   *  We may want to completely blacklist a particular address (e.g. a known bad actor affilite).\n', '   *  To that end, if the whitelistRate is exactly 1bp, we use that as a signal for blacklisting\n', '   *  and return a rate of zero. The upside is that we can completely turn off\n', '   *  sending transactions to a particular address when this is needed. The\n', "   *  downside is that you can't issued 1/100th of a percent commission.\n", '   *  However, since this is such a small amount its an acceptable tradeoff.\n', '   *\n', '   *  This implementation does not use the _productId, _pruchaseId,\n', '   *  _purchaseAmount, but we include them here as part of the protocol, because\n', '   *  they could be useful in more advanced affiliate programs.\n', '   *\n', '   * @param _affiliate - the address of the affiliate to check for\n', '   */\n', '  function rateFor(\n', '    address _affiliate,\n', '    uint256 /*_productId*/,\n', '    uint256 /*_purchaseId*/,\n', '    uint256 /*_purchaseAmount*/)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    uint256 whitelistedRate = whitelistRates[_affiliate];\n', '    if(whitelistedRate > 0) {\n', '      // use 1 bp as a blacklist signal\n', '      if(whitelistedRate == 1) {\n', '        return 0;\n', '      } else {\n', '        return Math.min256(whitelistedRate, maximumRate);\n', '      }\n', '    } else {\n', '      return Math.min256(baselineRate, maximumRate);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice cutFor returns the affiliate cut for a sale\n', '   * @dev cutFor returns the cut (amount in wei) to give in comission to the affiliate\n', '   *\n', '   * @param _affiliate - the address of the affiliate to check for\n', '   * @param _productId - the productId in the sale\n', '   * @param _purchaseId - the purchaseId in the sale\n', '   * @param _purchaseAmount - the purchaseAmount\n', '   */\n', '  function cutFor(\n', '    address _affiliate,\n', '    uint256 _productId,\n', '    uint256 _purchaseId,\n', '    uint256 _purchaseAmount)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    uint256 rate = rateFor(\n', '      _affiliate,\n', '      _productId,\n', '      _purchaseId,\n', '      _purchaseAmount);\n', '    require(rate <= hardCodedMaximumRate);\n', '    return (_purchaseAmount.mul(rate)).div(10000);\n', '  }\n', '\n', '  /**\n', '   * @notice credit an affiliate for a purchase\n', "   * @dev credit accepts eth and credits the affiliate's balance for the amount\n", '   *\n', '   * @param _affiliate - the address of the affiliate to credit\n', '   * @param _purchaseId - the purchaseId of the sale\n', '   */\n', '  function credit(\n', '    address _affiliate,\n', '    uint256 _purchaseId)\n', '    public\n', '    onlyStoreOrOwner\n', '    whenNotPaused\n', '    payable\n', '  {\n', '    require(msg.value > 0);\n', '    require(_affiliate != address(0));\n', '    balances[_affiliate] += msg.value;\n', '    lastDepositTimes[_affiliate] = now; // solium-disable-line security/no-block-members\n', '    lastDepositTime = now; // solium-disable-line security/no-block-members\n', '    AffiliateCredit(_affiliate, _purchaseId, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev _performWithdraw performs a withdrawal from address _from and\n', '   * transfers it to _to. This can be different because we allow the owner\n', '   * to withdraw unclaimed funds after a period of time.\n', '   *\n', '   * @param _from - the address to subtract balance from\n', '   * @param _to - the address to transfer ETH to\n', '   */\n', '  function _performWithdraw(address _from, address _to) private {\n', '    require(balances[_from] > 0);\n', '    uint256 balanceValue = balances[_from];\n', '    balances[_from] = 0;\n', '    _to.transfer(balanceValue);\n', '    Withdraw(_from, _to, balanceValue);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw\n', "   * @dev withdraw the msg.sender's balance\n", '   */\n', '  function withdraw() public whenNotPaused {\n', '    _performWithdraw(msg.sender, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw from a specific account\n', "   * @dev withdrawFrom allows the owner to withdraw an affiliate's unclaimed\n", '   * ETH, after the alotted time.\n', '   *\n', '   * This function can be called even if the contract is paused\n', '   *\n', '   * @param _affiliate - the address of the affiliate\n', '   * @param _to - the address to send ETH to\n', '   */\n', '  function withdrawFrom(address _affiliate, address _to) onlyOwner public {\n', '    // solium-disable-next-line security/no-block-members\n', '    require(now > lastDepositTimes[_affiliate].add(commissionExpiryTime));\n', '    _performWithdraw(_affiliate, _to);\n', '  }\n', '\n', '  /**\n', '   * @notice retire the contract (dangerous)\n', '   * @dev retire - withdraws the entire balance and marks the contract as retired, which\n', '   * prevents unpausing.\n', '   *\n', '   * If no new comissions have been deposited for the alotted time,\n', '   * then the owner may pause the program and retire this contract.\n', '   * This may only be performed once as the contract cannot be unpaused.\n', '   *\n', '   * We do this as an alternative to selfdestruct, because certain operations\n', '   * can still be performed after the contract has been selfdestructed, such as\n', '   * the owner withdrawing ETH accidentally sent here.\n', '   */\n', '  function retire(address _to) onlyOwner whenPaused public {\n', '    // solium-disable-next-line security/no-block-members\n', '    require(now > lastDepositTime.add(commissionExpiryTime));\n', '    _to.transfer(this.balance);\n', '    retired = true;\n', '  }\n', '\n', '  /**\n', '   * @notice whitelist an affiliate address\n', '   * @dev whitelist - white listed affiliates can receive a different\n', '   *   rate than the general public (whitelisted accounts would generally get a\n', '   *   better rate).\n', '   * @param _affiliate - the affiliate address to whitelist\n', '   * @param _rate - the rate, in basis-points (1/100th of a percent) to give this affiliate in each sale. NOTE: a rate of exactly 1 is the signal to blacklist this affiliate. That is, a rate of 1 will set the commission to 0.\n', '   */\n', '  function whitelist(address _affiliate, uint256 _rate) onlyOwner public {\n', '    require(_rate <= hardCodedMaximumRate);\n', '    whitelistRates[_affiliate] = _rate;\n', '    Whitelisted(_affiliate, _rate);\n', '  }\n', '\n', '  /**\n', '   * @notice set the rate for non-whitelisted affiliates\n', '   * @dev setBaselineRate - sets the baseline rate for any affiliate that is not whitelisted\n', '   * @param _newRate - the rate, in bp (1/100th of a percent) to give any non-whitelisted affiliate. Set to zero to "turn off"\n', '   */\n', '  function setBaselineRate(uint256 _newRate) onlyOwner public {\n', '    require(_newRate <= hardCodedMaximumRate);\n', '    baselineRate = _newRate;\n', '    RateChanged(0, _newRate);\n', '  }\n', '\n', '  /**\n', '   * @notice set the maximum rate for any affiliate\n', '   * @dev setMaximumRate - Set the maximum rate for any affiliate, including whitelists. That is, this overrides individual rates.\n', '   * @param _newRate - the rate, in bp (1/100th of a percent)\n', '   */\n', '  function setMaximumRate(uint256 _newRate) onlyOwner public {\n', '    require(_newRate <= hardCodedMaximumRate);\n', '    maximumRate = _newRate;\n', '    RateChanged(1, _newRate);\n', '  }\n', '\n', '  /**\n', '   * @notice unpause the contract\n', '   * @dev called by the owner to unpause, returns to normal state. Will not\n', '   * unpause if the contract is retired.\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    require(!retired);\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '\n', '}\n', '\n', 'contract ERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function transfer(address _to, uint256 _tokenId) external;\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function setApprovalForAll(address _to, bool _approved) external;\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '}\n', '\n', 'contract LicenseInventory is LicenseBase {\n', '  using SafeMath for uint256;\n', '\n', '  event ProductCreated(\n', '    uint256 id,\n', '    uint256 price,\n', '    uint256 available,\n', '    uint256 supply,\n', '    uint256 interval,\n', '    bool renewable\n', '  );\n', '  event ProductInventoryAdjusted(uint256 productId, uint256 available);\n', '  event ProductPriceChanged(uint256 productId, uint256 price);\n', '  event ProductRenewableChanged(uint256 productId, bool renewable);\n', '\n', '\n', '  /**\n', '   * @notice Product defines a product\n', '   * * renewable: There may come a time when we which to disable the ability to renew a subscription. For example, a plan we no longer wish to support. Obviously care needs to be taken with how we communicate this to customers, but contract-wise, we want to support the ability to discontinue renewal of certain plans.\n', '  */\n', '  struct Product {\n', '    uint256 id;\n', '    uint256 price;\n', '    uint256 available;\n', '    uint256 supply;\n', '    uint256 sold;\n', '    uint256 interval;\n', '    bool renewable;\n', '  }\n', '\n', '  // @notice All products in existence\n', '  uint256[] public allProductIds;\n', '\n', '  // @notice A mapping from product ids to Products\n', '  mapping (uint256 => Product) public products;\n', '\n', '  /*** internal ***/\n', '\n', '  /**\n', '   * @notice _productExists checks to see if a product exists\n', '   */\n', '  function _productExists(uint256 _productId) internal view returns (bool) {\n', '    return products[_productId].id != 0;\n', '  }\n', '\n', '  function _productDoesNotExist(uint256 _productId) internal view returns (bool) {\n', '    return products[_productId].id == 0;\n', '  }\n', '\n', '  function _createProduct(\n', '    uint256 _productId,\n', '    uint256 _initialPrice,\n', '    uint256 _initialInventoryQuantity,\n', '    uint256 _supply,\n', '    uint256 _interval)\n', '    internal\n', '  {\n', '    require(_productDoesNotExist(_productId));\n', '    require(_initialInventoryQuantity <= _supply);\n', '\n', '    Product memory _product = Product({\n', '      id: _productId,\n', '      price: _initialPrice,\n', '      available: _initialInventoryQuantity,\n', '      supply: _supply,\n', '      sold: 0,\n', '      interval: _interval,\n', '      renewable: _interval == 0 ? false : true\n', '    });\n', '\n', '    products[_productId] = _product;\n', '    allProductIds.push(_productId);\n', '\n', '    ProductCreated(\n', '      _product.id,\n', '      _product.price,\n', '      _product.available,\n', '      _product.supply,\n', '      _product.interval,\n', '      _product.renewable\n', '      );\n', '  }\n', '\n', '  function _incrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    internal\n', '  {\n', '    require(_productExists(_productId));\n', '    uint256 newInventoryLevel = products[_productId].available.add(_inventoryAdjustment);\n', '\n', '    // A supply of "0" means "unlimited". Otherwise we need to ensure that we\'re not over-creating this product\n', '    if(products[_productId].supply > 0) {\n', '      // you have to take already sold into account\n', '      require(products[_productId].sold.add(newInventoryLevel) <= products[_productId].supply);\n', '    }\n', '\n', '    products[_productId].available = newInventoryLevel;\n', '  }\n', '\n', '  function _decrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    internal\n', '  {\n', '    require(_productExists(_productId));\n', '    uint256 newInventoryLevel = products[_productId].available.sub(_inventoryAdjustment);\n', "    // unnecessary because we're using SafeMath and an unsigned int\n", '    // require(newInventoryLevel >= 0);\n', '    products[_productId].available = newInventoryLevel;\n', '  }\n', '\n', '  function _clearInventory(uint256 _productId) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].available = 0;\n', '  }\n', '\n', '  function _setPrice(uint256 _productId, uint256 _price) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].price = _price;\n', '  }\n', '\n', '  function _setRenewable(uint256 _productId, bool _isRenewable) internal\n', '  {\n', '    require(_productExists(_productId));\n', '    products[_productId].renewable = _isRenewable;\n', '  }\n', '\n', '  function _purchaseOneUnitInStock(uint256 _productId) internal {\n', '    require(_productExists(_productId));\n', '    require(availableInventoryOf(_productId) > 0);\n', '\n', '    // lower inventory\n', '    _decrementInventory(_productId, 1);\n', '\n', '    // record that one was sold\n', '    products[_productId].sold = products[_productId].sold.add(1);\n', '  }\n', '\n', '  function _requireRenewableProduct(uint256 _productId) internal view {\n', '    // productId must exist\n', '    require(_productId != 0);\n', '    // You can only renew a subscription product\n', '    require(isSubscriptionProduct(_productId));\n', '    // The product must currently be renewable\n', '    require(renewableOf(_productId));\n', '  }\n', '\n', '  /*** public ***/\n', '\n', '  /** executives-only **/\n', '\n', '  /**\n', '   * @notice createProduct creates a new product in the system\n', '   * @param _productId - the id of the product to use (cannot be changed)\n', '   * @param _initialPrice - the starting price (price can be changed)\n', '   * @param _initialInventoryQuantity - the initial inventory (inventory can be changed)\n', '   * @param _supply - the total supply - use `0` for "unlimited" (cannot be changed)\n', '   */\n', '  function createProduct(\n', '    uint256 _productId,\n', '    uint256 _initialPrice,\n', '    uint256 _initialInventoryQuantity,\n', '    uint256 _supply,\n', '    uint256 _interval)\n', '    external\n', '    onlyCEOOrCOO\n', '  {\n', '    _createProduct(\n', '      _productId,\n', '      _initialPrice,\n', '      _initialInventoryQuantity,\n', '      _supply,\n', '      _interval);\n', '  }\n', '\n', '  /**\n', '   * @notice incrementInventory - increments the inventory of a product\n', '   * @param _productId - the product id\n', '   * @param _inventoryAdjustment - the amount to increment\n', '   */\n', '  function incrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _incrementInventory(_productId, _inventoryAdjustment);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice decrementInventory removes inventory levels for a product\n', '  * @param _productId - the product id\n', '  * @param _inventoryAdjustment - the amount to decrement\n', '  */\n', '  function decrementInventory(\n', '    uint256 _productId,\n', '    uint256 _inventoryAdjustment)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _decrementInventory(_productId, _inventoryAdjustment);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice clearInventory clears the inventory of a product.\n', '  * @dev decrementInventory verifies inventory levels, whereas this method\n', '  * simply sets the inventory to zero. This is useful, for example, if an\n', '  * executive wants to take a product off the market quickly. There could be a\n', '  * race condition with decrementInventory where a product is sold, which could\n', '  * cause the admins decrement to fail (because it may try to decrement more\n', '  * than available).\n', '  *\n', '  * @param _productId - the product id\n', '  */\n', '  function clearInventory(uint256 _productId)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _clearInventory(_productId);\n', '    ProductInventoryAdjusted(_productId, availableInventoryOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice setPrice - sets the price of a product\n', '  * @param _productId - the product id\n', '  * @param _price - the product price\n', '  */\n', '  function setPrice(uint256 _productId, uint256 _price)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _setPrice(_productId, _price);\n', '    ProductPriceChanged(_productId, _price);\n', '  }\n', '\n', '  /**\n', '  * @notice setRenewable - sets if a product is renewable\n', '  * @param _productId - the product id\n', '  * @param _newRenewable - the new renewable setting\n', '  */\n', '  function setRenewable(uint256 _productId, bool _newRenewable)\n', '    external\n', '    onlyCLevel\n', '  {\n', '    _setRenewable(_productId, _newRenewable);\n', '    ProductRenewableChanged(_productId, _newRenewable);\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', '  * @notice The price of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function priceOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].price;\n', '  }\n', '\n', '  /**\n', '  * @notice The available inventory of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function availableInventoryOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].available;\n', '  }\n', '\n', '  /**\n', '  * @notice The total supply of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function totalSupplyOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].supply;\n', '  }\n', '\n', '  /**\n', '  * @notice The total sold of a product\n', '  * @param _productId - the product id\n', '  */\n', '  function totalSold(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].sold;\n', '  }\n', '\n', '  /**\n', '  * @notice The renewal interval of a product in seconds\n', '  * @param _productId - the product id\n', '  */\n', '  function intervalOf(uint256 _productId) public view returns (uint256) {\n', '    return products[_productId].interval;\n', '  }\n', '\n', '  /**\n', '  * @notice Is this product renewable?\n', '  * @param _productId - the product id\n', '  */\n', '  function renewableOf(uint256 _productId) public view returns (bool) {\n', '    return products[_productId].renewable;\n', '  }\n', '\n', '\n', '  /**\n', '  * @notice The product info for a product\n', '  * @param _productId - the product id\n', '  */\n', '  function productInfo(uint256 _productId)\n', '    public\n', '    view\n', '    returns (uint256, uint256, uint256, uint256, bool)\n', '  {\n', '    return (\n', '      priceOf(_productId),\n', '      availableInventoryOf(_productId),\n', '      totalSupplyOf(_productId),\n', '      intervalOf(_productId),\n', '      renewableOf(_productId));\n', '  }\n', '\n', '  /**\n', '  * @notice Get all product ids\n', '  */\n', '  function getAllProductIds() public view returns (uint256[]) {\n', '    return allProductIds;\n', '  }\n', '\n', '  /**\n', '   * @notice returns the total cost to renew a product for a number of cycles\n', '   * @dev If a product is a subscription, the interval defines the period of\n', '   * time, in seconds, users can subscribe for. E.g. 1 month or 1 year.\n', '   * _numCycles is the number of these intervals we want to use in the\n', '   * calculation of the price.\n', '   *\n', '   * We require that the end user send precisely the amount required (instead\n', '   * of dealing with excess refunds). This method is public so that clients can\n', '   * read the exact amount our contract expects to receive.\n', '   *\n', "   * @param _productId - the product we're calculating for\n", '   * @param _numCycles - the number of cycles to calculate for\n', '   */\n', '  function costForProductCycles(uint256 _productId, uint256 _numCycles)\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return priceOf(_productId).mul(_numCycles);\n', '  }\n', '\n', '  /**\n', '   * @notice returns if this product is a subscription or not\n', '   * @dev Some products are subscriptions and others are not. An interval of 0\n', '   * means the product is not a subscription\n', "   * @param _productId - the product we're checking\n", '   */\n', '  function isSubscriptionProduct(uint256 _productId) public view returns (bool) {\n', '    return intervalOf(_productId) > 0;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ERC165 {\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', 'contract LicenseOwnership is LicenseInventory, ERC721, ERC165, ERC721Metadata, ERC721Enumerable {\n', '  using SafeMath for uint256;\n', '\n', '  // Total amount of tokens\n', '  uint256 private totalTokens;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) private tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) private tokenApprovals;\n', '\n', '  // Mapping from owner address to operator address to approval\n', '  mapping (address => mapping (address => bool)) private operatorApprovals;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) private ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) private ownedTokensIndex;\n', '\n', '  /*** Constants ***/\n', '  // Configure these for your own deployment\n', '  string public constant NAME = "Dottabot";\n', '  string public constant SYMBOL = "DOTTA";\n', '  string public tokenMetadataBaseURI = "https://api.dottabot.com/";\n', '\n', '  /**\n', "   * @notice token's name\n", '   */\n', '  function name() external pure returns (string) {\n', '    return NAME;\n', '  }\n', '\n', '  /**\n', "   * @notice symbols's name\n", '   */\n', '  function symbol() external pure returns (string) {\n', '    return SYMBOL;\n', '  }\n', '\n', '  function implementsERC721() external pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string infoUrl)\n', '  {\n', '    return Strings.strConcat(\n', '      tokenMetadataBaseURI,\n', '      Strings.uint2str(_tokenId));\n', '  }\n', '\n', '  function supportsInterface(\n', '    bytes4 interfaceID) // solium-disable-line dotta/underscore-function-arguments\n', '    external view returns (bool)\n', '  {\n', '    return\n', '      interfaceID == this.supportsInterface.selector || // ERC165\n', '      interfaceID == 0x5b5e139f || // ERC721Metadata\n', '      interfaceID == 0x6466353c || // ERC-721 on 3/7/2018\n', '      interfaceID == 0x780e9d63; // ERC721Enumerable\n', '  }\n', '\n', '  function setTokenMetadataBaseURI(string _newBaseURI) external onlyCEOOrCOO {\n', '    tokenMetadataBaseURI = _newBaseURI;\n', '  }\n', '\n', '  /**\n', '  * @notice Guarantees msg.sender is owner of the given token\n', '  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '  */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the total amount of tokens stored by the contract\n', '  * @return uint256 representing the total amount of tokens\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalTokens;\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate valid NFTs\n', '  * @dev Our Licenses are kept in an array and each new License-token is just\n', '  * the next element in the array. This method is required for ERC721Enumerable\n', '  * which may support more complicated storage schemes. However, in our case the\n', '  * _index is the tokenId\n', '  * @param _index A counter less than `totalSupply()`\n', '  * @return The token identifier for the `_index`th NFT\n', '  */\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return _index;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the balance of the specified address\n', '  * @param _owner address to query the balance of\n', '  * @return uint256 representing the amount owned by the passed address\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokens[_owner].length;\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the list of tokens owned by a given address\n', '  * @param _owner address to query the tokens of\n', '  * @return uint256[] representing the list of tokens owned by the passed address\n', '  */\n', '  function tokensOf(address _owner) public view returns (uint256[]) {\n', '    return ownedTokens[_owner];\n', '  }\n', '\n', '  /**\n', '  * @notice Enumerate NFTs assigned to an owner\n', '  * @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  *  `_owner` is the zero address, representing invalid NFTs.\n', '  * @param _owner An address where we are interested in NFTs owned by them\n', '  * @param _index A counter less than `balanceOf(_owner)`\n', '  * @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    view\n', '    returns (uint256 _tokenId)\n', '  {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '  * @notice Gets the owner of the specified token ID\n', '  * @param _tokenId uint256 ID of the token to query the owner of\n', '  * @return owner address currently marked as the owner of the given token ID\n', '  */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the approved address to take ownership of a given token ID\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved to take ownership of the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved to transfer the given token ID or not\n', '   * Checks both for specific approval and operator approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether transfer by msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSenderApprovedFor(uint256 _tokenId) internal view returns (bool) {\n', '    return\n', '      ownerOf(_tokenId) == msg.sender ||\n', '      isSpecificallyApprovedFor(msg.sender, _tokenId) ||\n', '      isApprovedForAll(ownerOf(_tokenId), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether the msg.sender is approved for the given token ID or not\n', '   * @param _asker address of asking for approval\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return bool whether the msg.sender is approved for the given token ID or not\n', '   */\n', '  function isSpecificallyApprovedFor(address _asker, uint256 _tokenId) internal view returns (bool) {\n', '    return getApproved(_tokenId) == _asker;\n', '  }\n', '\n', '  /**\n', '   * @notice Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool)\n', '  {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of a given token ID to another address\n', '  * @param _to address to receive the ownership of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transfer(address _to, uint256 _tokenId)\n', '    external\n', '    whenNotPaused\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of the given token ID\n', '  * @param _to address to be approved for the given token ID\n', '  * @param _tokenId uint256 ID of the token to be approved\n', '  */\n', '  function approve(address _to, uint256 _tokenId)\n', '    external\n', '    whenNotPaused\n', '    onlyOwnerOf(_tokenId)\n', '  {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    if (getApproved(_tokenId) != 0 || _to != 0) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Enable or disable approval for a third party ("operator") to manage all your assets\n', '  * @dev Emits the ApprovalForAll event\n', '  * @param _to Address to add to the set of authorized operators.\n', '  * @param _approved True if the operators is approved, false to revoke approval\n', '  */\n', '  function setApprovalForAll(address _to, bool _approved)\n', '    external\n', '    whenNotPaused\n', '  {\n', '    if(_approved) {\n', '      approveAll(_to);\n', '    } else {\n', '      disapproveAll(_to);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Approves another address to claim for the ownership of any tokens owned by this account\n', '  * @param _to address to be approved for the given token ID\n', '  */\n', '  function approveAll(address _to)\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != msg.sender);\n', '    require(_to != address(0));\n', '    operatorApprovals[msg.sender][_to] = true;\n', '    ApprovalForAll(msg.sender, _to, true);\n', '  }\n', '\n', '  /**\n', '  * @notice Removes approval for another address to claim for the ownership of any\n', '  *  tokens owned by this account.\n', '  * @dev Note that this only removes the operator approval and\n', '  *  does not clear any independent, specific approvals of token transfers to this address\n', '  * @param _to address to be disapproved for the given token ID\n', '  */\n', '  function disapproveAll(address _to)\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != msg.sender);\n', '    delete operatorApprovals[msg.sender][_to];\n', '    ApprovalForAll(msg.sender, _to, false);\n', '  }\n', '\n', '  /**\n', '  * @notice Claims the ownership of a given token ID\n', '  * @param _tokenId uint256 ID of the token being claimed by the msg.sender\n', '  */\n', '  function takeOwnership(uint256 _tokenId)\n', '   external\n', '   whenNotPaused\n', '  {\n', '    require(isSenderApprovedFor(_tokenId));\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfer a token owned by another address, for which the calling address has\n', '  *  previously been granted transfer approval by the owner.\n', '  * @param _from The address that owns the token\n', '  * @param _to The address that will take ownership of the token. Can be any address, including the caller\n', '  * @param _tokenId The ID of the token to be transferred\n', '  */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(isSenderApprovedFor(_tokenId));\n', '    require(ownerOf(_tokenId) == _from);\n', '    _clearApprovalAndTransfer(ownerOf(_tokenId), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Transfers the ownership of an NFT from one address to another address\n', '  * @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  * operator, or the approved address for this NFT. Throws if `_from` is\n', '  * not the current owner. Throws if `_to` is the zero address. Throws if\n', '  * `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  * checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  * `onERC721Received` on `_to` and throws if the return value is not\n', '  * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  * @param _from The current owner of the NFT\n', '  * @param _to The new owner\n', '  * @param _tokenId The NFT to transfer\n', '  * @param _data Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_to != address(0));\n', '    require(_isValidLicense(_tokenId));\n', '    transferFrom(_from, _to, _tokenId);\n', '    if (_isContract(_to)) {\n', '      bytes4 tokenReceiverResponse = ERC721TokenReceiver(_to).onERC721Received.gas(50000)(\n', '        _from, _tokenId, _data\n', '      );\n', '      require(tokenReceiverResponse == bytes4(keccak256("onERC721Received(address,uint256,bytes)")));\n', '    }\n', '  }\n', '\n', '  /*\n', '   * @notice Transfers the ownership of an NFT from one address to another address\n', '   * @dev This works identically to the other function with an extra data parameter,\n', '   *  except this function just sets data to ""\n', '   * @param _from The current owner of the NFT\n', '   * @param _to The new owner\n', '   * @param _tokenId The NFT to transfer\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    whenNotPaused\n', '  {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '  * @notice Mint token function\n', '  * @param _to The address that will own the minted token\n', '  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '  */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    _addToken(_to, _tokenId);\n', '    Transfer(0x0, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval and transfer the ownership of a given token ID\n', '  * @param _from address which you want to send tokens from\n', '  * @param _to address which you want to transfer the token to\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    require(_to != ownerOf(_tokenId));\n', '    require(ownerOf(_tokenId) == _from);\n', '    require(_isValidLicense(_tokenId));\n', '\n', '    _clearApproval(_from, _tokenId);\n', '    _removeToken(_from, _tokenId);\n', '    _addToken(_to, _tokenId);\n', '    Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to clear current approval of a given token ID\n', '  * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function _clearApproval(address _owner, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    tokenApprovals[_tokenId] = 0;\n', '    Approval(_owner, 0, _tokenId);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to add a token ID to the list of a given address\n', '  * @param _to address representing the new owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '  */\n', '  function _addToken(address _to, uint256 _tokenId) private {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    uint256 length = balanceOf(_to);\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '    totalTokens = totalTokens.add(1);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal function to remove a token ID from the list of a given address\n', '  * @param _from address representing the previous owner of the given token ID\n', '  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '  */\n', '  function _removeToken(address _from, uint256 _tokenId) private {\n', '    require(ownerOf(_tokenId) == _from);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = balanceOf(_from).sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    tokenOwner[_tokenId] = 0;\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '    totalTokens = totalTokens.sub(1);\n', '  }\n', '\n', '  function _isContract(address addr) internal view returns (bool) {\n', '    uint size;\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', 'contract LicenseSale is LicenseOwnership {\n', '  AffiliateProgram public affiliateProgram;\n', '\n', '  /**\n', '   * @notice We credit affiliates for renewals that occur within this time of\n', '   * original purchase. E.g. If this is set to 1 year, and someone subscribes to\n', '   * a monthly plan, the affiliate will receive credits for that whole year, as\n', '   * the user renews their plan\n', '   */\n', '  uint256 public renewalsCreditAffiliatesFor = 1 years;\n', '\n', '  /** internal **/\n', '  function _performPurchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes,\n', '    address _affiliate)\n', '    internal returns (uint)\n', '  {\n', '    _purchaseOneUnitInStock(_productId);\n', '    return _createLicense(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      _attributes,\n', '      _affiliate\n', '      );\n', '  }\n', '\n', '  function _createLicense(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes,\n', '    address _affiliate)\n', '    internal\n', '    returns (uint)\n', '  {\n', '    // You cannot create a subscription license with zero cycles\n', '    if(isSubscriptionProduct(_productId)) {\n', '      require(_numCycles != 0);\n', '    }\n', '\n', '    // Non-subscription products have an expiration time of 0, meaning "no-expiration"\n', '    uint256 expirationTime = isSubscriptionProduct(_productId) ?\n', '      now.add(intervalOf(_productId).mul(_numCycles)) : // solium-disable-line security/no-block-members\n', '      0;\n', '\n', '    License memory _license = License({\n', '      productId: _productId,\n', '      attributes: _attributes,\n', '      issuedTime: now, // solium-disable-line security/no-block-members\n', '      expirationTime: expirationTime,\n', '      affiliate: _affiliate\n', '    });\n', '\n', '    uint256 newLicenseId = licenses.push(_license) - 1; // solium-disable-line zeppelin/no-arithmetic-operations\n', '    LicenseIssued(\n', '      _assignee,\n', '      msg.sender,\n', '      newLicenseId,\n', '      _license.productId,\n', '      _license.attributes,\n', '      _license.issuedTime,\n', '      _license.expirationTime,\n', '      _license.affiliate);\n', '    _mint(_assignee, newLicenseId);\n', '    return newLicenseId;\n', '  }\n', '\n', '  function _handleAffiliate(\n', '    address _affiliate,\n', '    uint256 _productId,\n', '    uint256 _licenseId,\n', '    uint256 _purchaseAmount)\n', '    internal\n', '  {\n', '    uint256 affiliateCut = affiliateProgram.cutFor(\n', '      _affiliate,\n', '      _productId,\n', '      _licenseId,\n', '      _purchaseAmount);\n', '    if(affiliateCut > 0) {\n', '      require(affiliateCut < _purchaseAmount);\n', '      affiliateProgram.credit.value(affiliateCut)(_affiliate, _licenseId);\n', '    }\n', '  }\n', '\n', '  function _performRenewal(uint256 _tokenId, uint256 _numCycles) internal {\n', '    // You cannot renew a non-expiring license\n', '    // ... but in what scenario can this happen?\n', '    // require(licenses[_tokenId].expirationTime != 0);\n', '    uint256 productId = licenseProductId(_tokenId);\n', '\n', '    // If our expiration is in the future, renewing adds time to that future expiration\n', '    // If our expiration has passed already, then we use `now` as the base.\n', '    uint256 renewalBaseTime = Math.max256(now, licenses[_tokenId].expirationTime);\n', '\n', '    // We assume that the payment has been validated outside of this function\n', '    uint256 newExpirationTime = renewalBaseTime.add(intervalOf(productId).mul(_numCycles));\n', '\n', '    licenses[_tokenId].expirationTime = newExpirationTime;\n', '\n', '    LicenseRenewal(\n', '      ownerOf(_tokenId),\n', '      msg.sender,\n', '      _tokenId,\n', '      productId,\n', '      newExpirationTime\n', '    );\n', '  }\n', '\n', '  function _affiliateProgramIsActive() internal view returns (bool) {\n', '    return\n', '      affiliateProgram != address(0) &&\n', '      affiliateProgram.storeAddress() == address(this) &&\n', '      !affiliateProgram.paused();\n', '  }\n', '\n', '  /** executives **/\n', '  function setAffiliateProgramAddress(address _address) external onlyCEO {\n', '    AffiliateProgram candidateContract = AffiliateProgram(_address);\n', '    require(candidateContract.isAffiliateProgram());\n', '    affiliateProgram = candidateContract;\n', '  }\n', '\n', '  function setRenewalsCreditAffiliatesFor(uint256 _newTime) external onlyCEO {\n', '    renewalsCreditAffiliatesFor = _newTime;\n', '  }\n', '\n', '  function createPromotionalPurchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    uint256 _attributes\n', '    )\n', '    external\n', '    onlyCEOOrCOO\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    return _performPurchase(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      _attributes,\n', '      address(0));\n', '  }\n', '\n', '  function createPromotionalRenewal(\n', '    uint256 _tokenId,\n', '    uint256 _numCycles\n', '    )\n', '    external\n', '    onlyCEOOrCOO\n', '    whenNotPaused\n', '  {\n', '    uint256 productId = licenseProductId(_tokenId);\n', '    _requireRenewableProduct(productId);\n', '\n', '    return _performRenewal(_tokenId, _numCycles);\n', '  }\n', '\n', '  /** anyone **/\n', '\n', '  /**\n', '  * @notice Makes a purchase of a product.\n', '  * @dev Requires that the value sent is exactly the price of the product\n', '  * @param _productId - the product to purchase\n', '  * @param _numCycles - the number of cycles being purchased. This number should be `1` for non-subscription products and the number of cycles for subscriptions.\n', "  * @param _assignee - the address to assign the purchase to (doesn't have to be msg.sender)\n", '  * @param _affiliate - the address to of the affiliate - use address(0) if none\n', '  */\n', '  function purchase(\n', '    uint256 _productId,\n', '    uint256 _numCycles,\n', '    address _assignee,\n', '    address _affiliate\n', '    )\n', '    external\n', '    payable\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    require(_productId != 0);\n', '    require(_numCycles != 0);\n', '    require(_assignee != address(0));\n', '    // msg.value can be zero: free products are supported\n', '\n', "    // Don't bother dealing with excess payments. Ensure the price paid is\n", '    // accurate. No more, no less.\n', '    require(msg.value == costForProductCycles(_productId, _numCycles));\n', '\n', "    // Non-subscription products should send a _numCycle of 1 -- you can't buy a\n", '    // multiple quantity of a non-subscription product with this function\n', '    if(!isSubscriptionProduct(_productId)) {\n', '      require(_numCycles == 1);\n', '    }\n', '\n', "    // this can, of course, be gamed by malicious miners. But it's adequate for our application\n", '    // Feel free to add your own strategies for product attributes\n', '    // solium-disable-next-line security/no-block-members, zeppelin/no-arithmetic-operations\n', '    uint256 attributes = uint256(keccak256(block.blockhash(block.number-1)))^_productId^(uint256(_assignee));\n', '    uint256 licenseId = _performPurchase(\n', '      _productId,\n', '      _numCycles,\n', '      _assignee,\n', '      attributes,\n', '      _affiliate);\n', '\n', '    if(\n', '      priceOf(_productId) > 0 &&\n', '      _affiliate != address(0) &&\n', '      _affiliateProgramIsActive()\n', '    ) {\n', '      _handleAffiliate(\n', '        _affiliate,\n', '        _productId,\n', '        licenseId,\n', '        msg.value);\n', '    }\n', '\n', '    return licenseId;\n', '  }\n', '\n', '  /**\n', '   * @notice Renews a subscription\n', '   */\n', '  function renew(\n', '    uint256 _tokenId,\n', '    uint256 _numCycles\n', '    )\n', '    external\n', '    payable\n', '    whenNotPaused\n', '  {\n', '    require(_numCycles != 0);\n', '    require(ownerOf(_tokenId) != address(0));\n', '\n', '    uint256 productId = licenseProductId(_tokenId);\n', '    _requireRenewableProduct(productId);\n', '\n', '    // No excess payments. Ensure the price paid is exactly accurate. No more,\n', '    // no less.\n', '    uint256 renewalCost = costForProductCycles(productId, _numCycles);\n', '    require(msg.value == renewalCost);\n', '\n', '    _performRenewal(_tokenId, _numCycles);\n', '\n', '    if(\n', '      renewalCost > 0 &&\n', '      licenseAffiliate(_tokenId) != address(0) &&\n', '      _affiliateProgramIsActive() &&\n', '      licenseIssuedTime(_tokenId).add(renewalsCreditAffiliatesFor) > now\n', '    ) {\n', '      _handleAffiliate(\n', '        licenseAffiliate(_tokenId),\n', '        productId,\n', '        _tokenId,\n', '        msg.value);\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract LicenseCore is LicenseSale {\n', '  address public newContractAddress;\n', '\n', '  function LicenseCore() public {\n', '    paused = true;\n', '\n', '    ceoAddress = msg.sender;\n', '    cooAddress = msg.sender;\n', '    cfoAddress = msg.sender;\n', '    withdrawalAddress = msg.sender;\n', '  }\n', '\n', '  function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n', '    newContractAddress = _v2Address;\n', '    ContractUpgrade(_v2Address);\n', '  }\n', '\n', '  function() external {\n', '    assert(false);\n', '  }\n', '\n', '  function unpause() public onlyCEO whenPaused {\n', '    require(newContractAddress == address(0));\n', '    super.unpause();\n', '  }\n', '}\n', '\n', 'library Strings {\n', '  // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '  function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n', '      bytes memory _ba = bytes(_a);\n', '      bytes memory _bb = bytes(_b);\n', '      bytes memory _bc = bytes(_c);\n', '      bytes memory _bd = bytes(_d);\n', '      bytes memory _be = bytes(_e);\n', '      string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '      bytes memory babcde = bytes(abcde);\n', '      uint k = 0;\n', '      for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '      for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '      for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '      for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '      for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '      return string(babcde);\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function uint2str(uint i) internal pure returns (string) {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}']
