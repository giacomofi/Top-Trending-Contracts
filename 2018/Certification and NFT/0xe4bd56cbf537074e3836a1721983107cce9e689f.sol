['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send or transfer.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '\n', '  // Called by children of this contract to remove value from an account\n', '  function asyncDebit(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].sub(amount);\n', '    totalPayments = totalPayments.sub(amount);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * Sorted list of sales for use in the marketplace. Sorting is maintained by linked list.\n', ' */\n', 'library SaleListLib {\n', '  address public constant nullAddress = address(0);\n', '\n', '  struct SaleList {\n', '    address head;\n', '\n', '    mapping(address => address) sellerListMapping;\n', '    mapping(address => uint) sellerToPrice;\n', '  }\n', '\n', '  function getBest(SaleList storage self) public view returns (address, uint) {\n', '    address head = self.head;\n', '    return (head, self.sellerToPrice[head]);\n', '  }\n', '\n', '  function addSale(SaleList storage self, address seller, uint price) public {\n', '    require(price != 0);\n', '    require(seller != nullAddress);\n', '\n', '    if (_contains(self, seller)) {\n', '      removeSale(self, seller);\n', '    }\n', '\n', '    self.sellerToPrice[seller] = price;\n', '    if (self.head == nullAddress || price <= self.sellerToPrice[self.head]) {\n', '      self.sellerListMapping[seller] = self.head;\n', '      self.head = seller;\n', '    } else {\n', '      address prev = self.head;\n', '      address cur = self.sellerListMapping[prev];\n', '\n', '      while (cur != nullAddress) {\n', '        if (price <= self.sellerToPrice[cur]) {\n', '          self.sellerListMapping[prev] = seller;\n', '          self.sellerListMapping[seller] = cur;\n', '\n', '          break;\n', '        }\n', '\n', '        prev = cur;\n', '        cur = self.sellerListMapping[cur];\n', '      }\n', '\n', '      // Insert value greater than all values in list\n', '      if (cur == nullAddress) {\n', '        self.sellerListMapping[prev] = seller;\n', '      }\n', '    }\n', '  }\n', '\n', '  function removeSale(SaleList storage self, address seller) public returns (bool) {\n', '    require(seller != nullAddress);\n', '\n', '    if (!_contains(self, seller)) {\n', '      return false;\n', '    }\n', '\n', '    if (seller == self.head) {\n', '      self.head = self.sellerListMapping[seller];\n', '      _remove(self, seller);\n', '    } else {\n', '      address prev = self.head;\n', '      address cur = self.sellerListMapping[prev];\n', '\n', '      // TODO: Make SURE that initialized mapping with address vals initializes those vals to address(0)\n', '      // NOTE: Redundant check (prev != seller)\n', '      while (cur != nullAddress && prev != seller) {\n', '        if (cur == seller) {\n', '          self.sellerListMapping[prev] = self.sellerListMapping[seller];\n', '          _remove(self, seller);\n', '\n', '          break;\n', '        }\n', '\n', '        prev = cur;\n', '        cur = self.sellerListMapping[cur];\n', '      }\n', '\n', '      // NOTE: Redundant check\n', '      if (cur == nullAddress) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  // NOTE: This is a purely internal method that *only* zeros out sellerListMapping and sellerToPrice\n', '  function _remove(SaleList storage self, address seller) internal {\n', '    self.sellerToPrice[seller] = 0;\n', '    self.sellerListMapping[seller] = nullAddress;\n', '  }\n', '\n', '  function _contains(SaleList storage self, address seller) view internal returns (bool) {\n', '    return self.sellerToPrice[seller] != 0;\n', '  }\n', '}\n', '\n', 'contract SaleRegistry is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  /////////\n', '  // Events\n', '  /////////\n', '\n', '  event SalePosted(\n', '    address indexed _seller,\n', '    bytes32 indexed _sig,\n', '    uint256 _price\n', '  );\n', '\n', '  event SaleCancelled(\n', '    address indexed _seller,\n', '    bytes32 indexed _sig\n', '  );\n', '\n', '  ////////\n', '  // State\n', '  ////////\n', '\n', '  mapping(bytes32 => SaleListLib.SaleList) _sigToSortedSales;\n', '\n', '  mapping(address => mapping(bytes32 => uint256)) _addressToSigToSalePrice;\n', '\n', '  // NOTE: Rules are different for contract owner. Can run many sales at a time, all at a single price. This\n', '  // allows multi-sale at genesis time\n', '  mapping(bytes32 => uint256) _ownerSigToNumSales;\n', '\n', '  mapping(bytes32 => uint256) public sigToNumSales;\n', '\n', '  /////////////\n', '  // User views\n', '  /////////////\n', '\n', '  // Returns (seller, price) tuple\n', '  function getBestSale(bytes32 sig) public view returns (address, uint256) {\n', '    return SaleListLib.getBest(_sigToSortedSales[sig]);\n', '  }\n', '\n', '  // Returns price that the sender is selling the current sig for (or 0 if not)\n', '  function getMySalePrice(bytes32 sig) public view returns (uint256) {\n', '    return _addressToSigToSalePrice[msg.sender][sig];\n', '  }\n', '\n', '  ///////////////\n', '  // User actions\n', '  ///////////////\n', '\n', '  // Convenience method used *only* at genesis sale time\n', '  function postGenesisSales(bytes32 sig, uint256 price, uint256 numSales) internal onlyOwner {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], owner, price);\n', '    _addressToSigToSalePrice[owner][sig] = price;\n', '\n', '    _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(numSales);\n', '    sigToNumSales[sig] = sigToNumSales[sig].add(numSales);\n', '\n', '    emit SalePosted(owner, sig, price);\n', '  }\n', '\n', '  // Admin method for re-listing all genesis sales\n', '  function relistGenesisSales(bytes32 sig, uint256 newPrice) external onlyOwner {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], owner, newPrice);\n', '    _addressToSigToSalePrice[owner][sig] = newPrice;\n', '\n', '    emit SalePosted(owner, sig, newPrice);\n', '  }\n', '\n', '  // NOTE: Only allows 1 active sale per address per sig, unless owner\n', '  function postSale(address seller, bytes32 sig, uint256 price) internal {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], seller, price);\n', '    _addressToSigToSalePrice[seller][sig] = price;\n', '\n', '    sigToNumSales[sig] = sigToNumSales[sig].add(1);\n', '\n', '    if (seller == owner) {\n', '      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(1);\n', '    }\n', '\n', '    emit SalePosted(seller, sig, price);\n', '  }\n', '\n', '  // NOTE: Special remove logic for contract owner&#39;s sale!\n', '  function cancelSale(address seller, bytes32 sig) internal {\n', '    if (seller == owner) {\n', '      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].sub(1);\n', '\n', '      if (_ownerSigToNumSales[sig] == 0) {\n', '        SaleListLib.removeSale(_sigToSortedSales[sig], seller);\n', '        _addressToSigToSalePrice[seller][sig] = 0;\n', '      }\n', '    } else {\n', '      SaleListLib.removeSale(_sigToSortedSales[sig], seller);\n', '      _addressToSigToSalePrice[seller][sig] = 0;\n', '    }\n', '    sigToNumSales[sig] = sigToNumSales[sig].sub(1);\n', '\n', '    emit SaleCancelled(seller, sig);\n', '  }\n', '}\n', '\n', 'contract OwnerRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  /////////\n', '  // Events\n', '  /////////\n', '\n', '  event CardCreated(\n', '    bytes32 indexed _sig,\n', '    uint256 _numAdded\n', '  );\n', '\n', '  event CardsTransferred(\n', '    bytes32 indexed _sig,\n', '    address indexed _oldOwner,\n', '    address indexed _newOwner,\n', '    uint256 _count\n', '  );\n', '\n', '  ////////\n', '  // State\n', '  ////////\n', '\n', '  bytes32[] _allSigs;\n', '  mapping(address => mapping(bytes32 => uint256)) _ownerToSigToCount;\n', '  mapping(bytes32 => uint256) _sigToCount;\n', '\n', '  ////////////////\n', '  // Admin actions\n', '  ////////////////\n', '\n', '  function addCardToRegistry(address owner, bytes32 sig, uint256 numToAdd) internal {\n', '    // Only allow adding cards that haven&#39;t already been added\n', '    require(_sigToCount[sig] == 0);\n', '\n', '    _allSigs.push(sig);\n', '    _ownerToSigToCount[owner][sig] = numToAdd;\n', '    _sigToCount[sig] = numToAdd;\n', '\n', '    emit CardCreated(sig, numToAdd);\n', '  }\n', '\n', '  /////////////\n', '  // User views\n', '  /////////////\n', '\n', '  function getAllSigs() public view returns (bytes32[]) {\n', '    return _allSigs;\n', '  }\n', '\n', '  function getNumSigsOwned(bytes32 sig) public view returns (uint256) {\n', '    return _ownerToSigToCount[msg.sender][sig];\n', '  }\n', '\n', '  function getNumSigs(bytes32 sig) public view returns (uint256) {\n', '    return _sigToCount[sig];\n', '  }\n', '\n', '  ///////////////////\n', '  // Transfer actions\n', '  ///////////////////\n', '\n', '  function registryTransfer(address oldOwner, address newOwner, bytes32 sig, uint256 count) internal {\n', '    // Must be transferring at least one card!\n', '    require(count > 0);\n', '\n', '    // Don&#39;t allow a transfer when the old owner doesn&#39;t enough of the card\n', '    require(_ownerToSigToCount[oldOwner][sig] >= count);\n', '\n', '    _ownerToSigToCount[oldOwner][sig] = _ownerToSigToCount[oldOwner][sig].sub(count);\n', '    _ownerToSigToCount[newOwner][sig] = _ownerToSigToCount[newOwner][sig].add(count);\n', '\n', '    emit CardsTransferred(sig, oldOwner, newOwner, count);\n', '  }\n', '}\n', '\n', 'contract ArtistRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(bytes32 => address) _sigToArtist;\n', '\n', '  // fee tuple is of form (txFeePercent, genesisSalePercent)\n', '  mapping(bytes32 => uint256[2]) _sigToFeeTuple;\n', '\n', '  function addArtistToRegistry(bytes32 sig,\n', '                               address artist,\n', '                               uint256 txFeePercent,\n', '                               uint256 genesisSalePercent) internal {\n', '    // Must be a valid artist address!\n', '    require(artist != address(0));\n', '\n', '    // Only allow 1 sig per artist!\n', '    require(_sigToArtist[sig] == address(0));\n', '\n', '    _sigToArtist[sig] = artist;\n', '    _sigToFeeTuple[sig] = [txFeePercent, genesisSalePercent];\n', '  }\n', '\n', '  function computeArtistTxFee(bytes32 sig, uint256 txFee) internal view returns (uint256) {\n', '    uint256 feePercent = _sigToFeeTuple[sig][0];\n', '    return (txFee.mul(feePercent)).div(100);\n', '  }\n', '\n', '  function computeArtistGenesisSaleFee(bytes32 sig, uint256 genesisSaleProfit) internal view returns (uint256) {\n', '    uint256 feePercent = _sigToFeeTuple[sig][1];\n', '    return (genesisSaleProfit.mul(feePercent)).div(100);\n', '  }\n', '\n', '  function getArtist(bytes32 sig) internal view returns (address) {\n', '    return _sigToArtist[sig];\n', '  }\n', '}\n', '\n', 'contract PepeCore is PullPayment, OwnerRegistry, SaleRegistry, ArtistRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 constant public totalTxFeePercent = 4;\n', '\n', '  ////////////////////\n', '  // Shareholder stuff\n', '  ////////////////////\n', '\n', '  // Only 3 equal shareholders max allowed on this contract representing the three equal-partner founders\n', '  // involved in its inception\n', '  address public shareholder1;\n', '  address public shareholder2;\n', '  address public shareholder3;\n', '\n', '  // 0 -> 3 depending on contract state. I only use uint256 so that I can use SafeMath...\n', '  uint256 public numShareholders = 0;\n', '\n', '  // Used to set initial shareholders\n', '  function addShareholderAddress(address newShareholder) external onlyOwner {\n', '    // Don&#39;t let shareholder be address(0)\n', '    require(newShareholder != address(0));\n', '\n', '    // Contract owner can&#39;t be a shareholder\n', '    require(newShareholder != owner);\n', '\n', '    // Must be an open shareholder spot!\n', '    require(shareholder1 == address(0) || shareholder2 == address(0) || shareholder3 == address(0));\n', '\n', '    if (shareholder1 == address(0)) {\n', '      shareholder1 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    } else if (shareholder2 == address(0)) {\n', '      shareholder2 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    } else if (shareholder3 == address(0)) {\n', '      shareholder3 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    }\n', '  }\n', '\n', '  // Splits the amount specified among shareholders equally\n', '  function payShareholders(uint256 amount) internal {\n', '    // If no shareholders, shareholder fees will be held in contract to be withdrawable by owner\n', '    if (numShareholders > 0) {\n', '      uint256 perShareholderFee = amount.div(numShareholders);\n', '\n', '      if (shareholder1 != address(0)) {\n', '        asyncSend(shareholder1, perShareholderFee);\n', '      }\n', '\n', '      if (shareholder2 != address(0)) {\n', '        asyncSend(shareholder2, perShareholderFee);\n', '      }\n', '\n', '      if (shareholder3 != address(0)) {\n', '        asyncSend(shareholder3, perShareholderFee);\n', '      }\n', '    }\n', '  }\n', '\n', '  ////////////////\n', '  // Admin actions\n', '  ////////////////\n', '\n', '  function withdrawContractBalance() external onlyOwner {\n', '    uint256 contractBalance = address(this).balance;\n', '    uint256 withdrawableBalance = contractBalance.sub(totalPayments);\n', '\n', '    // No withdrawal necessary if <= 0 balance\n', '    require(withdrawableBalance > 0);\n', '\n', '    msg.sender.transfer(withdrawableBalance);\n', '  }\n', '\n', '  function addCard(bytes32 sig,\n', '                   address artist,\n', '                   uint256 txFeePercent,\n', '                   uint256 genesisSalePercent,\n', '                   uint256 numToAdd,\n', '                   uint256 startingPrice) external onlyOwner {\n', '    addCardToRegistry(owner, sig, numToAdd);\n', '\n', '    addArtistToRegistry(sig, artist, txFeePercent, genesisSalePercent);\n', '\n', '    postGenesisSales(sig, startingPrice, numToAdd);\n', '  }\n', '\n', '  ///////////////\n', '  // User actions\n', '  ///////////////\n', '\n', '  function createSale(bytes32 sig, uint256 price) external {\n', '    // Can&#39;t sell a card for 0... May want other limits in the future\n', '    require(price > 0);\n', '\n', '    // Can&#39;t sell a card you don&#39;t own\n', '    require(getNumSigsOwned(sig) > 0);\n', '\n', '    // Can&#39;t post a sale if you have one posted already! Unless you&#39;re the contract owner\n', '    require(msg.sender == owner || _addressToSigToSalePrice[msg.sender][sig] == 0);\n', '\n', '    postSale(msg.sender, sig, price);\n', '  }\n', '\n', '  function removeSale(bytes32 sig) public {\n', '    // Can&#39;t cancel a sale that doesn&#39;t exist\n', '    require(_addressToSigToSalePrice[msg.sender][sig] > 0);\n', '\n', '    cancelSale(msg.sender, sig);\n', '  }\n', '\n', '  function computeTxFee(uint256 price) private pure returns (uint256) {\n', '    return (price * totalTxFeePercent) / 100;\n', '  }\n', '\n', '  // If card is held by contract owner, split among artist + shareholders\n', '  function paySellerFee(bytes32 sig, address seller, uint256 sellerProfit) private {\n', '    if (seller == owner) {\n', '      address artist = getArtist(sig);\n', '      uint256 artistFee = computeArtistGenesisSaleFee(sig, sellerProfit);\n', '      asyncSend(artist, artistFee);\n', '\n', '      payShareholders(sellerProfit.sub(artistFee));\n', '    } else {\n', '      asyncSend(seller, sellerProfit);\n', '    }\n', '  }\n', '\n', '  // Simply pay out tx fees appropriately\n', '  function payTxFees(bytes32 sig, uint256 txFee) private {\n', '    uint256 artistFee = computeArtistTxFee(sig, txFee);\n', '    address artist = getArtist(sig);\n', '    asyncSend(artist, artistFee);\n', '\n', '    payShareholders(txFee.sub(artistFee));\n', '  }\n', '\n', '  // Handle wallet debit if necessary, pay out fees, pay out seller profit, cancel sale, transfer card\n', '  function buy(bytes32 sig) external payable {\n', '    address seller;\n', '    uint256 price;\n', '    (seller, price) = getBestSale(sig);\n', '\n', '    // There must be a valid sale for the card\n', '    require(price > 0 && seller != address(0));\n', '\n', '    // Buyer must have enough Eth via wallet and payment to cover posted price\n', '    uint256 availableEth = msg.value.add(payments[msg.sender]);\n', '    require(availableEth >= price);\n', '\n', '    // Debit wallet if msg doesn&#39;t have enough value to cover price\n', '    if (msg.value < price) {\n', '      asyncDebit(msg.sender, price.sub(msg.value));\n', '    }\n', '\n', '    // Split out fees + seller profit\n', '    uint256 txFee = computeTxFee(price);\n', '    uint256 sellerProfit = price.sub(txFee);\n', '\n', '    // Pay out seller (special logic for seller == owner)\n', '    paySellerFee(sig, seller, sellerProfit);\n', '\n', '    // Pay out tx fees\n', '    payTxFees(sig, txFee);\n', '\n', '    // Cancel sale\n', '    cancelSale(seller, sig);\n', '\n', '    // Transfer single sig ownership in registry\n', '    registryTransfer(seller, msg.sender, sig, 1);\n', '  }\n', '\n', '  // Can also be used in airdrops, etc.\n', '  function transferSig(bytes32 sig, uint256 count, address newOwner) external {\n', '    uint256 numOwned = getNumSigsOwned(sig);\n', '\n', '    // Can&#39;t transfer cards you don&#39;t own\n', '    require(numOwned >= count);\n', '\n', '    // If transferring from contract owner, cancel the proper number of sales if necessary\n', '    if (msg.sender == owner) {\n', '      uint256 remaining = numOwned.sub(count);\n', '\n', '      if (remaining < _ownerSigToNumSales[sig]) {\n', '        uint256 numSalesToCancel = _ownerSigToNumSales[sig].sub(remaining);\n', '\n', '        for (uint256 i = 0; i < numSalesToCancel; i++) {\n', '          removeSale(sig);\n', '        }\n', '      }\n', '    } else {\n', '      // Remove existing sale if transferring all owned cards\n', '      if (numOwned == count && _addressToSigToSalePrice[msg.sender][sig] > 0) {\n', '        removeSale(sig);\n', '      }\n', '    }\n', '\n', '    // Transfer in registry\n', '    registryTransfer(msg.sender, newOwner, sig, count);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments. Inherit from this\n', ' * contract and use asyncSend instead of send or transfer.\n', ' */\n', 'contract PullPayment {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) public payments;\n', '  uint256 public totalPayments;\n', '\n', '  /**\n', '  * @dev Withdraw accumulated balance, called by payee.\n', '  */\n', '  function withdrawPayments() public {\n', '    address payee = msg.sender;\n', '    uint256 payment = payments[payee];\n', '\n', '    require(payment != 0);\n', '    require(address(this).balance >= payment);\n', '\n', '    totalPayments = totalPayments.sub(payment);\n', '    payments[payee] = 0;\n', '\n', '    payee.transfer(payment);\n', '  }\n', '\n', '  /**\n', '  * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '  * @param dest The destination address of the funds.\n', '  * @param amount The amount to transfer.\n', '  */\n', '  function asyncSend(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].add(amount);\n', '    totalPayments = totalPayments.add(amount);\n', '  }\n', '\n', '  // Called by children of this contract to remove value from an account\n', '  function asyncDebit(address dest, uint256 amount) internal {\n', '    payments[dest] = payments[dest].sub(amount);\n', '    totalPayments = totalPayments.sub(amount);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * Sorted list of sales for use in the marketplace. Sorting is maintained by linked list.\n', ' */\n', 'library SaleListLib {\n', '  address public constant nullAddress = address(0);\n', '\n', '  struct SaleList {\n', '    address head;\n', '\n', '    mapping(address => address) sellerListMapping;\n', '    mapping(address => uint) sellerToPrice;\n', '  }\n', '\n', '  function getBest(SaleList storage self) public view returns (address, uint) {\n', '    address head = self.head;\n', '    return (head, self.sellerToPrice[head]);\n', '  }\n', '\n', '  function addSale(SaleList storage self, address seller, uint price) public {\n', '    require(price != 0);\n', '    require(seller != nullAddress);\n', '\n', '    if (_contains(self, seller)) {\n', '      removeSale(self, seller);\n', '    }\n', '\n', '    self.sellerToPrice[seller] = price;\n', '    if (self.head == nullAddress || price <= self.sellerToPrice[self.head]) {\n', '      self.sellerListMapping[seller] = self.head;\n', '      self.head = seller;\n', '    } else {\n', '      address prev = self.head;\n', '      address cur = self.sellerListMapping[prev];\n', '\n', '      while (cur != nullAddress) {\n', '        if (price <= self.sellerToPrice[cur]) {\n', '          self.sellerListMapping[prev] = seller;\n', '          self.sellerListMapping[seller] = cur;\n', '\n', '          break;\n', '        }\n', '\n', '        prev = cur;\n', '        cur = self.sellerListMapping[cur];\n', '      }\n', '\n', '      // Insert value greater than all values in list\n', '      if (cur == nullAddress) {\n', '        self.sellerListMapping[prev] = seller;\n', '      }\n', '    }\n', '  }\n', '\n', '  function removeSale(SaleList storage self, address seller) public returns (bool) {\n', '    require(seller != nullAddress);\n', '\n', '    if (!_contains(self, seller)) {\n', '      return false;\n', '    }\n', '\n', '    if (seller == self.head) {\n', '      self.head = self.sellerListMapping[seller];\n', '      _remove(self, seller);\n', '    } else {\n', '      address prev = self.head;\n', '      address cur = self.sellerListMapping[prev];\n', '\n', '      // TODO: Make SURE that initialized mapping with address vals initializes those vals to address(0)\n', '      // NOTE: Redundant check (prev != seller)\n', '      while (cur != nullAddress && prev != seller) {\n', '        if (cur == seller) {\n', '          self.sellerListMapping[prev] = self.sellerListMapping[seller];\n', '          _remove(self, seller);\n', '\n', '          break;\n', '        }\n', '\n', '        prev = cur;\n', '        cur = self.sellerListMapping[cur];\n', '      }\n', '\n', '      // NOTE: Redundant check\n', '      if (cur == nullAddress) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  // NOTE: This is a purely internal method that *only* zeros out sellerListMapping and sellerToPrice\n', '  function _remove(SaleList storage self, address seller) internal {\n', '    self.sellerToPrice[seller] = 0;\n', '    self.sellerListMapping[seller] = nullAddress;\n', '  }\n', '\n', '  function _contains(SaleList storage self, address seller) view internal returns (bool) {\n', '    return self.sellerToPrice[seller] != 0;\n', '  }\n', '}\n', '\n', 'contract SaleRegistry is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  /////////\n', '  // Events\n', '  /////////\n', '\n', '  event SalePosted(\n', '    address indexed _seller,\n', '    bytes32 indexed _sig,\n', '    uint256 _price\n', '  );\n', '\n', '  event SaleCancelled(\n', '    address indexed _seller,\n', '    bytes32 indexed _sig\n', '  );\n', '\n', '  ////////\n', '  // State\n', '  ////////\n', '\n', '  mapping(bytes32 => SaleListLib.SaleList) _sigToSortedSales;\n', '\n', '  mapping(address => mapping(bytes32 => uint256)) _addressToSigToSalePrice;\n', '\n', '  // NOTE: Rules are different for contract owner. Can run many sales at a time, all at a single price. This\n', '  // allows multi-sale at genesis time\n', '  mapping(bytes32 => uint256) _ownerSigToNumSales;\n', '\n', '  mapping(bytes32 => uint256) public sigToNumSales;\n', '\n', '  /////////////\n', '  // User views\n', '  /////////////\n', '\n', '  // Returns (seller, price) tuple\n', '  function getBestSale(bytes32 sig) public view returns (address, uint256) {\n', '    return SaleListLib.getBest(_sigToSortedSales[sig]);\n', '  }\n', '\n', '  // Returns price that the sender is selling the current sig for (or 0 if not)\n', '  function getMySalePrice(bytes32 sig) public view returns (uint256) {\n', '    return _addressToSigToSalePrice[msg.sender][sig];\n', '  }\n', '\n', '  ///////////////\n', '  // User actions\n', '  ///////////////\n', '\n', '  // Convenience method used *only* at genesis sale time\n', '  function postGenesisSales(bytes32 sig, uint256 price, uint256 numSales) internal onlyOwner {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], owner, price);\n', '    _addressToSigToSalePrice[owner][sig] = price;\n', '\n', '    _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(numSales);\n', '    sigToNumSales[sig] = sigToNumSales[sig].add(numSales);\n', '\n', '    emit SalePosted(owner, sig, price);\n', '  }\n', '\n', '  // Admin method for re-listing all genesis sales\n', '  function relistGenesisSales(bytes32 sig, uint256 newPrice) external onlyOwner {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], owner, newPrice);\n', '    _addressToSigToSalePrice[owner][sig] = newPrice;\n', '\n', '    emit SalePosted(owner, sig, newPrice);\n', '  }\n', '\n', '  // NOTE: Only allows 1 active sale per address per sig, unless owner\n', '  function postSale(address seller, bytes32 sig, uint256 price) internal {\n', '    SaleListLib.addSale(_sigToSortedSales[sig], seller, price);\n', '    _addressToSigToSalePrice[seller][sig] = price;\n', '\n', '    sigToNumSales[sig] = sigToNumSales[sig].add(1);\n', '\n', '    if (seller == owner) {\n', '      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].add(1);\n', '    }\n', '\n', '    emit SalePosted(seller, sig, price);\n', '  }\n', '\n', "  // NOTE: Special remove logic for contract owner's sale!\n", '  function cancelSale(address seller, bytes32 sig) internal {\n', '    if (seller == owner) {\n', '      _ownerSigToNumSales[sig] = _ownerSigToNumSales[sig].sub(1);\n', '\n', '      if (_ownerSigToNumSales[sig] == 0) {\n', '        SaleListLib.removeSale(_sigToSortedSales[sig], seller);\n', '        _addressToSigToSalePrice[seller][sig] = 0;\n', '      }\n', '    } else {\n', '      SaleListLib.removeSale(_sigToSortedSales[sig], seller);\n', '      _addressToSigToSalePrice[seller][sig] = 0;\n', '    }\n', '    sigToNumSales[sig] = sigToNumSales[sig].sub(1);\n', '\n', '    emit SaleCancelled(seller, sig);\n', '  }\n', '}\n', '\n', 'contract OwnerRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  /////////\n', '  // Events\n', '  /////////\n', '\n', '  event CardCreated(\n', '    bytes32 indexed _sig,\n', '    uint256 _numAdded\n', '  );\n', '\n', '  event CardsTransferred(\n', '    bytes32 indexed _sig,\n', '    address indexed _oldOwner,\n', '    address indexed _newOwner,\n', '    uint256 _count\n', '  );\n', '\n', '  ////////\n', '  // State\n', '  ////////\n', '\n', '  bytes32[] _allSigs;\n', '  mapping(address => mapping(bytes32 => uint256)) _ownerToSigToCount;\n', '  mapping(bytes32 => uint256) _sigToCount;\n', '\n', '  ////////////////\n', '  // Admin actions\n', '  ////////////////\n', '\n', '  function addCardToRegistry(address owner, bytes32 sig, uint256 numToAdd) internal {\n', "    // Only allow adding cards that haven't already been added\n", '    require(_sigToCount[sig] == 0);\n', '\n', '    _allSigs.push(sig);\n', '    _ownerToSigToCount[owner][sig] = numToAdd;\n', '    _sigToCount[sig] = numToAdd;\n', '\n', '    emit CardCreated(sig, numToAdd);\n', '  }\n', '\n', '  /////////////\n', '  // User views\n', '  /////////////\n', '\n', '  function getAllSigs() public view returns (bytes32[]) {\n', '    return _allSigs;\n', '  }\n', '\n', '  function getNumSigsOwned(bytes32 sig) public view returns (uint256) {\n', '    return _ownerToSigToCount[msg.sender][sig];\n', '  }\n', '\n', '  function getNumSigs(bytes32 sig) public view returns (uint256) {\n', '    return _sigToCount[sig];\n', '  }\n', '\n', '  ///////////////////\n', '  // Transfer actions\n', '  ///////////////////\n', '\n', '  function registryTransfer(address oldOwner, address newOwner, bytes32 sig, uint256 count) internal {\n', '    // Must be transferring at least one card!\n', '    require(count > 0);\n', '\n', "    // Don't allow a transfer when the old owner doesn't enough of the card\n", '    require(_ownerToSigToCount[oldOwner][sig] >= count);\n', '\n', '    _ownerToSigToCount[oldOwner][sig] = _ownerToSigToCount[oldOwner][sig].sub(count);\n', '    _ownerToSigToCount[newOwner][sig] = _ownerToSigToCount[newOwner][sig].add(count);\n', '\n', '    emit CardsTransferred(sig, oldOwner, newOwner, count);\n', '  }\n', '}\n', '\n', 'contract ArtistRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(bytes32 => address) _sigToArtist;\n', '\n', '  // fee tuple is of form (txFeePercent, genesisSalePercent)\n', '  mapping(bytes32 => uint256[2]) _sigToFeeTuple;\n', '\n', '  function addArtistToRegistry(bytes32 sig,\n', '                               address artist,\n', '                               uint256 txFeePercent,\n', '                               uint256 genesisSalePercent) internal {\n', '    // Must be a valid artist address!\n', '    require(artist != address(0));\n', '\n', '    // Only allow 1 sig per artist!\n', '    require(_sigToArtist[sig] == address(0));\n', '\n', '    _sigToArtist[sig] = artist;\n', '    _sigToFeeTuple[sig] = [txFeePercent, genesisSalePercent];\n', '  }\n', '\n', '  function computeArtistTxFee(bytes32 sig, uint256 txFee) internal view returns (uint256) {\n', '    uint256 feePercent = _sigToFeeTuple[sig][0];\n', '    return (txFee.mul(feePercent)).div(100);\n', '  }\n', '\n', '  function computeArtistGenesisSaleFee(bytes32 sig, uint256 genesisSaleProfit) internal view returns (uint256) {\n', '    uint256 feePercent = _sigToFeeTuple[sig][1];\n', '    return (genesisSaleProfit.mul(feePercent)).div(100);\n', '  }\n', '\n', '  function getArtist(bytes32 sig) internal view returns (address) {\n', '    return _sigToArtist[sig];\n', '  }\n', '}\n', '\n', 'contract PepeCore is PullPayment, OwnerRegistry, SaleRegistry, ArtistRegistry {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 constant public totalTxFeePercent = 4;\n', '\n', '  ////////////////////\n', '  // Shareholder stuff\n', '  ////////////////////\n', '\n', '  // Only 3 equal shareholders max allowed on this contract representing the three equal-partner founders\n', '  // involved in its inception\n', '  address public shareholder1;\n', '  address public shareholder2;\n', '  address public shareholder3;\n', '\n', '  // 0 -> 3 depending on contract state. I only use uint256 so that I can use SafeMath...\n', '  uint256 public numShareholders = 0;\n', '\n', '  // Used to set initial shareholders\n', '  function addShareholderAddress(address newShareholder) external onlyOwner {\n', "    // Don't let shareholder be address(0)\n", '    require(newShareholder != address(0));\n', '\n', "    // Contract owner can't be a shareholder\n", '    require(newShareholder != owner);\n', '\n', '    // Must be an open shareholder spot!\n', '    require(shareholder1 == address(0) || shareholder2 == address(0) || shareholder3 == address(0));\n', '\n', '    if (shareholder1 == address(0)) {\n', '      shareholder1 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    } else if (shareholder2 == address(0)) {\n', '      shareholder2 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    } else if (shareholder3 == address(0)) {\n', '      shareholder3 = newShareholder;\n', '      numShareholders = numShareholders.add(1);\n', '    }\n', '  }\n', '\n', '  // Splits the amount specified among shareholders equally\n', '  function payShareholders(uint256 amount) internal {\n', '    // If no shareholders, shareholder fees will be held in contract to be withdrawable by owner\n', '    if (numShareholders > 0) {\n', '      uint256 perShareholderFee = amount.div(numShareholders);\n', '\n', '      if (shareholder1 != address(0)) {\n', '        asyncSend(shareholder1, perShareholderFee);\n', '      }\n', '\n', '      if (shareholder2 != address(0)) {\n', '        asyncSend(shareholder2, perShareholderFee);\n', '      }\n', '\n', '      if (shareholder3 != address(0)) {\n', '        asyncSend(shareholder3, perShareholderFee);\n', '      }\n', '    }\n', '  }\n', '\n', '  ////////////////\n', '  // Admin actions\n', '  ////////////////\n', '\n', '  function withdrawContractBalance() external onlyOwner {\n', '    uint256 contractBalance = address(this).balance;\n', '    uint256 withdrawableBalance = contractBalance.sub(totalPayments);\n', '\n', '    // No withdrawal necessary if <= 0 balance\n', '    require(withdrawableBalance > 0);\n', '\n', '    msg.sender.transfer(withdrawableBalance);\n', '  }\n', '\n', '  function addCard(bytes32 sig,\n', '                   address artist,\n', '                   uint256 txFeePercent,\n', '                   uint256 genesisSalePercent,\n', '                   uint256 numToAdd,\n', '                   uint256 startingPrice) external onlyOwner {\n', '    addCardToRegistry(owner, sig, numToAdd);\n', '\n', '    addArtistToRegistry(sig, artist, txFeePercent, genesisSalePercent);\n', '\n', '    postGenesisSales(sig, startingPrice, numToAdd);\n', '  }\n', '\n', '  ///////////////\n', '  // User actions\n', '  ///////////////\n', '\n', '  function createSale(bytes32 sig, uint256 price) external {\n', "    // Can't sell a card for 0... May want other limits in the future\n", '    require(price > 0);\n', '\n', "    // Can't sell a card you don't own\n", '    require(getNumSigsOwned(sig) > 0);\n', '\n', "    // Can't post a sale if you have one posted already! Unless you're the contract owner\n", '    require(msg.sender == owner || _addressToSigToSalePrice[msg.sender][sig] == 0);\n', '\n', '    postSale(msg.sender, sig, price);\n', '  }\n', '\n', '  function removeSale(bytes32 sig) public {\n', "    // Can't cancel a sale that doesn't exist\n", '    require(_addressToSigToSalePrice[msg.sender][sig] > 0);\n', '\n', '    cancelSale(msg.sender, sig);\n', '  }\n', '\n', '  function computeTxFee(uint256 price) private pure returns (uint256) {\n', '    return (price * totalTxFeePercent) / 100;\n', '  }\n', '\n', '  // If card is held by contract owner, split among artist + shareholders\n', '  function paySellerFee(bytes32 sig, address seller, uint256 sellerProfit) private {\n', '    if (seller == owner) {\n', '      address artist = getArtist(sig);\n', '      uint256 artistFee = computeArtistGenesisSaleFee(sig, sellerProfit);\n', '      asyncSend(artist, artistFee);\n', '\n', '      payShareholders(sellerProfit.sub(artistFee));\n', '    } else {\n', '      asyncSend(seller, sellerProfit);\n', '    }\n', '  }\n', '\n', '  // Simply pay out tx fees appropriately\n', '  function payTxFees(bytes32 sig, uint256 txFee) private {\n', '    uint256 artistFee = computeArtistTxFee(sig, txFee);\n', '    address artist = getArtist(sig);\n', '    asyncSend(artist, artistFee);\n', '\n', '    payShareholders(txFee.sub(artistFee));\n', '  }\n', '\n', '  // Handle wallet debit if necessary, pay out fees, pay out seller profit, cancel sale, transfer card\n', '  function buy(bytes32 sig) external payable {\n', '    address seller;\n', '    uint256 price;\n', '    (seller, price) = getBestSale(sig);\n', '\n', '    // There must be a valid sale for the card\n', '    require(price > 0 && seller != address(0));\n', '\n', '    // Buyer must have enough Eth via wallet and payment to cover posted price\n', '    uint256 availableEth = msg.value.add(payments[msg.sender]);\n', '    require(availableEth >= price);\n', '\n', "    // Debit wallet if msg doesn't have enough value to cover price\n", '    if (msg.value < price) {\n', '      asyncDebit(msg.sender, price.sub(msg.value));\n', '    }\n', '\n', '    // Split out fees + seller profit\n', '    uint256 txFee = computeTxFee(price);\n', '    uint256 sellerProfit = price.sub(txFee);\n', '\n', '    // Pay out seller (special logic for seller == owner)\n', '    paySellerFee(sig, seller, sellerProfit);\n', '\n', '    // Pay out tx fees\n', '    payTxFees(sig, txFee);\n', '\n', '    // Cancel sale\n', '    cancelSale(seller, sig);\n', '\n', '    // Transfer single sig ownership in registry\n', '    registryTransfer(seller, msg.sender, sig, 1);\n', '  }\n', '\n', '  // Can also be used in airdrops, etc.\n', '  function transferSig(bytes32 sig, uint256 count, address newOwner) external {\n', '    uint256 numOwned = getNumSigsOwned(sig);\n', '\n', "    // Can't transfer cards you don't own\n", '    require(numOwned >= count);\n', '\n', '    // If transferring from contract owner, cancel the proper number of sales if necessary\n', '    if (msg.sender == owner) {\n', '      uint256 remaining = numOwned.sub(count);\n', '\n', '      if (remaining < _ownerSigToNumSales[sig]) {\n', '        uint256 numSalesToCancel = _ownerSigToNumSales[sig].sub(remaining);\n', '\n', '        for (uint256 i = 0; i < numSalesToCancel; i++) {\n', '          removeSale(sig);\n', '        }\n', '      }\n', '    } else {\n', '      // Remove existing sale if transferring all owned cards\n', '      if (numOwned == count && _addressToSigToSalePrice[msg.sender][sig] > 0) {\n', '        removeSale(sig);\n', '      }\n', '    }\n', '\n', '    // Transfer in registry\n', '    registryTransfer(msg.sender, newOwner, sig, count);\n', '  }\n', '}']
