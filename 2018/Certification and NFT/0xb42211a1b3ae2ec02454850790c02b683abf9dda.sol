['pragma solidity 0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount)external returns (bool success);\n', '    function balanceOf(address _owner) external returns (uint256 balance);\n', '    function decimals()external view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner on adhoc requests\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    \n', '    event Withdrawn(address _wallet);\n', '    \n', '    function Vault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '\n', '    \n', '    function withdrawToWallet() public onlyOwner {\n', '     wallet.transfer(this.balance);\n', '     emit Withdrawn(wallet);\n', '  }\n', '  \n', '}\n', '\n', '\n', 'contract CLXTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '  \n', '      //rate of token in ether 1ETH = 8000 CLX\n', '      uint256 public rate = 8000;\n', '      \n', '      /*\n', '      *There will be 2 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      */\n', '\n', '      struct PhaseInfo{\n', '          uint256 hardcap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8   bonusPercentages;\n', '          uint256 minEtherContribution;\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '         \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '\n', '      //total tokens available for sale considering 8 decimal places\n', '      uint256 tokensAvailableForSale = 17700000000000000;\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '\n', '       //Keep track of emergency stop\n', '      bool public ifEmergencyStop ;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger Sale restart\n', '      event SaleRestarted(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event Finished(address _owner, uint256 time);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '\n', '    modifier _ifNotEmergencyStop() {\n', '        require(!ifEmergencyStop);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough CLX credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _ifNotEmergencyStop {\n', '       \n', '        ifEmergencyStop = true;  \n', '        \n', '        emit SaleStopped(msg.sender, now);\n', '    }\n', '\n', '    //to restart the sale after emergency stop\n', '    function emergencyRestart() external onlyOwner _contractUp  {\n', '        require(ifEmergencyStop);\n', '       \n', '        ifEmergencyStop = false;\n', '\n', '        emit SaleRestarted(msg.sender, now);\n', '    }\n', '  \n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return (phases[noOfPhases-1].endTime != 0);\n', '  }\n', '  \n', '   \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _hardCaps The array containing hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps ,uint256[] _minEtherContribution, uint8[2] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases == 2);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length ==  2);\n', '   require(_endTimes.length == _noOfPhases);\n', '    require(_hardCaps.length == _noOfPhases);\n', '    require(_bonusPercentages.length == _noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i = 0; i < _noOfPhases; i++){\n', '\n', '        require(_hardCaps[i] > 0);\n', '       \n', '        if(i>0){\n', '\n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                minEtherContribution : _minEtherContribution[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i] > now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                minEtherContribution : _minEtherContribution[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    function CLXTokenSale(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](2);\n', '        uint256[] memory endTimes = new uint256[](2);\n', '        uint256[] memory hardCaps = new uint256[](2);\n', '        uint256[] memory minEtherContribution = new uint256[](2);\n', '        uint8[2] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1525910400; //MAY 10, 2018 00:00 AM GMT\n', '        endTimes[0] = 0; //NO END TIME INITIALLY\n', '        hardCaps[0] = 7500 ether;\n', '        minEtherContribution[0] = 0.3 ether;\n', '        bonusPercentages[0] = 20;\n', '        \n', '        //phase-1: Public Sale\n', '        startTimes[1] = 0; //NO START TIME INITIALLY\n', '        endTimes[1] = 0; //NO END TIME INITIALLY\n', '        hardCaps[1] = 12500 ether;\n', '        minEtherContribution[1] = 0.1 ether;\n', '        bonusPercentages[1] = 5;\n', '        \n', '        setTiersInfo(2, startTimes, endTimes, hardCaps, minEtherContribution, bonusPercentages);\n', '        \n', '    }\n', '    \n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '\n', '   function startNextPhase() public onlyOwner _saleNotEnded _contractUp _ifNotEmergencyStop returns(bool){\n', '\n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       \n', '       require(currentPhaseIndex == 0);\n', '\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       uint256 tokensLeft;\n', '       uint256 tokensInPreICO = 7200000000000000; //considering 8 decimal places\n', '             \n', '       //Checking if tokens are left after the Pre ICO sale, if left, transfer all to the owner   \n', '       if(currentlyRunningPhase.weiRaised <= 7500 ether) {\n', '           tokensLeft = tokensInPreICO.sub(currentlyRunningPhase.weiRaised.mul(9600).div(10000000000));\n', '           token.transfer(msg.sender, tokensLeft);\n', '       }\n', '       \n', '       phases[0].endTime = now;\n', '       phases[1].startTime = now;\n', '\n', '       return true;\n', '       \n', '   }\n', '\n', '   /**\n', '   * @dev Must be called to end the sale, to do some extra finalization\n', '   * work. It finishes the sale, sends the unsold tokens to the owner&#39;s address\n', '   * IMP : Call withdrawFunds() before finishing the sale \n', '   */\n', '  function finishSale() public onlyOwner _contractUp _saleNotEnded returns (bool){\n', '      \n', '      int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '      require(currentPhaseIndex == 1);\n', '      \n', '      PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '      uint256 tokensLeft;\n', '      uint256 tokensInPublicSale = 10500000000000000; //considering 8 decimal places\n', '          \n', '          //Checking if tokens are left after the Public sale, if left, transfer all to the owner   \n', '       if(currentlyRunningPhase.weiRaised <= 12500 ether) {\n', '           tokensLeft = tokensInPublicSale.sub(currentlyRunningPhase.weiRaised.mul(8400).div(10000000000));\n', '           token.transfer(msg.sender, tokensLeft);\n', '       }\n', '      //End the sale\n', '      saleEnded = true;\n', '      \n', '      //Set the endTime of Public Sale\n', '      phases[noOfPhases-1].endTime = now;\n', '      \n', '      emit Finished(msg.sender, now);\n', '      return true;\n', '  }\n', '\n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded _ifNotEmergencyStop nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex >= 0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check hard cap for this phase has not been reached\n', '       require(weiAmount.add(currentlyRunningPhase.weiRaised) <= currentlyRunningPhase.hardcap);\n', '       \n', '       //check the minimum ether contribution\n', '       require(weiAmount >= currentlyRunningPhase.minEtherContribution);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.mul(rate).div(10000000000);//considering decimal places to be 8 for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages);\n', '\n', '\n', '       totalFunding = totalFunding.add(weiAmount);\n', '             \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentage Array of bonus percentages for the phase\n', '    */\n', '     function applyBonus(uint256 tokens, uint8 percentage) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         tokensToAdd = tokens.mul(percentage).div(100);\n', '         return tokens.add(tokensToAdd);\n', '    }\n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i=0;i<noOfPhases;i++){\n', '\n', '          if(phases[i].startTime!=0 && now>=phases[i].startTime && phases[i].endTime == 0){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   \n', '   /**\n', '   * @dev Get funding info of user/address.\n', '   * It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '\n', '   /**\n', '   * @dev Allow owner to withdraw funds to his wallet anytime in between the sale process \n', '   */\n', '\n', '    function withDrawFunds()public onlyOwner _saleNotEnded _contractUp {\n', '      \n', '       vault.withdrawToWallet();\n', '    }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount)external returns (bool success);\n', '    function balanceOf(address _owner) external returns (uint256 balance);\n', '    function decimals()external view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner on adhoc requests\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '    \n', '    event Withdrawn(address _wallet);\n', '    \n', '    function Vault(address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '\n', '    \n', '    function withdrawToWallet() public onlyOwner {\n', '     wallet.transfer(this.balance);\n', '     emit Withdrawn(wallet);\n', '  }\n', '  \n', '}\n', '\n', '\n', 'contract CLXTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '  \n', '      //rate of token in ether 1ETH = 8000 CLX\n', '      uint256 public rate = 8000;\n', '      \n', '      /*\n', '      *There will be 2 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      */\n', '\n', '      struct PhaseInfo{\n', '          uint256 hardcap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8   bonusPercentages;\n', '          uint256 minEtherContribution;\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '         \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '\n', '      //total tokens available for sale considering 8 decimal places\n', '      uint256 tokensAvailableForSale = 17700000000000000;\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '\n', '       //Keep track of emergency stop\n', '      bool public ifEmergencyStop ;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger Sale restart\n', '      event SaleRestarted(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event Finished(address _owner, uint256 time);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '\n', '    modifier _ifNotEmergencyStop() {\n', '        require(!ifEmergencyStop);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough CLX credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _ifNotEmergencyStop {\n', '       \n', '        ifEmergencyStop = true;  \n', '        \n', '        emit SaleStopped(msg.sender, now);\n', '    }\n', '\n', '    //to restart the sale after emergency stop\n', '    function emergencyRestart() external onlyOwner _contractUp  {\n', '        require(ifEmergencyStop);\n', '       \n', '        ifEmergencyStop = false;\n', '\n', '        emit SaleRestarted(msg.sender, now);\n', '    }\n', '  \n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return (phases[noOfPhases-1].endTime != 0);\n', '  }\n', '  \n', '   \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _hardCaps The array containing hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _hardCaps ,uint256[] _minEtherContribution, uint8[2] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases == 2);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length ==  2);\n', '   require(_endTimes.length == _noOfPhases);\n', '    require(_hardCaps.length == _noOfPhases);\n', '    require(_bonusPercentages.length == _noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i = 0; i < _noOfPhases; i++){\n', '\n', '        require(_hardCaps[i] > 0);\n', '       \n', '        if(i>0){\n', '\n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                minEtherContribution : _minEtherContribution[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i] > now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                hardcap:_hardCaps[i],\n', '                startTime:_startTimes[i],\n', '                minEtherContribution : _minEtherContribution[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    function CLXTokenSale(address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](2);\n', '        uint256[] memory endTimes = new uint256[](2);\n', '        uint256[] memory hardCaps = new uint256[](2);\n', '        uint256[] memory minEtherContribution = new uint256[](2);\n', '        uint8[2] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1525910400; //MAY 10, 2018 00:00 AM GMT\n', '        endTimes[0] = 0; //NO END TIME INITIALLY\n', '        hardCaps[0] = 7500 ether;\n', '        minEtherContribution[0] = 0.3 ether;\n', '        bonusPercentages[0] = 20;\n', '        \n', '        //phase-1: Public Sale\n', '        startTimes[1] = 0; //NO START TIME INITIALLY\n', '        endTimes[1] = 0; //NO END TIME INITIALLY\n', '        hardCaps[1] = 12500 ether;\n', '        minEtherContribution[1] = 0.1 ether;\n', '        bonusPercentages[1] = 5;\n', '        \n', '        setTiersInfo(2, startTimes, endTimes, hardCaps, minEtherContribution, bonusPercentages);\n', '        \n', '    }\n', '    \n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '\n', '   function startNextPhase() public onlyOwner _saleNotEnded _contractUp _ifNotEmergencyStop returns(bool){\n', '\n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       \n', '       require(currentPhaseIndex == 0);\n', '\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       uint256 tokensLeft;\n', '       uint256 tokensInPreICO = 7200000000000000; //considering 8 decimal places\n', '             \n', '       //Checking if tokens are left after the Pre ICO sale, if left, transfer all to the owner   \n', '       if(currentlyRunningPhase.weiRaised <= 7500 ether) {\n', '           tokensLeft = tokensInPreICO.sub(currentlyRunningPhase.weiRaised.mul(9600).div(10000000000));\n', '           token.transfer(msg.sender, tokensLeft);\n', '       }\n', '       \n', '       phases[0].endTime = now;\n', '       phases[1].startTime = now;\n', '\n', '       return true;\n', '       \n', '   }\n', '\n', '   /**\n', '   * @dev Must be called to end the sale, to do some extra finalization\n', "   * work. It finishes the sale, sends the unsold tokens to the owner's address\n", '   * IMP : Call withdrawFunds() before finishing the sale \n', '   */\n', '  function finishSale() public onlyOwner _contractUp _saleNotEnded returns (bool){\n', '      \n', '      int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '      require(currentPhaseIndex == 1);\n', '      \n', '      PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '      uint256 tokensLeft;\n', '      uint256 tokensInPublicSale = 10500000000000000; //considering 8 decimal places\n', '          \n', '          //Checking if tokens are left after the Public sale, if left, transfer all to the owner   \n', '       if(currentlyRunningPhase.weiRaised <= 12500 ether) {\n', '           tokensLeft = tokensInPublicSale.sub(currentlyRunningPhase.weiRaised.mul(8400).div(10000000000));\n', '           token.transfer(msg.sender, tokensLeft);\n', '       }\n', '      //End the sale\n', '      saleEnded = true;\n', '      \n', '      //Set the endTime of Public Sale\n', '      phases[noOfPhases-1].endTime = now;\n', '      \n', '      emit Finished(msg.sender, now);\n', '      return true;\n', '  }\n', '\n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded _ifNotEmergencyStop nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex >= 0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check hard cap for this phase has not been reached\n', '       require(weiAmount.add(currentlyRunningPhase.weiRaised) <= currentlyRunningPhase.hardcap);\n', '       \n', '       //check the minimum ether contribution\n', '       require(weiAmount >= currentlyRunningPhase.minEtherContribution);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.mul(rate).div(10000000000);//considering decimal places to be 8 for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages);\n', '\n', '\n', '       totalFunding = totalFunding.add(weiAmount);\n', '             \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentage Array of bonus percentages for the phase\n', '    */\n', '     function applyBonus(uint256 tokens, uint8 percentage) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         tokensToAdd = tokens.mul(percentage).div(100);\n', '         return tokens.add(tokensToAdd);\n', '    }\n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i=0;i<noOfPhases;i++){\n', '\n', '          if(phases[i].startTime!=0 && now>=phases[i].startTime && phases[i].endTime == 0){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   \n', '   /**\n', '   * @dev Get funding info of user/address.\n', '   * It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '\n', '   /**\n', '   * @dev Allow owner to withdraw funds to his wallet anytime in between the sale process \n', '   */\n', '\n', '    function withDrawFunds()public onlyOwner _saleNotEnded _contractUp {\n', '      \n', '       vault.withdrawToWallet();\n', '    }\n', '}']
