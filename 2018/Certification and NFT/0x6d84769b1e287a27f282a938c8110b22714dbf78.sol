['pragma solidity ^0.4.24;\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '\n', '    /**\n', '     * @dev Paused by default.\n', '     */\n', '    constructor(){\n', '        paused = true;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        require(paused == false);\n', '        _;\n', '    }\n', '}\n', 'interface ABIO_Token {\n', '    function owner() external returns (address);\n', '    function transfer(address receiver, uint amount) external;\n', '    function burnMyBalance() external;\n', '}\n', 'interface ABIO_ICO{\n', '    function deadline() external returns (uint);\n', '    function weiRaised() external returns (uint);\n', '}\n', '\n', 'contract ABIO_BaseICO is Haltable{\n', '    mapping(address => uint256) ethBalances;\n', '\n', '    uint public weiRaised;//total raised in wei\n', '    uint public abioSold;//amount of ABIO sold\n', '    uint public volume; //total amount of ABIO selling in this preICO\n', '\n', '    uint public startDate;\n', '    uint public length;\n', '    uint public deadline;\n', '    bool public restTokensBurned;\n', '\n', '    uint public weiPerABIO; //how much wei one ABIO costs\n', '    uint public minInvestment;\n', '    uint public fundingGoal;\n', '    bool public fundingGoalReached;\n', '    address public treasury;\n', '\n', '    ABIO_Token public abioToken;\n', '\n', '    event ICOStart(uint volume, uint weiPerABIO, uint minInvestment);\n', '    event SoftcapReached(address recipient, uint totalAmountRaised);\n', '    event FundsReceived(address backer, uint amount);\n', '    event FundsWithdrawn(address receiver, uint amount);\n', '\n', '    event ChangeTreasury(address operator, address newTreasury);\n', '    event ChangeMinInvestment(address operator, uint oldMin, uint newMin);\n', '\n', '         /**\n', '         * @notice allows owner to change the treasury in case of hack/lost keys.\n', '         * @dev Marked external because it is never called from this contract.\n', '         */\n', '         function changeTreasury(address _newTreasury) external onlyOwner{\n', '             treasury = _newTreasury;\n', '             emit ChangeTreasury(msg.sender, _newTreasury);\n', '         }\n', '\n', '         /**\n', '         * @notice allows owner to change the minInvestment in case of extreme price jumps of ETH price.\n', '         */\n', '         function changeMinInvestment(uint _newMin) external onlyOwner{\n', '             emit ChangeMinInvestment(msg.sender, minInvestment, _newMin);\n', '             minInvestment = _newMin;\n', '         }\n', '\n', '         /**\n', '          * @notice Called everytime we receive a contribution in ETH.\n', '          * @dev Tokens are immediately transferred to the contributor, even if goal doesn&#39;t get reached.\n', '          */\n', '         function () payable stopOnPause{\n', '             require(now < deadline);\n', '             require(msg.value >= minInvestment);\n', '             uint amount = msg.value;\n', '             ethBalances[msg.sender] += amount;\n', '             weiRaised += amount;\n', '             if(!fundingGoalReached && weiRaised >= fundingGoal){goalReached();}\n', '\n', '             uint ABIOAmount = amount / weiPerABIO ;\n', '             abioToken.transfer(msg.sender, ABIOAmount);\n', '             abioSold += ABIOAmount;\n', '             emit FundsReceived(msg.sender, amount);\n', '         }\n', '\n', '         /**\n', '         * @notice We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume.\n', '         * @dev If someone sends random tokens transaction is reverted.\n', '         * @dev If owner of token sends tokens, we accept them.\n', '         * @dev Crowdsale opens once this contract gets the tokens.\n', '         */\n', '         function tokenFallback(address _from, uint _value, bytes _data) external{\n', '             require(_from == abioToken.owner() || _from == owner);\n', '             volume = _value;\n', '             paused = false;\n', '             deadline = now + length;\n', '             emit ICOStart(_value, weiPerABIO, minInvestment);\n', '         }\n', '\n', '         /**\n', '         * @notice Burns tokens leftover from an ICO round.\n', '         * @dev This can be called by anyone after deadline since it&#39;s an essential and inevitable part.\n', '         */\n', '         function burnRestTokens() afterDeadline{\n', '                 require(!restTokensBurned);\n', '                 abioToken.burnMyBalance();\n', '                 restTokensBurned = true;\n', '         }\n', '\n', '         function isRunning() view returns (bool){\n', '             return (now < deadline);\n', '         }\n', '\n', '         function goalReached() internal;\n', '\n', '         modifier afterDeadline() { if (now >= deadline) _; }\n', '}\n', 'contract ABIO_preICO is ABIO_BaseICO{\n', '    address ICOAddress;\n', '    ABIO_ICO ICO;\n', '    uint finalDeadline;\n', '\n', '    constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){\n', '        treasury = _treasury;\n', '        abioToken = ABIO_Token(_abioAddress);\n', '\n', '        weiPerABIO = _priceInWei;\n', '        fundingGoal = _goalInWei;\n', '        minInvestment = _minWeiInvestment;\n', '\n', '        startDate = now;\n', '        length = _lenInMins * 1 minutes;\n', '     }\n', '     /**\n', '     * @notice Called by dev to supply the address of the ICO (which is created after the PreICO)\n', '     * @dev We check if `fundingGoal` is reached again, because this MIGHT be called after it is reached, so `extGoalReached()` will never be called after.\n', '     */\n', '    function supplyICOContract(address _addr) public onlyOwner{\n', '        require(_addr != 0x0);\n', '        ICOAddress = _addr;\n', '        ICO = ABIO_ICO(_addr);\n', '        if(!fundingGoalReached && weiRaised + ICO.weiRaised() >= fundingGoal){goalReached();}\n', '        finalDeadline = ICO.deadline();\n', '    }\n', '\n', '    function goalReached() internal{\n', '        fundingGoalReached = true;\n', '        emit SoftcapReached(treasury, fundingGoal);\n', '    }\n', '\n', '    /**\n', '    * @notice supposed to be called by ICO Contract IF `fundingGoal` wasn&#39;t reached during PreICO to notify it\n', '    * @dev !!Funds can&#39;t be deposited to treasury if `fundingGoal` isn&#39;t called before main ICO ends!!\n', '    * @dev This is, at max., called once! If this contract doesn&#39;t know ICOAddress by that time, we rely on the check in `supplyICOContract()`\n', '    */\n', '    function extGoalReached() afterDeadline external{\n', '        require(ICOAddress != 0x0); //ICO was supplied\n', '        require(msg.sender == ICOAddress);\n', '        goalReached();\n', '    }\n', '\n', '    /**\n', '     * @notice Lets participants withdraw the funds if `fundingGoal` was missed.\n', '     * @notice Lets treasury collect the funds if `fundingGoal` was reached.\n', '     * @dev The contract is obligated to return the ETH to contributors if `fundingGoal` isn&#39;t reached,\n', '     *      so we have to wait until the end for a user withdrawal.\n', '     * @dev The treasury can withdraw right after `fundingGoal` is reached.\n', '     */\n', '    function safeWithdrawal() afterDeadline stopOnPause{\n', '        if (!fundingGoalReached && now >= finalDeadline) {\n', '            uint amount = ethBalances[msg.sender];\n', '            ethBalances[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundsWithdrawn(msg.sender, amount);\n', '                } else {\n', '                    ethBalances[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '        else if (fundingGoalReached && treasury == msg.sender) {\n', '            if (treasury.send(weiRaised)) {\n', '                emit FundsWithdrawn(treasury, weiRaised);\n', '            } else if (treasury.send(address(this).balance)){\n', '                emit FundsWithdrawn(treasury, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', 'contract Ownable{\n', '    address public owner;\n', '    event ownerTransfer(address indexed oldOwner, address indexed newOwner);\n', '    event ownerGone(address indexed oldOwner);\n', '\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function changeOwner(address _newOwner) public onlyOwner{\n', '        require(_newOwner != address(0x0));\n', '        emit ownerTransfer(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', 'contract Haltable is Ownable{\n', '    bool public paused;\n', '    event ContractPaused(address by);\n', '    event ContractUnpaused(address by);\n', '\n', '    /**\n', '     * @dev Paused by default.\n', '     */\n', '    constructor(){\n', '        paused = true;\n', '    }\n', '    function pause() public onlyOwner {\n', '        paused = true;\n', '        emit ContractPaused(owner);\n', '    }\n', '    function unpause() public onlyOwner {\n', '        paused = false;\n', '        emit ContractUnpaused(owner);\n', '    }\n', '    modifier stopOnPause(){\n', '        require(paused == false);\n', '        _;\n', '    }\n', '}\n', 'interface ABIO_Token {\n', '    function owner() external returns (address);\n', '    function transfer(address receiver, uint amount) external;\n', '    function burnMyBalance() external;\n', '}\n', 'interface ABIO_ICO{\n', '    function deadline() external returns (uint);\n', '    function weiRaised() external returns (uint);\n', '}\n', '\n', 'contract ABIO_BaseICO is Haltable{\n', '    mapping(address => uint256) ethBalances;\n', '\n', '    uint public weiRaised;//total raised in wei\n', '    uint public abioSold;//amount of ABIO sold\n', '    uint public volume; //total amount of ABIO selling in this preICO\n', '\n', '    uint public startDate;\n', '    uint public length;\n', '    uint public deadline;\n', '    bool public restTokensBurned;\n', '\n', '    uint public weiPerABIO; //how much wei one ABIO costs\n', '    uint public minInvestment;\n', '    uint public fundingGoal;\n', '    bool public fundingGoalReached;\n', '    address public treasury;\n', '\n', '    ABIO_Token public abioToken;\n', '\n', '    event ICOStart(uint volume, uint weiPerABIO, uint minInvestment);\n', '    event SoftcapReached(address recipient, uint totalAmountRaised);\n', '    event FundsReceived(address backer, uint amount);\n', '    event FundsWithdrawn(address receiver, uint amount);\n', '\n', '    event ChangeTreasury(address operator, address newTreasury);\n', '    event ChangeMinInvestment(address operator, uint oldMin, uint newMin);\n', '\n', '         /**\n', '         * @notice allows owner to change the treasury in case of hack/lost keys.\n', '         * @dev Marked external because it is never called from this contract.\n', '         */\n', '         function changeTreasury(address _newTreasury) external onlyOwner{\n', '             treasury = _newTreasury;\n', '             emit ChangeTreasury(msg.sender, _newTreasury);\n', '         }\n', '\n', '         /**\n', '         * @notice allows owner to change the minInvestment in case of extreme price jumps of ETH price.\n', '         */\n', '         function changeMinInvestment(uint _newMin) external onlyOwner{\n', '             emit ChangeMinInvestment(msg.sender, minInvestment, _newMin);\n', '             minInvestment = _newMin;\n', '         }\n', '\n', '         /**\n', '          * @notice Called everytime we receive a contribution in ETH.\n', "          * @dev Tokens are immediately transferred to the contributor, even if goal doesn't get reached.\n", '          */\n', '         function () payable stopOnPause{\n', '             require(now < deadline);\n', '             require(msg.value >= minInvestment);\n', '             uint amount = msg.value;\n', '             ethBalances[msg.sender] += amount;\n', '             weiRaised += amount;\n', '             if(!fundingGoalReached && weiRaised >= fundingGoal){goalReached();}\n', '\n', '             uint ABIOAmount = amount / weiPerABIO ;\n', '             abioToken.transfer(msg.sender, ABIOAmount);\n', '             abioSold += ABIOAmount;\n', '             emit FundsReceived(msg.sender, amount);\n', '         }\n', '\n', '         /**\n', '         * @notice We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume.\n', '         * @dev If someone sends random tokens transaction is reverted.\n', '         * @dev If owner of token sends tokens, we accept them.\n', '         * @dev Crowdsale opens once this contract gets the tokens.\n', '         */\n', '         function tokenFallback(address _from, uint _value, bytes _data) external{\n', '             require(_from == abioToken.owner() || _from == owner);\n', '             volume = _value;\n', '             paused = false;\n', '             deadline = now + length;\n', '             emit ICOStart(_value, weiPerABIO, minInvestment);\n', '         }\n', '\n', '         /**\n', '         * @notice Burns tokens leftover from an ICO round.\n', "         * @dev This can be called by anyone after deadline since it's an essential and inevitable part.\n", '         */\n', '         function burnRestTokens() afterDeadline{\n', '                 require(!restTokensBurned);\n', '                 abioToken.burnMyBalance();\n', '                 restTokensBurned = true;\n', '         }\n', '\n', '         function isRunning() view returns (bool){\n', '             return (now < deadline);\n', '         }\n', '\n', '         function goalReached() internal;\n', '\n', '         modifier afterDeadline() { if (now >= deadline) _; }\n', '}\n', 'contract ABIO_preICO is ABIO_BaseICO{\n', '    address ICOAddress;\n', '    ABIO_ICO ICO;\n', '    uint finalDeadline;\n', '\n', '    constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){\n', '        treasury = _treasury;\n', '        abioToken = ABIO_Token(_abioAddress);\n', '\n', '        weiPerABIO = _priceInWei;\n', '        fundingGoal = _goalInWei;\n', '        minInvestment = _minWeiInvestment;\n', '\n', '        startDate = now;\n', '        length = _lenInMins * 1 minutes;\n', '     }\n', '     /**\n', '     * @notice Called by dev to supply the address of the ICO (which is created after the PreICO)\n', '     * @dev We check if `fundingGoal` is reached again, because this MIGHT be called after it is reached, so `extGoalReached()` will never be called after.\n', '     */\n', '    function supplyICOContract(address _addr) public onlyOwner{\n', '        require(_addr != 0x0);\n', '        ICOAddress = _addr;\n', '        ICO = ABIO_ICO(_addr);\n', '        if(!fundingGoalReached && weiRaised + ICO.weiRaised() >= fundingGoal){goalReached();}\n', '        finalDeadline = ICO.deadline();\n', '    }\n', '\n', '    function goalReached() internal{\n', '        fundingGoalReached = true;\n', '        emit SoftcapReached(treasury, fundingGoal);\n', '    }\n', '\n', '    /**\n', "    * @notice supposed to be called by ICO Contract IF `fundingGoal` wasn't reached during PreICO to notify it\n", "    * @dev !!Funds can't be deposited to treasury if `fundingGoal` isn't called before main ICO ends!!\n", "    * @dev This is, at max., called once! If this contract doesn't know ICOAddress by that time, we rely on the check in `supplyICOContract()`\n", '    */\n', '    function extGoalReached() afterDeadline external{\n', '        require(ICOAddress != 0x0); //ICO was supplied\n', '        require(msg.sender == ICOAddress);\n', '        goalReached();\n', '    }\n', '\n', '    /**\n', '     * @notice Lets participants withdraw the funds if `fundingGoal` was missed.\n', '     * @notice Lets treasury collect the funds if `fundingGoal` was reached.\n', "     * @dev The contract is obligated to return the ETH to contributors if `fundingGoal` isn't reached,\n", '     *      so we have to wait until the end for a user withdrawal.\n', '     * @dev The treasury can withdraw right after `fundingGoal` is reached.\n', '     */\n', '    function safeWithdrawal() afterDeadline stopOnPause{\n', '        if (!fundingGoalReached && now >= finalDeadline) {\n', '            uint amount = ethBalances[msg.sender];\n', '            ethBalances[msg.sender] = 0;\n', '            if (amount > 0) {\n', '                if (msg.sender.send(amount)) {\n', '                    emit FundsWithdrawn(msg.sender, amount);\n', '                } else {\n', '                    ethBalances[msg.sender] = amount;\n', '                }\n', '            }\n', '        }\n', '        else if (fundingGoalReached && treasury == msg.sender) {\n', '            if (treasury.send(weiRaised)) {\n', '                emit FundsWithdrawn(treasury, weiRaised);\n', '            } else if (treasury.send(address(this).balance)){\n', '                emit FundsWithdrawn(treasury, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '}']
