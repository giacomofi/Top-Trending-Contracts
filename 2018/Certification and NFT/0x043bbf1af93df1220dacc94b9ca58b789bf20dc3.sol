['pragma solidity ^0.4.21;\n', '\n', '/// @title ERC-165 Standard Interface Detection\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', 'contract ERC721 is ERC165 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function approve(address _approved, uint256 _tokenId) external payable;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external pure returns (string _name);\n', '    function symbol() external pure returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title A reusable contract to comply with ERC-165\n', '/// @author William Entriken (https://phor.net)\n', 'contract PublishInterfaces is ERC165 {\n', '    /// @dev Every interface that we support\n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    function PublishInterfaces() internal {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title The external contract that is responsible for generating metadata for GanTokens,\n', '///  it has one function that will return the data as bytes.\n', 'contract Metadata {\n', '\n', '    /// @dev Given a token Id, returns a string with metadata\n', '    function getMetadata(uint256 _tokenId, string) public pure returns (bytes32[4] buffer, uint256 count) {\n', '        if (_tokenId == 1) {\n', '            buffer[0] = "Hello World! :D";\n', '            count = 15;\n', '        } else if (_tokenId == 2) {\n', '            buffer[0] = "I would definitely choose a medi";\n', '            buffer[1] = "um length string.";\n', '            count = 49;\n', '        } else if (_tokenId == 3) {\n', '            buffer[0] = "Lorem ipsum dolor sit amet, mi e";\n', '            buffer[1] = "st accumsan dapibus augue lorem,";\n', '            buffer[2] = " tristique vestibulum id, libero";\n', '            buffer[3] = " suscipit varius sapien aliquam.";\n', '            count = 128;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GanNFT is ERC165, ERC721, ERC721Enumerable, PublishInterfaces, Ownable {\n', '\n', '  function GanNFT() internal {\n', '      supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '      supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '      supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '      supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\n', '  }\n', '\n', '  bytes4 private constant ERC721_RECEIVED = bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '\n', '  // @dev claim price taken for each new GanToken\n', '  // generating a new token will be free in the beinging and later changed\n', '  uint256 public claimPrice = 0;\n', '\n', '  // @dev max supply for token\n', '  uint256 public maxSupply = 300;\n', '\n', '  // The contract that will return tokens metadata\n', '  Metadata public erc721Metadata;\n', '\n', '  /// @dev list of all owned token ids\n', '  uint256[] public tokenIds;\n', '\n', '  /// @dev a mpping for all tokens\n', '  mapping(uint256 => address) public tokenIdToOwner;\n', '\n', '  /// @dev mapping to keep owner balances\n', '  mapping(address => uint256) public ownershipCounts;\n', '\n', '  /// @dev mapping to owners to an array of tokens that they own\n', '  mapping(address => uint256[]) public ownerBank;\n', '\n', '  /// @dev mapping to approved ids\n', '  mapping(uint256 => address) public tokenApprovals;\n', '\n', '  /// @dev The authorized operators for each address\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /// @notice A descriptive name for a collection of NFTs in this contract\n', '  function name() external pure returns (string) {\n', '      return "GanToken";\n', '  }\n', '\n', '  /// @notice An abbreviated name for NFTs in this contract\n', '  function symbol() external pure returns (string) {\n', '      return "GT";\n', '  }\n', '\n', '  /// @dev Set the address of the sibling contract that tracks metadata.\n', '  /// Only the contract creater can call this.\n', '  /// @param _contractAddress The location of the contract with meta data\n', '  function setMetadataAddress(address _contractAddress) public onlyOwner {\n', '      erc721Metadata = Metadata(_contractAddress);\n', '  }\n', '\n', '  modifier canTransfer(uint256 _tokenId, address _from, address _to) {\n', '    address owner = tokenIdToOwner[_tokenId];\n', '    require(tokenApprovals[_tokenId] == _to || owner == _from || operatorApprovals[_to][_to]);\n', '    _;\n', '  }\n', '  /// @notice checks to see if a sender owns a _tokenId\n', '  /// @param _tokenId The identifier for an NFT\n', '  modifier owns(uint256 _tokenId) {\n', '    require(tokenIdToOwner[_tokenId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /// @dev This emits any time the ownership of a GanToken changes.\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /// @dev This emits when the approved addresses for a GanToken is changed or reaffirmed.\n', '  /// The zero address indicates there is no owner and it get reset on a transfer\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  /// @dev This emits when an operator is enabled or disabled for an owner.\n', '  ///  The operator can manage all NFTs of the owner.\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  /// @notice allow the owner to set the supply max\n', '  function setMaxSupply(uint max) external payable onlyOwner {\n', '    require(max > tokenIds.length);\n', '\n', '    maxSupply = max;\n', '  }\n', '\n', '  /// @notice allow the owner to set a new fee for creating a GanToken\n', '  function setClaimPrice(uint256 price) external payable onlyOwner {\n', '    claimPrice = price;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) external view returns (uint256 balance) {\n', '    balance = ownershipCounts[_owner];\n', '  }\n', '\n', '  /// @notice Gets the onwner of a an NFT\n', '  /// @param _tokenId The identifier for an NFT\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '    owner = tokenIdToOwner[_tokenId];\n', '  }\n', '\n', '  /// @notice returns all owners&#39; tokens will return an empty array\n', '  /// if the address has no tokens\n', '  /// @param _owner The address of the owner in question\n', '  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n', '    uint256 tokenCount = ownershipCounts[_owner];\n', '\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    }\n', '\n', '    uint256[] memory result = new uint256[](tokenCount);\n', '\n', '    for (uint256 i = 0; i < tokenCount; i++) {\n', '      result[i] = ownerBank[_owner][i];\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /// @dev creates a list of all the tokenIds\n', '  function getAllTokenIds() external view returns (uint256[]) {\n', '    uint256[] memory result = new uint256[](tokenIds.length);\n', '    for (uint i = 0; i < result.length; i++) {\n', '      result[i] = tokenIds[i];\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /// @notice Create a new GanToken with a id and attaches an owner\n', '  /// @param _noise The id of the token that&#39;s being created\n', '  function newGanToken(uint256 _noise) external payable {\n', '    require(msg.sender != address(0));\n', '    require(tokenIdToOwner[_noise] == 0x0);\n', '    require(tokenIds.length < maxSupply);\n', '    require(msg.value >= claimPrice);\n', '\n', '    tokenIds.push(_noise);\n', '    ownerBank[msg.sender].push(_noise);\n', '    tokenIdToOwner[_noise] = msg.sender;\n', '    ownershipCounts[msg.sender]++;\n', '\n', '    emit Transfer(address(0), msg.sender, 0);\n', '  }\n', '\n', '  /// @notice Transfers the ownership of an NFT from one address to another address\n', '  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  ///  `onERC721Received` on `_to` and throws if the return value is not\n', '  ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  /// @param data Additional data with no specified format, sent in call to `_to`\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable\n', '  {\n', '      _safeTransferFrom(_from, _to, _tokenId, data);\n', '  }\n', '\n', '  /// @notice Transfers the ownership of an NFT from one address to another address\n', '  /// @dev This works identically to the other function with an extra data parameter,\n', '  ///  except this function just sets data to ""\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable\n', '  {\n', '      _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '  ///  THEY MAY BE PERMANENTLY LOST\n', '  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '  ///  `_tokenId` is not a valid NFT.\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    require(_to != 0x0);\n', '    require(_to != address(this));\n', '    require(tokenApprovals[_tokenId] == msg.sender);\n', '    require(tokenIdToOwner[_tokenId] == _from);\n', '\n', '    _transfer(_tokenId, _to);\n', '  }\n', '\n', '  /// @notice Grant another address the right to transfer a specific token via\n', '  ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n', '  /// @dev The zero address indicates there is no approved address.\n', '  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '  ///  operator of the current owner.\n', '  /// @dev Required for ERC-721 compliance.\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\n', '  function approve(address _to, uint256 _tokenId) external owns(_tokenId) payable {\n', '      // Register the approval (replacing any previous approval).\n', '      tokenApprovals[_tokenId] = _to;\n', '\n', '      emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// @notice Enable or disable approval for a third party ("operator") to manage\n', '  ///  all your asset.\n', '  /// @dev Emits the ApprovalForAll event\n', '  /// @param _operator Address to add to the set of authorized operators.\n', '  /// @param _approved True if the operators is approved, false to revoke approval\n', '  function setApprovalForAll(address _operator, bool _approved) external {\n', '      operatorApprovals[msg.sender][_operator] = _approved;\n', '      emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @notice Get the approved address for a single NFT\n', '  /// @param _tokenId The NFT to find the approved address for\n', '  /// @return The approved address for this NFT, or the zero address if there is none\n', '  function getApproved(uint256 _tokenId) external view returns (address) {\n', '      return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /// @notice Query if an address is an authorized operator for another address\n', '  /// @param _owner The address that owns the NFTs\n', '  /// @param _operator The address that acts on behalf of the owner\n', '  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '      return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() external view returns (uint256) {\n', '    return tokenIds.length;\n', '  }\n', '\n', '  /// @notice Enumerate valid NFTs\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for index the `_index`th NFT 0 if it doesn&#39;t exist,\n', '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '      return tokenIds[_index];\n', '  }\n', '\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\n', '      require(_owner != address(0));\n', '      require(_index < ownerBank[_owner].length);\n', '      _tokenId = ownerBank[_owner][_index];\n', '  }\n', '\n', '  function _transfer(uint256 _tokenId, address _to) internal {\n', '    require(_to != address(0));\n', '\n', '    address from = tokenIdToOwner[_tokenId];\n', '    uint256 tokenCount = ownershipCounts[from];\n', '    // remove from ownerBank and replace the deleted token id\n', '    for (uint256 i = 0; i < tokenCount; i++) {\n', '      uint256 ownedId = ownerBank[from][i];\n', '      if (_tokenId == ownedId) {\n', '        delete ownerBank[from][i];\n', '        if (i != tokenCount) {\n', '          ownerBank[from][i] = ownerBank[from][tokenCount - 1];\n', '        }\n', '        break;\n', '      }\n', '    }\n', '\n', '    ownershipCounts[from]--;\n', '    ownershipCounts[_to]++;\n', '    ownerBank[_to].push(_tokenId);\n', '\n', '    tokenIdToOwner[_tokenId] = _to;\n', '    tokenApprovals[_tokenId] = address(0);\n', '    emit Transfer(from, _to, 1);\n', '  }\n', '\n', '  /// @dev Actually perform the safeTransferFrom\n', '  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\n', '      private\n', '      canTransfer(_tokenId, _from, _to)\n', '  {\n', '      address owner = tokenIdToOwner[_tokenId];\n', '\n', '      require(owner == _from);\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      _transfer(_tokenId, _to);\n', '\n', '\n', '      // Do the callback after everything is done to avoid reentrancy attack\n', '      uint256 codeSize;\n', '      assembly { codeSize := extcodesize(_to) }\n', '      if (codeSize == 0) {\n', '          return;\n', '      }\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '      require(retval == ERC721_RECEIVED);\n', '  }\n', '\n', '  /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d5b4a7b4b6bdbbbcb195bbbaa1b1baa1fbbbb0a1">[email&#160;protected]</a>>)\n', '  ///  This method is licenced under the Apache License.\n', '  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '  function _memcpy(uint _dest, uint _src, uint _len) private pure {\n', '      // Copy word-length chunks while possible\n', '      for(; _len >= 32; _len -= 32) {\n', '          assembly {\n', '              mstore(_dest, mload(_src))\n', '          }\n', '          _dest += 32;\n', '          _src += 32;\n', '      }\n', '\n', '      // Copy remaining bytes\n', '      uint256 mask = 256 ** (32 - _len) - 1;\n', '      assembly {\n', '          let srcpart := and(mload(_src), not(mask))\n', '          let destpart := and(mload(_dest), mask)\n', '          mstore(_dest, or(destpart, srcpart))\n', '      }\n', '  }\n', '\n', '  /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b1d0c3d0d2d9dfd8d5f1dfdec5d5dec59fdfd4c5">[email&#160;protected]</a>>)\n', '  ///  This method is licenced under the Apache License.\n', '  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '  function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private pure returns (string) {\n', '      string memory outputString = new string(_stringLength);\n', '      uint256 outputPtr;\n', '      uint256 bytesPtr;\n', '\n', '      assembly {\n', '          outputPtr := add(outputString, 32)\n', '          bytesPtr := _rawBytes\n', '      }\n', '\n', '      _memcpy(outputPtr, bytesPtr, _stringLength);\n', '\n', '      return outputString;\n', '  }\n', '\n', '\n', '  /// @notice Returns a URI pointing to a metadata package for this token conforming to\n', '  ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\n', '  /// @param _tokenId The ID number of the GanToken whose metadata should be returned.\n', '  function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\n', '      require(erc721Metadata != address(0));\n', '      uint256 count;\n', '      bytes32[4] memory buffer;\n', '\n', '      (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\n', '\n', '      return _toString(buffer, count);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract GanTokenMain is GanNFT {\n', '\n', '  struct Offer {\n', '    bool isForSale;\n', '    uint256 tokenId;\n', '    address seller;\n', '    uint value;          // in ether\n', '    address onlySellTo;     // specify to sell only to a specific person\n', '  }\n', '\n', '  struct Bid {\n', '    bool hasBid;\n', '    uint256 tokenId;\n', '    address bidder;\n', '    uint value;\n', '  }\n', '\n', '  /// @dev mapping of balances for address\n', '  mapping(address => uint256) public pendingWithdrawals;\n', '\n', '  /// @dev mapping of tokenId to to an offer\n', '  mapping(uint256 => Offer) public ganTokenOfferedForSale;\n', '\n', '  /// @dev mapping bids to tokenIds\n', '  mapping(uint256 => Bid) public tokenBids;\n', '\n', '  event BidForGanTokenOffered(uint256 tokenId, uint256 value, address sender);\n', '  event BidWithdrawn(uint256 tokenId, uint256 value, address bidder);\n', '  event GanTokenOfferedForSale(uint256 tokenId, uint256 minSalePriceInWei, address onlySellTo);\n', '  event GanTokenNoLongerForSale(uint256 tokenId);\n', '\n', '\n', '  /// @notice Allow a token owner to pull sale\n', '  /// @param tokenId The id of the token that&#39;s created\n', '  function ganTokenNoLongerForSale(uint256 tokenId) public payable owns(tokenId) {\n', '    ganTokenOfferedForSale[tokenId] = Offer(false, tokenId, msg.sender, 0, 0x0);\n', '\n', '    emit GanTokenNoLongerForSale(tokenId);\n', '  }\n', '\n', '  /// @notice Put a token up for sale\n', '  /// @param tokenId The id of the token that&#39;s created\n', '  /// @param minSalePriceInWei desired price of token\n', '  function offerGanTokenForSale(uint tokenId, uint256 minSalePriceInWei) external payable owns(tokenId) {\n', '    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, 0x0);\n', '\n', '    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, 0x0);\n', '  }\n', '\n', '  /// @notice Create a new GanToken with a id and attaches an owner\n', '  /// @param tokenId The id of the token that&#39;s being created\n', '  function offerGanTokenForSaleToAddress(uint tokenId, address sendTo, uint256 minSalePriceInWei) external payable {\n', '    require(tokenIdToOwner[tokenId] == msg.sender);\n', '    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, sendTo);\n', '\n', '    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, sendTo);\n', '  }\n', '\n', '  /// @notice Allows an account to buy a NFT gan token that is up for offer\n', '  /// the token owner must set onlySellTo to the sender\n', '  /// @param id the id of the token\n', '  function buyGanToken(uint256 id) public payable {\n', '    Offer memory offer = ganTokenOfferedForSale[id];\n', '    require(offer.isForSale);\n', '    require(offer.onlySellTo == msg.sender && offer.onlySellTo != 0x0);\n', '    require(msg.value == offer.value);\n', '    require(tokenIdToOwner[id] == offer.seller);\n', '\n', '    safeTransferFrom(offer.seller, offer.onlySellTo, id);\n', '\n', '    ganTokenOfferedForSale[id] = Offer(false, id, offer.seller, 0, 0x0);\n', '\n', '    pendingWithdrawals[offer.seller] += msg.value;\n', '  }\n', '\n', '  /// @notice Allows an account to enter a higher bid on a toekn\n', '  /// @param tokenId the id of the token\n', '  function enterBidForGanToken(uint256 tokenId) external payable {\n', '    Bid memory existing = tokenBids[tokenId];\n', '    require(tokenIdToOwner[tokenId] != msg.sender);\n', '    require(tokenIdToOwner[tokenId] != 0x0);\n', '    require(msg.value > existing.value);\n', '    if (existing.value > 0) {\n', '      // Refund the failing bid\n', '      pendingWithdrawals[existing.bidder] += existing.value;\n', '    }\n', '\n', '    tokenBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value);\n', '    emit BidForGanTokenOffered(tokenId, msg.value, msg.sender);\n', '  }\n', '\n', '  /// @notice Allows the owner of a token to accept an outstanding bid for that token\n', '  /// @param tokenId The id of the token that&#39;s being created\n', '  /// @param price The desired price of token in wei\n', '  function acceptBid(uint256 tokenId, uint256 price) external payable {\n', '    require(tokenIdToOwner[tokenId] == msg.sender);\n', '    Bid memory bid = tokenBids[tokenId];\n', '    require(bid.value != 0);\n', '    require(bid.value == price);\n', '\n', '    safeTransferFrom(msg.sender, bid.bidder, tokenId);\n', '\n', '    tokenBids[tokenId] = Bid(false, tokenId, address(0), 0);\n', '    pendingWithdrawals[msg.sender] += bid.value;\n', '  }\n', '\n', '  /// @notice Check is a given id is on sale\n', '  /// @param tokenId The id of the token in question\n', '  /// @return a bool whether of not the token is on sale\n', '  function isOnSale(uint256 tokenId) external view returns (bool) {\n', '    return ganTokenOfferedForSale[tokenId].isForSale;\n', '  }\n', '\n', '  /// @notice Gets all the sale data related to a token\n', '  /// @param tokenId The id of the token\n', '  /// @return sale information\n', '  function getSaleData(uint256 tokenId) public view returns (bool isForSale, address seller, uint value, address onlySellTo) {\n', '    Offer memory offer = ganTokenOfferedForSale[tokenId];\n', '    isForSale = offer.isForSale;\n', '    seller = offer.seller;\n', '    value = offer.value;\n', '    onlySellTo = offer.onlySellTo;\n', '  }\n', '\n', '  /// @notice Gets all the bid data related to a token\n', '  /// @param tokenId The id of the token\n', '  /// @return bid information\n', '  function getBidData(uint256 tokenId) view public returns (bool hasBid, address bidder, uint value) {\n', '    Bid memory bid = tokenBids[tokenId];\n', '    hasBid = bid.hasBid;\n', '    bidder = bid.bidder;\n', '    value = bid.value;\n', '  }\n', '\n', '  /// @notice Allows a bidder to withdraw their bid\n', '  /// @param tokenId The id of the token\n', '  function withdrawBid(uint256 tokenId) external payable {\n', '      Bid memory bid = tokenBids[tokenId];\n', '      require(tokenIdToOwner[tokenId] != msg.sender);\n', '      require(tokenIdToOwner[tokenId] != 0x0);\n', '      require(bid.bidder == msg.sender);\n', '\n', '      emit BidWithdrawn(tokenId, bid.value, msg.sender);\n', '      uint amount = bid.value;\n', '      tokenBids[tokenId] = Bid(false, tokenId, 0x0, 0);\n', '      // Refund the bid money\n', '      msg.sender.transfer(amount);\n', '  }\n', '\n', '  /// @notice Allows a sender to withdraw any amount in the contrat\n', '  function withdraw() external {\n', '    uint256 amount = pendingWithdrawals[msg.sender];\n', '    // Remember to zero the pending refund before\n', '    // sending to prevent re-entrancy attacks\n', '    pendingWithdrawals[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/// @title ERC-165 Standard Interface Detection\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', 'contract ERC721 is ERC165 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function approve(address _approved, uint256 _tokenId) external payable;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external pure returns (string _name);\n', '    function symbol() external pure returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title A reusable contract to comply with ERC-165\n', '/// @author William Entriken (https://phor.net)\n', 'contract PublishInterfaces is ERC165 {\n', '    /// @dev Every interface that we support\n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    function PublishInterfaces() internal {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title The external contract that is responsible for generating metadata for GanTokens,\n', '///  it has one function that will return the data as bytes.\n', 'contract Metadata {\n', '\n', '    /// @dev Given a token Id, returns a string with metadata\n', '    function getMetadata(uint256 _tokenId, string) public pure returns (bytes32[4] buffer, uint256 count) {\n', '        if (_tokenId == 1) {\n', '            buffer[0] = "Hello World! :D";\n', '            count = 15;\n', '        } else if (_tokenId == 2) {\n', '            buffer[0] = "I would definitely choose a medi";\n', '            buffer[1] = "um length string.";\n', '            count = 49;\n', '        } else if (_tokenId == 3) {\n', '            buffer[0] = "Lorem ipsum dolor sit amet, mi e";\n', '            buffer[1] = "st accumsan dapibus augue lorem,";\n', '            buffer[2] = " tristique vestibulum id, libero";\n', '            buffer[3] = " suscipit varius sapien aliquam.";\n', '            count = 128;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GanNFT is ERC165, ERC721, ERC721Enumerable, PublishInterfaces, Ownable {\n', '\n', '  function GanNFT() internal {\n', '      supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '      supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '      supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '      supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\n', '  }\n', '\n', '  bytes4 private constant ERC721_RECEIVED = bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '\n', '  // @dev claim price taken for each new GanToken\n', '  // generating a new token will be free in the beinging and later changed\n', '  uint256 public claimPrice = 0;\n', '\n', '  // @dev max supply for token\n', '  uint256 public maxSupply = 300;\n', '\n', '  // The contract that will return tokens metadata\n', '  Metadata public erc721Metadata;\n', '\n', '  /// @dev list of all owned token ids\n', '  uint256[] public tokenIds;\n', '\n', '  /// @dev a mpping for all tokens\n', '  mapping(uint256 => address) public tokenIdToOwner;\n', '\n', '  /// @dev mapping to keep owner balances\n', '  mapping(address => uint256) public ownershipCounts;\n', '\n', '  /// @dev mapping to owners to an array of tokens that they own\n', '  mapping(address => uint256[]) public ownerBank;\n', '\n', '  /// @dev mapping to approved ids\n', '  mapping(uint256 => address) public tokenApprovals;\n', '\n', '  /// @dev The authorized operators for each address\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /// @notice A descriptive name for a collection of NFTs in this contract\n', '  function name() external pure returns (string) {\n', '      return "GanToken";\n', '  }\n', '\n', '  /// @notice An abbreviated name for NFTs in this contract\n', '  function symbol() external pure returns (string) {\n', '      return "GT";\n', '  }\n', '\n', '  /// @dev Set the address of the sibling contract that tracks metadata.\n', '  /// Only the contract creater can call this.\n', '  /// @param _contractAddress The location of the contract with meta data\n', '  function setMetadataAddress(address _contractAddress) public onlyOwner {\n', '      erc721Metadata = Metadata(_contractAddress);\n', '  }\n', '\n', '  modifier canTransfer(uint256 _tokenId, address _from, address _to) {\n', '    address owner = tokenIdToOwner[_tokenId];\n', '    require(tokenApprovals[_tokenId] == _to || owner == _from || operatorApprovals[_to][_to]);\n', '    _;\n', '  }\n', '  /// @notice checks to see if a sender owns a _tokenId\n', '  /// @param _tokenId The identifier for an NFT\n', '  modifier owns(uint256 _tokenId) {\n', '    require(tokenIdToOwner[_tokenId] == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /// @dev This emits any time the ownership of a GanToken changes.\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /// @dev This emits when the approved addresses for a GanToken is changed or reaffirmed.\n', '  /// The zero address indicates there is no owner and it get reset on a transfer\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '  /// @dev This emits when an operator is enabled or disabled for an owner.\n', '  ///  The operator can manage all NFTs of the owner.\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  /// @notice allow the owner to set the supply max\n', '  function setMaxSupply(uint max) external payable onlyOwner {\n', '    require(max > tokenIds.length);\n', '\n', '    maxSupply = max;\n', '  }\n', '\n', '  /// @notice allow the owner to set a new fee for creating a GanToken\n', '  function setClaimPrice(uint256 price) external payable onlyOwner {\n', '    claimPrice = price;\n', '  }\n', '\n', '  /// @dev Required for ERC-721 compliance.\n', '  function balanceOf(address _owner) external view returns (uint256 balance) {\n', '    balance = ownershipCounts[_owner];\n', '  }\n', '\n', '  /// @notice Gets the onwner of a an NFT\n', '  /// @param _tokenId The identifier for an NFT\n', '  /// @dev Required for ERC-721 compliance.\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '    owner = tokenIdToOwner[_tokenId];\n', '  }\n', '\n', "  /// @notice returns all owners' tokens will return an empty array\n", '  /// if the address has no tokens\n', '  /// @param _owner The address of the owner in question\n', '  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n', '    uint256 tokenCount = ownershipCounts[_owner];\n', '\n', '    if (tokenCount == 0) {\n', '      return new uint256[](0);\n', '    }\n', '\n', '    uint256[] memory result = new uint256[](tokenCount);\n', '\n', '    for (uint256 i = 0; i < tokenCount; i++) {\n', '      result[i] = ownerBank[_owner][i];\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /// @dev creates a list of all the tokenIds\n', '  function getAllTokenIds() external view returns (uint256[]) {\n', '    uint256[] memory result = new uint256[](tokenIds.length);\n', '    for (uint i = 0; i < result.length; i++) {\n', '      result[i] = tokenIds[i];\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '  /// @notice Create a new GanToken with a id and attaches an owner\n', "  /// @param _noise The id of the token that's being created\n", '  function newGanToken(uint256 _noise) external payable {\n', '    require(msg.sender != address(0));\n', '    require(tokenIdToOwner[_noise] == 0x0);\n', '    require(tokenIds.length < maxSupply);\n', '    require(msg.value >= claimPrice);\n', '\n', '    tokenIds.push(_noise);\n', '    ownerBank[msg.sender].push(_noise);\n', '    tokenIdToOwner[_noise] = msg.sender;\n', '    ownershipCounts[msg.sender]++;\n', '\n', '    emit Transfer(address(0), msg.sender, 0);\n', '  }\n', '\n', '  /// @notice Transfers the ownership of an NFT from one address to another address\n', '  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '  ///  `onERC721Received` on `_to` and throws if the return value is not\n', '  ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  /// @param data Additional data with no specified format, sent in call to `_to`\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) public payable\n', '  {\n', '      _safeTransferFrom(_from, _to, _tokenId, data);\n', '  }\n', '\n', '  /// @notice Transfers the ownership of an NFT from one address to another address\n', '  /// @dev This works identically to the other function with an extra data parameter,\n', '  ///  except this function just sets data to ""\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable\n', '  {\n', '      _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '  ///  THEY MAY BE PERMANENTLY LOST\n', '  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '  ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '  ///  `_tokenId` is not a valid NFT.\n', '  /// @param _from The current owner of the NFT\n', '  /// @param _to The new owner\n', '  /// @param _tokenId The NFT to transfer\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\n', '    require(_to != 0x0);\n', '    require(_to != address(this));\n', '    require(tokenApprovals[_tokenId] == msg.sender);\n', '    require(tokenIdToOwner[_tokenId] == _from);\n', '\n', '    _transfer(_tokenId, _to);\n', '  }\n', '\n', '  /// @notice Grant another address the right to transfer a specific token via\n', '  ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n', '  /// @dev The zero address indicates there is no approved address.\n', '  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '  ///  operator of the current owner.\n', '  /// @dev Required for ERC-721 compliance.\n', '  /// @param _to The address to be granted transfer approval. Pass address(0) to\n', '  ///  clear all approvals.\n', '  /// @param _tokenId The ID of the Kitty that can be transferred if this call succeeds.\n', '  function approve(address _to, uint256 _tokenId) external owns(_tokenId) payable {\n', '      // Register the approval (replacing any previous approval).\n', '      tokenApprovals[_tokenId] = _to;\n', '\n', '      emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /// @notice Enable or disable approval for a third party ("operator") to manage\n', '  ///  all your asset.\n', '  /// @dev Emits the ApprovalForAll event\n', '  /// @param _operator Address to add to the set of authorized operators.\n', '  /// @param _approved True if the operators is approved, false to revoke approval\n', '  function setApprovalForAll(address _operator, bool _approved) external {\n', '      operatorApprovals[msg.sender][_operator] = _approved;\n', '      emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @notice Get the approved address for a single NFT\n', '  /// @param _tokenId The NFT to find the approved address for\n', '  /// @return The approved address for this NFT, or the zero address if there is none\n', '  function getApproved(uint256 _tokenId) external view returns (address) {\n', '      return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /// @notice Query if an address is an authorized operator for another address\n', '  /// @param _owner The address that owns the NFTs\n', '  /// @param _operator The address that acts on behalf of the owner\n', '  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '      return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  /// @dev Required for ERC-721 compliance.\n', '  function totalSupply() external view returns (uint256) {\n', '    return tokenIds.length;\n', '  }\n', '\n', '  /// @notice Enumerate valid NFTs\n', '  /// @param _index A counter less than `totalSupply()`\n', "  /// @return The token identifier for index the `_index`th NFT 0 if it doesn't exist,\n", '  function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '      return tokenIds[_index];\n', '  }\n', '\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\n', '      require(_owner != address(0));\n', '      require(_index < ownerBank[_owner].length);\n', '      _tokenId = ownerBank[_owner][_index];\n', '  }\n', '\n', '  function _transfer(uint256 _tokenId, address _to) internal {\n', '    require(_to != address(0));\n', '\n', '    address from = tokenIdToOwner[_tokenId];\n', '    uint256 tokenCount = ownershipCounts[from];\n', '    // remove from ownerBank and replace the deleted token id\n', '    for (uint256 i = 0; i < tokenCount; i++) {\n', '      uint256 ownedId = ownerBank[from][i];\n', '      if (_tokenId == ownedId) {\n', '        delete ownerBank[from][i];\n', '        if (i != tokenCount) {\n', '          ownerBank[from][i] = ownerBank[from][tokenCount - 1];\n', '        }\n', '        break;\n', '      }\n', '    }\n', '\n', '    ownershipCounts[from]--;\n', '    ownershipCounts[_to]++;\n', '    ownerBank[_to].push(_tokenId);\n', '\n', '    tokenIdToOwner[_tokenId] = _to;\n', '    tokenApprovals[_tokenId] = address(0);\n', '    emit Transfer(from, _to, 1);\n', '  }\n', '\n', '  /// @dev Actually perform the safeTransferFrom\n', '  function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\n', '      private\n', '      canTransfer(_tokenId, _from, _to)\n', '  {\n', '      address owner = tokenIdToOwner[_tokenId];\n', '\n', '      require(owner == _from);\n', '      require(_to != address(0));\n', '      require(_to != address(this));\n', '      _transfer(_tokenId, _to);\n', '\n', '\n', '      // Do the callback after everything is done to avoid reentrancy attack\n', '      uint256 codeSize;\n', '      assembly { codeSize := extcodesize(_to) }\n', '      if (codeSize == 0) {\n', '          return;\n', '      }\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '      require(retval == ERC721_RECEIVED);\n', '  }\n', '\n', '  /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n', '  ///  This method is licenced under the Apache License.\n', '  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '  function _memcpy(uint _dest, uint _src, uint _len) private pure {\n', '      // Copy word-length chunks while possible\n', '      for(; _len >= 32; _len -= 32) {\n', '          assembly {\n', '              mstore(_dest, mload(_src))\n', '          }\n', '          _dest += 32;\n', '          _src += 32;\n', '      }\n', '\n', '      // Copy remaining bytes\n', '      uint256 mask = 256 ** (32 - _len) - 1;\n', '      assembly {\n', '          let srcpart := and(mload(_src), not(mask))\n', '          let destpart := and(mload(_dest), mask)\n', '          mstore(_dest, or(destpart, srcpart))\n', '      }\n', '  }\n', '\n', '  /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n', '  ///  This method is licenced under the Apache License.\n', '  ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n', '  function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private pure returns (string) {\n', '      string memory outputString = new string(_stringLength);\n', '      uint256 outputPtr;\n', '      uint256 bytesPtr;\n', '\n', '      assembly {\n', '          outputPtr := add(outputString, 32)\n', '          bytesPtr := _rawBytes\n', '      }\n', '\n', '      _memcpy(outputPtr, bytesPtr, _stringLength);\n', '\n', '      return outputString;\n', '  }\n', '\n', '\n', '  /// @notice Returns a URI pointing to a metadata package for this token conforming to\n', '  ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)\n', '  /// @param _tokenId The ID number of the GanToken whose metadata should be returned.\n', '  function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {\n', '      require(erc721Metadata != address(0));\n', '      uint256 count;\n', '      bytes32[4] memory buffer;\n', '\n', '      (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);\n', '\n', '      return _toString(buffer, count);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract GanTokenMain is GanNFT {\n', '\n', '  struct Offer {\n', '    bool isForSale;\n', '    uint256 tokenId;\n', '    address seller;\n', '    uint value;          // in ether\n', '    address onlySellTo;     // specify to sell only to a specific person\n', '  }\n', '\n', '  struct Bid {\n', '    bool hasBid;\n', '    uint256 tokenId;\n', '    address bidder;\n', '    uint value;\n', '  }\n', '\n', '  /// @dev mapping of balances for address\n', '  mapping(address => uint256) public pendingWithdrawals;\n', '\n', '  /// @dev mapping of tokenId to to an offer\n', '  mapping(uint256 => Offer) public ganTokenOfferedForSale;\n', '\n', '  /// @dev mapping bids to tokenIds\n', '  mapping(uint256 => Bid) public tokenBids;\n', '\n', '  event BidForGanTokenOffered(uint256 tokenId, uint256 value, address sender);\n', '  event BidWithdrawn(uint256 tokenId, uint256 value, address bidder);\n', '  event GanTokenOfferedForSale(uint256 tokenId, uint256 minSalePriceInWei, address onlySellTo);\n', '  event GanTokenNoLongerForSale(uint256 tokenId);\n', '\n', '\n', '  /// @notice Allow a token owner to pull sale\n', "  /// @param tokenId The id of the token that's created\n", '  function ganTokenNoLongerForSale(uint256 tokenId) public payable owns(tokenId) {\n', '    ganTokenOfferedForSale[tokenId] = Offer(false, tokenId, msg.sender, 0, 0x0);\n', '\n', '    emit GanTokenNoLongerForSale(tokenId);\n', '  }\n', '\n', '  /// @notice Put a token up for sale\n', "  /// @param tokenId The id of the token that's created\n", '  /// @param minSalePriceInWei desired price of token\n', '  function offerGanTokenForSale(uint tokenId, uint256 minSalePriceInWei) external payable owns(tokenId) {\n', '    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, 0x0);\n', '\n', '    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, 0x0);\n', '  }\n', '\n', '  /// @notice Create a new GanToken with a id and attaches an owner\n', "  /// @param tokenId The id of the token that's being created\n", '  function offerGanTokenForSaleToAddress(uint tokenId, address sendTo, uint256 minSalePriceInWei) external payable {\n', '    require(tokenIdToOwner[tokenId] == msg.sender);\n', '    ganTokenOfferedForSale[tokenId] = Offer(true, tokenId, msg.sender, minSalePriceInWei, sendTo);\n', '\n', '    emit GanTokenOfferedForSale(tokenId, minSalePriceInWei, sendTo);\n', '  }\n', '\n', '  /// @notice Allows an account to buy a NFT gan token that is up for offer\n', '  /// the token owner must set onlySellTo to the sender\n', '  /// @param id the id of the token\n', '  function buyGanToken(uint256 id) public payable {\n', '    Offer memory offer = ganTokenOfferedForSale[id];\n', '    require(offer.isForSale);\n', '    require(offer.onlySellTo == msg.sender && offer.onlySellTo != 0x0);\n', '    require(msg.value == offer.value);\n', '    require(tokenIdToOwner[id] == offer.seller);\n', '\n', '    safeTransferFrom(offer.seller, offer.onlySellTo, id);\n', '\n', '    ganTokenOfferedForSale[id] = Offer(false, id, offer.seller, 0, 0x0);\n', '\n', '    pendingWithdrawals[offer.seller] += msg.value;\n', '  }\n', '\n', '  /// @notice Allows an account to enter a higher bid on a toekn\n', '  /// @param tokenId the id of the token\n', '  function enterBidForGanToken(uint256 tokenId) external payable {\n', '    Bid memory existing = tokenBids[tokenId];\n', '    require(tokenIdToOwner[tokenId] != msg.sender);\n', '    require(tokenIdToOwner[tokenId] != 0x0);\n', '    require(msg.value > existing.value);\n', '    if (existing.value > 0) {\n', '      // Refund the failing bid\n', '      pendingWithdrawals[existing.bidder] += existing.value;\n', '    }\n', '\n', '    tokenBids[tokenId] = Bid(true, tokenId, msg.sender, msg.value);\n', '    emit BidForGanTokenOffered(tokenId, msg.value, msg.sender);\n', '  }\n', '\n', '  /// @notice Allows the owner of a token to accept an outstanding bid for that token\n', "  /// @param tokenId The id of the token that's being created\n", '  /// @param price The desired price of token in wei\n', '  function acceptBid(uint256 tokenId, uint256 price) external payable {\n', '    require(tokenIdToOwner[tokenId] == msg.sender);\n', '    Bid memory bid = tokenBids[tokenId];\n', '    require(bid.value != 0);\n', '    require(bid.value == price);\n', '\n', '    safeTransferFrom(msg.sender, bid.bidder, tokenId);\n', '\n', '    tokenBids[tokenId] = Bid(false, tokenId, address(0), 0);\n', '    pendingWithdrawals[msg.sender] += bid.value;\n', '  }\n', '\n', '  /// @notice Check is a given id is on sale\n', '  /// @param tokenId The id of the token in question\n', '  /// @return a bool whether of not the token is on sale\n', '  function isOnSale(uint256 tokenId) external view returns (bool) {\n', '    return ganTokenOfferedForSale[tokenId].isForSale;\n', '  }\n', '\n', '  /// @notice Gets all the sale data related to a token\n', '  /// @param tokenId The id of the token\n', '  /// @return sale information\n', '  function getSaleData(uint256 tokenId) public view returns (bool isForSale, address seller, uint value, address onlySellTo) {\n', '    Offer memory offer = ganTokenOfferedForSale[tokenId];\n', '    isForSale = offer.isForSale;\n', '    seller = offer.seller;\n', '    value = offer.value;\n', '    onlySellTo = offer.onlySellTo;\n', '  }\n', '\n', '  /// @notice Gets all the bid data related to a token\n', '  /// @param tokenId The id of the token\n', '  /// @return bid information\n', '  function getBidData(uint256 tokenId) view public returns (bool hasBid, address bidder, uint value) {\n', '    Bid memory bid = tokenBids[tokenId];\n', '    hasBid = bid.hasBid;\n', '    bidder = bid.bidder;\n', '    value = bid.value;\n', '  }\n', '\n', '  /// @notice Allows a bidder to withdraw their bid\n', '  /// @param tokenId The id of the token\n', '  function withdrawBid(uint256 tokenId) external payable {\n', '      Bid memory bid = tokenBids[tokenId];\n', '      require(tokenIdToOwner[tokenId] != msg.sender);\n', '      require(tokenIdToOwner[tokenId] != 0x0);\n', '      require(bid.bidder == msg.sender);\n', '\n', '      emit BidWithdrawn(tokenId, bid.value, msg.sender);\n', '      uint amount = bid.value;\n', '      tokenBids[tokenId] = Bid(false, tokenId, 0x0, 0);\n', '      // Refund the bid money\n', '      msg.sender.transfer(amount);\n', '  }\n', '\n', '  /// @notice Allows a sender to withdraw any amount in the contrat\n', '  function withdraw() external {\n', '    uint256 amount = pendingWithdrawals[msg.sender];\n', '    // Remember to zero the pending refund before\n', '    // sending to prevent re-entrancy attacks\n', '    pendingWithdrawals[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '}']
