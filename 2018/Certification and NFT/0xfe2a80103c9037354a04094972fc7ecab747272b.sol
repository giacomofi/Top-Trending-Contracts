['contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract COE {\n', '\n', '    string public name = "Coeval by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "COE";\n', '\n', '    address public owner;\n', '    address public devFeesAddr = 0xF772464393Ac87a1b7C628bF79090e014d931A23;\n', '    address public premine;\n', '    address tierController;\n', '\n', '    uint256[] tierTokens = [\n', '        1000000000000000000000,\n', '        900000000000000000000,\n', '        800000000000000000000,\n', '        700000000000000000000,\n', '        2300000000000000000000,\n', '        6500000000000000000000,\n', '        2000000000000000000000,\n', '        1200000000000000000000,\n', '        4500000000000000000000,\n', '        75000000000000000000\n', '    ];\n', '\n', '    // cost per token (cents *10^18) amounts for each tier.\n', '    uint256[] costPerToken = [\n', '        3.85E21,\n', '        6.1E21,\n', '        4.15E21,\n', '        5.92E21,\n', '        9.47E21,\n', '        1.1E22,\n', '        1.123E22,\n', '        1.115E22,\n', '        1.135E22,\n', '        1.013E22\n', '    ];\n', '\n', '    uint256 public totalSupply = 100000000000000000000000;\n', '    uint tierLevel = 0;\n', '    uint fiatPerEth = 385000000000000000000000;    // cents per ETH in this case (*10^18)\n', '    uint256 circulatingSupply = 0;\n', '    uint maxTier = 9;\n', '    uint256 devFees = 0;\n', '    uint256 fees = 10000;  // the calculation expects % * 100 (so 10% is 1000)\n', '\n', '    // flags\n', '    bool public receiveEth = true;\n', '    bool payFees = true;\n', '    bool distributionDone = false;\n', '    bool canExchange = true;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => bool) public exchangePartners;\n', '\n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    function COE() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function premine() public {\n', '        require(msg.sender == owner);\n', '        balances[premine] = add(balances[premine],32664993546427000000000);\n', '        Transfer(this, premine, 32664993546427000000000);\n', '        circulatingSupply = add(circulatingSupply, 32664993546427000000000);\n', '        totalSupply = sub(totalSupply,32664993546427000000000);\n', '    }\n', '\n', '    function () payable public {\n', '        require((msg.value > 0) && (receiveEth));\n', '\n', '        if(payFees) {\n', '            devFees = add(devFees, ((msg.value * fees) / 10000));\n', '        }\n', '        allocateTokens(convertEthToCents(msg.value));\n', '    }\n', '\n', '    function convertEthToCents(uint256 _incoming) internal returns (uint256) {\n', '        return mul(_incoming, fiatPerEth);\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted) internal {\n', '        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\n', '        uint256 _allocation = 0;\n', '        // multiply _submitted by cost per token and see if that is greater than _availableInTier\n', '\n', '        if(_submitted >= _availableInTier) {\n', '            _allocation = tierTokens[tierLevel];\n', '            tierTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '        else {\n', '            uint256 _tokens = div(div(mul(_submitted, 1 ether), costPerToken[tierLevel]), 1 ether);\n', '            _allocation = add(_allocation, _tokens);\n', '            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\n', '            _submitted = sub(_submitted, mul(_tokens, costPerToken[tierLevel]));\n', '        }\n', '\n', '        // transfer tokens allocated so far to wallet address from contract\n', '        balances[msg.sender] = add(balances[msg.sender],_allocation);\n', '        circulatingSupply = add(circulatingSupply, _allocation);\n', '        totalSupply = sub(totalSupply, _allocation);\n', '\n', '        if((_submitted != 0) && (tierLevel <= maxTier)) {\n', '            allocateTokens(_submitted);\n', '        }\n', '        else {\n', '            // emit transfer event\n', '            Transfer(this, msg.sender, balances[msg.sender]);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '        totalSupply = add(totalSupply, _value);\n', '        circulatingSupply = sub(circulatingSupply, _value);\n', '\n', '        if(_to == address(this)) {\n', '            // WARNING: if you transfer tokens back to the contract you will lose them\n', '            // use the exchange function to exchange for tokens with approved partner contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        else {\n', '            uint codeLength;\n', '\n', '            assembly {\n', '                codeLength := extcodesize(_to)\n', '            }\n', '\n', '            if(codeLength != 0) {\n', '                if(exchangePartners[_to]) {\n', '                    if(canExchange == true) {\n', '                        exchange(_to, _value);\n', '                    }\n', '                    else revert();  // until MNY is ready to accept COE revert attempts to exchange\n', '                }\n', '                else {\n', '                    // WARNING: if you transfer to a contract that cannot handle incoming tokens you may lose them\n', '                    balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                    balances[_to] = add(balances[_to], _value);\n', '                    Transfer(msg.sender, _to, _value);\n', '                }\n', '            }\n', '            else {\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                balances[_to] = add(balances[_to], _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '        }\n', '    }\n', '\n', '    function exchange(address _partner, uint _amount) internal {\n', '        require(exchangePartners[_partner]);\n', '        require(requestTokensFromOtherContract(_partner, this, msg.sender, _amount));\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _amount);\n', '        circulatingSupply = sub(circulatingSupply, _amount);\n', '        totalSupply = add(totalSupply, _amount);\n', '        Transfer(msg.sender, this, _amount);\n', '    }\n', '\n', '    function requestTokensFromOtherContract(address _targetContract, address _sourceContract, address _recipient, uint256 _value) internal returns (bool){\n', '        Partner p = Partner(_targetContract);\n', '        p.exchangeTokensFromOtherContract(_sourceContract, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return tierTokens[tierLevel];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    function setFiatPerEthRate(uint256 _newRate) {\n', '        require(msg.sender == owner);\n', '        fiatPerEth = _newRate;\n', '    }\n', '\n', '    function addExchangePartnerTargetAddress(address _partner) public {\n', '        require(msg.sender == owner);\n', '        exchangePartners[_partner] = true;\n', '    }\n', '\n', '    function canContractExchange(address _contract) public constant returns (bool) {\n', '        return exchangePartners[_contract];\n', '    }\n', '\n', '    function removeExchangePartnerTargetAddress(address _partner) public {\n', '        require(msg.sender == owner);\n', '        exchangePartners[_partner] = false;\n', '    }\n', '\n', '    function withdrawDevFees() public {\n', '        require(payFees);\n', '        devFeesAddr.transfer(devFees);\n', '        devFees = 0;\n', '    }\n', '\n', '    function changeDevFees(address _devFees) public {\n', '        require(msg.sender == owner);\n', '        devFeesAddr = _devFees;\n', '    }\n', '\n', '    function changePreMine(address _preMine) {\n', '        require(msg.sender == owner);\n', '        premine = _preMine;\n', '    }\n', '\n', '    function payFeesToggle() {\n', '        require(msg.sender == owner);\n', '        if(payFees) {\n', '            payFees = false;\n', '        }\n', '        else {\n', '            payFees = true;\n', '        }\n', '    }\n', '\n', '    function safeWithdrawal(address _receiver, uint256 _value) public {\n', '        require(msg.sender == owner);\n', '        // check balance before transferring\n', '        require(_value <= this.balance);\n', '        _receiver.transfer(_value);\n', '    }\n', '\n', '    // enables fee update - must be between 0 and 100 (%)\n', '    function updateFeeAmount(uint _newFee) public {\n', '        require(msg.sender == owner);\n', '        require((_newFee >= 0) && (_newFee <= 100));\n', '        fees = _newFee * 100;\n', '    }\n', '\n', '    function handleTokensFromOtherContracts(address _contract, address _recipient, uint256 _tokens) {\n', '        require(msg.sender == owner);\n', '        Target t;\n', '        t = Target(_contract);\n', '        t.transfer(_recipient, _tokens);\n', '    }\n', '\n', '    function changeOwner(address _recipient) {\n', '        require(msg.sender == owner);\n', '        owner = _recipient;\n', '    }\n', '\n', '    function changeTierController(address _controller) {\n', '        require(msg.sender == owner);\n', '        tierController = _controller;\n', '    }\n', '\n', '    function setTokenAndRate(uint256 _tokens, uint256 _rate) {\n', '        require((msg.sender == owner) || (msg.sender == tierController));\n', '        maxTier++;\n', '        tierTokens[maxTier] = _tokens;\n', '        costPerToken[maxTier] = _rate;\n', '    }\n', '\n', '    function setPreMineAddress(address _premine) {\n', '        require(msg.sender == owner);\n', '        premine = _premine;\n', '    }\n', '\n', '    function toggleReceiveEth() {\n', '        require(msg.sender == owner);\n', '        if(receiveEth == true) {\n', '            receiveEth = false;\n', '        }\n', '        else receiveEth = true;\n', '    }\n', '\n', '    function toggleTokenExchange() {\n', '        require(msg.sender == owner);\n', '        if(canExchange == true) {\n', '            canExchange = false;\n', '        }\n', '        else canExchange = true;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
['contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract COE {\n', '\n', '    string public name = "Coeval by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "COE";\n', '\n', '    address public owner;\n', '    address public devFeesAddr = 0xF772464393Ac87a1b7C628bF79090e014d931A23;\n', '    address public premine;\n', '    address tierController;\n', '\n', '    uint256[] tierTokens = [\n', '        1000000000000000000000,\n', '        900000000000000000000,\n', '        800000000000000000000,\n', '        700000000000000000000,\n', '        2300000000000000000000,\n', '        6500000000000000000000,\n', '        2000000000000000000000,\n', '        1200000000000000000000,\n', '        4500000000000000000000,\n', '        75000000000000000000\n', '    ];\n', '\n', '    // cost per token (cents *10^18) amounts for each tier.\n', '    uint256[] costPerToken = [\n', '        3.85E21,\n', '        6.1E21,\n', '        4.15E21,\n', '        5.92E21,\n', '        9.47E21,\n', '        1.1E22,\n', '        1.123E22,\n', '        1.115E22,\n', '        1.135E22,\n', '        1.013E22\n', '    ];\n', '\n', '    uint256 public totalSupply = 100000000000000000000000;\n', '    uint tierLevel = 0;\n', '    uint fiatPerEth = 385000000000000000000000;    // cents per ETH in this case (*10^18)\n', '    uint256 circulatingSupply = 0;\n', '    uint maxTier = 9;\n', '    uint256 devFees = 0;\n', '    uint256 fees = 10000;  // the calculation expects % * 100 (so 10% is 1000)\n', '\n', '    // flags\n', '    bool public receiveEth = true;\n', '    bool payFees = true;\n', '    bool distributionDone = false;\n', '    bool canExchange = true;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => bool) public exchangePartners;\n', '\n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    function COE() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function premine() public {\n', '        require(msg.sender == owner);\n', '        balances[premine] = add(balances[premine],32664993546427000000000);\n', '        Transfer(this, premine, 32664993546427000000000);\n', '        circulatingSupply = add(circulatingSupply, 32664993546427000000000);\n', '        totalSupply = sub(totalSupply,32664993546427000000000);\n', '    }\n', '\n', '    function () payable public {\n', '        require((msg.value > 0) && (receiveEth));\n', '\n', '        if(payFees) {\n', '            devFees = add(devFees, ((msg.value * fees) / 10000));\n', '        }\n', '        allocateTokens(convertEthToCents(msg.value));\n', '    }\n', '\n', '    function convertEthToCents(uint256 _incoming) internal returns (uint256) {\n', '        return mul(_incoming, fiatPerEth);\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted) internal {\n', '        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\n', '        uint256 _allocation = 0;\n', '        // multiply _submitted by cost per token and see if that is greater than _availableInTier\n', '\n', '        if(_submitted >= _availableInTier) {\n', '            _allocation = tierTokens[tierLevel];\n', '            tierTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '        else {\n', '            uint256 _tokens = div(div(mul(_submitted, 1 ether), costPerToken[tierLevel]), 1 ether);\n', '            _allocation = add(_allocation, _tokens);\n', '            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\n', '            _submitted = sub(_submitted, mul(_tokens, costPerToken[tierLevel]));\n', '        }\n', '\n', '        // transfer tokens allocated so far to wallet address from contract\n', '        balances[msg.sender] = add(balances[msg.sender],_allocation);\n', '        circulatingSupply = add(circulatingSupply, _allocation);\n', '        totalSupply = sub(totalSupply, _allocation);\n', '\n', '        if((_submitted != 0) && (tierLevel <= maxTier)) {\n', '            allocateTokens(_submitted);\n', '        }\n', '        else {\n', '            // emit transfer event\n', '            Transfer(this, msg.sender, balances[msg.sender]);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '        totalSupply = add(totalSupply, _value);\n', '        circulatingSupply = sub(circulatingSupply, _value);\n', '\n', '        if(_to == address(this)) {\n', '            // WARNING: if you transfer tokens back to the contract you will lose them\n', '            // use the exchange function to exchange for tokens with approved partner contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        else {\n', '            uint codeLength;\n', '\n', '            assembly {\n', '                codeLength := extcodesize(_to)\n', '            }\n', '\n', '            if(codeLength != 0) {\n', '                if(exchangePartners[_to]) {\n', '                    if(canExchange == true) {\n', '                        exchange(_to, _value);\n', '                    }\n', '                    else revert();  // until MNY is ready to accept COE revert attempts to exchange\n', '                }\n', '                else {\n', '                    // WARNING: if you transfer to a contract that cannot handle incoming tokens you may lose them\n', '                    balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                    balances[_to] = add(balances[_to], _value);\n', '                    Transfer(msg.sender, _to, _value);\n', '                }\n', '            }\n', '            else {\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                balances[_to] = add(balances[_to], _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '        }\n', '    }\n', '\n', '    function exchange(address _partner, uint _amount) internal {\n', '        require(exchangePartners[_partner]);\n', '        require(requestTokensFromOtherContract(_partner, this, msg.sender, _amount));\n', '        balances[msg.sender] = sub(balanceOf(msg.sender), _amount);\n', '        circulatingSupply = sub(circulatingSupply, _amount);\n', '        totalSupply = add(totalSupply, _amount);\n', '        Transfer(msg.sender, this, _amount);\n', '    }\n', '\n', '    function requestTokensFromOtherContract(address _targetContract, address _sourceContract, address _recipient, uint256 _value) internal returns (bool){\n', '        Partner p = Partner(_targetContract);\n', '        p.exchangeTokensFromOtherContract(_sourceContract, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return tierTokens[tierLevel];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    function setFiatPerEthRate(uint256 _newRate) {\n', '        require(msg.sender == owner);\n', '        fiatPerEth = _newRate;\n', '    }\n', '\n', '    function addExchangePartnerTargetAddress(address _partner) public {\n', '        require(msg.sender == owner);\n', '        exchangePartners[_partner] = true;\n', '    }\n', '\n', '    function canContractExchange(address _contract) public constant returns (bool) {\n', '        return exchangePartners[_contract];\n', '    }\n', '\n', '    function removeExchangePartnerTargetAddress(address _partner) public {\n', '        require(msg.sender == owner);\n', '        exchangePartners[_partner] = false;\n', '    }\n', '\n', '    function withdrawDevFees() public {\n', '        require(payFees);\n', '        devFeesAddr.transfer(devFees);\n', '        devFees = 0;\n', '    }\n', '\n', '    function changeDevFees(address _devFees) public {\n', '        require(msg.sender == owner);\n', '        devFeesAddr = _devFees;\n', '    }\n', '\n', '    function changePreMine(address _preMine) {\n', '        require(msg.sender == owner);\n', '        premine = _preMine;\n', '    }\n', '\n', '    function payFeesToggle() {\n', '        require(msg.sender == owner);\n', '        if(payFees) {\n', '            payFees = false;\n', '        }\n', '        else {\n', '            payFees = true;\n', '        }\n', '    }\n', '\n', '    function safeWithdrawal(address _receiver, uint256 _value) public {\n', '        require(msg.sender == owner);\n', '        // check balance before transferring\n', '        require(_value <= this.balance);\n', '        _receiver.transfer(_value);\n', '    }\n', '\n', '    // enables fee update - must be between 0 and 100 (%)\n', '    function updateFeeAmount(uint _newFee) public {\n', '        require(msg.sender == owner);\n', '        require((_newFee >= 0) && (_newFee <= 100));\n', '        fees = _newFee * 100;\n', '    }\n', '\n', '    function handleTokensFromOtherContracts(address _contract, address _recipient, uint256 _tokens) {\n', '        require(msg.sender == owner);\n', '        Target t;\n', '        t = Target(_contract);\n', '        t.transfer(_recipient, _tokens);\n', '    }\n', '\n', '    function changeOwner(address _recipient) {\n', '        require(msg.sender == owner);\n', '        owner = _recipient;\n', '    }\n', '\n', '    function changeTierController(address _controller) {\n', '        require(msg.sender == owner);\n', '        tierController = _controller;\n', '    }\n', '\n', '    function setTokenAndRate(uint256 _tokens, uint256 _rate) {\n', '        require((msg.sender == owner) || (msg.sender == tierController));\n', '        maxTier++;\n', '        tierTokens[maxTier] = _tokens;\n', '        costPerToken[maxTier] = _rate;\n', '    }\n', '\n', '    function setPreMineAddress(address _premine) {\n', '        require(msg.sender == owner);\n', '        premine = _premine;\n', '    }\n', '\n', '    function toggleReceiveEth() {\n', '        require(msg.sender == owner);\n', '        if(receiveEth == true) {\n', '            receiveEth = false;\n', '        }\n', '        else receiveEth = true;\n', '    }\n', '\n', '    function toggleTokenExchange() {\n', '        require(msg.sender == owner);\n', '        if(canExchange == true) {\n', '            canExchange = false;\n', '        }\n', '        else canExchange = true;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
