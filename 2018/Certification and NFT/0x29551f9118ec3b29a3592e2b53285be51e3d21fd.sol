['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '   function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '\n', '  event Approval(address indexed owner,address indexed spender,uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(ERC20 token,address from,address to,uint256 value) internal{\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '\n', 'contract PurchaseAdmin is Ownable{\n', '    \n', '  address public purchaseAdmin;\n', '  \n', '  bool public purchaseEnable = true;\n', '  \n', '  bool public grantEnable = true;\n', '  \n', '  //申购开始时间\n', '  uint256 public startAt;\n', '\n', '  //停止申购时间\n', '  uint256 public stopAt;\n', '\n', '  //发放时间\n', '  uint256 public grantAt;\n', '  \n', '  event PurchaseEnable(address indexed from, bool enable);\n', '  \n', '  event GrantEnable(address indexed from, bool enable);\n', '\n', '  function PurchaseAdmin() public{\n', '    purchaseAdmin = msg.sender;\n', '  }\n', '\n', '  function setPurchaseAdmin(address _purchaseAdmin) onlyOwner public {\n', '    purchaseAdmin = _purchaseAdmin;\n', '  }\n', '\n', '  modifier onlyPurchaseAdmin() {\n', '    require(msg.sender == purchaseAdmin);\n', '    _;\n', '  }\n', '  \n', '  function setEnablePurchase(bool enable ) onlyPurchaseAdmin public {\n', '    purchaseEnable = enable;\n', '    emit PurchaseEnable(msg.sender,enable);\n', '  }\n', '  \n', '  modifier checkPurchaseEnable() {\n', '    require(purchaseEnable);\n', '     require(block.timestamp >= startAt && block.timestamp <= stopAt);//要求在申购期内\n', '    _;\n', '  }\n', '\n', '  function setGrantEnable(bool enable ) onlyOwner public {\n', '    grantEnable = enable;\n', '    emit GrantEnable(msg.sender,enable);\n', '  }\n', '\n', '   modifier checkGrantEnable() {\n', '    require(grantEnable);\n', '    require(block.timestamp >= grantAt);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '//申购合约\n', 'contract MyPurchaseContract is Ownable,PurchaseAdmin{\n', '\n', '  using SafeMath for uint256;\n', '\n', '  using SafeERC20 for ERC20;\n', '\n', '  ERC20 public token;\n', '\n', '  //可申购总量\n', '  uint256 public totalAllocatedPurchase;\n', '\n', '  //剩余可申购数量\n', '  uint256 public remainingPurchaseAmount;\n', '\n', '  //以太币申购兑换代币的比例为1ether = 500UHT \n', '  uint256 public buyPrice =  (10 ** uint256(18)) / (500* (10 ** uint256(6)));\n', '  \n', '  //单个地址申购代币总额度有限制，申购代币不能超过100000个UHT\n', '  uint256 public maxPurchase = 100000;\n', '\n', '  //每次申购代币最多申购代币5000个UHT\n', '  uint256 public maxPurchaseOnce = 50000;\n', '\n', '  //每次申购代币最少申购代币100个UHT\n', '  uint256 public minPurchaseOnce = 1000;\n', '\n', '  //发放数次\n', '  uint256 grantCount = 0;\n', '\n', '  struct PurchaseData{\n', '    //已申购数量\n', '    uint256 amount;\n', '    \n', '    //已发放代币\n', '    bool grantDone;\n', '  }\n', '\n', '  //申购详情\n', '  mapping (address => PurchaseData) public purchasedDatas;\n', '\n', '  //申购申购者钱包地址\n', '  address[]  public purchasedWallets;\n', '\n', '  event Purchase(address indexed from, uint256 value);\n', '\n', '  event Grant(address indexed to, uint256 value);\n', '\n', '  function MyPurchaseContract(address _token) public {\n', '    token = ERC20(_token);\n', '    totalAllocatedPurchase = token.totalSupply().mul(30).div(100);//可申购总发行量的30%;\n', '    remainingPurchaseAmount = totalAllocatedPurchase;\n', '    startAt = block.timestamp;//申购开始时间\n', '    stopAt = block.timestamp + 60;//停止申购时间\n', '    grantAt = block.timestamp + 120;//发放时间\n', '  }\n', '\n', '  //申购  \n', '  function buyTokens()  payable checkPurchaseEnable public returns(uint256){\n', '      \n', '    require(msg.value > 0);\n', '\n', '    require(remainingPurchaseAmount > 0);//剩余可申购的总额度\n', '\n', '    require(purchasedDatas[msg.sender].amount < maxPurchase);//尚未超出单个地址申购代币总额度限制\n', '    \n', '    uint256 hopeAmount = msg.value.div(buyPrice);//计算用户期望申购的数量\n', '\n', '    //首次购买，必须最少申购minPurchaseOnce个代币\n', '    if (purchasedDatas[msg.sender].amount == 0 && hopeAmount < minPurchaseOnce) {\n', '      msg.sender.transfer(msg.value);//不成交，原路退还以太币\n', '      return 0;\n', '    }\n', '\n', '    uint256 currentAmount = hopeAmount;\n', '\n', '    //不能超出单次最大申购额度\n', '    if (hopeAmount >= maxPurchaseOnce) {\n', '       currentAmount = maxPurchaseOnce;\n', '    } \n', '\n', '    //不能超出剩余可申购额度\n', '    if (currentAmount >= remainingPurchaseAmount) {\n', '       currentAmount = remainingPurchaseAmount;\n', '    } \n', '\n', '    //首次申购，记录钱包地址\n', '    if (purchasedDatas[msg.sender].amount == 0){\n', '       purchasedWallets.push(msg.sender);\n', '    }\n', '\n', '    purchasedDatas[msg.sender].amount = purchasedDatas[msg.sender].amount.add(currentAmount);\n', '    \n', '    remainingPurchaseAmount = remainingPurchaseAmount.sub(currentAmount);\n', '    \n', '    emit Purchase(msg.sender,currentAmount);  \n', '\n', '    if (hopeAmount > currentAmount){\n', '      //超出申购额度的ether返回给用户\n', '      uint256 out = hopeAmount.sub(currentAmount);\n', '      //计算需要退还的ether\n', '      uint256 retwei = out.mul(buyPrice);\n', '      //退还ether\n', '      msg.sender.transfer(retwei);\n', '    }\n', '\n', '    return currentAmount;\n', '  }\n', '\n', '\n', '  //发放\n', '  function grantTokens(address _purchaser) onlyPurchaseAdmin checkGrantEnable public returns(bool){\n', '      \n', '    require(_purchaser  != address(0));\n', '    \n', '    require(purchasedDatas[_purchaser].grantDone);\n', '    \n', '    uint256 amount = purchasedDatas[_purchaser].amount;\n', '    \n', '    token.safeTransfer(_purchaser,amount);\n', '    \n', '    purchasedDatas[_purchaser].grantDone = true;\n', '    \n', '    grantCount = grantCount.add(1);\n', '\n', '    emit Grant(_purchaser,amount);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '  function claimETH() onlyPurchaseAdmin public returns(bool){\n', '\n', '    require(block.timestamp > grantAt);\n', '\n', '    require(grantCount == purchasedWallets.length);\n', '    \n', '    msg.sender.transfer(address(this).balance);\n', '    \n', '    return true;\n', '  }\n', '}']