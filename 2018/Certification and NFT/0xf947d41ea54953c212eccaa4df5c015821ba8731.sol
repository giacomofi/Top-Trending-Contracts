['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;C4F&#39; Coins4Favors contracts\n', '//\n', '// contracts for C4FEscrow and C4FToken Crowdsale\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;C4F&#39; FavorEscrow contract\n', '//\n', '// Escrow contract for favor request\n', '// allows to reserve tokens till a favor is completed, cancelled or arbitrated\n', '// handles requester and provider interaction, payout, cancellation and\n', '// arbitration if needed.\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract C4FEscrow {\n', '\n', '    using SafeMath for uint;\n', '    \n', '    address public owner;\n', '    address public requester;\n', '    address public provider;\n', '\n', '    uint256 public startTime;\n', '    uint256 public closeTime;\n', '    uint256 public deadline;\n', '    \n', '    uint256 public C4FID;\n', '    uint8   public status;\n', '    bool    public requesterLocked;\n', '    bool    public providerLocked;\n', '    bool    public providerCompleted;\n', '    bool    public requesterDisputed;\n', '    bool    public providerDisputed;\n', '    uint8   public arbitrationCosts;\n', '\n', '    event ownerChanged(address oldOwner, address newOwner);   \n', '    event deadlineChanged(uint256 oldDeadline, uint256 newDeadline);\n', '    event favorDisputed(address disputer);\n', '    event favorUndisputed(address undisputer);\n', '    event providerSet(address provider);\n', '    event providerLockSet(bool lockstat);\n', '    event providerCompletedSet(bool completed_status);\n', '    event requesterLockSet(bool lockstat);\n', '    event favorCompleted(address provider, uint256 tokenspaid);\n', '    event favorCancelled(uint256 tokensreturned);\n', '    event tokenOfferChanged(uint256 oldValue, uint256 newValue);\n', '    event escrowArbitrated(address provider, uint256 coinsreturned, uint256 fee);\n', '\n', '// ----------------------------------------------------------------------------\n', '// modifiers used in this contract to restrict function calls\n', '// ----------------------------------------------------------------------------\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }   \n', '\n', '    modifier onlyRequester {\n', '        require(msg.sender == requester);\n', '        _;\n', '    }   \n', '    \n', '    modifier onlyProvider {\n', '        require(msg.sender == provider);\n', '        _;\n', '    }   \n', '\n', '    modifier onlyOwnerOrRequester {\n', '        require((msg.sender == owner) || (msg.sender == requester)) ;\n', '        _;\n', '    }   \n', '    \n', '    modifier onlyOwnerOrProvider {\n', '        require((msg.sender == owner) || (msg.sender == provider)) ;\n', '        _;        \n', '    }\n', '    \n', '    modifier onlyProviderOrRequester {\n', '        require((msg.sender == requester) || (msg.sender == provider)) ;\n', '        _;        \n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Constructor\n', '    // ----------------------------------------------------------------------------\n', '    function C4FEscrow(address newOwner, uint256 ID, address req, uint256 deadl, uint8 arbCostPercent) public {\n', '        owner       = newOwner; // main contract\n', '        C4FID       = ID;\n', '        requester   = req;\n', '        provider    = address(0);\n', '        startTime   = now;\n', '        deadline    = deadl;\n', '        status      = 1;        // 1 = open, 2 = cancelled, 3=closed, 4=arbitrated\n', '        arbitrationCosts    = arbCostPercent;\n', '        requesterLocked     = false;\n', '        providerLocked      = false;\n', '        providerCompleted   = false;\n', '        requesterDisputed   = false;\n', '        providerDisputed    = false;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // returns the owner of the Escrow contract. This is the main C4F Token contract\n', '    // ----------------------------------------------------------------------------\n', '    function getOwner() public view returns (address ownner) {\n', '        return owner;\n', '    } \n', '    \n', '    function setOwner(address newOwner) public onlyOwner returns (bool success) {\n', '        require(newOwner != address(0));\n', '        ownerChanged(owner,newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Requester of the Escrow contract. This is the originator of the favor request\n', '    // ----------------------------------------------------------------------------\n', '    function getRequester() public view returns (address req) {\n', '        return requester;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Provider of the Escrow contract. This is the favor provider\n', '    // ----------------------------------------------------------------------------\n', '    function getProvider() public view returns (address prov) {\n', '        return provider;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the startTime of the Escrow contract which is the time it was created\n', '    // ----------------------------------------------------------------------------\n', '    function getStartTime() public view returns (uint256 st) {\n', '        return startTime;\n', '    }    \n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Deadline of the Escrow contract by which completion is needed\n', '    // Reqeuster can cancel the Escrow 12 hours after deadline expires if favor\n', '    // is not marked as completed by provider\n', '    // ----------------------------------------------------------------------------\n', '    function getDeadline() public view returns (uint256 actDeadline) {\n', '        actDeadline = deadline;\n', '        return actDeadline;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // adjusts the Deadline of the Escrow contract by which completion is needed\n', '    // Reqeuster can only change this till a provider accepted (locked) the contract\n', '    // ----------------------------------------------------------------------------\n', '    function changeDeadline(uint newDeadline) public onlyRequester returns (bool success) {\n', '        // deadline can only be changed if not locked by provider and not completed\n', '        require ((!providerLocked) && (!providerDisputed) && (!providerCompleted) && (status==1));\n', '        deadlineChanged(newDeadline, deadline);\n', '        deadline = newDeadline;\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the status of the Escrow contract\n', '    // ----------------------------------------------------------------------------\n', '    function getStatus() public view returns (uint8 s) {\n', '        return status;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Initiates dispute of the Escrow contract. Once requester or provider disputeFavor\n', '    // because they cannot agree on completion, the C4F system can arbitrate the Escrow\n', '    // based on the internal juror system.\n', '    // ----------------------------------------------------------------------------\n', '    function disputeFavor() public onlyProviderOrRequester returns (bool success) {\n', '        if(msg.sender == requester) {\n', '            requesterDisputed = true;\n', '        }\n', '        if(msg.sender == provider) {\n', '            providerDisputed = true;\n', '            providerLocked = true;\n', '        }\n', '        favorDisputed(msg.sender);\n', '        return true;\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // Allows to take back a dispute on the Escrow if conflict has been resolved\n', '    // ----------------------------------------------------------------------------\n', '    function undisputeFavor() public onlyProviderOrRequester returns (bool success) {\n', '        if(msg.sender == requester) {\n', '            requesterDisputed = false;\n', '        }\n', '        if(msg.sender == provider) {\n', '            providerDisputed = false;\n', '        }\n', '        favorUndisputed(msg.sender);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows to set the address of the provider for the Favor\n', '    // this can be done by the requester or the C4F system\n', '    // once the provider accepts, the providerLock flag disables changes to this\n', '    // ----------------------------------------------------------------------------\n', '    function setProvider(address newProvider) public onlyOwnerOrRequester returns (bool success) {\n', '        // can only change provider if not locked by current provider\n', '        require(!providerLocked);\n', '        require(!requesterLocked);\n', '        provider = newProvider;\n', '        providerSet(provider);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // switches the ProviderLock on or off. Once provider lock is switched on, \n', '    // it means the provider has formally accepted the offer and changes are \n', '    // blocked\n', '    // ----------------------------------------------------------------------------\n', '    function setProviderLock(bool lock) public onlyOwnerOrProvider returns (bool res) {\n', '        providerLocked = lock;\n', '        providerLockSet(lock);\n', '        return providerLocked;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // allows to set Favor to completed from Provider view, indicating that \n', '    // provider sess Favor as delivered\n', '    // ----------------------------------------------------------------------------\n', '    function setProviderCompleted(bool c) public onlyOwnerOrProvider returns (bool res) {\n', '        providerCompleted = c;\n', '        providerCompletedSet(c);\n', '        return c;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows to set requester lock, indicating requester accepted favor provider\n', '    // ----------------------------------------------------------------------------\n', '    function setRequesterLock(bool lock) public onlyOwnerOrRequester returns (bool res) {\n', '        requesterLocked = lock;\n', '        requesterLockSet(lock);\n', '        return requesterLocked;\n', '    }\n', '    \n', '\n', '    function getRequesterLock() public onlyOwnerOrRequester view returns (bool res) {\n', '        res = requesterLocked;\n', '        return res;\n', '    }\n', '\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // allows the C4F system to change the status of an Escrow contract\n', '    // ----------------------------------------------------------------------------\n', '    function setStatus(uint8 newStatus) public onlyOwner returns (uint8 stat) {\n', '        status = newStatus;    \n', '        stat = status;\n', '        return stat;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the current Token value of the escrow for competing the favor\n', '    // this is the token balance of the escrow contract in the main contract\n', '    // ----------------------------------------------------------------------------\n', '    function getTokenValue() public view returns (uint256 tokens) {\n', '        C4FToken C4F = C4FToken(owner);\n', '        return C4F.balanceOf(address(this));\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // completes the favor Escrow and pays out the tokens minus the commission fee\n', '    // ----------------------------------------------------------------------------\n', '    function completeFavor() public onlyRequester returns (bool success) {\n', '        // check if provider has been set\n', '        require(provider != address(0));\n', '        \n', '        // payout tokens to provider with commission\n', '        uint256 actTokenvalue = getTokenValue();\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transferWithCommission(provider, actTokenvalue)) revert();\n', '        closeTime = now;\n', '        status = 3;\n', '        favorCompleted(provider,actTokenvalue);\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // this function cancels a favor request on behalf of the requester\n', '    // only possible as long as no provider accepted the contract or 12 hours\n', '    // after the deadline if the provider did not indicate completion or disputed\n', '    // ----------------------------------------------------------------------------\n', '    function cancelFavor() public onlyRequester returns (bool success) {\n', '        // cannot cancel if locked by provider unless deadline expired by 12 hours and not completed/disputed\n', '        require((!providerLocked) || ((now > deadline.add(12*3600)) && (!providerCompleted) && (!providerDisputed)));\n', '        // cannot cancel after completed or arbitrated\n', '        require(status==1);\n', '        // send tokens back to requester\n', '        uint256 actTokenvalue = getTokenValue();\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transfer(requester,actTokenvalue)) revert();\n', '        closeTime = now;\n', '        status = 2;\n', '        favorCancelled(actTokenvalue);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows the favor originator to reduce the token offer\n', '    // This can only be done until a provider has accepted (locked) the favor request\n', '    // ----------------------------------------------------------------------------\n', '    function changeTokenOffer(uint256 newOffer) public onlyRequester returns (bool success) {\n', '        // cannot change if locked by provider\n', '        require((!providerLocked) && (!providerDisputed) && (!providerCompleted));\n', '        // cannot change if cancelled, closed or arbitrated\n', '        require(status==1);\n', '        // only use for reducing tokens (to increase simply transfer tokens to contract)\n', '        uint256 actTokenvalue = getTokenValue();\n', '        require(newOffer < actTokenvalue);\n', '        // cannot set to 0, use cancel to do that\n', '        require(newOffer > 0);\n', '        // pay back tokens to reach new offer level\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transfer(requester, actTokenvalue.sub(newOffer))) revert();\n', '        tokenOfferChanged(actTokenvalue,newOffer);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // arbitration can be done by the C4F system once requester or provider have\n', '    // disputed the favor contract. An independent juror system on the platform \n', '    // will vote on the outcome and define a split of the tokens between the two\n', '    // parties. The jurors get a percentage which is preset in the contratct for\n', '    // the arbitration\n', '    // ----------------------------------------------------------------------------\n', '    function arbitrateC4FContract(uint8 percentReturned) public onlyOwner returns (bool success) {\n', '        // can only arbitrate if one of the two parties has disputed \n', '        require((providerDisputed) || (requesterDisputed));\n', '        // C4F System owner can arbitrate and provide a split of tokens between 0-100%\n', '        uint256 actTokens = getTokenValue();\n', '        \n', '        // calc. arbitration fee based on percent costs\n', '        uint256 arbitrationTokens = actTokens.mul(arbitrationCosts);\n', '        arbitrationTokens = arbitrationTokens.div(100);\n', '        // subtract these from the tokens to be distributed between requester and provider\n', '        actTokens = actTokens.sub(arbitrationTokens);\n', '        \n', '        // now split the tokens up using provided percentage\n', '        uint256 requesterTokens = actTokens.mul(percentReturned);\n', '        requesterTokens = requesterTokens.div(100);\n', '        // actTokens to hold what gets forwarded to provider\n', '        actTokens = actTokens.sub(requesterTokens);\n', '        \n', '        // distribute the Tokens\n', '        C4FToken C4F = C4FToken(owner);\n', '        // arbitration tokens go to commissiontarget of master contract\n', '        address commissionTarget = C4F.getCommissionTarget();\n', '        // requester gets refunded his split\n', '        if(!C4F.transfer(requester, requesterTokens)) revert();\n', '        // provider gets his split of tokens\n', '        if(!C4F.transfer(provider, actTokens)) revert();\n', '        // arbitration fee to system for distribution\n', '        if(!C4F.transfer(commissionTarget, arbitrationTokens)) revert();\n', '        \n', '        // set status & closeTime\n', '        status = 4;\n', '        closeTime = now;\n', '        success = true;\n', '        escrowArbitrated(provider,requesterTokens,arbitrationTokens);\n', '        return success;\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// &#39;C4F&#39; &#39;Coins4Favors FavorCoin contract\n', '//\n', '// Symbol      : C4F\n', '// Name        : FavorCoin\n', '// Total supply: 100,000,000,000.000000000000000000\n', '// Decimals    : 18\n', '//\n', '// includes the crowdsale price, PreICO bonus structure, limits on sellable tokens\n', '// function to pause sale, commission fee transfer and favorcontract management\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract C4FToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint8 public _crowdsalePaused;\n', '    uint public _totalSupply;\n', '    uint public _salesprice;\n', '    uint public _endOfICO;\n', '    uint public _endOfPreICO;\n', '    uint public _beginOfICO;\n', '    uint public _bonusTime1;\n', '    uint public _bonusTime2;\n', '    uint public _bonusRatio1;\n', '    uint public _bonusRatio2;\n', '    uint public _percentSoldInPreICO;\n', '    uint public _maxTokenSoldPreICO;\n', '    uint public _percentSoldInICO;\n', '    uint public _maxTokenSoldICO;\n', '    uint public _total_sold;\n', '    uint public _commission;\n', '    uint8 public _arbitrationPercent;\n', '    address public _commissionTarget;\n', '    uint public _minimumContribution;\n', '    address[]   EscrowAddresses;\n', '    uint public _escrowIndex;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping(address => uint) whitelisted_amount;\n', '    mapping(address => bool) C4FEscrowContracts;\n', '    \n', '    \n', '    event newEscrowCreated(uint ID, address contractAddress, address requester);   \n', '    event ICOStartSet(uint256 starttime);\n', '    event ICOEndSet(uint256 endtime);\n', '    event PreICOEndSet(uint256 endtime);\n', '    event BonusTime1Set(uint256 bonustime);\n', '    event BonusTime2Set(uint256 bonustime);\n', '    event accountWhitelisted(address account, uint256 limit);\n', '    event crowdsalePaused(bool paused);\n', '    event crowdsaleResumed(bool resumed);\n', '    event commissionSet(uint256 commission);\n', '    event commissionTargetSet(address target);\n', '    event arbitrationPctSet(uint8 arbpercent);\n', '    event contractOwnerChanged(address escrowcontract, address newOwner);\n', '    event contractProviderChanged(address C4Fcontract, address provider);\n', '    event contractArbitrated(address C4Fcontract, uint8 percentSplit);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function C4FToken() public {\n', '        symbol          = "C4F";\n', '        name            = "C4F FavorCoins";\n', '        decimals        = 18;\n', '        \n', '        _totalSupply    = 100000000000 * 10**uint(decimals);\n', '\n', '        _salesprice     = 2000000;      // C4Fs per 1 Eth\n', '        _minimumContribution = 0.05 * 10**18;    // minimum amount is 0.05 Ether\n', '        \n', '        _endOfICO       = 1532908800;   // end of ICO is 30.07.18\n', '        _beginOfICO     = 1526342400;   // begin is 15.05.18\n', '        _bonusRatio1    = 110;          // 10% Bonus in second week of PreICO\n', '        _bonusRatio2    = 125;          // 25% Bonus in first week of PreICO\n', '        _bonusTime1     = 1527638400;   // prior to 30.05.18 add bonusRatio1\n', '        _bonusTime2     = 1526947200;   // prior to 22.05.18 add bonusRatio2\n', '        _endOfPreICO    = 1527811200;   // Pre ICO ends 01.06.2018\n', '        \n', '        _percentSoldInPreICO = 10;      // we only offer 10% of total Supply during PreICO\n', '        _maxTokenSoldPreICO = _totalSupply.mul(_percentSoldInPreICO);\n', '        _maxTokenSoldPreICO = _maxTokenSoldPreICO.div(100);\n', '        \n', '        _percentSoldInICO   = 60;      // in addition to 10% sold in PreICO, 60% sold in ICO \n', '        _maxTokenSoldICO    = _totalSupply.mul(_percentSoldInPreICO.add(_percentSoldInICO));\n', '        _maxTokenSoldICO    = _maxTokenSoldICO.div(100);\n', '        \n', '        _total_sold         = 0;            // total coins sold \n', '        \n', '        _commission         = 0;            // no comission on transfers \n', '        _commissionTarget   = owner;        // default any commission goes to the owner of the contract\n', '        _arbitrationPercent = 10;           // default costs for arbitration of an escrow contract\n', '                                            // is transferred to escrow contract at time of creation and kept there\n', '        \n', '        _crowdsalePaused    = 0;\n', '\n', '        balances[owner]     = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // notLocked: ensure no coins are moved by owners prior to end of ICO\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier notLocked {\n', '        require((msg.sender == owner) || (now >= _endOfICO));\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // onlyDuringICO: FavorCoins can only be bought via contract during ICO\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier onlyDuringICO {\n', '        require((now >= _beginOfICO) && (now <= _endOfICO));\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // notPaused: ability to stop crowdsale if problems occur\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier notPaused {\n', '        require(_crowdsalePaused == 0);\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // set ICO and PRE ICO Dates\n', '    // ------------------------------------------------------------------------\n', '\n', '    function setICOStart(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _beginOfICO  = ICOdate;\n', '        ICOStartSet(_beginOfICO);\n', '        return true;\n', '    }\n', '    \n', '    function setICOEnd(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _endOfICO  = ICOdate;\n', '        ICOEndSet(_endOfICO);\n', '        return true;\n', '    }\n', '    \n', '    function setPreICOEnd(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _endOfPreICO = ICOdate;\n', '        PreICOEndSet(_endOfPreICO);\n', '        return true;\n', '    }\n', '    \n', '    function setBonusDate1(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _bonusTime1 = ICOdate;\n', '        BonusTime1Set(_bonusTime1);\n', '        return true;\n', '    }\n', '\n', '    function setBonusDate2(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _bonusTime2 = ICOdate;\n', '        BonusTime2Set(_bonusTime2);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Whitelist address up to maximum spending (AML and KYC)\n', '    // ------------------------------------------------------------------------\n', '    function whitelistAccount(address account, uint limit) public onlyOwner {\n', '        whitelisted_amount[account] = limit*10**18;\n', '        accountWhitelisted(account,limit);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // return maximum remaining whitelisted amount for account \n', '    // ------------------------------------------------------------------------\n', '    function getWhitelistLimit(address account) public constant returns (uint limit) {\n', '        return whitelisted_amount[account];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Pause crowdsale in case of any problems\n', '    // ------------------------------------------------------------------------\n', '    function pauseCrowdsale() public onlyOwner returns (bool success) {\n', '        _crowdsalePaused = 1;\n', '        crowdsalePaused(true);\n', '        return true;\n', '    }\n', '\n', '    function resumeCrowdsale() public onlyOwner returns (bool success) {\n', '        _crowdsalePaused = 0;\n', '        crowdsaleResumed(true);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Commission can be added later to a percentage of the transferred\n', '    // C4F tokens for operating costs of the system. Percentage is capped at 2%\n', '    // ------------------------------------------------------------------------\n', '    function setCommission(uint comm) public onlyOwner returns (bool success) {\n', '        require(comm < 200); // we allow a maximum of 2% commission\n', '        _commission = comm;\n', '        commissionSet(comm);\n', '        return true;\n', '    }\n', '\n', '    function setArbitrationPercentage(uint8 arbitPct) public onlyOwner returns (bool success) {\n', '        require(arbitPct <= 15); // we allow a maximum of 15% arbitration costs\n', '        _arbitrationPercent = arbitPct;\n', '        arbitrationPctSet(_arbitrationPercent);\n', '        return true;\n', '    }\n', '\n', '    function setCommissionTarget(address ct) public onlyOwner returns (bool success) {\n', '        _commissionTarget = ct;\n', '        commissionTargetSet(_commissionTarget);\n', '        return true;\n', '    }\n', '    \n', '    function getCommissionTarget() public view returns (address ct) {\n', '        ct = _commissionTarget;\n', '        return ct;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from token owner&#39;s account to `to` account\n', '    // - Owner&#39;s account must have sufficient balance to transfer\n', '    // - 0 value transfers are allowed\n', '    // - users cannot transfer C4Fs prior to close of ICO\n', '    // - only owner can transfer anytime to do airdrops, etc.\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // this function will be used by the C4F app to charge a Commission\n', '    // on transfers later\n', '    // ------------------------------------------------------------------------\n', '    function transferWithCommission(address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        // split tokens using commission Percentage\n', '        uint comTokens = tokens.mul(_commission);\n', '        comTokens = comTokens.div(10000);\n', '        // adjust balances\n', '        balances[to] = balances[to].add(tokens.sub(comTokens));\n', '        balances[_commissionTarget] = balances[_commissionTarget].add(comTokens);\n', '        // trigger events\n', '        Transfer(msg.sender, to, tokens.sub(comTokens));\n', '        Transfer(msg.sender, _commissionTarget, comTokens);\n', '        return true;\n', '    }\n', '\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // TransferInternal handles Transfer of Tokens from Owner during ICO and Pre-ICO\n', '    // ------------------------------------------------------------------------\n', '    function transferInternal(address to, uint tokens) private returns (bool success) {\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', '    // from the token owner&#39;s account\n', '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public notLocked notPaused returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // not possivbe before end of ICO\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        // check allowance is high enough\n', '        require(allowed[from][msg.sender] >= tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[from] = balances[from].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // startEscrow FavorContract\n', '    // starts an escrow contract and transfers the tokens into the contract\n', '    // ------------------------------------------------------------------------\n', '    \n', '    function startFavorEscrow(uint256 ID, uint256 deadl, uint tokens) public notLocked returns (address C4FFavorContractAddr) {\n', '        // check if sufficient coins available\n', '        require(balanceOf(msg.sender) >= tokens);\n', '        // create contract\n', '        address newFavor = new C4FEscrow(address(this), ID, msg.sender, deadl, _arbitrationPercent);\n', '        // add to list of C4FEscrowContratcs\n', '        EscrowAddresses.push(newFavor);\n', '        C4FEscrowContracts[newFavor] = true;\n', '        // transfer tokens to contract\n', '        if(!transfer(newFavor, tokens)) revert();\n', '        C4FFavorContractAddr = newFavor;\n', '        newEscrowCreated(ID, newFavor, msg.sender);\n', '        return C4FFavorContractAddr;\n', '    }\n', '\n', '    function isFavorEscrow(uint id, address c4fes) public view returns (bool res) {\n', '        if(EscrowAddresses[id] == c4fes) {\n', '                res = true;\n', '            } else {\n', '                res = false;\n', '            }\n', '        return res;\n', '    }\n', '    \n', '    function getEscrowCount() public view returns (uint) {\n', '        return EscrowAddresses.length;\n', '    }\n', '    \n', '    function getEscrowAddress(uint ind) public view returns(address esa) {\n', '        require (ind <= EscrowAddresses.length);\n', '        esa = EscrowAddresses[ind];\n', '        return esa;\n', '    }\n', '    \n', '    \n', '    // use this function to allow C4F System to adjust owner of C4FEscrows \n', '    function setC4FContractOwner(address C4Fcontract, address newOwner) public onlyOwner returns (bool success) {\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProvider from there\n', '        if(!c4fec.setOwner(newOwner)) revert();\n', '        contractOwnerChanged(C4Fcontract,newOwner);\n', '        return true;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust provider of C4F Favorcontract    \n', '    function setC4FContractProvider(address C4Fcontract, address provider) public onlyOwner returns (bool success) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProvider from there\n', '        if(!c4fec.setProvider(provider)) revert();\n', '        contractProviderChanged(C4Fcontract, provider);\n', '        return true;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust providerLock \n', '    function setC4FContractProviderLock(address C4Fcontract, bool lock) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProviderLock from there\n', '        res = c4fec.setProviderLock(lock);\n', '        return res;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust providerCompleted status\n', '    function setC4FContractProviderCompleted(address C4Fcontract, bool completed) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProviderCompleted from there\n', '        res = c4fec.setProviderCompleted(completed);\n', '        return res;\n', '    }\n', '    \n', '        // use this function to allow C4F System to adjust providerLock \n', '    function setC4FContractRequesterLock(address C4Fcontract, bool lock) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setRequesterLock from there\n', '        res = c4fec.setRequesterLock(lock);\n', '        return res;\n', '    }\n', '\n', '    function setC4FContractStatus(address C4Fcontract, uint8 newStatus) public onlyOwner returns (uint8 s) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setStatus from there\n', '        s = c4fec.setStatus(newStatus);\n', '        return s;\n', '    }\n', '    \n', '    function arbitrateC4FContract(address C4Fcontract, uint8 percentSplit) public onlyOwner returns (bool success) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call arbitration\n', '        if(!c4fec.arbitrateC4FContract(percentSplit)) revert();\n', '        contractArbitrated(C4Fcontract, percentSplit);\n', '        return true;\n', '    }\n', '\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Convert to C4Fs using salesprice and bonus period and forward Eth to owner\n', '    // ------------------------------------------------------------------------\n', '    function () public onlyDuringICO notPaused payable  {\n', '        // check bonus ratio\n', '        uint bonusratio = 100;\n', '        // check for second week bonus\n', '        if(now <= _bonusTime1) {\n', '            bonusratio = _bonusRatio1;    \n', '        }\n', '        // check for first week bonus\n', '        if(now <= _bonusTime2) {\n', '            bonusratio = _bonusRatio2;    \n', '        }\n', '        \n', '        // minimum contribution met ?\n', '        require (msg.value >= _minimumContribution);\n', '        \n', '        // send C4F tokens back to sender based on Ether received\n', '        if (msg.value > 0) {\n', '            \n', '            // check if whitelisted and sufficient contribution left (AML & KYC)\n', '            if(!(whitelisted_amount[msg.sender] >= msg.value)) revert();\n', '            // reduce remaining contribution limit\n', '            whitelisted_amount[msg.sender] = whitelisted_amount[msg.sender].sub(msg.value);\n', '            \n', '            // determine amount of C4Fs \n', '            uint256 token_amount = msg.value.mul(_salesprice);\n', '            token_amount = token_amount.mul(bonusratio);\n', '            token_amount = token_amount.div(100);\n', '            \n', '            uint256 new_total = _total_sold.add(token_amount);\n', '            // check if PreICO volume sold off \n', '            if(now <= _endOfPreICO){\n', '                // check if we are above the limit with this transfer, then bounce\n', '                if(new_total > _maxTokenSoldPreICO) revert();\n', '            }\n', '            \n', '            // check if exceeding total ICO sale tokens\n', '            if(new_total > _maxTokenSoldICO) revert();\n', '            \n', '            // transfer tokens from owner account to sender\n', '            if(!transferInternal(msg.sender, token_amount)) revert();\n', '            _total_sold = new_total;\n', '            // forward received ether to owner account\n', '            if (!owner.send(msg.value)) revert(); // also reverts the transfer.\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'C4F' Coins4Favors contracts\n", '//\n', '// contracts for C4FEscrow and C4FToken Crowdsale\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'C4F' FavorEscrow contract\n", '//\n', '// Escrow contract for favor request\n', '// allows to reserve tokens till a favor is completed, cancelled or arbitrated\n', '// handles requester and provider interaction, payout, cancellation and\n', '// arbitration if needed.\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract C4FEscrow {\n', '\n', '    using SafeMath for uint;\n', '    \n', '    address public owner;\n', '    address public requester;\n', '    address public provider;\n', '\n', '    uint256 public startTime;\n', '    uint256 public closeTime;\n', '    uint256 public deadline;\n', '    \n', '    uint256 public C4FID;\n', '    uint8   public status;\n', '    bool    public requesterLocked;\n', '    bool    public providerLocked;\n', '    bool    public providerCompleted;\n', '    bool    public requesterDisputed;\n', '    bool    public providerDisputed;\n', '    uint8   public arbitrationCosts;\n', '\n', '    event ownerChanged(address oldOwner, address newOwner);   \n', '    event deadlineChanged(uint256 oldDeadline, uint256 newDeadline);\n', '    event favorDisputed(address disputer);\n', '    event favorUndisputed(address undisputer);\n', '    event providerSet(address provider);\n', '    event providerLockSet(bool lockstat);\n', '    event providerCompletedSet(bool completed_status);\n', '    event requesterLockSet(bool lockstat);\n', '    event favorCompleted(address provider, uint256 tokenspaid);\n', '    event favorCancelled(uint256 tokensreturned);\n', '    event tokenOfferChanged(uint256 oldValue, uint256 newValue);\n', '    event escrowArbitrated(address provider, uint256 coinsreturned, uint256 fee);\n', '\n', '// ----------------------------------------------------------------------------\n', '// modifiers used in this contract to restrict function calls\n', '// ----------------------------------------------------------------------------\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }   \n', '\n', '    modifier onlyRequester {\n', '        require(msg.sender == requester);\n', '        _;\n', '    }   \n', '    \n', '    modifier onlyProvider {\n', '        require(msg.sender == provider);\n', '        _;\n', '    }   \n', '\n', '    modifier onlyOwnerOrRequester {\n', '        require((msg.sender == owner) || (msg.sender == requester)) ;\n', '        _;\n', '    }   \n', '    \n', '    modifier onlyOwnerOrProvider {\n', '        require((msg.sender == owner) || (msg.sender == provider)) ;\n', '        _;        \n', '    }\n', '    \n', '    modifier onlyProviderOrRequester {\n', '        require((msg.sender == requester) || (msg.sender == provider)) ;\n', '        _;        \n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Constructor\n', '    // ----------------------------------------------------------------------------\n', '    function C4FEscrow(address newOwner, uint256 ID, address req, uint256 deadl, uint8 arbCostPercent) public {\n', '        owner       = newOwner; // main contract\n', '        C4FID       = ID;\n', '        requester   = req;\n', '        provider    = address(0);\n', '        startTime   = now;\n', '        deadline    = deadl;\n', '        status      = 1;        // 1 = open, 2 = cancelled, 3=closed, 4=arbitrated\n', '        arbitrationCosts    = arbCostPercent;\n', '        requesterLocked     = false;\n', '        providerLocked      = false;\n', '        providerCompleted   = false;\n', '        requesterDisputed   = false;\n', '        providerDisputed    = false;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // returns the owner of the Escrow contract. This is the main C4F Token contract\n', '    // ----------------------------------------------------------------------------\n', '    function getOwner() public view returns (address ownner) {\n', '        return owner;\n', '    } \n', '    \n', '    function setOwner(address newOwner) public onlyOwner returns (bool success) {\n', '        require(newOwner != address(0));\n', '        ownerChanged(owner,newOwner);\n', '        owner = newOwner;\n', '        return true;\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Requester of the Escrow contract. This is the originator of the favor request\n', '    // ----------------------------------------------------------------------------\n', '    function getRequester() public view returns (address req) {\n', '        return requester;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Provider of the Escrow contract. This is the favor provider\n', '    // ----------------------------------------------------------------------------\n', '    function getProvider() public view returns (address prov) {\n', '        return provider;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the startTime of the Escrow contract which is the time it was created\n', '    // ----------------------------------------------------------------------------\n', '    function getStartTime() public view returns (uint256 st) {\n', '        return startTime;\n', '    }    \n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the Deadline of the Escrow contract by which completion is needed\n', '    // Reqeuster can cancel the Escrow 12 hours after deadline expires if favor\n', '    // is not marked as completed by provider\n', '    // ----------------------------------------------------------------------------\n', '    function getDeadline() public view returns (uint256 actDeadline) {\n', '        actDeadline = deadline;\n', '        return actDeadline;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // adjusts the Deadline of the Escrow contract by which completion is needed\n', '    // Reqeuster can only change this till a provider accepted (locked) the contract\n', '    // ----------------------------------------------------------------------------\n', '    function changeDeadline(uint newDeadline) public onlyRequester returns (bool success) {\n', '        // deadline can only be changed if not locked by provider and not completed\n', '        require ((!providerLocked) && (!providerDisputed) && (!providerCompleted) && (status==1));\n', '        deadlineChanged(newDeadline, deadline);\n', '        deadline = newDeadline;\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the status of the Escrow contract\n', '    // ----------------------------------------------------------------------------\n', '    function getStatus() public view returns (uint8 s) {\n', '        return status;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Initiates dispute of the Escrow contract. Once requester or provider disputeFavor\n', '    // because they cannot agree on completion, the C4F system can arbitrate the Escrow\n', '    // based on the internal juror system.\n', '    // ----------------------------------------------------------------------------\n', '    function disputeFavor() public onlyProviderOrRequester returns (bool success) {\n', '        if(msg.sender == requester) {\n', '            requesterDisputed = true;\n', '        }\n', '        if(msg.sender == provider) {\n', '            providerDisputed = true;\n', '            providerLocked = true;\n', '        }\n', '        favorDisputed(msg.sender);\n', '        return true;\n', '    }\n', '    // ----------------------------------------------------------------------------\n', '    // Allows to take back a dispute on the Escrow if conflict has been resolved\n', '    // ----------------------------------------------------------------------------\n', '    function undisputeFavor() public onlyProviderOrRequester returns (bool success) {\n', '        if(msg.sender == requester) {\n', '            requesterDisputed = false;\n', '        }\n', '        if(msg.sender == provider) {\n', '            providerDisputed = false;\n', '        }\n', '        favorUndisputed(msg.sender);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows to set the address of the provider for the Favor\n', '    // this can be done by the requester or the C4F system\n', '    // once the provider accepts, the providerLock flag disables changes to this\n', '    // ----------------------------------------------------------------------------\n', '    function setProvider(address newProvider) public onlyOwnerOrRequester returns (bool success) {\n', '        // can only change provider if not locked by current provider\n', '        require(!providerLocked);\n', '        require(!requesterLocked);\n', '        provider = newProvider;\n', '        providerSet(provider);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // switches the ProviderLock on or off. Once provider lock is switched on, \n', '    // it means the provider has formally accepted the offer and changes are \n', '    // blocked\n', '    // ----------------------------------------------------------------------------\n', '    function setProviderLock(bool lock) public onlyOwnerOrProvider returns (bool res) {\n', '        providerLocked = lock;\n', '        providerLockSet(lock);\n', '        return providerLocked;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // allows to set Favor to completed from Provider view, indicating that \n', '    // provider sess Favor as delivered\n', '    // ----------------------------------------------------------------------------\n', '    function setProviderCompleted(bool c) public onlyOwnerOrProvider returns (bool res) {\n', '        providerCompleted = c;\n', '        providerCompletedSet(c);\n', '        return c;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows to set requester lock, indicating requester accepted favor provider\n', '    // ----------------------------------------------------------------------------\n', '    function setRequesterLock(bool lock) public onlyOwnerOrRequester returns (bool res) {\n', '        requesterLocked = lock;\n', '        requesterLockSet(lock);\n', '        return requesterLocked;\n', '    }\n', '    \n', '\n', '    function getRequesterLock() public onlyOwnerOrRequester view returns (bool res) {\n', '        res = requesterLocked;\n', '        return res;\n', '    }\n', '\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // allows the C4F system to change the status of an Escrow contract\n', '    // ----------------------------------------------------------------------------\n', '    function setStatus(uint8 newStatus) public onlyOwner returns (uint8 stat) {\n', '        status = newStatus;    \n', '        stat = status;\n', '        return stat;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // returns the current Token value of the escrow for competing the favor\n', '    // this is the token balance of the escrow contract in the main contract\n', '    // ----------------------------------------------------------------------------\n', '    function getTokenValue() public view returns (uint256 tokens) {\n', '        C4FToken C4F = C4FToken(owner);\n', '        return C4F.balanceOf(address(this));\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // completes the favor Escrow and pays out the tokens minus the commission fee\n', '    // ----------------------------------------------------------------------------\n', '    function completeFavor() public onlyRequester returns (bool success) {\n', '        // check if provider has been set\n', '        require(provider != address(0));\n', '        \n', '        // payout tokens to provider with commission\n', '        uint256 actTokenvalue = getTokenValue();\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transferWithCommission(provider, actTokenvalue)) revert();\n', '        closeTime = now;\n', '        status = 3;\n', '        favorCompleted(provider,actTokenvalue);\n', '        return true;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // this function cancels a favor request on behalf of the requester\n', '    // only possible as long as no provider accepted the contract or 12 hours\n', '    // after the deadline if the provider did not indicate completion or disputed\n', '    // ----------------------------------------------------------------------------\n', '    function cancelFavor() public onlyRequester returns (bool success) {\n', '        // cannot cancel if locked by provider unless deadline expired by 12 hours and not completed/disputed\n', '        require((!providerLocked) || ((now > deadline.add(12*3600)) && (!providerCompleted) && (!providerDisputed)));\n', '        // cannot cancel after completed or arbitrated\n', '        require(status==1);\n', '        // send tokens back to requester\n', '        uint256 actTokenvalue = getTokenValue();\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transfer(requester,actTokenvalue)) revert();\n', '        closeTime = now;\n', '        status = 2;\n', '        favorCancelled(actTokenvalue);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // allows the favor originator to reduce the token offer\n', '    // This can only be done until a provider has accepted (locked) the favor request\n', '    // ----------------------------------------------------------------------------\n', '    function changeTokenOffer(uint256 newOffer) public onlyRequester returns (bool success) {\n', '        // cannot change if locked by provider\n', '        require((!providerLocked) && (!providerDisputed) && (!providerCompleted));\n', '        // cannot change if cancelled, closed or arbitrated\n', '        require(status==1);\n', '        // only use for reducing tokens (to increase simply transfer tokens to contract)\n', '        uint256 actTokenvalue = getTokenValue();\n', '        require(newOffer < actTokenvalue);\n', '        // cannot set to 0, use cancel to do that\n', '        require(newOffer > 0);\n', '        // pay back tokens to reach new offer level\n', '        C4FToken C4F = C4FToken(owner);\n', '        if(!C4F.transfer(requester, actTokenvalue.sub(newOffer))) revert();\n', '        tokenOfferChanged(actTokenvalue,newOffer);\n', '        return true;\n', '    }\n', '    \n', '    // ----------------------------------------------------------------------------\n', '    // arbitration can be done by the C4F system once requester or provider have\n', '    // disputed the favor contract. An independent juror system on the platform \n', '    // will vote on the outcome and define a split of the tokens between the two\n', '    // parties. The jurors get a percentage which is preset in the contratct for\n', '    // the arbitration\n', '    // ----------------------------------------------------------------------------\n', '    function arbitrateC4FContract(uint8 percentReturned) public onlyOwner returns (bool success) {\n', '        // can only arbitrate if one of the two parties has disputed \n', '        require((providerDisputed) || (requesterDisputed));\n', '        // C4F System owner can arbitrate and provide a split of tokens between 0-100%\n', '        uint256 actTokens = getTokenValue();\n', '        \n', '        // calc. arbitration fee based on percent costs\n', '        uint256 arbitrationTokens = actTokens.mul(arbitrationCosts);\n', '        arbitrationTokens = arbitrationTokens.div(100);\n', '        // subtract these from the tokens to be distributed between requester and provider\n', '        actTokens = actTokens.sub(arbitrationTokens);\n', '        \n', '        // now split the tokens up using provided percentage\n', '        uint256 requesterTokens = actTokens.mul(percentReturned);\n', '        requesterTokens = requesterTokens.div(100);\n', '        // actTokens to hold what gets forwarded to provider\n', '        actTokens = actTokens.sub(requesterTokens);\n', '        \n', '        // distribute the Tokens\n', '        C4FToken C4F = C4FToken(owner);\n', '        // arbitration tokens go to commissiontarget of master contract\n', '        address commissionTarget = C4F.getCommissionTarget();\n', '        // requester gets refunded his split\n', '        if(!C4F.transfer(requester, requesterTokens)) revert();\n', '        // provider gets his split of tokens\n', '        if(!C4F.transfer(provider, actTokens)) revert();\n', '        // arbitration fee to system for distribution\n', '        if(!C4F.transfer(commissionTarget, arbitrationTokens)) revert();\n', '        \n', '        // set status & closeTime\n', '        status = 4;\n', '        closeTime = now;\n', '        success = true;\n', '        escrowArbitrated(provider,requesterTokens,arbitrationTokens);\n', '        return success;\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'C4F' 'Coins4Favors FavorCoin contract\n", '//\n', '// Symbol      : C4F\n', '// Name        : FavorCoin\n', '// Total supply: 100,000,000,000.000000000000000000\n', '// Decimals    : 18\n', '//\n', '// includes the crowdsale price, PreICO bonus structure, limits on sellable tokens\n', '// function to pause sale, commission fee transfer and favorcontract management\n', '//\n', '// (c) C4F Ltd Hongkong 2018\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract C4FToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint8 public _crowdsalePaused;\n', '    uint public _totalSupply;\n', '    uint public _salesprice;\n', '    uint public _endOfICO;\n', '    uint public _endOfPreICO;\n', '    uint public _beginOfICO;\n', '    uint public _bonusTime1;\n', '    uint public _bonusTime2;\n', '    uint public _bonusRatio1;\n', '    uint public _bonusRatio2;\n', '    uint public _percentSoldInPreICO;\n', '    uint public _maxTokenSoldPreICO;\n', '    uint public _percentSoldInICO;\n', '    uint public _maxTokenSoldICO;\n', '    uint public _total_sold;\n', '    uint public _commission;\n', '    uint8 public _arbitrationPercent;\n', '    address public _commissionTarget;\n', '    uint public _minimumContribution;\n', '    address[]   EscrowAddresses;\n', '    uint public _escrowIndex;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    mapping(address => uint) whitelisted_amount;\n', '    mapping(address => bool) C4FEscrowContracts;\n', '    \n', '    \n', '    event newEscrowCreated(uint ID, address contractAddress, address requester);   \n', '    event ICOStartSet(uint256 starttime);\n', '    event ICOEndSet(uint256 endtime);\n', '    event PreICOEndSet(uint256 endtime);\n', '    event BonusTime1Set(uint256 bonustime);\n', '    event BonusTime2Set(uint256 bonustime);\n', '    event accountWhitelisted(address account, uint256 limit);\n', '    event crowdsalePaused(bool paused);\n', '    event crowdsaleResumed(bool resumed);\n', '    event commissionSet(uint256 commission);\n', '    event commissionTargetSet(address target);\n', '    event arbitrationPctSet(uint8 arbpercent);\n', '    event contractOwnerChanged(address escrowcontract, address newOwner);\n', '    event contractProviderChanged(address C4Fcontract, address provider);\n', '    event contractArbitrated(address C4Fcontract, uint8 percentSplit);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function C4FToken() public {\n', '        symbol          = "C4F";\n', '        name            = "C4F FavorCoins";\n', '        decimals        = 18;\n', '        \n', '        _totalSupply    = 100000000000 * 10**uint(decimals);\n', '\n', '        _salesprice     = 2000000;      // C4Fs per 1 Eth\n', '        _minimumContribution = 0.05 * 10**18;    // minimum amount is 0.05 Ether\n', '        \n', '        _endOfICO       = 1532908800;   // end of ICO is 30.07.18\n', '        _beginOfICO     = 1526342400;   // begin is 15.05.18\n', '        _bonusRatio1    = 110;          // 10% Bonus in second week of PreICO\n', '        _bonusRatio2    = 125;          // 25% Bonus in first week of PreICO\n', '        _bonusTime1     = 1527638400;   // prior to 30.05.18 add bonusRatio1\n', '        _bonusTime2     = 1526947200;   // prior to 22.05.18 add bonusRatio2\n', '        _endOfPreICO    = 1527811200;   // Pre ICO ends 01.06.2018\n', '        \n', '        _percentSoldInPreICO = 10;      // we only offer 10% of total Supply during PreICO\n', '        _maxTokenSoldPreICO = _totalSupply.mul(_percentSoldInPreICO);\n', '        _maxTokenSoldPreICO = _maxTokenSoldPreICO.div(100);\n', '        \n', '        _percentSoldInICO   = 60;      // in addition to 10% sold in PreICO, 60% sold in ICO \n', '        _maxTokenSoldICO    = _totalSupply.mul(_percentSoldInPreICO.add(_percentSoldInICO));\n', '        _maxTokenSoldICO    = _maxTokenSoldICO.div(100);\n', '        \n', '        _total_sold         = 0;            // total coins sold \n', '        \n', '        _commission         = 0;            // no comission on transfers \n', '        _commissionTarget   = owner;        // default any commission goes to the owner of the contract\n', '        _arbitrationPercent = 10;           // default costs for arbitration of an escrow contract\n', '                                            // is transferred to escrow contract at time of creation and kept there\n', '        \n', '        _crowdsalePaused    = 0;\n', '\n', '        balances[owner]     = _totalSupply;\n', '        Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // notLocked: ensure no coins are moved by owners prior to end of ICO\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier notLocked {\n', '        require((msg.sender == owner) || (now >= _endOfICO));\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // onlyDuringICO: FavorCoins can only be bought via contract during ICO\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier onlyDuringICO {\n', '        require((now >= _beginOfICO) && (now <= _endOfICO));\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // notPaused: ability to stop crowdsale if problems occur\n', '    // ------------------------------------------------------------------------\n', '    \n', '    modifier notPaused {\n', '        require(_crowdsalePaused == 0);\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // set ICO and PRE ICO Dates\n', '    // ------------------------------------------------------------------------\n', '\n', '    function setICOStart(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _beginOfICO  = ICOdate;\n', '        ICOStartSet(_beginOfICO);\n', '        return true;\n', '    }\n', '    \n', '    function setICOEnd(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _endOfICO  = ICOdate;\n', '        ICOEndSet(_endOfICO);\n', '        return true;\n', '    }\n', '    \n', '    function setPreICOEnd(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _endOfPreICO = ICOdate;\n', '        PreICOEndSet(_endOfPreICO);\n', '        return true;\n', '    }\n', '    \n', '    function setBonusDate1(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _bonusTime1 = ICOdate;\n', '        BonusTime1Set(_bonusTime1);\n', '        return true;\n', '    }\n', '\n', '    function setBonusDate2(uint ICOdate) public onlyOwner returns (bool success) {\n', '        _bonusTime2 = ICOdate;\n', '        BonusTime2Set(_bonusTime2);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public constant returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Whitelist address up to maximum spending (AML and KYC)\n', '    // ------------------------------------------------------------------------\n', '    function whitelistAccount(address account, uint limit) public onlyOwner {\n', '        whitelisted_amount[account] = limit*10**18;\n', '        accountWhitelisted(account,limit);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // return maximum remaining whitelisted amount for account \n', '    // ------------------------------------------------------------------------\n', '    function getWhitelistLimit(address account) public constant returns (uint limit) {\n', '        return whitelisted_amount[account];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Pause crowdsale in case of any problems\n', '    // ------------------------------------------------------------------------\n', '    function pauseCrowdsale() public onlyOwner returns (bool success) {\n', '        _crowdsalePaused = 1;\n', '        crowdsalePaused(true);\n', '        return true;\n', '    }\n', '\n', '    function resumeCrowdsale() public onlyOwner returns (bool success) {\n', '        _crowdsalePaused = 0;\n', '        crowdsaleResumed(true);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Commission can be added later to a percentage of the transferred\n', '    // C4F tokens for operating costs of the system. Percentage is capped at 2%\n', '    // ------------------------------------------------------------------------\n', '    function setCommission(uint comm) public onlyOwner returns (bool success) {\n', '        require(comm < 200); // we allow a maximum of 2% commission\n', '        _commission = comm;\n', '        commissionSet(comm);\n', '        return true;\n', '    }\n', '\n', '    function setArbitrationPercentage(uint8 arbitPct) public onlyOwner returns (bool success) {\n', '        require(arbitPct <= 15); // we allow a maximum of 15% arbitration costs\n', '        _arbitrationPercent = arbitPct;\n', '        arbitrationPctSet(_arbitrationPercent);\n', '        return true;\n', '    }\n', '\n', '    function setCommissionTarget(address ct) public onlyOwner returns (bool success) {\n', '        _commissionTarget = ct;\n', '        commissionTargetSet(_commissionTarget);\n', '        return true;\n', '    }\n', '    \n', '    function getCommissionTarget() public view returns (address ct) {\n', '        ct = _commissionTarget;\n', '        return ct;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // - users cannot transfer C4Fs prior to close of ICO\n', '    // - only owner can transfer anytime to do airdrops, etc.\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // this function will be used by the C4F app to charge a Commission\n', '    // on transfers later\n', '    // ------------------------------------------------------------------------\n', '    function transferWithCommission(address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        // split tokens using commission Percentage\n', '        uint comTokens = tokens.mul(_commission);\n', '        comTokens = comTokens.div(10000);\n', '        // adjust balances\n', '        balances[to] = balances[to].add(tokens.sub(comTokens));\n', '        balances[_commissionTarget] = balances[_commissionTarget].add(comTokens);\n', '        // trigger events\n', '        Transfer(msg.sender, to, tokens.sub(comTokens));\n', '        Transfer(msg.sender, _commissionTarget, comTokens);\n', '        return true;\n', '    }\n', '\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // TransferInternal handles Transfer of Tokens from Owner during ICO and Pre-ICO\n', '    // ------------------------------------------------------------------------\n', '    function transferInternal(address to, uint tokens) private returns (bool success) {\n', '        balances[owner] = balances[owner].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public notLocked notPaused returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // not possivbe before end of ICO\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public notLocked notPaused returns (bool success) {\n', '        // check allowance is high enough\n', '        require(allowed[from][msg.sender] >= tokens);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        balances[from] = balances[from].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // startEscrow FavorContract\n', '    // starts an escrow contract and transfers the tokens into the contract\n', '    // ------------------------------------------------------------------------\n', '    \n', '    function startFavorEscrow(uint256 ID, uint256 deadl, uint tokens) public notLocked returns (address C4FFavorContractAddr) {\n', '        // check if sufficient coins available\n', '        require(balanceOf(msg.sender) >= tokens);\n', '        // create contract\n', '        address newFavor = new C4FEscrow(address(this), ID, msg.sender, deadl, _arbitrationPercent);\n', '        // add to list of C4FEscrowContratcs\n', '        EscrowAddresses.push(newFavor);\n', '        C4FEscrowContracts[newFavor] = true;\n', '        // transfer tokens to contract\n', '        if(!transfer(newFavor, tokens)) revert();\n', '        C4FFavorContractAddr = newFavor;\n', '        newEscrowCreated(ID, newFavor, msg.sender);\n', '        return C4FFavorContractAddr;\n', '    }\n', '\n', '    function isFavorEscrow(uint id, address c4fes) public view returns (bool res) {\n', '        if(EscrowAddresses[id] == c4fes) {\n', '                res = true;\n', '            } else {\n', '                res = false;\n', '            }\n', '        return res;\n', '    }\n', '    \n', '    function getEscrowCount() public view returns (uint) {\n', '        return EscrowAddresses.length;\n', '    }\n', '    \n', '    function getEscrowAddress(uint ind) public view returns(address esa) {\n', '        require (ind <= EscrowAddresses.length);\n', '        esa = EscrowAddresses[ind];\n', '        return esa;\n', '    }\n', '    \n', '    \n', '    // use this function to allow C4F System to adjust owner of C4FEscrows \n', '    function setC4FContractOwner(address C4Fcontract, address newOwner) public onlyOwner returns (bool success) {\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProvider from there\n', '        if(!c4fec.setOwner(newOwner)) revert();\n', '        contractOwnerChanged(C4Fcontract,newOwner);\n', '        return true;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust provider of C4F Favorcontract    \n', '    function setC4FContractProvider(address C4Fcontract, address provider) public onlyOwner returns (bool success) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProvider from there\n', '        if(!c4fec.setProvider(provider)) revert();\n', '        contractProviderChanged(C4Fcontract, provider);\n', '        return true;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust providerLock \n', '    function setC4FContractProviderLock(address C4Fcontract, bool lock) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProviderLock from there\n', '        res = c4fec.setProviderLock(lock);\n', '        return res;\n', '    }\n', '    \n', '    // use this function to allow C4F System to adjust providerCompleted status\n', '    function setC4FContractProviderCompleted(address C4Fcontract, bool completed) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setProviderCompleted from there\n', '        res = c4fec.setProviderCompleted(completed);\n', '        return res;\n', '    }\n', '    \n', '        // use this function to allow C4F System to adjust providerLock \n', '    function setC4FContractRequesterLock(address C4Fcontract, bool lock) public onlyOwner returns (bool res) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setRequesterLock from there\n', '        res = c4fec.setRequesterLock(lock);\n', '        return res;\n', '    }\n', '\n', '    function setC4FContractStatus(address C4Fcontract, uint8 newStatus) public onlyOwner returns (uint8 s) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call setStatus from there\n', '        s = c4fec.setStatus(newStatus);\n', '        return s;\n', '    }\n', '    \n', '    function arbitrateC4FContract(address C4Fcontract, uint8 percentSplit) public onlyOwner returns (bool success) {\n', '        // ensure this is a C4FEscrowContract initiated by C4F system\n', '        require(C4FEscrowContracts[C4Fcontract]);\n', '        C4FEscrow c4fec = C4FEscrow(C4Fcontract);\n', '        // call arbitration\n', '        if(!c4fec.arbitrateC4FContract(percentSplit)) revert();\n', '        contractArbitrated(C4Fcontract, percentSplit);\n', '        return true;\n', '    }\n', '\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Convert to C4Fs using salesprice and bonus period and forward Eth to owner\n', '    // ------------------------------------------------------------------------\n', '    function () public onlyDuringICO notPaused payable  {\n', '        // check bonus ratio\n', '        uint bonusratio = 100;\n', '        // check for second week bonus\n', '        if(now <= _bonusTime1) {\n', '            bonusratio = _bonusRatio1;    \n', '        }\n', '        // check for first week bonus\n', '        if(now <= _bonusTime2) {\n', '            bonusratio = _bonusRatio2;    \n', '        }\n', '        \n', '        // minimum contribution met ?\n', '        require (msg.value >= _minimumContribution);\n', '        \n', '        // send C4F tokens back to sender based on Ether received\n', '        if (msg.value > 0) {\n', '            \n', '            // check if whitelisted and sufficient contribution left (AML & KYC)\n', '            if(!(whitelisted_amount[msg.sender] >= msg.value)) revert();\n', '            // reduce remaining contribution limit\n', '            whitelisted_amount[msg.sender] = whitelisted_amount[msg.sender].sub(msg.value);\n', '            \n', '            // determine amount of C4Fs \n', '            uint256 token_amount = msg.value.mul(_salesprice);\n', '            token_amount = token_amount.mul(bonusratio);\n', '            token_amount = token_amount.div(100);\n', '            \n', '            uint256 new_total = _total_sold.add(token_amount);\n', '            // check if PreICO volume sold off \n', '            if(now <= _endOfPreICO){\n', '                // check if we are above the limit with this transfer, then bounce\n', '                if(new_total > _maxTokenSoldPreICO) revert();\n', '            }\n', '            \n', '            // check if exceeding total ICO sale tokens\n', '            if(new_total > _maxTokenSoldICO) revert();\n', '            \n', '            // transfer tokens from owner account to sender\n', '            if(!transferInternal(msg.sender, token_amount)) revert();\n', '            _total_sold = new_total;\n', '            // forward received ether to owner account\n', '            if (!owner.send(msg.value)) revert(); // also reverts the transfer.\n', '        }\n', '    }\n', '}']
