['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address internal owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public returns (bool) {\n', '        require(newOwner != address(0x0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface MintableToken {\n', '    function mint(address _to, uint256 _amount) external returns (bool);\n', '    function transferOwnership(address newOwner) external returns (bool);\n', '}\n', '\n', 'interface BitNauticWhitelist {\n', '    function AMLWhitelisted(address) external returns (bool);\n', '}\n', '\n', 'interface BitNauticCrowdsale {\n', '    function creditOf(address) external returns (uint256);\n', '}\n', '\n', 'contract BitNauticCrowdsaleTokenDistributor is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant ICOStartTime = 1531267200; // 11 Jul 2018 00:00 GMT\n', '    uint256 public constant ICOEndTime = 1536969600; // 15 Sep 2018 00:00 GMT\n', '\n', '    uint256 public teamSupply =     3000000 * 10 ** 18; // 6% of token cap\n', '    uint256 public bountySupply =   2500000 * 10 ** 18; // 5% of token cap\n', '    uint256 public reserveSupply =  5000000 * 10 ** 18; // 10% of token cap\n', '    uint256 public advisorSupply =  2500000 * 10 ** 18; // 5% of token cap\n', '    uint256 public founderSupply =  2000000 * 10 ** 18; // 4% of token cap\n', '\n', '    MintableToken public token;\n', '    BitNauticWhitelist public whitelist;\n', '    BitNauticCrowdsale public crowdsale;\n', '\n', '    mapping (address => bool) public hasClaimedTokens;\n', '\n', '    constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public {\n', '        token = _token;\n', '        whitelist = _whitelist;\n', '        crowdsale = _crowdsale;\n', '    }\n', '\n', '    function privateSale(address beneficiary, uint256 tokenAmount) onlyOwner public {\n', '        require(beneficiary != 0x0);\n', '\n', '        assert(token.mint(beneficiary, tokenAmount));\n', '    }\n', '\n', '    // this function can be called by the contributor to claim his BTNT tokens at the end of the ICO\n', '    function claimBitNauticTokens() public returns (bool) {\n', '        return grantContributorTokens(msg.sender);\n', '    }\n', '\n', '    // if the ICO is finished and the goal has been reached, this function will be used to mint and transfer BTNT tokens to each contributor\n', '    function grantContributorTokens(address contributor) public returns (bool) {\n', '        require(!hasClaimedTokens[contributor]);\n', '        require(crowdsale.creditOf(contributor) > 0);\n', '        require(whitelist.AMLWhitelisted(contributor));\n', '        require(now > ICOEndTime);\n', '\n', '        assert(token.mint(contributor, crowdsale.creditOf(contributor)));\n', '        hasClaimedTokens[contributor] = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferTokenOwnership(address newTokenOwner) onlyOwner public returns (bool) {\n', '        return token.transferOwnership(newTokenOwner);\n', '    }\n', '\n', '    function grantBountyTokens(address beneficiary) onlyOwner public {\n', '        require(bountySupply > 0);\n', '\n', '        token.mint(beneficiary, bountySupply);\n', '        bountySupply = 0;\n', '    }\n', '\n', '    function grantReserveTokens(address beneficiary) onlyOwner public {\n', '        require(reserveSupply > 0);\n', '\n', '        token.mint(beneficiary, reserveSupply);\n', '        reserveSupply = 0;\n', '    }\n', '\n', '    function grantAdvisorsTokens(address beneficiary) onlyOwner public {\n', '        require(advisorSupply > 0);\n', '\n', '        token.mint(beneficiary, advisorSupply);\n', '        advisorSupply = 0;\n', '    }\n', '\n', '    function grantFoundersTokens(address beneficiary) onlyOwner public {\n', '        require(founderSupply > 0);\n', '\n', '        token.mint(beneficiary, founderSupply);\n', '        founderSupply = 0;\n', '    }\n', '\n', '    function grantTeamTokens(address beneficiary) onlyOwner public {\n', '        require(teamSupply > 0);\n', '\n', '        token.mint(beneficiary, teamSupply);\n', '        teamSupply = 0;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address internal owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public returns (bool) {\n', '        require(newOwner != address(0x0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface MintableToken {\n', '    function mint(address _to, uint256 _amount) external returns (bool);\n', '    function transferOwnership(address newOwner) external returns (bool);\n', '}\n', '\n', 'interface BitNauticWhitelist {\n', '    function AMLWhitelisted(address) external returns (bool);\n', '}\n', '\n', 'interface BitNauticCrowdsale {\n', '    function creditOf(address) external returns (uint256);\n', '}\n', '\n', 'contract BitNauticCrowdsaleTokenDistributor is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant ICOStartTime = 1531267200; // 11 Jul 2018 00:00 GMT\n', '    uint256 public constant ICOEndTime = 1536969600; // 15 Sep 2018 00:00 GMT\n', '\n', '    uint256 public teamSupply =     3000000 * 10 ** 18; // 6% of token cap\n', '    uint256 public bountySupply =   2500000 * 10 ** 18; // 5% of token cap\n', '    uint256 public reserveSupply =  5000000 * 10 ** 18; // 10% of token cap\n', '    uint256 public advisorSupply =  2500000 * 10 ** 18; // 5% of token cap\n', '    uint256 public founderSupply =  2000000 * 10 ** 18; // 4% of token cap\n', '\n', '    MintableToken public token;\n', '    BitNauticWhitelist public whitelist;\n', '    BitNauticCrowdsale public crowdsale;\n', '\n', '    mapping (address => bool) public hasClaimedTokens;\n', '\n', '    constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public {\n', '        token = _token;\n', '        whitelist = _whitelist;\n', '        crowdsale = _crowdsale;\n', '    }\n', '\n', '    function privateSale(address beneficiary, uint256 tokenAmount) onlyOwner public {\n', '        require(beneficiary != 0x0);\n', '\n', '        assert(token.mint(beneficiary, tokenAmount));\n', '    }\n', '\n', '    // this function can be called by the contributor to claim his BTNT tokens at the end of the ICO\n', '    function claimBitNauticTokens() public returns (bool) {\n', '        return grantContributorTokens(msg.sender);\n', '    }\n', '\n', '    // if the ICO is finished and the goal has been reached, this function will be used to mint and transfer BTNT tokens to each contributor\n', '    function grantContributorTokens(address contributor) public returns (bool) {\n', '        require(!hasClaimedTokens[contributor]);\n', '        require(crowdsale.creditOf(contributor) > 0);\n', '        require(whitelist.AMLWhitelisted(contributor));\n', '        require(now > ICOEndTime);\n', '\n', '        assert(token.mint(contributor, crowdsale.creditOf(contributor)));\n', '        hasClaimedTokens[contributor] = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferTokenOwnership(address newTokenOwner) onlyOwner public returns (bool) {\n', '        return token.transferOwnership(newTokenOwner);\n', '    }\n', '\n', '    function grantBountyTokens(address beneficiary) onlyOwner public {\n', '        require(bountySupply > 0);\n', '\n', '        token.mint(beneficiary, bountySupply);\n', '        bountySupply = 0;\n', '    }\n', '\n', '    function grantReserveTokens(address beneficiary) onlyOwner public {\n', '        require(reserveSupply > 0);\n', '\n', '        token.mint(beneficiary, reserveSupply);\n', '        reserveSupply = 0;\n', '    }\n', '\n', '    function grantAdvisorsTokens(address beneficiary) onlyOwner public {\n', '        require(advisorSupply > 0);\n', '\n', '        token.mint(beneficiary, advisorSupply);\n', '        advisorSupply = 0;\n', '    }\n', '\n', '    function grantFoundersTokens(address beneficiary) onlyOwner public {\n', '        require(founderSupply > 0);\n', '\n', '        token.mint(beneficiary, founderSupply);\n', '        founderSupply = 0;\n', '    }\n', '\n', '    function grantTeamTokens(address beneficiary) onlyOwner public {\n', '        require(teamSupply > 0);\n', '\n', '        token.mint(beneficiary, teamSupply);\n', '        teamSupply = 0;\n', '    }\n', '}']
