['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n', ' * the methods to add functionality. Consider using &#39;super&#39; where appropriate to concatenate\n', ' * behavior.\n', ' */\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  Token public token;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // How many token units a buyer gets per ether.\n', '  uint256 public rate;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '\n', '  // ICO start timestamp\n', '  uint256 public startTime = now;\n', '\n', '  // periods timestamps\n', '  uint256 round1StartTime;\n', '  uint256 round1EndTime;\n', '  uint256 round2StartTime;\n', '  uint256 round2EndTime;\n', '  uint256 round3StartTime;\n', '  uint256 round3EndTime;\n', '  uint256 round4StartTime;\n', '  uint256 round4EndTime;\n', '\n', '  // bonuses in %\n', '  uint256 public round1Bonus = 20;\n', '  uint256 public round2Bonus = 15;\n', '  uint256 public round3Bonus = 5;\n', '\n', '  // min contribution in wei\n', '  uint256 public minContribution = 100 finney;\n', '\n', '  // hardcaps in tokens\n', '  uint256 public round1Cap = uint256(9e8).mul(1 ether);\n', '  uint256 public round2Cap = uint256(12e8).mul(1 ether);\n', '  uint256 public round3Cap = uint256(15e8).mul(1 ether);\n', '  uint256 public round4Cap = uint256(24e8).mul(1 ether);\n', '\n', '  // tokens sold\n', '  uint256 public round1Sold;\n', '  uint256 public round2Sold;\n', '  uint256 public round3Sold;\n', '  uint256 public round4Sold;\n', '\n', '  // Contributions\n', '  mapping(address => uint256) public contributions;\n', '\n', '  // hardCap in ETH\n', '  uint256 hardCap = 12500 ether;\n', '  // softCap in ETH\n', '  uint256 softCap = 1250 ether;\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '   * Event for external token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event ExternalTokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '   * @param _rate Base rate\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   */\n', '  constructor(uint256 _rate, address _newOwner, address _wallet, Token _token) public {\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    rate = _rate;\n', '    owner = _newOwner;\n', '    wallet = _wallet;\n', '    token = _token;\n', '    round1StartTime = startTime;\n', '    round1EndTime = round1StartTime.add(7 days);\n', '    round2StartTime = round1EndTime.add(1 days);\n', '    round2EndTime = round2StartTime.add(10 days);\n', '    round3StartTime = round2EndTime.add(1 days);\n', '    round3EndTime = round3StartTime.add(14 days);\n', '    round4StartTime = round3EndTime.add(1 days);\n', '    round4EndTime = round4StartTime.add(21 days);\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev getting stage index\n', '   */\n', '\n', '  function _getStageIndex () internal view returns (uint8) {\n', '    if (now < round1StartTime) return 0;\n', '    if (now <= round1EndTime) return 1;\n', '    if (now < round2StartTime) return 2;\n', '    if (now <= round2EndTime) return 3;\n', '    if (now < round3StartTime) return 4;\n', '    if (now <= round3EndTime) return 5;\n', '    if (now < round4StartTime) return 6;\n', '    if (now <= round4EndTime) return 7;\n', '    return 8;\n', '  }\n', '\n', '  /**\n', '   * @dev getting stage name\n', '   */\n', '\n', '  function getStageName () public view returns (string) {\n', '    uint8 stageIndex = _getStageIndex();\n', '    if (stageIndex == 0) return &#39;Pause&#39;;\n', '    if (stageIndex == 1) return &#39;Round1&#39;;\n', '    if (stageIndex == 2) return &#39;Round1 end&#39;;\n', '    if (stageIndex == 3) return &#39;Round2&#39;;\n', '    if (stageIndex == 4) return &#39;Round2 end&#39;;\n', '    if (stageIndex == 5) return &#39;Round3&#39;;\n', '    if (stageIndex == 6) return &#39;Round3 end&#39;;\n', '    if (stageIndex == 7) return &#39;Round4&#39;;\n', '    if (stageIndex == 8) return &#39;Round4 end&#39;;\n', '    return &#39;Pause&#39;;\n', '  }\n', '\n', '  /**\n', '   * @dev low level token purchase ***DO NOT OVERRIDE***\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable {\n', '\n', '    uint256 weiAmount = msg.value;\n', '    uint8 stageIndex = _getStageIndex();\n', '    require(stageIndex > 0);\n', '    require(stageIndex <= 8);\n', '\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(weiAmount, stageIndex);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    contributions[msg.sender] = contributions[msg.sender].add(weiAmount);\n', '\n', '    if (stageIndex == 1 || stageIndex == 2) round1Sold = round1Sold.add(tokens);\n', '    else if (stageIndex == 3 || stageIndex == 4) round2Sold = round2Sold.add(tokens);\n', '    else if (stageIndex == 5 || stageIndex == 6) round3Sold = round3Sold.add(tokens);\n', '    else round4Sold = round4Sold.add(tokens);\n', '\n', '    _processPurchase(_beneficiary, tokens);\n', '    emit TokenPurchase(\n', '      msg.sender,\n', '      _beneficiary,\n', '      weiAmount,\n', '      tokens\n', '    );\n', '    if (weiRaised >= softCap) _forwardFunds();\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n', '   * Example from CappedCrowdsale.sol&#39;s _preValidatePurchase method: \n', '   *   super._preValidatePurchase(_beneficiary, _weiAmount);\n', '   *   require(weiRaised.add(_weiAmount) <= cap);\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(\n', '    address _beneficiary,\n', '    uint256 _weiAmount\n', '  )\n', '    internal view\n', '  {\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount > 0);\n', '    require(weiRaised.add(_weiAmount) <= hardCap);\n', '\n', '    require(_weiAmount >= minContribution);\n', '  }\n', '\n', '  /**\n', '   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _tokenAmount Number of tokens to be emitted\n', '   */\n', '  function _deliverTokens(\n', '    address _beneficiary,\n', '    uint256 _tokenAmount\n', '  )\n', '    internal\n', '  {\n', '    require(token.transfer(_beneficiary, _tokenAmount));\n', '  }\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(\n', '    address _beneficiary,\n', '    uint256 _tokenAmount\n', '  )\n', '    internal\n', '  {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getTokenAmount(uint256 _weiAmount, uint8 _stageIndex)\n', '    internal view returns (uint256)\n', '  {\n', '    uint256 _bonus = 0;\n', '    uint256 _cap;\n', '    if (_stageIndex == 1) {\n', '      _bonus = round1Bonus;\n', '      _cap = round1Cap.sub(round1Sold);\n', '    } else if (_stageIndex == 2) {\n', '      _cap = round2Cap.sub(round1Sold);\n', '    } else if (_stageIndex == 3) {\n', '      _bonus = round2Bonus;\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);\n', '    } else if (_stageIndex == 4) {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);\n', '    } else if (_stageIndex == 5) {\n', '      _bonus = round3Bonus;\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);\n', '    }  else if (_stageIndex == 6) {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);\n', '    } else {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold).add(round4Cap).sub(round4Sold);\n', '    }\n', '\n', '    uint256 _tokenAmount = _weiAmount.mul(rate);\n', '    if (_bonus > 0) {\n', '      uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\n', '      _tokenAmount = _tokenAmount.add(_bonusTokens);\n', '    }\n', '    if (_stageIndex < 8) require(_tokenAmount <= _cap);\n', '    return _tokenAmount;\n', '  }\n', '\n', '  function refund () public returns (bool) {\n', '    require(now > round4EndTime);\n', '    require(weiRaised < softCap);\n', '    require(contributions[msg.sender] > 0);\n', '    uint256 refundAmount = contributions[msg.sender];\n', '    contributions[msg.sender] = 0;\n', '    weiRaised = weiRaised.sub(refundAmount);\n', '    msg.sender.transfer(refundAmount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function transferSoldTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner returns (bool) {\n', '    uint8 stageIndex = _getStageIndex();\n', '    require(stageIndex > 0);\n', '    require(stageIndex <= 8);\n', '\n', '    if (stageIndex == 1 || stageIndex == 2) {\n', '      round1Sold = round1Sold.add(_tokenAmount);\n', '      require(round1Sold <= round1Cap);\n', '    } else if (stageIndex == 3 || stageIndex == 4) {\n', '      round2Sold = round2Sold.add(_tokenAmount);\n', '      require(round2Sold <= round2Cap);\n', '    } else if (stageIndex == 5 || stageIndex == 6) {\n', '      round3Sold = round3Sold.add(_tokenAmount);\n', '      require(round3Sold <= round3Cap);\n', '    } else if (stageIndex == 7) {\n', '      round4Sold = round4Sold.add(_tokenAmount);\n', '      require(round4Sold <= round4Cap);\n', '    }\n', '    emit ExternalTokenPurchase(\n', '      _beneficiary,\n', '      _beneficiary,\n', '      _tokenAmount\n', '    );\n', '\n', '    require(token.transfer(_beneficiary, _tokenAmount));\n', '    return true;\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n', " * the methods to add functionality. Consider using 'super' where appropriate to concatenate\n", ' * behavior.\n', ' */\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  // The token being sold\n', '  Token public token;\n', '\n', '  // Address where funds are collected\n', '  address public wallet;\n', '\n', '  // How many token units a buyer gets per ether.\n', '  uint256 public rate;\n', '\n', '  // Amount of wei raised\n', '  uint256 public weiRaised;\n', '\n', '  // ICO start timestamp\n', '  uint256 public startTime = now;\n', '\n', '  // periods timestamps\n', '  uint256 round1StartTime;\n', '  uint256 round1EndTime;\n', '  uint256 round2StartTime;\n', '  uint256 round2EndTime;\n', '  uint256 round3StartTime;\n', '  uint256 round3EndTime;\n', '  uint256 round4StartTime;\n', '  uint256 round4EndTime;\n', '\n', '  // bonuses in %\n', '  uint256 public round1Bonus = 20;\n', '  uint256 public round2Bonus = 15;\n', '  uint256 public round3Bonus = 5;\n', '\n', '  // min contribution in wei\n', '  uint256 public minContribution = 100 finney;\n', '\n', '  // hardcaps in tokens\n', '  uint256 public round1Cap = uint256(9e8).mul(1 ether);\n', '  uint256 public round2Cap = uint256(12e8).mul(1 ether);\n', '  uint256 public round3Cap = uint256(15e8).mul(1 ether);\n', '  uint256 public round4Cap = uint256(24e8).mul(1 ether);\n', '\n', '  // tokens sold\n', '  uint256 public round1Sold;\n', '  uint256 public round2Sold;\n', '  uint256 public round3Sold;\n', '  uint256 public round4Sold;\n', '\n', '  // Contributions\n', '  mapping(address => uint256) public contributions;\n', '\n', '  // hardCap in ETH\n', '  uint256 hardCap = 12500 ether;\n', '  // softCap in ETH\n', '  uint256 softCap = 1250 ether;\n', '\n', '  /**\n', '   * Event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '   * Event for external token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event ExternalTokenPurchase(\n', '    address indexed purchaser,\n', '    address indexed beneficiary,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '   * @param _rate Base rate\n', '   * @param _wallet Address where collected funds will be forwarded to\n', '   * @param _token Address of the token being sold\n', '   */\n', '  constructor(uint256 _rate, address _newOwner, address _wallet, Token _token) public {\n', '    require(_wallet != address(0));\n', '    require(_token != address(0));\n', '    rate = _rate;\n', '    owner = _newOwner;\n', '    wallet = _wallet;\n', '    token = _token;\n', '    round1StartTime = startTime;\n', '    round1EndTime = round1StartTime.add(7 days);\n', '    round2StartTime = round1EndTime.add(1 days);\n', '    round2EndTime = round2StartTime.add(10 days);\n', '    round3StartTime = round2EndTime.add(1 days);\n', '    round3EndTime = round3StartTime.add(14 days);\n', '    round4StartTime = round3EndTime.add(1 days);\n', '    round4EndTime = round4StartTime.add(21 days);\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Crowdsale external interface\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev fallback function ***DO NOT OVERRIDE***\n', '   */\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev getting stage index\n', '   */\n', '\n', '  function _getStageIndex () internal view returns (uint8) {\n', '    if (now < round1StartTime) return 0;\n', '    if (now <= round1EndTime) return 1;\n', '    if (now < round2StartTime) return 2;\n', '    if (now <= round2EndTime) return 3;\n', '    if (now < round3StartTime) return 4;\n', '    if (now <= round3EndTime) return 5;\n', '    if (now < round4StartTime) return 6;\n', '    if (now <= round4EndTime) return 7;\n', '    return 8;\n', '  }\n', '\n', '  /**\n', '   * @dev getting stage name\n', '   */\n', '\n', '  function getStageName () public view returns (string) {\n', '    uint8 stageIndex = _getStageIndex();\n', "    if (stageIndex == 0) return 'Pause';\n", "    if (stageIndex == 1) return 'Round1';\n", "    if (stageIndex == 2) return 'Round1 end';\n", "    if (stageIndex == 3) return 'Round2';\n", "    if (stageIndex == 4) return 'Round2 end';\n", "    if (stageIndex == 5) return 'Round3';\n", "    if (stageIndex == 6) return 'Round3 end';\n", "    if (stageIndex == 7) return 'Round4';\n", "    if (stageIndex == 8) return 'Round4 end';\n", "    return 'Pause';\n", '  }\n', '\n', '  /**\n', '   * @dev low level token purchase ***DO NOT OVERRIDE***\n', '   * @param _beneficiary Address performing the token purchase\n', '   */\n', '  function buyTokens(address _beneficiary) public payable {\n', '\n', '    uint256 weiAmount = msg.value;\n', '    uint8 stageIndex = _getStageIndex();\n', '    require(stageIndex > 0);\n', '    require(stageIndex <= 8);\n', '\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '    // calculate token amount to be created\n', '    uint256 tokens = _getTokenAmount(weiAmount, stageIndex);\n', '\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    contributions[msg.sender] = contributions[msg.sender].add(weiAmount);\n', '\n', '    if (stageIndex == 1 || stageIndex == 2) round1Sold = round1Sold.add(tokens);\n', '    else if (stageIndex == 3 || stageIndex == 4) round2Sold = round2Sold.add(tokens);\n', '    else if (stageIndex == 5 || stageIndex == 6) round3Sold = round3Sold.add(tokens);\n', '    else round4Sold = round4Sold.add(tokens);\n', '\n', '    _processPurchase(_beneficiary, tokens);\n', '    emit TokenPurchase(\n', '      msg.sender,\n', '      _beneficiary,\n', '      weiAmount,\n', '      tokens\n', '    );\n', '    if (weiRaised >= softCap) _forwardFunds();\n', '  }\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  /**\n', '   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n', "   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \n", '   *   super._preValidatePurchase(_beneficiary, _weiAmount);\n', '   *   require(weiRaised.add(_weiAmount) <= cap);\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _preValidatePurchase(\n', '    address _beneficiary,\n', '    uint256 _weiAmount\n', '  )\n', '    internal view\n', '  {\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount > 0);\n', '    require(weiRaised.add(_weiAmount) <= hardCap);\n', '\n', '    require(_weiAmount >= minContribution);\n', '  }\n', '\n', '  /**\n', '   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '   * @param _beneficiary Address performing the token purchase\n', '   * @param _tokenAmount Number of tokens to be emitted\n', '   */\n', '  function _deliverTokens(\n', '    address _beneficiary,\n', '    uint256 _tokenAmount\n', '  )\n', '    internal\n', '  {\n', '    require(token.transfer(_beneficiary, _tokenAmount));\n', '  }\n', '\n', '  /**\n', '   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '   * @param _beneficiary Address receiving the tokens\n', '   * @param _tokenAmount Number of tokens to be purchased\n', '   */\n', '  function _processPurchase(\n', '    address _beneficiary,\n', '    uint256 _tokenAmount\n', '  )\n', '    internal\n', '  {\n', '    _deliverTokens(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  /**\n', '   * @dev Override to extend the way in which ether is converted to tokens.\n', '   * @param _weiAmount Value in wei to be converted into tokens\n', '   * @return Number of tokens that can be purchased with the specified _weiAmount\n', '   */\n', '  function _getTokenAmount(uint256 _weiAmount, uint8 _stageIndex)\n', '    internal view returns (uint256)\n', '  {\n', '    uint256 _bonus = 0;\n', '    uint256 _cap;\n', '    if (_stageIndex == 1) {\n', '      _bonus = round1Bonus;\n', '      _cap = round1Cap.sub(round1Sold);\n', '    } else if (_stageIndex == 2) {\n', '      _cap = round2Cap.sub(round1Sold);\n', '    } else if (_stageIndex == 3) {\n', '      _bonus = round2Bonus;\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);\n', '    } else if (_stageIndex == 4) {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold);\n', '    } else if (_stageIndex == 5) {\n', '      _bonus = round3Bonus;\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);\n', '    }  else if (_stageIndex == 6) {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold);\n', '    } else {\n', '      _cap = round1Cap.sub(round1Sold).add(round2Cap).sub(round2Sold).add(round3Cap).sub(round3Sold).add(round4Cap).sub(round4Sold);\n', '    }\n', '\n', '    uint256 _tokenAmount = _weiAmount.mul(rate);\n', '    if (_bonus > 0) {\n', '      uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\n', '      _tokenAmount = _tokenAmount.add(_bonusTokens);\n', '    }\n', '    if (_stageIndex < 8) require(_tokenAmount <= _cap);\n', '    return _tokenAmount;\n', '  }\n', '\n', '  function refund () public returns (bool) {\n', '    require(now > round4EndTime);\n', '    require(weiRaised < softCap);\n', '    require(contributions[msg.sender] > 0);\n', '    uint256 refundAmount = contributions[msg.sender];\n', '    contributions[msg.sender] = 0;\n', '    weiRaised = weiRaised.sub(refundAmount);\n', '    msg.sender.transfer(refundAmount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Determines how ETH is stored/forwarded on purchases.\n', '   */\n', '  function _forwardFunds() internal {\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function transferSoldTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner returns (bool) {\n', '    uint8 stageIndex = _getStageIndex();\n', '    require(stageIndex > 0);\n', '    require(stageIndex <= 8);\n', '\n', '    if (stageIndex == 1 || stageIndex == 2) {\n', '      round1Sold = round1Sold.add(_tokenAmount);\n', '      require(round1Sold <= round1Cap);\n', '    } else if (stageIndex == 3 || stageIndex == 4) {\n', '      round2Sold = round2Sold.add(_tokenAmount);\n', '      require(round2Sold <= round2Cap);\n', '    } else if (stageIndex == 5 || stageIndex == 6) {\n', '      round3Sold = round3Sold.add(_tokenAmount);\n', '      require(round3Sold <= round3Cap);\n', '    } else if (stageIndex == 7) {\n', '      round4Sold = round4Sold.add(_tokenAmount);\n', '      require(round4Sold <= round4Cap);\n', '    }\n', '    emit ExternalTokenPurchase(\n', '      _beneficiary,\n', '      _beneficiary,\n', '      _tokenAmount\n', '    );\n', '\n', '    require(token.transfer(_beneficiary, _tokenAmount));\n', '    return true;\n', '  }\n', '}']
