['pragma solidity ^0.4.21;\n', '\n', '/******************************************************************************\\\n', '*..................................SU.SQUARES..................................*\n', '*.......................Blockchain.rentable.advertising........................*\n', '*..............................................................................*\n', '* First, I just want to say we are so excited and humbled to get this far and  *\n', '* that you&#39;re even reading this. So thank you!                                 *\n', '*                                                                              *\n', '* This file is organized into multiple contracts that separate functionality   *\n', '* into logical parts. The deployed contract, SuMain, is at the bottom and      *\n', '* includes the rest of the file using inheritance.                             *\n', '*                                                                              *\n', '*  - ERC165, ERC721: These interfaces follow the official EIPs                 *\n', '*  - AccessControl: A reusable CEO/CFO/COO access model                        *\n', '*  - PublishInterfaces: An implementation of ERC165                            *\n', '*  - SuNFT: An implementation of ERC721                                        *\n', '*  - SuOperation: The actual square data and the personalize function          *\n', '*  - SuPromo, SuVending: How we sell or grant squares                          *\n', '*..............................................................................*\n', '*............................Su.&.William.Entriken.............................*\n', '*...................................(c) 2018...................................*\n', '\\******************************************************************************/\n', '\n', '/* AccessControl.sol **********************************************************/\n', '\n', '/// @title Reusable three-role access control inspired by CryptoKitties\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Keep the CEO wallet stored offline, I warned you\n', 'contract AccessControl {\n', '    /// @notice The account that can only reassign executive accounts\n', '    address public executiveOfficerAddress;\n', '\n', '    /// @notice The account that can collect funds from this contract\n', '    address public financialOfficerAddress;\n', '\n', '    /// @notice The account with administrative control of this contract\n', '    address public operatingOfficerAddress;\n', '\n', '    function AccessControl() internal {\n', '        executiveOfficerAddress = msg.sender;\n', '    }\n', '\n', '    /// @dev Only allowed by executive officer\n', '    modifier onlyExecutiveOfficer() {\n', '        require(msg.sender == executiveOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only allowed by financial officer\n', '    modifier onlyFinancialOfficer() {\n', '        require(msg.sender == financialOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only allowed by operating officer\n', '    modifier onlyOperatingOfficer() {\n', '        require(msg.sender == operatingOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @notice Reassign the executive officer role\n', '    /// @param _executiveOfficerAddress new officer address\n', '    function setExecutiveOfficer(address _executiveOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_executiveOfficerAddress != address(0));\n', '        executiveOfficerAddress = _executiveOfficerAddress;\n', '    }\n', '\n', '    /// @notice Reassign the financial officer role\n', '    /// @param _financialOfficerAddress new officer address\n', '    function setFinancialOfficer(address _financialOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_financialOfficerAddress != address(0));\n', '        financialOfficerAddress = _financialOfficerAddress;\n', '    }\n', '\n', '    /// @notice Reassign the operating officer role\n', '    /// @param _operatingOfficerAddress new officer address\n', '    function setOperatingOfficer(address _operatingOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_operatingOfficerAddress != address(0));\n', '        operatingOfficerAddress = _operatingOfficerAddress;\n', '    }\n', '\n', '    /// @notice Collect funds from this contract\n', '    function withdrawBalance() external onlyFinancialOfficer {\n', '        financialOfficerAddress.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '/* ERC165.sol *****************************************************************/\n', '\n', '/// @title ERC-165 Standard Interface Detection\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/* ERC721.sol *****************************************************************/\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', 'contract ERC721 is ERC165 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function approve(address _approved, uint256 _tokenId) external payable;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external pure returns (string _name);\n', '    function symbol() external pure returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/* PublishInterfaces.sol ******************************************************/\n', '\n', '/// @title A reusable contract to comply with ERC-165\n', '/// @author William Entriken (https://phor.net)\n', 'contract PublishInterfaces is ERC165 {\n', '    /// @dev Every interface that we support\n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    function PublishInterfaces() internal {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\n', '    }\n', '}\n', '\n', '/* SuNFT.sol ******************************************************************/\n', '\n', '/// @title Compliance with ERC-721 for Su Squares\n', '/// @dev This implementation assumes:\n', '///  - A fixed supply of NFTs, cannot mint or burn\n', '///  - ids are numbered sequentially starting at 1.\n', '///  - NFTs are initially assigned to this contract\n', '///  - This contract does not externally call its own functions\n', '/// @author William Entriken (https://phor.net)\n', 'contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces {\n', '    /// @dev The authorized address for each NFT\n', '    mapping (uint256 => address) internal tokenApprovals;\n', '\n', '    /// @dev The authorized operators for each address\n', '    mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '    /// @dev Guarantees msg.sender is the owner of _tokenId\n', '    /// @param _tokenId The token to validate belongs to msg.sender\n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // assert(msg.sender != address(this))\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier mustBeOwnedByThisContract(uint256 _tokenId) {\n', '        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(owner == address(0) || owner == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier canOperate(uint256 _tokenId) {\n', '        // assert(msg.sender != address(this))\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(msg.sender == owner || operatorApprovals[owner][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(uint256 _tokenId) {\n', '        // assert(msg.sender != address(this))\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(msg.sender == owner ||\n', '          msg.sender == tokenApprovals[_tokenId] ||\n', '          operatorApprovals[msg.sender][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier mustBeValidToken(uint256 _tokenId) {\n', '        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\n', '        _;\n', '    }\n', '\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        return _tokensOfOwnerWithSubstitutions[_owner].length;\n', '    }\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (address _owner)\n', '    {\n', '        _owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (_owner == address(0)) {\n', '            _owner = address(this);\n', '        }\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable\n', '    {\n', '        _safeTransferFrom(_from, _to, _tokenId, data);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable\n', '    {\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        external\n', '        payable\n', '        mustBeValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '    {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (owner == address(0)) {\n', '            owner = address(this);\n', '        }\n', '        require(owner == _from);\n', '        require(_to != address(0));\n', '        _transfer(_tokenId, _to);\n', '    }\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    function approve(address _approved, uint256 _tokenId)\n', '        external\n', '        payable\n', '        // assert(mustBeValidToken(_tokenId))\n', '        canOperate(_tokenId)\n', '    {\n', '        address _owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (_owner == address(0)) {\n', '            _owner = address(this);\n', '        }\n', '        tokenApprovals[_tokenId] = _approved;\n', '        emit Approval(_owner, _approved, _tokenId);\n', '    }\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your asset.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        operatorApprovals[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (address)\n', '    {\n', '        return tokenApprovals[_tokenId];\n', '    }\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '    // COMPLIANCE WITH ERC721Metadata //////////////////////////////////////////\n', '\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string) {\n', '        return "Su Squares";\n', '    }\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string) {\n', '        return "SU";\n', '    }\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (string _tokenURI)\n', '    {\n', '        _tokenURI = "https://tenthousandsu.com/erc721/00000.json";\n', '        bytes memory _tokenURIBytes = bytes(_tokenURI);\n', '        _tokenURIBytes[33] = byte(48+(_tokenId / 10000) % 10);\n', '        _tokenURIBytes[34] = byte(48+(_tokenId / 1000) % 10);\n', '        _tokenURIBytes[35] = byte(48+(_tokenId / 100) % 10);\n', '        _tokenURIBytes[36] = byte(48+(_tokenId / 10) % 10);\n', '        _tokenURIBytes[37] = byte(48+(_tokenId / 1) % 10);\n', '\n', '    }\n', '\n', '    // COMPLIANCE WITH ERC721Enumerable ////////////////////////////////////////\n', '\n', '    /// @notice Count NFTs tracked by this contract\n', '    /// @return A count of valid NFTs tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function totalSupply() external view returns (uint256) {\n', '        return TOTAL_SUPPLY;\n', '    }\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        require(_index < TOTAL_SUPPLY);\n', '        return _index + 1;\n', '    }\n', '\n', '    /// @notice Enumerate NFTs assigned to an owner\n', '    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid NFTs.\n', '    /// @param _owner An address where we are interested in NFTs owned by them\n', '    /// @param _index A counter less than `balanceOf(_owner)`\n', '    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\n', '        require(_owner != address(0));\n', '        require(_index < _tokensOfOwnerWithSubstitutions[_owner].length);\n', '        _tokenId = _tokensOfOwnerWithSubstitutions[_owner][_index];\n', '        // Handle substitutions\n', '        if (_owner == address(this)) {\n', '            if (_tokenId == 0) {\n', '                _tokenId = _index + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // INTERNAL INTERFACE //////////////////////////////////////////////////////\n', '\n', '    /// @dev Actually do a transfer, does NO precondition checking\n', '    function _transfer(uint256 _tokenId, address _to) internal {\n', '        // Here are the preconditions we are not checking:\n', '        // assert(canTransfer(_tokenId))\n', '        // assert(mustBeValidToken(_tokenId))\n', '        require(_to != address(0));\n', '\n', '        // Find the FROM address\n', '        address fromWithSubstitution = _tokenOwnerWithSubstitutions[_tokenId];\n', '        address from = fromWithSubstitution;\n', '        if (fromWithSubstitution == address(0)) {\n', '            from = address(this);\n', '        }\n', '\n', '        // Take away from the FROM address\n', '        // The Entriken algorithm for deleting from an indexed, unsorted array\n', '        uint256 indexToDeleteWithSubstitution = _ownedTokensIndexWithSubstitutions[_tokenId];\n', '        uint256 indexToDelete;\n', '        if (indexToDeleteWithSubstitution == 0) {\n', '            indexToDelete = _tokenId - 1;\n', '        } else {\n', '            indexToDelete = indexToDeleteWithSubstitution - 1;\n', '        }\n', '        if (indexToDelete != _tokensOfOwnerWithSubstitutions[from].length - 1) {\n', '            uint256 lastNftWithSubstitution = _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1];\n', '            uint256 lastNft = lastNftWithSubstitution;\n', '            if (lastNftWithSubstitution == 0) {\n', '                // assert(from ==  address(0) || from == address(this));\n', '                lastNft = _tokensOfOwnerWithSubstitutions[from].length;\n', '            }\n', '            _tokensOfOwnerWithSubstitutions[from][indexToDelete] = lastNft;\n', '            _ownedTokensIndexWithSubstitutions[lastNft] = indexToDelete + 1;\n', '        }\n', '        delete _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1]; // get gas back\n', '        _tokensOfOwnerWithSubstitutions[from].length--;\n', '        // Right now _ownedTokensIndexWithSubstitutions[_tokenId] is invalid, set it below based on the new owner\n', '\n', '        // Give to the TO address\n', '        _tokensOfOwnerWithSubstitutions[_to].push(_tokenId);\n', '        _ownedTokensIndexWithSubstitutions[_tokenId] = (_tokensOfOwnerWithSubstitutions[_to].length - 1) + 1;\n', '\n', '        // External processing\n', '        _tokenOwnerWithSubstitutions[_tokenId] = _to;\n', '        tokenApprovals[_tokenId] = address(0);\n', '        emit Transfer(from, _to, _tokenId);\n', '    }\n', '\n', '    // PRIVATE STORAGE AND FUNCTIONS ///////////////////////////////////////////\n', '\n', '    uint256 private constant TOTAL_SUPPLY = 10000; // SOLIDITY ISSUE #3356 make this immutable\n', '\n', '    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '\n', '    /// @dev The owner of each NFT\n', '    ///  If value == address(0), NFT is owned by address(this)\n', '    ///  If value != address(0), NFT is owned by value\n', '    ///  assert(This contract never assigns awnerhip to address(0) or destroys NFTs)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (uint256 => address) private _tokenOwnerWithSubstitutions;\n', '\n', '    /// @dev The list of NFTs owned by each address\n', '    ///  Nomenclature: this[key][index] = value\n', '    ///  If key != address(this) or value != 0, then value represents an NFT\n', '    ///  If key == address(this) and value == 0, then index + 1 is the NFT\n', '    ///  assert(0 is not a valid NFT)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (address => uint256[]) private _tokensOfOwnerWithSubstitutions;\n', '\n', '    /// @dev (Location + 1) of each NFT in its owner&#39;s list\n', '    ///  Nomenclature: this[key] = value\n', '    ///  If value != 0, _tokensOfOwnerWithSubstitutions[owner][value - 1] = nftId\n', '    ///  If value == 0, _tokensOfOwnerWithSubstitutions[owner][key - 1] = nftId\n', '    ///  assert(2**256-1 is not a valid NFT)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (uint256 => uint256) private _ownedTokensIndexWithSubstitutions;\n', '\n', '    // Due to implementation choices (no mint, no burn, contiguous NFT ids), it\n', '    // is not necessary to keep an array of NFT ids nor where each NFT id is\n', '    // located in that array.\n', '    // address[] private nftIds;\n', '    // mapping (uint256 => uint256) private nftIndexOfId;\n', '\n', '    function SuNFT() internal {\n', '        // Publish interfaces with ERC-165\n', '        supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '        supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\n', '\n', '        // The effect of substitution makes storing address(this), address(this)\n', '        // ..., address(this) for a total of TOTAL_SUPPLY times unnecessary at\n', '        // deployment time\n', '        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\n', '        //     _tokenOwnerWithSubstitutions[i] = address(this);\n', '        // }\n', '\n', '        // The effect of substitution makes storing 1, 2, ..., TOTAL_SUPPLY\n', '        // unnecessary at deployment time\n', '        _tokensOfOwnerWithSubstitutions[address(this)].length = TOTAL_SUPPLY;\n', '        // for (uint256 i = 0; i < TOTAL_SUPPLY; i++) {\n', '        //     _tokensOfOwnerWithSubstitutions[address(this)][i] = i + 1;\n', '        // }\n', '        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\n', '        //     _ownedTokensIndexWithSubstitutions[i] = i - 1;\n', '        // }\n', '    }\n', '\n', '    /// @dev Actually perform the safeTransferFrom\n', '    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\n', '        private\n', '        mustBeValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '    {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (owner == address(0)) {\n', '            owner = address(this);\n', '        }\n', '        require(owner == _from);\n', '        require(_to != address(0));\n', '        _transfer(_tokenId, _to);\n', '\n', '        // Do the callback after everything is done to avoid reentrancy attack\n', '        uint256 codeSize;\n', '        assembly { codeSize := extcodesize(_to) }\n', '        if (codeSize == 0) {\n', '            return;\n', '        }\n', '        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '        require(retval == ERC721_RECEIVED);\n', '    }\n', '}\n', '\n', '/* SuOperation.sol ************************************************************/\n', '\n', '/// @title The features that square owners can use\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuOperation is SuNFT {\n', '    /// @dev The personalization of a square has changed\n', '    event Personalized(uint256 _nftId);\n', '\n', '    /// @dev The main SuSquare struct. The owner may set these properties, subject\n', '    ///  subject to certain rules. The actual 10x10 image is rendered on our\n', '    ///  website using this data.\n', '    struct SuSquare {\n', '        /// @dev This increments on each update\n', '        uint256 version;\n', '\n', '        /// @dev A 10x10 pixel image, stored 8-bit RGB values from left-to-right\n', '        ///  and top-to-bottom order (normal English reading order). So it is\n', '        ///  exactly 300 bytes. Or it is an empty array.\n', '        ///  So the first byte is the red channel for the top-left pixel, then\n', '        ///  the blue, then the green, and then next is the red channel for the\n', '        ///  pixel to the right of the first pixel.\n', '        bytes rgbData;\n', '\n', '        /// @dev The title of this square, at most 64 bytes,\n', '        string title;\n', '\n', '        /// @dev The URL of this square, at most 100 bytes, or empty string\n', '        string href;\n', '    }\n', '\n', '    /// @notice All the Su Squares that ever exist or will exist. Each Su Square\n', '    ///  represents a square on our webpage in a 100x100 grid. The squares are\n', '    ///  arranged in left-to-right, top-to-bottom order. In other words, normal\n', '    ///  English reading order. So suSquares[1] is the top-left location and\n', '    ///  suSquares[100] is the top-right location. And suSquares[101] is\n', '    ///  directly below suSquares[1].\n', '    /// @dev There is no suSquares[0] -- that is an unused array index.\n', '    SuSquare[10001] public suSquares;\n', '\n', '    /// @notice Update the contents of your square, the first 3 personalizations\n', '    ///  for a square are free then cost 10 finney (0.01 ether) each\n', '    /// @param _squareId The top-left is 1, to its right is 2, ..., top-right is\n', '    ///  100 and then 101 is below 1... the last one at bottom-right is 10000\n', '    /// @param _squareId A 10x10 image for your square, in 8-bit RGB words\n', '    ///  ordered like the squares are ordered. See Imagemagick&#39;s command\n', '    ///  convert -size 10x10 -depth 8 in.rgb out.png\n', '    /// @param _title A description of your square (max 64 bytes UTF-8)\n', '    /// @param _href A hyperlink for your square (max 96 bytes)\n', '    function personalizeSquare(\n', '        uint256 _squareId,\n', '        bytes _rgbData,\n', '        string _title,\n', '        string _href\n', '    )\n', '        external\n', '        onlyOwnerOf(_squareId)\n', '        payable\n', '    {\n', '        require(bytes(_title).length <= 64);\n', '        require(bytes(_href).length <= 96);\n', '        require(_rgbData.length == 300);\n', '        suSquares[_squareId].version++;\n', '        suSquares[_squareId].rgbData = _rgbData;\n', '        suSquares[_squareId].title = _title;\n', '        suSquares[_squareId].href = _href;\n', '        if (suSquares[_squareId].version > 3) {\n', '            require(msg.value == 10 finney);\n', '        }\n', '        emit Personalized(_squareId);\n', '    }\n', '}\n', '\n', '/* SuPromo.sol ****************************************************************/\n', '\n', '/// @title A limited pre-sale and promotional giveaway.\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuPromo is AccessControl, SuNFT {\n', '    uint256 constant PROMO_CREATION_LIMIT = 5000;\n', '\n', '    /// @notice How many promo squares were granted\n', '    uint256 public promoCreatedCount;\n', '\n', '    /// @notice BEWARE, this does not use a safe transfer mechanism!\n', '    ///  You must manually check the receiver can accept NFTs\n', '    function grantToken(uint256 _tokenId, address _newOwner)\n', '        external\n', '        onlyOperatingOfficer\n', '        mustBeValidToken(_tokenId)\n', '        mustBeOwnedByThisContract(_tokenId)\n', '    {\n', '        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '        promoCreatedCount++;\n', '        _transfer(_tokenId, _newOwner);\n', '    }\n', '}\n', '\n', '/* SuVending.sol **************************************************************/\n', '\n', '/// @title A token vending machine\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuVending is SuNFT {\n', '    uint256 constant SALE_PRICE = 500 finney; // 0.5 ether\n', '\n', '    /// @notice The price is always 0.5 ether, and you can buy any available square\n', '    ///  Be sure you are calling this from a regular account (not a smart contract)\n', '    ///  or if you are calling from a smart contract, make sure it can use\n', '    ///  ERC-721 non-fungible tokens\n', '    function purchase(uint256 _nftId)\n', '        external\n', '        payable\n', '        mustBeValidToken(_nftId)\n', '        mustBeOwnedByThisContract(_nftId)\n', '    {\n', '        require(msg.value == SALE_PRICE);\n', '        _transfer(_nftId, msg.sender);\n', '    }\n', '}\n', '\n', '/* SuMain.sol *****************************************************************/\n', '\n', '/// @title The features that deed owners can use\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuMain is AccessControl, SuNFT, SuOperation, SuVending, SuPromo {\n', '    function SuMain() public {\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/******************************************************************************\\\n', '*..................................SU.SQUARES..................................*\n', '*.......................Blockchain.rentable.advertising........................*\n', '*..............................................................................*\n', '* First, I just want to say we are so excited and humbled to get this far and  *\n', "* that you're even reading this. So thank you!                                 *\n", '*                                                                              *\n', '* This file is organized into multiple contracts that separate functionality   *\n', '* into logical parts. The deployed contract, SuMain, is at the bottom and      *\n', '* includes the rest of the file using inheritance.                             *\n', '*                                                                              *\n', '*  - ERC165, ERC721: These interfaces follow the official EIPs                 *\n', '*  - AccessControl: A reusable CEO/CFO/COO access model                        *\n', '*  - PublishInterfaces: An implementation of ERC165                            *\n', '*  - SuNFT: An implementation of ERC721                                        *\n', '*  - SuOperation: The actual square data and the personalize function          *\n', '*  - SuPromo, SuVending: How we sell or grant squares                          *\n', '*..............................................................................*\n', '*............................Su.&.William.Entriken.............................*\n', '*...................................(c) 2018...................................*\n', '\\******************************************************************************/\n', '\n', '/* AccessControl.sol **********************************************************/\n', '\n', '/// @title Reusable three-role access control inspired by CryptoKitties\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev Keep the CEO wallet stored offline, I warned you\n', 'contract AccessControl {\n', '    /// @notice The account that can only reassign executive accounts\n', '    address public executiveOfficerAddress;\n', '\n', '    /// @notice The account that can collect funds from this contract\n', '    address public financialOfficerAddress;\n', '\n', '    /// @notice The account with administrative control of this contract\n', '    address public operatingOfficerAddress;\n', '\n', '    function AccessControl() internal {\n', '        executiveOfficerAddress = msg.sender;\n', '    }\n', '\n', '    /// @dev Only allowed by executive officer\n', '    modifier onlyExecutiveOfficer() {\n', '        require(msg.sender == executiveOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only allowed by financial officer\n', '    modifier onlyFinancialOfficer() {\n', '        require(msg.sender == financialOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @dev Only allowed by operating officer\n', '    modifier onlyOperatingOfficer() {\n', '        require(msg.sender == operatingOfficerAddress);\n', '        _;\n', '    }\n', '\n', '    /// @notice Reassign the executive officer role\n', '    /// @param _executiveOfficerAddress new officer address\n', '    function setExecutiveOfficer(address _executiveOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_executiveOfficerAddress != address(0));\n', '        executiveOfficerAddress = _executiveOfficerAddress;\n', '    }\n', '\n', '    /// @notice Reassign the financial officer role\n', '    /// @param _financialOfficerAddress new officer address\n', '    function setFinancialOfficer(address _financialOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_financialOfficerAddress != address(0));\n', '        financialOfficerAddress = _financialOfficerAddress;\n', '    }\n', '\n', '    /// @notice Reassign the operating officer role\n', '    /// @param _operatingOfficerAddress new officer address\n', '    function setOperatingOfficer(address _operatingOfficerAddress)\n', '        external\n', '        onlyExecutiveOfficer\n', '    {\n', '        require(_operatingOfficerAddress != address(0));\n', '        operatingOfficerAddress = _operatingOfficerAddress;\n', '    }\n', '\n', '    /// @notice Collect funds from this contract\n', '    function withdrawBalance() external onlyFinancialOfficer {\n', '        financialOfficerAddress.transfer(address(this).balance);\n', '    }\n', '}\n', '\n', '/* ERC165.sol *****************************************************************/\n', '\n', '/// @title ERC-165 Standard Interface Detection\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/* ERC721.sol *****************************************************************/\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', 'contract ERC721 is ERC165 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function approve(address _approved, uint256 _tokenId) external payable;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', 'interface ERC721TokenReceiver {\n', '\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    function name() external pure returns (string _name);\n', '    function symbol() external pure returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/* PublishInterfaces.sol ******************************************************/\n', '\n', '/// @title A reusable contract to comply with ERC-165\n', '/// @author William Entriken (https://phor.net)\n', 'contract PublishInterfaces is ERC165 {\n', '    /// @dev Every interface that we support\n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    function PublishInterfaces() internal {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '    }\n', '\n', '    /// @notice Query if a contract implements an interface\n', '    /// @param interfaceID The interface identifier, as specified in ERC-165\n', '    /// @dev Interface identification is specified in ERC-165. This function\n', '    ///  uses less than 30,000 gas.\n', '    /// @return `true` if the contract implements `interfaceID` and\n', '    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '        return supportedInterfaces[interfaceID] && (interfaceID != 0xffffffff);\n', '    }\n', '}\n', '\n', '/* SuNFT.sol ******************************************************************/\n', '\n', '/// @title Compliance with ERC-721 for Su Squares\n', '/// @dev This implementation assumes:\n', '///  - A fixed supply of NFTs, cannot mint or burn\n', '///  - ids are numbered sequentially starting at 1.\n', '///  - NFTs are initially assigned to this contract\n', '///  - This contract does not externally call its own functions\n', '/// @author William Entriken (https://phor.net)\n', 'contract SuNFT is ERC165, ERC721, ERC721Metadata, ERC721Enumerable, PublishInterfaces {\n', '    /// @dev The authorized address for each NFT\n', '    mapping (uint256 => address) internal tokenApprovals;\n', '\n', '    /// @dev The authorized operators for each address\n', '    mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '    /// @dev Guarantees msg.sender is the owner of _tokenId\n', '    /// @param _tokenId The token to validate belongs to msg.sender\n', '    modifier onlyOwnerOf(uint256 _tokenId) {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // assert(msg.sender != address(this))\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier mustBeOwnedByThisContract(uint256 _tokenId) {\n', '        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(owner == address(0) || owner == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier canOperate(uint256 _tokenId) {\n', '        // assert(msg.sender != address(this))\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(msg.sender == owner || operatorApprovals[owner][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(uint256 _tokenId) {\n', '        // assert(msg.sender != address(this))\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        require(msg.sender == owner ||\n', '          msg.sender == tokenApprovals[_tokenId] ||\n', '          operatorApprovals[msg.sender][msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier mustBeValidToken(uint256 _tokenId) {\n', '        require(_tokenId >= 1 && _tokenId <= TOTAL_SUPPLY);\n', '        _;\n', '    }\n', '\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '        return _tokensOfOwnerWithSubstitutions[_owner].length;\n', '    }\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (address _owner)\n', '    {\n', '        _owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (_owner == address(0)) {\n', '            _owner = address(this);\n', '        }\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable\n', '    {\n', '        _safeTransferFrom(_from, _to, _tokenId, data);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable\n', '    {\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId)\n', '        external\n', '        payable\n', '        mustBeValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '    {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (owner == address(0)) {\n', '            owner = address(this);\n', '        }\n', '        require(owner == _from);\n', '        require(_to != address(0));\n', '        _transfer(_tokenId, _to);\n', '    }\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    function approve(address _approved, uint256 _tokenId)\n', '        external\n', '        payable\n', '        // assert(mustBeValidToken(_tokenId))\n', '        canOperate(_tokenId)\n', '    {\n', '        address _owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (_owner == address(0)) {\n', '            _owner = address(this);\n', '        }\n', '        tokenApprovals[_tokenId] = _approved;\n', '        emit Approval(_owner, _approved, _tokenId);\n', '    }\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your asset.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        operatorApprovals[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (address)\n', '    {\n', '        return tokenApprovals[_tokenId];\n', '    }\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        return operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '    // COMPLIANCE WITH ERC721Metadata //////////////////////////////////////////\n', '\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string) {\n', '        return "Su Squares";\n', '    }\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string) {\n', '        return "SU";\n', '    }\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId)\n', '        external\n', '        view\n', '        mustBeValidToken(_tokenId)\n', '        returns (string _tokenURI)\n', '    {\n', '        _tokenURI = "https://tenthousandsu.com/erc721/00000.json";\n', '        bytes memory _tokenURIBytes = bytes(_tokenURI);\n', '        _tokenURIBytes[33] = byte(48+(_tokenId / 10000) % 10);\n', '        _tokenURIBytes[34] = byte(48+(_tokenId / 1000) % 10);\n', '        _tokenURIBytes[35] = byte(48+(_tokenId / 100) % 10);\n', '        _tokenURIBytes[36] = byte(48+(_tokenId / 10) % 10);\n', '        _tokenURIBytes[37] = byte(48+(_tokenId / 1) % 10);\n', '\n', '    }\n', '\n', '    // COMPLIANCE WITH ERC721Enumerable ////////////////////////////////////////\n', '\n', '    /// @notice Count NFTs tracked by this contract\n', '    /// @return A count of valid NFTs tracked by this contract, where each one of\n', '    ///  them has an assigned and queryable owner not equal to the zero address\n', '    function totalSupply() external view returns (uint256) {\n', '        return TOTAL_SUPPLY;\n', '    }\n', '\n', '    /// @notice Enumerate valid NFTs\n', '    /// @dev Throws if `_index` >= `totalSupply()`.\n', '    /// @param _index A counter less than `totalSupply()`\n', '    /// @return The token identifier for the `_index`th NFT,\n', '    ///  (sort order not specified)\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        require(_index < TOTAL_SUPPLY);\n', '        return _index + 1;\n', '    }\n', '\n', '    /// @notice Enumerate NFTs assigned to an owner\n', '    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '    ///  `_owner` is the zero address, representing invalid NFTs.\n', '    /// @param _owner An address where we are interested in NFTs owned by them\n', '    /// @param _index A counter less than `balanceOf(_owner)`\n', '    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '    ///   (sort order not specified)\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\n', '        require(_owner != address(0));\n', '        require(_index < _tokensOfOwnerWithSubstitutions[_owner].length);\n', '        _tokenId = _tokensOfOwnerWithSubstitutions[_owner][_index];\n', '        // Handle substitutions\n', '        if (_owner == address(this)) {\n', '            if (_tokenId == 0) {\n', '                _tokenId = _index + 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    // INTERNAL INTERFACE //////////////////////////////////////////////////////\n', '\n', '    /// @dev Actually do a transfer, does NO precondition checking\n', '    function _transfer(uint256 _tokenId, address _to) internal {\n', '        // Here are the preconditions we are not checking:\n', '        // assert(canTransfer(_tokenId))\n', '        // assert(mustBeValidToken(_tokenId))\n', '        require(_to != address(0));\n', '\n', '        // Find the FROM address\n', '        address fromWithSubstitution = _tokenOwnerWithSubstitutions[_tokenId];\n', '        address from = fromWithSubstitution;\n', '        if (fromWithSubstitution == address(0)) {\n', '            from = address(this);\n', '        }\n', '\n', '        // Take away from the FROM address\n', '        // The Entriken algorithm for deleting from an indexed, unsorted array\n', '        uint256 indexToDeleteWithSubstitution = _ownedTokensIndexWithSubstitutions[_tokenId];\n', '        uint256 indexToDelete;\n', '        if (indexToDeleteWithSubstitution == 0) {\n', '            indexToDelete = _tokenId - 1;\n', '        } else {\n', '            indexToDelete = indexToDeleteWithSubstitution - 1;\n', '        }\n', '        if (indexToDelete != _tokensOfOwnerWithSubstitutions[from].length - 1) {\n', '            uint256 lastNftWithSubstitution = _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1];\n', '            uint256 lastNft = lastNftWithSubstitution;\n', '            if (lastNftWithSubstitution == 0) {\n', '                // assert(from ==  address(0) || from == address(this));\n', '                lastNft = _tokensOfOwnerWithSubstitutions[from].length;\n', '            }\n', '            _tokensOfOwnerWithSubstitutions[from][indexToDelete] = lastNft;\n', '            _ownedTokensIndexWithSubstitutions[lastNft] = indexToDelete + 1;\n', '        }\n', '        delete _tokensOfOwnerWithSubstitutions[from][_tokensOfOwnerWithSubstitutions[from].length - 1]; // get gas back\n', '        _tokensOfOwnerWithSubstitutions[from].length--;\n', '        // Right now _ownedTokensIndexWithSubstitutions[_tokenId] is invalid, set it below based on the new owner\n', '\n', '        // Give to the TO address\n', '        _tokensOfOwnerWithSubstitutions[_to].push(_tokenId);\n', '        _ownedTokensIndexWithSubstitutions[_tokenId] = (_tokensOfOwnerWithSubstitutions[_to].length - 1) + 1;\n', '\n', '        // External processing\n', '        _tokenOwnerWithSubstitutions[_tokenId] = _to;\n', '        tokenApprovals[_tokenId] = address(0);\n', '        emit Transfer(from, _to, _tokenId);\n', '    }\n', '\n', '    // PRIVATE STORAGE AND FUNCTIONS ///////////////////////////////////////////\n', '\n', '    uint256 private constant TOTAL_SUPPLY = 10000; // SOLIDITY ISSUE #3356 make this immutable\n', '\n', '    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256("onERC721Received(address,uint256,bytes)"));\n', '\n', '    /// @dev The owner of each NFT\n', '    ///  If value == address(0), NFT is owned by address(this)\n', '    ///  If value != address(0), NFT is owned by value\n', '    ///  assert(This contract never assigns awnerhip to address(0) or destroys NFTs)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (uint256 => address) private _tokenOwnerWithSubstitutions;\n', '\n', '    /// @dev The list of NFTs owned by each address\n', '    ///  Nomenclature: this[key][index] = value\n', '    ///  If key != address(this) or value != 0, then value represents an NFT\n', '    ///  If key == address(this) and value == 0, then index + 1 is the NFT\n', '    ///  assert(0 is not a valid NFT)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (address => uint256[]) private _tokensOfOwnerWithSubstitutions;\n', '\n', "    /// @dev (Location + 1) of each NFT in its owner's list\n", '    ///  Nomenclature: this[key] = value\n', '    ///  If value != 0, _tokensOfOwnerWithSubstitutions[owner][value - 1] = nftId\n', '    ///  If value == 0, _tokensOfOwnerWithSubstitutions[owner][key - 1] = nftId\n', '    ///  assert(2**256-1 is not a valid NFT)\n', '    ///  See commented out code in constructor, saves hella gas\n', '    mapping (uint256 => uint256) private _ownedTokensIndexWithSubstitutions;\n', '\n', '    // Due to implementation choices (no mint, no burn, contiguous NFT ids), it\n', '    // is not necessary to keep an array of NFT ids nor where each NFT id is\n', '    // located in that array.\n', '    // address[] private nftIds;\n', '    // mapping (uint256 => uint256) private nftIndexOfId;\n', '\n', '    function SuNFT() internal {\n', '        // Publish interfaces with ERC-165\n', '        supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '        supportedInterfaces[0x8153916a] = true; // ERC721 + 165 (not needed)\n', '\n', '        // The effect of substitution makes storing address(this), address(this)\n', '        // ..., address(this) for a total of TOTAL_SUPPLY times unnecessary at\n', '        // deployment time\n', '        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\n', '        //     _tokenOwnerWithSubstitutions[i] = address(this);\n', '        // }\n', '\n', '        // The effect of substitution makes storing 1, 2, ..., TOTAL_SUPPLY\n', '        // unnecessary at deployment time\n', '        _tokensOfOwnerWithSubstitutions[address(this)].length = TOTAL_SUPPLY;\n', '        // for (uint256 i = 0; i < TOTAL_SUPPLY; i++) {\n', '        //     _tokensOfOwnerWithSubstitutions[address(this)][i] = i + 1;\n', '        // }\n', '        // for (uint256 i = 1; i <= TOTAL_SUPPLY; i++) {\n', '        //     _ownedTokensIndexWithSubstitutions[i] = i - 1;\n', '        // }\n', '    }\n', '\n', '    /// @dev Actually perform the safeTransferFrom\n', '    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)\n', '        private\n', '        mustBeValidToken(_tokenId)\n', '        canTransfer(_tokenId)\n', '    {\n', '        address owner = _tokenOwnerWithSubstitutions[_tokenId];\n', '        // Handle substitutions\n', '        if (owner == address(0)) {\n', '            owner = address(this);\n', '        }\n', '        require(owner == _from);\n', '        require(_to != address(0));\n', '        _transfer(_tokenId, _to);\n', '\n', '        // Do the callback after everything is done to avoid reentrancy attack\n', '        uint256 codeSize;\n', '        assembly { codeSize := extcodesize(_to) }\n', '        if (codeSize == 0) {\n', '            return;\n', '        }\n', '        bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n', '        require(retval == ERC721_RECEIVED);\n', '    }\n', '}\n', '\n', '/* SuOperation.sol ************************************************************/\n', '\n', '/// @title The features that square owners can use\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuOperation is SuNFT {\n', '    /// @dev The personalization of a square has changed\n', '    event Personalized(uint256 _nftId);\n', '\n', '    /// @dev The main SuSquare struct. The owner may set these properties, subject\n', '    ///  subject to certain rules. The actual 10x10 image is rendered on our\n', '    ///  website using this data.\n', '    struct SuSquare {\n', '        /// @dev This increments on each update\n', '        uint256 version;\n', '\n', '        /// @dev A 10x10 pixel image, stored 8-bit RGB values from left-to-right\n', '        ///  and top-to-bottom order (normal English reading order). So it is\n', '        ///  exactly 300 bytes. Or it is an empty array.\n', '        ///  So the first byte is the red channel for the top-left pixel, then\n', '        ///  the blue, then the green, and then next is the red channel for the\n', '        ///  pixel to the right of the first pixel.\n', '        bytes rgbData;\n', '\n', '        /// @dev The title of this square, at most 64 bytes,\n', '        string title;\n', '\n', '        /// @dev The URL of this square, at most 100 bytes, or empty string\n', '        string href;\n', '    }\n', '\n', '    /// @notice All the Su Squares that ever exist or will exist. Each Su Square\n', '    ///  represents a square on our webpage in a 100x100 grid. The squares are\n', '    ///  arranged in left-to-right, top-to-bottom order. In other words, normal\n', '    ///  English reading order. So suSquares[1] is the top-left location and\n', '    ///  suSquares[100] is the top-right location. And suSquares[101] is\n', '    ///  directly below suSquares[1].\n', '    /// @dev There is no suSquares[0] -- that is an unused array index.\n', '    SuSquare[10001] public suSquares;\n', '\n', '    /// @notice Update the contents of your square, the first 3 personalizations\n', '    ///  for a square are free then cost 10 finney (0.01 ether) each\n', '    /// @param _squareId The top-left is 1, to its right is 2, ..., top-right is\n', '    ///  100 and then 101 is below 1... the last one at bottom-right is 10000\n', '    /// @param _squareId A 10x10 image for your square, in 8-bit RGB words\n', "    ///  ordered like the squares are ordered. See Imagemagick's command\n", '    ///  convert -size 10x10 -depth 8 in.rgb out.png\n', '    /// @param _title A description of your square (max 64 bytes UTF-8)\n', '    /// @param _href A hyperlink for your square (max 96 bytes)\n', '    function personalizeSquare(\n', '        uint256 _squareId,\n', '        bytes _rgbData,\n', '        string _title,\n', '        string _href\n', '    )\n', '        external\n', '        onlyOwnerOf(_squareId)\n', '        payable\n', '    {\n', '        require(bytes(_title).length <= 64);\n', '        require(bytes(_href).length <= 96);\n', '        require(_rgbData.length == 300);\n', '        suSquares[_squareId].version++;\n', '        suSquares[_squareId].rgbData = _rgbData;\n', '        suSquares[_squareId].title = _title;\n', '        suSquares[_squareId].href = _href;\n', '        if (suSquares[_squareId].version > 3) {\n', '            require(msg.value == 10 finney);\n', '        }\n', '        emit Personalized(_squareId);\n', '    }\n', '}\n', '\n', '/* SuPromo.sol ****************************************************************/\n', '\n', '/// @title A limited pre-sale and promotional giveaway.\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuPromo is AccessControl, SuNFT {\n', '    uint256 constant PROMO_CREATION_LIMIT = 5000;\n', '\n', '    /// @notice How many promo squares were granted\n', '    uint256 public promoCreatedCount;\n', '\n', '    /// @notice BEWARE, this does not use a safe transfer mechanism!\n', '    ///  You must manually check the receiver can accept NFTs\n', '    function grantToken(uint256 _tokenId, address _newOwner)\n', '        external\n', '        onlyOperatingOfficer\n', '        mustBeValidToken(_tokenId)\n', '        mustBeOwnedByThisContract(_tokenId)\n', '    {\n', '        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n', '        promoCreatedCount++;\n', '        _transfer(_tokenId, _newOwner);\n', '    }\n', '}\n', '\n', '/* SuVending.sol **************************************************************/\n', '\n', '/// @title A token vending machine\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuVending is SuNFT {\n', '    uint256 constant SALE_PRICE = 500 finney; // 0.5 ether\n', '\n', '    /// @notice The price is always 0.5 ether, and you can buy any available square\n', '    ///  Be sure you are calling this from a regular account (not a smart contract)\n', '    ///  or if you are calling from a smart contract, make sure it can use\n', '    ///  ERC-721 non-fungible tokens\n', '    function purchase(uint256 _nftId)\n', '        external\n', '        payable\n', '        mustBeValidToken(_nftId)\n', '        mustBeOwnedByThisContract(_nftId)\n', '    {\n', '        require(msg.value == SALE_PRICE);\n', '        _transfer(_nftId, msg.sender);\n', '    }\n', '}\n', '\n', '/* SuMain.sol *****************************************************************/\n', '\n', '/// @title The features that deed owners can use\n', '/// @author William Entriken (https://phor.net)\n', '/// @dev See SuMain contract documentation for detail on how contracts interact.\n', 'contract SuMain is AccessControl, SuNFT, SuOperation, SuVending, SuPromo {\n', '    function SuMain() public {\n', '    }\n', '}']
