['pragma solidity ^0.4.18;\n', 'pragma solidity ^0.4.18;\n', '\n', '//It&#39;s open source,but... ;) Good luck! :P\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Beneficiary is Ownable {\n', '\n', '    address public beneficiary;\n', '\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'contract Pausable is Beneficiary{\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused {\n', '        // can&#39;t unpause if contract was upgraded\n', '        paused = false;\n', '    }\n', '} \n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract WarshipAccess is Pausable{\n', '\taddress[] public OfficialApps;\n', '\t//Official games & services\n', '\n', '\tfunction AddOfficialApps(address _app) onlyOwner public{\n', '\t\trequire(_app != address(0));\n', '\t\tOfficialApps.push(_app);\n', '\t}\n', '\t\n', '\tfunction nukeApps()onlyOwner public{\n', '\t    for(uint i = 0; i < OfficialApps.length; i++){\n', '\t\t\tdelete OfficialApps[i];\n', '\t        \n', '\t    }\n', '\t}\n', '\n', '\tfunction _isOfficialApps(address _app) internal view returns (bool){\n', '\t\tfor(uint i = 0; i < OfficialApps.length; i++){\n', '\t\t\tif( _app == OfficialApps[i] ){\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\tmodifier OnlyOfficialApps {\n', '        require(_isOfficialApps(msg.sender));\n', '        _;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '//main contract for warship\n', '\n', 'contract WarshipMain is WarshipAccess{\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    struct Warship {\n', '        uint128 appearance; //wsic code for producing warship outlook\n', '        uint32 profile;//profile including ship names\n', '        uint8 firepower;\n', '        uint8 armor;\n', '        uint8 hitrate;\n', '        uint8 speed;\n', '        uint8 duration;//ship strength\n', '        uint8 shiptype;//ship class\n', '        uint8 level;//strengthening level\n', '        uint8 status;//how it was built\n', '        uint16 specials;//16 specials\n', '        uint16 extend;\n', '    }//128+32+8*8+16*2=256\n', '\n', '    Warship[] public Ships;\n', '    mapping (uint256 => address) public ShipIdToOwner;\n', '    //Supporting 2^32 ships at most.\n', '    mapping (address => uint256) OwnerShipCount;\n', '    //Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (uint256 => address) public ShipIdToApproval;\n', '    //Each ship can only have one approved address for transfer at any time.\n', '    mapping (uint256 => uint256) public ShipIdToStatus;\n', '    //0 for sunk, 1 for live, 2 for min_broken, 3 for max_broken, 4 for on_marketing, 5 for in_pvp\n', '    //256 statuses at most.\n', '    \n', '\n', '    //SaleAuction\n', '    address public SaleAuction;\n', '    function setSaleAuction(address _sale) onlyOwner public{\n', '        require(_sale != address(0));\n', '        SaleAuction = _sale;\n', '    }\n', '\n', '\n', '\n', '    //event emitted when ship created or updated\n', '    event NewShip(address indexed owner, uint indexed shipId, uint256 wsic);\n', '    event ShipStatusUpdate(uint indexed shipId, uint8 newStatus);\n', '    event ShipStructUpdate(uint indexed shipId, uint256 wsic);\n', '\n', '    //----erc721 interface\n', '    bool public implementsERC721 = true;\n', '    string public constant name = "EtherWarship";\n', '    string public constant symbol = "SHIP";\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); \n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance){\n', '        return OwnerShipCount[_owner];\n', '    }\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner){\n', '        return ShipIdToOwner[_tokenId];\n', '    }\n', '    //function transfer(address _to, uint256 _tokenId) public;   //see below\n', '    //function approve(address _to, uint256 _tokenId) public;    //see below\n', '    //function takeOwnership(uint256 _tokenId) public;      //see below\n', '    //----erc721 interface\n', '\n', '\n', '    \n', '\n', '    //check if owned/approved\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ShipIdToOwner[_tokenId] == _claimant;\n', '    }\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ShipIdToApproval[_tokenId] == _claimant;\n', '    }\n', '\n', '\n', '    /// @dev Assigns ownership of a specific ship to an address.\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        OwnerShipCount[_to]=OwnerShipCount[_to].add(1);\n', '        ShipIdToOwner[_tokenId] = _to;\n', '        if (_from != address(0)) {\n', '            OwnerShipCount[_from]=OwnerShipCount[_from].sub(1);\n', '            // clear any previously approved ownership exchange\n', '            delete ShipIdToApproval[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        ShipIdToApproval[_tokenId] = _approved;\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '        // You can only send your own cat.\n', '        require(_owns(msg.sender, _tokenId));\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        require(ShipIdToStatus[_tokenId]==1||msg.sender==SaleAuction);\n', '        // Ship must be alive.\n', '\n', '        if(msg.sender == SaleAuction){\n', '            ShipIdToStatus[_tokenId] = 1;\n', '        }\n', '\n', '        _transfer(msg.sender, _to, _tokenId);\n', '\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Only an owner can grant transfer approval.\n', '        require(_owns(msg.sender, _tokenId));\n', '        // Register the approval (replacing any previous approval).\n', '        _approve(_tokenId, _to);\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '        // Check for approval and valid ownersh ip\n', '        //p.s. SaleAuction can call transferFrom for anyone\n', '        require(_approvedFor(msg.sender, _tokenId)||msg.sender==SaleAuction); \n', '\n', '        require(_owns(_from, _tokenId));\n', '\n', '        require(ShipIdToStatus[_tokenId]==1);\n', '        // Ship must be alive.\n', '\n', '        if(msg.sender == SaleAuction){\n', '            ShipIdToStatus[_tokenId] = 4;\n', '        }\n', '\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() public view returns (uint) {\n', '        return Ships.length;\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        // check approvals\n', '        require(ShipIdToApproval[_tokenId] == msg.sender);\n', '\n', '        require(ShipIdToStatus[_tokenId]==1);\n', '        // Ship must be alive.\n', '\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '\n', '    //------------all ERC-721 requirement are present----------------------\n', '\n', '\n', '\n', '\n', '\n', '    /// @dev uint256 WSIC to warship structure \n', '    function _translateWSIC (uint256 _wsic) internal pure returns(Warship){\n', '  //    uint128 _appearance = uint128(_wsic >> 128);\n', '  //    uint32 _profile = uint32((_wsic>>96)&0xffffffff);\n', '  //    uint8 _firepower = uint8((_wsic>>88)&0xff);\n', '        // uint8 _armor = uint8((_wsic>>80)&0xff);\n', '        // uint8 _hitrate = uint8((_wsic>>72)&0xff);\n', '        // uint8 _speed = uint8((_wsic>>64)&0xff);\n', '        // uint8 _duration = uint8((_wsic>>56)&0xff);\n', '        // uint8 _shiptype = uint8((_wsic>>48)&0xff);\n', '        // uint8 _level = uint8((_wsic>>40)&0xff);\n', '        // uint8 _status = uint8((_wsic>>32)&0xff);\n', '        // uint16 _specials = uint16((_wsic>>16)&0xffff);\n', '        // uint16 _extend = uint16(_wsic&0xffff);\n', '        Warship memory  _ship = Warship(uint128(_wsic >> 128), uint32((_wsic>>96)&0xffffffff), uint8((_wsic>>88)&0xff), uint8((_wsic>>80)&0xff), uint8((_wsic>>72)&0xff), uint8((_wsic>>64)&0xff),\n', '         uint8((_wsic>>56)&0xff), uint8((_wsic>>48)&0xff), uint8((_wsic>>40)&0xff), uint8((_wsic>>32)&0xff),  uint16((_wsic>>16)&0xffff), uint16(_wsic&0xffff));\n', '        return _ship;\n', '    }\n', '    function _encodeWSIC(Warship _ship) internal pure returns(uint256){\n', '        uint256 _wsic = 0x00;\n', '        _wsic = _wsic ^ (uint256(_ship.appearance) << 128);\n', '        _wsic = _wsic ^ (uint256(_ship.profile) << 96);\n', '        _wsic = _wsic ^ (uint256(_ship.firepower) << 88);\n', '        _wsic = _wsic ^ (uint256(_ship.armor) << 80);\n', '        _wsic = _wsic ^ (uint256(_ship.hitrate) << 72);\n', '        _wsic = _wsic ^ (uint256(_ship.speed) << 64);\n', '        _wsic = _wsic ^ (uint256(_ship.duration) << 56);\n', '        _wsic = _wsic ^ (uint256(_ship.shiptype) << 48);\n', '        _wsic = _wsic ^ (uint256(_ship.level) << 40);\n', '        _wsic = _wsic ^ (uint256(_ship.status) << 32);\n', '        _wsic = _wsic ^ (uint256(_ship.specials) << 16);\n', '        _wsic = _wsic ^ (uint256(_ship.extend));\n', '        return _wsic;\n', '    }\n', '\n', '\n', '    \n', '\n', '    // @dev An internal method that creates a new ship and stores it. This\n', '    ///  method doesn&#39;t do any checking and should only be called when the\n', '    ///  input data is known to be valid. \n', '    function _createship (uint256 _wsic, address _owner) internal returns(uint){\n', '        //wsic2ship\n', '        Warship memory _warship = _translateWSIC(_wsic);\n', '        //push into ships\n', '        uint256 newshipId = Ships.push(_warship) - 1;\n', '        //emit event\n', '        NewShip(_owner, newshipId, _wsic);\n', '        //set to alive\n', '        ShipIdToStatus[newshipId] = 1;\n', '        //transfer 0 to owner\n', '        _transfer(0, _owner, newshipId);\n', '        //"Where is the counter?Repeat that.Where is the counter?Everyone want to know it.----Troll XI"\n', '       \n', '        \n', '\n', '        return newshipId; \n', '    }\n', '\n', '    /// @dev An internal method that update a new ship. \n', '    function _update (uint256 _wsic, uint256 _tokenId) internal returns(bool){\n', '        //check if id is valid\n', '        require(_tokenId <= totalSupply());\n', '        //wsic2ship\n', '        Warship memory _warship = _translateWSIC(_wsic);\n', '        //emit event\n', '        ShipStructUpdate(_tokenId, _wsic);\n', '        //update\n', '        Ships[_tokenId] = _warship;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Allow official apps to create ship.\n', '    function createship(uint256 _wsic, address _owner) external OnlyOfficialApps returns(uint){\n', '        //check address\n', '        require(_owner != address(0));\n', '        return _createship(_wsic, _owner);\n', '    }\n', '\n', '    /// @dev Allow official apps to update ship.\n', '    function updateship (uint256 _wsic, uint256 _tokenId) external OnlyOfficialApps returns(bool){\n', '        return _update(_wsic, _tokenId);\n', '    }\n', '    /// @dev Allow official apps to update ship.\n', '    function SetStatus(uint256 _tokenId, uint256 _status) external OnlyOfficialApps returns(bool){\n', '        require(uint8(_status)==_status);\n', '        ShipIdToStatus[_tokenId] = _status;\n', '        ShipStatusUpdate(_tokenId, uint8(_status));\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '\n', '    /// @dev Get wsic code for a ship.\n', '    function Getwsic(uint256 _tokenId) external view returns(uint256){\n', '        //check if id is valid\n', '        require(_tokenId < Ships.length);\n', '        uint256 _wsic = _encodeWSIC(Ships[_tokenId]);\n', '        return _wsic;\n', '    }\n', '\n', '    /// @dev Get ships for a specified user.\n', '    function GetShipsByOwner(address _owner) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](OwnerShipCount[_owner]);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < Ships.length; i++) {\n', '          if (ShipIdToOwner[i] == _owner) {\n', '            result[counter] = i;\n', '            counter++;\n', '          }\n', '        }\n', '    return result;\n', '    }\n', '\n', '    /// @dev Get status\n', '    function GetStatus(uint256 _tokenId) external view returns(uint){\n', '        return ShipIdToStatus[_tokenId];\n', '    }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.18;\n', 'pragma solidity ^0.4.18;\n', '\n', "//It's open source,but... ;) Good luck! :P\n", '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Beneficiary is Ownable {\n', '\n', '    address public beneficiary;\n', '\n', '    function setBeneficiary(address _beneficiary) onlyOwner public {\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', 'contract Pausable is Beneficiary{\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyOwner whenNotPaused {\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused {\n', "        // can't unpause if contract was upgraded\n", '        paused = false;\n', '    }\n', '} \n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract WarshipAccess is Pausable{\n', '\taddress[] public OfficialApps;\n', '\t//Official games & services\n', '\n', '\tfunction AddOfficialApps(address _app) onlyOwner public{\n', '\t\trequire(_app != address(0));\n', '\t\tOfficialApps.push(_app);\n', '\t}\n', '\t\n', '\tfunction nukeApps()onlyOwner public{\n', '\t    for(uint i = 0; i < OfficialApps.length; i++){\n', '\t\t\tdelete OfficialApps[i];\n', '\t        \n', '\t    }\n', '\t}\n', '\n', '\tfunction _isOfficialApps(address _app) internal view returns (bool){\n', '\t\tfor(uint i = 0; i < OfficialApps.length; i++){\n', '\t\t\tif( _app == OfficialApps[i] ){\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\tmodifier OnlyOfficialApps {\n', '        require(_isOfficialApps(msg.sender));\n', '        _;\n', '    }\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', '\n', '//main contract for warship\n', '\n', 'contract WarshipMain is WarshipAccess{\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    struct Warship {\n', '        uint128 appearance; //wsic code for producing warship outlook\n', '        uint32 profile;//profile including ship names\n', '        uint8 firepower;\n', '        uint8 armor;\n', '        uint8 hitrate;\n', '        uint8 speed;\n', '        uint8 duration;//ship strength\n', '        uint8 shiptype;//ship class\n', '        uint8 level;//strengthening level\n', '        uint8 status;//how it was built\n', '        uint16 specials;//16 specials\n', '        uint16 extend;\n', '    }//128+32+8*8+16*2=256\n', '\n', '    Warship[] public Ships;\n', '    mapping (uint256 => address) public ShipIdToOwner;\n', '    //Supporting 2^32 ships at most.\n', '    mapping (address => uint256) OwnerShipCount;\n', '    //Used internally inside balanceOf() to resolve ownership count.\n', '    mapping (uint256 => address) public ShipIdToApproval;\n', '    //Each ship can only have one approved address for transfer at any time.\n', '    mapping (uint256 => uint256) public ShipIdToStatus;\n', '    //0 for sunk, 1 for live, 2 for min_broken, 3 for max_broken, 4 for on_marketing, 5 for in_pvp\n', '    //256 statuses at most.\n', '    \n', '\n', '    //SaleAuction\n', '    address public SaleAuction;\n', '    function setSaleAuction(address _sale) onlyOwner public{\n', '        require(_sale != address(0));\n', '        SaleAuction = _sale;\n', '    }\n', '\n', '\n', '\n', '    //event emitted when ship created or updated\n', '    event NewShip(address indexed owner, uint indexed shipId, uint256 wsic);\n', '    event ShipStatusUpdate(uint indexed shipId, uint8 newStatus);\n', '    event ShipStructUpdate(uint indexed shipId, uint256 wsic);\n', '\n', '    //----erc721 interface\n', '    bool public implementsERC721 = true;\n', '    string public constant name = "EtherWarship";\n', '    string public constant symbol = "SHIP";\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); \n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance){\n', '        return OwnerShipCount[_owner];\n', '    }\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner){\n', '        return ShipIdToOwner[_tokenId];\n', '    }\n', '    //function transfer(address _to, uint256 _tokenId) public;   //see below\n', '    //function approve(address _to, uint256 _tokenId) public;    //see below\n', '    //function takeOwnership(uint256 _tokenId) public;      //see below\n', '    //----erc721 interface\n', '\n', '\n', '    \n', '\n', '    //check if owned/approved\n', '    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ShipIdToOwner[_tokenId] == _claimant;\n', '    }\n', '    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '        return ShipIdToApproval[_tokenId] == _claimant;\n', '    }\n', '\n', '\n', '    /// @dev Assigns ownership of a specific ship to an address.\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        OwnerShipCount[_to]=OwnerShipCount[_to].add(1);\n', '        ShipIdToOwner[_tokenId] = _to;\n', '        if (_from != address(0)) {\n', '            OwnerShipCount[_from]=OwnerShipCount[_from].sub(1);\n', '            // clear any previously approved ownership exchange\n', '            delete ShipIdToApproval[_tokenId];\n', '        }\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n', '    ///  approval. Setting _approved to address(0) clears all transfer approval.\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        ShipIdToApproval[_tokenId] = _approved;\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transfer(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '        // You can only send your own cat.\n', '        require(_owns(msg.sender, _tokenId));\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        require(ShipIdToStatus[_tokenId]==1||msg.sender==SaleAuction);\n', '        // Ship must be alive.\n', '\n', '        if(msg.sender == SaleAuction){\n', '            ShipIdToStatus[_tokenId] = 1;\n', '        }\n', '\n', '        _transfer(msg.sender, _to, _tokenId);\n', '\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function approve(address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Only an owner can grant transfer approval.\n', '        require(_owns(msg.sender, _tokenId));\n', '        // Register the approval (replacing any previous approval).\n', '        _approve(_tokenId, _to);\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        require(_to != address(this));\n', '        // Check for approval and valid ownersh ip\n', '        //p.s. SaleAuction can call transferFrom for anyone\n', '        require(_approvedFor(msg.sender, _tokenId)||msg.sender==SaleAuction); \n', '\n', '        require(_owns(_from, _tokenId));\n', '\n', '        require(ShipIdToStatus[_tokenId]==1);\n', '        // Ship must be alive.\n', '\n', '        if(msg.sender == SaleAuction){\n', '            ShipIdToStatus[_tokenId] = 4;\n', '        }\n', '\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '    /// @dev Required for ERC-721 compliance.\n', '    function totalSupply() public view returns (uint) {\n', '        return Ships.length;\n', '    }\n', '\n', '    /// @dev Required for ERC-721 compliance.\n', '    function takeOwnership(uint256 _tokenId) public {\n', '        // check approvals\n', '        require(ShipIdToApproval[_tokenId] == msg.sender);\n', '\n', '        require(ShipIdToStatus[_tokenId]==1);\n', '        // Ship must be alive.\n', '\n', '        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\n', '    }\n', '\n', '\n', '    //------------all ERC-721 requirement are present----------------------\n', '\n', '\n', '\n', '\n', '\n', '    /// @dev uint256 WSIC to warship structure \n', '    function _translateWSIC (uint256 _wsic) internal pure returns(Warship){\n', '  //    uint128 _appearance = uint128(_wsic >> 128);\n', '  //    uint32 _profile = uint32((_wsic>>96)&0xffffffff);\n', '  //    uint8 _firepower = uint8((_wsic>>88)&0xff);\n', '        // uint8 _armor = uint8((_wsic>>80)&0xff);\n', '        // uint8 _hitrate = uint8((_wsic>>72)&0xff);\n', '        // uint8 _speed = uint8((_wsic>>64)&0xff);\n', '        // uint8 _duration = uint8((_wsic>>56)&0xff);\n', '        // uint8 _shiptype = uint8((_wsic>>48)&0xff);\n', '        // uint8 _level = uint8((_wsic>>40)&0xff);\n', '        // uint8 _status = uint8((_wsic>>32)&0xff);\n', '        // uint16 _specials = uint16((_wsic>>16)&0xffff);\n', '        // uint16 _extend = uint16(_wsic&0xffff);\n', '        Warship memory  _ship = Warship(uint128(_wsic >> 128), uint32((_wsic>>96)&0xffffffff), uint8((_wsic>>88)&0xff), uint8((_wsic>>80)&0xff), uint8((_wsic>>72)&0xff), uint8((_wsic>>64)&0xff),\n', '         uint8((_wsic>>56)&0xff), uint8((_wsic>>48)&0xff), uint8((_wsic>>40)&0xff), uint8((_wsic>>32)&0xff),  uint16((_wsic>>16)&0xffff), uint16(_wsic&0xffff));\n', '        return _ship;\n', '    }\n', '    function _encodeWSIC(Warship _ship) internal pure returns(uint256){\n', '        uint256 _wsic = 0x00;\n', '        _wsic = _wsic ^ (uint256(_ship.appearance) << 128);\n', '        _wsic = _wsic ^ (uint256(_ship.profile) << 96);\n', '        _wsic = _wsic ^ (uint256(_ship.firepower) << 88);\n', '        _wsic = _wsic ^ (uint256(_ship.armor) << 80);\n', '        _wsic = _wsic ^ (uint256(_ship.hitrate) << 72);\n', '        _wsic = _wsic ^ (uint256(_ship.speed) << 64);\n', '        _wsic = _wsic ^ (uint256(_ship.duration) << 56);\n', '        _wsic = _wsic ^ (uint256(_ship.shiptype) << 48);\n', '        _wsic = _wsic ^ (uint256(_ship.level) << 40);\n', '        _wsic = _wsic ^ (uint256(_ship.status) << 32);\n', '        _wsic = _wsic ^ (uint256(_ship.specials) << 16);\n', '        _wsic = _wsic ^ (uint256(_ship.extend));\n', '        return _wsic;\n', '    }\n', '\n', '\n', '    \n', '\n', '    // @dev An internal method that creates a new ship and stores it. This\n', "    ///  method doesn't do any checking and should only be called when the\n", '    ///  input data is known to be valid. \n', '    function _createship (uint256 _wsic, address _owner) internal returns(uint){\n', '        //wsic2ship\n', '        Warship memory _warship = _translateWSIC(_wsic);\n', '        //push into ships\n', '        uint256 newshipId = Ships.push(_warship) - 1;\n', '        //emit event\n', '        NewShip(_owner, newshipId, _wsic);\n', '        //set to alive\n', '        ShipIdToStatus[newshipId] = 1;\n', '        //transfer 0 to owner\n', '        _transfer(0, _owner, newshipId);\n', '        //"Where is the counter?Repeat that.Where is the counter?Everyone want to know it.----Troll XI"\n', '       \n', '        \n', '\n', '        return newshipId; \n', '    }\n', '\n', '    /// @dev An internal method that update a new ship. \n', '    function _update (uint256 _wsic, uint256 _tokenId) internal returns(bool){\n', '        //check if id is valid\n', '        require(_tokenId <= totalSupply());\n', '        //wsic2ship\n', '        Warship memory _warship = _translateWSIC(_wsic);\n', '        //emit event\n', '        ShipStructUpdate(_tokenId, _wsic);\n', '        //update\n', '        Ships[_tokenId] = _warship;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @dev Allow official apps to create ship.\n', '    function createship(uint256 _wsic, address _owner) external OnlyOfficialApps returns(uint){\n', '        //check address\n', '        require(_owner != address(0));\n', '        return _createship(_wsic, _owner);\n', '    }\n', '\n', '    /// @dev Allow official apps to update ship.\n', '    function updateship (uint256 _wsic, uint256 _tokenId) external OnlyOfficialApps returns(bool){\n', '        return _update(_wsic, _tokenId);\n', '    }\n', '    /// @dev Allow official apps to update ship.\n', '    function SetStatus(uint256 _tokenId, uint256 _status) external OnlyOfficialApps returns(bool){\n', '        require(uint8(_status)==_status);\n', '        ShipIdToStatus[_tokenId] = _status;\n', '        ShipStatusUpdate(_tokenId, uint8(_status));\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '\n', '    /// @dev Get wsic code for a ship.\n', '    function Getwsic(uint256 _tokenId) external view returns(uint256){\n', '        //check if id is valid\n', '        require(_tokenId < Ships.length);\n', '        uint256 _wsic = _encodeWSIC(Ships[_tokenId]);\n', '        return _wsic;\n', '    }\n', '\n', '    /// @dev Get ships for a specified user.\n', '    function GetShipsByOwner(address _owner) external view returns(uint[]) {\n', '    uint[] memory result = new uint[](OwnerShipCount[_owner]);\n', '    uint counter = 0;\n', '    for (uint i = 0; i < Ships.length; i++) {\n', '          if (ShipIdToOwner[i] == _owner) {\n', '            result[counter] = i;\n', '            counter++;\n', '          }\n', '        }\n', '    return result;\n', '    }\n', '\n', '    /// @dev Get status\n', '    function GetStatus(uint256 _tokenId) external view returns(uint){\n', '        return ShipIdToStatus[_tokenId];\n', '    }\n', '\n', '\n', '\n', '}']
