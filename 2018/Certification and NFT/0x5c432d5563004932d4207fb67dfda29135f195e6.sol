['pragma solidity ^0.4.18; // solhint-disable-line\n', '\n', 'contract FootieToken {\n', '\n', '\t/*** EVENTS ***/\n', '\n', '\t/// @dev The Birth event is fired whenever a new team comes into existence.\n', '\tevent Birth(uint256 teamId, string name, address owner);\n', '\n', '\t/// @dev Transfer event as defined in current draft of ERC721. \n', '\t///  ownership is assigned, including births.\n', '\tevent Transfer(address from, address to, uint256 teamId);\n', '\n', '\t/// @dev The TeamSold event is fired, as you might expect, whenever a team is sold.\n', '\tevent TeamSold(uint256 index, uint256 oldPrice, uint256 newPrice, address prevOwner, address newOwne, string name);\n', '\n', '\n', '\t/*** CONSTANTS ***/\n', '\n', '\t/// @notice Name and symbol of the non fungible token, as defined in ERC721.\n', '\tstring public constant NAME = "CryptoFootie"; // solhint-disable-line\n', '\tstring public constant SYMBOL = "FootieToken"; // solhint-disable-line\n', '\n', '\tuint256 private startingPrice = 0.002 ether;\n', '\tuint256 private constant TEAM_CREATION_LIMIT = 1000;\n', '\tuint256 private princeIncreasePercentage = 24;\n', '\n', '\n', '\t/*** STORAGE ***/\n', '\n', '\t/// @dev A mapping from team IDs to the address that owns them. All teams have\n', '\t///  some valid owner address.\n', '\tmapping (uint256 => address) private teamIndexToOwner;\n', '\n', '\t// @dev A mapping from the owner address to count of teams that address owns.\n', '\t//  Used internally inside balanceOf() to resolve ownership count.\n', '\tmapping (address => uint256) private ownershipTeamCount;\n', '\n', '\t/// @dev A mapping from teamIDs to an address that has been approved to call\n', '\t///  transferFrom(). Each tram can only have one approved address for transfer\n', '\t///  at any time. A zero value means no approval is outstanding.\n', '\tmapping (uint256 => address) private teamIndexToApproved;\n', '\n', '\t// @dev A mapping from teamIDs to the price of the token.\n', '\tmapping (uint256 => uint256) private teamIndexToPrice;\n', '\n', '\t// @dev A mapping from teamIDs to the price of the token.\n', '\tmapping (uint256 => uint256) private teamIndexToGoals;\n', '\n', '\t// The address of the account that can execute actions within each roles.\n', '\taddress public creatorAddress;\n', '\n', '\t// Keeps track of how many teams have been created\n', '\tuint256 public teamsCreatedCount;\n', '\n', '\n', '\t/*** DATATYPES ***/\n', '\tstruct Team {\n', '\t\tstring name;\n', '\t}\n', '\tTeam[] private teams;\n', '\n', '\n', '\t/*** ACCESS MODIFIERS ***/\n', '\t/// @dev Access modifier for Creator-only functionality\n', '\tmodifier onlyCreator() {\n', '\t\trequire(msg.sender == creatorAddress);\n', '\t\t_;\n', '\t}\n', '\n', '\n', '\t/*** CONSTRUCTOR ***/\n', '\tfunction FootieToken() public {\n', '\t\tcreatorAddress = msg.sender;\n', '\t}\n', '\n', '\tfunction _createTeam(string _name, uint256 _price) public onlyCreator {\n', '\t\trequire(teamsCreatedCount < TEAM_CREATION_LIMIT);\n', '\t\t// set initial price\n', '\t\tif (_price <= 0) {\n', '\t\t\t_price = startingPrice;\n', '\t\t}\n', '\n', '\t\t// increase the number of teams created so far\n', '\t\tteamsCreatedCount++;\n', '\n', '\t\tTeam memory _team = Team({\n', '\t\t\tname: _name\n', '\t\t});\n', '\t\tuint256 newteamId = teams.push(_team) - 1;\n', '\n', "\t\t// It's probably never going to happen, 4 billion tokens are A LOT, but\n", "\t\t// let's just be 100% sure we never let this happen.\n", '\t\trequire(newteamId == uint256(uint32(newteamId)));\n', '\n', '\t\t// send event to DAPP or anyone interested\n', '\t\tBirth(newteamId, _name, creatorAddress);\n', '\n', '\t\tteamIndexToPrice[newteamId] = _price;\n', '\n', '\t\t// This will assign ownership, and also emit the Transfer event as\n', '\t\t// per ERC721 draft\n', '\t\t_transfer(creatorAddress, creatorAddress, newteamId);\n', '\t}\n', '\n', '\t/// @notice Returns all the relevant information about a specific team.\n', '\t/// @param _index The index (teamId) of the team of interest.\n', '\tfunction getTeam(uint256 _index) public view returns (string teamName, uint256 sellingPrice, address owner, uint256 goals) {\n', '\t\tTeam storage team = teams[_index];\n', '\t\tteamName = team.name;\n', '\t\tsellingPrice = teamIndexToPrice[_index];\n', '\t\towner = teamIndexToOwner[_index];\n', '\t\tgoals = teamIndexToGoals[_index];\n', '\t}\n', '\t\n', '\t/// For querying balance of a particular account\n', '\t/// @param _owner The address for balance query\n', '\t/// @dev Required for ERC-721 compliance.\n', '\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\n', '\t\treturn ownershipTeamCount[_owner];\n', '\t}\n', '\n', '\t/// For querying owner of token\n', '\t/// @param _index The teamID for owner inquiry\n', '\t/// @dev Required for ERC-721 compliance.\n', '\tfunction ownerOf(uint256 _index) public view returns (address owner) {\n', '\t\towner = teamIndexToOwner[_index];\n', '\t\trequire(owner != address(0));\n', '\t}\n', '\n', '\t// Allows someone to send ether and buy a team\n', '\tfunction buyTeam(uint256 _index) public payable {\n', '\t\taddress oldOwner = teamIndexToOwner[_index];\n', '\t\taddress newOwner = msg.sender;\n', '\n', '\t\tuint256 sellingPrice = teamIndexToPrice[_index];\n', '\n', '\t\t// Making sure token owner is not sending to self\n', '\t\trequire(oldOwner != newOwner);\n', '\n', '\t\t// Safety check to prevent against an unexpected 0x0 default.\n', '\t\trequire(_addressNotNull(newOwner));\n', '\n', '\t\t// Making sure sent amount is greater than or equal to the sellingPrice\n', '\t\trequire(msg.value >= sellingPrice);\n', '\n', '\n', '\t\t// 96% goes to old owner\n', '\t\tuint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 96), 100));\n', '\n', '\t\t// 4% goes to the contract creator address\n', '\t\tuint256 fee = uint256(SafeMath.div(SafeMath.mul(sellingPrice, 4), 100));\n', '\t\t\n', '\t\t// any excess (the new owner payed more than needed) will be refunded to the new owner\n', '\t\tuint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);\n', '\n', '\t\t// Update price\n', '\t\tteamIndexToPrice[_index] = sellingPrice + SafeMath.div(SafeMath.mul(sellingPrice, princeIncreasePercentage), 100);\n', '\n', '\t\t//Update transaction count\n', '\t\tteamIndexToGoals[_index] = teamIndexToGoals[_index] + 1;\n', '\n', '\t\t// send the money to the previous owner\n', '\t\toldOwner.transfer(payment);\n', '\t\t// pay fee\n', '\t\tcreatorAddress.transfer(fee);\n', '\n', '\t\t// store the transfer\n', '\t\t_transfer(oldOwner, newOwner, _index);\n', '\n', '\t\tTeamSold(_index, sellingPrice, teamIndexToPrice[_index], oldOwner, newOwner, teams[_index].name);\n', '\n', '\t\tmsg.sender.transfer(purchaseExcess);\n', '\t}\n', '\n', '\n', '\n', '\t/*** PRIVATE FUNCTIONS ***/\n', '\n', '\t/// Safety check on _to address to prevent against an unexpected 0x0 default.\n', '\tfunction _addressNotNull(address _to) private pure returns (bool) {\n', '\t\treturn _to != address(0);\n', '\t}\n', '\n', '\t/// @dev Assigns ownership of a specific Person to an address.\n', '\tfunction _transfer(address _from, address _to, uint256 _index) private {\n', "\t\t// Since the number of persons is capped to 2^32 we can't overflow this\n", '\t\townershipTeamCount[_to]++;\n', '\t\t//transfer ownership\n', '\t\tteamIndexToOwner[_index] = _to;\n', '\n', '\t\t// Emit the transfer event.\n', '\t\tTransfer(_from, _to, _index);\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t* @dev Multiplies two numbers, throws on overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Integer division of two numbers, truncating the quotient.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Adds two numbers, throws on overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\treturn c;\n', '\t}\n', '}']