['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Token {\n', '    function balanceOf(address _owner) public constant returns (uint256);\n', '}\n', '\n', 'contract FactoryData is Ownable {\n', '    using SafeMath for uint256;\n', '    struct CP {\n', '        string refNumber;\n', '        string name;\n', '        mapping(address => bool) factories;\n', '    }\n', '\n', '    uint256 blocksquareFee = 20;\n', '    uint256 networkReserveFundFee = 50;\n', '    uint256 cpFee = 15;\n', '    uint256 firstBuyersFee = 15;\n', '\n', '    /* Mappings */\n', '    mapping(address => mapping(address => bool)) whitelisted;\n', '    mapping(string => address) countryFactory;\n', '    mapping(address => bool) memberOfBS;\n', '    mapping(address => uint256) requiredBST;\n', '    mapping(address => CP) CPs;\n', '    mapping(address => address) noFeeTransfersAccounts;\n', '    mapping(address => bool) prestigeAddress;\n', '    Token BST;\n', '\n', '    /**\n', '    * Constructor function\n', '    *\n', '    * Initializes contract.\n', '    **/\n', '    constructor() public {\n', '        memberOfBS[msg.sender] = true;\n', '        owner = msg.sender;\n', '        BST = Token(0x509A38b7a1cC0dcd83Aa9d06214663D9eC7c7F4a);\n', '    }\n', '\n', '    /**\n', '    * Add factory\n', '    *\n', '    * Owner can add factory for country\n', '    *\n', '    * @param _country Name of country\n', '    * @param _factory Address of factory\n', '    **/\n', '    function addFactory(string _country, address _factory) public onlyOwner {\n', '        countryFactory[_country] = _factory;\n', '    }\n', '\n', '    /**\n', '    * @dev add member to blocksquare group\n', '    * @param _member Address of member to add\n', '    **/\n', '    function addMemberToBS(address _member) public onlyOwner {\n', '        memberOfBS[_member] = true;\n', '    }\n', '\n', '    /**\n', '    * @dev add new certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _refNumber Reference number of certified partner\n', '    * @param _name Name of certified partner\n', '    **/\n', '    function createCP(address _cp, string _refNumber, string _name) public onlyOwner {\n', '        CP memory cp = CP(_refNumber, _name);\n', '        CPs[_cp] = cp;\n', '    }\n', '\n', '    /**\n', '    * @dev add allowance to create buildings in country to certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    **/\n', '    function addFactoryToCP(address _cp, address _factory) public onlyOwner {\n', '        CP storage cp = CPs[_cp];\n', '        cp.factories[_factory] = true;\n', '    }\n', '\n', '    /**\n', '    * @dev remove allowance to create buildings in country from certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    **/\n', '    function removeCP(address _cp, address _factory) public onlyOwner {\n', '        CP storage cp = CPs[_cp];\n', '        cp.factories[_factory] = false;\n', '    }\n', '\n', '    /**\n', '    * @dev connect two addresses so that they can send BSPT without fee\n', '    * @param _from First address\n', '    * @param _to Second address\n', '    **/\n', '    function addNoFeeAddress(address[] _from, address[] _to) public onlyOwner {\n', '        require(_from.length == _to.length);\n', '        for (uint256 i = 0; i < _from.length; i++) {\n', '            noFeeTransfersAccounts[_from[i]] = _to[i];\n', '            noFeeTransfersAccounts[_to[i]] = _from[i];\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev change BTS requirement for buying BSPT\n', '    * @param _factory Address of factory\n', '    * @param _amount Amount of required tokens\n', '    **/\n', '    function changeBSTRequirement(address _factory, uint256 _amount) public onlyOwner {\n', '        requiredBST[_factory] = _amount * 10 ** 18;\n', '    }\n', '\n', '    /**\n', '    * @dev add addresses to whitelist for factory\n', '    * @param _factory Address of factory\n', '    * @param _addresses Array of addresses to whitelist\n', '    **/\n', '    function addToWhitelist(address _factory, address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelisted[_factory][_addresses[i]] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev remove address from whitelist\n', '    * @param _factory Address of factory\n', '    * @param _user Address of user\n', '    **/\n', '    function removeFromWhitelist(address _factory, address _user) public onlyOwner {\n', '        whitelisted[_factory][_user] = false;\n', '    }\n', '\n', '    function changeFees(uint256 _network, uint256 _blocksquare, uint256 _cp, uint256 _firstBuyers) public onlyOwner {\n', '        require(_network.add(_blocksquare).add(_cp).add(_firstBuyers) == 100);\n', '        blocksquareFee = _network;\n', '        networkReserveFundFee = _blocksquare;\n', '        cpFee = _cp;\n', '        firstBuyersFee = _firstBuyers;\n', '    }\n', '\n', '    function changePrestige(address _owner) public onlyOwner {\n', '        prestigeAddress[_owner] = !prestigeAddress[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address is whitelisted for factory\n', '    * @param _factory Address of factory\n', '    * @param _user Address of user\n', '    * @return True if user is whitelisted for given factory, false instead\n', '    **/\n', '    function isWhitelisted(address _factory, address _user) public constant returns (bool) {\n', '        return whitelisted[_factory][_user];\n', '    }\n', '\n', '    /**\n', '    * @dev get factory address for given country\n', '    * @param _country Name of country\n', '    * @return Address of factory\n', '    **/\n', '    function getFactoryForCountry(string _country) public constant returns (address) {\n', '        return countryFactory[_country];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address is member of Blocksquare\n', '    * @param _member Address of member\n', '    * @return True if member is member of Blocksquare, false instead\n', '    **/\n', '    function isBS(address _member) public constant returns (bool) {\n', '        return memberOfBS[_member];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address has enough BST to buy BSPT\n', '    * @param _factory Address of factory\n', '    * @param _address Address of BST owner\n', '    * @return True if address has enough BST, false instead\n', '    **/\n', '    function hasEnoughBST(address _factory, address _address) constant public returns (bool) {\n', '        return BST.balanceOf(_address) >= requiredBST[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev amount of BST required to buy BSPT\n', '    * @param _factory Address of factory\n', '    * @return Amount of BST required\n', '    **/\n', '    function amountOfBSTRequired(address _factory) constant public returns (uint256) {\n', '        return requiredBST[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev check if certified partner can create new building in factory\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    * @return True if certified partner can create buildings, false instead\n', '    **/\n', '    function canCPCreateInFactory(address _cp, address _factory) constant public returns (bool) {\n', '        return CPs[_cp].factories[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev get info about certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @return Certified partner&#39;s reference number and name\n', '    **/\n', '    function getCP(address _cp) constant public returns (string, string) {\n', '        return (CPs[_cp].refNumber, CPs[_cp].name);\n', '    }\n', '\n', '    /**\n', '    * @dev check if two address can send BSPT without fee;\n', '    * @param _from From address\n', '    * @param _to To address\n', '    * @return True if addresses can send BSPT without fee between them, false instead\n', '    **/\n', '    function canMakeNoFeeTransfer(address _from, address _to) constant public returns (bool) {\n', '        return noFeeTransfersAccounts[_from] == _to;\n', '    }\n', '\n', '    function getNetworkFee() public constant returns (uint256) {\n', '        return networkReserveFundFee;\n', '    }\n', '\n', '    function getBlocksquareFee() public constant returns (uint256) {\n', '        return blocksquareFee;\n', '    }\n', '\n', '    function getCPFee() public constant returns (uint256) {\n', '        return cpFee;\n', '    }\n', '\n', '    function getFirstBuyersFee() public constant returns (uint256) {\n', '        return firstBuyersFee;\n', '    }\n', '\n', '    function hasPrestige(address _owner) public constant returns(bool) {\n', '        return prestigeAddress[_owner];\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract Token {\n', '    function balanceOf(address _owner) public constant returns (uint256);\n', '}\n', '\n', 'contract FactoryData is Ownable {\n', '    using SafeMath for uint256;\n', '    struct CP {\n', '        string refNumber;\n', '        string name;\n', '        mapping(address => bool) factories;\n', '    }\n', '\n', '    uint256 blocksquareFee = 20;\n', '    uint256 networkReserveFundFee = 50;\n', '    uint256 cpFee = 15;\n', '    uint256 firstBuyersFee = 15;\n', '\n', '    /* Mappings */\n', '    mapping(address => mapping(address => bool)) whitelisted;\n', '    mapping(string => address) countryFactory;\n', '    mapping(address => bool) memberOfBS;\n', '    mapping(address => uint256) requiredBST;\n', '    mapping(address => CP) CPs;\n', '    mapping(address => address) noFeeTransfersAccounts;\n', '    mapping(address => bool) prestigeAddress;\n', '    Token BST;\n', '\n', '    /**\n', '    * Constructor function\n', '    *\n', '    * Initializes contract.\n', '    **/\n', '    constructor() public {\n', '        memberOfBS[msg.sender] = true;\n', '        owner = msg.sender;\n', '        BST = Token(0x509A38b7a1cC0dcd83Aa9d06214663D9eC7c7F4a);\n', '    }\n', '\n', '    /**\n', '    * Add factory\n', '    *\n', '    * Owner can add factory for country\n', '    *\n', '    * @param _country Name of country\n', '    * @param _factory Address of factory\n', '    **/\n', '    function addFactory(string _country, address _factory) public onlyOwner {\n', '        countryFactory[_country] = _factory;\n', '    }\n', '\n', '    /**\n', '    * @dev add member to blocksquare group\n', '    * @param _member Address of member to add\n', '    **/\n', '    function addMemberToBS(address _member) public onlyOwner {\n', '        memberOfBS[_member] = true;\n', '    }\n', '\n', '    /**\n', '    * @dev add new certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _refNumber Reference number of certified partner\n', '    * @param _name Name of certified partner\n', '    **/\n', '    function createCP(address _cp, string _refNumber, string _name) public onlyOwner {\n', '        CP memory cp = CP(_refNumber, _name);\n', '        CPs[_cp] = cp;\n', '    }\n', '\n', '    /**\n', '    * @dev add allowance to create buildings in country to certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    **/\n', '    function addFactoryToCP(address _cp, address _factory) public onlyOwner {\n', '        CP storage cp = CPs[_cp];\n', '        cp.factories[_factory] = true;\n', '    }\n', '\n', '    /**\n', '    * @dev remove allowance to create buildings in country from certified partner\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    **/\n', '    function removeCP(address _cp, address _factory) public onlyOwner {\n', '        CP storage cp = CPs[_cp];\n', '        cp.factories[_factory] = false;\n', '    }\n', '\n', '    /**\n', '    * @dev connect two addresses so that they can send BSPT without fee\n', '    * @param _from First address\n', '    * @param _to Second address\n', '    **/\n', '    function addNoFeeAddress(address[] _from, address[] _to) public onlyOwner {\n', '        require(_from.length == _to.length);\n', '        for (uint256 i = 0; i < _from.length; i++) {\n', '            noFeeTransfersAccounts[_from[i]] = _to[i];\n', '            noFeeTransfersAccounts[_to[i]] = _from[i];\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev change BTS requirement for buying BSPT\n', '    * @param _factory Address of factory\n', '    * @param _amount Amount of required tokens\n', '    **/\n', '    function changeBSTRequirement(address _factory, uint256 _amount) public onlyOwner {\n', '        requiredBST[_factory] = _amount * 10 ** 18;\n', '    }\n', '\n', '    /**\n', '    * @dev add addresses to whitelist for factory\n', '    * @param _factory Address of factory\n', '    * @param _addresses Array of addresses to whitelist\n', '    **/\n', '    function addToWhitelist(address _factory, address[] _addresses) public onlyOwner {\n', '        for (uint256 i = 0; i < _addresses.length; i++) {\n', '            whitelisted[_factory][_addresses[i]] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev remove address from whitelist\n', '    * @param _factory Address of factory\n', '    * @param _user Address of user\n', '    **/\n', '    function removeFromWhitelist(address _factory, address _user) public onlyOwner {\n', '        whitelisted[_factory][_user] = false;\n', '    }\n', '\n', '    function changeFees(uint256 _network, uint256 _blocksquare, uint256 _cp, uint256 _firstBuyers) public onlyOwner {\n', '        require(_network.add(_blocksquare).add(_cp).add(_firstBuyers) == 100);\n', '        blocksquareFee = _network;\n', '        networkReserveFundFee = _blocksquare;\n', '        cpFee = _cp;\n', '        firstBuyersFee = _firstBuyers;\n', '    }\n', '\n', '    function changePrestige(address _owner) public onlyOwner {\n', '        prestigeAddress[_owner] = !prestigeAddress[_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address is whitelisted for factory\n', '    * @param _factory Address of factory\n', '    * @param _user Address of user\n', '    * @return True if user is whitelisted for given factory, false instead\n', '    **/\n', '    function isWhitelisted(address _factory, address _user) public constant returns (bool) {\n', '        return whitelisted[_factory][_user];\n', '    }\n', '\n', '    /**\n', '    * @dev get factory address for given country\n', '    * @param _country Name of country\n', '    * @return Address of factory\n', '    **/\n', '    function getFactoryForCountry(string _country) public constant returns (address) {\n', '        return countryFactory[_country];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address is member of Blocksquare\n', '    * @param _member Address of member\n', '    * @return True if member is member of Blocksquare, false instead\n', '    **/\n', '    function isBS(address _member) public constant returns (bool) {\n', '        return memberOfBS[_member];\n', '    }\n', '\n', '    /**\n', '    * @dev check if address has enough BST to buy BSPT\n', '    * @param _factory Address of factory\n', '    * @param _address Address of BST owner\n', '    * @return True if address has enough BST, false instead\n', '    **/\n', '    function hasEnoughBST(address _factory, address _address) constant public returns (bool) {\n', '        return BST.balanceOf(_address) >= requiredBST[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev amount of BST required to buy BSPT\n', '    * @param _factory Address of factory\n', '    * @return Amount of BST required\n', '    **/\n', '    function amountOfBSTRequired(address _factory) constant public returns (uint256) {\n', '        return requiredBST[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev check if certified partner can create new building in factory\n', '    * @param _cp Wallet address of certified partner\n', '    * @param _factory Factory address\n', '    * @return True if certified partner can create buildings, false instead\n', '    **/\n', '    function canCPCreateInFactory(address _cp, address _factory) constant public returns (bool) {\n', '        return CPs[_cp].factories[_factory];\n', '    }\n', '\n', '    /**\n', '    * @dev get info about certified partner\n', '    * @param _cp Wallet address of certified partner\n', "    * @return Certified partner's reference number and name\n", '    **/\n', '    function getCP(address _cp) constant public returns (string, string) {\n', '        return (CPs[_cp].refNumber, CPs[_cp].name);\n', '    }\n', '\n', '    /**\n', '    * @dev check if two address can send BSPT without fee;\n', '    * @param _from From address\n', '    * @param _to To address\n', '    * @return True if addresses can send BSPT without fee between them, false instead\n', '    **/\n', '    function canMakeNoFeeTransfer(address _from, address _to) constant public returns (bool) {\n', '        return noFeeTransfersAccounts[_from] == _to;\n', '    }\n', '\n', '    function getNetworkFee() public constant returns (uint256) {\n', '        return networkReserveFundFee;\n', '    }\n', '\n', '    function getBlocksquareFee() public constant returns (uint256) {\n', '        return blocksquareFee;\n', '    }\n', '\n', '    function getCPFee() public constant returns (uint256) {\n', '        return cpFee;\n', '    }\n', '\n', '    function getFirstBuyersFee() public constant returns (uint256) {\n', '        return firstBuyersFee;\n', '    }\n', '\n', '    function hasPrestige(address _owner) public constant returns(bool) {\n', '        return prestigeAddress[_owner];\n', '    }\n', '}']
