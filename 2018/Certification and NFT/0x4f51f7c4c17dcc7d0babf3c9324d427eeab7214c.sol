['pragma solidity ^0.4.18;\n', '\n', '//\n', '// EtherPiggyBank\n', '// (etherpiggybank.com)\n', '//        \n', '//   <`--&#39;\\>______\n', '//   /. .  `&#39;     \\\n', '//  (`&#39;)  ,        @\n', '//   `-._,        /\n', '//      )-)_/--( >  \n', '//     &#39;&#39;&#39;&#39;  &#39;&#39;&#39;&#39;\n', '//\n', '// Invest Ethereum into a long term stable solution where\n', '// your investment can grow organically as the system expands.\n', '// You will gain +1.5% of your invested Ethereum every day that\n', '// you leave it in the Ether Piggy Bank!\n', '// You can withdraw your investments at any time but it will\n', '// incur a 20% withdrawal fee (~13 days of investing).\n', '// You can also invest your profits back into your account and\n', '// your gains will compound the more you do this!\n', '// \n', '// Big players can compete for the investment positions available,\n', '// every time someone makes a deposit into the Ether Piggy Bank,\n', '// they will receive a percentage of that sale in their\n', '// affiliate commision.\n', '// You can buy this position off anyone and double it&#39;s current\n', '// buying price but every 3-7 days (depending on the position),\n', '// the buying price will halve until it reaches 0.125 ether.\n', '// Upon buying, the previous investor gets 75% of the buying price,\n', '// the dev gets 5% and the rest goes into the contract to encourage\n', '// an all round balanced ecosystem!\n', '//\n', '// You will also receive a 5% bonus, which will appear in your\n', '// affiliate commission, by referring another player to the game \n', '// via your referral URL! It&#39;s a HYIP on a smart contract, fully\n', '// transparent and you&#39;ll never need to worry about an exit scam or\n', '// someone taking all the money and leaving!\n', '\n', '\n', 'contract EtherPiggyBank {\n', '    \n', '    // investment tracking for each address\n', '    mapping (address => uint256) public investedETH;\n', '    mapping (address => uint256) public lastInvest;\n', '    \n', '    // for referrals and investor positions\n', '    mapping (address => uint256) public affiliateCommision;\n', '    uint256 REF_BONUS = 4; // 4% of the ether invested\n', '    // goes into the ref address&#39; affiliate commision\n', '    uint256 DEV_TAX = 1; // 1% of all ether invested\n', '    // goes into the dev address&#39; affiliate commision\n', '    \n', '    uint256 BASE_PRICE = 0.125 ether; // 1/8 ether\n', '    uint256 INHERITANCE_TAX = 75; // 75% will be returned to the\n', '    // investor if their position is purchased, the rest will\n', '    // go to the contract and the dev\n', '    uint256 DEV_TRANSFER_TAX = 5;\n', '    // this means that when purchased the sale will be distrubuted:\n', '    // 75% to the old position owner\n', '    // 5% to the dev\n', '    // and 20% to the contract for all the other investors\n', '    // ^ this will encourage a healthy ecosystem\n', '    struct InvestorPosition {\n', '        address investor;\n', '        uint256 startingLevel;\n', '        uint256 startingTime;\n', '        uint256 halfLife;\n', '        uint256 percentageCut;\n', '    }\n', '\n', '    InvestorPosition[] investorPositions; \n', '    address public dev;\n', '\n', '    // start up the contract!\n', '    function EtherPiggyBank() public {\n', '        \n', '        // set the dev address\n', '        dev = msg.sender;\n', '        \n', '        // make the gold level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: dev,\n', '            startingLevel: 5, // 1/8 ether * 2^5 = 4 ether\n', '            startingTime: now,\n', '            halfLife: 7 days, // 7 days until the level decreases\n', '            percentageCut: 5 // with 5% cut of all investments\n', '            }));\n', '\n', '        // make the silver level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: 0x6c0cf053076681cecbe31e5e19df8fb97deb5756,\n', '            startingLevel: 4, // 1/8 ether * 2^4 = 2 ether\n', '            startingTime: now,\n', '            halfLife: 5 days, // 5 days until the level decreases\n', '            percentageCut: 3 // with 3% cut of all investments\n', '            }));\n', '\n', '        // make the bronze level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: 0x66fe910c6a556173ea664a94f334d005ddc9ce9e,\n', '            startingLevel: 3, // 1/8 ether * 2^3 = 1 ether\n', '            startingTime: now,\n', '            halfLife: 3 days, // 3 days until the level decreases\n', '            percentageCut: 1 // with 1% cut of all investments\n', '            }));\n', '    }\n', '    \n', '    function investETH(address referral) public payable {\n', '        \n', '        require(msg.value >= 0.01 ether);\n', '        \n', '        if (getProfit(msg.sender) > 0) {\n', '            uint256 profit = getProfit(msg.sender);\n', '            lastInvest[msg.sender] = now;\n', '            msg.sender.transfer(profit);\n', '        }\n', '        \n', '        uint256 amount = msg.value;\n', '\n', '        // handle all of our investor positions first\n', '        bool flaggedRef = (referral == msg.sender || referral == dev); // ref cannot be the sender or the dev\n', '        for(uint256 i = 0; i < investorPositions.length; i++) {\n', '            \n', '            InvestorPosition memory position = investorPositions[i];\n', '\n', '            // check that our ref isn&#39;t an investor too\n', '            if (position.investor == referral) {\n', '                flaggedRef = true;\n', '            }\n', '            \n', '            // we cannot claim on our own investments\n', '            if (position.investor != msg.sender) {\n', '                uint256 commision = SafeMath.div(SafeMath.mul(amount, position.percentageCut), 100);\n', '                affiliateCommision[position.investor] = SafeMath.add(affiliateCommision[position.investor], commision);\n', '            }\n', '\n', '        }\n', '\n', '        // now for the referral (if we have one)\n', '        if (!flaggedRef && referral != 0x0) {\n', '            uint256 refBonus = SafeMath.div(SafeMath.mul(amount, REF_BONUS), 100); // 4%\n', '            affiliateCommision[referral] = SafeMath.add(affiliateCommision[referral], refBonus);\n', '        }\n', '        \n', '        // hand out the dev tax\n', '        uint256 devTax = SafeMath.div(SafeMath.mul(amount, DEV_TAX), 100); // 1%\n', '        affiliateCommision[dev] = SafeMath.add(affiliateCommision[dev], devTax);\n', '\n', '        \n', '        // now put it in your own piggy bank!\n', '        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], amount);\n', '        lastInvest[msg.sender] = now;\n', '\n', '    }\n', '    \n', '    function divestETH() public {\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '        \n', '        // 20% fee on taking capital out\n', '        uint256 capital = investedETH[msg.sender];\n', '        uint256 fee = SafeMath.div(capital, 5);\n', '        capital = SafeMath.sub(capital, fee);\n', '        \n', '        uint256 total = SafeMath.add(capital, profit);\n', '\n', '        require(total > 0);\n', '        investedETH[msg.sender] = 0;\n', '        lastInvest[msg.sender] = now;\n', '        msg.sender.transfer(total);\n', '\n', '    }\n', '    \n', '    function withdraw() public{\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '\n', '        require(profit > 0);\n', '        lastInvest[msg.sender] = now;\n', '        msg.sender.transfer(profit);\n', '\n', '    }\n', '\n', '    function withdrawAffiliateCommision() public {\n', '\n', '        require(affiliateCommision[msg.sender] > 0);\n', '        uint256 commision = affiliateCommision[msg.sender];\n', '        affiliateCommision[msg.sender] = 0;\n', '        msg.sender.transfer(commision);\n', '\n', '    }\n', '    \n', '    function reinvestProfit() public {\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '\n', '        require(profit > 0);\n', '        lastInvest[msg.sender] = now;\n', '        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], profit);\n', '\n', '    }\n', '\n', '    function inheritInvestorPosition(uint256 index) public payable {\n', '\n', '        require(investorPositions.length > index);\n', '        require(msg.sender == tx.origin);\n', '\n', '        InvestorPosition storage position = investorPositions[index];\n', '        uint256 currentLevel = getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife);\n', '        uint256 currentPrice = getCurrentPrice(currentLevel);\n', '\n', '        require(msg.value >= currentPrice);\n', '        uint256 purchaseExcess = SafeMath.sub(msg.value, currentPrice);\n', '        position.startingLevel = currentLevel + 1;\n', '        position.startingTime = now;\n', '\n', '        // now do the transfers\n', '        uint256 inheritanceTax = SafeMath.div(SafeMath.mul(currentPrice, INHERITANCE_TAX), 100); // 75%\n', '        position.investor.transfer(inheritanceTax);\n', '        position.investor = msg.sender; // set the new investor address\n', '\n', '        // now the dev transfer tax\n', '        uint256 devTransferTax = SafeMath.div(SafeMath.mul(currentPrice, DEV_TRANSFER_TAX), 100); // 5%\n', '        dev.transfer(devTransferTax);\n', '\n', '        // and finally the excess\n', '        msg.sender.transfer(purchaseExcess);\n', '\n', '        // after this point there will be 20% of currentPrice left in the contract\n', '        // this will be automatically go towards paying for profits and withdrawals\n', '\n', '    }\n', '\n', '    function getInvestorPosition(uint256 index) public view returns(address investor, uint256 currentPrice, uint256 halfLife, uint256 percentageCut) {\n', '        InvestorPosition memory position = investorPositions[index];\n', '        return (position.investor, getCurrentPrice(getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife)), position.halfLife, position.percentageCut);\n', '    }\n', '\n', '    function getCurrentPrice(uint256 currentLevel) internal view returns(uint256) {\n', '        return BASE_PRICE * 2**currentLevel; // ** is exponent, price doubles every level\n', '    }\n', '\n', '    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) internal view returns(uint256) {\n', '        uint256 timePassed = SafeMath.sub(now, startingTime);\n', '        uint256 levelsPassed = SafeMath.div(timePassed, halfLife);\n', '        if (startingLevel < levelsPassed) {\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(startingLevel,levelsPassed);\n', '    }\n', '\n', '    function getProfitFromSender() public view returns(uint256){\n', '        return getProfit(msg.sender);\n', '    }\n', '\n', '    function getProfit(address customer) public view returns(uint256){\n', '        uint256 secondsPassed = SafeMath.sub(now, lastInvest[customer]);\n', '        return SafeMath.div(SafeMath.mul(secondsPassed, investedETH[customer]), 5760000); // = days * amount * 0.015 (+1.5% per day)\n', '    }\n', '    \n', '    function getAffiliateCommision() public view returns(uint256){\n', '        return affiliateCommision[msg.sender];\n', '    }\n', '    \n', '    function getInvested() public view returns(uint256){\n', '        return investedETH[msg.sender];\n', '    }\n', '    \n', '    function getBalance() public view returns(uint256){\n', '        return this.balance;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '//\n', '// EtherPiggyBank\n', '// (etherpiggybank.com)\n', '//        \n', "//   <`--'\\>______\n", "//   /. .  `'     \\\n", "//  (`')  ,        @\n", '//   `-._,        /\n', '//      )-)_/--( >  \n', "//     ''''  ''''\n", '//\n', '// Invest Ethereum into a long term stable solution where\n', '// your investment can grow organically as the system expands.\n', '// You will gain +1.5% of your invested Ethereum every day that\n', '// you leave it in the Ether Piggy Bank!\n', '// You can withdraw your investments at any time but it will\n', '// incur a 20% withdrawal fee (~13 days of investing).\n', '// You can also invest your profits back into your account and\n', '// your gains will compound the more you do this!\n', '// \n', '// Big players can compete for the investment positions available,\n', '// every time someone makes a deposit into the Ether Piggy Bank,\n', '// they will receive a percentage of that sale in their\n', '// affiliate commision.\n', "// You can buy this position off anyone and double it's current\n", '// buying price but every 3-7 days (depending on the position),\n', '// the buying price will halve until it reaches 0.125 ether.\n', '// Upon buying, the previous investor gets 75% of the buying price,\n', '// the dev gets 5% and the rest goes into the contract to encourage\n', '// an all round balanced ecosystem!\n', '//\n', '// You will also receive a 5% bonus, which will appear in your\n', '// affiliate commission, by referring another player to the game \n', "// via your referral URL! It's a HYIP on a smart contract, fully\n", "// transparent and you'll never need to worry about an exit scam or\n", '// someone taking all the money and leaving!\n', '\n', '\n', 'contract EtherPiggyBank {\n', '    \n', '    // investment tracking for each address\n', '    mapping (address => uint256) public investedETH;\n', '    mapping (address => uint256) public lastInvest;\n', '    \n', '    // for referrals and investor positions\n', '    mapping (address => uint256) public affiliateCommision;\n', '    uint256 REF_BONUS = 4; // 4% of the ether invested\n', "    // goes into the ref address' affiliate commision\n", '    uint256 DEV_TAX = 1; // 1% of all ether invested\n', "    // goes into the dev address' affiliate commision\n", '    \n', '    uint256 BASE_PRICE = 0.125 ether; // 1/8 ether\n', '    uint256 INHERITANCE_TAX = 75; // 75% will be returned to the\n', '    // investor if their position is purchased, the rest will\n', '    // go to the contract and the dev\n', '    uint256 DEV_TRANSFER_TAX = 5;\n', '    // this means that when purchased the sale will be distrubuted:\n', '    // 75% to the old position owner\n', '    // 5% to the dev\n', '    // and 20% to the contract for all the other investors\n', '    // ^ this will encourage a healthy ecosystem\n', '    struct InvestorPosition {\n', '        address investor;\n', '        uint256 startingLevel;\n', '        uint256 startingTime;\n', '        uint256 halfLife;\n', '        uint256 percentageCut;\n', '    }\n', '\n', '    InvestorPosition[] investorPositions; \n', '    address public dev;\n', '\n', '    // start up the contract!\n', '    function EtherPiggyBank() public {\n', '        \n', '        // set the dev address\n', '        dev = msg.sender;\n', '        \n', '        // make the gold level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: dev,\n', '            startingLevel: 5, // 1/8 ether * 2^5 = 4 ether\n', '            startingTime: now,\n', '            halfLife: 7 days, // 7 days until the level decreases\n', '            percentageCut: 5 // with 5% cut of all investments\n', '            }));\n', '\n', '        // make the silver level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: 0x6c0cf053076681cecbe31e5e19df8fb97deb5756,\n', '            startingLevel: 4, // 1/8 ether * 2^4 = 2 ether\n', '            startingTime: now,\n', '            halfLife: 5 days, // 5 days until the level decreases\n', '            percentageCut: 3 // with 3% cut of all investments\n', '            }));\n', '\n', '        // make the bronze level investor\n', '        investorPositions.push(InvestorPosition({\n', '            investor: 0x66fe910c6a556173ea664a94f334d005ddc9ce9e,\n', '            startingLevel: 3, // 1/8 ether * 2^3 = 1 ether\n', '            startingTime: now,\n', '            halfLife: 3 days, // 3 days until the level decreases\n', '            percentageCut: 1 // with 1% cut of all investments\n', '            }));\n', '    }\n', '    \n', '    function investETH(address referral) public payable {\n', '        \n', '        require(msg.value >= 0.01 ether);\n', '        \n', '        if (getProfit(msg.sender) > 0) {\n', '            uint256 profit = getProfit(msg.sender);\n', '            lastInvest[msg.sender] = now;\n', '            msg.sender.transfer(profit);\n', '        }\n', '        \n', '        uint256 amount = msg.value;\n', '\n', '        // handle all of our investor positions first\n', '        bool flaggedRef = (referral == msg.sender || referral == dev); // ref cannot be the sender or the dev\n', '        for(uint256 i = 0; i < investorPositions.length; i++) {\n', '            \n', '            InvestorPosition memory position = investorPositions[i];\n', '\n', "            // check that our ref isn't an investor too\n", '            if (position.investor == referral) {\n', '                flaggedRef = true;\n', '            }\n', '            \n', '            // we cannot claim on our own investments\n', '            if (position.investor != msg.sender) {\n', '                uint256 commision = SafeMath.div(SafeMath.mul(amount, position.percentageCut), 100);\n', '                affiliateCommision[position.investor] = SafeMath.add(affiliateCommision[position.investor], commision);\n', '            }\n', '\n', '        }\n', '\n', '        // now for the referral (if we have one)\n', '        if (!flaggedRef && referral != 0x0) {\n', '            uint256 refBonus = SafeMath.div(SafeMath.mul(amount, REF_BONUS), 100); // 4%\n', '            affiliateCommision[referral] = SafeMath.add(affiliateCommision[referral], refBonus);\n', '        }\n', '        \n', '        // hand out the dev tax\n', '        uint256 devTax = SafeMath.div(SafeMath.mul(amount, DEV_TAX), 100); // 1%\n', '        affiliateCommision[dev] = SafeMath.add(affiliateCommision[dev], devTax);\n', '\n', '        \n', '        // now put it in your own piggy bank!\n', '        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], amount);\n', '        lastInvest[msg.sender] = now;\n', '\n', '    }\n', '    \n', '    function divestETH() public {\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '        \n', '        // 20% fee on taking capital out\n', '        uint256 capital = investedETH[msg.sender];\n', '        uint256 fee = SafeMath.div(capital, 5);\n', '        capital = SafeMath.sub(capital, fee);\n', '        \n', '        uint256 total = SafeMath.add(capital, profit);\n', '\n', '        require(total > 0);\n', '        investedETH[msg.sender] = 0;\n', '        lastInvest[msg.sender] = now;\n', '        msg.sender.transfer(total);\n', '\n', '    }\n', '    \n', '    function withdraw() public{\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '\n', '        require(profit > 0);\n', '        lastInvest[msg.sender] = now;\n', '        msg.sender.transfer(profit);\n', '\n', '    }\n', '\n', '    function withdrawAffiliateCommision() public {\n', '\n', '        require(affiliateCommision[msg.sender] > 0);\n', '        uint256 commision = affiliateCommision[msg.sender];\n', '        affiliateCommision[msg.sender] = 0;\n', '        msg.sender.transfer(commision);\n', '\n', '    }\n', '    \n', '    function reinvestProfit() public {\n', '\n', '        uint256 profit = getProfit(msg.sender);\n', '\n', '        require(profit > 0);\n', '        lastInvest[msg.sender] = now;\n', '        investedETH[msg.sender] = SafeMath.add(investedETH[msg.sender], profit);\n', '\n', '    }\n', '\n', '    function inheritInvestorPosition(uint256 index) public payable {\n', '\n', '        require(investorPositions.length > index);\n', '        require(msg.sender == tx.origin);\n', '\n', '        InvestorPosition storage position = investorPositions[index];\n', '        uint256 currentLevel = getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife);\n', '        uint256 currentPrice = getCurrentPrice(currentLevel);\n', '\n', '        require(msg.value >= currentPrice);\n', '        uint256 purchaseExcess = SafeMath.sub(msg.value, currentPrice);\n', '        position.startingLevel = currentLevel + 1;\n', '        position.startingTime = now;\n', '\n', '        // now do the transfers\n', '        uint256 inheritanceTax = SafeMath.div(SafeMath.mul(currentPrice, INHERITANCE_TAX), 100); // 75%\n', '        position.investor.transfer(inheritanceTax);\n', '        position.investor = msg.sender; // set the new investor address\n', '\n', '        // now the dev transfer tax\n', '        uint256 devTransferTax = SafeMath.div(SafeMath.mul(currentPrice, DEV_TRANSFER_TAX), 100); // 5%\n', '        dev.transfer(devTransferTax);\n', '\n', '        // and finally the excess\n', '        msg.sender.transfer(purchaseExcess);\n', '\n', '        // after this point there will be 20% of currentPrice left in the contract\n', '        // this will be automatically go towards paying for profits and withdrawals\n', '\n', '    }\n', '\n', '    function getInvestorPosition(uint256 index) public view returns(address investor, uint256 currentPrice, uint256 halfLife, uint256 percentageCut) {\n', '        InvestorPosition memory position = investorPositions[index];\n', '        return (position.investor, getCurrentPrice(getCurrentLevel(position.startingLevel, position.startingTime, position.halfLife)), position.halfLife, position.percentageCut);\n', '    }\n', '\n', '    function getCurrentPrice(uint256 currentLevel) internal view returns(uint256) {\n', '        return BASE_PRICE * 2**currentLevel; // ** is exponent, price doubles every level\n', '    }\n', '\n', '    function getCurrentLevel(uint256 startingLevel, uint256 startingTime, uint256 halfLife) internal view returns(uint256) {\n', '        uint256 timePassed = SafeMath.sub(now, startingTime);\n', '        uint256 levelsPassed = SafeMath.div(timePassed, halfLife);\n', '        if (startingLevel < levelsPassed) {\n', '            return 0;\n', '        }\n', '        return SafeMath.sub(startingLevel,levelsPassed);\n', '    }\n', '\n', '    function getProfitFromSender() public view returns(uint256){\n', '        return getProfit(msg.sender);\n', '    }\n', '\n', '    function getProfit(address customer) public view returns(uint256){\n', '        uint256 secondsPassed = SafeMath.sub(now, lastInvest[customer]);\n', '        return SafeMath.div(SafeMath.mul(secondsPassed, investedETH[customer]), 5760000); // = days * amount * 0.015 (+1.5% per day)\n', '    }\n', '    \n', '    function getAffiliateCommision() public view returns(uint256){\n', '        return affiliateCommision[msg.sender];\n', '    }\n', '    \n', '    function getInvested() public view returns(uint256){\n', '        return investedETH[msg.sender];\n', '    }\n', '    \n', '    function getBalance() public view returns(uint256){\n', '        return this.balance;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}']
