['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Registrar\n', ' */\n', 'contract Registrar {\n', '\taddress private contractOwner;\n', '\tbool public paused;\n', '\n', '\tstruct Manifest {\n', '\t\taddress registrant;\n', '\t\tbytes32 name;\n', '\t\tuint256 version;\n', '\t\tuint256 index;\n', '\t\tbytes32 hashTypeName;\n', '\t\tstring checksum;\n', '\t\tuint256 createdOn;\n', '\t}\n', '\t\n', '\tstruct HashType {\n', '\t    bytes32 name;\n', '\t    bool active;\n', '\t}\n', '\t\n', '\tuint256 public numHashTypes;\n', '\tmapping(bytes32 => Manifest) private manifests;\n', '\tmapping(address => bytes32[]) private registrantManifests;\n', '\tmapping(bytes32 => bytes32[]) private registrantNameManifests;\n', '\tmapping(bytes32 => uint256) private registrantNameVersionCount;\n', '\tmapping(bytes32 => uint256) public hashTypeIdLookup;\n', '\tmapping(uint256 => HashType) public hashTypes;\n', '\t\n', '\t /**\n', '\t  * @dev Log when a manifest registration is successful\n', '\t  */\n', '\tevent LogManifest(address indexed registrant, bytes32 indexed name, uint256 indexed version, bytes32 hashTypeName, string checksum);\n', '\n', '    /**\n', '\t * @dev Checks if contractOwner addresss is calling\n', '\t */\n', '\tmodifier onlyContractOwner {\n', '\t\trequire(msg.sender == contractOwner);\n', '\t\t_;\n', '\t}\n', '\n', '    /**\n', '\t * @dev Checks if contract is active\n', '\t */\n', '\tmodifier contractIsActive {\n', '\t\trequire(paused == false);\n', '\t\t_;\n', '\t}\n', '\n', '    /**\n', '     * @dev Checks if the values provided for this manifest are valid\n', '     */\n', '    modifier manifestIsValid(bytes32 name, bytes32 hashTypeName, string checksum, address registrant) {\n', '        require(name != bytes32(0x0) && \n', '            hashTypes[hashTypeIdLookup[hashTypeName]].active == true &&\n', '            bytes(checksum).length != 0 &&\n', '            registrant != address(0x0) &&\n', '            manifests[keccak256(abi.encodePacked(registrant, name, nextVersion(registrant, name)))].name == bytes32(0x0)\n', '            );\n', '        _;\n', '    }\n', '    \n', '\t/**\n', '\t * Constructor\n', '     */\n', '\tconstructor() public {\n', '\t\tcontractOwner = msg.sender;\n', '\t\taddHashType(&#39;sha256&#39;);\n', '\t}\n', '\n', '    /******************************************/\n', '    /*           OWNER ONLY METHODS           */\n', '    /******************************************/\n', '    \n', '    /**\n', '     * @dev Allows contractOwner to add hashType\n', '     * @param _name The value to be added\n', '     */\n', '    function addHashType(bytes32 _name) public onlyContractOwner {\n', '        require(hashTypeIdLookup[_name] == 0);\n', '        numHashTypes++;\n', '        hashTypeIdLookup[_name] = numHashTypes;\n', '        HashType storage _hashType = hashTypes[numHashTypes];\n', '        \n', '        // Store info about this hashType\n', '        _hashType.name = _name;\n', '        _hashType.active = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @dev Allows contractOwner to activate/deactivate hashType\n', '\t * @param _name The name of the hashType\n', '\t * @param _active The value to be set\n', '\t */\n', '\tfunction setActiveHashType(bytes32 _name, bool _active) public onlyContractOwner {\n', '        require(hashTypeIdLookup[_name] > 0);\n', '        hashTypes[hashTypeIdLookup[_name]].active = _active;\n', '\t}\n', '\n', '    /**\n', '     * @dev Allows contractOwner to pause the contract\n', '     * @param _paused The value to be set\n', '     */\n', '\tfunction setPaused(bool _paused) public onlyContractOwner {\n', '\t\tpaused = _paused;\n', '\t}\n', '    \n', '    /**\n', '\t * @dev Allows contractOwner to kill the contract\n', '\t */\n', '    function kill() public onlyContractOwner {\n', '\t\tselfdestruct(contractOwner);\n', '\t}\n', '\n', '    /******************************************/\n', '    /*            PUBLIC METHODS              */\n', '    /******************************************/\n', '\t/**\n', '\t * @dev Function to determine the next version value of a manifest\n', '\t * @param _registrant The registrant address of the manifest\n', '\t * @param _name The name of the manifest\n', '\t * @return The next version value\n', '\t */\n', '\tfunction nextVersion(address _registrant, bytes32 _name) public view returns (uint256) {\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    return (registrantNameVersionCount[registrantNameIndex] + 1);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Function to register a manifest\n', '\t * @param _name The name of the manifest\n', '\t * @param _hashTypeName The hashType of the manifest\n', '\t * @param _checksum The checksum of the manifest\n', '\t */\n', '\tfunction register(bytes32 _name, bytes32 _hashTypeName, string _checksum) public \n', '\t    contractIsActive\n', '\t    manifestIsValid(_name, _hashTypeName, _checksum, msg.sender) {\n', '\n', '\t    // Generate registrant name index\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(msg.sender, _name));\n', '\t    \n', '\t    // Increment the version for this manifest\n', '\t    registrantNameVersionCount[registrantNameIndex]++;\n', '\t    \n', '\t    // Generate ID for this manifest\n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(msg.sender, _name, registrantNameVersionCount[registrantNameIndex]));\n', '\t    \n', '        Manifest storage _manifest = manifests[manifestId];\n', '        \n', '        // Store info about this manifest\n', '        _manifest.registrant = msg.sender;\n', '        _manifest.name = _name;\n', '        _manifest.version = registrantNameVersionCount[registrantNameIndex];\n', '        _manifest.index = registrantNameManifests[registrantNameIndex].length;\n', '        _manifest.hashTypeName = _hashTypeName;\n', '        _manifest.checksum = _checksum;\n', '        _manifest.createdOn = now;\n', '        \n', '        registrantManifests[msg.sender].push(manifestId);\n', '        registrantNameManifests[registrantNameIndex].push(manifestId);\n', '\n', '\t    emit LogManifest(msg.sender, _manifest.name, _manifest.version, _manifest.hashTypeName, _manifest.checksum);\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a manifest registration based on registrant address, manifest name and version\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @param _version The version of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getManifest(address _registrant, bytes32 _name, uint256 _version) public view \n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t        \n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\n', '\t    require(manifests[manifestId].name != bytes32(0x0));\n', '\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a manifest registration based on manifestId\n', '     * @param _manifestId The registration ID of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getManifestById(bytes32 _manifestId) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t    require(manifests[_manifestId].name != bytes32(0x0));\n', '\n', '\t    Manifest memory _manifest = manifests[_manifestId];\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get the latest manifest registration based on registrant address and manifest name\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getLatestManifestByName(address _registrant, bytes32 _name) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t        \n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    require(registrantNameManifests[registrantNameIndex].length > 0);\n', '\t    \n', '\t    bytes32 manifestId = registrantNameManifests[registrantNameIndex][registrantNameManifests[registrantNameIndex].length - 1];\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get the latest manifest registration based on registrant address\n', '     * @param _registrant The registrant address of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getLatestManifest(address _registrant) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t    require(registrantManifests[_registrant].length > 0);\n', '\t    \n', '\t    bytes32 manifestId = registrantManifests[_registrant][registrantManifests[_registrant].length - 1];\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get a list of manifest Ids based on registrant address\n', '     * @param _registrant The registrant address of the manifest\n', '     * @return Array of manifestIds\n', '     */\n', '\tfunction getManifestIdsByRegistrant(address _registrant) public view returns (bytes32[]) {\n', '\t    return registrantManifests[_registrant];\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a list of manifest Ids based on registrant address and manifest name\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @return Array of registrationsIds\n', '     */\n', '\tfunction getManifestIdsByName(address _registrant, bytes32 _name) public view returns (bytes32[]) {\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    return registrantNameManifests[registrantNameIndex];\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get manifest Id based on registrant address, manifest name and version\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @param _version The version of the manifest\n', '     * @return The manifestId of the manifest\n', '     */\n', '\tfunction getManifestId(address _registrant, bytes32 _name, uint256 _version) public view returns (bytes32) {\n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\n', '\t    require(manifests[manifestId].name != bytes32(0x0));\n', '\t    return manifestId;\n', '\t}\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Registrar\n', ' */\n', 'contract Registrar {\n', '\taddress private contractOwner;\n', '\tbool public paused;\n', '\n', '\tstruct Manifest {\n', '\t\taddress registrant;\n', '\t\tbytes32 name;\n', '\t\tuint256 version;\n', '\t\tuint256 index;\n', '\t\tbytes32 hashTypeName;\n', '\t\tstring checksum;\n', '\t\tuint256 createdOn;\n', '\t}\n', '\t\n', '\tstruct HashType {\n', '\t    bytes32 name;\n', '\t    bool active;\n', '\t}\n', '\t\n', '\tuint256 public numHashTypes;\n', '\tmapping(bytes32 => Manifest) private manifests;\n', '\tmapping(address => bytes32[]) private registrantManifests;\n', '\tmapping(bytes32 => bytes32[]) private registrantNameManifests;\n', '\tmapping(bytes32 => uint256) private registrantNameVersionCount;\n', '\tmapping(bytes32 => uint256) public hashTypeIdLookup;\n', '\tmapping(uint256 => HashType) public hashTypes;\n', '\t\n', '\t /**\n', '\t  * @dev Log when a manifest registration is successful\n', '\t  */\n', '\tevent LogManifest(address indexed registrant, bytes32 indexed name, uint256 indexed version, bytes32 hashTypeName, string checksum);\n', '\n', '    /**\n', '\t * @dev Checks if contractOwner addresss is calling\n', '\t */\n', '\tmodifier onlyContractOwner {\n', '\t\trequire(msg.sender == contractOwner);\n', '\t\t_;\n', '\t}\n', '\n', '    /**\n', '\t * @dev Checks if contract is active\n', '\t */\n', '\tmodifier contractIsActive {\n', '\t\trequire(paused == false);\n', '\t\t_;\n', '\t}\n', '\n', '    /**\n', '     * @dev Checks if the values provided for this manifest are valid\n', '     */\n', '    modifier manifestIsValid(bytes32 name, bytes32 hashTypeName, string checksum, address registrant) {\n', '        require(name != bytes32(0x0) && \n', '            hashTypes[hashTypeIdLookup[hashTypeName]].active == true &&\n', '            bytes(checksum).length != 0 &&\n', '            registrant != address(0x0) &&\n', '            manifests[keccak256(abi.encodePacked(registrant, name, nextVersion(registrant, name)))].name == bytes32(0x0)\n', '            );\n', '        _;\n', '    }\n', '    \n', '\t/**\n', '\t * Constructor\n', '     */\n', '\tconstructor() public {\n', '\t\tcontractOwner = msg.sender;\n', "\t\taddHashType('sha256');\n", '\t}\n', '\n', '    /******************************************/\n', '    /*           OWNER ONLY METHODS           */\n', '    /******************************************/\n', '    \n', '    /**\n', '     * @dev Allows contractOwner to add hashType\n', '     * @param _name The value to be added\n', '     */\n', '    function addHashType(bytes32 _name) public onlyContractOwner {\n', '        require(hashTypeIdLookup[_name] == 0);\n', '        numHashTypes++;\n', '        hashTypeIdLookup[_name] = numHashTypes;\n', '        HashType storage _hashType = hashTypes[numHashTypes];\n', '        \n', '        // Store info about this hashType\n', '        _hashType.name = _name;\n', '        _hashType.active = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @dev Allows contractOwner to activate/deactivate hashType\n', '\t * @param _name The name of the hashType\n', '\t * @param _active The value to be set\n', '\t */\n', '\tfunction setActiveHashType(bytes32 _name, bool _active) public onlyContractOwner {\n', '        require(hashTypeIdLookup[_name] > 0);\n', '        hashTypes[hashTypeIdLookup[_name]].active = _active;\n', '\t}\n', '\n', '    /**\n', '     * @dev Allows contractOwner to pause the contract\n', '     * @param _paused The value to be set\n', '     */\n', '\tfunction setPaused(bool _paused) public onlyContractOwner {\n', '\t\tpaused = _paused;\n', '\t}\n', '    \n', '    /**\n', '\t * @dev Allows contractOwner to kill the contract\n', '\t */\n', '    function kill() public onlyContractOwner {\n', '\t\tselfdestruct(contractOwner);\n', '\t}\n', '\n', '    /******************************************/\n', '    /*            PUBLIC METHODS              */\n', '    /******************************************/\n', '\t/**\n', '\t * @dev Function to determine the next version value of a manifest\n', '\t * @param _registrant The registrant address of the manifest\n', '\t * @param _name The name of the manifest\n', '\t * @return The next version value\n', '\t */\n', '\tfunction nextVersion(address _registrant, bytes32 _name) public view returns (uint256) {\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    return (registrantNameVersionCount[registrantNameIndex] + 1);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Function to register a manifest\n', '\t * @param _name The name of the manifest\n', '\t * @param _hashTypeName The hashType of the manifest\n', '\t * @param _checksum The checksum of the manifest\n', '\t */\n', '\tfunction register(bytes32 _name, bytes32 _hashTypeName, string _checksum) public \n', '\t    contractIsActive\n', '\t    manifestIsValid(_name, _hashTypeName, _checksum, msg.sender) {\n', '\n', '\t    // Generate registrant name index\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(msg.sender, _name));\n', '\t    \n', '\t    // Increment the version for this manifest\n', '\t    registrantNameVersionCount[registrantNameIndex]++;\n', '\t    \n', '\t    // Generate ID for this manifest\n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(msg.sender, _name, registrantNameVersionCount[registrantNameIndex]));\n', '\t    \n', '        Manifest storage _manifest = manifests[manifestId];\n', '        \n', '        // Store info about this manifest\n', '        _manifest.registrant = msg.sender;\n', '        _manifest.name = _name;\n', '        _manifest.version = registrantNameVersionCount[registrantNameIndex];\n', '        _manifest.index = registrantNameManifests[registrantNameIndex].length;\n', '        _manifest.hashTypeName = _hashTypeName;\n', '        _manifest.checksum = _checksum;\n', '        _manifest.createdOn = now;\n', '        \n', '        registrantManifests[msg.sender].push(manifestId);\n', '        registrantNameManifests[registrantNameIndex].push(manifestId);\n', '\n', '\t    emit LogManifest(msg.sender, _manifest.name, _manifest.version, _manifest.hashTypeName, _manifest.checksum);\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a manifest registration based on registrant address, manifest name and version\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @param _version The version of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getManifest(address _registrant, bytes32 _name, uint256 _version) public view \n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t        \n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\n', '\t    require(manifests[manifestId].name != bytes32(0x0));\n', '\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a manifest registration based on manifestId\n', '     * @param _manifestId The registration ID of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getManifestById(bytes32 _manifestId) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t    require(manifests[_manifestId].name != bytes32(0x0));\n', '\n', '\t    Manifest memory _manifest = manifests[_manifestId];\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get the latest manifest registration based on registrant address and manifest name\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getLatestManifestByName(address _registrant, bytes32 _name) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t        \n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    require(registrantNameManifests[registrantNameIndex].length > 0);\n', '\t    \n', '\t    bytes32 manifestId = registrantNameManifests[registrantNameIndex][registrantNameManifests[registrantNameIndex].length - 1];\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get the latest manifest registration based on registrant address\n', '     * @param _registrant The registrant address of the manifest\n', '     * @return The registrant address of the manifest\n', '     * @return The name of the manifest\n', '     * @return The version of the manifest\n', '     * @return The index of this manifest in registrantNameManifests\n', '     * @return The hashTypeName of the manifest\n', '     * @return The checksum of the manifest\n', '     * @return The created on date of the manifest\n', '     */\n', '\tfunction getLatestManifest(address _registrant) public view\n', '\t    returns (address, bytes32, uint256, uint256, bytes32, string, uint256) {\n', '\t    require(registrantManifests[_registrant].length > 0);\n', '\t    \n', '\t    bytes32 manifestId = registrantManifests[_registrant][registrantManifests[_registrant].length - 1];\n', '\t    Manifest memory _manifest = manifests[manifestId];\n', '\n', '\t    return (\n', '\t        _manifest.registrant,\n', '\t        _manifest.name,\n', '\t        _manifest.version,\n', '\t        _manifest.index,\n', '\t        _manifest.hashTypeName,\n', '\t        _manifest.checksum,\n', '\t        _manifest.createdOn\n', '\t   );\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get a list of manifest Ids based on registrant address\n', '     * @param _registrant The registrant address of the manifest\n', '     * @return Array of manifestIds\n', '     */\n', '\tfunction getManifestIdsByRegistrant(address _registrant) public view returns (bytes32[]) {\n', '\t    return registrantManifests[_registrant];\n', '\t}\n', '\n', '    /**\n', '     * @dev Function to get a list of manifest Ids based on registrant address and manifest name\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @return Array of registrationsIds\n', '     */\n', '\tfunction getManifestIdsByName(address _registrant, bytes32 _name) public view returns (bytes32[]) {\n', '\t    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));\n', '\t    return registrantNameManifests[registrantNameIndex];\n', '\t}\n', '\t\n', '\t/**\n', '     * @dev Function to get manifest Id based on registrant address, manifest name and version\n', '     * @param _registrant The registrant address of the manifest\n', '     * @param _name The name of the manifest\n', '     * @param _version The version of the manifest\n', '     * @return The manifestId of the manifest\n', '     */\n', '\tfunction getManifestId(address _registrant, bytes32 _name, uint256 _version) public view returns (bytes32) {\n', '\t    bytes32 manifestId = keccak256(abi.encodePacked(_registrant, _name, _version));\n', '\t    require(manifests[manifestId].name != bytes32(0x0));\n', '\t    return manifestId;\n', '\t}\n', '}']
