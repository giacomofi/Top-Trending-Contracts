['pragma solidity ^0.4.16;\n', '\n', '\n', '\n', 'contract TokenERC20 {\n', '\n', '  /* Begin Owned Contract Members */\n', '  // An array of owners\n', '  mapping (address => bool) public owners;\n', '\n', '  // Has the next action been authorised by another owner\n', '  bool public nextActionIsAuthorised = false;\n', '  address public actionAuthorisedBy;\n', '  // Does an owner-only action have to be authorised by another owner\n', '  bool public requireAuthorisation = true;\n', '\n', '\n', '\n', '  function isOwner(address addressToCheck) view public returns (bool) {\n', '    return owners[addressToCheck];\n', '  }\n', '\n', '\n', '\n', '  modifier onlyOwners {\n', '    require(isOwner(msg.sender));\n', '    if (requireAuthorisation) {\n', '      checkActionIsAuthorisedAndReset();\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  function authoriseNextAction() public {\n', '    require(isOwner(msg.sender));\n', '    require(requireAuthorisation);\n', '    require(!nextActionIsAuthorised);\n', '    nextActionIsAuthorised = true;\n', '    actionAuthorisedBy = msg.sender;\n', '  }\n', '\n', '\n', '\n', '  function checkActionIsAuthorisedAndReset() public {\n', '    require(isOwner(msg.sender));\n', '    bool isValidAuthorisationRequest = (nextActionIsAuthorised && actionAuthorisedBy != msg.sender);\n', '    require(isValidAuthorisationRequest);\n', '    nextActionIsAuthorised = false;\n', '  }\n', '\n', '\n', '\n', '  function setRequireAuthorisation(bool _requireAuthorisation) onlyOwners public {\n', '    requireAuthorisation = _requireAuthorisation;\n', '  }\n', '  /* End Owned Contract Members */\n', '\n', '\n', '  // Public variables of the token\n', '  bool public tokenInitialised = false;\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals = 18;\n', '  uint256 public totalSupply;\n', '  uint256 public sellPrice;\n', '  address public currentSeller;\n', '\n', '  // Are users currently allowed to...\n', '  bool public allowTransfers = false; // transfer their tokens\n', '  bool public allowBurns = false;     // burn their tokens\n', '  bool public allowBuying = false;    // buy tokens\n', '\n', '  // This creates an array with...\n', '  mapping (address => uint256) public balanceOf;    // all balances\n', '  mapping (address => uint256) public etherSpent;   // how much an addeess has spent\n', '  mapping (address => bool) public frozenAccounts;  // frozen accounts\n', '  address[] investors;\n', '  uint64 public investorCount;\n', '\n', '\n', '\n', '  /*** Begin ICO Variables ***/\n', '\n', '  // Unit lenghts for week, month and year\n', '  uint256 constant public weekLength = 60 * 60 * 24 * 7;\n', '  uint256 constant public monthLength = 2627856; // (60 * 60 * 24 * 30.415) As to not have to re-adjust for different month lengths\n', '  uint256 constant public yearLength = 60 * 60 * 24 * 7 * 52;\n', '\n', '  uint256 public icoBeginDate;\n', '  uint256 public icoEndDate;\n', '  bool public icoParametersSet = false;\n', '\n', '  uint256 public tokensSoldAtIco = 0;\n', '  uint256 public minimumTokenThreshold;\n', '  bool public etherHasBeenReturnedToInvestors = false;\n', '  uint256 public softCap;\n', '  uint256 public runTimeAfterSoftCapReached;\n', '  uint256 public dateSoftCapWasReached = 0;\n', '\n', '  uint256 public maxFundsThatCanBeWithdrawnByOwners = 0;\n', '  uint256 public fundsWithdrawnByOwners = 0;\n', '\n', '  uint8 immediateAllowancePercentage;\n', '  uint8 firstYearAllowancePercentage;\n', '  uint8 secondYearAllowancePercentage;\n', '\n', '  mapping (uint8 => uint8) public weekBonuses; // Bonus of 20% is stored as 120, 10% as 110 etc.\n', '\n', '\n', '\n', '  modifier onlyWhenIcoParametersAreSet {\n', '    require(icoParametersSet);\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  modifier onlyWhenIcoParametersAreNotSet {\n', '    require(!icoParametersSet);\n', '    _;\n', '  }\n', '\n', '\n', '\n', '  modifier onlyDuringIco {\n', '    require(icoParametersSet);\n', '    updateContract();\n', '    require(isIcoRunning());\n', '    _;\n', '  }\n', '  /*** End ICO Variables ***/\n', '\n', '\n', '\n', '  /*** Begin ICO Setters ***/\n', '  function setIcoParametersSet(bool set) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    icoParametersSet = set;\n', '  }\n', '\n', '\n', '\n', '  function setIcoBeginDate(uint256 beginDate) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    icoBeginDate = beginDate;\n', '  }\n', '\n', '\n', '\n', '  function setIcoEndDate (uint256 endDate) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    icoEndDate = endDate;\n', '  }\n', '\n', '\n', '\n', '  function setSoftCap (uint256 cap) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    softCap = cap;\n', '  }\n', '\n', '\n', '\n', '  function setRunTimeAfterSoftCapReached (uint256 runTime) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    runTimeAfterSoftCapReached = runTime;\n', '  }\n', '\n', '\n', '\n', '  function setImmediateAllowancePercentage(uint8 allowancePercentage) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    immediateAllowancePercentage = allowancePercentage;\n', '  }\n', '\n', '\n', '\n', '  function setFirstYearAllowancePercentage(uint8 allowancePercentage) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    firstYearAllowancePercentage = allowancePercentage;\n', '  }\n', '\n', '\n', '\n', '  function setSecondYearAllowancePercentage(uint8 allowancePercentage) onlyWhenIcoParametersAreNotSet onlyOwners public {\n', '    secondYearAllowancePercentage = allowancePercentage;\n', '  }\n', '\n', '\n', '\n', '  function initialiseToken() public {\n', '    require(!tokenInitialised);\n', '    name = "BaraToken";\n', '    symbol = "BRT";\n', '    totalSupply = 160000000 * 10 ** uint256(decimals);\n', '    balanceOf[msg.sender] = totalSupply;\n', '    currentSeller = msg.sender;\n', '    owners[msg.sender] = true;\n', '    owners[0x1434e028b12D196AcBE5304A94d0a5F816eb5d55] = true;\n', '    tokenInitialised = true;\n', '  }\n', '\n', '\n', '\n', '  function() payable public {\n', '    buyTokens();\n', '  }\n', '\n', '\n', '\n', '  function updateContract() onlyWhenIcoParametersAreSet public {\n', '    if (hasSoftCapBeenReached() && dateSoftCapWasReached == 0) {\n', '      dateSoftCapWasReached = now;\n', '      bool reachingSoftCapWillExtendIco = (dateSoftCapWasReached + runTimeAfterSoftCapReached > icoEndDate);\n', '      if (!reachingSoftCapWillExtendIco)\n', '        icoEndDate = dateSoftCapWasReached + runTimeAfterSoftCapReached;\n', '    }\n', '    if (!isBeforeIco())\n', '      updateOwnersWithdrawAllowance();\n', '  }\n', '\n', '\n', '\n', '  function isBeforeIco() onlyWhenIcoParametersAreSet internal view returns (bool) {\n', '    return (now <= icoBeginDate);\n', '  }\n', '\n', '\n', '\n', '  function isIcoRunning() onlyWhenIcoParametersAreSet internal view returns (bool) {\n', '    bool reachingSoftCapWillExtendIco = (dateSoftCapWasReached + runTimeAfterSoftCapReached) > icoEndDate;\n', '    bool afterBeginDate = now > icoBeginDate;\n', '    bool beforeEndDate = now < icoEndDate;\n', '    if (hasSoftCapBeenReached() && !reachingSoftCapWillExtendIco)\n', '      beforeEndDate = now < (dateSoftCapWasReached + runTimeAfterSoftCapReached);\n', '    bool running = afterBeginDate && beforeEndDate;\n', '    return running;\n', '  }\n', '\n', '\n', '\n', '  function isAfterIco() onlyWhenIcoParametersAreSet internal view returns (bool) {\n', '    return (now > icoEndDate);\n', '  }\n', '\n', '\n', '\n', '\n', '  function hasSoftCapBeenReached() onlyWhenIcoParametersAreSet internal view returns (bool) {\n', '    return (tokensSoldAtIco >= softCap && softCap != 0);\n', '  }\n', '\n', '\n', '\n', '  // In the first week of the ICO, there will be a bonus, say 20%, then the second week 10%,\n', '  // of tokens. This retrieves that bonus. 20% is stored as 120, 10% as 110, etc.\n', '  function getWeekBonus(uint256 amountPurchased) onlyWhenIcoParametersAreSet internal view returns (uint256) {\n', '    uint256 weekBonus = uint256(weekBonuses[getWeeksPassedSinceStartOfIco()]);\n', '    if (weekBonus != 0)\n', '      return (amountPurchased * weekBonus) / 100;\n', '    return amountPurchased;\n', '  }\n', '\n', '\n', '\n', '  function getTimeSinceEndOfIco() onlyWhenIcoParametersAreSet internal view returns (uint256) {\n', '    require(now > icoEndDate);\n', '    uint256 timeSinceEndOfIco = now - icoEndDate;\n', '    return timeSinceEndOfIco;\n', '  }\n', '\n', '\n', '\n', '  function getWeeksPassedSinceStartOfIco() onlyWhenIcoParametersAreSet internal view returns (uint8) {\n', '    require(!isBeforeIco());\n', '    uint256 timeSinceIco = now - icoBeginDate;\n', '    uint8 weeksPassedSinceIco = uint8(timeSinceIco / weekLength);\n', '    return weeksPassedSinceIco;\n', '  }\n', '\n', '\n', '\n', '  // Update how much the owners can withdraw based on how much time has passed\n', '  // since the end of the ICO\n', '  function updateOwnersWithdrawAllowance() onlyWhenIcoParametersAreSet internal {\n', '    if (isAfterIco()) {\n', '      uint256 totalFunds = this.balance;\n', '      maxFundsThatCanBeWithdrawnByOwners = 0;\n', '      uint256 immediateAllowance = (totalFunds * immediateAllowancePercentage) / 100;\n', '      bool secondYear = now - icoEndDate >= yearLength;\n', '      uint8 monthsPassedSinceIco = getMonthsPassedEndOfSinceIco();\n', '      if (secondYear) {\n', '        uint256 monthsPassedInSecondYear = monthsPassedSinceIco - 12;\n', '        // (monthsPassed / 12) * (allowancePercentage / 100) i.e. (monthsPassed * allowancePercentage / 1200)\n', '        // all multiplied by the totalFunds available to be withdrwan\n', "        // They're multiplied in one line to ensure not losing any information since we don't have floats\n", '        // The minimum a person can buy is 1/10^12 tokens and we have 18 decimals, meaning always at least\n', '        // 6 decimals to hold information done in multiplication/division\n', '        uint256 secondYearAllowance = ((totalFunds * secondYearAllowancePercentage * monthsPassedInSecondYear) / 1200);\n', '      }\n', '      uint8 monthsPassedInFirstYear = monthsPassedSinceIco;\n', '      if (secondYear)\n', '        monthsPassedInFirstYear = 12;\n', '      uint256 firstYearAllowance = ((totalFunds * firstYearAllowancePercentage * monthsPassedInFirstYear) / 1200);\n', '      maxFundsThatCanBeWithdrawnByOwners = immediateAllowance + firstYearAllowance + secondYearAllowance;\n', '    }\n', '  }\n', '\n', '\n', '\n', '  function getMonthsPassedEndOfSinceIco() onlyWhenIcoParametersAreSet internal view returns (uint8) {\n', '    uint256 timePassedSinceIco = now - icoEndDate;\n', '    uint8 monthsPassedSinceIco = uint8(timePassedSinceIco / weekLength);\n', '    return monthsPassedSinceIco + 1;\n', '  }\n', '\n', '\n', '\n', '  // Check if the amount the owners are attempting to withdraw is within their current allowance\n', '  function amountIsWithinOwnersAllowance(uint256 amountToWithdraw) internal view returns (bool) {\n', '    if (now - icoEndDate >= yearLength * 2)\n', '      return true;\n', '    uint256 totalFundsWithdrawnAfterThisTransaction = fundsWithdrawnByOwners + amountToWithdraw;\n', '    bool withinAllowance = totalFundsWithdrawnAfterThisTransaction <= maxFundsThatCanBeWithdrawnByOwners;\n', '    return withinAllowance;\n', '  }\n', '\n', '\n', '\n', '  function buyTokens() onlyDuringIco payable public {\n', '    require(allowBuying);\n', '    require(!frozenAccounts[msg.sender]);\n', '    require(msg.value > 0);\n', '    uint256 numberOfTokensPurchased = msg.value / sellPrice;\n', '    require(numberOfTokensPurchased >= 10 ** 6);\n', '    numberOfTokensPurchased = getWeekBonus(numberOfTokensPurchased);\n', '    _transfer(currentSeller, msg.sender, numberOfTokensPurchased);\n', '    tokensSoldAtIco += numberOfTokensPurchased;\n', '    if (!(etherSpent[msg.sender] > 0)) {\n', '      investors[investorCount] = msg.sender;\n', '      investorCount++;\n', '    }\n', '    etherSpent[msg.sender] += msg.value;\n', '  }\n', '\n', '\n', '\n', '  /* These generate a public event on the blockchain that will notify clients */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Burn(address indexed from, uint256 value);\n', '  event FrozenFunds(address target, bool frozen);\n', '  event NewSellPrice(uint256 _sellPrice);\n', '\n', '\n', '\n', '  function setTokenName(string tokenName) onlyOwners public {\n', '    name = tokenName;\n', '  }\n', '\n', '\n', '\n', '  function setTokenSymbol(string tokenSymbol) onlyOwners public {\n', '    symbol = tokenSymbol;\n', '  }\n', '\n', '\n', '\n', '  function setAllowTransfers(bool allow) onlyOwners public {\n', '    allowTransfers = allow;\n', '  }\n', '\n', '\n', '\n', '  function setAllowBurns(bool allow) onlyOwners public {\n', '    allowBurns = allow;\n', '  }\n', '\n', '\n', '\n', '  function setAllowBuying(bool allow) onlyOwners public {\n', '    allowBuying = allow;\n', '  }\n', '\n', '\n', '\n', '  function setSellPrice(uint256 _sellPrice) onlyOwners public {\n', '    sellPrice = _sellPrice;\n', '    NewSellPrice(_sellPrice);\n', '  }\n', '\n', '\n', '\n', '  function setCurrentSeller(address newSeller) onlyOwners public {\n', '    currentSeller = newSeller;\n', '  }\n', '\n', '\n', '\n', '  function ownersTransfer(address _to, uint256 _amount) onlyOwners public {\n', '    _transfer(msg.sender, _to, _amount);\n', '  }\n', '\n', '\n', '\n', '  function transfer(address _to, uint256 _value) public {\n', '    require(allowTransfers && !isOwner(msg.sender));\n', '    _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '\n', '\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '    require (_to != 0x0);\n', '    require (balanceOf[_from] >= _value);\n', '    require (balanceOf[_to] + _value > balanceOf[_to]);\n', '    require(!frozenAccounts[_from]);\n', '    require(!frozenAccounts[_to]);\n', '    balanceOf[_from] -= _value;\n', '    balanceOf[_to] += _value;\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '\n', '\n', '  function mintToken(address target, uint256 mintedAmount) onlyOwners public {\n', '    balanceOf[target] += mintedAmount;\n', '    totalSupply += mintedAmount;\n', '    Transfer(0, this, mintedAmount);\n', '    Transfer(this, target, mintedAmount);\n', '  }\n', '\n', '\n', '\n', '  function burn(uint256 amount) public {\n', '    require(allowBurns && !isOwner(msg.sender));\n', '    require(balanceOf[msg.sender] >= amount);\n', '    balanceOf[msg.sender] -= amount;\n', '    totalSupply -= amount;\n', '    Burn(msg.sender, amount);\n', '  }\n', '\n', '\n', '\n', '  function burnFrom(address from, uint256 amount) onlyOwners public {\n', '    require (balanceOf[from] >= amount);\n', '    balanceOf[from] -= amount;\n', '    totalSupply -= amount;\n', '    Burn(from, amount);\n', '  }\n', '\n', '\n', '\n', '  function freezeAccount(address target, bool freeze) onlyOwners public {\n', '    frozenAccounts[target] = freeze;\n', '    FrozenFunds(target, freeze);\n', '  }\n', '\n', '\n', '\n', '  function addOwner(address owner) onlyOwners public {\n', '    owners[owner] = true;\n', '  }\n', '\n', '\n', '\n', '  function removeOwner(address owner) onlyOwners public {\n', '    owners[owner] = false;\n', '  }\n', '\n', '\n', '\n', '  function sendContractFundsToAddress(uint256 amount, address recipient) onlyOwners public {\n', '    require(icoParametersSet);\n', '    require(isAfterIco());\n', '    require(tokensSoldAtIco >= minimumTokenThreshold);\n', '    require(amount <= this.balance);\n', '    updateContract();\n', '    require(amountIsWithinOwnersAllowance(amount));\n', '    recipient.transfer(amount);\n', '  }\n', '\n', '\n', '\n', '  function returnEtherToInvestors() onlyOwners onlyWhenIcoParametersAreSet public {\n', '    require(isAfterIco());\n', '    require(!etherHasBeenReturnedToInvestors);\n', '    require(tokensSoldAtIco < minimumTokenThreshold);\n', '    for (uint64 investorNumber; investorNumber < investorCount; investorNumber++) {\n', '      address investor = investors[investorNumber];\n', '      uint256 amountToSend = etherSpent[investor];\n', '      investor.transfer(amountToSend);\n', '    }\n', '    etherHasBeenReturnedToInvestors = true;\n', '  }\n', '\n', '\n', '\n', '  function getContractBalance() public view returns (uint256) {\n', '    return this.balance;\n', '  }\n', '\n', '\n', '\n', '\n', '}']