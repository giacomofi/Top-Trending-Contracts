['pragma solidity ^0.4.22;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(address(0) != _newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '/** @author OVCode Switzerland AG */\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', 'contract TokenERC20 is SafeMath {\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    \n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event ReceiveApproval(address _from, uint256 _value, address _token);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '    * For the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function TokenERC20() public {\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(safeAdd(balanceOf[_to],_value) > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = safeAdd(balanceOf[_from],balanceOf[_to]);\n', '        // Subtract from the sender\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(32 * 3) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(32 * 2) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit ReceiveApproval(msg.sender, _value, this);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);  // Subtract from the sender\n', '        totalSupply = safeSub(totalSupply,_value);                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) onlyPayloadSize(32 * 2) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);             // Subtract from the sender&#39;s allowance\n', '        totalSupply = safeSub(totalSupply,_value);                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', '\n', 'contract OVC is Ownable, TokenERC20 {\n', '\n', '    uint256 public ovcPerEther = 0;\n', '    uint256 public minOVC;\n', '    uint256 public constant ICO_START_TIME = 1526891400; // 05.21.2018 08:30:00 UTC\n', '    uint256 public constant ICO_END_TIME = 1532131199; // 07.20.2018 11:59:59 UTC\n', '\n', '    uint256 public totalOVCSold = 0;\n', '    \n', '    OVCLockAllocation public lockedAllocation;\n', '    mapping (address => bool) public frozenAccount;\n', '  \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '    event ChangeOvcEtherConversion(address owner, uint256 amount);\n', '    /* Initializes contract, Total Supply (83,875,000 OVC), name (OVCODE) and symbol (OVC), Min OVC Per Wallet\n', '    // Assign the 30,000,000 of the total supply to the presale account\n', '    // Assign the 10,500,000 of the total supply to the First ICO account\n', '    // Assign the 11,000,000 of the total supply to the Second ICO account\n', '    // Assign the 1,075,000 of the total supply to the bonus account\n', '    // Assign the 2,450,000 of the total supply to the bounty account\n', '    // Assign the 14,850,000 of the total supply to the first investor account\n', '    // Assign the 4,000,000 of the total supply to the second investor account\n', '    // Lock-in the 10,000,000 of the total supply to `OVCLockAllocation` contract within 36 months(unlock 1/3 every 12 months)\n', '    */\n', '    function OVC() public {\n', '\n', '        totalSupply = safeMul(83875000,(10 ** uint256(decimals) ));  // Update total supply(83,875,000) with the decimal amount\n', '        name = "OVCODE";  // Set the name for display purposes\n', '        symbol = "OVC";   // Set the symbol for display purposes\n', '        \n', '        // 30,000,000 tokens for Presale \n', '        balanceOf[msg.sender] = safeMul(30000000,(10 ** uint256(decimals))); \n', '\n', '        // 11,000,000 ICO tokens for direct buy on the smart contract\n', '        /* @notice Transfer this token to OVC Smart Contract Address \n', '          to enable the puchaser to buy directly on the contract */\n', '        address icoAccount1 = 0xe5aB5D1Da8817bFB4b0Af44eFDcCC850a47E477a;\n', '        balanceOf[icoAccount1] = safeMul(11000000,(10 ** uint256(decimals))); \n', '\n', '        // 10,500,000 ICO tokens for cash and btc purchaser\n', '        /* @notice This account will be used to send token \n', '            to the purchaser that used BTC or CASH */\n', '        address icoAccount2 = 0xfD382a7478ce3ddCd6a03F6c1848F31659753388;\n', '        balanceOf[icoAccount2] = safeMul(10500000,(10 ** uint256(decimals))); \n', '\n', '        // 1,075,000 tokens for bonus, referrals and discounts\n', '        address bonusAccount = 0xAde1Cf49c41919658132FF003C409fBcb2909472;\n', '        balanceOf[bonusAccount] = safeMul(1075000,(10 ** uint256(decimals)));\n', '        \n', '        // 2,450,000 tokens for bounty\n', '        address bountyAccount = 0xb690acb524BFBD968A91D614654aEEC5041597E0;\n', '        balanceOf[bountyAccount] = safeMul(2450000,(10 ** uint256(decimals)));\n', '\n', '        // 14,850,000 & 4,000,000 for our investors\n', '        address investor1 = 0x17dC8dD84bD8DbAC168209360EDc1E8539D965DA;\n', '        balanceOf[investor1] = safeMul(14850000,(10 ** uint256(decimals)));\n', '        address investor2 = 0x5B2213eeFc9b7939D863085f7F2D9D1f3a771D5f;\n', '        balanceOf[investor2] = safeMul(4000000,(10 ** uint256(decimals)));\n', '        \n', '        // Founder and Developer 10,000,000 of the total Supply / Lock-in within 36 months(unlock 1/3 every 12 months)\n', '        uint256 totalAllocation = safeMul(10000000,(10 ** uint256(decimals)));\n', '        \n', '        // Initilize the `OVCLockAllocation` contract with the totalAllocation and 3 allocated wallets\n', '        address firstAllocatedWallet = 0xD0427222388145a1A14F5FC4a376e8412C39c6a4;\n', '        address secondAllocatedWallet = 0xe141c480274376A4eB499ACEeD84c47b5FDF4B39;\n', '        address thirdAllocatedWallet = 0xD46811aBe15a53dd76b309E3e1f8f9C4550D3918;\n', '        lockedAllocation = new OVCLockAllocation(totalAllocation,firstAllocatedWallet,secondAllocatedWallet,thirdAllocatedWallet);\n', '        // Assign the 10,000,000 lock token to the `OVCLockAllocation` contract address\n', '        balanceOf[lockedAllocation] = totalAllocation;\n', '\n', '        // @notice Minimum token per wallet 10 OVC\n', '        minOVC = safeMul(10,(10 ** uint256(decimals)));\n', '    }\n', '    \n', '    /* @notice Allow user to send ether directly to the contract address */\n', '    function () public payable {\n', '        buyTokens();\n', '    }\n', '    \n', '    /* @notice private function for buy token, enable the purchaser to \n', '    // send Ether directly to the contract address */\n', '    function buyTokens() private {\n', '        require(now > ICO_START_TIME );\n', '        require(now < ICO_END_TIME );\n', '\n', '        uint256 _value = safeMul(msg.value,ovcPerEther);\n', '        uint256 futureBalance = safeAdd(balanceOf[msg.sender],_value);\n', '\n', '        require(futureBalance >= minOVC);\n', '        owner.transfer(address(this).balance);\n', '\n', '        _transfer(this, msg.sender, _value);\n', '        totalOVCSold = safeAdd(totalOVCSold,_value);\n', '    }\n', '    \n', '     /* @notice Change the current amount of OVC token per Ether */\n', '    function changeOVCPerEther(uint256 amount) onlyPayloadSize(1 * 32) onlyOwner public {\n', '        require(amount >= 0);\n', '        ovcPerEther = amount;\n', '        emit ChangeOvcEtherConversion(msg.sender, amount);\n', '    }\n', '\n', '    /* @notice Transfer all unsold token to the contract owner */\n', '    function transferUnsoldToken() onlyOwner public {\n', '        require(now > ICO_END_TIME );\n', '        require (balanceOf[this] > 0); \n', '        uint256 unsoldToken = balanceOf[this]; \n', '        _transfer(this, msg.sender, unsoldToken);\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough balance\n', '        require (safeAdd(balanceOf[_to],_value) > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);// Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);// Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) onlyPayloadSize(32 * 2) onlyOwner public {\n', '        balanceOf[target] = safeAdd(balanceOf[target],mintedAmount);\n', '        totalSupply = safeAdd(totalSupply,mintedAmount);\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', '\n', 'contract OVCLockAllocation is SafeMath {\n', '\n', '    uint256 public totalLockAllocated;\n', '    OVC public ovc;\n', '    /**\n', '    * For the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    struct Allocations {\n', '        uint256 allocated;\n', '        uint256 unlockedAt;\n', '        bool released;\n', '    }\n', '\n', '    mapping (address => Allocations) public allocations;\n', '\n', '    /* Initialize the total allocated OVC token */\n', '    // Initialize the 3 wallet address, allocated amount and date unlock\n', '    // @param `totalAllocated` Total allocated token from  `OVC` contract\n', '    // @param `firstAllocatedWallet` wallet address that allowed to unlock the first 1/3 allocated token\n', '    // @param `secondAllocatedWallet` wallet address that allowed to unlock the second 1/3 allocated token\n', '    // @param `thirdAllocatedWallet` wallet address that allowed to unlock the third 1/3 allocated token\n', '    function OVCLockAllocation(uint256 totalAllocated, address firstAllocatedWallet, address secondAllocatedWallet, address thirdAllocatedWallet) public {\n', '        ovc = OVC(msg.sender);\n', '        totalLockAllocated = totalAllocated;\n', '        Allocations memory allocation;\n', '\n', '        // Initialize the first allocation wallet address and date unlockedAt\n', '        // Unlock 1/3 or 33% of the token allocated after 12 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 33),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(12,30 days)));\n', '        allocation.released = false;\n', '        allocations[firstAllocatedWallet] = allocation;\n', '        \n', '\n', '        // Initialize the second allocation wallet address and date unlockedAt\n', '        // Unlock 1/3 or 33% of the token allocated after 24 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 33),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(24,30 days)));\n', '        allocation.released = false;\n', '        allocations[secondAllocatedWallet] = allocation;\n', '\n', '        // Initialize the third allocation wallet address and date unlockedAt\n', '        // Unlock last or 34% of the token allocated after 36 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 34),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(36,30 days))); \n', '        allocation.released = false;\n', '        allocations[thirdAllocatedWallet] = allocation;\n', '    }\n', '    \n', '        /**\n', '    * @notice called by allocated address to release the token\n', '    */\n', '    function releaseTokens() public {\n', '        Allocations memory allocation;\n', '        allocation = allocations[msg.sender];\n', '        require(allocation.released == false);\n', '        require(allocation.allocated > 0);\n', '        require(allocation.unlockedAt > 0);\n', '        require(now >= allocation.unlockedAt);\n', '            \n', '        uint256 allocated = allocation.allocated;\n', '        ovc.transfer(msg.sender, allocated);\n', '\n', '        allocation.allocated = 0;\n', '        allocation.unlockedAt = 0;\n', '        allocation.released = true;\n', '        allocations[msg.sender] = allocation;\n', '    }\n', '} \n', '\n', '/** @author OVCode Switzerland AG */']
['pragma solidity ^0.4.22;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(address(0) != _newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        owner = msg.sender;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '/** @author OVCode Switzerland AG */\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'contract SafeMath {\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function SafeMath() public {\n', '    }\n', '\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', 'contract TokenERC20 is SafeMath {\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    \n', '    // 18 decimals is the strongly suggested default, avoid changing it\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    // This creates an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event ReceiveApproval(address _from, uint256 _value, address _token);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '    * For the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev constructor\n', '    */\n', '    function TokenERC20() public {\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(safeAdd(balanceOf[_to],_value) > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = safeAdd(balanceOf[_from],balanceOf[_to]);\n', '        // Subtract from the sender\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);\n', '        // Add the same to the recipient\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(32 * 3) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(32 * 2) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit ReceiveApproval(msg.sender, _value, this);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);  // Subtract from the sender\n', '        totalSupply = safeSub(totalSupply,_value);                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Destroy tokens from other account\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '     *\n', '     * @param _from the address of the sender\n', '     * @param _value the amount of money to burn\n', '     */\n', '    function burnFrom(address _from, uint256 _value) onlyPayloadSize(32 * 2) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender],_value);             // Subtract from the sender's allowance\n", '        totalSupply = safeSub(totalSupply,_value);                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', '\n', 'contract OVC is Ownable, TokenERC20 {\n', '\n', '    uint256 public ovcPerEther = 0;\n', '    uint256 public minOVC;\n', '    uint256 public constant ICO_START_TIME = 1526891400; // 05.21.2018 08:30:00 UTC\n', '    uint256 public constant ICO_END_TIME = 1532131199; // 07.20.2018 11:59:59 UTC\n', '\n', '    uint256 public totalOVCSold = 0;\n', '    \n', '    OVCLockAllocation public lockedAllocation;\n', '    mapping (address => bool) public frozenAccount;\n', '  \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event FrozenFunds(address target, bool frozen);\n', '    event ChangeOvcEtherConversion(address owner, uint256 amount);\n', '    /* Initializes contract, Total Supply (83,875,000 OVC), name (OVCODE) and symbol (OVC), Min OVC Per Wallet\n', '    // Assign the 30,000,000 of the total supply to the presale account\n', '    // Assign the 10,500,000 of the total supply to the First ICO account\n', '    // Assign the 11,000,000 of the total supply to the Second ICO account\n', '    // Assign the 1,075,000 of the total supply to the bonus account\n', '    // Assign the 2,450,000 of the total supply to the bounty account\n', '    // Assign the 14,850,000 of the total supply to the first investor account\n', '    // Assign the 4,000,000 of the total supply to the second investor account\n', '    // Lock-in the 10,000,000 of the total supply to `OVCLockAllocation` contract within 36 months(unlock 1/3 every 12 months)\n', '    */\n', '    function OVC() public {\n', '\n', '        totalSupply = safeMul(83875000,(10 ** uint256(decimals) ));  // Update total supply(83,875,000) with the decimal amount\n', '        name = "OVCODE";  // Set the name for display purposes\n', '        symbol = "OVC";   // Set the symbol for display purposes\n', '        \n', '        // 30,000,000 tokens for Presale \n', '        balanceOf[msg.sender] = safeMul(30000000,(10 ** uint256(decimals))); \n', '\n', '        // 11,000,000 ICO tokens for direct buy on the smart contract\n', '        /* @notice Transfer this token to OVC Smart Contract Address \n', '          to enable the puchaser to buy directly on the contract */\n', '        address icoAccount1 = 0xe5aB5D1Da8817bFB4b0Af44eFDcCC850a47E477a;\n', '        balanceOf[icoAccount1] = safeMul(11000000,(10 ** uint256(decimals))); \n', '\n', '        // 10,500,000 ICO tokens for cash and btc purchaser\n', '        /* @notice This account will be used to send token \n', '            to the purchaser that used BTC or CASH */\n', '        address icoAccount2 = 0xfD382a7478ce3ddCd6a03F6c1848F31659753388;\n', '        balanceOf[icoAccount2] = safeMul(10500000,(10 ** uint256(decimals))); \n', '\n', '        // 1,075,000 tokens for bonus, referrals and discounts\n', '        address bonusAccount = 0xAde1Cf49c41919658132FF003C409fBcb2909472;\n', '        balanceOf[bonusAccount] = safeMul(1075000,(10 ** uint256(decimals)));\n', '        \n', '        // 2,450,000 tokens for bounty\n', '        address bountyAccount = 0xb690acb524BFBD968A91D614654aEEC5041597E0;\n', '        balanceOf[bountyAccount] = safeMul(2450000,(10 ** uint256(decimals)));\n', '\n', '        // 14,850,000 & 4,000,000 for our investors\n', '        address investor1 = 0x17dC8dD84bD8DbAC168209360EDc1E8539D965DA;\n', '        balanceOf[investor1] = safeMul(14850000,(10 ** uint256(decimals)));\n', '        address investor2 = 0x5B2213eeFc9b7939D863085f7F2D9D1f3a771D5f;\n', '        balanceOf[investor2] = safeMul(4000000,(10 ** uint256(decimals)));\n', '        \n', '        // Founder and Developer 10,000,000 of the total Supply / Lock-in within 36 months(unlock 1/3 every 12 months)\n', '        uint256 totalAllocation = safeMul(10000000,(10 ** uint256(decimals)));\n', '        \n', '        // Initilize the `OVCLockAllocation` contract with the totalAllocation and 3 allocated wallets\n', '        address firstAllocatedWallet = 0xD0427222388145a1A14F5FC4a376e8412C39c6a4;\n', '        address secondAllocatedWallet = 0xe141c480274376A4eB499ACEeD84c47b5FDF4B39;\n', '        address thirdAllocatedWallet = 0xD46811aBe15a53dd76b309E3e1f8f9C4550D3918;\n', '        lockedAllocation = new OVCLockAllocation(totalAllocation,firstAllocatedWallet,secondAllocatedWallet,thirdAllocatedWallet);\n', '        // Assign the 10,000,000 lock token to the `OVCLockAllocation` contract address\n', '        balanceOf[lockedAllocation] = totalAllocation;\n', '\n', '        // @notice Minimum token per wallet 10 OVC\n', '        minOVC = safeMul(10,(10 ** uint256(decimals)));\n', '    }\n', '    \n', '    /* @notice Allow user to send ether directly to the contract address */\n', '    function () public payable {\n', '        buyTokens();\n', '    }\n', '    \n', '    /* @notice private function for buy token, enable the purchaser to \n', '    // send Ether directly to the contract address */\n', '    function buyTokens() private {\n', '        require(now > ICO_START_TIME );\n', '        require(now < ICO_END_TIME );\n', '\n', '        uint256 _value = safeMul(msg.value,ovcPerEther);\n', '        uint256 futureBalance = safeAdd(balanceOf[msg.sender],_value);\n', '\n', '        require(futureBalance >= minOVC);\n', '        owner.transfer(address(this).balance);\n', '\n', '        _transfer(this, msg.sender, _value);\n', '        totalOVCSold = safeAdd(totalOVCSold,_value);\n', '    }\n', '    \n', '     /* @notice Change the current amount of OVC token per Ether */\n', '    function changeOVCPerEther(uint256 amount) onlyPayloadSize(1 * 32) onlyOwner public {\n', '        require(amount >= 0);\n', '        ovcPerEther = amount;\n', '        emit ChangeOvcEtherConversion(msg.sender, amount);\n', '    }\n', '\n', '    /* @notice Transfer all unsold token to the contract owner */\n', '    function transferUnsoldToken() onlyOwner public {\n', '        require(now > ICO_END_TIME );\n', '        require (balanceOf[this] > 0); \n', '        uint256 unsoldToken = balanceOf[this]; \n', '        _transfer(this, msg.sender, unsoldToken);\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] >= _value);               // Check if the sender has enough balance\n', '        require (safeAdd(balanceOf[_to],_value) > balanceOf[_to]); // Check for overflows\n', '        require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '        balanceOf[_from] = safeSub(balanceOf[_from],_value);// Subtract from the sender\n', '        balanceOf[_to] = safeAdd(balanceOf[_to],_value);// Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice Create `mintedAmount` tokens and send it to `target`\n', '    /// @param target Address to receive the tokens\n', '    /// @param mintedAmount the amount of tokens it will receive\n', '    function mintToken(address target, uint256 mintedAmount) onlyPayloadSize(32 * 2) onlyOwner public {\n', '        balanceOf[target] = safeAdd(balanceOf[target],mintedAmount);\n', '        totalSupply = safeAdd(totalSupply,mintedAmount);\n', '        emit Transfer(0, this, mintedAmount);\n', '        emit Transfer(this, target, mintedAmount);\n', '    }\n', '\n', '    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '    /// @param target Address to be frozen\n', '    /// @param freeze either to freeze it or not\n', '    function freezeAccount(address target, bool freeze) onlyOwner public {\n', '        frozenAccount[target] = freeze;\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '}\n', '\n', '/** @author OVCode Switzerland AG */\n', '\n', '\n', 'contract OVCLockAllocation is SafeMath {\n', '\n', '    uint256 public totalLockAllocated;\n', '    OVC public ovc;\n', '    /**\n', '    * For the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    struct Allocations {\n', '        uint256 allocated;\n', '        uint256 unlockedAt;\n', '        bool released;\n', '    }\n', '\n', '    mapping (address => Allocations) public allocations;\n', '\n', '    /* Initialize the total allocated OVC token */\n', '    // Initialize the 3 wallet address, allocated amount and date unlock\n', '    // @param `totalAllocated` Total allocated token from  `OVC` contract\n', '    // @param `firstAllocatedWallet` wallet address that allowed to unlock the first 1/3 allocated token\n', '    // @param `secondAllocatedWallet` wallet address that allowed to unlock the second 1/3 allocated token\n', '    // @param `thirdAllocatedWallet` wallet address that allowed to unlock the third 1/3 allocated token\n', '    function OVCLockAllocation(uint256 totalAllocated, address firstAllocatedWallet, address secondAllocatedWallet, address thirdAllocatedWallet) public {\n', '        ovc = OVC(msg.sender);\n', '        totalLockAllocated = totalAllocated;\n', '        Allocations memory allocation;\n', '\n', '        // Initialize the first allocation wallet address and date unlockedAt\n', '        // Unlock 1/3 or 33% of the token allocated after 12 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 33),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(12,30 days)));\n', '        allocation.released = false;\n', '        allocations[firstAllocatedWallet] = allocation;\n', '        \n', '\n', '        // Initialize the second allocation wallet address and date unlockedAt\n', '        // Unlock 1/3 or 33% of the token allocated after 24 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 33),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(24,30 days)));\n', '        allocation.released = false;\n', '        allocations[secondAllocatedWallet] = allocation;\n', '\n', '        // Initialize the third allocation wallet address and date unlockedAt\n', '        // Unlock last or 34% of the token allocated after 36 months\n', '        allocation.allocated = safeDiv(safeMul(totalLockAllocated, 34),100);\n', '        allocation.unlockedAt = safeAdd(now,(safeMul(36,30 days))); \n', '        allocation.released = false;\n', '        allocations[thirdAllocatedWallet] = allocation;\n', '    }\n', '    \n', '        /**\n', '    * @notice called by allocated address to release the token\n', '    */\n', '    function releaseTokens() public {\n', '        Allocations memory allocation;\n', '        allocation = allocations[msg.sender];\n', '        require(allocation.released == false);\n', '        require(allocation.allocated > 0);\n', '        require(allocation.unlockedAt > 0);\n', '        require(now >= allocation.unlockedAt);\n', '            \n', '        uint256 allocated = allocation.allocated;\n', '        ovc.transfer(msg.sender, allocated);\n', '\n', '        allocation.allocated = 0;\n', '        allocation.unlockedAt = 0;\n', '        allocation.released = true;\n', '        allocations[msg.sender] = allocation;\n', '    }\n', '} \n', '\n', '/** @author OVCode Switzerland AG */']
