['pragma solidity ^0.4.21;\n', '// We have to specify what version of compiler this code will compile with\n', '\n', '\n', 'contract MarbleEarth {\n', '\n', '\n', '  struct NewMoon {\n', '\n', '    uint timeAdded;\n', '    MoonType moonType;\n', '    uint64 votes;\n', '    mapping (address => bool) supportMap;\n', '\n', '  }\n', '\n', '\n', '  enum MoonType { Verification, Purge}\n', '\n', '  MRBLToken tokenContract;\n', '  VerificationMoon verificationContract;\n', '  PurgeMoon purgeContract;\n', '\n', '  address[] addresses;\n', '  bytes32[] identities;\n', '  mapping (address => bytes32) voterMap;\n', '\n', '  mapping (address => NewMoon) public proposedMoons;\n', '  address[] public proposedMoonsIndex;\n', '\n', '  address public verificationAddress;\n', '  address public purgeAddress;\n', '  address public tokenAddress;\n', '\n', '  address public lastVerified;\n', '\n', '//constructor\n', '\n', '  function MarbleEarth(address verificationMoon, address purgeMoon) public {\n', '\n', '    verificationMoon = verificationMoon;\n', '    purgeMoon = purgeMoon;\n', '\n', '  }\n', '\n', '  function proposeNewMoon(address mAddress, MoonType moonType) public  {\n', '    \n', '    if ((block.timestamp - proposedMoons[proposedMoonsIndex[0]].timeAdded) > 172800) {\n', '\n', '      delete proposedMoons[proposedMoonsIndex[0]];\n', '      delete proposedMoonsIndex[0];\n', '\n', '      }\n', '\n', '    if (proposedMoonsIndex.length >= 1000) {\n', '      return;\n', '      }\n', '\n', '      proposedMoons[mAddress] = NewMoon(block.timestamp, moonType, 1);\n', '      proposedMoonsIndex.push(mAddress);\n', '\n', '  }\n', '\n', '\n', '  function supportNewMoon(address newMoonAddress) public {\n', '\n', '    NewMoon storage newMoon = proposedMoons[newMoonAddress];\n', '\n', '    if (!newMoon.supportMap[msg.sender]) {\n', '      newMoon.supportMap[msg.sender] = true;\n', '      newMoon.votes++;\n', '      proposedMoons[newMoonAddress] = newMoon;\n', '    }\n', '\n', '    uint quotient = (newMoon.votes*100)/addresses.length;\n', '\n', '    if (quotient >= 67) {\n', '    \n', '      replaceNewMoon(newMoon, newMoonAddress);\n', '    }\n', '\n', '  }\n', '\n', '  function replaceNewMoon(NewMoon newMoon, address newMoonAddress) internal {\n', '\n', '      if (newMoon.moonType == MoonType.Verification) {\n', '       verificationAddress = newMoonAddress;\n', '      }\n', '\n', '      else if (newMoon.moonType == MoonType.Purge) {\n', '        purgeAddress = newMoonAddress;\n', '      }\n', '\n', '      delete proposedMoons[newMoonAddress]; \n', '\n', '  }\n', '\n', '  function proposePurge(address proposedAddress, bytes32 proof) public {\n', '\n', '    purgeContract = PurgeMoon(purgeAddress);\n', '    purgeContract.propose(proposedAddress, proof, addresses, identities);\n', '\n', '  }\n', '\n', '  function proposeVoter(bytes32 proof) public {\n', '\n', '    verificationContract = VerificationMoon(verificationAddress);\n', '    verificationContract.propose(msg.sender, proof, addresses, identities);\n', '\n', '  }\n', '\n', '  function addVoter(address voterAddress, address verifierAddress, bytes32 identity) public {\n', '    \n', '    if (msg.sender != verificationAddress)\n', '      return;\n', '\n', '    addresses.push(voterAddress);\n', '    identities.push(identity);\n', '    voterMap[voterAddress] = identity;\n', '\n', '    tokenContract = MRBLToken(tokenAddress);\n', '    tokenContract.transfer(voterAddress, newVoterAllocation());\n', '    tokenContract.transfer(verifierAddress, verifierAllocation());\n', '    lastVerified = voterAddress;\n', '\n', '  }\n', '\n', '  function getBalance() public returns (uint256) {\n', '        tokenContract = MRBLToken(tokenAddress);            \n', '        return tokenContract.getBalance(this);\n', '    }\n', '\n', '    function verifierAllocation() internal returns (uint) {\n', '     \n', '      uint contractBalance = getBalance();\n', '      return (-contractBalance*addresses.length/100000000000 + 2*contractBalance/10000000000)*1/5;\n', '\n', '    }\n', '\n', '  function newVoterAllocation() internal returns (uint) {\n', '            uint contractBalance = getBalance();\n', '           if (addresses.length < 1000000) {runLottery(contractBalance); }\n', '\n', '      return (-contractBalance*addresses.length/100000000000 + 2*contractBalance/10000000000)*4/5;\n', '\n', '  }\n', '\n', '  function runLottery(uint contractBalance) internal {\n', '\n', '            bytes32 blockHash = block.blockhash(block.number);\n', '            bytes32 randomHash = keccak256(lastVerified, blockHash);\n', '            uint hashNumber = uint(randomHash);\n', '     \n', '        if (addresses.length < 1000 && hashNumber < 2**246) {\n', '             tokenContract = MRBLToken(tokenAddress);\n', '             tokenContract.transfer(lastVerified, contractBalance/5);\n', '        }\n', '        else if (hashNumber < 2**236)  {\n', '             tokenContract = MRBLToken(tokenAddress);\n', '             tokenContract.transfer(lastVerified, contractBalance/5);\n', '       }\n', '\n', '  }\n', '\n', '  function purgeVoter(address purgedAddress, uint arrayIndex) public {\n', '    \n', '    if (msg.sender != purgeAddress)\n', '      return;\n', '\n', '    if (addresses[arrayIndex] != purgedAddress)\n', '      return;\n', '\n', '      delete addresses[arrayIndex];\n', '      delete identities[arrayIndex];\n', '      delete voterMap[purgedAddress];\n', '\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract VerificationMoon {\n', '  \n', '    struct NewVoter {\n', '\n', '\n', '      uint timeAdded;\n', '      uint64 votes;\n', '      bytes32 argument;\n', '      mapping (address => bool) supportMap;\n', '\n', '\n', '  }\n', '\n', '  address public marbleEarthAddress;\n', '  mapping (address => NewVoter) public proposedVoters;\n', '  uint16 public numberOfProposed;\n', '  address[] public voterAddresses;\n', '  bytes32[] public voterIdentities;\n', '\n', '  function propose(address selfProposed, bytes32 argument, address[] addresses, bytes32[] identities) public {\n', '\n', '    if (msg.sender != marbleEarthAddress)\n', '      return;\n', '\n', '    voterAddresses = addresses;\n', '    voterIdentities = identities;\n', '\n', '    if (addresses.length == 0) {\n', '        addVoter(selfProposed, selfProposed, argument);\n', '    }\n', '    else {\n', '\n', '    NewVoter memory newVoter;\n', '    newVoter.argument = argument;\n', '    newVoter.timeAdded = block.timestamp;\n', '    proposedVoters[selfProposed] = newVoter;\n', '\n', '    }\n', '\n', '  }\n', '\n', '  function addVoter(address verifiedAddress,address verifierAddress, bytes32 argument) internal {\n', '\n', '         MarbleEarth marbleEarth = MarbleEarth(marbleEarthAddress);\n', '         marbleEarth.addVoter(verifiedAddress, verifierAddress, argument);\n', '\n', '  }\n', '\n', '  function supportNewVoter(address _address) public {\n', '\n', '    if ((block.timestamp - proposedVoters[0].timeAdded) > 604800) {\n', '\n', '      delete proposedVoters[0];\n', '      numberOfProposed--;\n', '\n', '      }\n', '\n', '    if (numberOfProposed >= 1000) {\n', '\n', '      return;\n', '\n', '      }\n', '\n', '    if (!proposedVoters[_address].supportMap[msg.sender]) {\n', '      proposedVoters[_address].supportMap[msg.sender] = true;\n', '      proposedVoters[_address].votes++;\n', '      numberOfProposed++;\n', '\n', '    }\n', '\n', '    if (proposedVoters[_address].votes*100 / voterAddresses.length > 50) {\n', '\n', '        addVoter(_address, msg.sender, proposedVoters[_address].argument);\n', '        delete proposedVoters[_address];\n', '        numberOfProposed--;\n', '\n', '    }\n', '  }\n', '}\n', '\n', 'contract PurgeMoon {\n', '  \n', '    struct NewPurge {\n', '\n', '      uint timeAdded;\n', '      uint64 votes;\n', '      bytes32 argument;\n', '      mapping (address => bool) supportMap;\n', '\n', '  }\n', '\n', '  address public marbleEarthAddress;\n', '  mapping (address => NewPurge) public proposedPurges;\n', '  uint16 public numberOfProposed;\n', '  address[] public voterAddresses;\n', '  bytes32[] public voterIdentities;\n', '\n', '  function propose(address proposed, bytes32 argument, address[] addresses, bytes32[] identities) public {\n', '\n', '    if (msg.sender != marbleEarthAddress)\n', '      return;\n', '\n', '    voterAddresses = addresses;\n', '    voterIdentities = identities;\n', '\n', '    NewPurge memory newPurge;\n', '    newPurge.argument = argument;\n', '    newPurge.timeAdded = block.timestamp;\n', '    proposedPurges[proposed] = newPurge;\n', '\n', '  }\n', '\n', '  function purgeVoter(address purgedAddress, uint arrayIndex) internal {\n', '\n', '         MarbleEarth marbleEarth = MarbleEarth(marbleEarthAddress);\n', '         marbleEarth.purgeVoter(purgedAddress, arrayIndex);\n', '\n', '  }\n', '\n', '  function supportNewPurge(address _address, uint arrayIndex) public {\n', '\n', '    if ((block.timestamp - proposedPurges[0].timeAdded) > 604800) {\n', '\n', '      delete proposedPurges[0];\n', '      numberOfProposed--;\n', '\n', '      }\n', '\n', '    if (numberOfProposed >= 1000) {\n', '\n', '      return;\n', '\n', '      }\n', '\n', '    if (!proposedPurges[_address].supportMap[msg.sender]) {\n', '      proposedPurges[_address].supportMap[msg.sender] = true;\n', '      proposedPurges[_address].votes++;\n', '      numberOfProposed++;\n', '\n', '    }\n', '\n', '    if (proposedPurges[_address].votes*100 / voterAddresses.length > 50) {\n', '\n', '        purgeVoter(_address, arrayIndex);\n', '        delete proposedPurges[_address];\n', '        numberOfProposed--;\n', '\n', '    }\n', '  }\n', '}\n', '\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract MRBLToken {\n', '    string public name = "Marble";\n', '    string public symbol = "MRBL";\n', '    uint256 public decimals = 18;\n', '    uint256 public totalSupply = 100*1000*1000*1000*10**decimals;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function MRBLToken() public {\n', '        balanceOf[msg.sender] = totalSupply;                \n', '    }\n', '\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function getBalance(address _address) view public returns (uint256) {\n', '        return balanceOf[_address];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] -= _value;            \n', '        totalSupply -= _value;                      \n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                \n', '        require(_value <= allowance[_from][msg.sender]);    \n', '        balanceOf[_from] -= _value;                         \n', '        allowance[_from][msg.sender] -= _value;             \n', '        totalSupply -= _value;                              \n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']