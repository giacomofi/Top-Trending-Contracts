['/*\n', 'This Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', 'This Contract is distributed WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', 'You should have received a copy of the GNU lesser General Public License\n', '<http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract InterfaceERC20Token\n', '{\n', '    function balanceOf (address tokenOwner) public constant returns (uint balance);\n', '    function transfer (address to, uint tokens) public returns (bool success);\n', '    function allowance (address _owner, address _spender) public constant returns (uint remaining);\n', '    function transferFrom (address _from, address _to, uint _value) public returns (bool success);\n', '}\n', '\n', 'contract LittleStoreERC20Token\n', '{\n', '\n', '    mapping (address => bool) public agents;\n', '    address public addressERC20Token;\n', '    InterfaceERC20Token internal ERC20Token;\n', '\n', '    bool public sale;\n', '    uint public price;\n', '    uint public bonusLine;\n', '    uint public bonusSize;\n', '\n', '    event ChangePermission (address indexed _called, address indexed _to, bool _permission);\n', '    event ChangeSaleSettings (address indexed _called, address indexed _token, uint _price, uint _bonusLine, uint _bonusSize);\n', '    event Buy (address indexed _called, address indexed _token, uint _count, uint _bonusCount, uint _value);\n', '    event Donate (address indexed _from, uint _value);\n', '\n', '    function LittleStoreERC20Token () public\n', '    {\n', '        agents[msg.sender] = true;\n', '        sale = true;\n', '    }\n', '\n', '    modifier onlyAdministrators ()\n', '    {\n', '        require (agents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function changePermission (address _agent, bool _permission) public onlyAdministrators ()\n', '    {\n', '        if (msg.sender != _agent)\n', '        {\n', '            agents[_agent] = _permission;\n', '            ChangePermission (msg.sender, _agent, _permission);\n', '        }\n', '    }\n', '\n', '    function changeSaleSettings (address _addressERC20Token, uint _priceGwei, uint _bonusLine, uint _bonusSize) public onlyAdministrators ()\n', '    {\n', '        addressERC20Token = _addressERC20Token;\n', '        ERC20Token = InterfaceERC20Token (_addressERC20Token);\n', '        price = _priceGwei * 1000000000; //calculation of gwei in wei\n', '        bonusLine = _bonusLine;\n', '        bonusSize = _bonusSize;\n', '        ChangeSaleSettings (msg.sender, _addressERC20Token, _priceGwei * 1000000000, _bonusLine, _bonusSize);\n', '    }\n', '\n', '    function saleValve (bool _sale) public onlyAdministrators ()\n', '    {\n', '        sale = _sale;\n', '    }\n', '\n', '    function allowanceTransfer () public onlyAdministrators ()\n', '    {\n', '        ERC20Token.transferFrom (msg.sender, this, ERC20Token.allowance (msg.sender, this));\n', '    }\n', '\n', '    function withdrawalToken (address _to) public onlyAdministrators ()\n', '    {\n', '        ERC20Token.transfer (_to, ERC20Token.balanceOf (this));\n', '    }\n', '\n', '    function withdrawal (address _to) public onlyAdministrators ()\n', '    {\n', '        _to.transfer (this.balance);\n', '    }\n', '    \n', '    function destroy (address _to) public onlyAdministrators ()\n', '    {\n', '        withdrawalToken (_to);\n', '        selfdestruct (_to);\n', '    }\n', '\n', '    function totalSale () public constant returns (uint)\n', '    {\n', '        return ERC20Token.balanceOf (this); \n', '    }\n', '\n', '    function () payable\n', '    {\n', '       Donate (msg.sender, msg.value);\n', '    }\n', '\n', '    function buy () payable\n', '    {\n', '        uint thisBalance = ERC20Token.balanceOf (this);\n', '        require (thisBalance > 0 && sale);\n', '        \n', '        uint countToken;\n', '        uint countBonusToken;\n', '        \n', '        countToken = msg.value / price;\n', '        require (countToken > 0);\n', '        \n', '        if (thisBalance > countToken)\n', '        {\n', '            thisBalance -= countToken;\n', '            countBonusToken = (countToken / bonusLine) * bonusSize;\n', '            \n', '            if (countBonusToken > 0 && thisBalance <= countBonusToken)\n', '            {\n', '                countBonusToken = thisBalance;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            countToken = thisBalance;\n', '        }\n', '            \n', '        require (ERC20Token.transfer (msg.sender, countToken + countBonusToken));\n', '        msg.sender.transfer (msg.value - (countToken * price));\n', '        Buy (msg.sender, addressERC20Token, countToken, countBonusToken, msg.value);\n', '    }\n', '}']
['/*\n', 'This Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', 'This Contract is distributed WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', 'You should have received a copy of the GNU lesser General Public License\n', '<http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract InterfaceERC20Token\n', '{\n', '    function balanceOf (address tokenOwner) public constant returns (uint balance);\n', '    function transfer (address to, uint tokens) public returns (bool success);\n', '    function allowance (address _owner, address _spender) public constant returns (uint remaining);\n', '    function transferFrom (address _from, address _to, uint _value) public returns (bool success);\n', '}\n', '\n', 'contract LittleStoreERC20Token\n', '{\n', '\n', '    mapping (address => bool) public agents;\n', '    address public addressERC20Token;\n', '    InterfaceERC20Token internal ERC20Token;\n', '\n', '    bool public sale;\n', '    uint public price;\n', '    uint public bonusLine;\n', '    uint public bonusSize;\n', '\n', '    event ChangePermission (address indexed _called, address indexed _to, bool _permission);\n', '    event ChangeSaleSettings (address indexed _called, address indexed _token, uint _price, uint _bonusLine, uint _bonusSize);\n', '    event Buy (address indexed _called, address indexed _token, uint _count, uint _bonusCount, uint _value);\n', '    event Donate (address indexed _from, uint _value);\n', '\n', '    function LittleStoreERC20Token () public\n', '    {\n', '        agents[msg.sender] = true;\n', '        sale = true;\n', '    }\n', '\n', '    modifier onlyAdministrators ()\n', '    {\n', '        require (agents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function changePermission (address _agent, bool _permission) public onlyAdministrators ()\n', '    {\n', '        if (msg.sender != _agent)\n', '        {\n', '            agents[_agent] = _permission;\n', '            ChangePermission (msg.sender, _agent, _permission);\n', '        }\n', '    }\n', '\n', '    function changeSaleSettings (address _addressERC20Token, uint _priceGwei, uint _bonusLine, uint _bonusSize) public onlyAdministrators ()\n', '    {\n', '        addressERC20Token = _addressERC20Token;\n', '        ERC20Token = InterfaceERC20Token (_addressERC20Token);\n', '        price = _priceGwei * 1000000000; //calculation of gwei in wei\n', '        bonusLine = _bonusLine;\n', '        bonusSize = _bonusSize;\n', '        ChangeSaleSettings (msg.sender, _addressERC20Token, _priceGwei * 1000000000, _bonusLine, _bonusSize);\n', '    }\n', '\n', '    function saleValve (bool _sale) public onlyAdministrators ()\n', '    {\n', '        sale = _sale;\n', '    }\n', '\n', '    function allowanceTransfer () public onlyAdministrators ()\n', '    {\n', '        ERC20Token.transferFrom (msg.sender, this, ERC20Token.allowance (msg.sender, this));\n', '    }\n', '\n', '    function withdrawalToken (address _to) public onlyAdministrators ()\n', '    {\n', '        ERC20Token.transfer (_to, ERC20Token.balanceOf (this));\n', '    }\n', '\n', '    function withdrawal (address _to) public onlyAdministrators ()\n', '    {\n', '        _to.transfer (this.balance);\n', '    }\n', '    \n', '    function destroy (address _to) public onlyAdministrators ()\n', '    {\n', '        withdrawalToken (_to);\n', '        selfdestruct (_to);\n', '    }\n', '\n', '    function totalSale () public constant returns (uint)\n', '    {\n', '        return ERC20Token.balanceOf (this); \n', '    }\n', '\n', '    function () payable\n', '    {\n', '       Donate (msg.sender, msg.value);\n', '    }\n', '\n', '    function buy () payable\n', '    {\n', '        uint thisBalance = ERC20Token.balanceOf (this);\n', '        require (thisBalance > 0 && sale);\n', '        \n', '        uint countToken;\n', '        uint countBonusToken;\n', '        \n', '        countToken = msg.value / price;\n', '        require (countToken > 0);\n', '        \n', '        if (thisBalance > countToken)\n', '        {\n', '            thisBalance -= countToken;\n', '            countBonusToken = (countToken / bonusLine) * bonusSize;\n', '            \n', '            if (countBonusToken > 0 && thisBalance <= countBonusToken)\n', '            {\n', '                countBonusToken = thisBalance;\n', '            }\n', '        }\n', '        else\n', '        {\n', '            countToken = thisBalance;\n', '        }\n', '            \n', '        require (ERC20Token.transfer (msg.sender, countToken + countBonusToken));\n', '        msg.sender.transfer (msg.value - (countToken * price));\n', '        Buy (msg.sender, addressERC20Token, countToken, countBonusToken, msg.value);\n', '    }\n', '}']
