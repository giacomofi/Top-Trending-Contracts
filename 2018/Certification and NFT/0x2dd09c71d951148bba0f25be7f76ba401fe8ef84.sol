['pragma solidity ^0.4.18;\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '---------------------------------------------------------------------------------------------\n', 'GoToken, a highly scalable, low cost mobile first network infrastructure for Ethereum\n', '---------------------------------------------------------------------------------------------\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', 'contract Token {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    ERC20 Token standard implementation\n', '    https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '    https://github.com/ethereum/EIPs/issues/20\n', '\n', '    We didn&#39;t implement a separate totalsupply() function. Instead the public variable\n', '    totalSupply will automatically create a getter function to access the supply\n', '    of the token.\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    uint256 public totalSupply;\n', '\n', '/*\n', '    ERC20 Token Model\n', '*/\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _who, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _who) public constant returns (uint256 remaining);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', '/// @title Standard token contract - Standard token implementation.\n', 'contract StandardToken is Token {\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Storage data structures\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @notice Send "_value" tokens to "_to" from "msg.sender".\n', '    /// @dev Transfers sender&#39;s tokens to a given address. Returns success.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer "_value" tokens from "_from" to "_to" if "msg.sender" is allowed.\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n', '    {\n', '        //Address shouldn&#39;t be null\n', '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approves "_who" to transfer "_value" tokens from "msg.sender" to any address.\n', '    /// @dev Sets approved amount of tokens for the spender. Returns success.\n', '    /// @param _who Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _who, uint256 _value) public returns (bool) {\n', '\n', '        // Address shouldn&#39;t be null\n', '        require(_who != 0x0);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_who, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require(_value == 0 || allowed[msg.sender][_who] == 0);\n', '\n', '        allowed[msg.sender][_who] = _value;\n', '        Approval(msg.sender, _who, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _who Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _who) constant public returns (uint256)\n', '    {\n', '        return allowed[_owner][_who];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by a given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '\n', '/// @title GoToken, a highly scalable, low cost mobile first network infrastructure for Ethereum\n', 'contract GoToken is StandardToken {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '      All GoToken balances are transferable.\n', '      Token name, ticker symbol and decimals\n', '      1 token (GOT) = 1 indivisible unit * multiplier\n', '      The multiplier is set dynamically from token&#39;s number of decimals (i.e. 10 ** decimals)\n', '\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Storage data structures\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    string constant public name = "GoToken";\n', '    string constant public symbol = "GOT";\n', '    uint256 constant public decimals = 18;\n', '    uint256 constant multiplier = 10 ** (decimals);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    event Deployed(uint256 indexed _total_supply);\n', '    //event Burnt(address indexed _receiver, uint256 indexed _num, uint256 indexed _total_supply);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @dev GoToken Contract constructor function sets GoToken dutch auction\n', '    /// contract address and assigns the tokens to the auction.\n', '    /// @param auction_address Address of dutch auction contract.\n', '    /// @param wallet_address Address of wallet.\n', '    /// @param initial_supply Number of initially provided token units (indivisible units).\n', '    function GoToken(address auction_address, address wallet_address, uint256 initial_supply) public\n', '    {\n', '        // Auction address should not be null.\n', '        require(auction_address != 0x0);\n', '        require(wallet_address != 0x0);\n', '\n', '        // Initial supply is in indivisible units e.g. 50e24\n', '        require(initial_supply > multiplier);\n', '\n', '        // Total supply of indivisible GOT units at deployment\n', '        totalSupply = initial_supply;\n', '\n', '        // preallocation\n', '        balances[auction_address] = initial_supply / 2;\n', '        balances[wallet_address] = initial_supply / 2;\n', '\n', '        // Record the events\n', '        Transfer(0x0, auction_address, balances[auction_address]);\n', '        Transfer(0x0, wallet_address, balances[wallet_address]);\n', '\n', '        Deployed(totalSupply);\n', '\n', '        assert(totalSupply == balances[auction_address] + balances[wallet_address]);\n', '    }\n', '\n', '}\n', '\n', '\n', '/// @title GoToken Uniform Price Dutch auction contract - distribution of a fixed\n', '/// number of tokens using second price auction, where everybody gets the same final\n', '/// price when the auction ends i.e. the ending bid becomes the finalized\n', '/// price per token for all participants.\n', 'contract GoTokenDutchAuction {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    GoToken Uniform Price Dutch auction contract - distribution of a fixed\n', '    number of tokens using seconprice auction, where everybody gets the lowest\n', '    price when the auction ends i.e. the ending bid becomes the finalized\n', '    price per token. This is the mechanism for price discovery.\n', '\n', '    The uniform price Dutch auction is set up to discover a fair price for a\n', '    fixed amount of GOT tokens. It starts with a very high price which\n', '    continuously declines with every block over time, based on a predefined\n', '    formula. After the auction is started, participants can send in ETH to bid.\n', '    The auction ends once the price multiplied with the number of offered tokens\n', '    equals the total ETH amount sent to the auction. All participants receive\n', '    their tokens at the same final price.\n', '\n', '    The main goals of the auction are to enable everyone to participate while\n', '    offering certainty about the maximum total value of all tokens at the time\n', '    of the bid.\n', '\n', '    All token balances are transferable.\n', '    Token name, ticker symbol and decimals\n', '    1 token (GOT) = 1 indivisible unit * multiplier\n', '    multiplier set from token&#39;s number of decimals (i.e. 10 ** decimals)\n', '\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Data structures for Storage\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    GoToken public token;\n', '    address public owner_address;\n', '    address public wallet_address;\n', '    address public whitelister_address;\n', '    address public distributor_address;\n', '\n', '    // Minimum bid value during the auction\n', '    uint256 constant public bid_threshold = 10 finney;\n', '\n', '    // Maximum contribution per ETH address during public sale\n', '    //uint256 constant public MAX_CONTRIBUTION_PUBLICSALE = 20 ether;\n', '\n', '    // token multiplied derived out of decimals\n', '    uint256 public token_multiplier;\n', '\n', '    // Total number of indivisible GoTokens (GOT * token_multiplier) that will be auctioned\n', '    uint256 public num_tokens_auctioned;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Price decay function parameters to be changed depending on the desired outcome\n', '    This is modeled based on composite exponentially decaying curve auction price model.\n', '    The price curves are mathematically modeled per the business needs. There are two\n', '    exponentially decaying curves for teh auction: curve 1 is for teh first eight days\n', '    and curve 2 is for the remaining days until the auction is finalized.\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    // Starting price in WEI; e.g. 2 * 10 ** 18\n', '    uint256 public price_start;\n', '\n', '    uint256 constant public CURVE_CUTOFF_DURATION = 8 days;\n', '\n', '    // Price constant for first eight days of the price curve; e.g. 1728\n', '    uint256 public price_constant1;\n', '\n', '    // Price exponent for first eight days of the price curve; e.g. 2\n', '    uint256 public price_exponent1;\n', '\n', '    // Price constant for eight plus days of the price curve; e.g. 1257\n', '    uint256 public price_constant2;\n', '\n', '    // Price exponent for eight plus days of the price curve; e.g. 2\n', '    uint256 public price_exponent2;\n', '\n', '    // For private sale start time (same as auction deployement time)\n', '    uint256 public privatesale_start_time;\n', '\n', '    // For calculating elapsed time for price auction\n', '    uint256 public auction_start_time;\n', '    uint256 public end_time;\n', '    uint256 public start_block;\n', '\n', '    // All ETH received from the bids\n', '    uint256 public received_wei;\n', '    uint256 public received_wei_with_bonus;\n', '\n', '    // Cumulative ETH funds for which the tokens have been claimed\n', '    uint256 public funds_claimed;\n', '\n', '    // Wei per token (GOT * token_multiplier)\n', '    uint256 public final_price;\n', '\n', '    struct Account {\n', '  \t\tuint256 accounted;\t// bid value including bonus\n', '  \t\tuint256 received;\t// the amount received, without bonus\n', '  \t}\n', '\n', '    // Address of the Bidder => bid value\n', '    mapping (address => Account) public bids;\n', '\n', '    // privatesalewhitelist for private ETH addresses\n', '    mapping (address => bool) public privatesalewhitelist;\n', '\n', '    // publicsalewhitelist for addresses that want to bid in public sale excluding private sale accounts\n', '    mapping (address => bool) public publicsalewhitelist;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Bonus tiers\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    // Maximum duration after sale begins that 15% bonus is active.\n', '  \tuint256 constant public BONUS_DAY1_DURATION = 24 hours; ///24 hours;\n', '\n', '  \t// Maximum duration after sale begins that 10% bonus is active.\n', '  \tuint256 constant public BONUS_DAY2_DURATION = 48 hours; ///48 hours;\n', '\n', '  \t// Maximum duration after sale begins that 5% bonus is active.\n', '  \tuint256 constant public BONUS_DAY3_DURATION = 72 hours; ///72 hours;\n', '\n', '    // The current percentage of bonus that contributors get.\n', '  \tuint256 public currentBonus = 0;\n', '\n', '    // Waiting time in days before a participant can claim tokens after the end of the auction\n', '    uint256 constant public TOKEN_CLAIM_WAIT_PERIOD = 0 days;\n', '\n', '    // Keep track of stages during the auction and contract deployment process\n', '    Stages public stage;\n', '\n', '    enum Stages {\n', '        AuctionDeployed,\n', '        AuctionSetUp,\n', '        AuctionStarted,\n', '        AuctionEnded,\n', '        TokensDistributed\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Modifiers\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    // State of the auction\n', '    modifier atStage(Stages _stage) {\n', '        require(stage == _stage);\n', '        _;\n', '    }\n', '\n', '    // Only owner of the contract\n', '    modifier isOwner() {\n', '        require(msg.sender == owner_address);\n', '        _;\n', '    }\n', '\n', '    // Only who is allowed to whitelist the participant ETH addresses (specified\n', '    // during the contract deployment)\n', '    modifier isWhitelister() {\n', '        require(msg.sender == whitelister_address);\n', '        _;\n', '    }\n', '\n', '    // Only who is allowed to distribute the GOT to the participant ETH addresses (specified\n', '    // during the contract deployment)\n', '    modifier isDistributor() {\n', '        require(msg.sender == distributor_address);\n', '        _;\n', '    }\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    event Deployed(uint256 indexed _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256  _price_constant2, uint256 _price_exponent2);\n', '    event Setup();\n', '    event AuctionStarted(uint256 indexed _auction_start_time, uint256 indexed _block_number);\n', '    event BidSubmission(address indexed _sender,uint256 _amount, uint256 _amount_with_bonus, uint256 _remaining_funds_to_end_auction);\n', '    event ClaimedTokens(address indexed _recipient, uint256 _sent_amount);\n', '    event AuctionEnded(uint256 _final_price);\n', '    event TokensDistributed();\n', '\n', '    /// whitelisting events for private sale and public sale ETH addresses\n', '  \tevent PrivateSaleWhitelisted(address indexed who);\n', '    event RemovedFromPrivateSaleWhitelist(address indexed who);\n', '    event PublicSaleWhitelisted(address indexed who);\n', '    event RemovedFromPublicSaleWhitelist(address indexed who);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @dev GoToken Contract constructor function sets the starting price,\n', '    /// price constant and price exponent for calculating the Dutch Auction price.\n', '    /// @param _wallet_address Wallet address to which all contributed ETH will be forwarded.\n', '    function GoTokenDutchAuction(\n', '        address _wallet_address,\n', '        address _whitelister_address,\n', '        address _distributor_address,\n', '        uint256 _price_start,\n', '        uint256 _price_constant1,\n', '        uint256 _price_exponent1,\n', '        uint256 _price_constant2,\n', '        uint256 _price_exponent2)\n', '        public\n', '    {\n', '        // Address shouldn&#39;t be null\n', '        require(_wallet_address != 0x0);\n', '        require(_whitelister_address != 0x0);\n', '        require(_distributor_address != 0x0);\n', '        wallet_address = _wallet_address;\n', '        whitelister_address = _whitelister_address;\n', '        distributor_address = _distributor_address;\n', '\n', '        owner_address = msg.sender;\n', '        stage = Stages.AuctionDeployed;\n', '        changePriceCurveSettings(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n', '        Deployed(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n', '    }\n', '\n', '    /// @dev Fallback function for the contract, which calls bid()\n', '    function () public payable {\n', '        bid();\n', '    }\n', '\n', '    /// @notice Set "_token_address" as the token address to be used in the auction.\n', '    /// @dev Setup function sets external contracts addresses.\n', '    /// @param _token_address Token address.\n', '    function setup(address _token_address) public isOwner atStage(Stages.AuctionDeployed) {\n', '        require(_token_address != 0x0);\n', '        token = GoToken(_token_address);\n', '\n', '        // Get number of GoToken indivisible tokens (GOT * token_multiplier)\n', '        // to be auctioned from token auction balance\n', '        num_tokens_auctioned = token.balanceOf(address(this));\n', '\n', '        // Set the number of the token multiplier for its decimals\n', '        token_multiplier = 10 ** (token.decimals());\n', '\n', '        // State is set to Auction Setup\n', '        stage = Stages.AuctionSetUp;\n', '        Setup();\n', '    }\n', '\n', '    /// @notice Set "_price_start", "_price_constant1" and "_price_exponent1"\n', '    ///  "_price_constant2" and "_price_exponent2" as\n', '    /// the new starting price, price constant and price exponent for the auction price.\n', '    /// @dev Changes auction price function parameters before auction is started.\n', '    /// @param _price_start Updated start price.\n', '    /// @param _price_constant1 Updated price divisor constant.\n', '    /// @param _price_exponent1 Updated price divisor exponent.\n', '    /// @param _price_constant2 Updated price divisor constant.\n', '    /// @param _price_exponent2 Updated price divisor exponent.\n', '    function changePriceCurveSettings(\n', '        uint256 _price_start,\n', '        uint256 _price_constant1,\n', '        uint256 _price_exponent1,\n', '        uint256 _price_constant2,\n', '        uint256 _price_exponent2)\n', '        internal\n', '    {\n', '        // You can change the price curve settings only when either the auction is Deployed\n', '        // or the auction is setup. You can&#39;t change during the auction is running or ended.\n', '        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);\n', '        require(_price_start > 0);\n', '        require(_price_constant1 > 0);\n', '        require(_price_constant2 > 0);\n', '\n', '        price_start = _price_start;\n', '        price_constant1 = _price_constant1;\n', '        price_exponent1 = _price_exponent1;\n', '        price_constant2 = _price_constant2;\n', '        price_exponent2 = _price_exponent2;\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Functions related to whitelisting of presale and public sale ETH addresses.\n', '    The Whitelister must add the participant&#39;s ETH address before they can bid.\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    // @notice Adds account addresses to public sale ETH whitelist.\n', '    // @dev Adds account addresses to public sale ETH whitelist.\n', '    // @param _bidder_addresses Array of addresses. Use double quoted array.\n', '    function addToPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '            require(!privatesalewhitelist[_bidder_addresses[i]]); //Can&#39;t be in public whitelist\n', '            publicsalewhitelist[_bidder_addresses[i]] = true;\n', '            PublicSaleWhitelisted(_bidder_addresses[i]);\n', '        }\n', '    }\n', '\n', '    // @notice Removes account addresses from public sale ETH whitelist.\n', '    // @dev Removes account addresses from public sale ETH whitelist.\n', '    // @param _bidder_addresses Array of addresses.  Use double quoted array.\n', '    function removeFromPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '            publicsalewhitelist[_bidder_addresses[i]] = false;\n', '            RemovedFromPublicSaleWhitelist(_bidder_addresses[i]);\n', '        }\n', '    }\n', '\n', '    // Private sale contributors whitelist. Only Admin can add or remove\n', '\n', '  \t// @notice Adds presale account addresses to privatesalewhitelist.\n', '    // @ Admin Adds presale account addresses to privatesalewhitelist.\n', '    // @param _bidder_addresses Array of addresses.\n', '    function addToPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '              privatesalewhitelist[_bidder_addresses[i]] = true;\n', '  \t\t\t\t\t\tPrivateSaleWhitelisted(_bidder_addresses[i]);\n', '          }\n', '      }\n', '\n', '      // @notice Removes presale account addresses from privatesalewhitelist.\n', '      // @ Admin Removes presale account addresses from privatesalewhitelist.\n', '      // @param _bidder_addresses Array of addresses.\n', '      function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n', '          for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '              privatesalewhitelist[_bidder_addresses[i]] = false;\n', '  \t\t\t\t\t\tRemovedFromPrivateSaleWhitelist(_bidder_addresses[i]);\n', '          }\n', '      }\n', '\n', '    // @notice Start the auction.\n', '    // @dev Starts auction and sets auction_start_time.\n', '    function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\n', '        stage = Stages.AuctionStarted;\n', '        auction_start_time = now;\n', '        start_block = block.number;\n', '        AuctionStarted(auction_start_time, start_block);\n', '    }\n', '\n', '    /// @notice Send "msg.value" WEI to the auction from the "msg.sender" account.\n', '    /// @dev Allows to send a bid to the auction.\n', '    function bid() public payable\n', '    {\n', '        // Address shouldn&#39;t be null and the minimum bid amount of contribution is met.\n', '        // Private sale contributor can submit a bid at AuctionSetUp before AuctionStarted\n', '        // When AuctionStarted only private sale and public sale whitelisted ETH addresses can participate\n', '        require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n', '        require(privatesalewhitelist[msg.sender] || publicsalewhitelist[msg.sender]);\n', '        if (stage == Stages.AuctionSetUp){\n', '          require(privatesalewhitelist[msg.sender]);\n', '        }\n', '        require(msg.value > 0);\n', '        require(bids[msg.sender].received + msg.value >= bid_threshold);\n', '        assert(bids[msg.sender].received + msg.value >= msg.value);\n', '\n', '        // Maximum public sale contribution per ETH account\n', '        //if (stage == Stages.AuctionStarted && publicsalewhitelist[msg.sender]) {\n', '        //  require (bids[msg.sender].received + msg.value <= MAX_CONTRIBUTION_PUBLICSALE);\n', '        //}\n', '\n', '        // Remaining funds without the current bid value to end the auction\n', '        uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction();\n', '\n', '        // The bid value must be less than the funds remaining to end the auction\n', '        // at the current price.\n', '        require(msg.value <= remaining_funds_to_end_auction);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '        Bonus period settings\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '        //Private sale bids before Auction starts\n', '        if (stage == Stages.AuctionSetUp){\n', '          require(privatesalewhitelist[msg.sender]);\n', '          currentBonus = 25; //private sale bonus before AuctionStarted\n', '        }\n', '        else if (stage == Stages.AuctionStarted) {\n', '          // private sale contributors bonus period settings\n', '      \t\tif (privatesalewhitelist[msg.sender] && now >= auction_start_time  && now < auction_start_time + BONUS_DAY1_DURATION) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 1 bonus\n', '      \t\t}\n', '          else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 2 bonus\n', '      \t\t}\n', '      \t\telse if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 3 bonus\n', '      \t\t}\n', '          else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n', '              currentBonus = 25; //private sale contributor Day 4+ bonus\n', '          }\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time  && now < auction_start_time + BONUS_DAY1_DURATION) {\n', '      \t\t\t\tcurrentBonus = 15; //private sale contributor Day 1 bonus\n', '      \t\t}\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n', '      \t\t\t\tcurrentBonus = 10; //private sale contributor Day 2 bonus\n', '      \t\t}\n', '      \t\telse if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n', '      \t\t\t\tcurrentBonus = 5; //private sale contributor Day 3 bonus\n', '      \t\t}\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n', '              currentBonus = 0; //private sale contributor Day 4+ bonus\n', '          }\n', '      \t\telse {\n', '      \t\t\t\tcurrentBonus = 0;\n', '      \t\t}\n', '        }\n', '        else {\n', '          currentBonus = 0;\n', '        }\n', '\n', '        // amount raised including bonus\n', '        uint256 accounted = msg.value + msg.value * (currentBonus) / 100;\n', '\n', '        // Save the bid amount received with and without bonus.\n', '    \t\tbids[msg.sender].accounted += accounted; //including bonus\n', '    \t\tbids[msg.sender].received += msg.value;\n', '\n', '        // keep track of total amount raised and with bonus\n', '        received_wei += msg.value;\n', '        received_wei_with_bonus += accounted;\n', '\n', '        // Send bid amount to wallet\n', '        wallet_address.transfer(msg.value);\n', '\n', '        //Log the bid\n', '        BidSubmission(msg.sender, msg.value, accounted, remaining_funds_to_end_auction);\n', '\n', '        assert(received_wei >= msg.value);\n', '        assert(received_wei_with_bonus >= accounted);\n', '    }\n', '\n', '    // @notice Finalize the auction - sets the final GoToken price and\n', '    // changes the auction stage after no bids are allowed. Only owner can finalize the auction.\n', '    // The owner can end the auction anytime after either the auction is deployed or started.\n', '    // @dev Finalize auction and set the final GOT token price.\n', '    function finalizeAuction() public isOwner\n', '    {\n', '        // The owner can end the auction anytime during the stages\n', '        // AuctionSetUp and AuctionStarted\n', '        require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n', '\n', '        // Calculate the final price = WEI / (GOT / token_multiplier)\n', '        final_price = token_multiplier * received_wei_with_bonus / num_tokens_auctioned;\n', '\n', '        // End the auction\n', '        end_time = now;\n', '        stage = Stages.AuctionEnded;\n', '        AuctionEnded(final_price);\n', '\n', '        assert(final_price > 0);\n', '    }\n', '\n', '    // @notice Distribute GoTokens for "receiver_address" after the auction has ended by the owner.\n', '    // @dev Distribute GoTokens for "receiver_address" after auction has ended by the owner.\n', '    // @param receiver_address GoTokens will be assigned to this address if eligible.\n', '    function distributeGoTokens(address receiver_address)\n', '        public isDistributor atStage(Stages.AuctionEnded) returns (bool)\n', '    {\n', '        // Waiting period in days after the end of the auction, before anyone can claim GoTokens.\n', '        // Ensures enough time to check if auction was finalized correctly\n', '        // before users start transacting tokens\n', '        require(now > end_time + TOKEN_CLAIM_WAIT_PERIOD);\n', '        require(receiver_address != 0x0);\n', '        require(bids[receiver_address].received > 0);\n', '\n', '        if (bids[receiver_address].received == 0 || bids[receiver_address].accounted == 0) {\n', '            return false;\n', '        }\n', '\n', '        // Number of GOT = bid_wei_with_bonus / (wei_per_GOT * token_multiplier)\n', '        // Includes the bonus\n', '        uint256 num = (token_multiplier * bids[receiver_address].accounted) / final_price;\n', '\n', '        // Due to final_price rounding, the number of assigned tokens may be higher\n', '        // than expected. Therefore, the number of remaining unassigned auction tokens\n', '        // may be smaller than the number of tokens needed for the last claimTokens call\n', '        uint256 auction_tokens_balance = token.balanceOf(address(this));\n', '        if (num > auction_tokens_balance) {\n', '            num = auction_tokens_balance;\n', '        }\n', '\n', '        // Update the total amount of funds for which tokens have been claimed\n', '        funds_claimed += bids[receiver_address].received;\n', '\n', '        // Set receiver bid to 0 before assigning tokens\n', '        bids[receiver_address].accounted = 0;\n', '        bids[receiver_address].received = 0;\n', '\n', '        // Send the GoTokens to the receiver address including the qualified bonus\n', '        require(token.transfer(receiver_address, num));\n', '\n', '        // Log the event for claimed GoTokens\n', '        ClaimedTokens(receiver_address, num);\n', '\n', '        // After the last tokens are claimed, change the auction stage\n', '        // Due to the above logic described, rounding errors will not be an issue here.\n', '        if (funds_claimed == received_wei) {\n', '            stage = Stages.TokensDistributed;\n', '            TokensDistributed();\n', '        }\n', '\n', '        assert(token.balanceOf(receiver_address) >= num);\n', '        assert(bids[receiver_address].accounted == 0);\n', '        assert(bids[receiver_address].received == 0);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Get the GOT price in WEI during the auction, at the time of\n', '    /// calling this function. Returns 0 if auction has ended.\n', '    /// Returns "price_start" before auction has started.\n', '    /// @dev Calculates the current GOT token price in WEI.\n', '    /// @return Returns WEI per indivisible GOT (token_multiplier * GOT).\n', '    function price() public constant returns (uint256) {\n', '        if (stage == Stages.AuctionEnded ||\n', '            stage == Stages.TokensDistributed) {\n', '            return 0;\n', '        }\n', '        return calcTokenPrice();\n', '    }\n', '\n', '    /// @notice Get the remaining funds needed to end the auction, calculated at\n', '    /// the current GOT price in WEI.\n', '    /// @dev The remaining funds necessary to end the auction at the current GOT price in WEI.\n', '    /// @return Returns the remaining funds to end the auction in WEI.\n', '    function remainingFundsToEndAuction() constant public returns (uint256) {\n', '\n', '        // num_tokens_auctioned = total number of indivisible GOT (GOT * token_multiplier) that is auctioned\n', '        uint256 required_wei_at_price = num_tokens_auctioned * price() / token_multiplier;\n', '        if (required_wei_at_price <= received_wei) {\n', '            return 0;\n', '        }\n', '\n', '        return required_wei_at_price - received_wei;\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Private function for calcuclating current token price\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    // @dev Calculates the token price (WEI / GOT) at the current timestamp\n', '    // during the auction; elapsed time = 0 before auction starts.\n', '    // This is a composite exponentially decaying curve (two curves combined).\n', '    // The curve 1 is for the first 8 days and the curve 2 is for the remaining days.\n', '    // They are of the form:\n', '    //         current_price  = price_start * (1 + elapsed) / (1 + elapsed + decay_rate);\n', '    //          where, decay_rate = elapsed ** price_exponent / price_constant;\n', '    // Based on the provided parameters, the price does not change in the first\n', '    // price_constant^(1/price_exponent) seconds due to rounding.\n', '    // Rounding in `decay_rate` also produces values that increase instead of decrease\n', '    // in the beginning of the auction; these spikes decrease over time and are noticeable\n', '    // only in first hours. This should be calculated before usage.\n', '    // @return Returns the token price - WEI per GOT.\n', '\n', '    function calcTokenPrice() constant private returns (uint256) {\n', '        uint256 elapsed;\n', '        uint256 decay_rate1;\n', '        uint256 decay_rate2;\n', '        if (stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp){\n', '          return price_start;\n', '        }\n', '        if (stage == Stages.AuctionStarted) {\n', '            elapsed = now - auction_start_time;\n', '            // The first eight days auction price curve\n', '            if (now >= auction_start_time && now < auction_start_time + CURVE_CUTOFF_DURATION){\n', '              decay_rate1 = elapsed ** price_exponent1 / price_constant1;\n', '              return price_start * (1 + elapsed) / (1 + elapsed + decay_rate1);\n', '            }\n', '            // The remaining days auction price curve\n', '            else if (now >= auction_start_time && now >= auction_start_time + CURVE_CUTOFF_DURATION){\n', '              decay_rate2 = elapsed ** price_exponent2 / price_constant2;\n', '              return price_start * (1 + elapsed) / (1 + elapsed + decay_rate2);\n', '            }\n', '            else {\n', '              return price_start;\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '---------------------------------------------------------------------------------------------\n', 'GoToken, a highly scalable, low cost mobile first network infrastructure for Ethereum\n', '---------------------------------------------------------------------------------------------\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', 'contract Token {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    ERC20 Token standard implementation\n', '    https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\n', '    https://github.com/ethereum/EIPs/issues/20\n', '\n', "    We didn't implement a separate totalsupply() function. Instead the public variable\n", '    totalSupply will automatically create a getter function to access the supply\n', '    of the token.\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    uint256 public totalSupply;\n', '\n', '/*\n', '    ERC20 Token Model\n', '*/\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _who, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _who) public constant returns (uint256 remaining);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', '/// @title Standard token contract - Standard token implementation.\n', 'contract StandardToken is Token {\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Storage data structures\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @notice Send "_value" tokens to "_to" from "msg.sender".\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfer "_value" tokens from "_from" to "_to" if "msg.sender" is allowed.\n', '    /// @dev Allows for an approved third party to transfer tokens from one\n', '    /// address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    /// @return Returns success of function call.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n', '    {\n', "        //Address shouldn't be null\n", '        require(_from != 0x0);\n', '        require(_to != 0x0);\n', '        require(_to != address(this));\n', '        require(balances[_from] >= _value);\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approves "_who" to transfer "_value" tokens from "msg.sender" to any address.\n', '    /// @dev Sets approved amount of tokens for the spender. Returns success.\n', '    /// @param _who Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    /// @return Returns success of function call.\n', '    function approve(address _who, uint256 _value) public returns (bool) {\n', '\n', "        // Address shouldn't be null\n", '        require(_who != 0x0);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_who, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require(_value == 0 || allowed[msg.sender][_who] == 0);\n', '\n', '        allowed[msg.sender][_who] = _value;\n', '        Approval(msg.sender, _who, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens that a spender can transfer on behalf of a token owner.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _who Address of token spender.\n', '    /// @return Returns remaining allowance for spender.\n', '    function allowance(address _owner, address _who) constant public returns (uint256)\n', '    {\n', '        return allowed[_owner][_who];\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by a given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @return Returns balance of owner.\n', '    function balanceOf(address _owner) constant public returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', '\n', '/// @title GoToken, a highly scalable, low cost mobile first network infrastructure for Ethereum\n', 'contract GoToken is StandardToken {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '      All GoToken balances are transferable.\n', '      Token name, ticker symbol and decimals\n', '      1 token (GOT) = 1 indivisible unit * multiplier\n', "      The multiplier is set dynamically from token's number of decimals (i.e. 10 ** decimals)\n", '\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Storage data structures\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    string constant public name = "GoToken";\n', '    string constant public symbol = "GOT";\n', '    uint256 constant public decimals = 18;\n', '    uint256 constant multiplier = 10 ** (decimals);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    event Deployed(uint256 indexed _total_supply);\n', '    //event Burnt(address indexed _receiver, uint256 indexed _num, uint256 indexed _total_supply);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @dev GoToken Contract constructor function sets GoToken dutch auction\n', '    /// contract address and assigns the tokens to the auction.\n', '    /// @param auction_address Address of dutch auction contract.\n', '    /// @param wallet_address Address of wallet.\n', '    /// @param initial_supply Number of initially provided token units (indivisible units).\n', '    function GoToken(address auction_address, address wallet_address, uint256 initial_supply) public\n', '    {\n', '        // Auction address should not be null.\n', '        require(auction_address != 0x0);\n', '        require(wallet_address != 0x0);\n', '\n', '        // Initial supply is in indivisible units e.g. 50e24\n', '        require(initial_supply > multiplier);\n', '\n', '        // Total supply of indivisible GOT units at deployment\n', '        totalSupply = initial_supply;\n', '\n', '        // preallocation\n', '        balances[auction_address] = initial_supply / 2;\n', '        balances[wallet_address] = initial_supply / 2;\n', '\n', '        // Record the events\n', '        Transfer(0x0, auction_address, balances[auction_address]);\n', '        Transfer(0x0, wallet_address, balances[wallet_address]);\n', '\n', '        Deployed(totalSupply);\n', '\n', '        assert(totalSupply == balances[auction_address] + balances[wallet_address]);\n', '    }\n', '\n', '}\n', '\n', '\n', '/// @title GoToken Uniform Price Dutch auction contract - distribution of a fixed\n', '/// number of tokens using second price auction, where everybody gets the same final\n', '/// price when the auction ends i.e. the ending bid becomes the finalized\n', '/// price per token for all participants.\n', 'contract GoTokenDutchAuction {\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    GoToken Uniform Price Dutch auction contract - distribution of a fixed\n', '    number of tokens using seconprice auction, where everybody gets the lowest\n', '    price when the auction ends i.e. the ending bid becomes the finalized\n', '    price per token. This is the mechanism for price discovery.\n', '\n', '    The uniform price Dutch auction is set up to discover a fair price for a\n', '    fixed amount of GOT tokens. It starts with a very high price which\n', '    continuously declines with every block over time, based on a predefined\n', '    formula. After the auction is started, participants can send in ETH to bid.\n', '    The auction ends once the price multiplied with the number of offered tokens\n', '    equals the total ETH amount sent to the auction. All participants receive\n', '    their tokens at the same final price.\n', '\n', '    The main goals of the auction are to enable everyone to participate while\n', '    offering certainty about the maximum total value of all tokens at the time\n', '    of the bid.\n', '\n', '    All token balances are transferable.\n', '    Token name, ticker symbol and decimals\n', '    1 token (GOT) = 1 indivisible unit * multiplier\n', "    multiplier set from token's number of decimals (i.e. 10 ** decimals)\n", '\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Data structures for Storage\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    GoToken public token;\n', '    address public owner_address;\n', '    address public wallet_address;\n', '    address public whitelister_address;\n', '    address public distributor_address;\n', '\n', '    // Minimum bid value during the auction\n', '    uint256 constant public bid_threshold = 10 finney;\n', '\n', '    // Maximum contribution per ETH address during public sale\n', '    //uint256 constant public MAX_CONTRIBUTION_PUBLICSALE = 20 ether;\n', '\n', '    // token multiplied derived out of decimals\n', '    uint256 public token_multiplier;\n', '\n', '    // Total number of indivisible GoTokens (GOT * token_multiplier) that will be auctioned\n', '    uint256 public num_tokens_auctioned;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Price decay function parameters to be changed depending on the desired outcome\n', '    This is modeled based on composite exponentially decaying curve auction price model.\n', '    The price curves are mathematically modeled per the business needs. There are two\n', '    exponentially decaying curves for teh auction: curve 1 is for teh first eight days\n', '    and curve 2 is for the remaining days until the auction is finalized.\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    // Starting price in WEI; e.g. 2 * 10 ** 18\n', '    uint256 public price_start;\n', '\n', '    uint256 constant public CURVE_CUTOFF_DURATION = 8 days;\n', '\n', '    // Price constant for first eight days of the price curve; e.g. 1728\n', '    uint256 public price_constant1;\n', '\n', '    // Price exponent for first eight days of the price curve; e.g. 2\n', '    uint256 public price_exponent1;\n', '\n', '    // Price constant for eight plus days of the price curve; e.g. 1257\n', '    uint256 public price_constant2;\n', '\n', '    // Price exponent for eight plus days of the price curve; e.g. 2\n', '    uint256 public price_exponent2;\n', '\n', '    // For private sale start time (same as auction deployement time)\n', '    uint256 public privatesale_start_time;\n', '\n', '    // For calculating elapsed time for price auction\n', '    uint256 public auction_start_time;\n', '    uint256 public end_time;\n', '    uint256 public start_block;\n', '\n', '    // All ETH received from the bids\n', '    uint256 public received_wei;\n', '    uint256 public received_wei_with_bonus;\n', '\n', '    // Cumulative ETH funds for which the tokens have been claimed\n', '    uint256 public funds_claimed;\n', '\n', '    // Wei per token (GOT * token_multiplier)\n', '    uint256 public final_price;\n', '\n', '    struct Account {\n', '  \t\tuint256 accounted;\t// bid value including bonus\n', '  \t\tuint256 received;\t// the amount received, without bonus\n', '  \t}\n', '\n', '    // Address of the Bidder => bid value\n', '    mapping (address => Account) public bids;\n', '\n', '    // privatesalewhitelist for private ETH addresses\n', '    mapping (address => bool) public privatesalewhitelist;\n', '\n', '    // publicsalewhitelist for addresses that want to bid in public sale excluding private sale accounts\n', '    mapping (address => bool) public publicsalewhitelist;\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Bonus tiers\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    // Maximum duration after sale begins that 15% bonus is active.\n', '  \tuint256 constant public BONUS_DAY1_DURATION = 24 hours; ///24 hours;\n', '\n', '  \t// Maximum duration after sale begins that 10% bonus is active.\n', '  \tuint256 constant public BONUS_DAY2_DURATION = 48 hours; ///48 hours;\n', '\n', '  \t// Maximum duration after sale begins that 5% bonus is active.\n', '  \tuint256 constant public BONUS_DAY3_DURATION = 72 hours; ///72 hours;\n', '\n', '    // The current percentage of bonus that contributors get.\n', '  \tuint256 public currentBonus = 0;\n', '\n', '    // Waiting time in days before a participant can claim tokens after the end of the auction\n', '    uint256 constant public TOKEN_CLAIM_WAIT_PERIOD = 0 days;\n', '\n', '    // Keep track of stages during the auction and contract deployment process\n', '    Stages public stage;\n', '\n', '    enum Stages {\n', '        AuctionDeployed,\n', '        AuctionSetUp,\n', '        AuctionStarted,\n', '        AuctionEnded,\n', '        TokensDistributed\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Modifiers\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '    // State of the auction\n', '    modifier atStage(Stages _stage) {\n', '        require(stage == _stage);\n', '        _;\n', '    }\n', '\n', '    // Only owner of the contract\n', '    modifier isOwner() {\n', '        require(msg.sender == owner_address);\n', '        _;\n', '    }\n', '\n', '    // Only who is allowed to whitelist the participant ETH addresses (specified\n', '    // during the contract deployment)\n', '    modifier isWhitelister() {\n', '        require(msg.sender == whitelister_address);\n', '        _;\n', '    }\n', '\n', '    // Only who is allowed to distribute the GOT to the participant ETH addresses (specified\n', '    // during the contract deployment)\n', '    modifier isDistributor() {\n', '        require(msg.sender == distributor_address);\n', '        _;\n', '    }\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Events\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    event Deployed(uint256 indexed _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256  _price_constant2, uint256 _price_exponent2);\n', '    event Setup();\n', '    event AuctionStarted(uint256 indexed _auction_start_time, uint256 indexed _block_number);\n', '    event BidSubmission(address indexed _sender,uint256 _amount, uint256 _amount_with_bonus, uint256 _remaining_funds_to_end_auction);\n', '    event ClaimedTokens(address indexed _recipient, uint256 _sent_amount);\n', '    event AuctionEnded(uint256 _final_price);\n', '    event TokensDistributed();\n', '\n', '    /// whitelisting events for private sale and public sale ETH addresses\n', '  \tevent PrivateSaleWhitelisted(address indexed who);\n', '    event RemovedFromPrivateSaleWhitelist(address indexed who);\n', '    event PublicSaleWhitelisted(address indexed who);\n', '    event RemovedFromPublicSaleWhitelist(address indexed who);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Public facing functions\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    /// @dev GoToken Contract constructor function sets the starting price,\n', '    /// price constant and price exponent for calculating the Dutch Auction price.\n', '    /// @param _wallet_address Wallet address to which all contributed ETH will be forwarded.\n', '    function GoTokenDutchAuction(\n', '        address _wallet_address,\n', '        address _whitelister_address,\n', '        address _distributor_address,\n', '        uint256 _price_start,\n', '        uint256 _price_constant1,\n', '        uint256 _price_exponent1,\n', '        uint256 _price_constant2,\n', '        uint256 _price_exponent2)\n', '        public\n', '    {\n', "        // Address shouldn't be null\n", '        require(_wallet_address != 0x0);\n', '        require(_whitelister_address != 0x0);\n', '        require(_distributor_address != 0x0);\n', '        wallet_address = _wallet_address;\n', '        whitelister_address = _whitelister_address;\n', '        distributor_address = _distributor_address;\n', '\n', '        owner_address = msg.sender;\n', '        stage = Stages.AuctionDeployed;\n', '        changePriceCurveSettings(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n', '        Deployed(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n', '    }\n', '\n', '    /// @dev Fallback function for the contract, which calls bid()\n', '    function () public payable {\n', '        bid();\n', '    }\n', '\n', '    /// @notice Set "_token_address" as the token address to be used in the auction.\n', '    /// @dev Setup function sets external contracts addresses.\n', '    /// @param _token_address Token address.\n', '    function setup(address _token_address) public isOwner atStage(Stages.AuctionDeployed) {\n', '        require(_token_address != 0x0);\n', '        token = GoToken(_token_address);\n', '\n', '        // Get number of GoToken indivisible tokens (GOT * token_multiplier)\n', '        // to be auctioned from token auction balance\n', '        num_tokens_auctioned = token.balanceOf(address(this));\n', '\n', '        // Set the number of the token multiplier for its decimals\n', '        token_multiplier = 10 ** (token.decimals());\n', '\n', '        // State is set to Auction Setup\n', '        stage = Stages.AuctionSetUp;\n', '        Setup();\n', '    }\n', '\n', '    /// @notice Set "_price_start", "_price_constant1" and "_price_exponent1"\n', '    ///  "_price_constant2" and "_price_exponent2" as\n', '    /// the new starting price, price constant and price exponent for the auction price.\n', '    /// @dev Changes auction price function parameters before auction is started.\n', '    /// @param _price_start Updated start price.\n', '    /// @param _price_constant1 Updated price divisor constant.\n', '    /// @param _price_exponent1 Updated price divisor exponent.\n', '    /// @param _price_constant2 Updated price divisor constant.\n', '    /// @param _price_exponent2 Updated price divisor exponent.\n', '    function changePriceCurveSettings(\n', '        uint256 _price_start,\n', '        uint256 _price_constant1,\n', '        uint256 _price_exponent1,\n', '        uint256 _price_constant2,\n', '        uint256 _price_exponent2)\n', '        internal\n', '    {\n', '        // You can change the price curve settings only when either the auction is Deployed\n', "        // or the auction is setup. You can't change during the auction is running or ended.\n", '        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);\n', '        require(_price_start > 0);\n', '        require(_price_constant1 > 0);\n', '        require(_price_constant2 > 0);\n', '\n', '        price_start = _price_start;\n', '        price_constant1 = _price_constant1;\n', '        price_exponent1 = _price_exponent1;\n', '        price_constant2 = _price_constant2;\n', '        price_exponent2 = _price_exponent2;\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Functions related to whitelisting of presale and public sale ETH addresses.\n', "    The Whitelister must add the participant's ETH address before they can bid.\n", '---------------------------------------------------------------------------------------------\n', '*/\n', '    // @notice Adds account addresses to public sale ETH whitelist.\n', '    // @dev Adds account addresses to public sale ETH whitelist.\n', '    // @param _bidder_addresses Array of addresses. Use double quoted array.\n', '    function addToPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', "            require(!privatesalewhitelist[_bidder_addresses[i]]); //Can't be in public whitelist\n", '            publicsalewhitelist[_bidder_addresses[i]] = true;\n', '            PublicSaleWhitelisted(_bidder_addresses[i]);\n', '        }\n', '    }\n', '\n', '    // @notice Removes account addresses from public sale ETH whitelist.\n', '    // @dev Removes account addresses from public sale ETH whitelist.\n', '    // @param _bidder_addresses Array of addresses.  Use double quoted array.\n', '    function removeFromPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '            publicsalewhitelist[_bidder_addresses[i]] = false;\n', '            RemovedFromPublicSaleWhitelist(_bidder_addresses[i]);\n', '        }\n', '    }\n', '\n', '    // Private sale contributors whitelist. Only Admin can add or remove\n', '\n', '  \t// @notice Adds presale account addresses to privatesalewhitelist.\n', '    // @ Admin Adds presale account addresses to privatesalewhitelist.\n', '    // @param _bidder_addresses Array of addresses.\n', '    function addToPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n', '        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '              privatesalewhitelist[_bidder_addresses[i]] = true;\n', '  \t\t\t\t\t\tPrivateSaleWhitelisted(_bidder_addresses[i]);\n', '          }\n', '      }\n', '\n', '      // @notice Removes presale account addresses from privatesalewhitelist.\n', '      // @ Admin Removes presale account addresses from privatesalewhitelist.\n', '      // @param _bidder_addresses Array of addresses.\n', '      function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n', '          for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n', '              privatesalewhitelist[_bidder_addresses[i]] = false;\n', '  \t\t\t\t\t\tRemovedFromPrivateSaleWhitelist(_bidder_addresses[i]);\n', '          }\n', '      }\n', '\n', '    // @notice Start the auction.\n', '    // @dev Starts auction and sets auction_start_time.\n', '    function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\n', '        stage = Stages.AuctionStarted;\n', '        auction_start_time = now;\n', '        start_block = block.number;\n', '        AuctionStarted(auction_start_time, start_block);\n', '    }\n', '\n', '    /// @notice Send "msg.value" WEI to the auction from the "msg.sender" account.\n', '    /// @dev Allows to send a bid to the auction.\n', '    function bid() public payable\n', '    {\n', "        // Address shouldn't be null and the minimum bid amount of contribution is met.\n", '        // Private sale contributor can submit a bid at AuctionSetUp before AuctionStarted\n', '        // When AuctionStarted only private sale and public sale whitelisted ETH addresses can participate\n', '        require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n', '        require(privatesalewhitelist[msg.sender] || publicsalewhitelist[msg.sender]);\n', '        if (stage == Stages.AuctionSetUp){\n', '          require(privatesalewhitelist[msg.sender]);\n', '        }\n', '        require(msg.value > 0);\n', '        require(bids[msg.sender].received + msg.value >= bid_threshold);\n', '        assert(bids[msg.sender].received + msg.value >= msg.value);\n', '\n', '        // Maximum public sale contribution per ETH account\n', '        //if (stage == Stages.AuctionStarted && publicsalewhitelist[msg.sender]) {\n', '        //  require (bids[msg.sender].received + msg.value <= MAX_CONTRIBUTION_PUBLICSALE);\n', '        //}\n', '\n', '        // Remaining funds without the current bid value to end the auction\n', '        uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction();\n', '\n', '        // The bid value must be less than the funds remaining to end the auction\n', '        // at the current price.\n', '        require(msg.value <= remaining_funds_to_end_auction);\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '        Bonus period settings\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '        //Private sale bids before Auction starts\n', '        if (stage == Stages.AuctionSetUp){\n', '          require(privatesalewhitelist[msg.sender]);\n', '          currentBonus = 25; //private sale bonus before AuctionStarted\n', '        }\n', '        else if (stage == Stages.AuctionStarted) {\n', '          // private sale contributors bonus period settings\n', '      \t\tif (privatesalewhitelist[msg.sender] && now >= auction_start_time  && now < auction_start_time + BONUS_DAY1_DURATION) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 1 bonus\n', '      \t\t}\n', '          else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 2 bonus\n', '      \t\t}\n', '      \t\telse if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n', '      \t\t\t\tcurrentBonus = 25; //private sale contributor Day 3 bonus\n', '      \t\t}\n', '          else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n', '              currentBonus = 25; //private sale contributor Day 4+ bonus\n', '          }\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time  && now < auction_start_time + BONUS_DAY1_DURATION) {\n', '      \t\t\t\tcurrentBonus = 15; //private sale contributor Day 1 bonus\n', '      \t\t}\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n', '      \t\t\t\tcurrentBonus = 10; //private sale contributor Day 2 bonus\n', '      \t\t}\n', '      \t\telse if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n', '      \t\t\t\tcurrentBonus = 5; //private sale contributor Day 3 bonus\n', '      \t\t}\n', '          else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n', '              currentBonus = 0; //private sale contributor Day 4+ bonus\n', '          }\n', '      \t\telse {\n', '      \t\t\t\tcurrentBonus = 0;\n', '      \t\t}\n', '        }\n', '        else {\n', '          currentBonus = 0;\n', '        }\n', '\n', '        // amount raised including bonus\n', '        uint256 accounted = msg.value + msg.value * (currentBonus) / 100;\n', '\n', '        // Save the bid amount received with and without bonus.\n', '    \t\tbids[msg.sender].accounted += accounted; //including bonus\n', '    \t\tbids[msg.sender].received += msg.value;\n', '\n', '        // keep track of total amount raised and with bonus\n', '        received_wei += msg.value;\n', '        received_wei_with_bonus += accounted;\n', '\n', '        // Send bid amount to wallet\n', '        wallet_address.transfer(msg.value);\n', '\n', '        //Log the bid\n', '        BidSubmission(msg.sender, msg.value, accounted, remaining_funds_to_end_auction);\n', '\n', '        assert(received_wei >= msg.value);\n', '        assert(received_wei_with_bonus >= accounted);\n', '    }\n', '\n', '    // @notice Finalize the auction - sets the final GoToken price and\n', '    // changes the auction stage after no bids are allowed. Only owner can finalize the auction.\n', '    // The owner can end the auction anytime after either the auction is deployed or started.\n', '    // @dev Finalize auction and set the final GOT token price.\n', '    function finalizeAuction() public isOwner\n', '    {\n', '        // The owner can end the auction anytime during the stages\n', '        // AuctionSetUp and AuctionStarted\n', '        require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n', '\n', '        // Calculate the final price = WEI / (GOT / token_multiplier)\n', '        final_price = token_multiplier * received_wei_with_bonus / num_tokens_auctioned;\n', '\n', '        // End the auction\n', '        end_time = now;\n', '        stage = Stages.AuctionEnded;\n', '        AuctionEnded(final_price);\n', '\n', '        assert(final_price > 0);\n', '    }\n', '\n', '    // @notice Distribute GoTokens for "receiver_address" after the auction has ended by the owner.\n', '    // @dev Distribute GoTokens for "receiver_address" after auction has ended by the owner.\n', '    // @param receiver_address GoTokens will be assigned to this address if eligible.\n', '    function distributeGoTokens(address receiver_address)\n', '        public isDistributor atStage(Stages.AuctionEnded) returns (bool)\n', '    {\n', '        // Waiting period in days after the end of the auction, before anyone can claim GoTokens.\n', '        // Ensures enough time to check if auction was finalized correctly\n', '        // before users start transacting tokens\n', '        require(now > end_time + TOKEN_CLAIM_WAIT_PERIOD);\n', '        require(receiver_address != 0x0);\n', '        require(bids[receiver_address].received > 0);\n', '\n', '        if (bids[receiver_address].received == 0 || bids[receiver_address].accounted == 0) {\n', '            return false;\n', '        }\n', '\n', '        // Number of GOT = bid_wei_with_bonus / (wei_per_GOT * token_multiplier)\n', '        // Includes the bonus\n', '        uint256 num = (token_multiplier * bids[receiver_address].accounted) / final_price;\n', '\n', '        // Due to final_price rounding, the number of assigned tokens may be higher\n', '        // than expected. Therefore, the number of remaining unassigned auction tokens\n', '        // may be smaller than the number of tokens needed for the last claimTokens call\n', '        uint256 auction_tokens_balance = token.balanceOf(address(this));\n', '        if (num > auction_tokens_balance) {\n', '            num = auction_tokens_balance;\n', '        }\n', '\n', '        // Update the total amount of funds for which tokens have been claimed\n', '        funds_claimed += bids[receiver_address].received;\n', '\n', '        // Set receiver bid to 0 before assigning tokens\n', '        bids[receiver_address].accounted = 0;\n', '        bids[receiver_address].received = 0;\n', '\n', '        // Send the GoTokens to the receiver address including the qualified bonus\n', '        require(token.transfer(receiver_address, num));\n', '\n', '        // Log the event for claimed GoTokens\n', '        ClaimedTokens(receiver_address, num);\n', '\n', '        // After the last tokens are claimed, change the auction stage\n', '        // Due to the above logic described, rounding errors will not be an issue here.\n', '        if (funds_claimed == received_wei) {\n', '            stage = Stages.TokensDistributed;\n', '            TokensDistributed();\n', '        }\n', '\n', '        assert(token.balanceOf(receiver_address) >= num);\n', '        assert(bids[receiver_address].accounted == 0);\n', '        assert(bids[receiver_address].received == 0);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Get the GOT price in WEI during the auction, at the time of\n', '    /// calling this function. Returns 0 if auction has ended.\n', '    /// Returns "price_start" before auction has started.\n', '    /// @dev Calculates the current GOT token price in WEI.\n', '    /// @return Returns WEI per indivisible GOT (token_multiplier * GOT).\n', '    function price() public constant returns (uint256) {\n', '        if (stage == Stages.AuctionEnded ||\n', '            stage == Stages.TokensDistributed) {\n', '            return 0;\n', '        }\n', '        return calcTokenPrice();\n', '    }\n', '\n', '    /// @notice Get the remaining funds needed to end the auction, calculated at\n', '    /// the current GOT price in WEI.\n', '    /// @dev The remaining funds necessary to end the auction at the current GOT price in WEI.\n', '    /// @return Returns the remaining funds to end the auction in WEI.\n', '    function remainingFundsToEndAuction() constant public returns (uint256) {\n', '\n', '        // num_tokens_auctioned = total number of indivisible GOT (GOT * token_multiplier) that is auctioned\n', '        uint256 required_wei_at_price = num_tokens_auctioned * price() / token_multiplier;\n', '        if (required_wei_at_price <= received_wei) {\n', '            return 0;\n', '        }\n', '\n', '        return required_wei_at_price - received_wei;\n', '    }\n', '\n', '/*\n', '---------------------------------------------------------------------------------------------\n', '    Private function for calcuclating current token price\n', '---------------------------------------------------------------------------------------------\n', '*/\n', '\n', '    // @dev Calculates the token price (WEI / GOT) at the current timestamp\n', '    // during the auction; elapsed time = 0 before auction starts.\n', '    // This is a composite exponentially decaying curve (two curves combined).\n', '    // The curve 1 is for the first 8 days and the curve 2 is for the remaining days.\n', '    // They are of the form:\n', '    //         current_price  = price_start * (1 + elapsed) / (1 + elapsed + decay_rate);\n', '    //          where, decay_rate = elapsed ** price_exponent / price_constant;\n', '    // Based on the provided parameters, the price does not change in the first\n', '    // price_constant^(1/price_exponent) seconds due to rounding.\n', '    // Rounding in `decay_rate` also produces values that increase instead of decrease\n', '    // in the beginning of the auction; these spikes decrease over time and are noticeable\n', '    // only in first hours. This should be calculated before usage.\n', '    // @return Returns the token price - WEI per GOT.\n', '\n', '    function calcTokenPrice() constant private returns (uint256) {\n', '        uint256 elapsed;\n', '        uint256 decay_rate1;\n', '        uint256 decay_rate2;\n', '        if (stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp){\n', '          return price_start;\n', '        }\n', '        if (stage == Stages.AuctionStarted) {\n', '            elapsed = now - auction_start_time;\n', '            // The first eight days auction price curve\n', '            if (now >= auction_start_time && now < auction_start_time + CURVE_CUTOFF_DURATION){\n', '              decay_rate1 = elapsed ** price_exponent1 / price_constant1;\n', '              return price_start * (1 + elapsed) / (1 + elapsed + decay_rate1);\n', '            }\n', '            // The remaining days auction price curve\n', '            else if (now >= auction_start_time && now >= auction_start_time + CURVE_CUTOFF_DURATION){\n', '              decay_rate2 = elapsed ** price_exponent2 / price_constant2;\n', '              return price_start * (1 + elapsed) / (1 + elapsed + decay_rate2);\n', '            }\n', '            else {\n', '              return price_start;\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '}']
