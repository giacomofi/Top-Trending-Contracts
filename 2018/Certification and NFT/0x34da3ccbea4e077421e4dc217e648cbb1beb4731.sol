['pragma solidity ^0.4.18;\n', '\n', 'contract Voting {\n', '  address creator; // The address of the account that created this ballot.\n', '\n', '  mapping (bytes32 => uint8) public votesReceived;\n', '  mapping (address => bytes32) public votes;\n', '\n', '  bytes32[] public candidateList;\n', '  uint16 public totalVotes;\n', '  bool public votingFinished;\n', '\n', '  function Voting(bytes32[] candidateNames) public {\n', '    creator = msg.sender;\n', '    candidateList = candidateNames;\n', '  }\n', '\n', '  function totalVotesFor(bytes32 candidate) view public returns (uint8) {\n', '    require(validCandidate(candidate));\n', "    require(votingFinished);  // Don't reveal votes until voting is finished\n", '    return votesReceived[candidate];\n', '  }\n', '\n', '  function numCandidates() public constant returns(uint count) {\n', '    return candidateList.length;\n', '  }\n', '\n', '  function getMyVote() public returns(bytes32 candidate) {\n', '    return votes[msg.sender];\n', '  }\n', '\n', '  function voteForCandidate(bytes32 candidate) public {\n', '    require(!votingFinished);\n', '    require(validCandidate(candidate));\n', '    votes[msg.sender] = candidate;\n', '    votesReceived[candidate] += 1;\n', '    totalVotes += 1;\n', '  }\n', '\n', '  function validCandidate(bytes32 candidate) view public returns (bool) {\n', '    for(uint i = 0; i < candidateList.length; i++) {\n', '      if (candidateList[i] == candidate) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '  \n', '  function endVote() public returns (bool) {\n', '    require(msg.sender == creator);  // Only contract creator can end the vote.\n', '    votingFinished = true;\n', '  }\n', '  \n', '}']