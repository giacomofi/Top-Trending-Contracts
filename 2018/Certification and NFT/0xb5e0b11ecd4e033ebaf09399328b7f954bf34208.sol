['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Empires is Ownable {\n', '\n', '    uint curr_rate = 50000000000000000; // 0.05 Ether\n', '    uint withraw_balance = 0;\n', '\n', '    struct Flag {\n', '        address[] spotOwner;\n', '        bytes32[] spotTxt;\n', '        uint spotRate;\n', '        uint prize;\n', '        uint16 spotWon;\n', '    }\n', '\n', '    Flag emptyFlag;\n', '\n', '    mapping (uint16 => Flag[]) public cntry_flgs;\n', '\n', '    function getRate () external view returns (uint) {\n', '        return curr_rate;\n', '    }\n', '\n', '    function setRate (uint newRate) external onlyOwner {\n', '        curr_rate = newRate;\n', '    }\n', '\n', '    function regSpot (uint16 cntryId, bytes32 stxt) private {\n', '\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.push(msg.sender);\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt.push(stxt);\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize + (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * 70 / 100);\n', '        withraw_balance = withraw_balance + cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate - (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * 70 / 100);\n', '\n', '    }\n', '\n', '    function createFlag (uint16 cntryId, uint sRate) private {\n', '\n', '        cntry_flgs[cntryId].push(Flag(new address[](0), new bytes32[](0), sRate, 0, 1000));\n', '\n', '    }\n', '\n', '    function completedFlag (uint16 cntryId) private {\n', '\n', '        //generate spotWon\n', '        uint16 randomSpot = uint16(uint(keccak256(now, msg.sender)) % 600);\n', '\n', '        // transfer to winner\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner[randomSpot].transfer(cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize);\n', '\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotWon = randomSpot;\n', '\n', '    }\n', '\n', '    function regSpots (uint16 cntryId, uint16 numOfSpots, bytes32 stxt) external payable {\n', '\n', '        require (numOfSpots > 0 && numOfSpots <= 600);\n', '\n', '        uint i;\n', '        uint j;\n', '        uint j1;\n', '        uint flagCompleted;\n', '\n', '        // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '          \n', '            require(msg.value == cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * numOfSpots);\n', '\n', '            i = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.length;\n', '\n', '            if (600-i >= numOfSpots) {\n', '\n', '                j = numOfSpots;\n', '\n', '                while (j > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j --;\n', '                    i ++;\n', '\n', '                }\n', '\n', '            } else {\n', '              // flag spots overflow\n', '\n', '                j1 = 600-i;\n', '                j = numOfSpots - j1;\n', '\n', '                while (j1 > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j1 --;\n', '                    i ++;\n', '\n', '                }\n', '\n', '                uint currRateHolder = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate;\n', '\n', '                // flag completion\n', '                completedFlag (cntryId);\n', '                flagCompleted = 1;\n', '\n', '                // create new flag\n', '                createFlag(cntryId, currRateHolder);\n', '\n', '                i = 0;\n', '\n', '                while (j > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j --;\n', '                    i ++;\n', '                }\n', '\n', '        }\n', '\n', '      } else {\n', '\n', '            require(msg.value == curr_rate * numOfSpots);\n', '\n', '            // create new flag\n', '            createFlag(cntryId, curr_rate);\n', '\n', '            i = 0;\n', '            j = numOfSpots;\n', '\n', '            while (j > 0) {\n', '\n', '                regSpot(cntryId, stxt);\n', '                j --;\n', '                i ++;\n', '            }\n', '\n', '      }\n', '      \n', '      // check flag completion\n', '        if (i==600) {\n', '            completedFlag (cntryId);\n', '            flagCompleted = 1;\n', '            createFlag(cntryId, curr_rate);\n', '        }\n', '\n', '        UpdateFlagList(cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner, cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt, flagCompleted);\n', '\n', '    }\n', '\n', '    event UpdateFlagList(address[] spotOwners,bytes32[] spotTxt, uint flagCompleted);\n', '\n', '    function getActiveFlag(uint16 cntryId) external view returns (address[],bytes32[],uint,uint,uint16) {\n', '      // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotWon);\n', '        } else {\n', '            return (emptyFlag.spotOwner, \n', '            emptyFlag.spotTxt, \n', '            emptyFlag.spotRate, \n', '            emptyFlag.prize, \n', '            emptyFlag.spotWon);      \n', '        }\n', '    }\n', '\n', '    function getCompletedFlag(uint16 cntryId, uint16 flagId) external view returns (address[],bytes32[],uint,uint,uint16) {\n', '        return (cntry_flgs[cntryId][flagId].spotOwner, \n', '        cntry_flgs[cntryId][flagId].spotTxt, \n', '        cntry_flgs[cntryId][flagId].spotRate, \n', '        cntry_flgs[cntryId][flagId].prize, \n', '        cntry_flgs[cntryId][flagId].spotWon);\n', '    }\n', '\n', '\n', '    function getActiveFlagRate(uint16 cntryId) external view returns (uint) {\n', '        // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate;\n', '        } else {\n', '            return curr_rate;\n', '        }\n', '    }\n', '\n', '    function getCountrySpots(uint16 cntryId) external view returns (uint) {\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return (cntry_flgs[cntryId].length-1)*600 + cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.length;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function withdraw() external onlyOwner {\n', '        uint tb = withraw_balance;\n', '        owner.transfer(tb);\n', '        withraw_balance = withraw_balance - tb;\n', '    }\n', '\n', '    function getWithdrawBalance () external view onlyOwner returns (uint) {\n', '        return withraw_balance;\n', '    }\n', '\n', '    function() public payable { }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Empires is Ownable {\n', '\n', '    uint curr_rate = 50000000000000000; // 0.05 Ether\n', '    uint withraw_balance = 0;\n', '\n', '    struct Flag {\n', '        address[] spotOwner;\n', '        bytes32[] spotTxt;\n', '        uint spotRate;\n', '        uint prize;\n', '        uint16 spotWon;\n', '    }\n', '\n', '    Flag emptyFlag;\n', '\n', '    mapping (uint16 => Flag[]) public cntry_flgs;\n', '\n', '    function getRate () external view returns (uint) {\n', '        return curr_rate;\n', '    }\n', '\n', '    function setRate (uint newRate) external onlyOwner {\n', '        curr_rate = newRate;\n', '    }\n', '\n', '    function regSpot (uint16 cntryId, bytes32 stxt) private {\n', '\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.push(msg.sender);\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt.push(stxt);\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize + (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * 70 / 100);\n', '        withraw_balance = withraw_balance + cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate - (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * 70 / 100);\n', '\n', '    }\n', '\n', '    function createFlag (uint16 cntryId, uint sRate) private {\n', '\n', '        cntry_flgs[cntryId].push(Flag(new address[](0), new bytes32[](0), sRate, 0, 1000));\n', '\n', '    }\n', '\n', '    function completedFlag (uint16 cntryId) private {\n', '\n', '        //generate spotWon\n', '        uint16 randomSpot = uint16(uint(keccak256(now, msg.sender)) % 600);\n', '\n', '        // transfer to winner\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner[randomSpot].transfer(cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize);\n', '\n', '        cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotWon = randomSpot;\n', '\n', '    }\n', '\n', '    function regSpots (uint16 cntryId, uint16 numOfSpots, bytes32 stxt) external payable {\n', '\n', '        require (numOfSpots > 0 && numOfSpots <= 600);\n', '\n', '        uint i;\n', '        uint j;\n', '        uint j1;\n', '        uint flagCompleted;\n', '\n', '        // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '          \n', '            require(msg.value == cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate * numOfSpots);\n', '\n', '            i = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.length;\n', '\n', '            if (600-i >= numOfSpots) {\n', '\n', '                j = numOfSpots;\n', '\n', '                while (j > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j --;\n', '                    i ++;\n', '\n', '                }\n', '\n', '            } else {\n', '              // flag spots overflow\n', '\n', '                j1 = 600-i;\n', '                j = numOfSpots - j1;\n', '\n', '                while (j1 > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j1 --;\n', '                    i ++;\n', '\n', '                }\n', '\n', '                uint currRateHolder = cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate;\n', '\n', '                // flag completion\n', '                completedFlag (cntryId);\n', '                flagCompleted = 1;\n', '\n', '                // create new flag\n', '                createFlag(cntryId, currRateHolder);\n', '\n', '                i = 0;\n', '\n', '                while (j > 0) {\n', '\n', '                    regSpot(cntryId, stxt);\n', '                    j --;\n', '                    i ++;\n', '                }\n', '\n', '        }\n', '\n', '      } else {\n', '\n', '            require(msg.value == curr_rate * numOfSpots);\n', '\n', '            // create new flag\n', '            createFlag(cntryId, curr_rate);\n', '\n', '            i = 0;\n', '            j = numOfSpots;\n', '\n', '            while (j > 0) {\n', '\n', '                regSpot(cntryId, stxt);\n', '                j --;\n', '                i ++;\n', '            }\n', '\n', '      }\n', '      \n', '      // check flag completion\n', '        if (i==600) {\n', '            completedFlag (cntryId);\n', '            flagCompleted = 1;\n', '            createFlag(cntryId, curr_rate);\n', '        }\n', '\n', '        UpdateFlagList(cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner, cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt, flagCompleted);\n', '\n', '    }\n', '\n', '    event UpdateFlagList(address[] spotOwners,bytes32[] spotTxt, uint flagCompleted);\n', '\n', '    function getActiveFlag(uint16 cntryId) external view returns (address[],bytes32[],uint,uint,uint16) {\n', '      // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return (cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotTxt, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].prize, \n', '            cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotWon);\n', '        } else {\n', '            return (emptyFlag.spotOwner, \n', '            emptyFlag.spotTxt, \n', '            emptyFlag.spotRate, \n', '            emptyFlag.prize, \n', '            emptyFlag.spotWon);      \n', '        }\n', '    }\n', '\n', '    function getCompletedFlag(uint16 cntryId, uint16 flagId) external view returns (address[],bytes32[],uint,uint,uint16) {\n', '        return (cntry_flgs[cntryId][flagId].spotOwner, \n', '        cntry_flgs[cntryId][flagId].spotTxt, \n', '        cntry_flgs[cntryId][flagId].spotRate, \n', '        cntry_flgs[cntryId][flagId].prize, \n', '        cntry_flgs[cntryId][flagId].spotWon);\n', '    }\n', '\n', '\n', '    function getActiveFlagRate(uint16 cntryId) external view returns (uint) {\n', '        // check active flag exists:\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotRate;\n', '        } else {\n', '            return curr_rate;\n', '        }\n', '    }\n', '\n', '    function getCountrySpots(uint16 cntryId) external view returns (uint) {\n', '        if (cntry_flgs[cntryId].length > 0) {\n', '            return (cntry_flgs[cntryId].length-1)*600 + cntry_flgs[cntryId][cntry_flgs[cntryId].length-1].spotOwner.length;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function withdraw() external onlyOwner {\n', '        uint tb = withraw_balance;\n', '        owner.transfer(tb);\n', '        withraw_balance = withraw_balance - tb;\n', '    }\n', '\n', '    function getWithdrawBalance () external view onlyOwner returns (uint) {\n', '        return withraw_balance;\n', '    }\n', '\n', '    function() public payable { }\n', '\n', '}']
