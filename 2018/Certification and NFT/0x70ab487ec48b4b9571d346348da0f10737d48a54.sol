['/*\n', '*\n', "* PredictionExchange is an exchange contract that doesn't accept bets on the outcomes,\n", '* but instead matchedes backers/takers (those betting on odds) with layers/makers \n', '* (those offering the odds).\n', '*\n', '* Note:\n', '*\n', '*       side: 0 (unknown), 1 (support), 2 (against), 3 (draw)\n', '*       role: 0 (unknown), 1 (maker), 2 (taker)\n', '*       state: 0 (unknown), 1 (created), 2 (reported), 3 (disputed)\n', '*       __test__* events will be removed prior to production deployment\n', '*       odds are rounded up (2.25 is 225)\n', '*\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract PredictionHandshake {\n', '\n', '        struct Market {\n', '\n', '                address creator;\n', '                uint fee; \n', '                bytes32 source;\n', '                uint closingTime; \n', '                uint reportTime; \n', '                uint disputeTime;\n', '\n', '                uint state;\n', '                uint outcome;\n', '\n', '                uint totalMatchedStake;\n', '                uint totalOpenStake;\n', '                uint disputeMatchedStake;\n', '                bool resolved;\n', '                mapping(uint => uint) outcomeMatchedStake;\n', '                \n', '                mapping(address => mapping(uint => Order)) open; // address => side => order\n', '                mapping(address => mapping(uint => Order)) matched; // address => side => order\n', '                mapping(address => bool) disputed;\n', '        }\n', '        \n', '        \n', '        function getMatchedData(uint hid, uint side, address user, uint userOdds) public onlyRoot view returns \n', '        (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        ) \n', '        {\n', '            Market storage m = markets[hid];\n', '            Order storage o = m.matched[user][side];\n', '            // return (stake, payout, odds, pool size)\n', '            return (o.stake, o.payout, userOdds, o.odds[userOdds]);\n', '        }\n', '        \n', '        function getOpenData(uint hid, uint side, address user, uint userOdds) public onlyRoot view returns \n', '        (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        ) \n', '        {\n', '            Market storage m = markets[hid];\n', '            Order storage o = m.open[user][side];\n', '            // return (stake, payout, odds, pool size)\n', '            return (o.stake, o.payout, userOdds, o.odds[userOdds]);\n', '        }\n', '\n', '        struct Order {\n', '                uint stake;\n', '                uint payout;\n', '                mapping(uint => uint) odds; // odds => pool size\n', '        }\n', '\n', '        struct Trial {\n', '                uint hid;\n', '                uint side;\n', '                bool valid;\n', '                mapping(uint => uint) amt; // odds => amt\n', '                mapping(uint => uint) totalStakes; // hid => amt\n', '        }\n', '\n', '        uint public NETWORK_FEE = 20; // 20%\n', '        uint public ODDS_1 = 100; // 1.00 is 100; 2.25 is 225 \n', '        uint public DISPUTE_THRESHOLD = 50; // 50%\n', '        uint public EXPIRATION = 30 days; \n', '\n', '        Market[] public markets;\n', '        address public root;\n', '        uint256 public total;\n', '\n', '        mapping(address => Trial) trial;\n', '\n', '        constructor() public {\n', '                root = msg.sender;\n', '        } \n', '\n', '\n', '        event __createMarket(uint hid, uint closingTime, uint reportTime, uint disputeTime, bytes32 offchain);\n', '\n', '        function createMarket(\n', '                uint fee, \n', '                bytes32 source,\n', '                uint closingWindow, \n', '                uint reportWindow, \n', '                uint disputeWindow,\n', '                bytes32 offchain\n', '        ) \n', '                public \n', '        {\n', '                _createMarket(msg.sender, fee, source, closingWindow, reportWindow, disputeWindow, offchain);\n', '        }\n', '\n', '\n', '        function createMarketForShurikenUser(\n', '                address creator,\n', '                uint fee, \n', '                bytes32 source,\n', '                uint closingWindow, \n', '                uint reportWindow, \n', '                uint disputeWindow,\n', '                bytes32 offchain\n', '        ) \n', '                public \n', '                onlyRoot\n', '        {\n', '                _createMarket(creator, fee, source, closingWindow, reportWindow, disputeWindow, offchain);\n', '        }\n', '\n', '        function _createMarket(\n', '                address creator,\n', '                uint fee, \n', '                bytes32 source,\n', '                uint closingWindow, \n', '                uint reportWindow, \n', '                uint disputeWindow,\n', '                bytes32 offchain\n', '        ) \n', '                public \n', '        {\n', '                Market memory m;\n', '                m.creator = creator;\n', '                m.fee = fee;\n', '                m.source = source;\n', '                m.closingTime = now + closingWindow * 1 seconds;\n', '                m.reportTime = m.closingTime + reportWindow * 1 seconds;\n', '                m.disputeTime = m.reportTime + disputeWindow * 1 seconds;\n', '                m.state = 1;\n', '                markets.push(m);\n', '\n', '                emit __createMarket(markets.length - 1, m.closingTime, m.reportTime, m.disputeTime, offchain);\n', '        }\n', '\n', '\n', '        event __init(uint hid, bytes32 offchain);\n', '        event __test__init(uint stake);\n', '\n', '        // market maker\n', '        function init(\n', '                uint hid, \n', '                uint side, \n', '                uint odds, \n', '                bytes32 offchain\n', '        ) \n', '                public \n', '                payable \n', '        {\n', '                _init(hid, side, odds, msg.sender, offchain);\n', '        }\n', '\n', '\n', '        // market maker. only called by root.  \n', '        function initTestDrive(\n', '                uint hid, \n', '                uint side, \n', '                uint odds, \n', '                address maker, \n', '                bytes32 offchain\n', '        ) \n', '                public\n', '                payable\n', '                onlyRoot\n', '        {\n', '                trial[maker].hid = hid;\n', '                trial[maker].side = side;\n', '                trial[maker].amt[odds] += msg.value;\n', '                trial[maker].totalStakes[hid] += msg.value;\n', '                trial[maker].valid = true;\n', '\n', '                _init(hid, side, odds, maker, offchain);\n', '        }\n', '        \n', '        function uninitTestDrive\n', '        (\n', '            uint hid,\n', '            uint side,\n', '            uint odds,\n', '            address maker,\n', '            uint value,\n', '            bytes32 offchain\n', '        )\n', '            public\n', '            onlyRoot\n', '        {\n', '                // make sure trial is existed and currently betting.\n', '                require(trial[maker].hid == hid && trial[maker].side == side && trial[maker].amt[odds] > 0);\n', '                trial[maker].amt[odds] -= value;\n', '                trial[maker].totalStakes[hid] -= value;\n', '                \n', '                Market storage m = markets[hid];\n', '                \n', '                require(m.open[maker][side].stake >= value);\n', '                require(m.open[maker][side].odds[odds] >= value);\n', '                require(m.totalOpenStake >= value);\n', '\n', '                m.open[maker][side].stake -= value;\n', '                m.open[maker][side].odds[odds] -= value;\n', '                m.totalOpenStake -= value;\n', '\n', '                require(total + value >= total);\n', '                total += value;\n', '            \n', '                emit __uninit(hid, offchain);\n', '                emit __test__uninit(m.open[msg.sender][side].stake);\n', '        }\n', '        \n', '        event __withdrawTrial(uint256 amount);\n', '\n', '        function withdrawTrial() public onlyRoot {\n', '            root.transfer(total);\n', '            emit __withdrawTrial(total);\n', '            total = 0;\n', '        }\n', '        \n', '        // market maker cancels order\n', '        function uninit(\n', '                uint hid, \n', '                uint side, \n', '                uint stake, \n', '                uint odds, \n', '                bytes32 offchain\n', '        ) \n', '                public \n', '                onlyPredictor(hid) \n', '        {\n', '                Market storage m = markets[hid];\n', '\n', '                uint trialAmt; \n', '                if (trial[msg.sender].hid == hid && trial[msg.sender].side == side)\n', '                    trialAmt = trial[msg.sender].amt[odds];\n', '\n', '                require(m.open[msg.sender][side].stake - trialAmt >= stake);\n', '                require(m.open[msg.sender][side].odds[odds] - trialAmt >= stake);\n', '\n', '                m.open[msg.sender][side].stake -= stake;\n', '                m.open[msg.sender][side].odds[odds] -= stake;\n', '                m.totalOpenStake -= stake;\n', '\n', '                msg.sender.transfer(stake);\n', '\n', '                emit __uninit(hid, offchain);\n', '                emit __test__uninit(m.open[msg.sender][side].stake);\n', '        }\n', '\n', '\n', '        function _init(\n', '                uint hid, \n', '                uint side, \n', '                uint odds, \n', '                address maker, \n', '                bytes32 offchain\n', '        ) \n', '                private \n', '        {\n', '                Market storage m = markets[hid];\n', '\n', '                require(now < m.closingTime);\n', '                require(m.state == 1);\n', '\n', '                m.open[maker][side].stake += msg.value;\n', '                m.open[maker][side].odds[odds] += msg.value;\n', '                m.totalOpenStake += msg.value;\n', '\n', '                emit __init(hid, offchain);\n', '                emit __test__init(m.open[maker][side].stake);\n', '        }\n', '\n', '\n', '        event __uninit(uint hid, bytes32 offchain);\n', '        event __test__uninit(uint stake);\n', '\n', '        \n', '\n', '\n', '        event __shake(uint hid, bytes32 offchain);\n', '        event __test__shake__taker__matched(uint stake, uint payout);\n', '        event __test__shake__maker__matched(uint stake, uint payout);\n', '        event __test__shake__maker__open(uint stake);\n', '\n', '\n', '        // market taker\n', '        function shake(\n', '                uint hid, \n', '                uint side, \n', '                uint takerOdds, \n', '                address maker, \n', '                uint makerOdds, \n', '                bytes32 offchain\n', '        ) \n', '                public \n', '                payable \n', '        {\n', '                _shake(hid, side, msg.sender, takerOdds, maker, makerOdds, offchain);\n', '        }\n', '\n', '\n', '        function shakeTestDrive(\n', '                uint hid, \n', '                uint side, \n', '                address taker,\n', '                uint takerOdds, \n', '                address maker, \n', '                uint makerOdds, \n', '                bytes32 offchain\n', '        ) \n', '                public \n', '                payable \n', '                onlyRoot\n', '        {\n', '                trial[taker].hid = hid;\n', '                trial[taker].side = side;\n', '                trial[taker].amt[takerOdds] += msg.value;\n', '                trial[taker].totalStakes[hid] += msg.value;\n', '                trial[taker].valid = true;\n', '\n', '                _shake(hid, side, taker, takerOdds, maker, makerOdds, offchain);\n', '        }\n', '\n', '\n', '        function _shake(\n', '                uint hid, \n', '                uint side, \n', '                address taker,\n', '                uint takerOdds, \n', '                address maker, \n', '                uint makerOdds, \n', '                bytes32 offchain\n', '        ) \n', '                private \n', '        {\n', '                require(maker != 0);\n', '                require(takerOdds >= ODDS_1);\n', '                require(makerOdds >= ODDS_1);\n', '\n', '                Market storage m = markets[hid];\n', '\n', '                require(m.state == 1);\n', '                require(now < m.closingTime);\n', '\n', '                uint makerSide = 3 - side;\n', '\n', '                uint takerStake = msg.value;\n', '                uint makerStake = m.open[maker][makerSide].stake;\n', '\n', '                uint takerPayout = (takerStake * takerOdds) / ODDS_1;\n', '                uint makerPayout = (makerStake * makerOdds) / ODDS_1;\n', '\n', '                if (takerPayout < makerPayout) {\n', '                        makerStake = takerPayout - takerStake;\n', '                        makerPayout = takerPayout;\n', '                } else {\n', '                        takerStake = makerPayout - makerStake;\n', '                        takerPayout = makerPayout;\n', '                }\n', '\n', '                // check if the odds matching is valid\n', '                require(takerOdds * ODDS_1 >= makerOdds * (takerOdds - ODDS_1));\n', '\n', '                // check if the stake is sufficient\n', '                require(m.open[maker][makerSide].odds[makerOdds] >= makerStake);\n', '                require(m.open[maker][makerSide].stake >= makerStake);\n', '\n', "                // remove maker's order from open (could be partial)\n", '                m.open[maker][makerSide].odds[makerOdds] -= makerStake;\n', '                m.open[maker][makerSide].stake -= makerStake;\n', '                m.totalOpenStake -=  makerStake;\n', '\n', "                // add maker's order to matched\n", '                m.matched[maker][makerSide].odds[makerOdds] += makerStake;\n', '                m.matched[maker][makerSide].stake += makerStake;\n', '                m.matched[maker][makerSide].payout += makerPayout;\n', '                m.totalMatchedStake += makerStake;\n', '                m.outcomeMatchedStake[makerSide] += makerStake;\n', '\n', "                // add taker's order to matched\n", '                m.matched[taker][side].odds[takerOdds] += takerStake;\n', '                m.matched[taker][side].stake += takerStake;\n', '                m.matched[taker][side].payout += takerPayout;\n', '                m.totalMatchedStake += takerStake;\n', '                m.outcomeMatchedStake[side] += takerStake;\n', '\n', '                emit __shake(hid, offchain);\n', '\n', '                emit __test__shake__taker__matched(m.matched[taker][side].stake, m.matched[taker][side].payout);\n', '                emit __test__shake__maker__matched(m.matched[maker][makerSide].stake, m.matched[maker][makerSide].payout);\n', '                emit __test__shake__maker__open(m.open[maker][makerSide].stake);\n', '\n', '        }\n', '\n', '\n', '        event __collect(uint hid, bytes32 offchain);\n', '        event __test__collect(uint network, uint market, uint trader);\n', '\n', '        function collect(uint hid, bytes32 offchain) public onlyPredictor(hid) {\n', '                _collect(hid, msg.sender, offchain);\n', '        }\n', '\n', '        function collectTestDrive(uint hid, address winner, bytes32 offchain) public onlyRoot {\n', '                _collect(hid, winner, offchain);\n', '        }\n', '\n', '        // collect payouts & outstanding stakes (if there is outcome)\n', '        function _collect(uint hid, address winner, bytes32 offchain) private {\n', '                Market storage m = markets[hid]; \n', '\n', '                require(m.state == 2);\n', '                require(now > m.disputeTime);\n', '\n', '                // calc network commission, market commission and winnings\n', '                uint marketComm = (m.matched[winner][m.outcome].payout * m.fee) / 100;\n', '                uint networkComm = (marketComm * NETWORK_FEE) / 100;\n', '\n', '                uint amt = m.matched[winner][m.outcome].payout;\n', '\n', '                amt += m.open[winner][1].stake; \n', '                amt += m.open[winner][2].stake;\n', '\n', '                require(amt - marketComm >= 0);\n', '                require(marketComm - networkComm >= 0);\n', '\n', '                // update totals\n', '                m.totalOpenStake -= m.open[winner][1].stake;\n', '                m.totalOpenStake -= m.open[winner][2].stake;\n', '                m.totalMatchedStake -= m.matched[winner][1].stake;\n', '                m.totalMatchedStake -= m.matched[winner][2].stake;\n', '\n', '                // wipe data\n', '                m.open[winner][1].stake = 0; \n', '                m.open[winner][2].stake = 0;\n', '                m.matched[winner][1].stake = 0; \n', '                m.matched[winner][2].stake = 0;\n', '                m.matched[winner][m.outcome].payout = 0;\n', '\n', '                winner.transfer(amt - marketComm);\n', '                m.creator.transfer(marketComm - networkComm);\n', '                root.transfer(networkComm);\n', '\n', '                emit __collect(hid, offchain);\n', '                emit __test__collect(networkComm, marketComm - networkComm, amt - marketComm);\n', '        }\n', '\n', '\n', '        event __refund(uint hid, bytes32 offchain);\n', '        event __test__refund(uint amt);\n', '\n', '        // refund stakes when market closes (if there is no outcome)\n', '        function refund(uint hid, bytes32 offchain) public onlyPredictor(hid) {\n', '\n', '                Market storage m = markets[hid]; \n', '\n', '                require(m.state == 1 || m.outcome == 3);\n', '                require(now > m.reportTime);\n', '\n', '                // calc refund amt\n', '                uint amt;\n', '                amt += m.matched[msg.sender][1].stake;\n', '                amt += m.matched[msg.sender][2].stake;\n', '                amt += m.open[msg.sender][1].stake;\n', '                amt += m.open[msg.sender][2].stake;\n', '\n', '                require(amt > 0);\n', '\n', '                // wipe data\n', '                m.matched[msg.sender][1].stake = 0;\n', '                m.matched[msg.sender][2].stake = 0;\n', '                m.open[msg.sender][1].stake = 0;\n', '                m.open[msg.sender][2].stake = 0;\n', '\n', '                if(!(trial[msg.sender].valid)) {\n', '                        msg.sender.transfer(amt);\n', '                } else {\n', '                        uint trialAmt = trial[msg.sender].totalStakes[hid];\n', '                        amt = amt - trialAmt;\n', '                        require(amt > 0);\n', '                        msg.sender.transfer(amt);\n', '                }\n', '\n', '                emit __refund(hid, offchain);\n', '                emit __test__refund(amt);\n', '        }\n', '\n', '\n', '        event __report(uint hid, bytes32 offchain);\n', '\n', '        // report outcome\n', '        function report(uint hid, uint outcome, bytes32 offchain) public {\n', '                Market storage m = markets[hid]; \n', '                require(now <= m.reportTime);\n', '                require(msg.sender == m.creator);\n', '                require(m.state == 1);\n', '                m.outcome = outcome;\n', '                m.state = 2;\n', '                emit __report(hid, offchain);\n', '        }\n', '\n', '\n', '        event __dispute(uint hid, uint outcome, uint state, bytes32 offchain);\n', '\n', '\n', '        function disputeTestDrive(uint hid, address sender, bytes32 offchain) public onlyRoot {\n', '                require(trial[sender].hid == hid && trial[sender].valid);\n', '                _dispute(hid, sender, offchain);\n', '        }        \n', '\n', '        function dispute(uint hid, bytes32 offchain) public onlyPredictor(hid) {\n', '                _dispute(hid, msg.sender, offchain);\n', '        }\n', '\n', '        // dispute outcome\n', '        function _dispute(uint hid, address sender, bytes32 offchain) private {\n', '                Market storage m = markets[hid]; \n', '\n', '                require(now <= m.disputeTime);\n', '                require(m.state == 2);\n', '                require(!m.resolved);\n', '\n', '                require(!m.disputed[sender]);\n', '                m.disputed[sender] = true;\n', '\n', '                // make sure user places bet on this side\n', '                uint side = 3 - m.outcome;\n', '                uint stake = 0;\n', '                uint outcomeMatchedStake = 0;\n', '                if (side == 0) {\n', '                        stake = m.matched[sender][1].stake;   \n', '                        stake += m.matched[sender][2].stake;   \n', '                        outcomeMatchedStake = m.outcomeMatchedStake[1];\n', '                        outcomeMatchedStake += m.outcomeMatchedStake[2];\n', '\n', '                } else {\n', '                        stake = m.matched[sender][side].stake;   \n', '                        outcomeMatchedStake = m.outcomeMatchedStake[side];\n', '                }\n', '                require(stake > 0);\n', '                m.disputeMatchedStake += stake;\n', '\n', '                // if dispute stakes > 50% of the total stakes\n', '                if (100 * m.disputeMatchedStake > DISPUTE_THRESHOLD * outcomeMatchedStake) {\n', '                        m.state = 3;\n', '                }\n', '                emit __dispute(hid, m.outcome, m.state, offchain);\n', '        }\n', '\n', '\n', '        event __resolve(uint hid, bytes32 offchain);\n', '\n', '        function resolve(uint hid, uint outcome, bytes32 offchain) public onlyRoot {\n', '                Market storage m = markets[hid]; \n', '                require(m.state == 3);\n', '                require(outcome == 1 || outcome == 2 || outcome == 3);\n', '                m.resolved = true;\n', '                m.outcome = outcome;\n', '                m.state = 2;\n', '                emit __resolve(hid, offchain);\n', '        }\n', '\n', '\n', '        modifier onlyPredictor(uint hid) {\n', '                require(markets[hid].matched[msg.sender][1].stake > 0 || \n', '                        markets[hid].matched[msg.sender][2].stake > 0 || \n', '                        markets[hid].open[msg.sender][1].stake > 0 || \n', '                        markets[hid].open[msg.sender][2].stake > 0);\n', '                _;\n', '        }\n', '\n', '\n', '        modifier onlyRoot() {\n', '                require(msg.sender == root);\n', '                _;\n', '        }\n', '}']