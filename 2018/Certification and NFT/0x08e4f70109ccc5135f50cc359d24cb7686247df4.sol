['pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Unidirectional Ether payment channels contract.\n', 'contract Unidirectional {\n', '    using SafeMath for uint256;\n', '\n', '    struct PaymentChannel {\n', '        address sender;\n', '        address receiver;\n', '        uint256 value; // Total amount of money deposited to the channel.\n', '\n', '        uint32 settlingPeriod; // How many blocks to wait for the receiver to claim her funds, after sender starts settling.\n', '        uint256 settlingUntil; // Starting with this block number, anyone can settle the channel.\n', '    }\n', '\n', '    mapping (bytes32 => PaymentChannel) public channels;\n', '\n', '    event DidOpen(bytes32 indexed channelId, address indexed sender, address indexed receiver, uint256 value);\n', '    event DidDeposit(bytes32 indexed channelId, uint256 deposit);\n', '    event DidClaim(bytes32 indexed channelId);\n', '    event DidStartSettling(bytes32 indexed channelId);\n', '    event DidSettle(bytes32 indexed channelId);\n', '\n', '    /*** ACTIONS AND CONSTRAINTS ***/\n', '\n', '    /// @notice Open a new channel between `msg.sender` and `receiver`, and do an initial deposit to the channel.\n', '    /// @param channelId Unique identifier of the channel to be created.\n', '    /// @param receiver Receiver of the funds, counter-party of `msg.sender`.\n', '    /// @param settlingPeriod Number of blocks to wait for receiver to `claim` her funds after the sender starts settling period (see `startSettling`).\n', '    /// After that period is over anyone could call `settle`, and move all the channel funds to the sender.\n', '    function open(bytes32 channelId, address receiver, uint32 settlingPeriod) public payable {\n', '        require(isAbsent(channelId));\n', '\n', '        channels[channelId] = PaymentChannel({\n', '            sender: msg.sender,\n', '            receiver: receiver,\n', '            value: msg.value,\n', '            settlingPeriod: settlingPeriod,\n', '            settlingUntil: 0\n', '        });\n', '\n', '        DidOpen(channelId, msg.sender, receiver, msg.value);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can deposit money into the channel identified by `channelId`.\n', '    /// @dev Constraint `deposit` call.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param origin Caller of `deposit` function.\n', '    function canDeposit(bytes32 channelId, address origin) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isSender = channel.sender == origin;\n', '        return isOpen(channelId) && isSender;\n', '    }\n', '\n', '    /// @notice Add more money to the contract.\n', '    /// @param channelId Identifier of the channel.\n', '    function deposit(bytes32 channelId) public payable {\n', '        require(canDeposit(channelId, msg.sender));\n', '\n', '        channels[channelId].value += msg.value;\n', '\n', '        DidDeposit(channelId, msg.value);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can start settling the channel identified by `channelId`.\n', '    /// @dev Constraint `startSettling` call.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param origin Caller of `startSettling` function.\n', '    function canStartSettling(bytes32 channelId, address origin) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isSender = channel.sender == origin;\n', '        return isOpen(channelId) && isSender;\n', '    }\n', '\n', '    /// @notice Sender initiates settling of the contract.\n', '    /// @dev Actually set `settlingUntil` field of the PaymentChannel structure.\n', '    /// @param channelId Identifier of the channel.\n', '    function startSettling(bytes32 channelId) public {\n', '        require(canStartSettling(channelId, msg.sender));\n', '\n', '        PaymentChannel storage channel = channels[channelId];\n', '        channel.settlingUntil = block.number + channel.settlingPeriod;\n', '\n', '        DidStartSettling(channelId);\n', '    }\n', '\n', '    /// @notice Ensure one can settle the channel identified by `channelId`.\n', '    /// @dev Check if settling period is over by comparing `settlingUntil` to a current block number.\n', '    /// @param channelId Identifier of the channel.\n', '    function canSettle(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isWaitingOver = isSettling(channelId) && block.number >= channel.settlingUntil;\n', '        return isSettling(channelId) && isWaitingOver;\n', '    }\n', '\n', '    /// @notice Move the money to sender, and close the channel.\n', '    /// After the settling period is over, and receiver has not claimed the funds, anyone could call that.\n', '    /// @param channelId Identifier of the channel.\n', '    function settle(bytes32 channelId) public {\n', '        require(canSettle(channelId));\n', '        PaymentChannel storage channel = channels[channelId];\n', '        channel.sender.transfer(channel.value);\n', '\n', '        delete channels[channelId];\n', '        DidSettle(channelId);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can claim `payment` amount on channel identified by `channelId`.\n', '    /// @dev Check if `signature` is made by sender part of the channel, and is for payment promise (see `paymentDigest`).\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount claimed.\n', '    /// @param origin Caller of `claim` function.\n', '    /// @param signature Signature for the payment promise.\n', '    function canClaim(bytes32 channelId, uint256 payment, address origin, bytes signature) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isReceiver = origin == channel.receiver;\n', '        bytes32 hash = recoveryPaymentDigest(channelId, payment);\n', '        bool isSigned = channel.sender == ECRecovery.recover(hash, signature);\n', '\n', '        return isReceiver && isSigned;\n', '    }\n', '\n', '    /// @notice Claim the funds, and close the channel.\n', '    /// @dev Can be claimed by channel receiver only. Guarded by `canClaim`.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount claimed.\n', '    /// @param signature Signature for the payment promise.\n', '    function claim(bytes32 channelId, uint256 payment, bytes signature) public {\n', '        require(canClaim(channelId, payment, msg.sender, signature));\n', '\n', '        PaymentChannel memory channel = channels[channelId];\n', '\n', '        if (payment >= channel.value) {\n', '            channel.receiver.transfer(channel.value);\n', '        } else {\n', '            channel.receiver.transfer(payment);\n', '            channel.sender.transfer(channel.value.sub(payment));\n', '        }\n', '\n', '        delete channels[channelId];\n', '\n', '        DidClaim(channelId);\n', '    }\n', '\n', '    /*** CHANNEL STATE ***/\n', '\n', '    /// @notice Check if the channel is present: in open or settling state.\n', '    /// @param channelId Identifier of the channel.\n', '    function isPresent(bytes32 channelId) public view returns(bool) {\n', '        return !isAbsent(channelId);\n', '    }\n', '\n', '    /// @notice Check if the channel is not present.\n', '    /// @param channelId Identifier of the channel.\n', '    function isAbsent(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        return channel.sender == 0;\n', '    }\n', '\n', '    /// @notice Check if the channel is in settling state: waits till the settling period is over.\n', '    /// @dev It is settling, if `settlingUntil` is set to non-zero.\n', '    /// @param channelId Identifier of the channel.\n', '    function isSettling(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        return channel.settlingUntil != 0;\n', '    }\n', '\n', '    /// @notice Check if the channel is open: present and not settling.\n', '    /// @param channelId Identifier of the channel.\n', '    function isOpen(bytes32 channelId) public view returns(bool) {\n', '        return isPresent(channelId) && !isSettling(channelId);\n', '    }\n', '\n', '    /*** PAYMENT DIGEST ***/\n', '\n', '    /// @return Hash of the payment promise to sign.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount to send, and to claim later.\n', '    function paymentDigest(bytes32 channelId, uint256 payment) public view returns(bytes32) {\n', '        return keccak256(address(this), channelId, payment);\n', '    }\n', '\n', '    /// @return Actually signed hash of the payment promise, considering "Ethereum Signed Message" prefix.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount to send, and to claim later.\n', '    function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        return keccak256(prefix, paymentDigest(channelId, payment));\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title Unidirectional Ether payment channels contract.\n', 'contract Unidirectional {\n', '    using SafeMath for uint256;\n', '\n', '    struct PaymentChannel {\n', '        address sender;\n', '        address receiver;\n', '        uint256 value; // Total amount of money deposited to the channel.\n', '\n', '        uint32 settlingPeriod; // How many blocks to wait for the receiver to claim her funds, after sender starts settling.\n', '        uint256 settlingUntil; // Starting with this block number, anyone can settle the channel.\n', '    }\n', '\n', '    mapping (bytes32 => PaymentChannel) public channels;\n', '\n', '    event DidOpen(bytes32 indexed channelId, address indexed sender, address indexed receiver, uint256 value);\n', '    event DidDeposit(bytes32 indexed channelId, uint256 deposit);\n', '    event DidClaim(bytes32 indexed channelId);\n', '    event DidStartSettling(bytes32 indexed channelId);\n', '    event DidSettle(bytes32 indexed channelId);\n', '\n', '    /*** ACTIONS AND CONSTRAINTS ***/\n', '\n', '    /// @notice Open a new channel between `msg.sender` and `receiver`, and do an initial deposit to the channel.\n', '    /// @param channelId Unique identifier of the channel to be created.\n', '    /// @param receiver Receiver of the funds, counter-party of `msg.sender`.\n', '    /// @param settlingPeriod Number of blocks to wait for receiver to `claim` her funds after the sender starts settling period (see `startSettling`).\n', '    /// After that period is over anyone could call `settle`, and move all the channel funds to the sender.\n', '    function open(bytes32 channelId, address receiver, uint32 settlingPeriod) public payable {\n', '        require(isAbsent(channelId));\n', '\n', '        channels[channelId] = PaymentChannel({\n', '            sender: msg.sender,\n', '            receiver: receiver,\n', '            value: msg.value,\n', '            settlingPeriod: settlingPeriod,\n', '            settlingUntil: 0\n', '        });\n', '\n', '        DidOpen(channelId, msg.sender, receiver, msg.value);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can deposit money into the channel identified by `channelId`.\n', '    /// @dev Constraint `deposit` call.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param origin Caller of `deposit` function.\n', '    function canDeposit(bytes32 channelId, address origin) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isSender = channel.sender == origin;\n', '        return isOpen(channelId) && isSender;\n', '    }\n', '\n', '    /// @notice Add more money to the contract.\n', '    /// @param channelId Identifier of the channel.\n', '    function deposit(bytes32 channelId) public payable {\n', '        require(canDeposit(channelId, msg.sender));\n', '\n', '        channels[channelId].value += msg.value;\n', '\n', '        DidDeposit(channelId, msg.value);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can start settling the channel identified by `channelId`.\n', '    /// @dev Constraint `startSettling` call.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param origin Caller of `startSettling` function.\n', '    function canStartSettling(bytes32 channelId, address origin) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isSender = channel.sender == origin;\n', '        return isOpen(channelId) && isSender;\n', '    }\n', '\n', '    /// @notice Sender initiates settling of the contract.\n', '    /// @dev Actually set `settlingUntil` field of the PaymentChannel structure.\n', '    /// @param channelId Identifier of the channel.\n', '    function startSettling(bytes32 channelId) public {\n', '        require(canStartSettling(channelId, msg.sender));\n', '\n', '        PaymentChannel storage channel = channels[channelId];\n', '        channel.settlingUntil = block.number + channel.settlingPeriod;\n', '\n', '        DidStartSettling(channelId);\n', '    }\n', '\n', '    /// @notice Ensure one can settle the channel identified by `channelId`.\n', '    /// @dev Check if settling period is over by comparing `settlingUntil` to a current block number.\n', '    /// @param channelId Identifier of the channel.\n', '    function canSettle(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isWaitingOver = isSettling(channelId) && block.number >= channel.settlingUntil;\n', '        return isSettling(channelId) && isWaitingOver;\n', '    }\n', '\n', '    /// @notice Move the money to sender, and close the channel.\n', '    /// After the settling period is over, and receiver has not claimed the funds, anyone could call that.\n', '    /// @param channelId Identifier of the channel.\n', '    function settle(bytes32 channelId) public {\n', '        require(canSettle(channelId));\n', '        PaymentChannel storage channel = channels[channelId];\n', '        channel.sender.transfer(channel.value);\n', '\n', '        delete channels[channelId];\n', '        DidSettle(channelId);\n', '    }\n', '\n', '    /// @notice Ensure `origin` address can claim `payment` amount on channel identified by `channelId`.\n', '    /// @dev Check if `signature` is made by sender part of the channel, and is for payment promise (see `paymentDigest`).\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount claimed.\n', '    /// @param origin Caller of `claim` function.\n', '    /// @param signature Signature for the payment promise.\n', '    function canClaim(bytes32 channelId, uint256 payment, address origin, bytes signature) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        bool isReceiver = origin == channel.receiver;\n', '        bytes32 hash = recoveryPaymentDigest(channelId, payment);\n', '        bool isSigned = channel.sender == ECRecovery.recover(hash, signature);\n', '\n', '        return isReceiver && isSigned;\n', '    }\n', '\n', '    /// @notice Claim the funds, and close the channel.\n', '    /// @dev Can be claimed by channel receiver only. Guarded by `canClaim`.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount claimed.\n', '    /// @param signature Signature for the payment promise.\n', '    function claim(bytes32 channelId, uint256 payment, bytes signature) public {\n', '        require(canClaim(channelId, payment, msg.sender, signature));\n', '\n', '        PaymentChannel memory channel = channels[channelId];\n', '\n', '        if (payment >= channel.value) {\n', '            channel.receiver.transfer(channel.value);\n', '        } else {\n', '            channel.receiver.transfer(payment);\n', '            channel.sender.transfer(channel.value.sub(payment));\n', '        }\n', '\n', '        delete channels[channelId];\n', '\n', '        DidClaim(channelId);\n', '    }\n', '\n', '    /*** CHANNEL STATE ***/\n', '\n', '    /// @notice Check if the channel is present: in open or settling state.\n', '    /// @param channelId Identifier of the channel.\n', '    function isPresent(bytes32 channelId) public view returns(bool) {\n', '        return !isAbsent(channelId);\n', '    }\n', '\n', '    /// @notice Check if the channel is not present.\n', '    /// @param channelId Identifier of the channel.\n', '    function isAbsent(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        return channel.sender == 0;\n', '    }\n', '\n', '    /// @notice Check if the channel is in settling state: waits till the settling period is over.\n', '    /// @dev It is settling, if `settlingUntil` is set to non-zero.\n', '    /// @param channelId Identifier of the channel.\n', '    function isSettling(bytes32 channelId) public view returns(bool) {\n', '        PaymentChannel memory channel = channels[channelId];\n', '        return channel.settlingUntil != 0;\n', '    }\n', '\n', '    /// @notice Check if the channel is open: present and not settling.\n', '    /// @param channelId Identifier of the channel.\n', '    function isOpen(bytes32 channelId) public view returns(bool) {\n', '        return isPresent(channelId) && !isSettling(channelId);\n', '    }\n', '\n', '    /*** PAYMENT DIGEST ***/\n', '\n', '    /// @return Hash of the payment promise to sign.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount to send, and to claim later.\n', '    function paymentDigest(bytes32 channelId, uint256 payment) public view returns(bytes32) {\n', '        return keccak256(address(this), channelId, payment);\n', '    }\n', '\n', '    /// @return Actually signed hash of the payment promise, considering "Ethereum Signed Message" prefix.\n', '    /// @param channelId Identifier of the channel.\n', '    /// @param payment Amount to send, and to claim later.\n', '    function recoveryPaymentDigest(bytes32 channelId, uint256 payment) internal view returns(bytes32) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        return keccak256(prefix, paymentDigest(channelId, payment));\n', '    }\n', '}']
