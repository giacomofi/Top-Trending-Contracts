['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath { //standard library for uint\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0 || b == 0){\n', '        return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\n', '    if (b == 0){\n', '      return 1;\n', '    }\n', '    uint256 c = a**b;\n', '    assert (c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '//standard contract to identify owner\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  address public newOwner;\n', '\n', '  address public techSupport;\n', '\n', '  address public newTechSupport;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTechSupport() {\n', '    require(msg.sender == techSupport || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '  function transferTechSupport (address _newSupport) public{\n', '    require (msg.sender == owner || msg.sender == techSupport);\n', '    newTechSupport = _newSupport;\n', '  }\n', '\n', '  function acceptSupport() public{\n', '    if(msg.sender == newTechSupport){\n', '      techSupport = newTechSupport;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '//Abstract Token contract\n', 'contract BineuroToken{\n', '  function setCrowdsaleContract (address) public;\n', '  function sendCrowdsaleTokens(address, uint256)  public;\n', '  function burnTokens(address,address, address, uint) public;\n', '  function getOwner()public view returns(address);\n', '}\n', '\n', '//Crowdsale contract\n', 'contract Crowdsale is Ownable{\n', '\n', '  using SafeMath for uint;\n', '\n', '  uint public decimals = 3;\n', '  // Token contract address\n', '  BineuroToken public token;\n', '\n', '  // Constructor\n', '  function Crowdsale(address _tokenAddress) public{\n', '    token = BineuroToken(_tokenAddress);\n', '    techSupport = msg.sender;\n', '\n', '    token.setCrowdsaleContract(this);\n', '    owner = token.getOwner();\n', '  }\n', '\n', '  address etherDistribution1 = 0x64f89e3CE504f1b15FcD4465b780Fb393ab79187;\n', '  address etherDistribution2 = 0x320359973d7953FbEf62C4f50960C46D8DBE2425;\n', '\n', '  address bountyAddress = 0x7e06828655Ba568Bbe06eD8ce165e4052A6Ea441;\n', '\n', '  //Crowdsale variables\n', '  uint public tokensSold = 0;\n', '  uint public ethCollected = 0;\n', '\n', '  // Buy constants\n', '  uint public minDeposit = (uint)(500).mul((uint)(10).pow(decimals));\n', '\n', '  uint public tokenPrice = 0.0001 ether;\n', '\n', '  // Ico constants\n', '  uint public icoStart = 1522141200; //27.03.2018  12:00 UTC+3\n', '  uint public icoFinish = 1528156800; //27.03.2018  12:00 UTC+2\n', '\n', '  uint public maxCap = 47000000 ether;\n', '\n', '  //Owner can change end date\n', '  function changeIcoFinish (uint _newDate) public onlyTechSupport {\n', '    icoFinish = _newDate;\n', '  }\n', '\n', '  //check is now ICO\n', '  function isIco(uint _time) public view returns (bool){\n', '    if((icoStart <= _time) && (_time < icoFinish)){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function timeBasedBonus(uint _time) public view returns(uint res) {\n', '    res = 20;\n', '    uint timeBuffer = icoStart;\n', '    for (uint i = 0; i<10; i++){\n', '      if(_time <= timeBuffer + 7 days){\n', '        return res;\n', '      }else{\n', '        res = res - 2;\n', '        timeBuffer = timeBuffer + 7 days;\n', '      }\n', '      if (res == 0){\n', '        return (0);\n', '      }\n', '    }\n', '    return res;\n', '  }\n', '  \n', '  function volumeBasedBonus(uint _value)public pure returns(uint res) {\n', '    if(_value < 5 ether){\n', '      return 0;\n', '    }\n', '    if (_value < 15 ether){\n', '      return 2;\n', '    }\n', '    if (_value < 30 ether){\n', '      return 5;\n', '    }\n', '    if (_value < 50 ether){\n', '      return 8;\n', '    }\n', '    return 10;\n', '  }\n', '  \n', '  //fallback function (when investor send ether to contract)\n', '  function() public payable{\n', '    require(isIco(now));\n', '    require(ethCollected.add(msg.value) <= maxCap);\n', '    require(buy(msg.sender,msg.value, now)); //redirect to func buy\n', '  }\n', '\n', '  //function buy Tokens\n', '  function buy(address _address, uint _value, uint _time) internal returns (bool){\n', '    uint tokensForSend = etherToTokens(_value,_time);\n', '\n', '    require (tokensForSend >= minDeposit);\n', '\n', '    tokensSold = tokensSold.add(tokensForSend);\n', '    ethCollected = ethCollected.add(_value);\n', '\n', '    token.sendCrowdsaleTokens(_address,tokensForSend);\n', '    etherDistribution1.transfer(this.balance/2);\n', '    etherDistribution2.transfer(this.balance);\n', '\n', '    return true;\n', '  }\n', '\n', '  function manualSendTokens (address _address, uint _tokens) public onlyTechSupport {\n', '    token.sendCrowdsaleTokens(_address, _tokens);\n', '    tokensSold = tokensSold.add(_tokens);\n', '  }\n', '  \n', '\n', '  //convert ether to tokens (without decimals)\n', '  function etherToTokens(uint _value, uint _time) public view returns(uint res) {\n', '    res = _value.mul((uint)(10).pow(decimals))/(tokenPrice);\n', '    uint bonus = timeBasedBonus(_time).add(volumeBasedBonus(_value));\n', '    res = res.add(res.mul(bonus)/100);\n', '  }\n', '\n', '  bool public isIcoEnded = false;\n', '  function endIco () public {\n', '    require(!isIcoEnded);\n', '    require(msg.sender == owner || msg.sender == techSupport);\n', '    require(now > icoFinish + 5 days);\n', '    token.burnTokens(etherDistribution1,etherDistribution2, bountyAddress, tokensSold);\n', '    isIcoEnded = true;\n', '  }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'library SafeMath { //standard library for uint\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0 || b == 0){\n', '        return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256){ //power function\n', '    if (b == 0){\n', '      return 1;\n', '    }\n', '    uint256 c = a**b;\n', '    assert (c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '//standard contract to identify owner\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  address public newOwner;\n', '\n', '  address public techSupport;\n', '\n', '  address public newTechSupport;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTechSupport() {\n', '    require(msg.sender == techSupport || msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '  function transferTechSupport (address _newSupport) public{\n', '    require (msg.sender == owner || msg.sender == techSupport);\n', '    newTechSupport = _newSupport;\n', '  }\n', '\n', '  function acceptSupport() public{\n', '    if(msg.sender == newTechSupport){\n', '      techSupport = newTechSupport;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '//Abstract Token contract\n', 'contract BineuroToken{\n', '  function setCrowdsaleContract (address) public;\n', '  function sendCrowdsaleTokens(address, uint256)  public;\n', '  function burnTokens(address,address, address, uint) public;\n', '  function getOwner()public view returns(address);\n', '}\n', '\n', '//Crowdsale contract\n', 'contract Crowdsale is Ownable{\n', '\n', '  using SafeMath for uint;\n', '\n', '  uint public decimals = 3;\n', '  // Token contract address\n', '  BineuroToken public token;\n', '\n', '  // Constructor\n', '  function Crowdsale(address _tokenAddress) public{\n', '    token = BineuroToken(_tokenAddress);\n', '    techSupport = msg.sender;\n', '\n', '    token.setCrowdsaleContract(this);\n', '    owner = token.getOwner();\n', '  }\n', '\n', '  address etherDistribution1 = 0x64f89e3CE504f1b15FcD4465b780Fb393ab79187;\n', '  address etherDistribution2 = 0x320359973d7953FbEf62C4f50960C46D8DBE2425;\n', '\n', '  address bountyAddress = 0x7e06828655Ba568Bbe06eD8ce165e4052A6Ea441;\n', '\n', '  //Crowdsale variables\n', '  uint public tokensSold = 0;\n', '  uint public ethCollected = 0;\n', '\n', '  // Buy constants\n', '  uint public minDeposit = (uint)(500).mul((uint)(10).pow(decimals));\n', '\n', '  uint public tokenPrice = 0.0001 ether;\n', '\n', '  // Ico constants\n', '  uint public icoStart = 1522141200; //27.03.2018  12:00 UTC+3\n', '  uint public icoFinish = 1528156800; //27.03.2018  12:00 UTC+2\n', '\n', '  uint public maxCap = 47000000 ether;\n', '\n', '  //Owner can change end date\n', '  function changeIcoFinish (uint _newDate) public onlyTechSupport {\n', '    icoFinish = _newDate;\n', '  }\n', '\n', '  //check is now ICO\n', '  function isIco(uint _time) public view returns (bool){\n', '    if((icoStart <= _time) && (_time < icoFinish)){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function timeBasedBonus(uint _time) public view returns(uint res) {\n', '    res = 20;\n', '    uint timeBuffer = icoStart;\n', '    for (uint i = 0; i<10; i++){\n', '      if(_time <= timeBuffer + 7 days){\n', '        return res;\n', '      }else{\n', '        res = res - 2;\n', '        timeBuffer = timeBuffer + 7 days;\n', '      }\n', '      if (res == 0){\n', '        return (0);\n', '      }\n', '    }\n', '    return res;\n', '  }\n', '  \n', '  function volumeBasedBonus(uint _value)public pure returns(uint res) {\n', '    if(_value < 5 ether){\n', '      return 0;\n', '    }\n', '    if (_value < 15 ether){\n', '      return 2;\n', '    }\n', '    if (_value < 30 ether){\n', '      return 5;\n', '    }\n', '    if (_value < 50 ether){\n', '      return 8;\n', '    }\n', '    return 10;\n', '  }\n', '  \n', '  //fallback function (when investor send ether to contract)\n', '  function() public payable{\n', '    require(isIco(now));\n', '    require(ethCollected.add(msg.value) <= maxCap);\n', '    require(buy(msg.sender,msg.value, now)); //redirect to func buy\n', '  }\n', '\n', '  //function buy Tokens\n', '  function buy(address _address, uint _value, uint _time) internal returns (bool){\n', '    uint tokensForSend = etherToTokens(_value,_time);\n', '\n', '    require (tokensForSend >= minDeposit);\n', '\n', '    tokensSold = tokensSold.add(tokensForSend);\n', '    ethCollected = ethCollected.add(_value);\n', '\n', '    token.sendCrowdsaleTokens(_address,tokensForSend);\n', '    etherDistribution1.transfer(this.balance/2);\n', '    etherDistribution2.transfer(this.balance);\n', '\n', '    return true;\n', '  }\n', '\n', '  function manualSendTokens (address _address, uint _tokens) public onlyTechSupport {\n', '    token.sendCrowdsaleTokens(_address, _tokens);\n', '    tokensSold = tokensSold.add(_tokens);\n', '  }\n', '  \n', '\n', '  //convert ether to tokens (without decimals)\n', '  function etherToTokens(uint _value, uint _time) public view returns(uint res) {\n', '    res = _value.mul((uint)(10).pow(decimals))/(tokenPrice);\n', '    uint bonus = timeBasedBonus(_time).add(volumeBasedBonus(_value));\n', '    res = res.add(res.mul(bonus)/100);\n', '  }\n', '\n', '  bool public isIcoEnded = false;\n', '  function endIco () public {\n', '    require(!isIcoEnded);\n', '    require(msg.sender == owner || msg.sender == techSupport);\n', '    require(now > icoFinish + 5 days);\n', '    token.burnTokens(etherDistribution1,etherDistribution2, bountyAddress, tokensSold);\n', '    isIcoEnded = true;\n', '  }\n', '}']
