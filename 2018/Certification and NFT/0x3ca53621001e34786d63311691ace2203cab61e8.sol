['pragma solidity ^0.4.18;\n', '\n', '/*\n', '  Copyright 2017, Anton Egorov (Mothership Foundation)\n', '  Copyright 2017, An Hoang Phan Ngo (Mothership Foundation)\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '// File: contracts/interface/Controlled.sol\n', '\n', 'contract Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier\n', '  modifier onlyController {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '\n', '  address public controller;\n', '\n', '  function Controlled() public { controller = msg.sender; }\n', '\n', '  /// @notice Changes the controller of the contract\n', '  /// @param _newController The new controller of the contract\n', '  function changeController(address _newController) public onlyController {\n', '    controller = _newController;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/Burnable.sol\n', '\n', '/// @dev Burnable introduces a burner role, which could be used to destroy\n', '///  tokens. The burner address could be changed by himself.\n', 'contract Burnable is Controlled {\n', '  address public burner;\n', '\n', '  /// @notice The function with this modifier could be called by a controller\n', '  /// as well as by a burner. But burner could use the onlt his/her address as\n', '  /// a target.\n', '  modifier onlyControllerOrBurner(address target) {\n', '    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\n', '    _;\n', '  }\n', '\n', '  modifier onlyBurner {\n', '    assert(msg.sender == burner);\n', '    _;\n', '  }\n', '\n', '  /// Contract creator become a burner by default\n', '  function Burnable() public { burner = msg.sender;}\n', '\n', '  /// @notice Change a burner address\n', '  /// @param _newBurner The new burner address\n', '  function changeBurner(address _newBurner) public onlyBurner {\n', '    burner = _newBurner;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/ERC20Token.sol\n', '\n', '// @dev Abstract contract for the full ERC 20 Token standard\n', '//  https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20Token {\n', '  /// total amount of tokens\n', '  function totalSupply() public view returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/interface/MiniMeTokenI.sol\n', '\n', '/// @dev MiniMeToken interface. Using this interface instead of whole contracts\n', '///  will reduce contract sise and gas cost\n', 'contract MiniMeTokenI is ERC20Token, Burnable {\n', '\n', '  string public name;                //The Token&#39;s name: e.g. DigixDAO Tokens\n', '  uint8 public decimals;             //Number of decimals of the smallest unit\n', '  string public symbol;              //An identifier: e.g. REP\n', '  string public version = "MMT_0.1"; //An arbitrary versioning scheme\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '  ///  its behalf, and then a function is triggered in the contract that is\n', '  ///  being approved, `_spender`. This allows users to use their tokens to\n', '  ///  interact with contracts in one function call instead of two\n', '  /// @param _spender The address of the contract able to transfer the tokens\n', '  /// @param _amount The amount of tokens to be approved for transfer\n', '  /// @return True if the function call was successful\n', '  function approveAndCall(\n', '    address _spender,\n', '    uint256 _amount,\n', '    bytes _extraData) public returns (bool success);\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @param _blockNumber The block number when the balance is queried\n', '  /// @return The balance at `_blockNumber`\n', '  function balanceOfAt(\n', '    address _owner,\n', '    uint _blockNumber) public constant returns (uint);\n', '\n', '  /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '  /// @param _blockNumber The block number when the totalSupply is queried\n', '  /// @return The total amount of tokens at `_blockNumber`\n', '  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '  /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '  /// @param _owner The address that will be assigned the new tokens\n', '  /// @param _amount The quantity of tokens generated\n', '  /// @return True if the tokens are generated correctly\n', '  function mintTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '\n', '  /// @notice Burns `_amount` tokens from `_owner`\n', '  /// @param _owner The address that will lose the tokens\n', '  /// @param _amount The quantity of tokens to burn\n', '  /// @return True if the tokens are burned correctly\n', '  function destroyTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '/////////////////\n', '// Finalize \n', '////////////////\n', '  function finalize() public;\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public;\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '}\n', '\n', '// File: contracts/interface/TokenController.sol\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '    /// @param _owner The address that sent the ether to create tokens\n', '    /// @return True if the ether is accepted, false if it throws\n', '  function proxyMintTokens(\n', '    address _owner, \n', '    uint _amount,\n', '    bytes32 _paidTxID) public returns(bool);\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param _from The origin of the transfer\n', '    /// @param _to The destination of the transfer\n', '    /// @param _amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param _owner The address that calls `approve()`\n', '    /// @param _spender The spender in the `approve()` call\n', '    /// @param _amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '  function onApprove(address _owner, address _spender, uint _amount) public\n', '    returns(bool);\n', '}\n', '\n', '// File: contracts/Distribution.sol\n', '\n', 'contract Distribution is Controlled, TokenController {\n', '\n', '  /// Record tx details for each minting operation\n', '  struct Transaction {\n', '    uint256 amount;\n', '    bytes32 paidTxID;\n', '  }\n', '\n', '  MiniMeTokenI public token;\n', '\n', '  address public reserveWallet; // Team&#39;s wallet address\n', '\n', '  uint256 public totalSupplyCap; // Total Token supply to be generated\n', '  uint256 public totalReserve; // A number of tokens to reserve for the team/bonuses\n', '\n', '  uint256 public finalizedBlock;\n', '\n', '  /// Record all transaction details for all minting operations\n', '  mapping (address => Transaction[]) allTransactions;\n', '\n', '  /// @param _token Address of the SEN token contract\n', '  ///  the contribution finalizes.\n', '  /// @param _reserveWallet Team&#39;s wallet address to distribute reserved pool\n', '  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\n', '  /// @param _totalReserve A number of tokens to reserve for the team/bonuses\n', '  function Distribution(\n', '    address _token,\n', '    address _reserveWallet,\n', '    uint256 _totalSupplyCap,\n', '    uint256 _totalReserve\n', '  ) public onlyController\n', '  {\n', '    // Initialize only once\n', '    assert(address(token) == 0x0);\n', '\n', '    token = MiniMeTokenI(_token);\n', '    reserveWallet = _reserveWallet;\n', '\n', '    require(_totalReserve < _totalSupplyCap);\n', '    totalSupplyCap = _totalSupplyCap;\n', '    totalReserve = _totalReserve;\n', '\n', '    assert(token.totalSupply() == 0);\n', '    assert(token.decimals() == 18); // Same amount of decimals as ETH\n', '  }\n', '\n', '  function distributionCap() public constant returns (uint256) {\n', '    return totalSupplyCap - totalReserve;\n', '  }\n', '\n', '  /// @notice This method can be called the distribution cap is reached only\n', '  function finalize() public onlyController {\n', '    assert(token.totalSupply() >= distributionCap());\n', '\n', '    // Mint reserve pool\n', '    doMint(reserveWallet, totalReserve);\n', '\n', '    finalizedBlock = getBlockNumber();\n', '    token.finalize(); // Token becomes unmintable after this\n', '\n', '    // Distribution controller becomes a Token controller\n', '    token.changeController(controller);\n', '\n', '    Finalized();\n', '  }\n', '\n', '//////////\n', '// TokenController functions\n', '//////////\n', '\n', '  function proxyMintTokens(\n', '    address _th,\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  ) public onlyController returns (bool)\n', '  {\n', '    require(_th != 0x0);\n', '\n', '    require(_amount + token.totalSupply() <= distributionCap());\n', '\n', '    doMint(_th, _amount);\n', '    addTransaction(\n', '      allTransactions[_th],\n', '      _amount,\n', '      _paidTxID);\n', '\n', '    Purchase(\n', '      _th,\n', '      _amount,\n', '      _paidTxID);\n', '\n', '    return true;\n', '  }\n', '\n', '  function onTransfer(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function onApprove(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  //////////\n', '  // Safety Methods\n', '  //////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public onlyController {\n', '    if (token.controller() == address(this)) {\n', '      token.claimTokens(_token);\n', '    }\n', '    if (_token == 0x0) {\n', '      controller.transfer(this.balance);\n', '      return;\n', '    }\n', '\n', '    ERC20Token otherToken = ERC20Token(_token);\n', '    uint256 balance = otherToken.balanceOf(this);\n', '    otherToken.transfer(controller, balance);\n', '    ClaimedTokens(_token, controller, balance);\n', '  }\n', '\n', '  //////////////////////////////////\n', '  // Minting tokens and oraclization\n', '  //////////////////////////////////\n', '\n', '  /// Total transaction count belong to an address\n', '  function totalTransactionCount(address _owner) public constant returns(uint) {\n', '    return allTransactions[_owner].length;\n', '  }\n', '\n', '  /// Query a transaction details by address and its index in transactions array\n', '  function getTransactionAtIndex(address _owner, uint index) public constant returns(\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  ) {\n', '    _amount = allTransactions[_owner][index].amount;\n', '    _paidTxID = allTransactions[_owner][index].paidTxID;\n', '  }\n', '\n', '  /// Save transaction details belong to an address\n', '  /// @param  transactions all transactions belong to an address\n', '  /// @param _amount amount of tokens issued in the transaction\n', '  /// @param _paidTxID blockchain tx_hash\n', '  function addTransaction(\n', '    Transaction[] storage transactions,\n', '    uint _amount,\n', '    bytes32 _paidTxID\n', '    ) internal\n', '  {\n', '    Transaction storage newTx = transactions[transactions.length++];\n', '    newTx.amount = _amount;\n', '    newTx.paidTxID = _paidTxID;\n', '  }\n', '\n', '  function doMint(address _th, uint256 _amount) internal {\n', '    assert(token.mintTokens(_th, _amount));\n', '  }\n', '\n', '//////////\n', '// Testing specific methods\n', '//////////\n', '\n', '  /// @notice This function is overridden by the test Mocks.\n', '  function getBlockNumber() internal constant returns (uint256) { return block.number; }\n', '\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', '  event Purchase(\n', '    address indexed _owner,\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  );\n', '  event Finalized();\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', '  Copyright 2017, Anton Egorov (Mothership Foundation)\n', '  Copyright 2017, An Hoang Phan Ngo (Mothership Foundation)\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '// File: contracts/interface/Controlled.sol\n', '\n', 'contract Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier\n', '  modifier onlyController {\n', '    require(msg.sender == controller);\n', '    _;\n', '  }\n', '\n', '  address public controller;\n', '\n', '  function Controlled() public { controller = msg.sender; }\n', '\n', '  /// @notice Changes the controller of the contract\n', '  /// @param _newController The new controller of the contract\n', '  function changeController(address _newController) public onlyController {\n', '    controller = _newController;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/Burnable.sol\n', '\n', '/// @dev Burnable introduces a burner role, which could be used to destroy\n', '///  tokens. The burner address could be changed by himself.\n', 'contract Burnable is Controlled {\n', '  address public burner;\n', '\n', '  /// @notice The function with this modifier could be called by a controller\n', '  /// as well as by a burner. But burner could use the onlt his/her address as\n', '  /// a target.\n', '  modifier onlyControllerOrBurner(address target) {\n', '    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\n', '    _;\n', '  }\n', '\n', '  modifier onlyBurner {\n', '    assert(msg.sender == burner);\n', '    _;\n', '  }\n', '\n', '  /// Contract creator become a burner by default\n', '  function Burnable() public { burner = msg.sender;}\n', '\n', '  /// @notice Change a burner address\n', '  /// @param _newBurner The new burner address\n', '  function changeBurner(address _newBurner) public onlyBurner {\n', '    burner = _newBurner;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/ERC20Token.sol\n', '\n', '// @dev Abstract contract for the full ERC 20 Token standard\n', '//  https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20Token {\n', '  /// total amount of tokens\n', '  function totalSupply() public view returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/interface/MiniMeTokenI.sol\n', '\n', '/// @dev MiniMeToken interface. Using this interface instead of whole contracts\n', '///  will reduce contract sise and gas cost\n', 'contract MiniMeTokenI is ERC20Token, Burnable {\n', '\n', "  string public name;                //The Token's name: e.g. DigixDAO Tokens\n", '  uint8 public decimals;             //Number of decimals of the smallest unit\n', '  string public symbol;              //An identifier: e.g. REP\n', '  string public version = "MMT_0.1"; //An arbitrary versioning scheme\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '  ///  its behalf, and then a function is triggered in the contract that is\n', '  ///  being approved, `_spender`. This allows users to use their tokens to\n', '  ///  interact with contracts in one function call instead of two\n', '  /// @param _spender The address of the contract able to transfer the tokens\n', '  /// @param _amount The amount of tokens to be approved for transfer\n', '  /// @return True if the function call was successful\n', '  function approveAndCall(\n', '    address _spender,\n', '    uint256 _amount,\n', '    bytes _extraData) public returns (bool success);\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @param _blockNumber The block number when the balance is queried\n', '  /// @return The balance at `_blockNumber`\n', '  function balanceOfAt(\n', '    address _owner,\n', '    uint _blockNumber) public constant returns (uint);\n', '\n', '  /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '  /// @param _blockNumber The block number when the totalSupply is queried\n', '  /// @return The total amount of tokens at `_blockNumber`\n', '  function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '  /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '  /// @param _owner The address that will be assigned the new tokens\n', '  /// @param _amount The quantity of tokens generated\n', '  /// @return True if the tokens are generated correctly\n', '  function mintTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '\n', '  /// @notice Burns `_amount` tokens from `_owner`\n', '  /// @param _owner The address that will lose the tokens\n', '  /// @param _amount The quantity of tokens to burn\n', '  /// @return True if the tokens are burned correctly\n', '  function destroyTokens(address _owner, uint _amount) public returns (bool);\n', '\n', '/////////////////\n', '// Finalize \n', '////////////////\n', '  function finalize() public;\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public;\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '}\n', '\n', '// File: contracts/interface/TokenController.sol\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '    /// @param _owner The address that sent the ether to create tokens\n', '    /// @return True if the ether is accepted, false if it throws\n', '  function proxyMintTokens(\n', '    address _owner, \n', '    uint _amount,\n', '    bytes32 _paidTxID) public returns(bool);\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param _from The origin of the transfer\n', '    /// @param _to The destination of the transfer\n', '    /// @param _amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '  function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param _owner The address that calls `approve()`\n', '    /// @param _spender The spender in the `approve()` call\n', '    /// @param _amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '  function onApprove(address _owner, address _spender, uint _amount) public\n', '    returns(bool);\n', '}\n', '\n', '// File: contracts/Distribution.sol\n', '\n', 'contract Distribution is Controlled, TokenController {\n', '\n', '  /// Record tx details for each minting operation\n', '  struct Transaction {\n', '    uint256 amount;\n', '    bytes32 paidTxID;\n', '  }\n', '\n', '  MiniMeTokenI public token;\n', '\n', "  address public reserveWallet; // Team's wallet address\n", '\n', '  uint256 public totalSupplyCap; // Total Token supply to be generated\n', '  uint256 public totalReserve; // A number of tokens to reserve for the team/bonuses\n', '\n', '  uint256 public finalizedBlock;\n', '\n', '  /// Record all transaction details for all minting operations\n', '  mapping (address => Transaction[]) allTransactions;\n', '\n', '  /// @param _token Address of the SEN token contract\n', '  ///  the contribution finalizes.\n', "  /// @param _reserveWallet Team's wallet address to distribute reserved pool\n", '  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\n', '  /// @param _totalReserve A number of tokens to reserve for the team/bonuses\n', '  function Distribution(\n', '    address _token,\n', '    address _reserveWallet,\n', '    uint256 _totalSupplyCap,\n', '    uint256 _totalReserve\n', '  ) public onlyController\n', '  {\n', '    // Initialize only once\n', '    assert(address(token) == 0x0);\n', '\n', '    token = MiniMeTokenI(_token);\n', '    reserveWallet = _reserveWallet;\n', '\n', '    require(_totalReserve < _totalSupplyCap);\n', '    totalSupplyCap = _totalSupplyCap;\n', '    totalReserve = _totalReserve;\n', '\n', '    assert(token.totalSupply() == 0);\n', '    assert(token.decimals() == 18); // Same amount of decimals as ETH\n', '  }\n', '\n', '  function distributionCap() public constant returns (uint256) {\n', '    return totalSupplyCap - totalReserve;\n', '  }\n', '\n', '  /// @notice This method can be called the distribution cap is reached only\n', '  function finalize() public onlyController {\n', '    assert(token.totalSupply() >= distributionCap());\n', '\n', '    // Mint reserve pool\n', '    doMint(reserveWallet, totalReserve);\n', '\n', '    finalizedBlock = getBlockNumber();\n', '    token.finalize(); // Token becomes unmintable after this\n', '\n', '    // Distribution controller becomes a Token controller\n', '    token.changeController(controller);\n', '\n', '    Finalized();\n', '  }\n', '\n', '//////////\n', '// TokenController functions\n', '//////////\n', '\n', '  function proxyMintTokens(\n', '    address _th,\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  ) public onlyController returns (bool)\n', '  {\n', '    require(_th != 0x0);\n', '\n', '    require(_amount + token.totalSupply() <= distributionCap());\n', '\n', '    doMint(_th, _amount);\n', '    addTransaction(\n', '      allTransactions[_th],\n', '      _amount,\n', '      _paidTxID);\n', '\n', '    Purchase(\n', '      _th,\n', '      _amount,\n', '      _paidTxID);\n', '\n', '    return true;\n', '  }\n', '\n', '  function onTransfer(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function onApprove(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  //////////\n', '  // Safety Methods\n', '  //////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public onlyController {\n', '    if (token.controller() == address(this)) {\n', '      token.claimTokens(_token);\n', '    }\n', '    if (_token == 0x0) {\n', '      controller.transfer(this.balance);\n', '      return;\n', '    }\n', '\n', '    ERC20Token otherToken = ERC20Token(_token);\n', '    uint256 balance = otherToken.balanceOf(this);\n', '    otherToken.transfer(controller, balance);\n', '    ClaimedTokens(_token, controller, balance);\n', '  }\n', '\n', '  //////////////////////////////////\n', '  // Minting tokens and oraclization\n', '  //////////////////////////////////\n', '\n', '  /// Total transaction count belong to an address\n', '  function totalTransactionCount(address _owner) public constant returns(uint) {\n', '    return allTransactions[_owner].length;\n', '  }\n', '\n', '  /// Query a transaction details by address and its index in transactions array\n', '  function getTransactionAtIndex(address _owner, uint index) public constant returns(\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  ) {\n', '    _amount = allTransactions[_owner][index].amount;\n', '    _paidTxID = allTransactions[_owner][index].paidTxID;\n', '  }\n', '\n', '  /// Save transaction details belong to an address\n', '  /// @param  transactions all transactions belong to an address\n', '  /// @param _amount amount of tokens issued in the transaction\n', '  /// @param _paidTxID blockchain tx_hash\n', '  function addTransaction(\n', '    Transaction[] storage transactions,\n', '    uint _amount,\n', '    bytes32 _paidTxID\n', '    ) internal\n', '  {\n', '    Transaction storage newTx = transactions[transactions.length++];\n', '    newTx.amount = _amount;\n', '    newTx.paidTxID = _paidTxID;\n', '  }\n', '\n', '  function doMint(address _th, uint256 _amount) internal {\n', '    assert(token.mintTokens(_th, _amount));\n', '  }\n', '\n', '//////////\n', '// Testing specific methods\n', '//////////\n', '\n', '  /// @notice This function is overridden by the test Mocks.\n', '  function getBlockNumber() internal constant returns (uint256) { return block.number; }\n', '\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', '  event Purchase(\n', '    address indexed _owner,\n', '    uint256 _amount,\n', '    bytes32 _paidTxID\n', '  );\n', '  event Finalized();\n', '}']
