['pragma solidity ^0.4.25;\n', '\n', 'contract GameBoard {\n', '\n', '  uint8 constant public minSquareId = 1;\n', '  uint8 constant public maxSquareId = 24;\n', '  uint8 constant public numSquares = 24;\n', '}\n', '\n', 'contract JackpotRules {\n', '  using SafeMath for uint256;\n', '\n', '  constructor() public {}\n', '\n', '  // NOTE: The next methods *must* add up to 100%\n', '\n', '  // 50%\n', '  function _winnerJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(2);\n', '  }\n', '\n', '  // 40%\n', '  function _landholderJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return (jackpot.mul(2)).div(5);\n', '  }\n', '\n', '  // 5%\n', '  function _nextPotJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(20);\n', '  }\n', '\n', '  // 5%\n', '  function _teamJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(20);\n', '  }\n', '}\n', '\n', 'library Math {\n', '  /**\n', '  * @dev Returns the largest of two numbers.\n', '  */\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns the smallest of two numbers.\n', '  */\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * @dev Calculates the average of two numbers. Since these are integers,\n', '  * averages of an even and odd number cannot be represented, and will be\n', '  * rounded down.\n', '  */\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract PullPayment {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public payments;\n', '    uint256 public totalPayments;\n', '\n', '    /**\n', '     * @dev Withdraw accumulated balance, called by payee.\n', '     */\n', '    function withdrawPayments() public {\n', '        address payee = msg.sender;\n', '        uint256 payment = payments[payee];\n', '\n', '        require(payment != 0);\n', '        require(address(this).balance >= payment);\n', '\n', '        totalPayments = totalPayments.sub(payment);\n', '        payments[payee] = 0;\n', '\n', '        payee.transfer(payment);\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '     * @param dest The destination address of the funds.\n', '     * @param amount The amount to transfer.\n', '     */\n', '    function asyncSend(address dest, uint256 amount) internal {\n', '        payments[dest] = payments[dest].add(amount);\n', '        totalPayments = totalPayments.add(amount);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract TaxRules {\n', '    using SafeMath for uint256;\n', '\n', '    constructor() public {}\n', '\n', '    // 10%\n', '    function _priceToTax(uint256 price) public pure returns (uint256) {\n', '        return price.div(10);\n', '    }\n', '\n', '    // NOTE: The next methods *must* add up to 100%\n', '\n', '    // 40%\n', '    function _jackpotTax(uint256 tax) public pure returns (uint256) {\n', '        return (tax.mul(2)).div(5);\n', '    }\n', '\n', '    // 38%\n', '    function _totalLandholderTax(uint256 tax) public pure returns (uint256) {\n', '        return (tax.mul(19)).div(50);\n', '    }\n', '\n', '    // 17%/12%\n', '    function _teamTax(uint256 tax, bool hasReferrer) public pure returns (uint256) {\n', '        if (hasReferrer) {\n', '            return (tax.mul(3)).div(25);\n', '        } else {\n', '            return (tax.mul(17)).div(100);\n', '        }\n', '    }\n', '    \n', '    // sell 25% of tokens\n', '    function _p3dSellPercentage(uint256 tokens) public pure returns (uint256) {\n', '        return tokens.div(4);\n', '    }\n', '\n', '    // 5% although only invoked if _teamTax is lower value\n', '    function _referrerTax(uint256 tax, bool hasReferrer)  public pure returns (uint256) {\n', '        if (hasReferrer) {\n', '            return tax.div(20);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // 5%\n', '    function _nextPotTax(uint256 tax) public pure returns (uint256) {\n', '        return tax.div(20);\n', '    }\n', '}\n', '\n', 'contract Commercializ3d is\n', '    GameBoard,\n', '    PullPayment,\n', '    Ownable,\n', '    TaxRules,\n', '    JackpotRules {\n', '    using SafeMath for uint256;\n', '    using Math for uint256;\n', '\n', '    enum Stage {\n', '        DutchAuction,\n', '        GameRounds\n', '    }\n', '    Stage public stage = Stage.DutchAuction;\n', '\n', '    modifier atStage(Stage _stage) {\n', '        require(\n', '            stage == _stage,\n', '            "Function cannot be called at this stage."\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(uint startingStage) public {\n', '        if (startingStage == uint(Stage.GameRounds)) {\n', '            stage = Stage.GameRounds;\n', '            _startGameRound();\n', '        } else {\n', '            _startAuction();\n', '        }\n', '    }\n', '\n', '    mapping(uint8 => address) public squareToOwner;\n', '    mapping(uint8 => uint256) public squareToPrice;\n', '    uint256 public totalSquareValue;\n', '\n', '    function _changeSquarePrice(uint8 squareId, uint256 newPrice) private {\n', '        uint256 oldPrice = squareToPrice[squareId];\n', '        squareToPrice[squareId] = newPrice;\n', '        totalSquareValue = (totalSquareValue.sub(oldPrice)).add(newPrice);\n', '    }\n', '\n', '    event SquareOwnerChanged(\n', '        uint8 indexed squareId,\n', '        address indexed oldOwner,\n', '        address indexed newOwner,\n', '        uint256 oldPrice,\n', '        uint256 newPrice\n', '    );\n', '\n', '    HourglassInterface constant P3DContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '    \n', '    function _buyP3D(uint256 amount) private {\n', '        P3DContract.buy.value(amount)(0xB111DaBb8EdD8260B5c1E471945A62bE2eE24470);\n', '    }\n', '    \n', '    function _sendP3D(address to, uint256 amount) private {\n', '        P3DContract.transfer(to, amount);\n', '    }\n', '    \n', '    function getP3DBalance() view public returns(uint256) {\n', '        return (P3DContract.balanceOf(address(this)));\n', '    }\n', '    \n', '    function getDivsBalance() view public returns(uint256) {\n', '        return (P3DContract.dividendsOf(address(this)));\n', '    }\n', '    \n', '    function withdrawContractBalance() external onlyOwner {\n', '        uint256 contractBalance = address(this).balance;\n', '        uint256 withdrawableBalance = contractBalance.sub(totalPayments);\n', '\n', '        // No withdrawal necessary if <= 0 balance\n', '        require(withdrawableBalance > 0);\n', '\n', '        asyncSend(msg.sender, withdrawableBalance);\n', '    }\n', '\n', '    event AuctionStarted(\n', '        uint256 startingAuctionPrice,\n', '        uint256 endingAuctionPrice,\n', '        uint256 auctionDuration,\n', '        uint256 startTime\n', '    );\n', '\n', '    event AuctionEnded(\n', '        uint256 endTime\n', '    );\n', '\n', '    uint256 constant public startingAuctionPrice = 0.1 ether;\n', '    uint256 constant public endingAuctionPrice = 0.05 ether;\n', '    uint256 constant public auctionDuration = 5 days; // period over which land price decreases linearly\n', '\n', '    uint256 public numBoughtSquares;\n', '    uint256 public auctionStartTime;\n', '\n', '    function buySquareAtAuction(uint8 squareId, uint256 newPrice, address referrer) public payable atStage(Stage.DutchAuction) {\n', '        require(\n', '            squareToOwner[squareId] == address(0) && squareToPrice[squareId] == 0,\n', '            "This square has already been auctioned off"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '        uint256 price = getSquarePriceAuction();\n', '\n', '        require(\n', '            msg.value >= tax.add(price),\n', '            "Must pay the full price and tax for a square on auction"\n', '        );\n', '\n', '        _distributeAuctionTax(msg.value, referrer);\n', '\n', '        squareToOwner[squareId] = msg.sender;\n', '        _changeSquarePrice(squareId, newPrice);\n', '\n', '        numBoughtSquares = numBoughtSquares.add(1);\n', '\n', '        emit SquareOwnerChanged(squareId, address(0), msg.sender, price, newPrice);\n', '\n', '        if (numBoughtSquares >= numSquares) {\n', '            endAuction();\n', '        }\n', '    }\n', '\n', '    function _distributeAuctionTax(uint256 tax, address referrer) private {\n', '        _distributeLandholderTax(_totalLandholderTax(tax));\n', '\n', '        uint256 totalJackpotTax = _jackpotTax(tax).add(_nextPotTax(tax));\n', '        nextJackpot = nextJackpot.add(totalJackpotTax);\n', '\n', '        // NOTE: referrer tax comes out of p3d tax\n', '        bool hasReferrer = referrer != address(0);\n', '        _buyP3D(_teamTax(tax, hasReferrer));\n', '        asyncSend(referrer, _referrerTax(tax, hasReferrer));\n', '    }\n', '\n', '    function getSquarePriceAuction() public view atStage(Stage.DutchAuction) returns (uint256) {\n', '        return endingAuctionPrice;\n', '    }\n', '\n', '    function endAuction() private {\n', '        require(\n', '            numBoughtSquares >= numSquares,\n', '            "All squares must be purchased to end round"\n', '        );\n', '\n', '        stage = Stage.GameRounds;\n', '        _startGameRound();\n', '\n', '        emit AuctionEnded(now);\n', '    }\n', '\n', '    function _startAuction() private {\n', '        auctionStartTime = now;\n', '        numBoughtSquares = 0;\n', '\n', '        emit AuctionStarted(startingAuctionPrice,\n', '                            endingAuctionPrice,\n', '                            auctionDuration,\n', '                            auctionStartTime);\n', '    }\n', '\n', '    uint256 constant public startingRoundExtension = 24 hours;\n', '    uint256 constant public halvingVolume = 10 ether;\n', '    uint256 constant public minRoundExtension = 10 seconds;\n', '\n', '    uint256 public roundNumber = 0;\n', '\n', '    uint256 public curExtensionVolume;\n', '    uint256 public curRoundExtension;\n', '\n', '    uint256 public roundEndTime;\n', '\n', '    uint256 public jackpot;\n', '    uint256 public nextJackpot;\n', '\n', '    event SquarePriceChanged(\n', '        uint8 indexed squareId,\n', '        address indexed owner,\n', '        uint256 oldPrice,\n', '        uint256 newPrice\n', '    );\n', '\n', '    event GameRoundStarted(\n', '        uint256 initJackpot,\n', '        uint256 endTime,\n', '        uint256 roundNumber\n', '    );\n', '\n', '    event GameRoundExtended(\n', '        uint256 endTime\n', '    );\n', '\n', '    event GameRoundEnded(\n', '        uint256 jackpot\n', '    );\n', '\n', '    function roundTimeRemaining() public view atStage(Stage.GameRounds) returns (uint256)  {\n', '        if (_roundOver()) {\n', '            return 0;\n', '        } else {\n', '            return roundEndTime.sub(now);\n', '        }\n', '    }\n', '\n', '    function _extendRound() private {\n', '        roundEndTime = roundEndTime.max(now.add(curRoundExtension));\n', '\n', '        emit GameRoundExtended(roundEndTime);\n', '    }\n', '\n', '    function _startGameRound() private {\n', '        curExtensionVolume = 0 ether;\n', '        curRoundExtension = startingRoundExtension;\n', '\n', '        jackpot = nextJackpot;\n', '        nextJackpot = 0;\n', '\n', '        roundNumber = roundNumber.add(1);\n', '\n', '        _extendRound();\n', '\n', '        emit GameRoundStarted(jackpot, roundEndTime, roundNumber);\n', '    }\n', '\n', '    function _roundOver() private view returns (bool) {\n', '        return now >= roundEndTime;\n', '    }\n', '\n', '    modifier duringRound() {\n', '        require(\n', '            !_roundOver(),\n', '            "Round is over"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // needed for round extension halving\n', '    function _logRoundExtensionVolume(uint256 amount) private {\n', '        curExtensionVolume = curExtensionVolume.add(amount);\n', '\n', '        if (curExtensionVolume >= halvingVolume) {\n', '            curRoundExtension = curRoundExtension.div(2).max(minRoundExtension);\n', '            curExtensionVolume = 0 ether;\n', '        }\n', '    }\n', '\n', '    function endGameRound() public atStage(Stage.GameRounds) {\n', '        require(\n', '            _roundOver(),\n', '            "Round must be over!"\n', '        );\n', '\n', '        _distributeJackpot();\n', '\n', '        emit GameRoundEnded(jackpot);\n', '\n', '        _startGameRound();\n', '    }\n', '\n', '    function setSquarePrice(uint8 squareId, uint256 newPrice, address referrer)\n', '        public\n', '        payable\n', '        atStage(Stage.GameRounds)\n', '        duringRound {\n', '        require(\n', '            squareToOwner[squareId] == msg.sender,\n', '            "Can\'t set square price for a square you don\'t own!"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '\n', '        require(\n', '            msg.value >= tax,\n', '            "Must pay tax on new square price!"\n', '        );\n', '\n', '        uint256 oldPrice = squareToPrice[squareId];\n', '        _distributeTax(msg.value, referrer);\n', '        _changeSquarePrice(squareId, newPrice);\n', '\n', "        // NOTE: Currently we extend round for 'every' square price change. Alternatively could do only on\n", '        // increases or decreases or changes exceeding some magnitude\n', '        _extendRound();\n', '        _logRoundExtensionVolume(msg.value);\n', '\n', '        emit SquarePriceChanged(squareId, squareToOwner[squareId], oldPrice, newPrice);\n', '    }\n', '\n', '    function buySquare(uint8 squareId, uint256 newPrice, address referrer)\n', '        public\n', '        payable\n', '        atStage(Stage.GameRounds)\n', '        duringRound {\n', '        address oldOwner = squareToOwner[squareId];\n', '        require(\n', '            oldOwner != msg.sender,\n', '            "Can\'t buy a square you already own"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '\n', '        uint256 oldPrice = squareToPrice[squareId];\n', '        require(\n', '            msg.value >= tax.add(oldPrice),\n', '            "Must pay full price and tax for square"\n', '        );\n', '\n', '        // pay seller\n', '        asyncSend(oldOwner, squareToPrice[squareId]);\n', '        squareToOwner[squareId] = msg.sender;\n', '\n', '        uint256 actualTax = msg.value.sub(oldPrice);\n', '        _distributeTax(actualTax, referrer);\n', '\n', '        _changeSquarePrice(squareId, newPrice);\n', '        _extendRound();\n', '        _logRoundExtensionVolume(msg.value);\n', '\n', '        emit SquareOwnerChanged(squareId, oldOwner, msg.sender, oldPrice, newPrice);\n', '    }\n', '\n', '    function _distributeJackpot() private {\n', '        uint256 winnerJackpot = _winnerJackpot(jackpot);\n', '        uint256 landholderJackpot = _landholderJackpot(jackpot);\n', '        \n', '        // get divs\n', '        uint256 divs = getDivsBalance();\n', '        if (divs > 0) {\n', '            P3DContract.withdraw();\n', '        }\n', '        \n', '        // add divs to landholderJackpot\n', '        landholderJackpot = landholderJackpot.add(divs);\n', '        \n', '        _distributeWinnerAndLandholderJackpot(winnerJackpot, landholderJackpot);\n', '\n', '        _buyP3D(_teamJackpot(jackpot));\n', '        \n', '        nextJackpot = nextJackpot.add(_nextPotJackpot(jackpot));\n', '    }\n', '\n', '    function _calculatePriceComplement(uint8 squareId) private view returns (uint256) {\n', '        return totalSquareValue.sub(squareToPrice[squareId]);\n', '    }\n', '\n', '    // NOTE: These are bundled together so that we only have to compute complements once\n', '    function _distributeWinnerAndLandholderJackpot(uint256 winnerJackpot, uint256 landholderJackpot) private {\n', '        uint256[] memory complements = new uint256[](numSquares + 1); // inc necessary b/c squares are 1-indexed\n', '        uint256 totalPriceComplement = 0;\n', '\n', '        uint256 bestComplement = 0;\n', '        uint8 lastWinningSquareId = 0;\n', '        for (uint8 i = minSquareId; i <= maxSquareId; i++) {\n', '            uint256 priceComplement = _calculatePriceComplement(i);\n', '\n', '            // update winner\n', '            if (bestComplement == 0 || priceComplement > bestComplement) {\n', '                bestComplement = priceComplement;\n', '                lastWinningSquareId = i;\n', '            }\n', '\n', '            complements[i] = priceComplement;\n', '            totalPriceComplement = totalPriceComplement.add(priceComplement);\n', '        }\n', '        uint256 numWinners = 0;\n', '        for (i = minSquareId; i <= maxSquareId; i++) {\n', '            if (_calculatePriceComplement(i) == bestComplement) {\n', '                numWinners++;\n', '            }\n', '        }\n', '        \n', '        // transfer some % P3D tokens to (why? see )\n', '        uint256 p3dTokens = getP3DBalance();\n', '    \n', '        // distribute jackpot among all winners. save time on the majority (1-winner) case\n', '        if (numWinners == 1) {\n', '            asyncSend(squareToOwner[lastWinningSquareId], winnerJackpot);\n', '            \n', '            if (p3dTokens > 0) {\n', '                _sendP3D(squareToOwner[lastWinningSquareId], _p3dSellPercentage(p3dTokens));\n', '            }\n', '        } else {\n', '            for (i = minSquareId; i <= maxSquareId; i++) {\n', '                if (_calculatePriceComplement(i) == bestComplement) {\n', '                    asyncSend(squareToOwner[i], winnerJackpot.div(numWinners));\n', '                    \n', '                    if (p3dTokens > 0) {\n', '                        _sendP3D(squareToOwner[i], _p3dSellPercentage(p3dTokens));\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // distribute landholder things\n', '        for (i = minSquareId; i <= maxSquareId; i++) {\n', "            // NOTE: We don't exclude the jackpot winner(s) here, so the winner(s) is paid 'twice'\n", '            uint256 landholderAllocation = complements[i].mul(landholderJackpot).div(totalPriceComplement);\n', '\n', '            asyncSend(squareToOwner[i], landholderAllocation);\n', '        }\n', '    }\n', '\n', '    function _distributeTax(uint256 tax, address referrer) private {\n', '        jackpot = jackpot.add(_jackpotTax(tax));\n', '\n', '        _distributeLandholderTax(_totalLandholderTax(tax));\n', '        nextJackpot = nextJackpot.add(_nextPotTax(tax));\n', '\n', '        // NOTE: referrer tax comes out of p3d tax\n', '        bool hasReferrer = referrer != address(0);\n', '        _buyP3D(_teamTax(tax, hasReferrer));\n', '        asyncSend(referrer, _referrerTax(tax, hasReferrer));\n', '    }\n', '\n', '    function _distributeLandholderTax(uint256 tax) private {\n', '        for (uint8 square = minSquareId; square <= maxSquareId; square++) {\n', '            if (squareToOwner[square] != address(0) && squareToPrice[square] != 0) {\n', '                uint256 squarePrice = squareToPrice[square];\n', '                uint256 allocation = tax.mul(squarePrice).div(totalSquareValue);\n', '\n', '                asyncSend(squareToOwner[square], allocation);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function() payable {}\n', '}\n', '\n', 'interface HourglassInterface  {\n', '    function() payable external;\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function sell(uint256 _amountOfTokens) external;\n', '    function reinvest() external;\n', '    function withdraw() external;\n', '    function exit() external;\n', '    function dividendsOf(address _playerAddress) external view returns(uint256);\n', '    function balanceOf(address _playerAddress) external view returns(uint256);\n', '    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n', '    function stakingRequirement() external view returns(uint256);\n', '}']