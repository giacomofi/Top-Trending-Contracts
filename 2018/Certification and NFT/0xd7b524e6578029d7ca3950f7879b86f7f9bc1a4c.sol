['pragma solidity ^0.4.16;\n', '\n', '/// @title SafeMath\n', '/// @dev Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title ERC20 Standard Token interface\n', 'contract IERC20Token {\n', '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '}\n', '\n', '/// @title ERC20 Standard Token implementation\n', 'contract ERC20Token is IERC20Token {\n', '    using SafeMath for uint256;\n', '\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;&#39;;\n', '    string public symbol = &#39;&#39;;\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0);\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool) {\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IOwned {\n', '    function owner() public constant returns (address) { owner; }\n', '    function transferOwnership(address _newOwner) public;\n', '}\n', '\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) validAddress(_newOwner) onlyOwner {\n', '        require(_newOwner != owner);\n', '        \n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/// @title BXN contract interface\n', 'contract ISmartToken {\n', '    function initialSupply() public constant returns (uint256) { initialSupply; }\n', '\n', '    function totalSoldTokens() public constant returns (uint256) { totalSoldTokens; }\n', '    function totalProjectToken() public constant returns (uint256) { totalProjectToken; }\n', '\n', '    function fundingEnabled() public constant returns (bool) { fundingEnabled; }\n', '    function transfersEnabled() public constant returns (bool) { transfersEnabled; }\n', '}\n', '\n', '/// @title BXN contract - crowdfunding code for BXN Project\n', 'contract SmartToken is ISmartToken, ERC20Token, Owned {\n', '    using SafeMath for uint256;\n', ' \n', '    // The current initial token supply.\n', '    uint256 public initialSupply = 80000000 ether;\n', '\n', '    // Cold wallet for distribution of tokens.\n', '    address public fundingWallet;\n', '\n', '    // The flag indicates if the BXN contract is in Funding state.\n', '    bool public fundingEnabled = true;\n', '\n', '    // The maximum tokens available for sale.\n', '    uint256 public maxSaleToken;\n', '\n', '    // Total number of tokens sold.\n', '    uint256 public totalSoldTokens;\n', '    // Total number of tokens for BXN Project.\n', '    uint256 public totalProjectToken;\n', '    uint256 private totalLockToken;\n', '\n', '    // The flag indicates if the BXN contract is in eneble / disable transfers.\n', '    bool public transfersEnabled = true; \n', '\n', '    // Wallets, which allowed the transaction during the crowdfunding.\n', '    mapping (address => bool) private fundingWallets;\n', '    // Wallets B2BX Project, which will be locked the tokens\n', '    mapping (address => allocationLock) public allocations;\n', '\n', '    struct allocationLock {\n', '        uint256 value;\n', '        uint256 end;\n', '        bool locked;\n', '    }\n', '\n', '    event Finalize(address indexed _from, uint256 _value);\n', '    event Lock(address indexed _from, address indexed _to, uint256 _value, uint256 _end);\n', '    event Unlock(address indexed _from, address indexed _to, uint256 _value);\n', '    event DisableTransfers(address indexed _from);\n', '\n', '    /// @notice BXN Project - Initializing crowdfunding.\n', '    /// @dev Constructor.\n', '    function SmartToken() ERC20Token("BITTXN", "BXN", 18) {\n', '        // The main, cold wallet for the distribution of tokens.\n', '        fundingWallet = msg.sender; \n', '\n', '        maxSaleToken = initialSupply.mul(100).div(100);\n', '\n', '        balanceOf[fundingWallet] = maxSaleToken;\n', '        totalSupply = initialSupply;\n', '\n', '        fundingWallets[fundingWallet] = true;\n', '        fundingWallets[0x39ee193486cC7A1A24bBaF84a301e8DD1265c11D] = true;\n', '        fundingWallets[0xBc5814406436173aCc1BD17398110b4F405C124A] = true;\n', '        fundingWallets[0xFc3aCeB2e8Bf624F0A924a6106fBC9e5FfBccD45] = true;\n', '        fundingWallets[0x6da56D0c21F7B2D32a1b411E806A6b4Ce4b51034] = true;\n', '        fundingWallets[0xc55c8D13CD5DA748c30918f899447983B53d896b] = true;\n', '    }\n', '\n', '    // Validates an address - currently only checks that it isn&#39;t null.\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier transfersAllowed(address _address) {\n', '        if (fundingEnabled) {\n', '            require(fundingWallets[_address]);\n', '        }\n', '\n', '        require(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    /// @notice This function is disabled during the crowdfunding.\n', '    /// @dev Send tokens.\n', '    /// @param _to address      The address of the tokens recipient.\n', '    /// @param _value _value    The amount of token to be transferred.\n', '    function transfer(address _to, uint256 _value) public validAddress(_to) transfersAllowed(msg.sender) returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @notice This function is disabled during the crowdfunding.\n', '    /// @dev Send from tokens.\n', '    /// @param _from address    The address of the sender of the token\n', '    /// @param _to address      The address of the tokens recipient.\n', '    /// @param _value _value    The amount of token to be transferred.\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) transfersAllowed(_from) returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice This function can accept for blocking no more than "totalProjectToken".\n', '    /// @dev Lock tokens to a specified address.\n', '    /// @param _to address      The address to lock tokens to.\n', '    /// @param _value uint256   The amount of tokens to be locked.\n', '    /// @param _end uint256     The end of the lock period.\n', '    function lock(address _to, uint256 _value, uint256 _end) internal validAddress(_to) onlyOwner returns (bool) {\n', '        require(_value > 0);\n', '\n', '        assert(totalProjectToken > 0);\n', '\n', '        // Check that this lock doesn&#39;t exceed the total amount of tokens currently available for totalProjectToken.\n', '        totalLockToken = totalLockToken.add(_value);\n', '        assert(totalProjectToken >= totalLockToken);\n', '\n', '        // Make sure that a single address can be locked tokens only once.\n', '        require(allocations[_to].value == 0);\n', '\n', '        // Assign a new lock.\n', '        allocations[_to] = allocationLock({\n', '            value: _value,\n', '            end: _end,\n', '            locked: true\n', '        });\n', '\n', '        Lock(this, _to, _value, _end);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Only the owner of a locked wallet can unlock the tokens.\n', '    /// @dev Unlock tokens at the address to the caller function.\n', '    function unlock() external {\n', '        require(allocations[msg.sender].locked);\n', '        require(now >= allocations[msg.sender].end);\n', '        \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);\n', '\n', '        allocations[msg.sender].locked = false;\n', '\n', '        Transfer(this, msg.sender, allocations[msg.sender].value);\n', '        Unlock(this, msg.sender, allocations[msg.sender].value);\n', '    }\n', '\n', '    /// @notice BXN Allocation - finalize crowdfunding & time-locked vault of tokens allocated\n', '    /// to BXN company, developers and Airdrop program.\n', '    function finalize() external onlyOwner {\n', '        require(fundingEnabled);\n', '\n', '        // Get total sold tokens on the fundingWallet.\n', '        // totalSoldTokens is 80% of the total number of tokens.\n', '        totalSoldTokens = maxSaleToken.sub(balanceOf[fundingWallet]);\n', '\n', '        // totalProjectToken = totalSoldTokens * 50 / 50 (50% this is BXN Project & 50% this is totalSoldTokens)\n', '        //\n', '        // |----------totalSoldTokens-----totalProjectToken|\n', '        // |================50%====|================50%====|\n', '        // |totalSupply=(totalSoldTokens+totalProjectToken)|\n', '        totalProjectToken = totalSoldTokens.mul(50).div(50);\n', '\n', '        // BXN Prodject allocations tokens.\n', '        // 90% of the totalProjectToken tokens (== 45% totalSupply) go to BXN Company.\n', '        lock(0xf03eb5eD89Da5ccAC43498A2C56434e30505AB09, totalProjectToken.mul(90).div(100), now);\n', '        // 10% of the totalProjectToken tokens (== 5% totalSupply) go to Airdrop program.\n', '        lock(0xCAF7149Ef61E54F72ACdC7f44a05E5d7D1Db134B, totalProjectToken.mul(10).div(100), now);\n', '        \n', '        // Zeroing a cold wallet.\n', '        balanceOf[fundingWallet] = 0;\n', '\n', '        // End of crowdfunding.\n', '        fundingEnabled = false;\n', '\n', '        // End of crowdfunding.\n', '        Transfer(this, fundingWallet, 0);\n', '        Finalize(msg.sender, totalSupply);\n', '    }\n', '    /// @notice Disable all transfers in case of a vulnerability found in the contract or other systems.\n', '    /// @dev Disable transfers in BXN contract.\n', '    function disableTransfers() external onlyOwner {\n', '        require(transfersEnabled);\n', '\n', '        transfersEnabled = false;\n', '\n', '        DisableTransfers(msg.sender);\n', '    }\n', '\n', '    function enableTransfers() external onlyOwner {\n', '        require(!transfersEnabled);\n', '\n', '        transfersEnabled = !false;\n', '\n', '        DisableTransfers(msg.sender);\n', '    }\n', '    /// @dev Disable the hot wallets for transfers.\n', '    /// @param _address address Address in fundingWallets[]\n', '    function disableFundingWallets(address _address) external onlyOwner {\n', '        require(fundingEnabled);\n', '        require(fundingWallet != _address);\n', '        require(fundingWallets[_address]);\n', '\n', '        fundingWallets[_address] = false;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '/// @title SafeMath\n', '/// @dev Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/// @title ERC20 Standard Token interface\n', 'contract IERC20Token {\n', '    function name() public constant returns (string) { name; }\n', '    function symbol() public constant returns (string) { symbol; }\n', '    function decimals() public constant returns (uint8) { decimals; }\n', '    function totalSupply() public constant returns (uint256) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '}\n', '\n', '/// @title ERC20 Standard Token implementation\n', 'contract ERC20Token is IERC20Token {\n', '    using SafeMath for uint256;\n', '\n', "    string public standard = 'Token 0.1';\n", "    string public name = '';\n", "    string public symbol = '';\n", '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0);\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) returns (bool) {\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool) {\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract IOwned {\n', '    function owner() public constant returns (address) { owner; }\n', '    function transferOwnership(address _newOwner) public;\n', '}\n', '\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) validAddress(_newOwner) onlyOwner {\n', '        require(_newOwner != owner);\n', '        \n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/// @title BXN contract interface\n', 'contract ISmartToken {\n', '    function initialSupply() public constant returns (uint256) { initialSupply; }\n', '\n', '    function totalSoldTokens() public constant returns (uint256) { totalSoldTokens; }\n', '    function totalProjectToken() public constant returns (uint256) { totalProjectToken; }\n', '\n', '    function fundingEnabled() public constant returns (bool) { fundingEnabled; }\n', '    function transfersEnabled() public constant returns (bool) { transfersEnabled; }\n', '}\n', '\n', '/// @title BXN contract - crowdfunding code for BXN Project\n', 'contract SmartToken is ISmartToken, ERC20Token, Owned {\n', '    using SafeMath for uint256;\n', ' \n', '    // The current initial token supply.\n', '    uint256 public initialSupply = 80000000 ether;\n', '\n', '    // Cold wallet for distribution of tokens.\n', '    address public fundingWallet;\n', '\n', '    // The flag indicates if the BXN contract is in Funding state.\n', '    bool public fundingEnabled = true;\n', '\n', '    // The maximum tokens available for sale.\n', '    uint256 public maxSaleToken;\n', '\n', '    // Total number of tokens sold.\n', '    uint256 public totalSoldTokens;\n', '    // Total number of tokens for BXN Project.\n', '    uint256 public totalProjectToken;\n', '    uint256 private totalLockToken;\n', '\n', '    // The flag indicates if the BXN contract is in eneble / disable transfers.\n', '    bool public transfersEnabled = true; \n', '\n', '    // Wallets, which allowed the transaction during the crowdfunding.\n', '    mapping (address => bool) private fundingWallets;\n', '    // Wallets B2BX Project, which will be locked the tokens\n', '    mapping (address => allocationLock) public allocations;\n', '\n', '    struct allocationLock {\n', '        uint256 value;\n', '        uint256 end;\n', '        bool locked;\n', '    }\n', '\n', '    event Finalize(address indexed _from, uint256 _value);\n', '    event Lock(address indexed _from, address indexed _to, uint256 _value, uint256 _end);\n', '    event Unlock(address indexed _from, address indexed _to, uint256 _value);\n', '    event DisableTransfers(address indexed _from);\n', '\n', '    /// @notice BXN Project - Initializing crowdfunding.\n', '    /// @dev Constructor.\n', '    function SmartToken() ERC20Token("BITTXN", "BXN", 18) {\n', '        // The main, cold wallet for the distribution of tokens.\n', '        fundingWallet = msg.sender; \n', '\n', '        maxSaleToken = initialSupply.mul(100).div(100);\n', '\n', '        balanceOf[fundingWallet] = maxSaleToken;\n', '        totalSupply = initialSupply;\n', '\n', '        fundingWallets[fundingWallet] = true;\n', '        fundingWallets[0x39ee193486cC7A1A24bBaF84a301e8DD1265c11D] = true;\n', '        fundingWallets[0xBc5814406436173aCc1BD17398110b4F405C124A] = true;\n', '        fundingWallets[0xFc3aCeB2e8Bf624F0A924a6106fBC9e5FfBccD45] = true;\n', '        fundingWallets[0x6da56D0c21F7B2D32a1b411E806A6b4Ce4b51034] = true;\n', '        fundingWallets[0xc55c8D13CD5DA748c30918f899447983B53d896b] = true;\n', '    }\n', '\n', "    // Validates an address - currently only checks that it isn't null.\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier transfersAllowed(address _address) {\n', '        if (fundingEnabled) {\n', '            require(fundingWallets[_address]);\n', '        }\n', '\n', '        require(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    /// @notice This function is disabled during the crowdfunding.\n', '    /// @dev Send tokens.\n', '    /// @param _to address      The address of the tokens recipient.\n', '    /// @param _value _value    The amount of token to be transferred.\n', '    function transfer(address _to, uint256 _value) public validAddress(_to) transfersAllowed(msg.sender) returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @notice This function is disabled during the crowdfunding.\n', '    /// @dev Send from tokens.\n', '    /// @param _from address    The address of the sender of the token\n', '    /// @param _to address      The address of the tokens recipient.\n', '    /// @param _value _value    The amount of token to be transferred.\n', '    function transferFrom(address _from, address _to, uint256 _value) public validAddress(_to) transfersAllowed(_from) returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice This function can accept for blocking no more than "totalProjectToken".\n', '    /// @dev Lock tokens to a specified address.\n', '    /// @param _to address      The address to lock tokens to.\n', '    /// @param _value uint256   The amount of tokens to be locked.\n', '    /// @param _end uint256     The end of the lock period.\n', '    function lock(address _to, uint256 _value, uint256 _end) internal validAddress(_to) onlyOwner returns (bool) {\n', '        require(_value > 0);\n', '\n', '        assert(totalProjectToken > 0);\n', '\n', "        // Check that this lock doesn't exceed the total amount of tokens currently available for totalProjectToken.\n", '        totalLockToken = totalLockToken.add(_value);\n', '        assert(totalProjectToken >= totalLockToken);\n', '\n', '        // Make sure that a single address can be locked tokens only once.\n', '        require(allocations[_to].value == 0);\n', '\n', '        // Assign a new lock.\n', '        allocations[_to] = allocationLock({\n', '            value: _value,\n', '            end: _end,\n', '            locked: true\n', '        });\n', '\n', '        Lock(this, _to, _value, _end);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice Only the owner of a locked wallet can unlock the tokens.\n', '    /// @dev Unlock tokens at the address to the caller function.\n', '    function unlock() external {\n', '        require(allocations[msg.sender].locked);\n', '        require(now >= allocations[msg.sender].end);\n', '        \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(allocations[msg.sender].value);\n', '\n', '        allocations[msg.sender].locked = false;\n', '\n', '        Transfer(this, msg.sender, allocations[msg.sender].value);\n', '        Unlock(this, msg.sender, allocations[msg.sender].value);\n', '    }\n', '\n', '    /// @notice BXN Allocation - finalize crowdfunding & time-locked vault of tokens allocated\n', '    /// to BXN company, developers and Airdrop program.\n', '    function finalize() external onlyOwner {\n', '        require(fundingEnabled);\n', '\n', '        // Get total sold tokens on the fundingWallet.\n', '        // totalSoldTokens is 80% of the total number of tokens.\n', '        totalSoldTokens = maxSaleToken.sub(balanceOf[fundingWallet]);\n', '\n', '        // totalProjectToken = totalSoldTokens * 50 / 50 (50% this is BXN Project & 50% this is totalSoldTokens)\n', '        //\n', '        // |----------totalSoldTokens-----totalProjectToken|\n', '        // |================50%====|================50%====|\n', '        // |totalSupply=(totalSoldTokens+totalProjectToken)|\n', '        totalProjectToken = totalSoldTokens.mul(50).div(50);\n', '\n', '        // BXN Prodject allocations tokens.\n', '        // 90% of the totalProjectToken tokens (== 45% totalSupply) go to BXN Company.\n', '        lock(0xf03eb5eD89Da5ccAC43498A2C56434e30505AB09, totalProjectToken.mul(90).div(100), now);\n', '        // 10% of the totalProjectToken tokens (== 5% totalSupply) go to Airdrop program.\n', '        lock(0xCAF7149Ef61E54F72ACdC7f44a05E5d7D1Db134B, totalProjectToken.mul(10).div(100), now);\n', '        \n', '        // Zeroing a cold wallet.\n', '        balanceOf[fundingWallet] = 0;\n', '\n', '        // End of crowdfunding.\n', '        fundingEnabled = false;\n', '\n', '        // End of crowdfunding.\n', '        Transfer(this, fundingWallet, 0);\n', '        Finalize(msg.sender, totalSupply);\n', '    }\n', '    /// @notice Disable all transfers in case of a vulnerability found in the contract or other systems.\n', '    /// @dev Disable transfers in BXN contract.\n', '    function disableTransfers() external onlyOwner {\n', '        require(transfersEnabled);\n', '\n', '        transfersEnabled = false;\n', '\n', '        DisableTransfers(msg.sender);\n', '    }\n', '\n', '    function enableTransfers() external onlyOwner {\n', '        require(!transfersEnabled);\n', '\n', '        transfersEnabled = !false;\n', '\n', '        DisableTransfers(msg.sender);\n', '    }\n', '    /// @dev Disable the hot wallets for transfers.\n', '    /// @param _address address Address in fundingWallets[]\n', '    function disableFundingWallets(address _address) external onlyOwner {\n', '        require(fundingEnabled);\n', '        require(fundingWallet != _address);\n', '        require(fundingWallets[_address]);\n', '\n', '        fundingWallets[_address] = false;\n', '    }\n', '\n', '}']
