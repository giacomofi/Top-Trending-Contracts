['pragma solidity ^0.4.24;\n', '\n', 'library DataSet {\n', '\n', '    enum RoundState {\n', '        UNKNOWN,        // aim to differ from normal states\n', '        STARTED,        // start current round\n', '        STOPPED,        // stop current round\n', '        DRAWN,          // draw winning number\n', '        ASSIGNED        // assign to foundation, winner\n', '    }\n', '\n', '    struct Round {\n', '        uint256                         count;              // record total numbers sold already\n', '        uint256                         timestamp;          // timestamp refer to first bet(round start)\n', '        uint256                         blockNumber;        // block number refer to last bet\n', '        uint256                         drawBlockNumber;    // block number refer to draw winning number\n', '        RoundState                      state;              // round state\n', '        uint256                         pond;               // amount refer to current round\n', '        uint256                         winningNumber;      // winning number\n', "        address                         winner;             // winner's address\n", '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title NumberCompressor\n', ' * @dev Number compressor to storage the begin and end numbers into a uint256\n', ' */\n', 'library NumberCompressor {\n', '\n', '    uint256 constant private MASK = 16777215;   // 2 ** 24 - 1\n', '\n', '    function encode(uint256 _begin, uint256 _end, uint256 _ceiling) internal pure returns (uint256)\n', '    {\n', '        require(_begin <= _end && _end < _ceiling, "number is invalid");\n', '\n', '        return _begin << 24 | _end;\n', '    }\n', '\n', '    function decode(uint256 _value) internal pure returns (uint256, uint256)\n', '    {\n', '        uint256 end = _value & MASK;\n', '        uint256 begin = (_value >> 24) & MASK;\n', '        return (begin, end);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\n', ' * - added sqrt\n', ' * - added sq\n', ' * - added pwr\n', ' * - changed asserts to requires with error log outputs\n', ' * - removed div, its useless\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b, "SafeMath mul failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(b <= a, "SafeMath sub failed");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "SafeMath add failed");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y)\n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y)\n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '\n', '    /**\n', '     * @dev x to the power of y\n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else\n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', 'contract Events {\n', '\n', '    event onActivate\n', '    (\n', '        address indexed addr,\n', '        uint256 timestamp,\n', '        uint256 bonus,\n', '        uint256 issued_numbers\n', '    );\n', '\n', '    event onDraw\n', '    (\n', '        uint256 timestatmp,\n', '        uint256 blockNumber,\n', '        uint256 roundID,\n', '        uint256 winningNumber\n', '    );\n', '\n', '    event onStartRunnd\n', '    (\n', '        uint256 timestamp,\n', '        uint256 roundID\n', '    );\n', '\n', '    event onBet\n', '    (\n', '        address indexed addr,\n', '        uint256 timestamp,\n', '        uint256 roundID,\n', '        uint256 beginNumber,\n', '        uint256 endNumber\n', '    );\n', '\n', '    event onAssign\n', '    (\n', '        address indexed operatorAddr,\n', '        uint256 timestatmp,\n', '        address indexed winnerAddr,\n', '        uint256 roundID,\n', '        uint256 pond,\n', '        uint256 bonus,      // assigned to winner\n', '        uint256 fund        // assigned to platform\n', '    );\n', '\n', '    event onRefund\n', '    (\n', '        address indexed operatorAddr,\n', '        uint256 timestamp,\n', '        address indexed playerAddr,\n', '        uint256 count,\n', '        uint256 amount\n', '    );\n', '\n', '    event onLastRefund\n', '    (\n', '        address indexed operatorAddr,\n', '        uint256 timestamp,\n', '        address indexed platformAddr,\n', '        uint256 amout\n', '    );\n', '\n', '}\n', '\n', 'contract Winner is Events {\n', '\n', '    using SafeMath for *;\n', '\n', '    uint256     constant private    MIN_BET = 0.01 ether;                                   // min bet every time\n', '    uint256     constant private    PRICE   = 0.01 ether;                                   // 0.01 ether every number\n', '    uint256     constant private    MAX_DURATION = 30 days;                                 // max duration every round\n', '    uint256     constant private    REFUND_RATE = 90;                                       // refund rate to player(%)\n', "    address     constant private    platform = 0x1f79bfeCe98447ac5466Fd9b8F71673c780566Df;  // paltform's address\n", '    uint256     private             curRoundID;                                             // current round\n', '    uint256     private             drawnRoundID;                                           // already drawn round\n', '    uint256     private             drawnBlockNumber;                                       // already drawn a round in block\n', '    uint256     private             bonus;                                                  // bonus assigned to the winner\n', '    uint256     private             issued_numbers;                                         // total numbers every round\n', '    bool        private             initialized;                                            // game is initialized or not\n', '\n', '    // (roundID => data) returns round data\n', '    mapping (uint256 => DataSet.Round) private rounds;\n', "    // (roundID => address => numbers) returns player's numbers in round\n", '    mapping (uint256 => mapping(address => uint256[])) private playerNumbers;\n', '    mapping (address => bool) private administrators;\n', '\n', '    // default constructor\n', '    constructor() public {\n', '    }\n', '\n', '    /**\n', '     * @dev check sender must be administrators\n', '     */\n', '    modifier isAdmin() {\n', '        require(administrators[msg.sender], "only administrators");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev make sure no one can interact with contract until it has\n', '     * been initialized.\n', '     */\n', '    modifier isInitialized () {\n', '        require(initialized == true, "game is inactive");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev prevent contract from interacting with external contracts.\n', '     */\n', '    modifier isHuman() {\n', '        address _addr = msg.sender;\n', '        uint256 _codeLength;\n', '\n', '        assembly {_codeLength := extcodesize(_addr)}\n', '        require(_codeLength == 0, "sorry, humans only");\n', '        _;\n', '    }\n', '\n', '    /**\n', "     * @dev check the bet's bound\n", '     * @param _eth the eth amount\n', '     * In order to ensure as many as possiable players envolve in the\n', '     * game, you can only buy no more than 2 * issued_numbers every time.\n', '     */\n', '    modifier isWithinLimits(uint256 _eth) {\n', '        require(_eth >= MIN_BET, "the bet is too small");\n', '        require(_eth <= PRICE.mul(issued_numbers).mul(2), "the bet is too big");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev default to bet\n', '     */\n', '    function() public payable isHuman() isInitialized() isWithinLimits(msg.value)\n', '    {\n', '        bet(msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev initiate game\n', '     * @param _bonus the bonus assigned the winner every round\n', '     * @param _issued_numbers the quantity of candidate numbers every round\n', '     */\n', '    function initiate(uint256 _bonus, uint256 _issued_numbers) public isHuman()\n', '    {\n', '        // can only be initialized once\n', '        require(initialized == false, "it has been initialized already");\n', '        require(_bonus > 0, "bonus is invalid");\n', '        require(_issued_numbers > 0, "issued_numbers is invalid");\n', '\n', '        // initiate global parameters\n', '        initialized = true;\n', '        administrators[msg.sender] = true;\n', '        bonus = _bonus;\n', '        issued_numbers = _issued_numbers;\n', '\n', '        emit onActivate(msg.sender, block.timestamp, bonus, issued_numbers);\n', '\n', '        // start the first round game\n', '        curRoundID = 1;\n', '        rounds[curRoundID].state = DataSet.RoundState.STARTED;\n', '        rounds[curRoundID].timestamp = block.timestamp;\n', '        drawnRoundID = 0;\n', '\n', '        emit onStartRunnd(block.timestamp, curRoundID);\n', '    }\n', '\n', '    /**\n', '     * @dev draw winning number\n', '     */\n', '    function drawNumber() private view returns(uint256) {\n', '        return uint256(keccak256(abi.encodePacked(\n', '\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 1))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 2))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 3))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 4))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 5))))) / (block.timestamp)).add\n', '            ((uint256(keccak256(abi.encodePacked(block.blockhash(block.number - 6))))) / (block.timestamp))\n', '\n', '        ))) % issued_numbers;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev bet\n', '     * @param _amount the amount for a bet\n', '     */\n', '    function bet(uint256 _amount) private\n', '    {\n', '        // 1. draw the winning number if it is necessary\n', '        if (block.number != drawnBlockNumber\n', '            && curRoundID > drawnRoundID\n', '            && rounds[drawnRoundID + 1].count == issued_numbers\n', '            && block.number >= rounds[drawnRoundID + 1].blockNumber + 7)\n', '        {\n', '            drawnBlockNumber = block.number;\n', '            drawnRoundID += 1;\n', '\n', '            rounds[drawnRoundID].winningNumber = drawNumber();\n', '            rounds[drawnRoundID].state = DataSet.RoundState.DRAWN;\n', '            rounds[drawnRoundID].drawBlockNumber = drawnBlockNumber;\n', '\n', '            emit onDraw(block.timestamp, drawnBlockNumber, drawnRoundID, rounds[drawnRoundID].winningNumber);\n', '        }\n', '\n', '        // 2. bet\n', '        uint256 amount = _amount;\n', '        while (true)\n', '        {\n', '            // in every round, one can buy min(max, available) numbers.\n', '            uint256 max = issued_numbers - rounds[curRoundID].count;\n', '            uint256 available = amount.div(PRICE).min(max);\n', '\n', '            if (available == 0)\n', '            {\n', '                // on condition that the PRICE is 0.01 eth, if the player pays 0.056 eth for\n', '                // a bet, then the player can exchange only five number, as 0.056/0.01 = 5,\n', '                // and the rest 0.06 eth distributed to the pond of current round.\n', '                if (amount != 0)\n', '                {\n', '                    rounds[curRoundID].pond += amount;\n', '                }\n', '                break;\n', '            }\n', '            uint256[] storage numbers = playerNumbers[curRoundID][msg.sender];\n', '            uint256 begin = rounds[curRoundID].count;\n', '            uint256 end = begin + available - 1;\n', '            uint256 compressedNumber = NumberCompressor.encode(begin, end, issued_numbers);\n', '            numbers.push(compressedNumber);\n', '            rounds[curRoundID].pond += available.mul(PRICE);\n', '            rounds[curRoundID].count += available;\n', '            amount -= available.mul(PRICE);\n', '\n', '            emit onBet(msg.sender, block.timestamp, curRoundID, begin, end);\n', '\n', '            if (rounds[curRoundID].count == issued_numbers)\n', '            {\n', '                // end current round and start the next round\n', '                rounds[curRoundID].blockNumber = block.number;\n', '                rounds[curRoundID].state = DataSet.RoundState.STOPPED;\n', '                curRoundID += 1;\n', '                rounds[curRoundID].state = DataSet.RoundState.STARTED;\n', '                rounds[curRoundID].timestamp = block.timestamp;\n', '\n', '                emit onStartRunnd(block.timestamp, curRoundID);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev assign for a round\n', '     * @param _roundID the round ID\n', '     */\n', '    function assign(uint256 _roundID) external isHuman() isInitialized()\n', '    {\n', '        assign2(msg.sender, _roundID);\n', '    }\n', '\n', '    /**\n', '     * @dev assign for a round\n', "     * @param _player the player's address\n", '     * @param _roundID the round ID\n', '     */\n', '    function assign2(address _player, uint256 _roundID) public isHuman() isInitialized()\n', '    {\n', '        require(rounds[_roundID].state == DataSet.RoundState.DRAWN, "it\'s not time for assigning");\n', '\n', '        uint256[] memory numbers = playerNumbers[_roundID][_player];\n', '        require(numbers.length > 0, "player did not involve in");\n', '        uint256 targetNumber = rounds[_roundID].winningNumber;\n', '        for (uint256 i = 0; i < numbers.length; i ++)\n', '        {\n', '            (uint256 start, uint256 end) = NumberCompressor.decode(numbers[i]);\n', '            if (targetNumber >= start && targetNumber <= end)\n', '            {\n', '                // assgin bonus to player, and the rest of the pond to platform\n', '                uint256 fund = rounds[_roundID].pond.sub(bonus);\n', '                _player.transfer(bonus);\n', '                platform.transfer(fund);\n', '                rounds[_roundID].state = DataSet.RoundState.ASSIGNED;\n', '                rounds[_roundID].winner = _player;\n', '\n', '                emit onAssign(msg.sender, block.timestamp, _player, _roundID, rounds[_roundID].pond, bonus, fund);\n', '\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev refund to player and platform\n', '     */\n', '    function refund() external isHuman() isInitialized()\n', '    {\n', '        refund2(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev refund to player and platform\n', "     * @param _player the player's address\n", '     */\n', '    function refund2(address _player) public isInitialized() isHuman()\n', '    {\n', '        require(block.timestamp.sub(rounds[curRoundID].timestamp) >= MAX_DURATION, "it\'s not time for refunding");\n', '\n', '        // 1. count numbers owned by the player\n', '        uint256[] storage numbers = playerNumbers[curRoundID][_player];\n', '        require(numbers.length > 0, "player did not involve in");\n', '\n', '        uint256 count = 0;\n', '        for (uint256 i = 0; i < numbers.length; i ++)\n', '        {\n', '            (uint256 begin, uint256 end) = NumberCompressor.decode(numbers[i]);\n', '            count += (end - begin + 1);\n', '        }\n', '\n', '        // 2. refund 90% to the player\n', '        uint256 amount = count.mul(PRICE).mul(REFUND_RATE).div(100);\n', '        rounds[curRoundID].pond = rounds[curRoundID].pond.sub(amount);\n', '        _player.transfer(amount);\n', '\n', '        emit onRefund(msg.sender, block.timestamp, _player, count, amount);\n', '\n', '        // 3. refund the rest(abount 10% of the pond) to the platform if the player is the last to refund\n', '        rounds[curRoundID].count -= count;\n', '        if (rounds[curRoundID].count == 0)\n', '        {\n', '            uint256 last = rounds[curRoundID].pond;\n', '            platform.transfer(last);\n', '            rounds[curRoundID].pond = 0;\n', '\n', '            emit onLastRefund(msg.sender, block.timestamp, platform, last);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev return player's numbers in the round\n", '     * @param _roundID round ID\n', "     * @param _palyer player's address\n", "     * @return uint256[], player's numbers\n", '     */\n', '    function getPlayerRoundNumbers(uint256 _roundID, address _palyer) public view returns(uint256[])\n', '    {\n', '        return playerNumbers[_roundID][_palyer];\n', '    }\n', '\n', '    /**\n', "     * @dev return round's information\n", '     * @param _roundID round ID\n', "     * @return uint256, quantity of round's numbers\n", '     * @return uint256, block number refer to last bet\n', '     * @return uint256, block number refer to draw winning number\n', "     * @return uint256, round's running state\n", "     * @return uint256, round's pond\n", "     * @return uint256, round's winning number if drawn\n", "     * @return address, round's winner if assigned\n", '     */\n', '    function getRoundInfo(uint256 _roundID) public view\n', '        returns(uint256, uint256, uint256, uint256, uint256, uint256, address)\n', '    {\n', '        return (\n', '            rounds[_roundID].count,\n', '            rounds[_roundID].blockNumber,\n', '            rounds[_roundID].drawBlockNumber,\n', '            uint256(rounds[_roundID].state),\n', '            rounds[_roundID].pond,\n', '            rounds[_roundID].winningNumber,\n', '            rounds[_roundID].winner\n', '        );\n', '    }\n', '\n', '    /**\n', "     * @dev return game's information\n", '     * @return bool, game is active or not\n', '     * @return uint256, bonus assigned to the winner\n', '     * @return uint256, total numbers every round\n', '     * @return uint256, current round ID\n', '     * @return uint256, already drawn round ID\n', '     */\n', '    function gameInfo() public view\n', '        returns(bool, uint256, uint256, uint256, uint256)\n', '    {\n', '        return (\n', '            initialized,\n', '            bonus,\n', '            issued_numbers,\n', '            curRoundID,\n', '            drawnRoundID\n', '        );\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () public payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0), "address invalid");\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant implementationPosition = keccak256("you are the lucky man.proxy");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = implementationPosition;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param newImplementation address representing the new implementation to be set\n', '    */\n', '    function setImplementation(address newImplementation) internal {\n', '        bytes32 position = implementationPosition;\n', '        assembly {\n', '            sstore(position, newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != newImplementation, "new address is the same");\n', '        setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant proxyOwnerPosition = keccak256("you are the lucky man.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor() public {\n', '        setUpgradeabilityOwner(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner(), "owner only");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = proxyOwnerPosition;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the owner\n', '    */\n', '    function setUpgradeabilityOwner(address newProxyOwner) internal {\n', '        bytes32 position = proxyOwnerPosition;\n', '        assembly {\n', '            sstore(position, newProxyOwner)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n', '        require(newOwner != address(0), "address is invalid");\n', '        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n', '        setUpgradeabilityOwner(newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address implementation) public onlyProxyOwner {\n', '        _upgradeTo(implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\n', '    * to initialize whatever is needed through a low level call.\n', '    * @param implementation representing the address of the new implementation to be set.\n', '    * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\n', '    * signature of the implementation to be called with the needed payload\n', '    */\n', '    function upgradeToAndCall(address implementation, bytes data) public payable onlyProxyOwner {\n', '        upgradeTo(implementation);\n', '        require(address(this).call.value(msg.value)(data), "data is invalid");\n', '    }\n', '}']