['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' @title Token77G\n', '\n', '*/\n', '\n', 'contract Token77G is Claimable, StandardToken {\n', '\n', '    string constant public name = "GraphenTech";\n', '    string constant public symbol = "77G";\n', '    uint8 constant public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\n', '\n', '    uint256 public graphenRestrictedDate;\n', '    //Contains restricted tokens that cannot be sold before graphenDeadLine\n', '    mapping (address => uint256) private restrictedTokens;\n', '    // This array contains the list of address to be used by DAO contract\n', '    address[] private addList;\n', '    address private icoadd;\n', '\n', '    /**\n', '     @dev this event generates a public event on the blockchain that will notify clients\n', '    **/\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     @dev this event notifies clients about the amount burnt\n', '    **/\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '     /**\n', '     @dev Constructor function\n', '          Initializes contract with initial supply tokens to the creator of the contract and\n', '          allocates restriceted amount of tokens to some addresses\n', '    */\n', '    function Token77G(\n', '    address _team,\n', '    address _reserve,\n', '    address _advisors,\n', '    uint _deadLine\n', '    )\n', '    public\n', '    {\n', '\n', '        icoadd = msg.sender;\n', '        totalSupply_ = (19000000000) * 10 ** uint256(decimals);\n', '\n', '        balances[_reserve] = balances[_reserve].add((1890500000) * 10 ** uint256(decimals));\n', '        addAddress(_reserve);\n', '        emit Transfer(icoadd, _reserve, (1890500000) * 10 ** uint256(decimals));\n', '\n', '        allocateTokens(_team, (1330000000) * 10 ** uint256(decimals));\n', '        emit Transfer(icoadd, _team, (1330000000) * 10 ** uint256(decimals));\n', '\n', '        balances[_advisors] = balances[_advisors].add((950000000) * 10 ** uint256(decimals));\n', '        addAddress(_advisors);\n', '        emit Transfer(icoadd, _advisors, (950000000) * 10 ** uint256(decimals));\n', '\n', '        balances[icoadd] = (14829500000) * 10 **uint256(decimals);\n', '        graphenRestrictedDate = _deadLine;\n', '\n', '    }\n', '\n', '    /**\n', '     @dev Return number of restricted tokens from address\n', '\n', '\n', '      @param _add The address to check restricted tokens\n', '    */\n', '    function restrictedTokensOf(address _add) public view returns(uint restrctedTokens) {\n', '        return restrictedTokens[_add];\n', '    }\n', '\n', '    /**\n', '     @dev Transfer tokens\n', '          Send `_value` tokens to `_to` from your account\n', '\n', '      @param _to The address of the recipient\n', '      @param _value the amount to send\n', '    */\n', '    // solhint-disable-next-line\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        uint256  tmpRestrictedDate;\n', '\n', '        if (restrictedTokens[msg.sender] > 0) {\n', '            require((now < tmpRestrictedDate && _value <= (balances[msg.sender].sub(restrictedTokens[msg.sender])))||now >= tmpRestrictedDate);// solhint-disable-line\n', '        }\n', '        if (balances[_to] == 0) addAddress(_to);\n', '        _transfer(_to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev Transfer tokens from one address to another\n', '        @param _from address The address which you want to send tokens from\n', '        @param _to address The address which you want to transfer to\n', '        @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\n', '        uint256 tmpRestrictedDate;\n', '\n', '        if (restrictedTokens[msg.sender] > 0) {\n', '            require((now < tmpRestrictedDate && _value <= (balances[msg.sender]-restrictedTokens[msg.sender]))||now >= tmpRestrictedDate);// solhint-disable-line\n', '        }\n', '\n', '        if (balances[_to] == 0)addAddress(_to);\n', '        super.transferFrom(_from, _to, _value);\n', '        return true;\n', '\n', '    }\n', '     /**\n', '     @dev Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    // solhint-disable-next-line\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender\n', '        totalSupply_ = totalSupply_.sub(_value);                      // Updates totalSupply_\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, 0x0, _value);\n', '        return true;\n', '    }\n', '\n', '     /**\n', '     @dev Returns address by position\n', '\n', '     @param _index contains the position to find in addList\n', '     */\n', '    function getAddressFromList(uint256 _index)public view  returns (address add) {\n', '        require(_index < addList.length);\n', '        return addList[_index];\n', '    }\n', '\n', '     /**\n', '     @dev Returns length of address list\n', '\n', '     @return uint list size\n', '     */\n', '    function getAddListSize()public view  returns (uint) {\n', '        return addList.length;\n', '    }\n', '\n', '     /**\n', '     @dev This function adds a number of tokes to an address and sets this tokens as restricted.\n', '\n', '      @param _add The address to allocate restricted tokens\n', '      @param _value Number of tokens to be given\n', '    */\n', '    function allocateTokens(address _add, uint256 _value) private {\n', '        balances[_add] = balances[_add].add(_value);\n', '        restrictedTokens[_add] = restrictedTokens[_add].add(_value);\n', '        addAddress(_add);\n', '    }\n', '\n', '     /**\n', '     @dev Internal transfer, only can be called by this contract.\n', '\n', '      @param _to The address of the recipient\n', '      @param _value number of tokens to be transfered.\n', '     */\n', '    function _transfer(address _to, uint256 _value) private {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[msg.sender] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        // Save this for an assertion in the future\n', '        uint256 previousBalances = balances[msg.sender].add(balances[_to]);\n', '        // Subtract from the sender\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);// Con libreria Maths\n', '        // Add the same to the recipient\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[msg.sender] + balances[_to] == previousBalances);\n', '    }\n', '\n', '   /**\n', '     @dev Adcd ..\n', '     cd a new address to list of address\n', '          Include `_add&#180; if doesn&#180;t exist within addList\n', '\n', '     @param _add contains the address to be included in the addList.\n', '     */\n', '    function addAddress(address _add) private {\n', '        addList.push(_add);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' @title ICO_Graphene\n', '*/\n', '\n', 'contract ICO_Graphene is Claimable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Shows  number of tokens available for Private-ICO\n', '    uint256 public availablePrivateICO;\n', '    // Shows  number of tokens available for PRE-ICO\n', '    uint256 public availablePreICO;\n', '    // Shows  number of tokens available for ICO_w1\n', '    uint256 public availableICO_w1;\n', '    // Shows  number of tokens available for ICO_w2\n', '    uint256 public availableICO_w2;\n', '\n', '    // Shows  number of tokens totals available for ICO\n', '    uint256 public availableICO;\n', '\n', '    // Counts ETHs raised in the ICO\n', '    uint256 public amountRaised;\n', '    // Number of tokens sold within Private-ICO, PRE-ICO and ICO_w1 and ICO_w2\n', '    uint256 public tokensSold;\n', '    // Number of token decimals\n', '    uint256 private decimals;\n', '\n', '    // Shows PrivateICO starting timestamp\n', '    uint256 public startPrivateICO = 1528329600; // 1528329600 Thursday, 07-Jun-18 00:00:00 UTC\n', '    // Shows PrivateICO ending timestamp\n', '    uint256 public endPrivateICO = 1532649599; // 1532649599 Thursday, 26-Jul-18 23:59:59 UTC\n', '\n', '    // Shows Pre-ICO starting timestamp\n', '    uint256 public startPreICO = 1532649600; // 1532649600 Friday, 27-Jul-18 00:00:00 UTC\n', '    // Shows Pre-ICO ending timestamp\n', '    uint256 public endPreICO = 1535327999; // 1535327999 Sunday, 26-Aug-18 23:59:59 UTC\n', '\n', '    // Shows ICO starting timestamp\n', '    uint256 public startICO_w1 = 1535328000; // 1535328000 Monday, 27-Aug-18 00:00:00 UTC\n', '    // Shows ICO ending timestamp\n', '    uint256 public endICO_w1 = 1538006399; // 1538006399 Thursday, 26-Sep-18 23:59:59 UTC\n', '\n', '    // Shows ICO starting timestamp\n', '    uint256 public startICO_w2 = 1538006400; // 1538006400 Friday, 27-Sep-18 00:00:00 UTC\n', '    // Shows ICO ending timestamp\n', '    uint256 public endICO_w2 = 1540684799; // 1540684799 Wednesday, 27-Oct-18 23:59:59 UTC\n', '\n', '    // ICO status list\n', '    enum StatusList { NotStarted, Running, Waiting, Closed, Paused}\n', '    // ICO current status\n', '    StatusList public status;\n', '    // ICO stages list\n', '    enum StagesList { N_A, PrivateICO, PreICO, ICO_w1, ICO_w2}\n', '    // ICO current status\n', '    StagesList public stage;\n', '    // Contains token price within each stage\n', '    uint256[5] private tokenPrice;\n', '    // Contains token contract\n', '    Token77G private tokenReward;\n', '\n', '    // Some tokens cannot be sold before this date.\n', '    // 6 moths after finish ico\n', '    uint256 public restrictedTokensDate = 1550447999; // Sunday, 17-Feb-19 23:59:59 UTC\n', '\n', '    // Contains token contract address\n', '    address public tokenAdd;\n', '\n', '    // Shows purchase address and amount\n', '    mapping(address => uint256) public purchaseMap;\n', '    // Contains ETHs that cannot be sent to an address.\n', '    // mapping(address => uint256) public failToTranferList;\n', '\n', '    // List of address\n', '\n', '    // Token&#39;s delivery\n', '    address constant private TOKENSRESERVE = 0xA89779a50b3540677495e12eA09f02B6Bf09803F;\n', '    address constant private TEAM = 0x39E545F03d26334d735815Bb9882423cE46d8326;\n', '    address constant private ADVISORS = 0x96DFaBbD575C48d82e5bCC92f64E0349Da60712a;\n', '\n', '    // Eth&#39;s delivery\n', '    address constant private SALARIES = 0x99330754059f1348296526a52AA4F787a7648B46;\n', '    address constant private MARKETINGandBUSINESS = 0x824663D62c22f2592c5a3DC37638C09907adE7Ec;\n', '    address constant private RESEARCHandDEVELOPMENT = 0x7156023Cd4579Eb6a7A171062A44574809B353C8;\n', '    address constant private RESERVE = 0xAE55c485Fe70Ce6E547A30f5F4b28F32D9c1c093;\n', '    address constant private FACTORIES = 0x30CF1d5F0c561118fA017f15B86f914ef5C078e6;\n', '    address constant private PLANEQUIPMENT = 0xC74c83d8eC7c6233715b0aD8Ba4da8f72301fA24;\n', '    address constant private PRODUCTION = 0xEa0553a23469cb7140190d443762d70664a36343;\n', '\n', '\n', '    /**\n', '     @dev This event notifies a tokens purchase\n', '    **/\n', '    event Purchase(address _from, uint _amount, uint _tokens);\n', '\n', '    /**\n', '     @dev Checks if ICO is active\n', '     @param _status StatusList condition to compare with current status\n', '    **/\n', '    modifier onlyInState (StatusList _status) {\n', '        require(_status == status);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     @dev Checks if ICO status is not PAUSED\n', '    **/\n', '    modifier onlyIfNotPaused() {\n', '        require(status != StatusList.Paused);\n', '        _;\n', '    }\n', '\n', '     /**\n', '     @dev Constructor. Creates ICO_Graphene tokens and define PrivateICO, PreICO, ICO tokens.\n', '          ICO status and stages are set to initial values.\n', '    */\n', '    function ICO_Graphene() public {\n', '\n', '        tokenReward = new Token77G(TEAM, TOKENSRESERVE, ADVISORS, restrictedTokensDate);\n', '\n', '        tokenAdd = tokenReward;\n', '        decimals = tokenReward.decimals();\n', '        status = StatusList.NotStarted;\n', '        stage = StagesList.N_A;\n', '        amountRaised = 0;\n', '        tokensSold = 0;\n', '\n', '        availablePrivateICO = (1729000000) * 10 ** uint256(decimals);\n', '        availablePreICO = (3325000000) * 10 ** uint256(decimals);\n', '        availableICO_w1 = (5120500000) * 10 ** uint256(decimals);\n', '        availableICO_w2 = (4655000000) * 10 ** uint256(decimals);\n', '\n', '        tokenPrice = [0, 13860000000000, 14850000000000, 17820000000000, 19800000000000];\n', '\n', '    }\n', '\n', '     /**\n', '\n', '     @dev The function (Fallback) without name is the default function that is called whenever\n', '          anyone sends funds to a contract, this method starts purchase process.\n', '     */\n', '    function () public payable onlyIfNotPaused {\n', '        updateStatus();\n', '        if (stage == StagesList.PrivateICO) {\n', '            require(msg.value >= 1000000000000000000 wei);\n', '        }\n', '        _transfer();\n', '        updateStatusViaTokens();\n', '    }\n', '\n', '      /**\n', '     @dev Standar function to kill ICO contract and return ETHs to owner.\n', '    */\n', '    function kill()\n', '    external onlyOwner onlyInState(StatusList.Closed) {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     @dev Public function to be call by owner that changes ICO status to Pause.\n', '          No other function will be available if status is Pause but unpause()\n', '     */\n', '    function pause() public onlyOwner {\n', '        updateStatus();\n', '        require(status != StatusList.Closed);\n', '        status = StatusList.Paused;\n', '    }\n', '\n', '    /**\n', '     @dev Public function to be call by owner when ICO status is Paused, it changes ICO status to the right status\n', '          based on ICO dates.\n', '     */\n', '    function unpause() public onlyOwner onlyInState(StatusList.Paused) {\n', '        updateStatus();\n', '        updateStatusViaTokens();\n', '    }\n', '\n', '    /**\n', '     @dev PRE-ICO and ICO times can be changed with this function by the owner if ICO has not started.\n', '    *     This function changes startTimestamp time with _startingTime given.\n', '     @param     _startPrivateICO contains new starting date for PRE-ICO\n', '     @param     _endPrivateICO contains new ending date for PRE-ICO\n', '     @param     _startPreICO contains new starting date for ICO\n', '     @param     _endPreICO contains new ending date for ICO\n', '     @param     _startICO_w1 contains new starting date for PRE-ICO\n', '     @param     _endICO_w1 contains new ending date for PRE-ICO\n', '     @param     _startICO_w2 contains new starting date for ICO\n', '     @param     _endICO_w2 contains new ending date for ICO\n', '    */\n', '    function setNewICOTime(\n', '    uint _startPrivateICO,\n', '    uint _endPrivateICO,\n', '    uint _startPreICO,\n', '    uint _endPreICO,\n', '    uint _startICO_w1,\n', '    uint _endICO_w1,\n', '    uint _startICO_w2,\n', '    uint _endICO_w2\n', '    )\n', '    public\n', '    onlyOwner onlyInState(StatusList.NotStarted) {\n', '        require(now < startPrivateICO && startPrivateICO < endPrivateICO && startPreICO < endPreICO && startICO_w1 < endICO_w1 && startICO_w2 < endICO_w2); // solhint-disable-line\n', '        startPrivateICO = _startPrivateICO;\n', '        endPrivateICO = _endPrivateICO;\n', '        startPreICO = _startPreICO;\n', '        endPreICO = _endPreICO;\n', '        startICO_w1 = _startICO_w1;\n', '        endICO_w1 = _endICO_w1;\n', '        startICO_w2 = _startICO_w2;\n', '        endICO_w2 = _endICO_w2;\n', '    }\n', '\n', '    /**\n', '     @dev This function can be call by owner to close the ICO if status is closed .\n', '    *     Transfer the excess tokens to RESERVE if there are available tokens\n', '    */\n', '     function closeICO() public onlyOwner {\n', '        updateStatus();\n', '        require(status == StatusList.Closed);\n', '        transferExcessTokensToReserve();\n', '    }\n', '\n', '    function transferExcessTokensToReserve() internal {\n', '      availableICO = tokenReward.balanceOf(this);\n', '      if (availableICO > 0) {\n', '        tokenReward.transfer(TOKENSRESERVE, availableICO);\n', '      }\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO status, as described in the withepaper\n', '          ICO is available for purchases if date & time is within the PRE-ICO or ICO dates.\n', '     */\n', '    function updateStatus() internal {\n', '        if (now >= endICO_w2) {// solhint-disable-line\n', '            status = StatusList.Closed;\n', '        } else {\n', '            // solhint-disable-next-line\n', '            if ((now > endPrivateICO && now < startPreICO) || (now > endPreICO && now < startICO_w1)) {\n', '                status = StatusList.Waiting;\n', '            } else {\n', '                if (now < startPrivateICO) {// solhint-disable-line\n', '                    status = StatusList.NotStarted;\n', '                } else {\n', '                    status = StatusList.Running;\n', '                    updateStages();\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO status when tokens are sold out.\n', '          ICO has a number of limmited tokens to be sold within PrivateICO, PRE-ICO and ICO stages,\n', '          this method changes status to WaitingICO if PRE-ICO tokens are sold out or\n', '          Closed when ICO tokens are sold out.\n', '     */\n', '    function updateStatusViaTokens() internal {\n', '        availableICO = tokenReward.balanceOf(this);\n', '        if (availablePrivateICO == 0 && stage == StagesList.PrivateICO) status = StatusList.Waiting;\n', '        if (availablePreICO == 0 && stage == StagesList.PreICO) status = StatusList.Waiting;\n', '        if (availableICO_w1 == 0 && stage == StagesList.ICO_w1) status = StatusList.Waiting;\n', '        if (availableICO_w2 == 0 && stage == StagesList.ICO_w2) status = StatusList.Waiting;\n', '        if (availableICO == 0) status = StatusList.Closed;\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO stages.\n', '          Stage is used in order to calculate the proper token price.\n', '     */\n', '    function updateStages() internal onlyInState(StatusList.Running) {\n', '        if (now <= endPrivateICO && now > startPrivateICO) { stage = StagesList.PrivateICO; return;}// solhint-disable-line\n', '        if (now <= endPreICO && now > startPreICO) { stage = StagesList.PreICO; return;}// solhint-disable-line\n', '        if (now <= endICO_w1 && now > startICO_w1) { stage = StagesList.ICO_w1; return;}// solhint-disable-line\n', '        if (now <= endICO_w2 && now > startICO_w2) { stage = StagesList.ICO_w2; return;}// solhint-disable-lin\n', '        stage = StagesList.N_A;\n', '    }\n', '\n', '     /**\n', '      @dev Private function to manage GrapheneTech purchases by calculating the right number\n', '           of tokens based on the value sent.\n', '           Includes any purchase within a mapping to track address and amount spent.\n', '           Tracks the number of tokens sold. and ICO amount raised\n', '           Transfer tokens to the buyer address.\n', '           Calculates refound value if applais.\n', '     */\n', '    function _transfer() private onlyInState(StatusList.Running) {\n', '        uint amount = msg.value;\n', '        uint amountToReturn = 0;\n', '        uint tokens = 0;\n', '        (tokens, amountToReturn) = getTokens(amount);\n', '        purchaseMap[msg.sender] = purchaseMap[msg.sender].add(amount);\n', '        tokensSold = tokensSold.add(tokens);\n', '        amount = amount.sub(amountToReturn);\n', '        amountRaised = amountRaised.add(amount);\n', '        if (stage == StagesList.PrivateICO) availablePrivateICO = availablePrivateICO.sub(tokens);\n', '        if (stage == StagesList.PreICO) availablePreICO = availablePreICO.sub(tokens);\n', '        if (stage == StagesList.ICO_w1) availableICO_w1 = availableICO_w1.sub(tokens);\n', '        if (stage == StagesList.ICO_w2) availableICO_w2 = availableICO_w2.sub(tokens);\n', '        tokenReward.transfer(msg.sender, tokens);\n', '        sendETH(amount);\n', '\n', '        if (amountToReturn > 0) {\n', '            bool refound = msg.sender.send(amountToReturn);\n', '            require(refound);\n', '        }\n', '\n', '        emit Purchase(msg.sender, amount, tokens);\n', '    }\n', '\n', '     /**\n', '      @dev Returns the number of tokens based on the ETH sent and token price.\n', '\n', '      @param _value this contais the ETHs sent and it is used to calculate the right number of tokens to be transfered.\n', '      @return number of tokens based on the ETH sent and token price.\n', '     */\n', '    function getTokens(uint256 _value)\n', '    private view\n', '    onlyInState(StatusList.Running)\n', '    returns(uint256 numTokens, uint256 amountToReturn) {\n', '\n', '        uint256 eths = _value.mul(10**decimals);//Adding decimals to get an acurate number of tokens\n', '        numTokens = 0;\n', '        uint256 tokensAvailable = 0;\n', '        numTokens = eths.div(tokenPrice[uint256(stage)]);\n', '\n', '        if (stage == StagesList.PrivateICO) {\n', '            tokensAvailable = availablePrivateICO;\n', '        } else if (stage == StagesList.PreICO) {\n', '            tokensAvailable = availablePreICO;\n', '        } else if (stage == StagesList.ICO_w1) {\n', '            tokensAvailable = availableICO_w1;\n', '        } else if (stage == StagesList.ICO_w2) {\n', '            tokensAvailable = availableICO_w2;\n', '        }\n', '\n', '        if (tokensAvailable >= numTokens) {\n', '            amountToReturn = 0;\n', '        } else {\n', '            numTokens = tokensAvailable;\n', '            amountToReturn = _value.sub(numTokens.div(10**decimals).mul(tokenPrice[uint256(stage)]));\n', '        }\n', '\n', '        return (numTokens, amountToReturn);\n', '    }\n', '\n', '    /**\n', '     @dev This function sends ETHs to the list of address SALARIES, MARKETINGandBUSINESS, RESEARCHandDEVELOPMENT, RESERVE, FACTORIES, PLANEQUIPMENT, PRODUCTION\n', '     @param _amount this are the ETHs that have to be send between different address.\n', '\n', '    */\n', '    function sendETH(uint _amount)  private {\n', '\n', '        uint paymentSALARIES = _amount.mul(3).div(100);\n', '        uint paymentMARKETINGandBUSINESS = _amount.mul(4).div(100);\n', '        uint paymentRESEARCHandDEVELOPMENT = _amount.mul(14).div(100);\n', '        uint paymentRESERVE = _amount.mul(18).div(100);\n', '        uint paymentFACTORIES = _amount.mul(24).div(100);\n', '        uint paymentPLANEQUIPMENT = _amount.mul(19).div(100);\n', '        uint paymentPRODUCTION = _amount.mul(18).div(100);\n', '\n', '        SALARIES.transfer(paymentSALARIES);\n', '        MARKETINGandBUSINESS.transfer(paymentMARKETINGandBUSINESS);\n', '        RESEARCHandDEVELOPMENT.transfer(paymentRESEARCHandDEVELOPMENT);\n', '        RESERVE.transfer(paymentRESERVE);\n', '        FACTORIES.transfer(paymentFACTORIES);\n', '        PLANEQUIPMENT.transfer(paymentPLANEQUIPMENT);\n', '        PRODUCTION.transfer(paymentPRODUCTION);\n', '\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' @title Token77G\n', '\n', '*/\n', '\n', 'contract Token77G is Claimable, StandardToken {\n', '\n', '    string constant public name = "GraphenTech";\n', '    string constant public symbol = "77G";\n', '    uint8 constant public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it\n', '\n', '    uint256 public graphenRestrictedDate;\n', '    //Contains restricted tokens that cannot be sold before graphenDeadLine\n', '    mapping (address => uint256) private restrictedTokens;\n', '    // This array contains the list of address to be used by DAO contract\n', '    address[] private addList;\n', '    address private icoadd;\n', '\n', '    /**\n', '     @dev this event generates a public event on the blockchain that will notify clients\n', '    **/\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     @dev this event notifies clients about the amount burnt\n', '    **/\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '     /**\n', '     @dev Constructor function\n', '          Initializes contract with initial supply tokens to the creator of the contract and\n', '          allocates restriceted amount of tokens to some addresses\n', '    */\n', '    function Token77G(\n', '    address _team,\n', '    address _reserve,\n', '    address _advisors,\n', '    uint _deadLine\n', '    )\n', '    public\n', '    {\n', '\n', '        icoadd = msg.sender;\n', '        totalSupply_ = (19000000000) * 10 ** uint256(decimals);\n', '\n', '        balances[_reserve] = balances[_reserve].add((1890500000) * 10 ** uint256(decimals));\n', '        addAddress(_reserve);\n', '        emit Transfer(icoadd, _reserve, (1890500000) * 10 ** uint256(decimals));\n', '\n', '        allocateTokens(_team, (1330000000) * 10 ** uint256(decimals));\n', '        emit Transfer(icoadd, _team, (1330000000) * 10 ** uint256(decimals));\n', '\n', '        balances[_advisors] = balances[_advisors].add((950000000) * 10 ** uint256(decimals));\n', '        addAddress(_advisors);\n', '        emit Transfer(icoadd, _advisors, (950000000) * 10 ** uint256(decimals));\n', '\n', '        balances[icoadd] = (14829500000) * 10 **uint256(decimals);\n', '        graphenRestrictedDate = _deadLine;\n', '\n', '    }\n', '\n', '    /**\n', '     @dev Return number of restricted tokens from address\n', '\n', '\n', '      @param _add The address to check restricted tokens\n', '    */\n', '    function restrictedTokensOf(address _add) public view returns(uint restrctedTokens) {\n', '        return restrictedTokens[_add];\n', '    }\n', '\n', '    /**\n', '     @dev Transfer tokens\n', '          Send `_value` tokens to `_to` from your account\n', '\n', '      @param _to The address of the recipient\n', '      @param _value the amount to send\n', '    */\n', '    // solhint-disable-next-line\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        uint256  tmpRestrictedDate;\n', '\n', '        if (restrictedTokens[msg.sender] > 0) {\n', '            require((now < tmpRestrictedDate && _value <= (balances[msg.sender].sub(restrictedTokens[msg.sender])))||now >= tmpRestrictedDate);// solhint-disable-line\n', '        }\n', '        if (balances[_to] == 0) addAddress(_to);\n', '        _transfer(_to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev Transfer tokens from one address to another\n', '        @param _from address The address which you want to send tokens from\n', '        @param _to address The address which you want to transfer to\n', '        @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '\n', '        uint256 tmpRestrictedDate;\n', '\n', '        if (restrictedTokens[msg.sender] > 0) {\n', '            require((now < tmpRestrictedDate && _value <= (balances[msg.sender]-restrictedTokens[msg.sender]))||now >= tmpRestrictedDate);// solhint-disable-line\n', '        }\n', '\n', '        if (balances[_to] == 0)addAddress(_to);\n', '        super.transferFrom(_from, _to, _value);\n', '        return true;\n', '\n', '    }\n', '     /**\n', '     @dev Destroy tokens\n', '     *\n', '     * Remove `_value` tokens from the system irreversibly\n', '     *\n', '     * @param _value the amount of money to burn\n', '     */\n', '    // solhint-disable-next-line\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender\n', '        totalSupply_ = totalSupply_.sub(_value);                      // Updates totalSupply_\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, 0x0, _value);\n', '        return true;\n', '    }\n', '\n', '     /**\n', '     @dev Returns address by position\n', '\n', '     @param _index contains the position to find in addList\n', '     */\n', '    function getAddressFromList(uint256 _index)public view  returns (address add) {\n', '        require(_index < addList.length);\n', '        return addList[_index];\n', '    }\n', '\n', '     /**\n', '     @dev Returns length of address list\n', '\n', '     @return uint list size\n', '     */\n', '    function getAddListSize()public view  returns (uint) {\n', '        return addList.length;\n', '    }\n', '\n', '     /**\n', '     @dev This function adds a number of tokes to an address and sets this tokens as restricted.\n', '\n', '      @param _add The address to allocate restricted tokens\n', '      @param _value Number of tokens to be given\n', '    */\n', '    function allocateTokens(address _add, uint256 _value) private {\n', '        balances[_add] = balances[_add].add(_value);\n', '        restrictedTokens[_add] = restrictedTokens[_add].add(_value);\n', '        addAddress(_add);\n', '    }\n', '\n', '     /**\n', '     @dev Internal transfer, only can be called by this contract.\n', '\n', '      @param _to The address of the recipient\n', '      @param _value number of tokens to be transfered.\n', '     */\n', '    function _transfer(address _to, uint256 _value) private {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balances[msg.sender] >= _value);\n', '        // Check for overflows\n', '        require(balances[_to] + _value > balances[_to]);\n', '        // Save this for an assertion in the future\n', '        uint256 previousBalances = balances[msg.sender].add(balances[_to]);\n', '        // Subtract from the sender\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);// Con libreria Maths\n', '        // Add the same to the recipient\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balances[msg.sender] + balances[_to] == previousBalances);\n', '    }\n', '\n', '   /**\n', '     @dev Adcd ..\n', '     cd a new address to list of address\n', '          Include `_add´ if doesn´t exist within addList\n', '\n', '     @param _add contains the address to be included in the addList.\n', '     */\n', '    function addAddress(address _add) private {\n', '        addList.push(_add);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' @title ICO_Graphene\n', '*/\n', '\n', 'contract ICO_Graphene is Claimable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Shows  number of tokens available for Private-ICO\n', '    uint256 public availablePrivateICO;\n', '    // Shows  number of tokens available for PRE-ICO\n', '    uint256 public availablePreICO;\n', '    // Shows  number of tokens available for ICO_w1\n', '    uint256 public availableICO_w1;\n', '    // Shows  number of tokens available for ICO_w2\n', '    uint256 public availableICO_w2;\n', '\n', '    // Shows  number of tokens totals available for ICO\n', '    uint256 public availableICO;\n', '\n', '    // Counts ETHs raised in the ICO\n', '    uint256 public amountRaised;\n', '    // Number of tokens sold within Private-ICO, PRE-ICO and ICO_w1 and ICO_w2\n', '    uint256 public tokensSold;\n', '    // Number of token decimals\n', '    uint256 private decimals;\n', '\n', '    // Shows PrivateICO starting timestamp\n', '    uint256 public startPrivateICO = 1528329600; // 1528329600 Thursday, 07-Jun-18 00:00:00 UTC\n', '    // Shows PrivateICO ending timestamp\n', '    uint256 public endPrivateICO = 1532649599; // 1532649599 Thursday, 26-Jul-18 23:59:59 UTC\n', '\n', '    // Shows Pre-ICO starting timestamp\n', '    uint256 public startPreICO = 1532649600; // 1532649600 Friday, 27-Jul-18 00:00:00 UTC\n', '    // Shows Pre-ICO ending timestamp\n', '    uint256 public endPreICO = 1535327999; // 1535327999 Sunday, 26-Aug-18 23:59:59 UTC\n', '\n', '    // Shows ICO starting timestamp\n', '    uint256 public startICO_w1 = 1535328000; // 1535328000 Monday, 27-Aug-18 00:00:00 UTC\n', '    // Shows ICO ending timestamp\n', '    uint256 public endICO_w1 = 1538006399; // 1538006399 Thursday, 26-Sep-18 23:59:59 UTC\n', '\n', '    // Shows ICO starting timestamp\n', '    uint256 public startICO_w2 = 1538006400; // 1538006400 Friday, 27-Sep-18 00:00:00 UTC\n', '    // Shows ICO ending timestamp\n', '    uint256 public endICO_w2 = 1540684799; // 1540684799 Wednesday, 27-Oct-18 23:59:59 UTC\n', '\n', '    // ICO status list\n', '    enum StatusList { NotStarted, Running, Waiting, Closed, Paused}\n', '    // ICO current status\n', '    StatusList public status;\n', '    // ICO stages list\n', '    enum StagesList { N_A, PrivateICO, PreICO, ICO_w1, ICO_w2}\n', '    // ICO current status\n', '    StagesList public stage;\n', '    // Contains token price within each stage\n', '    uint256[5] private tokenPrice;\n', '    // Contains token contract\n', '    Token77G private tokenReward;\n', '\n', '    // Some tokens cannot be sold before this date.\n', '    // 6 moths after finish ico\n', '    uint256 public restrictedTokensDate = 1550447999; // Sunday, 17-Feb-19 23:59:59 UTC\n', '\n', '    // Contains token contract address\n', '    address public tokenAdd;\n', '\n', '    // Shows purchase address and amount\n', '    mapping(address => uint256) public purchaseMap;\n', '    // Contains ETHs that cannot be sent to an address.\n', '    // mapping(address => uint256) public failToTranferList;\n', '\n', '    // List of address\n', '\n', "    // Token's delivery\n", '    address constant private TOKENSRESERVE = 0xA89779a50b3540677495e12eA09f02B6Bf09803F;\n', '    address constant private TEAM = 0x39E545F03d26334d735815Bb9882423cE46d8326;\n', '    address constant private ADVISORS = 0x96DFaBbD575C48d82e5bCC92f64E0349Da60712a;\n', '\n', "    // Eth's delivery\n", '    address constant private SALARIES = 0x99330754059f1348296526a52AA4F787a7648B46;\n', '    address constant private MARKETINGandBUSINESS = 0x824663D62c22f2592c5a3DC37638C09907adE7Ec;\n', '    address constant private RESEARCHandDEVELOPMENT = 0x7156023Cd4579Eb6a7A171062A44574809B353C8;\n', '    address constant private RESERVE = 0xAE55c485Fe70Ce6E547A30f5F4b28F32D9c1c093;\n', '    address constant private FACTORIES = 0x30CF1d5F0c561118fA017f15B86f914ef5C078e6;\n', '    address constant private PLANEQUIPMENT = 0xC74c83d8eC7c6233715b0aD8Ba4da8f72301fA24;\n', '    address constant private PRODUCTION = 0xEa0553a23469cb7140190d443762d70664a36343;\n', '\n', '\n', '    /**\n', '     @dev This event notifies a tokens purchase\n', '    **/\n', '    event Purchase(address _from, uint _amount, uint _tokens);\n', '\n', '    /**\n', '     @dev Checks if ICO is active\n', '     @param _status StatusList condition to compare with current status\n', '    **/\n', '    modifier onlyInState (StatusList _status) {\n', '        require(_status == status);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     @dev Checks if ICO status is not PAUSED\n', '    **/\n', '    modifier onlyIfNotPaused() {\n', '        require(status != StatusList.Paused);\n', '        _;\n', '    }\n', '\n', '     /**\n', '     @dev Constructor. Creates ICO_Graphene tokens and define PrivateICO, PreICO, ICO tokens.\n', '          ICO status and stages are set to initial values.\n', '    */\n', '    function ICO_Graphene() public {\n', '\n', '        tokenReward = new Token77G(TEAM, TOKENSRESERVE, ADVISORS, restrictedTokensDate);\n', '\n', '        tokenAdd = tokenReward;\n', '        decimals = tokenReward.decimals();\n', '        status = StatusList.NotStarted;\n', '        stage = StagesList.N_A;\n', '        amountRaised = 0;\n', '        tokensSold = 0;\n', '\n', '        availablePrivateICO = (1729000000) * 10 ** uint256(decimals);\n', '        availablePreICO = (3325000000) * 10 ** uint256(decimals);\n', '        availableICO_w1 = (5120500000) * 10 ** uint256(decimals);\n', '        availableICO_w2 = (4655000000) * 10 ** uint256(decimals);\n', '\n', '        tokenPrice = [0, 13860000000000, 14850000000000, 17820000000000, 19800000000000];\n', '\n', '    }\n', '\n', '     /**\n', '\n', '     @dev The function (Fallback) without name is the default function that is called whenever\n', '          anyone sends funds to a contract, this method starts purchase process.\n', '     */\n', '    function () public payable onlyIfNotPaused {\n', '        updateStatus();\n', '        if (stage == StagesList.PrivateICO) {\n', '            require(msg.value >= 1000000000000000000 wei);\n', '        }\n', '        _transfer();\n', '        updateStatusViaTokens();\n', '    }\n', '\n', '      /**\n', '     @dev Standar function to kill ICO contract and return ETHs to owner.\n', '    */\n', '    function kill()\n', '    external onlyOwner onlyInState(StatusList.Closed) {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     @dev Public function to be call by owner that changes ICO status to Pause.\n', '          No other function will be available if status is Pause but unpause()\n', '     */\n', '    function pause() public onlyOwner {\n', '        updateStatus();\n', '        require(status != StatusList.Closed);\n', '        status = StatusList.Paused;\n', '    }\n', '\n', '    /**\n', '     @dev Public function to be call by owner when ICO status is Paused, it changes ICO status to the right status\n', '          based on ICO dates.\n', '     */\n', '    function unpause() public onlyOwner onlyInState(StatusList.Paused) {\n', '        updateStatus();\n', '        updateStatusViaTokens();\n', '    }\n', '\n', '    /**\n', '     @dev PRE-ICO and ICO times can be changed with this function by the owner if ICO has not started.\n', '    *     This function changes startTimestamp time with _startingTime given.\n', '     @param     _startPrivateICO contains new starting date for PRE-ICO\n', '     @param     _endPrivateICO contains new ending date for PRE-ICO\n', '     @param     _startPreICO contains new starting date for ICO\n', '     @param     _endPreICO contains new ending date for ICO\n', '     @param     _startICO_w1 contains new starting date for PRE-ICO\n', '     @param     _endICO_w1 contains new ending date for PRE-ICO\n', '     @param     _startICO_w2 contains new starting date for ICO\n', '     @param     _endICO_w2 contains new ending date for ICO\n', '    */\n', '    function setNewICOTime(\n', '    uint _startPrivateICO,\n', '    uint _endPrivateICO,\n', '    uint _startPreICO,\n', '    uint _endPreICO,\n', '    uint _startICO_w1,\n', '    uint _endICO_w1,\n', '    uint _startICO_w2,\n', '    uint _endICO_w2\n', '    )\n', '    public\n', '    onlyOwner onlyInState(StatusList.NotStarted) {\n', '        require(now < startPrivateICO && startPrivateICO < endPrivateICO && startPreICO < endPreICO && startICO_w1 < endICO_w1 && startICO_w2 < endICO_w2); // solhint-disable-line\n', '        startPrivateICO = _startPrivateICO;\n', '        endPrivateICO = _endPrivateICO;\n', '        startPreICO = _startPreICO;\n', '        endPreICO = _endPreICO;\n', '        startICO_w1 = _startICO_w1;\n', '        endICO_w1 = _endICO_w1;\n', '        startICO_w2 = _startICO_w2;\n', '        endICO_w2 = _endICO_w2;\n', '    }\n', '\n', '    /**\n', '     @dev This function can be call by owner to close the ICO if status is closed .\n', '    *     Transfer the excess tokens to RESERVE if there are available tokens\n', '    */\n', '     function closeICO() public onlyOwner {\n', '        updateStatus();\n', '        require(status == StatusList.Closed);\n', '        transferExcessTokensToReserve();\n', '    }\n', '\n', '    function transferExcessTokensToReserve() internal {\n', '      availableICO = tokenReward.balanceOf(this);\n', '      if (availableICO > 0) {\n', '        tokenReward.transfer(TOKENSRESERVE, availableICO);\n', '      }\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO status, as described in the withepaper\n', '          ICO is available for purchases if date & time is within the PRE-ICO or ICO dates.\n', '     */\n', '    function updateStatus() internal {\n', '        if (now >= endICO_w2) {// solhint-disable-line\n', '            status = StatusList.Closed;\n', '        } else {\n', '            // solhint-disable-next-line\n', '            if ((now > endPrivateICO && now < startPreICO) || (now > endPreICO && now < startICO_w1)) {\n', '                status = StatusList.Waiting;\n', '            } else {\n', '                if (now < startPrivateICO) {// solhint-disable-line\n', '                    status = StatusList.NotStarted;\n', '                } else {\n', '                    status = StatusList.Running;\n', '                    updateStages();\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO status when tokens are sold out.\n', '          ICO has a number of limmited tokens to be sold within PrivateICO, PRE-ICO and ICO stages,\n', '          this method changes status to WaitingICO if PRE-ICO tokens are sold out or\n', '          Closed when ICO tokens are sold out.\n', '     */\n', '    function updateStatusViaTokens() internal {\n', '        availableICO = tokenReward.balanceOf(this);\n', '        if (availablePrivateICO == 0 && stage == StagesList.PrivateICO) status = StatusList.Waiting;\n', '        if (availablePreICO == 0 && stage == StagesList.PreICO) status = StatusList.Waiting;\n', '        if (availableICO_w1 == 0 && stage == StagesList.ICO_w1) status = StatusList.Waiting;\n', '        if (availableICO_w2 == 0 && stage == StagesList.ICO_w2) status = StatusList.Waiting;\n', '        if (availableICO == 0) status = StatusList.Closed;\n', '    }\n', '\n', '    /**\n', '     @dev Internal function to manage ICO stages.\n', '          Stage is used in order to calculate the proper token price.\n', '     */\n', '    function updateStages() internal onlyInState(StatusList.Running) {\n', '        if (now <= endPrivateICO && now > startPrivateICO) { stage = StagesList.PrivateICO; return;}// solhint-disable-line\n', '        if (now <= endPreICO && now > startPreICO) { stage = StagesList.PreICO; return;}// solhint-disable-line\n', '        if (now <= endICO_w1 && now > startICO_w1) { stage = StagesList.ICO_w1; return;}// solhint-disable-line\n', '        if (now <= endICO_w2 && now > startICO_w2) { stage = StagesList.ICO_w2; return;}// solhint-disable-lin\n', '        stage = StagesList.N_A;\n', '    }\n', '\n', '     /**\n', '      @dev Private function to manage GrapheneTech purchases by calculating the right number\n', '           of tokens based on the value sent.\n', '           Includes any purchase within a mapping to track address and amount spent.\n', '           Tracks the number of tokens sold. and ICO amount raised\n', '           Transfer tokens to the buyer address.\n', '           Calculates refound value if applais.\n', '     */\n', '    function _transfer() private onlyInState(StatusList.Running) {\n', '        uint amount = msg.value;\n', '        uint amountToReturn = 0;\n', '        uint tokens = 0;\n', '        (tokens, amountToReturn) = getTokens(amount);\n', '        purchaseMap[msg.sender] = purchaseMap[msg.sender].add(amount);\n', '        tokensSold = tokensSold.add(tokens);\n', '        amount = amount.sub(amountToReturn);\n', '        amountRaised = amountRaised.add(amount);\n', '        if (stage == StagesList.PrivateICO) availablePrivateICO = availablePrivateICO.sub(tokens);\n', '        if (stage == StagesList.PreICO) availablePreICO = availablePreICO.sub(tokens);\n', '        if (stage == StagesList.ICO_w1) availableICO_w1 = availableICO_w1.sub(tokens);\n', '        if (stage == StagesList.ICO_w2) availableICO_w2 = availableICO_w2.sub(tokens);\n', '        tokenReward.transfer(msg.sender, tokens);\n', '        sendETH(amount);\n', '\n', '        if (amountToReturn > 0) {\n', '            bool refound = msg.sender.send(amountToReturn);\n', '            require(refound);\n', '        }\n', '\n', '        emit Purchase(msg.sender, amount, tokens);\n', '    }\n', '\n', '     /**\n', '      @dev Returns the number of tokens based on the ETH sent and token price.\n', '\n', '      @param _value this contais the ETHs sent and it is used to calculate the right number of tokens to be transfered.\n', '      @return number of tokens based on the ETH sent and token price.\n', '     */\n', '    function getTokens(uint256 _value)\n', '    private view\n', '    onlyInState(StatusList.Running)\n', '    returns(uint256 numTokens, uint256 amountToReturn) {\n', '\n', '        uint256 eths = _value.mul(10**decimals);//Adding decimals to get an acurate number of tokens\n', '        numTokens = 0;\n', '        uint256 tokensAvailable = 0;\n', '        numTokens = eths.div(tokenPrice[uint256(stage)]);\n', '\n', '        if (stage == StagesList.PrivateICO) {\n', '            tokensAvailable = availablePrivateICO;\n', '        } else if (stage == StagesList.PreICO) {\n', '            tokensAvailable = availablePreICO;\n', '        } else if (stage == StagesList.ICO_w1) {\n', '            tokensAvailable = availableICO_w1;\n', '        } else if (stage == StagesList.ICO_w2) {\n', '            tokensAvailable = availableICO_w2;\n', '        }\n', '\n', '        if (tokensAvailable >= numTokens) {\n', '            amountToReturn = 0;\n', '        } else {\n', '            numTokens = tokensAvailable;\n', '            amountToReturn = _value.sub(numTokens.div(10**decimals).mul(tokenPrice[uint256(stage)]));\n', '        }\n', '\n', '        return (numTokens, amountToReturn);\n', '    }\n', '\n', '    /**\n', '     @dev This function sends ETHs to the list of address SALARIES, MARKETINGandBUSINESS, RESEARCHandDEVELOPMENT, RESERVE, FACTORIES, PLANEQUIPMENT, PRODUCTION\n', '     @param _amount this are the ETHs that have to be send between different address.\n', '\n', '    */\n', '    function sendETH(uint _amount)  private {\n', '\n', '        uint paymentSALARIES = _amount.mul(3).div(100);\n', '        uint paymentMARKETINGandBUSINESS = _amount.mul(4).div(100);\n', '        uint paymentRESEARCHandDEVELOPMENT = _amount.mul(14).div(100);\n', '        uint paymentRESERVE = _amount.mul(18).div(100);\n', '        uint paymentFACTORIES = _amount.mul(24).div(100);\n', '        uint paymentPLANEQUIPMENT = _amount.mul(19).div(100);\n', '        uint paymentPRODUCTION = _amount.mul(18).div(100);\n', '\n', '        SALARIES.transfer(paymentSALARIES);\n', '        MARKETINGandBUSINESS.transfer(paymentMARKETINGandBUSINESS);\n', '        RESEARCHandDEVELOPMENT.transfer(paymentRESEARCHandDEVELOPMENT);\n', '        RESERVE.transfer(paymentRESERVE);\n', '        FACTORIES.transfer(paymentFACTORIES);\n', '        PLANEQUIPMENT.transfer(paymentPLANEQUIPMENT);\n', '        PRODUCTION.transfer(paymentPRODUCTION);\n', '\n', '    }\n', '\n', '}']
