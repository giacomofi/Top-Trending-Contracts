['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply () view public returns (uint256 supply);\n', '    function balanceOf (address _owner) view public returns (uint256 balance);\n', '    function transfer (address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve (address _spender, uint256 _value) public returns (bool success);\n', '    function allowance (address _owner, address _spender) view public returns (uint256 remaining);\n', '\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval (address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract AbstractToken is Token {\n', '    using SafeMath for uint;\n', '\n', '    function AbstractToken () public payable{\n', '        \n', '    }\n', '\n', '    function balanceOf (address _owner) view public returns (uint256 balance) {\n', '        return accounts[_owner];\n', '    }\n', '\n', '    function transfer (address _to, uint256 _value) public returns (bool success) {\n', '        uint256 fromBalance = accounts[msg.sender];\n', '        if (fromBalance < _value) return false;\n', '        if (_value > 0 && msg.sender != _to) {\n', '            accounts[msg.sender] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 spenderAllowance = allowances[_from][msg.sender];\n', '        if (spenderAllowance < _value) return false;\n', '        uint256 fromBalance = accounts[_from];\n', '        if (fromBalance < _value) return false;\n', '\n', '        allowances[_from][msg.sender] = spenderAllowance.sub(_value);\n', '\n', '        if (_value > 0 && _from != _to) {\n', '            accounts[_from] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(_from, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function approve (address _spender, uint256 _value) public returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance (address _owner, address _spender) view public returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) accounts;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowances;\n', '}\n', '\n', 'contract AbstractVirtualToken is AbstractToken {\n', '    using SafeMath for uint;\n', '\n', '    uint256 constant MAXIMUM_TOKENS_COUNT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    uint256 constant BALANCE_MASK = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    uint256 constant MATERIALIZED_FLAG_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    function AbstractVirtualToken () public{\n', '        \n', '    }\n', '\n', '    function totalSupply () view public returns (uint256 supply) {\n', '        return tokensCount;\n', '    }\n', '\n', '    function balanceOf (address _owner) constant public returns (uint256 balance) { \n', '        return (accounts[_owner] & BALANCE_MASK).add(getVirtualBalance(_owner));\n', '    }\n', '\n', '    function transfer (address _to, uint256 _value) public returns (bool success) {\n', '        if (_value > balanceOf(msg.sender)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(msg.sender, _value);\n', '            return AbstractToken.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (_value > allowance(_from, msg.sender)) return false;\n', '        if (_value > balanceOf(_from)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(_from, _value);\n', '            return AbstractToken.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    function virtualBalanceOf (address _owner) internal view returns (uint256 _virtualBalance);\n', '\n', '    function getVirtualBalance (address _owner) private view returns (uint256 _virtualBalance) {\n', '        if (accounts [_owner] & MATERIALIZED_FLAG_MASK != 0) return 0;\n', '        else {\n', '            _virtualBalance = virtualBalanceOf(_owner);\n', '            uint256 maxVirtualBalance = MAXIMUM_TOKENS_COUNT.sub(tokensCount);\n', '            if (_virtualBalance > maxVirtualBalance)\n', '                _virtualBalance = maxVirtualBalance;\n', '        }\n', '    }\n', '\n', '    function materializeBalanceIfNeeded (address _owner, uint256 _value) private {\n', '        uint256 storedBalance = accounts[_owner];\n', '        if (storedBalance & MATERIALIZED_FLAG_MASK == 0) {\n', '            if (_value > storedBalance) {\n', '                uint256 virtualBalance = getVirtualBalance(_owner);\n', '                require (_value.sub(storedBalance) <= virtualBalance);\n', '                accounts[_owner] = MATERIALIZED_FLAG_MASK | storedBalance.add(virtualBalance);\n', '                tokensCount = tokensCount.add(virtualBalance);\n', '            }\n', '        }\n', '    }\n', '\n', '    uint256 tokensCount;\n', '}\n', '\n', 'contract PornLoversToken is HasNoTokens, AbstractVirtualToken {\n', '    \n', '    uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether;\n', '    uint256 private constant VIRTUAL_COUNT = 91;\n', '\n', '    event LogBonusSet(address indexed _address, uint256 _amount);\n', '\n', '    function virtualBalanceOf(address _owner) internal view returns (uint256) {\n', '        return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0;\n', '    }\n', '\n', '    function name() public pure returns (string result) {\n', '        return "91porn.com";\n', '    }\n', '\n', '    function symbol() public pure returns (string result) {\n', '        return "91porn";\n', '    }\n', '\n', '    function decimals() public pure returns (uint8 result) {\n', '        return 0;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transfer(_to, _value); \n', '        return success;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '\n', '        return success;\n', '    }\n', '\n', '    function massNotify(address[] _owners) public onlyOwner {\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            Transfer(address(0), _owners[i], VIRTUAL_COUNT);\n', '        }\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address who) public constant returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract HasNoTokens is Ownable {\n', '    event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount);\n', '\n', '    function extractTokens(address _token, address _claimer) onlyOwner public {\n', '        if (_token == 0x0) {\n', '            _claimer.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(_claimer, balance);\n', '        ExtractedTokens(_token, _claimer, balance);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '    function totalSupply () view public returns (uint256 supply);\n', '    function balanceOf (address _owner) view public returns (uint256 balance);\n', '    function transfer (address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve (address _spender, uint256 _value) public returns (bool success);\n', '    function allowance (address _owner, address _spender) view public returns (uint256 remaining);\n', '\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval (address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract AbstractToken is Token {\n', '    using SafeMath for uint;\n', '\n', '    function AbstractToken () public payable{\n', '        \n', '    }\n', '\n', '    function balanceOf (address _owner) view public returns (uint256 balance) {\n', '        return accounts[_owner];\n', '    }\n', '\n', '    function transfer (address _to, uint256 _value) public returns (bool success) {\n', '        uint256 fromBalance = accounts[msg.sender];\n', '        if (fromBalance < _value) return false;\n', '        if (_value > 0 && msg.sender != _to) {\n', '            accounts[msg.sender] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 spenderAllowance = allowances[_from][msg.sender];\n', '        if (spenderAllowance < _value) return false;\n', '        uint256 fromBalance = accounts[_from];\n', '        if (fromBalance < _value) return false;\n', '\n', '        allowances[_from][msg.sender] = spenderAllowance.sub(_value);\n', '\n', '        if (_value > 0 && _from != _to) {\n', '            accounts[_from] = fromBalance.sub(_value);\n', '            accounts[_to] = accounts[_to].add(_value);\n', '            Transfer(_from, _to, _value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function approve (address _spender, uint256 _value) public returns (bool success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance (address _owner, address _spender) view public returns (uint256 remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) accounts;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowances;\n', '}\n', '\n', 'contract AbstractVirtualToken is AbstractToken {\n', '    using SafeMath for uint;\n', '\n', '    uint256 constant MAXIMUM_TOKENS_COUNT = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    uint256 constant BALANCE_MASK = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    uint256 constant MATERIALIZED_FLAG_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    function AbstractVirtualToken () public{\n', '        \n', '    }\n', '\n', '    function totalSupply () view public returns (uint256 supply) {\n', '        return tokensCount;\n', '    }\n', '\n', '    function balanceOf (address _owner) constant public returns (uint256 balance) { \n', '        return (accounts[_owner] & BALANCE_MASK).add(getVirtualBalance(_owner));\n', '    }\n', '\n', '    function transfer (address _to, uint256 _value) public returns (bool success) {\n', '        if (_value > balanceOf(msg.sender)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(msg.sender, _value);\n', '            return AbstractToken.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if (_value > allowance(_from, msg.sender)) return false;\n', '        if (_value > balanceOf(_from)) return false;\n', '        else {\n', '            materializeBalanceIfNeeded(_from, _value);\n', '            return AbstractToken.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    function virtualBalanceOf (address _owner) internal view returns (uint256 _virtualBalance);\n', '\n', '    function getVirtualBalance (address _owner) private view returns (uint256 _virtualBalance) {\n', '        if (accounts [_owner] & MATERIALIZED_FLAG_MASK != 0) return 0;\n', '        else {\n', '            _virtualBalance = virtualBalanceOf(_owner);\n', '            uint256 maxVirtualBalance = MAXIMUM_TOKENS_COUNT.sub(tokensCount);\n', '            if (_virtualBalance > maxVirtualBalance)\n', '                _virtualBalance = maxVirtualBalance;\n', '        }\n', '    }\n', '\n', '    function materializeBalanceIfNeeded (address _owner, uint256 _value) private {\n', '        uint256 storedBalance = accounts[_owner];\n', '        if (storedBalance & MATERIALIZED_FLAG_MASK == 0) {\n', '            if (_value > storedBalance) {\n', '                uint256 virtualBalance = getVirtualBalance(_owner);\n', '                require (_value.sub(storedBalance) <= virtualBalance);\n', '                accounts[_owner] = MATERIALIZED_FLAG_MASK | storedBalance.add(virtualBalance);\n', '                tokensCount = tokensCount.add(virtualBalance);\n', '            }\n', '        }\n', '    }\n', '\n', '    uint256 tokensCount;\n', '}\n', '\n', 'contract PornLoversToken is HasNoTokens, AbstractVirtualToken {\n', '    \n', '    uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether;\n', '    uint256 private constant VIRTUAL_COUNT = 91;\n', '\n', '    event LogBonusSet(address indexed _address, uint256 _amount);\n', '\n', '    function virtualBalanceOf(address _owner) internal view returns (uint256) {\n', '        return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0;\n', '    }\n', '\n', '    function name() public pure returns (string result) {\n', '        return "91porn.com";\n', '    }\n', '\n', '    function symbol() public pure returns (string result) {\n', '        return "91porn";\n', '    }\n', '\n', '    function decimals() public pure returns (uint8 result) {\n', '        return 0;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transfer(_to, _value); \n', '        return success;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '\n', '        return success;\n', '    }\n', '\n', '    function massNotify(address[] _owners) public onlyOwner {\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            Transfer(address(0), _owners[i], VIRTUAL_COUNT);\n', '        }\n', '    }\n', '\n', '    function kill() public onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}']
