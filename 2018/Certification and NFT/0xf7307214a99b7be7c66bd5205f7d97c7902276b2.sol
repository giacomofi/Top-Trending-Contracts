['pragma solidity ^0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title BytesTools\n', ' * @dev Useful tools for bytes type\n', ' */\n', 'library BytesTools {\n', '\t\n', '\t/**\n', '\t * @dev Parses n of type bytes to uint256\n', '\t */\n', '\tfunction parseInt(bytes n) internal pure returns (uint256) {\n', '\t\t\n', '\t\tuint256 parsed = 0;\n', '\t\tbool decimals = false;\n', '\t\t\n', '\t\tfor (uint256 i = 0; i < n.length; i++) {\n', '\t\t\tif ( n[i] >= 48 && n[i] <= 57) {\n', '\t\t\t\t\n', '\t\t\t\tif (decimals) break;\n', '\t\t\t\t\n', '\t\t\t\tparsed *= 10;\n', '\t\t\t\tparsed += uint256(n[i]) - 48;\n', '\t\t\t} else if (n[i] == 46) {\n', '\t\t\t\tdecimals = true;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\treturn parsed;\n', '\t}\n', '\t\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\t\n', '\t/**\n', '\t* @dev Multiplies two numbers, throws on overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 c = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* @dev Integer division of two numbers, truncating the quotient.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a / b;\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* @dev Adds two numbers, throws on overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t* @dev Powers the first number to the second, throws on overflow.\n', '\t*/\n', '\tfunction pow(uint a, uint b) internal pure returns (uint) {\n', '\t\tif (b == 0) {\n', '\t\t\treturn 1;\n', '\t\t}\n', '\t\tuint c = a ** b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Multiplies the given number by 10**decimals\n', '\t */\n', '\tfunction withDecimals(uint number, uint decimals) internal pure returns (uint) {\n', '\t\treturn mul(number, pow(10, decimals));\n', '\t}\n', '\t\n', '}\n', '\n', '/**\n', '* @title Contract that will work with ERC223 tokens\n', '*/\n', 'contract ERC223Reciever {\n', '\t\n', '\t/**\n', '\t * @dev Standard ERC223 function that will handle incoming token transfers\n', '\t *\n', '\t * @param _from address  Token sender address\n', '\t * @param _value uint256 Amount of tokens\n', '\t * @param _data bytes  Transaction metadata\n', '\t */\n', '\tfunction tokenFallback(address _from, uint256 _value, bytes _data) external returns (bool);\n', '\t\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\t\n', '\taddress public owner;\n', '\taddress public potentialOwner;\n', '\t\n', '\t\n', '\tevent OwnershipRemoved(address indexed previousOwner);\n', '\tevent OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction Ownable() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyPotentialOwner() {\n', '\t\trequire(msg.sender == potentialOwner);\n', '\t\t_;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param newOwner The address of potential new owner to transfer ownership to.\n', '\t */\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransfer(owner, newOwner);\n', '\t\tpotentialOwner = newOwner;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Allow the potential owner confirm ownership of the contract.\n', '\t */\n', '\tfunction confirmOwnership() public onlyPotentialOwner {\n', '\t\temit OwnershipTransferred(owner, potentialOwner);\n', '\t\towner = potentialOwner;\n', '\t\tpotentialOwner = address(0);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Remove the contract owner permanently\n', '\t */\n', '\tfunction removeOwnership() public onlyOwner {\n', '\t\temit OwnershipRemoved(owner);\n', '\t\towner = address(0);\n', '\t}\n', '\t\n', '}\n', '\n', '/**\n', ' * @title  UKT Token Voting contract\n', ' * @author  Oleg Levshin <levshin@ucoz-team.net>\n', ' */\n', 'contract UKTTokenVoting is ERC223Reciever, Ownable {\n', '\t\n', '\tusing SafeMath for uint256;\n', '\tusing BytesTools for bytes;\n', '\t\n', '\tstruct Vote {\n', '\t\tuint256 proposalIdx;\n', '\t\tuint256 tokensValue;\n', '\t\tuint256 weight;\n', '\t\taddress tokenContractAddress;\n', '\t\tuint256 blockNumber;\n', '\t}\n', '\t\n', '\tmapping(address => bool) public acceptedTokens;\n', '\tmapping(address => uint256) public acceptedTokensValues;\n', '\t\n', '\tbytes32[] public proposals;\n', '\tmapping (uint256 => uint256) public proposalsWeights;\n', '\t\n', '\tuint256 public dateStart;\n', '\tuint256 public dateEnd;\n', '\t\n', '\taddress[] public voters;\n', '\tmapping (address => Vote) public votes;\n', '\t\n', '\tbool public isFinalized = false;\n', '\tbool public isFinalizedValidly = false;\n', '\t\n', '\tevent NewVote(address indexed voter, uint256 proposalIdx, uint256 proposalWeight);\n', '\tevent TokensClaimed(address to);\n', '\tevent TokensRefunded(address to);\n', '\t\n', '\t\n', '\tfunction UKTTokenVoting(\n', '\t\tuint256 _dateEnd,\n', '\t\tbytes32[] _proposals,\n', '\t\taddress[] _acceptedTokens,\n', '\t\tuint256[] _acceptedTokensValues\n', '\t) public {\n', '\t\trequire(_dateEnd > now);\n', '\t\trequire(_proposals.length > 1);\n', '\t\trequire(_acceptedTokens.length > 0);\n', '\t\trequire(_acceptedTokensValues.length > 0);\n', '\t\trequire(_acceptedTokens.length == _acceptedTokensValues.length);\n', '\t\t\n', '\t\tdateStart = now;\n', '\t\tdateEnd = _dateEnd;\n', '\t\t\n', '\t\tproposals.push("Not valid proposal");\n', '\t\tproposalsWeights[0] = 0;\n', '\t\tfor(uint256 i = 0; i < _proposals.length; i++) {\n', '\t\t\tproposals.push(_proposals[i]);\n', '\t\t\tproposalsWeights[i+1] = 0;\n', '\t\t}\n', '\t\t\n', '\t\tfor(uint256 j = 0; j < _acceptedTokens.length; j++) {\n', '\t\t\tacceptedTokens[_acceptedTokens[j]] = true;\n', '\t\t\tacceptedTokensValues[_acceptedTokens[j]] = _acceptedTokensValues[j];\n', '\t\t}\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Executes automatically when user transfer his token to this contract address\n', '\t */\n', '\tfunction tokenFallback(\n', '\t\taddress _from,\n', '\t\tuint256 _value,\n', '\t\tbytes _data\n', '\t) external returns (bool) {\n', '\t\t// voting hasn&#39;t ended yet\n', '\t\trequire(now < dateEnd);\n', '\t\t\n', '\t\t// executed from contract in acceptedTokens\n', '\t\trequire(acceptedTokens[msg.sender] == true);\n', '\t\t\n', '\t\t// value of tokens is enough for voting\n', '\t\trequire(_value >= acceptedTokensValues[msg.sender]);\n', '\t\t\n', '\t\t// give proposal index is valid\n', '\t\tuint256 proposalIdx = _data.parseInt();\n', '\t\trequire(isValidProposal(proposalIdx));\n', '\t\t\n', '\t\t// user hasn&#39;t voted yet\n', '\t\trequire(isAddressNotVoted(_from));\n', '\t\t\n', '\t\tuint256 weight = _value.div(acceptedTokensValues[msg.sender]);\n', '\t\t\n', '\t\tvotes[_from] = Vote(proposalIdx, _value, weight, msg.sender, block.number);\n', '\t\tvoters.push(_from);\n', '\t\t\n', '\t\tproposalsWeights[proposalIdx] = proposalsWeights[proposalIdx].add(weight);\n', '\t\t\n', '\t\temit NewVote(_from, proposalIdx, proposalsWeights[proposalIdx]);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Gets winner tuple after voting is finished\n', '\t */\n', '\tfunction getWinner() external view returns (uint256 winnerIdx, bytes32 winner, uint256 winnerWeight) {\n', '\t\trequire(now >= dateEnd);\n', '\t\t\n', '\t\twinnerIdx = 0;\n', '\t\twinner = proposals[winnerIdx];\n', '\t\twinnerWeight = proposalsWeights[winnerIdx];\n', '\t\t\n', '\t\tfor(uint256 i = 1; i < proposals.length; i++) {\n', '\t\t\tif(proposalsWeights[i] >= winnerWeight) {\n', '\t\t\t\twinnerIdx = i;\n', '\t\t\t\twinner = proposals[winnerIdx];\n', '\t\t\t\twinnerWeight = proposalsWeights[i];\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif (winnerIdx > 0) {\n', '\t\t\tfor(uint256 j = 1; j < proposals.length; j++) {\n', '\t\t\t\tif(j != winnerIdx && proposalsWeights[j] == proposalsWeights[winnerIdx]) {\n', '\t\t\t\t\treturn (0, proposals[0], proposalsWeights[0]);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\treturn (winnerIdx, winner, winnerWeight);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Finalizes voting\n', '\t */\n', '\tfunction finalize(bool _isFinalizedValidly) external onlyOwner {\n', '\t\trequire(now >= dateEnd && ! isFinalized);\n', '\t\t\n', '\t\tisFinalized = true;\n', '\t\tisFinalizedValidly = _isFinalizedValidly;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Allows voter to claim his tokens back to address\n', '\t */\n', '\tfunction claimTokens() public returns (bool) {\n', '\t\trequire(isAddressVoted(msg.sender));\n', '\t\t\n', '\t\trequire(transferTokens(msg.sender));\n', '\t\temit TokensClaimed(msg.sender);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Refunds tokens for all voters\n', '\t */\n', '\tfunction refundTokens(address to) public onlyOwner returns (bool) {\n', '\t\tif(to != address(0)) {\n', '\t\t\treturn _refundTokens(to);\n', '\t\t}\n', '\t\t\n', '\t\tfor(uint256 i = 0; i < voters.length; i++) {\n', '\t\t\t_refundTokens(voters[i]);\n', '\t\t}\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Checks proposal index for validity\n', '\t */\n', '\tfunction isValidProposal(uint256 proposalIdx) private view returns (bool) {\n', '\t\treturn (\n', '\t\t\tproposalIdx > 0 &&\n', '\t\t\tproposals[proposalIdx].length > 0\n', '\t\t);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Return true if address not voted yet\n', '\t */\n', '\tfunction isAddressNotVoted(address _address) private view returns (bool) {\n', '\t\t// solium-disable-next-line operator-whitespace\n', '\t\treturn (\n', '\t\t\t// solium-disable-next-line operator-whitespace\n', '\t\t\tvotes[_address].proposalIdx == 0 &&\n', '\t\t\tvotes[_address].tokensValue == 0 &&\n', '\t\t\tvotes[_address].weight == 0 &&\n', '\t\t\tvotes[_address].tokenContractAddress == address(0) &&\n', '\t\t\tvotes[_address].blockNumber == 0\n', '\t\t);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Return true if address already voted\n', '\t */\n', '\tfunction isAddressVoted(address _address) private view returns (bool) {\n', '\t\treturn ! isAddressNotVoted(_address);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Trasnfer tokens to voter\n', '\t */\n', '\tfunction transferTokens(address to) private returns (bool) {\n', '\t\t\n', '\t\tVote memory vote = votes[to];\n', '\t\t\n', '\t\tif(vote.tokensValue == 0) {\n', '\t\t\treturn true;\n', '\t\t}\n', '\t\tvotes[to].tokensValue = 0;\n', '\t\t\n', '\t\tif ( ! isFinalized) {\n', '\t\t\tvotes[to] = Vote(0, 0, 0, address(0), 0);\n', '\t\t\tproposalsWeights[vote.proposalIdx] = proposalsWeights[vote.proposalIdx].sub(vote.weight);\n', '\t\t}\n', '\t\t\n', '\t\treturn vote.tokenContractAddress.call(bytes4(keccak256("transfer(address,uint256)")), to, vote.tokensValue);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Refunds tokens to particular address\n', '\t */\n', '\tfunction _refundTokens(address to) private returns (bool) {\n', '\t\trequire(transferTokens(to));\n', '\t\temit TokensRefunded(to);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\t\n', '}\n', '\n', '/**\n', ' * @title  UKT Token Voting Factory contract\n', ' * @author  Oleg Levshin <levshin@ucoz-team.net>\n', ' */\n', 'contract UKTTokenVotingFactory is Ownable {\n', '\t\n', '\taddress[] public votings;\n', '\tmapping(address => int256) public votingsWinners;\n', '\t\n', '\tevent VotingCreated(address indexed votingAddress, uint256 dateEnd, bytes32[] proposals, address[] acceptedTokens, uint256[] acceptedTokensValues);\n', '\tevent WinnerSetted(address indexed votingAddress, uint256 winnerIdx, bytes32 winner, uint256 winnerWeight);\n', '\tevent VotingFinalized(address indexed votingAddress, bool isFinalizedValidly);\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Checks voting contract address for validity\n', '\t */\n', '\tfunction isValidVoting(address votingAddress) private view returns (bool) {\n', '\t\tfor (uint256 i = 0; i < votings.length; i++) {\n', '\t\t\tif (votings[i] == votingAddress) {\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\treturn false;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Creates new instance of UKTTokenVoting contract with given params\n', '\t */\n', '\tfunction getNewVoting(\n', '\t\tuint256 dateEnd,\n', '\t\tbytes32[] proposals,\n', '\t\taddress[] acceptedTokens,\n', '\t\tuint256[] acceptedTokensValues\n', '\t) public onlyOwner returns (address votingAddress) {\n', '\t\t\n', '\t\tvotingAddress = address(new UKTTokenVoting(dateEnd, proposals, acceptedTokens, acceptedTokensValues));\n', '\t\t\n', '\t\temit VotingCreated(votingAddress, dateEnd, proposals, acceptedTokens, acceptedTokensValues);\n', '\t\t\n', '\t\tvotings.push(votingAddress);\n', '\t\tvotingsWinners[votingAddress] = -1;\n', '\t\t\n', '\t\treturn votingAddress;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Refunds tokens for all voters\n', '\t */\n', '\tfunction refundVotingTokens(address votingAddress, address to) public onlyOwner returns (bool) {\n', '\t\trequire(isValidVoting(votingAddress));\n', '\t\t\n', '\t\treturn UKTTokenVoting(votingAddress).refundTokens(to);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Sets calculated proposalIdx as voting winner\n', '\t */\n', '\tfunction setVotingWinner(address votingAddress) public onlyOwner {\n', '\t\trequire(votingsWinners[votingAddress] == -1);\n', '\t\t\n', '\t\tuint256 winnerIdx;\n', '\t\tbytes32 winner;\n', '\t\tuint256 winnerWeight;\n', '\t\t\n', '\t\t(winnerIdx, winner, winnerWeight) = UKTTokenVoting(votingAddress).getWinner();\n', '\t\t\n', '\t\tbool isFinalizedValidly = winnerIdx > 0;\n', '\t\t\n', '\t\tUKTTokenVoting(votingAddress).finalize(isFinalizedValidly);\n', '\t\t\n', '\t\temit VotingFinalized(votingAddress, isFinalizedValidly);\n', '\t\t\n', '\t\tvotingsWinners[votingAddress] = int256(winnerIdx);\n', '\t\t\n', '\t\temit WinnerSetted(votingAddress, winnerIdx, winner, winnerWeight);\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '\t * @dev Gets voting winner\n', '\t */\n', '\tfunction getVotingWinner(address votingAddress) public view returns (bytes32) {\n', '\t\trequire(votingsWinners[votingAddress] > -1);\n', '\t\t\n', '\t\treturn UKTTokenVoting(votingAddress).proposals(uint256(votingsWinners[votingAddress]));\n', '\t}\n', '}']