['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/Interface/EIP20Interface.sol\n', '\n', 'contract EIP20Interface {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    function totalSupply() public view returns (uint256 supply);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balanceÏ€\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/PLCRVoting.sol\n', '\n', 'library DLL {\n', '    uint constant NULL_NODE_ID = 0;\n', '\n', '    struct Node {\n', '        uint next;\n', '        uint prev;\n', '    }\n', '\n', '    struct Data {\n', '        mapping(uint => Node) dll;\n', '    }\n', '\n', '    function isEmpty(Data storage self) public view returns (bool) {\n', '        return getStart(self) == NULL_NODE_ID;\n', '    }\n', '\n', '    function contains(Data storage self, uint _curr) public view returns (bool) {\n', '        if (isEmpty(self) || _curr == NULL_NODE_ID) {\n', '            return false;\n', '        } \n', '\n', '        bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n', '        bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n', '        return isSingleNode || !isNullNode;\n', '    }\n', '\n', '    function getNext(Data storage self, uint _curr) public view returns (uint) {\n', '        return self.dll[_curr].next;\n', '    }\n', '\n', '    function getPrev(Data storage self, uint _curr) public view returns (uint) {\n', '        return self.dll[_curr].prev;\n', '    }\n', '\n', '    function getStart(Data storage self) public view returns (uint) {\n', '        return getNext(self, NULL_NODE_ID);\n', '    }\n', '\n', '    function getEnd(Data storage self) public view returns (uint) {\n', '        return getPrev(self, NULL_NODE_ID);\n', '    }\n', '\n', '    /**\n', '    @dev Inserts a new node between _prev and _next. When inserting a node already existing in \n', '    the list it will be automatically removed from the old position.\n', '    @param _prev the node which _new will be inserted after\n', '    @param _curr the id of the new node being inserted\n', '    @param _next the node which _new will be inserted before\n', '    */\n', '    function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n', '        require(_curr != NULL_NODE_ID);\n', '\n', '        remove(self, _curr);\n', '\n', '        require(_prev == NULL_NODE_ID || contains(self, _prev));\n', '        require(_next == NULL_NODE_ID || contains(self, _next));\n', '\n', '        require(getNext(self, _prev) == _next);\n', '        require(getPrev(self, _next) == _prev);\n', '\n', '        self.dll[_curr].prev = _prev;\n', '        self.dll[_curr].next = _next;\n', '\n', '        self.dll[_prev].next = _curr;\n', '        self.dll[_next].prev = _curr;\n', '    }\n', '\n', '    function remove(Data storage self, uint _curr) public {\n', '        if (!contains(self, _curr)) {\n', '            return;\n', '        }\n', '\n', '        uint next = getNext(self, _curr);\n', '        uint prev = getPrev(self, _curr);\n', '\n', '        self.dll[next].prev = prev;\n', '        self.dll[prev].next = next;\n', '\n', '        delete self.dll[_curr];\n', '    }\n', '}\n', '\n', 'library AttributeStore {\n', '    struct Data {\n', '        mapping(bytes32 => uint) store;\n', '    }\n', '\n', '    function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n', '    public view returns (uint) {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        return self.store[key];\n', '    }\n', '\n', '    function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n', '    public {\n', '        bytes32 key = keccak256(_UUID, _attrName);\n', '        self.store[key] = _attrVal;\n', '    }\n', '}\n', '\n', '\n', '/**\n', '@title Partial-Lock-Commit-Reveal Voting scheme with ERC20 tokens\n', '@author Team: Aspyn Palatnick, Cem Ozer, Yorke Rhodes\n', '*/\n', 'contract PLCRVoting {\n', '\n', '    // ============\n', '    // EVENTS:\n', '    // ============\n', '\n', '    event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n', '    event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\n', '    event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n', '    event _VotingRightsGranted(uint numTokens, address indexed voter);\n', '    event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n', '    event _TokensRescued(uint indexed pollID, address indexed voter);\n', '\n', '    // ============\n', '    // DATA STRUCTURES:\n', '    // ============\n', '\n', '    using AttributeStore for AttributeStore.Data;\n', '    using DLL for DLL.Data;\n', '    using SafeMath for uint;\n', '\n', '    struct Poll {\n', '        uint commitEndDate;     /// expiration date of commit period for poll\n', '        uint revealEndDate;     /// expiration date of reveal period for poll\n', '        uint voteQuorum;\t    /// number of votes required for a proposal to pass\n', '        uint votesFor;\t\t    /// tally of votes supporting proposal\n', '        uint votesAgainst;      /// tally of votes countering proposal\n', '        mapping(address => bool) didCommit;  /// indicates whether an address committed a vote for this poll\n', '        mapping(address => bool) didReveal;   /// indicates whether an address revealed a vote for this poll\n', '    }\n', '\n', '    // ============\n', '    // STATE VARIABLES:\n', '    // ============\n', '\n', '    uint constant public INITIAL_POLL_NONCE = 0;\n', '    uint public pollNonce;\n', '\n', '    mapping(uint => Poll) public pollMap; // maps pollID to Poll struct\n', '    mapping(address => uint) public voteTokenBalance; // maps user&#39;s address to voteToken balance\n', '\n', '    mapping(address => DLL.Data) dllMap;\n', '    AttributeStore.Data store;\n', '\n', '    EIP20Interface public token;\n', '\n', '    /**\n', '    @dev Initializer. Can only be called once.\n', '    @param _token The address where the ERC20 token contract is deployed\n', '    */\n', '    constructor(address _token) public {\n', '        require(_token != 0 && address(token) == 0);\n', '\n', '        token = EIP20Interface(_token);\n', '        pollNonce = INITIAL_POLL_NONCE;\n', '    }\n', '\n', '    // ================\n', '    // TOKEN INTERFACE:\n', '    // ================\n', '\n', '    /**\n', '    @notice Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights\n', '    @dev Assumes that msg.sender has approved voting contract to spend on their behalf\n', '    @param _numTokens The number of votingTokens desired in exchange for ERC20 tokens\n', '    */\n', '    function requestVotingRights(uint _numTokens) public {\n', '        require(token.balanceOf(msg.sender) >= _numTokens);\n', '        voteTokenBalance[msg.sender] += _numTokens;\n', '        require(token.transferFrom(msg.sender, this, _numTokens));\n', '        emit _VotingRightsGranted(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice Withdraw _numTokens ERC20 tokens from the voting contract, revoking these voting rights\n', '    @param _numTokens The number of ERC20 tokens desired in exchange for voting rights\n', '    */\n', '    function withdrawVotingRights(uint _numTokens) external {\n', '        uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n', '        require(availableTokens >= _numTokens);\n', '        voteTokenBalance[msg.sender] -= _numTokens;\n', '        require(token.transfer(msg.sender, _numTokens));\n', '        emit _VotingRightsWithdrawn(_numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed vote where poll has ended\n', '    @param _pollID Integer identifier associated with the target poll\n', '    */\n', '    function rescueTokens(uint _pollID) public {\n', '        require(isExpired(pollMap[_pollID].revealEndDate));\n', '        require(dllMap[msg.sender].contains(_pollID));\n', '\n', '        dllMap[msg.sender].remove(_pollID);\n', '        emit _TokensRescued(_pollID, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @dev Unlocks tokens locked in unrevealed votes where polls have ended\n', '    @param _pollIDs Array of integer identifiers associated with the target polls\n', '    */\n', '    function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\n', '        // loop through arrays, rescuing tokens from all\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            rescueTokens(_pollIDs[i]);\n', '        }\n', '    }\n', '\n', '    // =================\n', '    // VOTING INTERFACE:\n', '    // =================\n', '\n', '    /**\n', '    @notice Commits vote using hash of choice and secret salt to conceal vote until reveal\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _secretHash Commit keccak256 hash of voter&#39;s choice and salt (tightly packed in this order)\n', '    @param _numTokens The number of tokens to be committed towards the target poll\n', '    @param _prevPollID The ID of the poll that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\n', '        require(commitPeriodActive(_pollID));\n', '\n', '        // if msg.sender doesn&#39;t have enough voting rights,\n', '        // request for enough voting rights\n', '        if (voteTokenBalance[msg.sender] < _numTokens) {\n', '            uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\n', '            requestVotingRights(remainder);\n', '        }\n', '\n', '        // make sure msg.sender has enough voting rights\n', '        require(voteTokenBalance[msg.sender] >= _numTokens);\n', '        // prevent user from committing to zero node placeholder\n', '        require(_pollID != 0);\n', '        // prevent user from committing a secretHash of 0\n', '        require(_secretHash != 0);\n', '\n', '        // Check if _prevPollID exists in the user&#39;s DLL or if _prevPollID is 0\n', '        require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n', '\n', '        uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n', '\n', '        // edge case: in-place update\n', '        if (nextPollID == _pollID) {\n', '            nextPollID = dllMap[msg.sender].getNext(_pollID);\n', '        }\n', '\n', '        require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n', '        dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n', '\n', '        bytes32 UUID = attrUUID(msg.sender, _pollID);\n', '\n', '        store.setAttribute(UUID, "numTokens", _numTokens);\n', '        store.setAttribute(UUID, "commitHash", uint(_secretHash));\n', '\n', '        pollMap[_pollID].didCommit[msg.sender] = true;\n', '        emit _VoteCommitted(_pollID, _numTokens, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice                 Commits votes using hashes of choices and secret salts to conceal votes until reveal\n', '    @param _pollIDs         Array of integer identifiers associated with target polls\n', '    @param _secretHashes    Array of commit keccak256 hashes of voter&#39;s choices and salts (tightly packed in this order)\n', '    @param _numsTokens      Array of numbers of tokens to be committed towards the target polls\n', '    @param _prevPollIDs     Array of IDs of the polls that the user has voted the maximum number of tokens in which is still less than or equal to numTokens\n', '    */\n', '    function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\n', '        // make sure the array lengths are all the same\n', '        require(_pollIDs.length == _secretHashes.length);\n', '        require(_pollIDs.length == _numsTokens.length);\n', '        require(_pollIDs.length == _prevPollIDs.length);\n', '\n', '        // loop through arrays, committing each individual vote values\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @dev Compares previous and next poll&#39;s committed tokens for sorting purposes\n', '    @param _prevID Integer identifier associated with previous poll in sorted order\n', '    @param _nextID Integer identifier associated with next poll in sorted order\n', '    @param _voter Address of user to check DLL position for\n', '    @param _numTokens The number of tokens to be committed towards the poll (used for sorting)\n', '    @return valid Boolean indication of if the specified position maintains the sort\n', '    */\n', '    function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n', '        bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n', '        // if next is zero node, _numTokens does not need to be greater\n', '        bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n', '        return prevValid && nextValid;\n', '    }\n', '\n', '    /**\n', '    @notice Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _voteOption Vote choice used to generate commitHash for associated poll\n', '    @param _salt Secret number used to generate commitHash for associated poll\n', '    */\n', '    function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\n', '        // Make sure the reveal period is active\n', '        require(revealPeriodActive(_pollID));\n', '        require(pollMap[_pollID].didCommit[msg.sender]);                         // make sure user has committed a vote for this poll\n', '        require(!pollMap[_pollID].didReveal[msg.sender]);                        // prevent user from revealing multiple times\n', '        require(keccak256(abi.encodePacked(_voteOption, _salt)) == getCommitHash(msg.sender, _pollID)); // compare resultant hash from inputs to original commitHash\n', '\n', '        uint numTokens = getNumTokens(msg.sender, _pollID);\n', '\n', '        if (_voteOption == 1) {// apply numTokens to appropriate poll choice\n', '            pollMap[_pollID].votesFor += numTokens;\n', '        } else {\n', '            pollMap[_pollID].votesAgainst += numTokens;\n', '        }\n', '\n', '        dllMap[msg.sender].remove(_pollID); // remove the node referring to this vote upon reveal\n', '        pollMap[_pollID].didReveal[msg.sender] = true;\n', '\n', '        emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice             Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens\n', '    @param _pollIDs     Array of integer identifiers associated with target polls\n', '    @param _voteOptions Array of vote choices used to generate commitHashes for associated polls\n', '    @param _salts       Array of secret numbers used to generate commitHashes for associated polls\n', '    */\n', '    function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\n', '        // make sure the array lengths are all the same\n', '        require(_pollIDs.length == _voteOptions.length);\n', '        require(_pollIDs.length == _salts.length);\n', '\n', '        // loop through arrays, revealing each individual vote values\n', '        for (uint i = 0; i < _pollIDs.length; i++) {\n', '            revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @param _pollID Integer identifier associated with target poll\n', '    @param _salt Arbitrarily chosen integer used to generate secretHash\n', '    @return correctVotes Number of tokens voted for winning option\n', '    */\n', '    function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\n', '        require(pollEnded(_pollID));\n', '        require(pollMap[_pollID].didReveal[_voter]);\n', '\n', '        uint winningChoice = isPassed(_pollID) ? 1 : 0;\n', '        bytes32 winnerHash = keccak256(abi.encodePacked(winningChoice, _salt));\n', '        bytes32 commitHash = getCommitHash(_voter, _pollID);\n', '\n', '        require(winnerHash == commitHash);\n', '\n', '        return getNumTokens(_voter, _pollID);\n', '    }\n', '\n', '    // ==================\n', '    // POLLING INTERFACE:\n', '    // ==================\n', '\n', '    /**\n', '    @dev Initiates a poll with canonical configured parameters at pollID emitted by PollCreated event\n', '    @param _voteQuorum Type of majority (out of 100) that is necessary for poll to be successful\n', '    @param _commitDuration Length of desired commit period in seconds\n', '    @param _revealDuration Length of desired reveal period in seconds\n', '    */\n', '    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n', '        pollNonce = pollNonce + 1;\n', '\n', '        uint commitEndDate = block.timestamp.add(_commitDuration);\n', '        uint revealEndDate = commitEndDate.add(_revealDuration);\n', '\n', '        pollMap[pollNonce] = Poll({\n', '            voteQuorum: _voteQuorum,\n', '            commitEndDate: commitEndDate,\n', '            revealEndDate: revealEndDate,\n', '            votesFor: 0,\n', '            votesAgainst: 0\n', '        });\n', '\n', '        emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n', '        return pollNonce;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if proposal has passed\n', '    @dev Check if votesFor out of totalVotes exceeds votesQuorum (requires pollEnded)\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function isPassed(uint _pollID) constant public returns (bool passed) {\n', '        require(pollEnded(_pollID));\n', '\n', '        Poll memory poll = pollMap[_pollID];\n', '        return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n', '    }\n', '\n', '    // ----------------\n', '    // POLLING HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Gets the total winning votes for reward distribution purposes\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Total number of votes committed to the winning option for specified poll\n', '    */\n', '    function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n', '        require(pollEnded(_pollID));\n', '\n', '        if (isPassed(_pollID))\n', '            return pollMap[_pollID].votesFor;\n', '        else\n', '            return pollMap[_pollID].votesAgainst;\n', '    }\n', '\n', '    /**\n', '    @notice Determines if poll is over\n', '    @dev Checks isExpired for specified poll&#39;s revealEndDate\n', '    @return Boolean indication of whether polling period is over\n', '    */\n', '    function pollEnded(uint _pollID) constant public returns (bool ended) {\n', '        require(pollExists(_pollID));\n', '\n', '        return isExpired(pollMap[_pollID].revealEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the commit period is still active for the specified poll\n', '    @dev Checks isExpired for the specified poll&#39;s commitEndDate\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of isCommitPeriodActive for target poll\n', '    */\n', '    function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].commitEndDate);\n', '    }\n', '\n', '    /**\n', '    @notice Checks if the reveal period is still active for the specified poll\n', '    @dev Checks isExpired for the specified poll&#39;s revealEndDate\n', '    @param _pollID Integer identifier associated with target poll\n', '    */\n', '    function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n', '        require(pollExists(_pollID));\n', '\n', '        return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has committed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has committed\n', '    */\n', '    function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didCommit[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if user has revealed for specified poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Boolean indication of whether user has revealed\n', '    */\n', '    function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n', '        require(pollExists(_pollID));\n', '\n', '        return pollMap[_pollID].didReveal[_voter];\n', '    }\n', '\n', '    /**\n', '    @dev Checks if a poll exists\n', '    @param _pollID The pollID whose existance is to be evaluated.\n', '    @return Boolean Indicates whether a poll exists for the provided pollID\n', '    */\n', '    function pollExists(uint _pollID) constant public returns (bool exists) {\n', '        return (_pollID != 0 && _pollID <= pollNonce);\n', '    }\n', '\n', '    // ---------------------------\n', '    // DOUBLE-LINKED-LIST HELPERS:\n', '    // ---------------------------\n', '\n', '    /**\n', '    @dev Gets the bytes32 commitHash property of target poll\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Bytes32 hash property attached to target poll\n', '    */\n', '    function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n', '        return bytes32(store.getAttribute(attrUUID(_voter, _pollID), "commitHash"));\n', '    }\n', '\n', '    /**\n', '    @dev Wrapper for getAttribute with attrName="numTokens"\n', '    @param _voter Address of user to check against\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return Number of tokens committed to poll in sorted poll-linked-list\n', '    */\n', '    function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n', '        return store.getAttribute(attrUUID(_voter, _pollID), "numTokens");\n', '    }\n', '\n', '    /**\n', '    @dev Gets top element of sorted poll-linked-list\n', '    @param _voter Address of user to check against\n', '    @return Integer identifier to poll with maximum number of tokens committed to it\n', '    */\n', '    function getLastNode(address _voter) constant public returns (uint pollID) {\n', '        return dllMap[_voter].getPrev(0);\n', '    }\n', '\n', '    /**\n', '    @dev Gets the numTokens property of getLastNode\n', '    @param _voter Address of user to check against\n', '    @return Maximum number of tokens committed in poll specified\n', '    */\n', '    function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n', '        return getNumTokens(_voter, getLastNode(_voter));\n', '    }\n', '\n', '    /*\n', '    @dev Takes the last node in the user&#39;s DLL and iterates backwards through the list searching\n', '    for a node with a value less than or equal to the provided _numTokens value. When such a node\n', '    is found, if the provided _pollID matches the found nodeID, this operation is an in-place\n', '    update. In that case, return the previous node of the node being updated. Otherwise return the\n', '    first node that was found with a value less than or equal to the provided _numTokens.\n', '    @param _voter The voter whose DLL will be searched\n', '    @param _numTokens The value for the numTokens attribute in the node to be inserted\n', '    @return the node which the propoded node should be inserted after\n', '    */\n', '    function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n', '    constant public returns (uint prevNode) {\n', '      // Get the last node in the list and the number of tokens in that node\n', '        uint nodeID = getLastNode(_voter);\n', '        uint tokensInNode = getNumTokens(_voter, nodeID);\n', '\n', '      // Iterate backwards through the list until reaching the root node\n', '        while(nodeID != 0) {\n', '            // Get the number of tokens in the current node\n', '            tokensInNode = getNumTokens(_voter, nodeID);\n', '            if (tokensInNode <= _numTokens) { // We found the insert point!\n', '                if (nodeID == _pollID) {\n', '                    // This is an in-place update. Return the prev node of the node being updated\n', '                    nodeID = dllMap[_voter].getPrev(nodeID);\n', '                }\n', '            // Return the insert point\n', '                return nodeID;\n', '            }\n', '            // We did not find the insert point. Continue iterating backwards through the list\n', '            nodeID = dllMap[_voter].getPrev(nodeID);\n', '        }\n', '\n', '        // The list is empty, or a smaller value than anything else in the list is being inserted\n', '        return nodeID;\n', '    }\n', '\n', '    // ----------------\n', '    // GENERAL HELPERS:\n', '    // ----------------\n', '\n', '    /**\n', '    @dev Checks if an expiration date has been reached\n', '    @param _terminationDate Integer timestamp of date to compare current timestamp with\n', '    @return expired Boolean indication of whether the terminationDate has passed\n', '    */\n', '    function isExpired(uint _terminationDate) constant public returns (bool expired) {\n', '        return (block.timestamp > _terminationDate);\n', '    }\n', '\n', '    /**\n', '    @dev Generates an identifier which associates a user and a poll together\n', '    @param _pollID Integer identifier associated with target poll\n', '    @return UUID Hash which is deterministic from _user and _pollID\n', '    */\n', '    function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n', '        return keccak256(abi.encodePacked(_user, _pollID));\n', '    }\n', '}']