['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Constant {\n', '    function balanceOf( address who ) view public returns (uint value);\n', '}\n', 'contract ERC20Stateful {\n', '    function transfer( address to, uint value) public returns (bool ok);\n', '}\n', 'contract ERC20Events {\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', 'contract ERC20 is ERC20Constant, ERC20Stateful, ERC20Events {}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"owner only");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract WhitelistSale is Owned {\n', '\n', '    ERC20 public blocToken;\n', '\n', '    uint256 public blocPerEth;\n', '    \n', '    bool running;\n', '\n', '    mapping(address => bool) public whitelisted;\n', '\n', '    mapping(address => uint256) public bought;\n', '    \n', '    mapping(address => uint256) public userLimitAmount;\n', '    \n', '    mapping(address => bool) public whitelistUserGettedBloc;\n', '        \n', '    mapping(address => bool) public whitelistUserGettedEthBack;\n', '    \n', '    uint256 rebackRate; // 0-10000\n', '    uint256 constant MaxRate = 10000; \n', '    address public receiver;\n', '    address[] private whitelistUsers;\n', '    uint256 constant public maxGasPrice = 50000000000;\n', '\n', '    event LogWithdrawal(uint256 _value);\n', '    event LogBought(uint orderInMana);\n', '    // event LogUserAdded(address user);\n', '    event LogUserRemoved(address user);\n', '\n', '    constructor(\n', '        address _receiver\n', '    ) public Owned()\n', '    {\n', '        blocToken;\n', '        receiver         = _receiver;\n', '        blocPerEth       = 0;\n', '        whitelistUsers   = new address[](0);\n', '        rebackRate       = 0;\n', '        running          = true;\n', '    }\n', '    \n', '    function getRebackRate() public view returns (uint256 rate) {\n', '        return rebackRate;\n', '    }\n', '    \n', '    function changePerEthToBlocNumber(uint256 _value)  public onlyOwner {\n', '        require(_value > 0,"ratio must > 0");\n', '        blocPerEth = _value;\n', '    }\n', '    \n', '    function changeRebackRate(uint256 _rate)  public onlyOwner {\n', '        require(_rate > 0,"refundrate must > 0");\n', '        require(_rate < MaxRate,"refundrate must < 10000");\n', '        rebackRate = _rate;\n', '    }\n', '    \n', '    function changeBlocTokenAdress(ERC20 _tokenContractAddress)  public onlyOwner {\n', '        blocToken = _tokenContractAddress;\n', '    }\n', '    \n', '    function withdrawEth(uint256 _value)  public onlyOwner {\n', '        require(receiver != address(0),"receiver not set");\n', '        receiver.transfer(_value);\n', '    }\n', '\n', '    function withdrawBloc(uint256 _value)  public onlyOwner  returns (bool ok) {\n', '        require(blocToken != address(0),"token contract not set");\n', '        return withdrawToken(blocToken, _value);\n', '    }\n', '\n', '    function withdrawToken(address _token, uint256 _value) private onlyOwner  returns (bool ok) {\n', '        bool result = ERC20(_token).transfer(owner,_value);\n', '        if (result) emit LogWithdrawal(_value);\n', '        return result;\n', '    }\n', '\n', '    function changeReceiver(address _receiver) public onlyOwner {\n', '        require(_receiver != address(0),"empty receiver");\n', '        receiver = _receiver;\n', '    }\n', '    \n', '    function changeBlocPerEth(uint256 _value) public onlyOwner {\n', '        require(_value != 0,"ratio should > 0");\n', '        blocPerEth = _value;\n', '    }\n', '    \n', '    function changeRuningState(bool _value) public onlyOwner {\n', '        running = _value;\n', '    }\n', '    \n', '    modifier onlyIsRuning {\n', '        require(running,"KYC over");\n', '        _;\n', '    }\n', '\n', '    function buy() private onlyIsRuning {\n', '        require(whitelisted[msg.sender],"not whitelisted");\n', '        require(whitelistUserGettedBloc[msg.sender] == false,"token already sent");\n', '        require(msg.value >= 0.2 ether,"must greater or equal to 0.2 eth");\n', '\n', '        uint256 allowedForSender = SafeMath.sub(userLimitAmount[msg.sender], bought[msg.sender]);\n', '        if (msg.value > allowedForSender) revert("over limit amount");\n', '        // receiver.transfer(msg.value);\n', '        bought[msg.sender] = SafeMath.add(bought[msg.sender], msg.value);\n', '    }\n', '    \n', '    function transferBlocToUser(address userAddress) public onlyOwner {\n', '        require(rebackRate < MaxRate,"refundrate overflow");\n', '        require(blocPerEth > 0,"token ratio not set");\n', '        require(whitelistUserGettedBloc[userAddress] == false,"token already sent");\n', '        require(bought[userAddress] > 0,"not bought");\n', '             \n', '        uint256 bountPerEth = SafeMath.mul( blocPerEth , (MaxRate - rebackRate));\n', '        uint orderInBloc = SafeMath.mul(SafeMath.div(bought[userAddress],MaxRate),bountPerEth) ;\n', '            \n', '        uint256 balanceInBloc = blocToken.balanceOf(address(this));\n', '        if (orderInBloc > balanceInBloc) revert("not enough token");\n', '        if (blocToken.transfer(userAddress, orderInBloc)) whitelistUserGettedBloc[userAddress] = true;\n', '    }\n', '    \n', '    function transferEthBackToUser(address userAddress) public onlyOwner {\n', '        require(rebackRate > 0,"refundrate not set");\n', '        require(whitelistUserGettedEthBack[userAddress] == false,"token already sent");\n', '        require(bought[userAddress] > 0,"not bought");\n', '             \n', '        uint backEthNumber = SafeMath.mul(SafeMath.div(bought[userAddress],MaxRate),rebackRate) ;\n', '        whitelistUserGettedEthBack[userAddress] = true;\n', '        userAddress.transfer(backEthNumber);\n', '    }\n', '    \n', '\n', '    function addUser(address user,uint amount) public onlyOwner onlyIsRuning {\n', '        if (whitelisted[user] == true) {\n', '            if (userLimitAmount[user] != amount) {\n', '                userLimitAmount[user] = amount;\n', '            }\n', '            return;\n', '        }\n', '        \n', '        whitelisted[user] = true;\n', '        whitelistUsers.push(user);\n', '        userLimitAmount[user] = amount;\n', '        whitelistUserGettedBloc[user] = false;\n', '        whitelistUserGettedEthBack[user] = false;\n', '        // emit LogUserAdded(user);\n', '    }\n', '\n', '    function removeUser(address user) public onlyOwner onlyIsRuning {\n', '        whitelisted[user] = false;\n', '        emit LogUserRemoved(user);\n', '    }\n', '\n', '    function addManyUsers(address[] users,uint[] amounts) public onlyOwner onlyIsRuning {\n', '        require(users.length < 10000,"list too long");\n', '        require(users.length == amounts.length, "users&#39; length != amounts&#39; length");\n', '        \n', '        for (uint index = 0; index < users.length; index++) {\n', '            addUser(users[index],amounts[index]);\n', '        }\n', '    }\n', '\n', '    function() public payable onlyIsRuning {\n', '        require(tx.gasprice <= maxGasPrice,"gas price must not greater than 50GWei");\n', '        buy();\n', '    }\n', '    \n', '    function getWhiteUsers() public view onlyOwner returns(address[] whitelistUsersResult) {\n', '        return whitelistUsers;\n', '    }\n', '\n', '\n', '    function getWhiteUsersFrom(uint index, uint size) public view onlyOwner returns(address[] whitelistUsersResult) {\n', '        address[] memory slice = new address[](size);\n', '        uint idx = 0;\n', '        for (uint i = index; idx < size && i < whitelistUsers.length; i++) {\n', '            slice[idx] = whitelistUsers[i];\n', '            idx++;\n', '        }\n', '        return slice;\n', '    }\n', '}']