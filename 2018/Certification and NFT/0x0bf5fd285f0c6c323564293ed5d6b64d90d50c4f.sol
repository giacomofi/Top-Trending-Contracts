['pragma solidity ^0.4.20;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = 0xfd52FA412913096A6B2E84374baBF84b6FF2baf6;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', 'contract FranklinFarmer is Ownable {\n', '\n', '    // The tokens can never be stolen\n', '    modifier secCheck(address aContract) {\n', '        require(aContract != address(contractCall));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Data\n', '    */\n', '\n', '    _Contract contractCall;  // a reference to the contract\n', '\n', '    //\n', '    uint256 public KNOWLEDGE_TO_GET_1FRANKLIN=86400; //for final version should be seconds in a day\n', '    uint256 PSN=10000;\n', '    uint256 PSNH=5000;\n', '    bool public initialized=false;\n', '    mapping (address => uint256) public hatcheryFranklin;\n', '    mapping (address => uint256) public claimedKnowledge;\n', '    mapping (address => uint256) public lastUse;\n', '    mapping (address => address) public referrals;\n', '    uint256 public marketKnowledge;\n', '\n', '    constructor() public {\n', '        contractCall = _Contract(0x05215FCE25902366480696F38C3093e31DBCE69A);\n', '    }\n', '\n', '    // If you send money directly to the contract it gets treated like a donation\n', '    function() payable public {\n', '    }\n', '\n', '    // External is cheaper to use because it uses the calldata opcode \n', '    // while public needs to copy all the arguments to memory, as described here.\n', '    function useKnowledge(address ref) external {\n', '        require(initialized);\n', '        if(referrals[msg.sender] == 0 && referrals[msg.sender]!=msg.sender){\n', '            referrals[msg.sender] = ref;\n', '        }\n', '        uint256 knowledgeUsed = getMyKnowledge();\n', '        uint256 newFranklin = SafeMath.div(knowledgeUsed,KNOWLEDGE_TO_GET_1FRANKLIN);\n', '        hatcheryFranklin[msg.sender] = SafeMath.add(hatcheryFranklin[msg.sender],newFranklin);\n', '        claimedKnowledge[msg.sender] = 0;\n', '        lastUse[msg.sender] = now;\n', '        \n', '        //send referral\n', '        claimedKnowledge[referrals[msg.sender]] = SafeMath.add(claimedKnowledge[referrals[msg.sender]],SafeMath.div(knowledgeUsed,5));\n', '        \n', '        //boost market to nerf hoarding\n', '        marketKnowledge = SafeMath.add(marketKnowledge,SafeMath.div(knowledgeUsed,10));\n', '    }\n', '\n', '    function sellKnowledge() external {\n', '        require(initialized);\n', '        address customerAddress = msg.sender;\n', '        uint256 hasKnowledge = getMyKnowledge();\n', '        uint256 knowledgeValue = calculateKnowledgeSell(hasKnowledge);\n', '        uint256 fee = devFee(knowledgeValue);\n', '        claimedKnowledge[customerAddress] = 0;\n', '        lastUse[customerAddress] = now;\n', '        marketKnowledge = SafeMath.add(marketKnowledge,hasKnowledge);\n', '        owner.transfer(fee);\n', '        //\n', '        uint256 amountLeft = SafeMath.sub(knowledgeValue,fee);\n', '        //customerAddress.transfer(amountLeft);\n', '        contractCall.buy.value(amountLeft)(customerAddress);\n', '        contractCall.transfer(customerAddress, myTokens()); // 50000000000000000 = 0.05 Rev1 tokens\n', '    }\n', '    function buyKnowledge() external payable{\n', '        require(initialized);\n', '        uint256 knowledgeBought = calculateKnowledgeBuy(msg.value,SafeMath.sub(this.balance,msg.value));\n', '        claimedKnowledge[msg.sender] = SafeMath.add(claimedKnowledge[msg.sender],knowledgeBought);\n', '    }\n', '    //magic trade balancing algorithm\n', '    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public view returns(uint256){\n', '        //(PSN*bs)/(PSNH+((PSN*rs+PSNH*rt)/rt));\n', '        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));\n', '    }\n', '    function calculateKnowledgeSell(uint256 knowledge) public view returns(uint256){\n', '        return calculateTrade(knowledge,marketKnowledge,this.balance);\n', '    }\n', '    function calculateKnowledgeBuy(uint256 eth,uint256 contractBalance) public view returns(uint256){\n', '        return calculateTrade(eth,contractBalance,marketKnowledge);\n', '    }\n', '    function calculateKnowledgeBuySimple(uint256 eth) public view returns(uint256){\n', '        return calculateKnowledgeBuy(eth,this.balance);\n', '    }\n', '    function devFee(uint256 amount) public view returns(uint256){\n', '        return SafeMath.div(SafeMath.mul(amount,50),100); // 50%\n', '    }\n', '    function seedMarket(uint256 knowledge) external payable {\n', '        require(marketKnowledge==0);\n', '        initialized = true;\n', '        marketKnowledge = knowledge;\n', '    }\n', '\n', '    function getBalance() public view returns(uint256){\n', '        return this.balance;\n', '    }\n', '    function getMyFranklin() public view returns(uint256){\n', '        return hatcheryFranklin[msg.sender];\n', '    }\n', '    function getMyKnowledge() public view returns(uint256){\n', '        return SafeMath.add(claimedKnowledge[msg.sender],getKnowledgeSinceLastUse(msg.sender));\n', '    }\n', '    function getKnowledgeSinceLastUse(address adr) public view returns(uint256){\n', '        uint256 secondsPassed = min(KNOWLEDGE_TO_GET_1FRANKLIN,SafeMath.sub(now,lastUse[adr]));\n', '        return SafeMath.mul(secondsPassed,hatcheryFranklin[adr]);\n', '    }\n', '    function min(uint256 a, uint256 b) private pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    // Rev1 related information functions\n', '    function myTokens() public view returns(uint256) {\n', '        return contractCall.myTokens();\n', '    }\n', '\n', '    function myDividends() public view returns(uint256) {\n', '        return contractCall.myDividends(true);\n', '    }\n', '\n', '\n', '     /* A trap door for when someone sends tokens other than the intended ones so the overseers\n', '      can decide where to send them. (credit: Doublr Contract) */\n', '    function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner() secCheck(tokenAddress) returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '//Need to ensure this contract can send tokens to people\n', 'contract ERC20Interface\n', '{\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', '// Interface to actually call contract functions of e.g. REV1\n', 'contract _Contract\n', '{\n', '    function buy(address) public payable returns(uint256);\n', '    function exit() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '    function withdraw() public;\n', '    function transfer(address, uint256) public returns(bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '     /**\n', '      * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '      /**\n', '      * @dev Integer division of two numbers, truncating the quotient.\n', '      */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']