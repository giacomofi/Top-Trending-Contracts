['pragma solidity ^0.4.23;\n', '\n', 'contract ArtStamp { \n', '    \n', '    /************************** */\n', '    /*        STORAGE           */\n', '    /************************** */\n', '    struct Piece {\n', '        string metadata;\n', '        string title;\n', '        bytes32 proof;\n', '        address owner;\n', '        //this currently does nothing, but i believe it will make it much easier if/when we make a future \n', '        //version of this app in which buying and selling pieces with ethereum is allowed\n', '        bool forSale; \n', '        //witnesses have to sign off on any transfer or sale, but have no rights to initiate them\n', '        //typically the witness will be the artist or anyone with rights to the pieces\n', '        //as of right now witnesses can only be added when a piece is created and cannot be altered\n', '        address witness;\n', '    }\n', '\n', '    //structure to keep track of a party to a contract and whether they have signed or not,\n', '    //  and how much ether they have contributed\n', '    struct Signature {\n', '        address signee;\n', '        bool hasSigned;\n', '    }\n', '\n', '    //structure to represent escrow situation and keep track of all parties to contract\n', '    struct Escrow {\n', '        Signature sender;\n', '        Signature recipient;\n', '        Signature witness;\n', '        //block number when escrow is initiated, recorded so that escrow can timeout\n', '        uint blockNum;\n', '    }\n', '    \n', '    //contains all pieces on the market\n', '    mapping (uint => Piece) pieces;\n', '\n', '    //number of pieces\n', '    uint piecesLength;\n', '\n', '    //list of all escrow situations currently in progress\n', '    mapping (uint => Escrow) escrowLedger;\n', '\n', '    //this is used to ensure that no piece can be uploaded twice. \n', '    //dataRecord[(hash of a piece goes here)] will be true if that piece has already been uploaded\n', '    mapping (bytes32 => bool) dataRecord;\n', '\n', '    /************************** */\n', '    /*         LOGIC            */\n', '    /************************** */\n', '\n', '\n', '    //\n', '\n', '\n', '\n', '    /****** PUBLIC READ */\n', '\n', '    //get data relating to escrow\n', '    function getEscrowData(uint i) view public returns (address, bool, address, bool, address, bool, uint){\n', '        return (escrowLedger[i].sender.signee, escrowLedger[i].sender.hasSigned, \n', '        escrowLedger[i].recipient.signee, escrowLedger[i].recipient.hasSigned, \n', '        escrowLedger[i].witness.signee, escrowLedger[i].witness.hasSigned, \n', '        escrowLedger[i].blockNum);\n', '    }\n', '\n', '    //returns total number of pieces\n', '    function getNumPieces() view public returns (uint) {\n', '        return piecesLength;\n', '    }\n', '\n', '    function getOwner(uint id) view public returns (address) {\n', '        return pieces[id].owner;\n', '    }\n', '\n', '    function getPiece(uint id) view public returns (string, string, bytes32, bool, address, address) {\n', '        Piece memory piece = pieces[id];\n', '        return (piece.metadata, piece.title, piece.proof, piece.forSale, piece.owner, piece.witness);\n', '    }\n', '    \n', '    function hashExists(bytes32 proof) view public returns (bool) {\n', '        return dataRecord[proof];\n', '    }\n', '\n', '    function hasOwnership(uint id) view public returns (bool)\n', '    {\n', '        return pieces[id].owner == msg.sender;\n', '    }\n', '\n', '\n', '    //\n', '\n', '\n', '\n', '\n', '    /****** PUBLIC WRITE */\n', '\n', '    function addPieceAndHash(string _metadata, string _title, string data, address witness) public {\n', '        bytes32 _proof = keccak256(abi.encodePacked(data));\n', '        //check for hash collisions to see if the piece has already been uploaded\n', '        addPiece(_metadata,_title,_proof,witness);\n', '    }\n', '    \n', '    function addPiece(string _metadata, string _title, bytes32 _proof, address witness) public {\n', '        bool exists = hashExists(_proof);\n', '        require(!exists, "This piece has already been uploaded");\n', '        dataRecord[_proof] = true;\n', '        pieces[piecesLength] = Piece(_metadata,  _title, _proof, msg.sender, false, witness);\n', '        piecesLength++;\n', '    }\n', '\n', '    //edit both title and metadata with one transaction, will make things easier on the front end\n', '    function editPieceData(uint id, string newTitle, string newMetadata) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don&#39;t own this piece");\n', '        pieces[id].metadata = newMetadata;\n', '        pieces[id].title = newTitle;\n', '    }\n', '\n', '    function editMetadata(uint id, string newMetadata) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don&#39;t own this piece");\n', '        pieces[id].metadata = newMetadata;\n', '    }\n', '\n', '    function editTitle(uint id, string newTitle) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don&#39;t own this piece");\n', '        pieces[id].title = newTitle;\n', '    }\n', '\n', '    function escrowTransfer(uint id, address recipient) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don&#39;t own this piece");\n', '\n', '        //set owner of piece to artstamp smart contract\n', '        pieces[id].owner = address(this);\n', '\n', '        //upadte escrow ledger\n', '        escrowLedger[id] = Escrow({\n', '            sender: Signature(msg.sender,false),\n', '            recipient: Signature(recipient,false),\n', '            witness: Signature(pieces[id].witness,false),\n', '            blockNum: block.number});\n', '    }\n', '    \n', '\n', '    //100000 blocks should be about 20 days which seems reasonable\n', '    //TODO: should make it so contracts owner can change this\n', '    uint timeout = 100000; \n', '\n', '    //timeout where piece will be returned to original owner if people dont sign\n', '    function retrievePieceFromEscrow(uint id) public {\n', '        //reject transaction if piece is not in escrow \n', '        require(pieces[id].owner == address(this));\n', '\n', '        require(block.number > escrowLedger[id].blockNum + timeout);\n', '\n', '        address sender = escrowLedger[id].sender.signee;\n', '\n', '        delete escrowLedger[id];\n', '\n', '        pieces[id].owner = sender;\n', '\n', '    } \n', '\n', '    function signEscrow(uint id) public {\n', '        //reject transaction if piece is not in escrow \n', '        require(pieces[id].owner == address(this));\n', '\n', '        //reject transaction if signee isnt any of the parties involved\n', '        require(msg.sender == escrowLedger[id].sender.signee ||\n', '            msg.sender == escrowLedger[id].recipient.signee || \n', '            msg.sender == escrowLedger[id].witness.signee, \n', '            "You don&#39;t own this piece");\n', '\n', '        bool allHaveSigned = true;\n', '\n', '        if(msg.sender == escrowLedger[id].sender.signee){\n', '            escrowLedger[id].sender.hasSigned = true;\n', '        }  \n', '        allHaveSigned = allHaveSigned && escrowLedger[id].sender.hasSigned;\n', '        \n', '        if(msg.sender == escrowLedger[id].recipient.signee){\n', '            escrowLedger[id].recipient.hasSigned = true;\n', '        }\n', '        allHaveSigned = allHaveSigned && escrowLedger[id].recipient.hasSigned;\n', '        \n', '\n', '        if(msg.sender == escrowLedger[id].witness.signee){\n', '            escrowLedger[id].witness.hasSigned = true;\n', '        }        \n', '        \n', '        allHaveSigned = allHaveSigned && \n', '            (escrowLedger[id].witness.hasSigned || \n', '            escrowLedger[id].witness.signee == 0x0000000000000000000000000000000000000000);\n', '\n', '        //transfer the pieces\n', '        if(allHaveSigned)\n', '        {\n', '            address recipient = escrowLedger[id].recipient.signee;\n', '            delete escrowLedger[id];\n', '            pieces[id].owner = recipient;\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function transferPiece(uint id, address _to) public\n', '    {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don&#39;t own this piece");\n', '\n', '        //check if there is a witness, if so initiate escrow\n', '        if(pieces[id].witness != 0x0000000000000000000000000000000000000000){\n', '            escrowTransfer(id, _to);\n', '            return;\n', '        }\n', '\n', '        pieces[id].owner = _to;\n', '    }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract ArtStamp { \n', '    \n', '    /************************** */\n', '    /*        STORAGE           */\n', '    /************************** */\n', '    struct Piece {\n', '        string metadata;\n', '        string title;\n', '        bytes32 proof;\n', '        address owner;\n', '        //this currently does nothing, but i believe it will make it much easier if/when we make a future \n', '        //version of this app in which buying and selling pieces with ethereum is allowed\n', '        bool forSale; \n', '        //witnesses have to sign off on any transfer or sale, but have no rights to initiate them\n', '        //typically the witness will be the artist or anyone with rights to the pieces\n', '        //as of right now witnesses can only be added when a piece is created and cannot be altered\n', '        address witness;\n', '    }\n', '\n', '    //structure to keep track of a party to a contract and whether they have signed or not,\n', '    //  and how much ether they have contributed\n', '    struct Signature {\n', '        address signee;\n', '        bool hasSigned;\n', '    }\n', '\n', '    //structure to represent escrow situation and keep track of all parties to contract\n', '    struct Escrow {\n', '        Signature sender;\n', '        Signature recipient;\n', '        Signature witness;\n', '        //block number when escrow is initiated, recorded so that escrow can timeout\n', '        uint blockNum;\n', '    }\n', '    \n', '    //contains all pieces on the market\n', '    mapping (uint => Piece) pieces;\n', '\n', '    //number of pieces\n', '    uint piecesLength;\n', '\n', '    //list of all escrow situations currently in progress\n', '    mapping (uint => Escrow) escrowLedger;\n', '\n', '    //this is used to ensure that no piece can be uploaded twice. \n', '    //dataRecord[(hash of a piece goes here)] will be true if that piece has already been uploaded\n', '    mapping (bytes32 => bool) dataRecord;\n', '\n', '    /************************** */\n', '    /*         LOGIC            */\n', '    /************************** */\n', '\n', '\n', '    //\n', '\n', '\n', '\n', '    /****** PUBLIC READ */\n', '\n', '    //get data relating to escrow\n', '    function getEscrowData(uint i) view public returns (address, bool, address, bool, address, bool, uint){\n', '        return (escrowLedger[i].sender.signee, escrowLedger[i].sender.hasSigned, \n', '        escrowLedger[i].recipient.signee, escrowLedger[i].recipient.hasSigned, \n', '        escrowLedger[i].witness.signee, escrowLedger[i].witness.hasSigned, \n', '        escrowLedger[i].blockNum);\n', '    }\n', '\n', '    //returns total number of pieces\n', '    function getNumPieces() view public returns (uint) {\n', '        return piecesLength;\n', '    }\n', '\n', '    function getOwner(uint id) view public returns (address) {\n', '        return pieces[id].owner;\n', '    }\n', '\n', '    function getPiece(uint id) view public returns (string, string, bytes32, bool, address, address) {\n', '        Piece memory piece = pieces[id];\n', '        return (piece.metadata, piece.title, piece.proof, piece.forSale, piece.owner, piece.witness);\n', '    }\n', '    \n', '    function hashExists(bytes32 proof) view public returns (bool) {\n', '        return dataRecord[proof];\n', '    }\n', '\n', '    function hasOwnership(uint id) view public returns (bool)\n', '    {\n', '        return pieces[id].owner == msg.sender;\n', '    }\n', '\n', '\n', '    //\n', '\n', '\n', '\n', '\n', '    /****** PUBLIC WRITE */\n', '\n', '    function addPieceAndHash(string _metadata, string _title, string data, address witness) public {\n', '        bytes32 _proof = keccak256(abi.encodePacked(data));\n', '        //check for hash collisions to see if the piece has already been uploaded\n', '        addPiece(_metadata,_title,_proof,witness);\n', '    }\n', '    \n', '    function addPiece(string _metadata, string _title, bytes32 _proof, address witness) public {\n', '        bool exists = hashExists(_proof);\n', '        require(!exists, "This piece has already been uploaded");\n', '        dataRecord[_proof] = true;\n', '        pieces[piecesLength] = Piece(_metadata,  _title, _proof, msg.sender, false, witness);\n', '        piecesLength++;\n', '    }\n', '\n', '    //edit both title and metadata with one transaction, will make things easier on the front end\n', '    function editPieceData(uint id, string newTitle, string newMetadata) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don\'t own this piece");\n', '        pieces[id].metadata = newMetadata;\n', '        pieces[id].title = newTitle;\n', '    }\n', '\n', '    function editMetadata(uint id, string newMetadata) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don\'t own this piece");\n', '        pieces[id].metadata = newMetadata;\n', '    }\n', '\n', '    function editTitle(uint id, string newTitle) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don\'t own this piece");\n', '        pieces[id].title = newTitle;\n', '    }\n', '\n', '    function escrowTransfer(uint id, address recipient) public {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don\'t own this piece");\n', '\n', '        //set owner of piece to artstamp smart contract\n', '        pieces[id].owner = address(this);\n', '\n', '        //upadte escrow ledger\n', '        escrowLedger[id] = Escrow({\n', '            sender: Signature(msg.sender,false),\n', '            recipient: Signature(recipient,false),\n', '            witness: Signature(pieces[id].witness,false),\n', '            blockNum: block.number});\n', '    }\n', '    \n', '\n', '    //100000 blocks should be about 20 days which seems reasonable\n', '    //TODO: should make it so contracts owner can change this\n', '    uint timeout = 100000; \n', '\n', '    //timeout where piece will be returned to original owner if people dont sign\n', '    function retrievePieceFromEscrow(uint id) public {\n', '        //reject transaction if piece is not in escrow \n', '        require(pieces[id].owner == address(this));\n', '\n', '        require(block.number > escrowLedger[id].blockNum + timeout);\n', '\n', '        address sender = escrowLedger[id].sender.signee;\n', '\n', '        delete escrowLedger[id];\n', '\n', '        pieces[id].owner = sender;\n', '\n', '    } \n', '\n', '    function signEscrow(uint id) public {\n', '        //reject transaction if piece is not in escrow \n', '        require(pieces[id].owner == address(this));\n', '\n', '        //reject transaction if signee isnt any of the parties involved\n', '        require(msg.sender == escrowLedger[id].sender.signee ||\n', '            msg.sender == escrowLedger[id].recipient.signee || \n', '            msg.sender == escrowLedger[id].witness.signee, \n', '            "You don\'t own this piece");\n', '\n', '        bool allHaveSigned = true;\n', '\n', '        if(msg.sender == escrowLedger[id].sender.signee){\n', '            escrowLedger[id].sender.hasSigned = true;\n', '        }  \n', '        allHaveSigned = allHaveSigned && escrowLedger[id].sender.hasSigned;\n', '        \n', '        if(msg.sender == escrowLedger[id].recipient.signee){\n', '            escrowLedger[id].recipient.hasSigned = true;\n', '        }\n', '        allHaveSigned = allHaveSigned && escrowLedger[id].recipient.hasSigned;\n', '        \n', '\n', '        if(msg.sender == escrowLedger[id].witness.signee){\n', '            escrowLedger[id].witness.hasSigned = true;\n', '        }        \n', '        \n', '        allHaveSigned = allHaveSigned && \n', '            (escrowLedger[id].witness.hasSigned || \n', '            escrowLedger[id].witness.signee == 0x0000000000000000000000000000000000000000);\n', '\n', '        //transfer the pieces\n', '        if(allHaveSigned)\n', '        {\n', '            address recipient = escrowLedger[id].recipient.signee;\n', '            delete escrowLedger[id];\n', '            pieces[id].owner = recipient;\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function transferPiece(uint id, address _to) public\n', '    {\n', '        bool ownership = hasOwnership(id);\n', '        require(ownership, "You don\'t own this piece");\n', '\n', '        //check if there is a witness, if so initiate escrow\n', '        if(pieces[id].witness != 0x0000000000000000000000000000000000000000){\n', '            escrowTransfer(id, _to);\n', '            return;\n', '        }\n', '\n', '        pieces[id].owner = _to;\n', '    }\n', '\n', '\n', '\n', '}']
