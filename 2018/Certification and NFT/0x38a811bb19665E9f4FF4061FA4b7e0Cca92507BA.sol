['pragma solidity ^0.4.24;\n', '\n', '// Safe Math\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) return 0;\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '// Ownable\n', '\n', '\n', 'contract Ownable {\n', '  address public _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  constructor() public {\n', '    _owner = msg.sender;\n', '  }\n', '\n', '\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == _owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// TRAVEL Token\n', '\n', 'contract TRAVELToken is ERC20Interface, Ownable {\n', '  using SafeMath for uint256;\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint256 private _totalSupply;\n', '    uint256 private _rate;\n', '    uint private _minPayment;\n', '    uint private airdropAmount;\n', '    uint256 private _soldTokens;\n', '    uint256[4] public _startDates;\n', '    uint256[4] public _endDates;\n', '    uint256[4] public _bonuses;\n', '   \n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '       symbol = "TRAVEL";\n', '       name = "TRAVEL Token";\n', '       decimals = 18;\n', '       _minPayment = 0.01 ether; //Minimal amount allowed to buy tokens\n', '       _soldTokens = 0; //Total number of sold tokens (excluding bonus tokens)\n', '\n', '\n', '      //Beginning and ending dates for ICO stages    \n', '        _startDates = [1539550800, 1543615200, 1546293600, 1548972000]; \n', '        _endDates = [1543528800, 1546207200, 1548885600, 1550181600];\n', '        _bonuses = [50, 30, 20, 10];\n', '\n', '       _totalSupply = 47000000 * (10 ** uint256(decimals)); \n', '       airdropAmount = 2000000 * (10 ** uint256(decimals));\n', '\n', '       _balances[_owner] = airdropAmount;\n', '       _balances[address(this)] = (_totalSupply-airdropAmount);\n', '\n', '       _rate=225000000000; //exchange rate. Will be update daily according to ETH/USD rate at coinmarketcap.com\n', '       _allowed[address(this)][_owner]=_totalSupply;\n', '       emit Transfer(address(0), _owner, airdropAmount);\n', '    }\n', '\n', '    \n', '    // Method for batch distribution of airdrop tokens.\n', '    function sendBatchCS(address[] _recipients, uint[] _values) external onlyOwner returns (bool) {\n', '        require(_recipients.length == _values.length);\n', '        uint senderBalance = _balances[msg.sender];\n', '        for (uint i = 0; i < _values.length; i++) {\n', '            uint value = _values[i];\n', '            address to = _recipients[i];\n', '            require(senderBalance >= value);\n', '            senderBalance = senderBalance - value;\n', '            _balances[to] += value;\n', '            emit Transfer(msg.sender, to, value);\n', '        }\n', '        _balances[msg.sender] = senderBalance;\n', '        return true;\n', '    }\n', '    \n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return _allowed[owner][spender];\n', '  }\n', '\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    require(value <= _balances[msg.sender]);\n', '    require(to != address(0));\n', '    _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    require(value <= _balances[from]);\n', '    require(value <= _allowed[from][msg.sender]);\n', '    require(to != address(0));\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '  \n', '\n', '  function sendTokens(address from, address to, uint256 value) internal returns (bool) {\n', '    require(value <= _balances[from]);\n', '    require(to != address(0));\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '\n', '// Function to burn undistributed amount of tokens after ICO is finished\n', '    function burn() external onlyOwner {\n', '      require(now >_endDates[3]);\n', '      _burn(address(this),_balances[address(this)]);\n', '    }\n', '\n', '  function _burn(address account, uint256 amount) internal {\n', '    require(account != 0);\n', '    require(amount <= _balances[account]);\n', '\n', '    _totalSupply = _totalSupply.sub(amount);\n', '    _balances[account] = _balances[account].sub(amount);\n', '\n', '    emit Transfer(account, 0x0000000000000000000000000000000000000000, amount);\n', '  }\n', '\n', '\n', '  function _burnFrom(address account, uint256 amount) internal {\n', '    require(amount <= _allowed[account][msg.sender]);\n', '    require(amount <=_balances[account]);\n', '    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n', '      amount);\n', '    _burn(account, amount);\n', '  }\n', '\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function getRate() public view returns(uint256) {\n', '    return _rate;\n', '  }\n', '\n', '  function _setRate(uint newrate) external onlyOwner {\n', '    require (newrate > 0);\n', '    _rate = newrate;\n', '  }\n', '\n', '  function soldTokens() public view returns (uint256) {\n', '    return _soldTokens;\n', '  }\n', '\n', '  // Method to check current ICO stage\n', '\n', '  function currentStage() public view returns (uint256) {\n', '    require(now >=_startDates[0] && now <= _endDates[3]);\n', '    if (now >= _startDates[0] && now <= _endDates[0]) return 0;\n', '    if (now >= _startDates[1] && now <= _endDates[1]) return 1;\n', '    if (now >= _startDates[2] && now <= _endDates[2]) return 2;\n', '    if (now >= _startDates[3] && now <= _endDates[3]) return 3;\n', '  }\n', '\n', '// Show current bonus tokens percentage\n', '\n', ' function currentBonus() public view returns (uint256) {\n', '    require(now >=_startDates[0] && now <= _endDates[3]);\n', '    return _bonuses[currentStage()];\n', '  }\n', '\n', '  function _setLastDate(uint _date) external onlyOwner returns (bool){\n', '    require (_date > now);\n', '    require (_date > _startDates[3]);\n', '    require (_date < 2147483647);\n', '    _endDates[3] = _date;\n', '    return true;\n', '  }\n', '\n', '  // Returns date of ICO finish\n', '  function _getLastDate() public view returns (uint256) {\n', '    return uint256(_endDates[3]);\n', '  }\n', '\n', '  function _getTokenAmount(uint256 weiAmount) internal view returns (uint256 tokens, uint256 bonus) {\n', '    tokens = uint256(weiAmount * _rate / (10**9));\n', '    bonus = uint256(tokens * _bonuses[currentStage()]/100);\n', '    return (tokens, bonus);\n', '  }\n', '\n', '  function _forwardFunds(uint256 amount) external onlyOwner {\n', '    require (address(this).balance > 0);\n', '    require (amount <= address(this).balance);\n', '    require (amount > 0);\n', '    _owner.transfer(amount);\n', '  }\n', '\n', '  function buyTokens(address beneficiary) public payable {\n', '    uint256 tokens;\n', '    uint256 bonus;\n', '    uint256 weiAmount = msg.value;\n', '\n', '    _preValidatePurchase(beneficiary, weiAmount);\n', '\n', '    (tokens, bonus) = _getTokenAmount(weiAmount);\n', '   \n', '    uint256 total = tokens.add(bonus);\n', '\n', '    _soldTokens = _soldTokens.add(tokens);\n', '    \n', '    _processPurchase(beneficiary, total);\n', '\n', '    emit TokensPurchased(msg.sender, beneficiary,  weiAmount, total);\n', '\n', '  }\n', '\n', '  function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\n', '    require (now >= _startDates[0]);\n', '    require (now <= _endDates[3]);\n', '    require(beneficiary != address(0));\n', '    require(weiAmount >= _minPayment);\n', '    require (_balances[address(this)] > 0);\n', '  }\n', '\n', '\n', '  function _preICOSale(address beneficiary, uint256 tokenAmount) internal {\n', '    require(_soldTokens < 1000000 * (10 ** uint256(decimals)));\n', '    require(_soldTokens.add(tokenAmount) <= 1000000 * (10 ** uint256(decimals)));\n', '    sendTokens(address(this), beneficiary, tokenAmount);\n', '  }\n', '\n', '  function _ICOSale(address beneficiary, uint256 tokenAmount) internal {\n', '    require(_soldTokens < 30000000 * (10 ** uint256(decimals)));\n', '    require(_soldTokens.add(tokenAmount) <= 30000000 * (10 ** uint256(decimals)));\n', '    sendTokens(address(this), beneficiary, tokenAmount);\n', '  }\n', '\n', '\n', '  function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n', '    require(_balances[address(this)]>=tokenAmount);\n', '    if (currentStage() == 0) {\n', '      _preICOSale(beneficiary, tokenAmount);\n', '    } else {\n', '      _ICOSale(beneficiary, tokenAmount);\n', '\n', '    }\n', '  }\n', '}']