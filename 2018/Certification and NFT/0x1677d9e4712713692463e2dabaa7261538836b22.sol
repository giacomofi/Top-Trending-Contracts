['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev SafeMath library implemented for uint32\n', ' */\n', 'library SafeMath32 {\n', '\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath16\n', ' * @dev SafeMath library implemented for uint16\n', ' */\n', 'library SafeMath16 {\n', '\n', '  function mul(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint16 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint16 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint16 a, uint16 b) internal pure returns (uint16) {\n', '    uint16 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '   * @dev Guarantees msg.sender is owner of the given token\n', '   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '   */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '   * @param _tokenId uint256 ID of the token to validate\n', '   */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param _owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the owner of the specified token ID\n', '   * @param _tokenId uint256 ID of the token to query the owner of\n', '   * @return owner address currently marked as the owner of the given token ID\n', '   */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the specified token exists\n', '   * @param _tokenId uint256 ID of the token to query the existance of\n', '   * @return whether the token exists\n', '   */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Approves another address to transfer the given token ID\n', '   * @dev The zero address indicates there is no approved address.\n', '   * @dev There can only be one approved address per token at a given time.\n', '   * @dev Can only be called by the token owner or an approved operator.\n', '   * @param _to address to be approved for the given token ID\n', '   * @param _tokenId uint256 ID of the token to be approved\n', '   */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets or unsets the approval of a given operator\n', '   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '   * @param _to operator address to set the approval\n', '   * @param _approved representing the status of the approval to be set\n', '   */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    emit ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given token ID to another address\n', '   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    // solium-disable-next-line arg-overflow\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes data to send along with a safe transfer check\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    transferFrom(_from, _to, _tokenId);\n', '    // solium-disable-next-line arg-overflow\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to The address that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to clear current approval of a given token ID\n', '   * @dev Reverts if the given address is not indeed the owner of the token\n', '   * @param _owner owner of the token\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      emit Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to invoke `onERC721Received` on a target address\n', '   * @dev The call is not executed if the target address is not a contract\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _to target address that will receive the tokens\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes optional data to send along with the call\n', '   * @return whether the call correctly returned the expected magic value\n', '   */\n', '  function checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    returns (bool)\n', '  {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract PausableToken is ERC721BasicToken, Pausable {\n', '\tfunction approve(address _to, uint256 _tokenId) public whenNotPaused {\n', '\t\tsuper.approve(_to, _tokenId);\n', '\t}\n', '\n', '\tfunction setApprovalForAll(address _operator, bool _approved) public whenNotPaused {\n', '\t\tsuper.setApprovalForAll(_operator, _approved);\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '\t\tsuper.transferFrom(_from, _to, _tokenId);\n', '\t}\n', '\n', '\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public whenNotPaused {\n', '\t\tsuper.safeTransferFrom(_from, _to, _tokenId);\n', '\t}\n', '\t\n', '\tfunction safeTransferFrom(\n', '\t    address _from,\n', '\t    address _to,\n', '\t    uint256 _tokenId,\n', '\t    bytes _data\n', '\t  )\n', '\t    public whenNotPaused {\n', '\t\tsuper.safeTransferFrom(_from, _to, _tokenId, _data);\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @title WorldCupFactory\n', ' * @author Cocos\n', ' * @dev Declare token struct, and generated all toekn\n', ' */\n', 'contract WorldCupFactory is Claimable, PausableToken {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint public initPrice;\n', '\n', '\t//string[] public initTokenData = [];\n', '\n', '\t// @dev Declare token struct    \n', '\tstruct Country {\n', '\t\t// token name\n', '\t\tstring name;\n', '\t\t\n', '\t\t// token current price\n', '\t\tuint price;\n', '\t}\n', '\n', '\tCountry[] public countries;\n', '\n', '    /// @dev A mapping from countryIDs to an address that has been approved to call\n', '    ///  transferFrom(). Each Country can only have one approved address for transfer\n', '    ///  at any time. A zero value means no approval is outstanding.\n', '\t//mapping (uint => address) internal tokenOwner;\n', '\n', '\t// @dev A mapping from owner address to count of tokens that address owns.\n', '    //  Used internally inside balanceOf() to resolve ownership count.\n', '\t//mapping (address => uint) internal ownedTokensCount;\n', '\n', '\t\n', '\t/// @dev The WorldCupFactory constructor sets the initialized price of One token\n', '\tfunction WorldCupFactory(uint _initPrice) public {\n', '\t\tinitPrice = _initPrice;\n', '\t\tpaused    = true;\n', '\t}\n', '\n', '\tfunction createToken() external onlyOwner {\n', '\t\t// Create tokens\n', '\t\tuint length = countries.length;\n', '\t\tfor (uint i = length; i < length + 100; i++) {\n', '\t\t\tif (i >= 836 ) {\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\n', '\t\t\tif (i < 101) {\n', '\t\t\t\t_createToken("Country");\n', '\t\t\t}else {\n', '\t\t\t\t_createToken("Player");\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\t/// @dev Create token with _name, internally.\n', '\tfunction _createToken(string _name) internal {\n', '\t\tuint id = countries.push( Country(_name, initPrice) ) - 1;\n', '\t\ttokenOwner[id] = msg.sender;\n', '\t\townedTokensCount[msg.sender] = ownedTokensCount[msg.sender].add(1);\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title Control and manage\n', ' * @author Cocos\n', ' * @dev Use for owner setting operating income address, PayerInterface.\n', ' * \n', ' */\n', 'contract WorldCupControl is WorldCupFactory {\n', '\t/// @dev Operating income address.\n', '\taddress public cooAddress;\n', '\n', '\n', '    function WorldCupControl() public {\n', '        cooAddress = msg.sender;\n', '    }\n', '\n', '\t/// @dev Assigns a new address to act as the COO.\n', '    /// @param _newCOO The address of the new COO.\n', '    function setCOO(address _newCOO) external onlyOwner {\n', '        require(_newCOO != address(0));\n', '        \n', '        cooAddress = _newCOO;\n', '    }\n', '\n', '    /// @dev Allows the CFO to capture the balance available to the contract.\n', '    function withdrawBalance() external onlyOwner {\n', '        uint balance = address(this).balance;\n', '        \n', '        cooAddress.send(balance);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Define \n', ' * @author Cocos\n', ' * @dev Provide some function for web front-end that can be use for convenience.\n', ' * \n', ' */\n', 'contract WorldCupHelper is WorldCupControl {\n', '\n', '\t/// @dev Return tokenid array\n', '\tfunction getTokenByOwner(address _owner) external view returns(uint[]) {\n', '\t    uint[] memory result = new uint[](ownedTokensCount[_owner]);\n', '\t    uint counter = 0;\n', '\n', '\t    for (uint i = 0; i < countries.length; i++) {\n', '\t\t\tif (tokenOwner[i] == _owner) {\n', '\t\t\t\tresult[counter] = i;\n', '\t\t\t\tcounter++;\n', '\t\t\t}\n', '\t    }\n', '\t\treturn result;\n', '  \t}\n', '\n', '  \t/// @dev Return tokens price list. It gets the same order as ids.\n', '  \tfunction getTokenPriceListByIds(uint[] _ids) external view returns(uint[]) {\n', '  \t\tuint[] memory result = new uint[](_ids.length);\n', '  \t\tuint counter = 0;\n', '\n', '  \t\tfor (uint i = 0; i < _ids.length; i++) {\n', '  \t\t\tCountry storage token = countries[_ids[i]];\n', '  \t\t\tresult[counter] = token.price;\n', '  \t\t\tcounter++;\n', '  \t\t}\n', '  \t\treturn result;\n', '  \t}\n', '\n', '}\n', '\n', '/// @dev PayerInterface must implement ERC20 standard token.\n', 'contract PayerInterface {\n', '\tfunction totalSupply() public view returns (uint256);\n', '\tfunction balanceOf(address who) public view returns (uint256);\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '\n', '\tfunction allowance(address owner, address spender) public view returns (uint256);\n', '  \tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  \tfunction approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * @title AuctionPaused\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract AuctionPaused is Ownable {\n', '  event AuctionPause();\n', '  event AuctionUnpause();\n', '\n', '  bool public auctionPaused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not auctionPaused.\n', '   */\n', '  modifier whenNotAuctionPaused() {\n', '    require(!auctionPaused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is auctionPaused.\n', '   */\n', '  modifier whenAuctionPaused() {\n', '    require(auctionPaused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function auctionPause() onlyOwner whenNotAuctionPaused public {\n', '    auctionPaused = true;\n', '    emit AuctionPause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function auctionUnpause() onlyOwner whenAuctionPaused public {\n', '    auctionPaused = false;\n', '    emit AuctionUnpause();\n', '  }\n', '}\n', '\n', 'contract WorldCupAuction is WorldCupHelper, AuctionPaused {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\tevent PurchaseToken(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _tokenPrice, uint256 _timestamp, uint256 _purchaseCounter);\n', '\n', '\t/// @dev ERC721 Token upper limit of price, cap.\n', "\t///  Cap is the upper limit of price. It represented eth's cap if isEthPayable is true \n", "\t///  or erc20 token's cap if isEthPayable is false.\n", "\t///  Note!!! Using 'wei' for eth's cap units. Using minimum units for erc20 token cap units.\n", '\tuint public cap;\n', '\n', '    uint public finalCap;\n', '\n', '\t/// @dev 1 equal to 0.001\n', "\t/// erc721 token's price increasing. Each purchase the price increases 5%\n", '\tuint public increasePermillage = 50;\n', '\n', '\t/// @dev 1 equal to 0.001\n', '\t/// Exchange fee 2.3%\n', '\tuint public sysFeePermillage = 23;\n', '\n', '\n', '\t/// @dev Contract operating income address.\n', '\tPayerInterface public payerContract = PayerInterface(address(0));\n', '\n', '    /// @dev If isEthPayable is true, users can only use eth to buy current erc721 token.\n', "    ///  If isEthPayable is false, that mean's users can only use PayerInterface's token to buy current erc721 token.\n", '    bool public isEthPayable;\n', '\n', '    uint public purchaseCounter = 0;\n', '\n', '    /// @dev Constructor\n', '    /// @param _initPrice erc721 token initialized price.\n', '    /// @param _cap Upper limit of increase price.\n', '    /// @param _isEthPayable \n', '    /// @param _address PayerInterface address, it must be a ERC20 contract.\n', '    function WorldCupAuction(uint _initPrice, uint _cap, bool _isEthPayable, address _address) public WorldCupFactory(_initPrice) {\n', '        require( (_isEthPayable == false && _address != address(0)) || _isEthPayable == true && _address == address(0) );\n', '\n', '        cap           = _cap;\n', '        finalCap      = _cap.add(_cap.mul(25).div(1000));\n', '        isEthPayable  = _isEthPayable;\n', '        payerContract = PayerInterface(_address);\n', '    }\n', '\n', '    function purchaseWithEth(uint _tokenId) external payable whenNotAuctionPaused {\n', '    \trequire(isEthPayable == true);\n', '    \trequire(msg.sender != tokenOwner[_tokenId]);\n', '\n', '    \t/// @dev If `_tokenId` is out of the range of the array,\n', '        /// this will throw automatically and revert all changes.\n', '    \tCountry storage token = countries[_tokenId];\n', '    \tuint nextPrice = _computeNextPrice(token);\n', '\n', '    \trequire(msg.value >= nextPrice);\n', '\n', '    \tuint fee = nextPrice.mul(sysFeePermillage).div(1000);\n', '    \tuint oldOwnerRefund = nextPrice.sub(fee);\n', '\n', '    \taddress oldOwner = ownerOf(_tokenId);\n', '\n', '    \t// Refund eth to the person who owned this erc721 token.\n', '    \toldOwner.transfer(oldOwnerRefund);\n', '\n', '    \t// Transfer fee to the cooAddress.\n', '    \tcooAddress.transfer(fee);\n', '\n', '    \t// Transfer eth left go back to the sender.\n', '    \tif ( msg.value.sub(oldOwnerRefund).sub(fee) > 0.0001 ether ) {\n', '    \t\tmsg.sender.transfer( msg.value.sub(oldOwnerRefund).sub(fee) );\n', '    \t}\n', '\n', '    \t//Update token price\n', '    \ttoken.price = nextPrice;\n', '\n', '    \t_transfer(oldOwner, msg.sender, _tokenId);\n', '\n', '    \temit PurchaseToken(oldOwner, msg.sender, _tokenId, nextPrice, now, purchaseCounter);\n', '        purchaseCounter = purchaseCounter.add(1);\n', '    }\n', '\n', '    function purchaseWithToken(uint _tokenId) external whenNotAuctionPaused {\n', '    \trequire(isEthPayable == false);\n', '    \trequire(payerContract != address(0));\n', '    \trequire(msg.sender != tokenOwner[_tokenId]);\n', '\n', '        Country storage token = countries[_tokenId];\n', '        uint nextPrice = _computeNextPrice(token);\n', '\n', '        // We need to know how much erc20 token allows our contract to transfer.\n', '        uint256 aValue = payerContract.allowance(msg.sender, address(this));\n', '        require(aValue >= nextPrice);\n', '\n', '        uint fee = nextPrice.mul(sysFeePermillage).div(1000);\n', '        uint oldOwnerRefund = nextPrice.sub(fee);\n', '\n', '        address oldOwner = ownerOf(_tokenId);\n', '\n', '        // Refund erc20 token to the person who owned this erc721 token.\n', '        require(payerContract.transferFrom(msg.sender, oldOwner, oldOwnerRefund));\n', '\n', '        // Transfer fee to the cooAddress.\n', '        require(payerContract.transferFrom(msg.sender, cooAddress, fee));\n', '\n', '        // Update token price\n', '        token.price = nextPrice;\n', '\n', '        _transfer(oldOwner, msg.sender, _tokenId);\n', '\n', '        emit PurchaseToken(oldOwner, msg.sender, _tokenId, nextPrice, now, purchaseCounter);\n', '        purchaseCounter = purchaseCounter.add(1);\n', '\n', '    }\n', '\n', '    function getTokenNextPrice(uint _tokenId) public view returns(uint) {\n', '        Country storage token = countries[_tokenId];\n', '        uint nextPrice = _computeNextPrice(token);\n', '        return nextPrice;\n', '    }\n', '\n', '    function _computeNextPrice(Country storage token) private view returns(uint) {\n', '        if (token.price >= cap) {\n', '            return finalCap;\n', '        }\n', '\n', '    \tuint price = token.price;\n', '    \tuint addPrice = price.mul(increasePermillage).div(1000);\n', '\n', '\t\tuint nextPrice = price.add(addPrice);\n', '\t\tif (nextPrice > cap) {\n', '\t\t\tnextPrice = cap;\n', '\t\t}\n', '\n', '    \treturn nextPrice;\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n', '        // Clear approval.\n', '        if (tokenApprovals[_tokenId] != address(0)) {\n', '            tokenApprovals[_tokenId] = address(0);\n', '            emit Approval(_from, address(0), _tokenId);\n', '        }\n', '\n', '        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '        tokenOwner[_tokenId] = _to;\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract CryptoWCRC is WorldCupAuction {\n', '\n', '\tstring public constant name = "CryptoWCRC";\n', '    \n', '    string public constant symbol = "WCRC";\n', '\n', '    function CryptoWCRC(uint _initPrice, uint _cap, bool _isEthPayable, address _address) public WorldCupAuction(_initPrice, _cap, _isEthPayable, _address) {\n', '\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '    \treturn countries.length;\n', '    }\n', '\n', '}']