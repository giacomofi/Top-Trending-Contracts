['pragma solidity ^0.4.19;\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', 'interface ERC721 /* is ERC165 */ {\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    function approve(address _approved, uint256 _tokenId) external;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your assets.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x780e9d63\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /// @notice Enumerate valid NFTs\n', '  /// @dev Throws if `_index` >= `totalSupply()`.\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for the `_index`th NFT,\n', '  ///  (sort order not specified)\n', '  function tokenByIndex(uint256 _index) external view returns (uint256);\n', '\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address \n', '    /// @param _tokenId The NFT identifier which is being transferred\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', 'contract Ownable {\n', '    address private owner;\n', '\n', '    event LogOwnerChange(address _owner);\n', '\n', '    // Modify method to only allow calls from the owner of the contract.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Replace the contract owner with a new owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address to replace the current owner with.\n', '     */\n', '    function replaceOwner(address _owner) external onlyOwner {\n', '        owner = _owner;\n', '\n', '        LogOwnerChange(_owner);\n', '    }\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    // Mapping of a contract address to its position in the list of active\n', '    // contracts. This allows an O(1) look-up of the contract address compared\n', '    // to a linear search within an array.\n', '    mapping(address => uint256) private contractIndices;\n', '\n', '    // The list of contracts that are allowed to call the contract-restricted\n', '    // methods of contracts that extend this `Controllable` contract.\n', '    address[] private contracts;\n', '\n', '    /**\n', '     * Modify method to only allow calls from active contract addresses.\n', '     *\n', '     * Notes\n', '     * -----\n', '     * The zero address is considered an inactive address, as it is impossible\n', '     * for users to send a call from that address.\n', '     */\n', '    modifier onlyActiveContracts() {\n', '        require(contractIndices[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    function Controllable() public Ownable() {\n', '        // The zeroth index of the list of active contracts is occupied by the\n', '        // zero address to ensure that an index of zero can be used to indicate\n', '        // that the contract address is inactive.\n', '        contracts.push(address(0));\n', '    }\n', '\n', '    /**\n', '     * Add a contract address to the list of active contracts.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The contract address to add to the list of active contracts.\n', '     */\n', '    function activateContract(address _address) external onlyOwner {\n', '        require(contractIndices[_address] == 0);\n', '\n', '        contracts.push(_address);\n', '\n', '        // The index of the newly added contract is equal to the length of the\n', '        // array of active contracts minus one, as Solidity is a zero-based\n', '        // language.\n', '        contractIndices[_address] = contracts.length - 1;\n', '    }\n', '\n', '    /**\n', '     * Remove a contract address from the list of active contracts.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The contract address to remove from the list of active contracts.\n', '     */\n', '    function deactivateContract(address _address) external onlyOwner {\n', '        require(contractIndices[_address] != 0);\n', '\n', '        // Get the last contract in the array of active contracts. This address\n', '        // will be used to overwrite the address that will be removed.\n', '        address lastActiveContract = contracts[contracts.length - 1];\n', '\n', '        // Overwrite the address that is to be removed with the value of the\n', '        // last contract in the list. There is a possibility that these are the\n', '        // same values, in which case nothing happens.\n', '        contracts[contractIndices[_address]] = lastActiveContract;\n', '\n', '        // Reduce the contracts array size by one, as the last contract address\n', '        // will have been successfully moved.\n', '        contracts.length--;\n', '\n', '        // Set the address mapping to zero, effectively rendering the contract\n', '        // banned from calling this contract.\n', '        contractIndices[_address] = 0;\n', '    }\n', '\n', '    /**\n', '     * Get the list of active contracts for this contract.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address[]\n', '     *     The list of contract addresses that are allowed to call the\n', '     *     contract-restricted methods of this contract.\n', '     */\n', '    function getActiveContracts() external view returns (address[]) {\n', '        return contracts;\n', '    }\n', '}\n', '\n', 'library Tools {\n', '    /**\n', '     * Concatenate two strings.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * stringLeft : string\n', '     *     A string to concatenate with another string. This is the left part.\n', '     * stringRight : string\n', '     *     A string to concatenate with another string. This is the right part.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The resulting string from concatenating the two given strings.\n', '     */\n', '    function concatenate(\n', '        string stringLeft,\n', '        string stringRight\n', '    )\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', '        // Get byte representations of both strings to allow for one-by-one\n', '        // character iteration.\n', '        bytes memory stringLeftBytes = bytes(stringLeft);\n', '        bytes memory stringRightBytes = bytes(stringRight);\n', '\n', '        // Initialize new string holder with the appropriate number of bytes to\n', '        // hold the concatenated string.\n', '        string memory resultString = new string(\n', '            stringLeftBytes.length + stringRightBytes.length\n', '        );\n', '\n', '        // Get a bytes representation of the result string to allow for direct\n', '        // modification.\n', '        bytes memory resultBytes = bytes(resultString);\n', '\n', '        // Initialize a number to hold the current index of the result string\n', '        // to assign a character to.\n', '        uint k = 0;\n', '\n', '        // First loop over the left string, and afterwards over the right\n', '        // string to assign each character to its proper location in the new\n', '        // string.\n', '        for (uint i = 0; i < stringLeftBytes.length; i++) {\n', '            resultBytes[k++] = stringLeftBytes[i];\n', '        }\n', '\n', '        for (i = 0; i < stringRightBytes.length; i++) {\n', '            resultBytes[k++] = stringRightBytes[i];\n', '        }\n', '\n', '        return string(resultBytes);\n', '    }\n', '\n', '    /**\n', '     * Convert 256-bit unsigned integer into a 32 bytes structure.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * value : uint256\n', '     *     The unsigned integer to convert to bytes32.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bytes32\n', '     *     The bytes32 representation of the given unsigned integer.\n', '     */\n', '    function uint256ToBytes32(uint256 value) internal pure returns (bytes32) {\n', '        if (value == 0) {\n', '            return &#39;0&#39;;\n', '        }\n', '\n', '        bytes32 resultBytes;\n', '\n', '        while (value > 0) {\n', '            resultBytes = bytes32(uint(resultBytes) / (2 ** 8));\n', '            resultBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\n', '            value /= 10;\n', '        }\n', '\n', '        return resultBytes;\n', '    }\n', '\n', '    /**\n', '     * Convert bytes32 data structure into a string.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * data : bytes32\n', '     *     The bytes to convert to a string.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The string representation of given bytes.\n', '     *\n', '     * Notes\n', '     * -----\n', '     * This method is right-padded with zero bytes.\n', '     */\n', '    function bytes32ToString(bytes32 data) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '\n', '        for (uint i = 0; i < 32; i++) {\n', '            bytes1 char = bytes1(bytes32(uint256(data) * 2 ** (8 * i)));\n', '\n', '            if (char != 0) {\n', '                bytesString[i] = char;\n', '            }\n', '        }\n', '\n', '        return string(bytesString);\n', '    }\n', '}\n', '\n', '/**\n', ' * Partial interface of former ownership contract.\n', ' *\n', ' * This interface is used to perform the migration of tokens, from the former\n', ' * ownership contract to the current version. The inclusion of the entire\n', ' * contract is too bulky, hence the partial interface.\n', ' */\n', 'interface PartialOwnership {\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * Ethergotchi Ownership Contract\n', ' *\n', ' * This contract governs the "non-fungible tokens" (NFTs) that represent the\n', ' * various Ethergotchi owned by players within Aethia.\n', ' *\n', ' * The NFTs are implemented according to the standard described in EIP-721 as\n', ' * it was on March 19th, 2018.\n', ' *\n', ' * In addition to the mentioned specification, a method was added to create new\n', ' * tokens: `add(uint256 _tokenId, address _owner)`. This method can *only* be\n', ' * called by activated Aethia game contracts.\n', ' *\n', ' * For more information on Aethia and/or Ethergotchi, visit the following\n', ' * website: https://aethia.co\n', ' */\n', 'contract EthergotchiOwnershipV2 is\n', '    Controllable,\n', '    ERC721,\n', '    ERC721Enumerable,\n', '    ERC721Metadata\n', '{\n', '    // Direct mapping to keep track of token owners.\n', '    mapping(uint256 => address) private ownerByTokenId;\n', '\n', '    // Mapping that keeps track of all tokens owned by a specific address. This\n', '    // allows for iteration by owner, and is implemented to be able to comply\n', '    // with the enumeration methods described in the ERC721Enumerable interface.\n', '    mapping(address => uint256[]) private tokenIdsByOwner;\n', '\n', '    // Mapping that keeps track of a token"s position in an owner"s list of\n', '    // tokens. This allows for constant time look-ups within the list, instead\n', '    // of needing to iterate the list of tokens.\n', '    mapping(uint256 => uint256) private ownerTokenIndexByTokenId;\n', '\n', '    // Mapping that keeps track of addresses that are approved to make a\n', '    // transfer of a token. Approval can only be given to a single address, but\n', '    // can be overridden for modification or retraction purposes.\n', '    mapping(uint256 => address) private approvedTransfers;\n', '\n', '    // Mapping that keeps track of operators that are allowed to perform\n', '    // actions on behalf of another address. An address is allowed to set more\n', '    // than one operator. Operators can perform all actions on behalf on an\n', '    // address, *except* for setting a different operator.\n', '    mapping(address => mapping(address => bool)) private operators;\n', '\n', '    // Total number of tokens governed by this contract. This allows for the\n', '    // enumeration of all tokens, provided that tokens are created with their\n', '    // identifiers being numbers, incremented by one.\n', '    uint256 private totalTokens;\n', '\n', '    // The ERC-165 identifier of the ERC-165 interface. This contract\n', '    // implements the `supportsInterface` method to check whether other types\n', '    // of standard interfaces are supported.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(\n', '        keccak256("supportsInterface(bytes4)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 interface. This contract\n', '    // implements all methods of the ERC-721 Enumerable interface, and uses\n', '    // this identifier to supply the correct answer to a call to\n', '    // `supportsInterface`.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(\n', '        keccak256("balanceOf(address)") ^\n', '        keccak256("ownerOf(uint256)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256,bytes)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256)") ^\n', '        keccak256("transferFrom(address,address,uint256)") ^\n', '        keccak256("approve(address,uint256)") ^\n', '        keccak256("setApprovalForAll(address,bool)") ^\n', '        keccak256("getApproved(uint256)") ^\n', '        keccak256("isApprovedForAll(address,address)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Enumerable interface. This\n', '    // contract implements all methods of the ERC-721 Enumerable interface, and\n', '    // uses this identifier to supply the correct answer to a call to\n', '    // `supportsInterface`.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4(\n', '        keccak256("totalSupply()") ^\n', '        keccak256("tokenByIndex(uint256)") ^\n', '        keccak256("tokenOfOwnerByIndex(address,uint256)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Metadata interface. This contract\n', '    // implements all methods of the ERC-721 Metadata interface, and uses the\n', '    // identifier to supply the correct answer to a `supportsInterface` call.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4(\n', '        keccak256("name()") ^\n', '        keccak256("symbol()") ^\n', '        keccak256("tokenURI(uint256)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Token Receiver interface. This\n', '    // is not implemented by this contract, but is used to identify the\n', '    // response given by the receiving contracts, if the `safeTransferFrom`\n', '    // method is used.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4(\n', '        keccak256("onERC721Received(address,uint256,bytes)")\n', '    );\n', '\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _approved,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    event ApprovalForAll(\n', '        address indexed _owner,\n', '        address indexed _operator,\n', '        bool _approved\n', '    );\n', '\n', '    /**\n', '     * Modify method to only allow calls if the token is valid.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Ethergotchi are valid if they are owned by an address that is not the\n', '     * zero address.\n', '     */\n', '    modifier onlyValidToken(uint256 _tokenId) {\n', '        require(ownerByTokenId[_tokenId] != address(0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Modify method to only allow transfers from authorized callers.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method also adds a few checks against common transfer beneficiary\n', '     * mistakes to prevent a subset of unintended transfers that cannot be\n', '     * reverted.\n', '     */\n', '    modifier onlyValidTransfers(address _from, address _to, uint256 _tokenId) {\n', '        // Get owner of the token. This is used to check against various cases\n', '        // where the caller is allowed to transfer the token.\n', '        address tokenOwner = ownerByTokenId[_tokenId];\n', '\n', '        // Check whether the caller is allowed to transfer the token with given\n', '        // identifier. The caller is allowed to perform the transfer in any of\n', '        // the following cases:\n', '        //  1. the caller is the owner of the token;\n', '        //  2. the caller is approved by the owner of the token to transfer\n', '        //     that specific token; or\n', '        //  3. the caller is approved as operator by the owner of the token, in\n', '        //     which case the caller is approved to perform any action on\n', '        //     behalf of the owner.\n', '        require(\n', '            msg.sender == tokenOwner ||\n', '            msg.sender == approvedTransfers[_tokenId] ||\n', '            operators[tokenOwner][msg.sender]\n', '        );\n', '\n', '        // Check against accidental transfers to the common "wrong" addresses.\n', '        // This includes the zero address, this ownership contract address, and\n', '        // "non-transfers" where the same address is filled in for both `_from`\n', '        // and `_to`.\n', '        require(\n', '            _to != address(0) &&\n', '            _to != address(this) &&\n', '            _to != _from\n', '        );\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Ethergotchi ownership contract constructor\n', '     *\n', '     * At the time of contract construction, an Ethergotchi is artificially\n', '     * constructed to ensure that Ethergotchi are numbered starting from one.\n', '     */\n', '    function EthergotchiOwnershipV2(\n', '        address _formerContract\n', '    )\n', '        public\n', '        Controllable()\n', '    {\n', '        ownerByTokenId[0] = address(0);\n', '        tokenIdsByOwner[address(0)].push(0);\n', '        ownerTokenIndexByTokenId[0] = 0;\n', '\n', '        // The migration index is initialized to 1 as the zeroth token need not\n', '        // be migrated; it is already created during the construction of this\n', '        // contract.\n', '        migrationIndex = 1;\n', '        formerContract = PartialOwnership(_formerContract);\n', '    }\n', '\n', '    /**\n', '     * Add new token into circulation.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to add into circulation.\n', '     * _owner : address\n', '     *     The address of the owner who receives the newly added token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method can only be called by active game contracts. Game contracts\n', '     * are added and modified manually. These additions and modifications\n', '     * always trigger an event for audit purposes.\n', '     */\n', '    function add(\n', '        uint256 _tokenId,\n', '        address _owner\n', '    )\n', '        external\n', '        onlyActiveContracts\n', '    {\n', '        // Safety checks to prevent contracts from calling this method without\n', '        // setting the proper arguments.\n', '        require(_tokenId != 0 && _owner != address(0));\n', '\n', '        _add(_tokenId, _owner);\n', '\n', '        // As per the standard, transfers of newly created tokens should always\n', '        // originate from the zero address.\n', '        Transfer(address(0), _owner, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Check whether contract supports given interface.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * interfaceID : bytes4\n', '     *     The four-bytes representation of an interface of which to check\n', '     *     whether this contract supports it.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if given interface is supported, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * It is expected that the `bytes4` values of interfaces are generated by\n', '     * calling XOR on all function signatures of the interface.\n', '     *\n', '     * Technically more interfaces are supported, as some interfaces may be\n', '     * subsets of the supported interfaces. This check is only to be used to\n', '     * verify whether "standard interfaces" are supported.\n', '     */\n', '    function supportsInterface(\n', '        bytes4 interfaceID\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721 ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721_METADATA ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721_ENUMERABLE\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the name of the token this contract governs ownership of.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This is the collective name of the token. Individual tokens may be named\n', '     * differently by their owners.\n', '     */\n', '    function name() external pure returns (string) {\n', '        return "Ethergotchi";\n', '    }\n', '\n', '    /**\n', '     * Get the symbol of the token this contract governs ownership of.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This symbol has been explicitly changed to `ETHERGOTCHI` from `GOTCHI`\n', '     * in the `PHOENIX` patch of Aethia to prevent confusion with older tokens.\n', '     */\n', '    function symbol() external pure returns (string) {\n', '        return "ETHERGOTCHI";\n', '    }\n', '\n', '    /**\n', '     * Get the URI pointing to a JSON file with metadata for a given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to get the URI for.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The URI pointing to a JSON file with metadata for the token with\n', '     *     given identifier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method returns a string that may contain more than one null-byte,\n', '     * because the conversion method is not ideal.\n', '     */\n', '    function tokenURI(uint256 _tokenId) external view returns (string) {\n', '        bytes32 tokenIdBytes = Tools.uint256ToBytes32(_tokenId);\n', '\n', '        return Tools.concatenate(\n', '            "https://aethia.co/ethergotchi/",\n', '            Tools.bytes32ToString(tokenIdBytes)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the number of tokens assigned to given owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of the owner of which to get the number of owned tokens\n', '     *     of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of tokens owned by given owner.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Tokens owned by the zero address are considered invalid, as described in\n', '     * the EIP 721 standard, and queries regarding the zero address will result\n', '     * in the transaction being rejected.\n', '     */\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '\n', '        return tokenIdsByOwner[_owner].length;\n', '    }\n', '\n', '    /**\n', '     * Get the address of the owner of given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token of which to get the owner"s address.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address\n', '     *     The address of the owner of given token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Tokens owned by the zero address are considered invalid, as described in\n', '     * the EIP 721 standard, and queries regarding the zero address will result\n', '     * in the transaction being rejected.\n', '     */\n', '    function ownerOf(uint256 _tokenId) external view returns (address) {\n', '        // Store the owner in a temporary variable to avoid having to do the\n', '        // lookup twice.\n', '        address _owner = ownerByTokenId[_tokenId];\n', '\n', '        require(_owner != address(0));\n', '\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     * data : bytes\n', '     *     Non-specified data to send along the transfer towards the `to`\n', '     *     address that can be processed.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a check to determine whether the receiving party is\n', '     * a smart contract by calling the `_isContract` method. This works until\n', '     * the `Serenity` update of Ethereum is deployed.\n', '     */\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes data\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '    {\n', '        // Call the internal `_safeTransferFrom` method to avoid duplicating\n', '        // the transfer code.\n', '        _safeTransferFrom(_from, _to, _tokenId, data);\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method does exactly the same as calling the `safeTransferFrom`\n', '     * method with the `data` parameter set to an empty bytes value:\n', '     *  `safeTransferFrom(_from, _to, _tokenId, "")`\n', '     */\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '    {\n', '        // Call the internal `_safeTransferFrom` method to avoid duplicating\n', '        // the transfer code.\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a few rudimentary checks to determine whether the\n', '     * receiving party can actually receive the token. However, it is still up\n', '     * to the caller to ensure this is actually the case.\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '        onlyValidTransfers(_from, _to, _tokenId)\n', '    {\n', '        _transfer(_to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Approve the given address for the transfer of the given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _approved : address\n', '     *     The address to approve. Approval allows the address to transfer the\n', '     *     given token to a different address.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to give transfer approval for.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * There is no specific method to revoke approvals, but the approval is\n', '     * removed after the transfer has been completed. Additionally the owner\n', '     * or operator may call the method with the zero address as `_approved` to\n', '     * effectively revoke the approval.\n', '     */\n', '    function approve(address _approved, uint256 _tokenId) external {\n', '        address _owner = ownerByTokenId[_tokenId];\n', '\n', '        // Approval can only be given by the owner or an operator approved by\n', '        // the owner.\n', '        require(msg.sender == _owner || operators[_owner][msg.sender]);\n', '\n', '        // Set address as approved for transfer. It can be the case that the\n', '        // address was already set (e.g. this method was called twice in a row)\n', '        // in which case this does not change anything.\n', '        approvedTransfers[_tokenId] = _approved;\n', '\n', '        Approval(msg.sender, _approved, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Set approval for a third-party to manage all tokens of the caller.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _operator : address\n', '     *     The address to set the operator status for.\n', '     * _approved : bool\n', '     *     The operator status. True if the given address should be allowed to\n', '     *     act on behalf of the caller, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * There is no duplicate checking done out of simplicity. Callers are thus\n', '     * able to set the same address as operator a multitude of times, even if\n', '     * it does not change the actual state of the system.\n', '     */\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        operators[msg.sender][_operator] = _approved;\n', '\n', '        ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /**\n', '     * Get approved address for given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token of which to get the approved address of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address\n', '     *     The address that is allowed to initiate a transfer of the given\n', '     *     token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Technically this method could be implemented without the method modifier\n', '     * as the network guarantees that the address mapping is initiated with all\n', '     * addresses set to the zero address. The requirement is implemented to\n', '     * comply with the standard as described in EIP-721.\n', '     */\n', '    function getApproved(\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        view\n', '        onlyValidToken(_tokenId)\n', '        returns (address)\n', '    {\n', '        return approvedTransfers[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * Check whether an address is an authorized operator of another address.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of which to check whether it has approved the other\n', '     *     address to act as operator.\n', '     * _operator : address\n', '     *     The address of which to check whether it has been approved to act\n', '     *     as operator on behalf of `_owner`.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if `_operator` is approved for all actions on behalf of\n', '     *     `_owner`.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method cannot fail, as the Ethereum network guarantees that all\n', '     * address mappings exist and are set to the zero address by default.\n', '     */\n', '    function isApprovedForAll(\n', '        address _owner,\n', '        address _operator\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return operators[_owner][_operator];\n', '    }\n', '\n', '    /**\n', '     * Get the total number of tokens currently in circulation.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The total number of tokens currently in circulation.\n', '     */\n', '    function totalSupply() external view returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    /**\n', '     * Get token identifier by index.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _index : uint256\n', '     *     The index of the token to get the identifier of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The identifier of the token at given index.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Ethergotchi tokens are incrementally numbered starting from zero, and\n', '     * always go up by one. The index of the token is thus equivalent to its\n', '     * identifier.\n', '     */\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        require(_index < totalTokens);\n', '\n', '        return _index;\n', '    }\n', '\n', '    /**\n', '     * Get token of owner by index.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of the owner of which to get the token of.\n', '     * _index : uint256\n', '     *     The index of the token in the given owner"s list of token.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The identifier of the token at given index of an owner"s list of\n', '     *     tokens.\n', '     */\n', '    function tokenOfOwnerByIndex(\n', '        address _owner,\n', '        uint256 _index\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(_index < tokenIdsByOwner[_owner].length);\n', '\n', '        return tokenIdsByOwner[_owner][_index];\n', '    }\n', '\n', '    /**\n', '     * Check whether given address is a smart contract.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The address of which to check whether it is a contract.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if given address is a contract, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method works as long as the `Serenity` update of Ethereum has not\n', '     * been deployed. At the time of writing, contracts cannot set their code\n', '     * size to zero, nor can "normal" addresses set their code size to anything\n', '     * non-zero. With `Serenity` the idea will be that each and every address\n', '     * is an contract, effectively rendering this method.\n', '     */\n', '    function _isContract(address _address) internal view returns (bool) {\n', '        uint size;\n', '\n', '        assembly {\n', '            size := extcodesize(_address)\n', '        }\n', '\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     * data : bytes\n', '     *     Non-specified data to send along the transfer towards the `to`\n', '     *     address that can be processed.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a check to determine whether the receiving party is\n', '     * a smart contract by calling the `_isContract` method. This works until\n', '     * the `Serenity` update of Ethereum is deployed.\n', '     */\n', '    function _safeTransferFrom(\n', '        address _from, \n', '        address _to, \n', '        uint256 _tokenId,\n', '        bytes data\n', '    )\n', '        internal\n', '        onlyValidTransfers(_from, _to, _tokenId)\n', '    {\n', '        // Call the method that performs the actual transfer. All common cases\n', '        // of "wrong" transfers have already been checked at this point. The\n', '        // internal transfer method does no checking.\n', '        _transfer(_to, _tokenId);\n', '\n', '        // Check whether the receiving party is a contract, and if so, call\n', '        // the `onERC721Received` method as defined in the ERC-721 standard.\n', '        if (_isContract(_to)) {\n', '\n', '            // Assume the receiving party has implemented ERC721TokenReceiver,\n', '            // as otherwise the "unsafe" `transferFrom` method should have been\n', '            // called instead.\n', '            ERC721TokenReceiver _receiver = ERC721TokenReceiver(_to);\n', '\n', '            // The response returned by `onERC721Received` of the receiving\n', '            // contract"s `on *must* be equal to the magic number defined by\n', '            // the ERC-165 signature of `ERC721TokenReceiver`. If this is not\n', '            // the case, the transaction will be reverted.\n', '            require(\n', '                _receiver.onERC721Received(\n', '                    address(this),\n', '                    _tokenId,\n', '                    data\n', '                ) == INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer token to new owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _to : address\n', '     *     The address of the owner-to-be of given token.\n', '     * _tokenId : _tokenId\n', '     *     The identifier of the token that is to be transferred.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs no safety checks as it can only be called within\n', '     * the controlled environment of this contract.\n', '     */\n', '    function _transfer(address _to, uint256 _tokenId) internal {\n', '        // Get current owner of the token. It is technically possible that the\n', '        // owner is the same address as the address to which the token is to be\n', '        // sent to. In this case the token will be moved to the end of the list\n', '        // of tokens owned by this address.\n', '        address _from = ownerByTokenId[_tokenId];\n', '\n', '        // There are two possible scenarios for transfers when it comes to the\n', '        // removal of the token from the side that currently owns the token:\n', '        //  1: the owner has two or more tokens; or\n', '        //  2: the owner has one token.\n', '        if (tokenIdsByOwner[_from].length > 1) {\n', '\n', '            // Get the index of the token that has to be removed from the list\n', '            // of tokens owned by the current owner.\n', '            uint256 tokenIndexToDelete = ownerTokenIndexByTokenId[_tokenId];\n', '\n', '            // To keep the list of tokens without gaps, and thus reducing the\n', '            // gas cost associated with interacting with the list, the last\n', '            // token in the owner"s list of tokens is moved to fill the gap\n', '            // created by removing the token.\n', '            uint256 tokenIndexToMove = tokenIdsByOwner[_from].length - 1;\n', '\n', '            // Overwrite the token that is to be removed with the token that\n', '            // was at the end of the list. It is possible that both are one and\n', '            // the same, in which case nothing happens.\n', '            tokenIdsByOwner[_from][tokenIndexToDelete] =\n', '                tokenIdsByOwner[_from][tokenIndexToMove];\n', '        }\n', '\n', '        // Remove the last item in the list of tokens owned by the current\n', '        // owner. This item has either already been copied to the location of\n', '        // the token that is to be transferred, or is the only token of this\n', '        // owner in which case the list of tokens owned by this owner is now\n', '        // empty.\n', '        tokenIdsByOwner[_from].length--;\n', '\n', '        // Add the token to the list of tokens owned by `_to`. Items are always\n', '        // added to the very end of the list. This makes the token index of the\n', '        // new token within the owner"s list of tokens equal to the length of\n', '        // the list minus one as Solidity is a zero-based language. This token\n', '        // index is then set for this token identifier.\n', '        tokenIdsByOwner[_to].push(_tokenId);\n', '        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_to].length - 1;\n', '\n', '        // Set the direct ownership information of the token to the new owner\n', '        // after all other ownership-related mappings have been updated to make\n', '        // sure the "side" data is correct.\n', '        ownerByTokenId[_tokenId] = _to;\n', '\n', '        // Remove the approved address of this token. It may be the case there\n', '        // was no approved address, in which case nothing changes.\n', '        approvedTransfers[_tokenId] = address(0);\n', '\n', '        // Log the transfer event onto the blockchain to leave behind an audit\n', '        // trail of all transfers that have taken place.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Add new token into circulation.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to add into circulation.\n', '     * _owner : address\n', '     *     The address of the owner who receives the newly added token.\n', '     */\n', '    function _add(uint256 _tokenId, address _owner) internal {\n', '        // Ensure the token does not already exist, and prevent duplicate calls\n', '        // using the same identifier.\n', '        require(ownerByTokenId[_tokenId] == address(0));\n', '\n', '        // Update the direct ownership mapping, by setting the owner of the\n', '        // token identifier to `_owner`, and adding the token to the list of\n', '        // tokens owned by `_owner`. Arrays are always initialized to empty\n', '        // versions of of their specific type, thus ensuring that the `push`\n', '        // method will not fail.\n', '        ownerByTokenId[_tokenId] = _owner;\n', '        tokenIdsByOwner[_owner].push(_tokenId);\n', '\n', '        // Update the mapping that keeps track of a token"s index within the\n', '        // list of tokens owned by each owner. At the time of addition a token\n', '        // is always added to the end of the list, and will thus always equal\n', '        // the number of tokens already in the list, minus one, because the\n', '        // arrays within Solidity are zero-based.\n', '        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_owner].length - 1;\n', '\n', '        totalTokens += 1;\n', '    }\n', '\n', '    /*********************************************/\n', '    /** MIGRATION state variables and functions **/\n', '    /*********************************************/\n', '\n', '    // This number is used to keep track of how many tokens have been migrated.\n', '    // The number cannot exceed the number of tokens that were assigned to\n', '    // owners in the previous Ownership contract.\n', '    uint256 public migrationIndex;\n', '\n', '    // The previous token ownership contract.\n', '    PartialOwnership private formerContract;\n', '\n', '    /**\n', '     * Migrate data from the former Ethergotchi ownership contract.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _count : uint256\n', '     *     The number of tokens to migrate in a single transaction.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method is limited in use to ensure no &#39;malicious&#39; calls are made.\n', '     * Additionally, this method writes to a contract state variable to keep\n', '     * track of how many tokens have been migrated.\n', '     */\n', '    function migrate(uint256 _count) external onlyOwner {\n', '        // Ensure that the migrate function can *only* be called in a specific\n', '        // time period. This period ranges from Saturday, March 24th, 00:00:00\n', '        // UTC until Sunday, March 25th, 23:59:59 UTC.\n', '        require(1521849600 <= now && now <= 1522022399);\n', '\n', '        // Get the maximum number of tokens handed out by the previous\n', '        // ownership contract.\n', '        uint256 formerTokenCount = formerContract.totalSupply();\n', '\n', '        // The index to stop the migration at for this transaction.\n', '        uint256 endIndex = migrationIndex + _count;\n', '\n', '        // It is possible that the final transaction has a higher end index\n', '        // than there are a number of tokens. In this case, the end index is\n', '        // reduced to ensure no non-existent tokens are migrated.\n', '        if (endIndex >= formerTokenCount) {\n', '            endIndex = formerTokenCount;\n', '        }\n', '\n', '        // Loop through the token identifiers to migrate in this transaction.\n', '        // Token identifiers are equivalent to their &#39;index&#39;, as identifiers\n', '        // start at zero (with the zeroth token being owned by the zero\n', '        // address), and are incremented by one for each new token.\n', '        for (uint256 i = migrationIndex; i < endIndex; i++) {\n', '            address tokenOwner;\n', '\n', '            // There was a malicious account that acquired over 400 eggs via\n', '            // referral codes, which breaks the terms of use. The acquired egg\n', '            // numbers ranged from identifier 1247 up until 1688, excluding\n', '            // 1296, 1297, 1479, 1492, 1550, 1551, and 1555. This was found by\n', '            // looking at activity on the pick-up contract, and tracing it back\n', '            // to the following address:\n', '            //  `0c7a911ac29ea1e3b1d438f98f8bc053131dcaf52`\n', '            if (_isExcluded(i)) {\n', '                tokenOwner = address(0);\n', '            } else {\n', '                tokenOwner = formerContract.ownerOf(i);\n', '            }\n', '\n', '            // Assign the token to the same address that owned it in the\n', '            // previous ownership contract.\n', '            _add(i, tokenOwner);\n', '\n', '            // Log the token transfer. In this case where the token is &#39;newly&#39;\n', '            // created, but actually transferred from a previous contract, the\n', '            // `_from` address is set to the previous contract address, to\n', '            // signify a migration.\n', '            Transfer(address(formerContract), tokenOwner, i);\n', '        }\n', '\n', '        // Set the new migration index to where the current transaction ended\n', '        // its migration.\n', '        migrationIndex = endIndex;\n', '    }\n', '\n', '    /**\n', '     * Check if Ethergotchi should be excluded from migration.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _gotchiId : uint256\n', '     *     The identifier of the Ethergotchi of which to check the exclusion\n', '     *     status.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if the Ethergotchi should be excluded from the migration, else\n', '     *     False.\n', '     */\n', '    function _isExcluded(uint256 _gotchiId) internal pure returns (bool) {\n', '        return\n', '            1247 <= _gotchiId && _gotchiId <= 1688 &&\n', '            _gotchiId != 1296 &&\n', '            _gotchiId != 1297 &&\n', '            _gotchiId != 1479 &&\n', '            _gotchiId != 1492 &&\n', '            _gotchiId != 1550 &&\n', '            _gotchiId != 1551 &&\n', '            _gotchiId != 1555;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', 'interface ERC721 /* is ERC165 */ {\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param _owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `_owner`, possibly zero\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @param _tokenId The identifier for an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `_to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `_to`\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to ""\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '\n', '    /// @notice Set or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param _approved The new approved NFT controller\n', '    /// @param _tokenId The NFT to approve\n', '    function approve(address _approved, uint256 _tokenId) external;\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', '    ///  all your assets.\n', '    /// @dev Throws unless `msg.sender` is the current NFT owner.\n', '    /// @dev Emits the ApprovalForAll event\n', '    /// @param _operator Address to add to the set of authorized operators.\n', '    /// @param _approved True if the operators is approved, false to revoke approval\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `_tokenId` is not a valid NFT\n', '    /// @param _tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param _owner The address that owns the NFTs\n', '    /// @param _operator The address that acts on behalf of the owner\n', '    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x780e9d63\n', 'interface ERC721Enumerable /* is ERC721 */ {\n', '  /// @notice Count NFTs tracked by this contract\n', '  /// @return A count of valid NFTs tracked by this contract, where each one of\n', '  ///  them has an assigned and queryable owner not equal to the zero address\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /// @notice Enumerate valid NFTs\n', '  /// @dev Throws if `_index` >= `totalSupply()`.\n', '  /// @param _index A counter less than `totalSupply()`\n', '  /// @return The token identifier for the `_index`th NFT,\n', '  ///  (sort order not specified)\n', '  function tokenByIndex(uint256 _index) external view returns (uint256);\n', '\n', '  /// @notice Enumerate NFTs assigned to an owner\n', '  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n', '  ///  `_owner` is the zero address, representing invalid NFTs.\n', '  /// @param _owner An address where we are interested in NFTs owned by them\n', '  /// @param _index A counter less than `balanceOf(_owner)`\n', '  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n', '  ///   (sort order not specified)\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\n', 'interface ERC721Metadata /* is ERC721 */ {\n', '    /// @notice A descriptive name for a collection of NFTs in this contract\n', '    function name() external pure returns (string _name);\n', '\n', '    /// @notice An abbreviated name for NFTs in this contract\n', '    function symbol() external pure returns (string _symbol);\n', '\n', '    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n', '    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n', '    ///  3986. The URI may point to a JSON file that conforms to the "ERC721\n', '    ///  Metadata JSON Schema".\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\n', 'interface ERC721TokenReceiver {\n', '    /// @notice Handle the receipt of an NFT\n', '    /// @dev The ERC721 smart contract calls this function on the recipient\n', '    ///  after a `transfer`. This function MAY throw to revert and reject the\n', '    ///  transfer. This function MUST use 50,000 gas or less. Return of other\n', '    ///  than the magic value MUST result in the transaction being reverted.\n', '    ///  Note: the contract address is always the message sender.\n', '    /// @param _from The sending address \n', '    /// @param _tokenId The NFT identifier which is being transferred\n', '    /// @param data Additional data with no specified format\n', '    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '    ///  unless throwing\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n', '}\n', '\n', 'contract Ownable {\n', '    address private owner;\n', '\n', '    event LogOwnerChange(address _owner);\n', '\n', '    // Modify method to only allow calls from the owner of the contract.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Replace the contract owner with a new owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address to replace the current owner with.\n', '     */\n', '    function replaceOwner(address _owner) external onlyOwner {\n', '        owner = _owner;\n', '\n', '        LogOwnerChange(_owner);\n', '    }\n', '}\n', '\n', 'contract Controllable is Ownable {\n', '    // Mapping of a contract address to its position in the list of active\n', '    // contracts. This allows an O(1) look-up of the contract address compared\n', '    // to a linear search within an array.\n', '    mapping(address => uint256) private contractIndices;\n', '\n', '    // The list of contracts that are allowed to call the contract-restricted\n', '    // methods of contracts that extend this `Controllable` contract.\n', '    address[] private contracts;\n', '\n', '    /**\n', '     * Modify method to only allow calls from active contract addresses.\n', '     *\n', '     * Notes\n', '     * -----\n', '     * The zero address is considered an inactive address, as it is impossible\n', '     * for users to send a call from that address.\n', '     */\n', '    modifier onlyActiveContracts() {\n', '        require(contractIndices[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    function Controllable() public Ownable() {\n', '        // The zeroth index of the list of active contracts is occupied by the\n', '        // zero address to ensure that an index of zero can be used to indicate\n', '        // that the contract address is inactive.\n', '        contracts.push(address(0));\n', '    }\n', '\n', '    /**\n', '     * Add a contract address to the list of active contracts.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The contract address to add to the list of active contracts.\n', '     */\n', '    function activateContract(address _address) external onlyOwner {\n', '        require(contractIndices[_address] == 0);\n', '\n', '        contracts.push(_address);\n', '\n', '        // The index of the newly added contract is equal to the length of the\n', '        // array of active contracts minus one, as Solidity is a zero-based\n', '        // language.\n', '        contractIndices[_address] = contracts.length - 1;\n', '    }\n', '\n', '    /**\n', '     * Remove a contract address from the list of active contracts.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The contract address to remove from the list of active contracts.\n', '     */\n', '    function deactivateContract(address _address) external onlyOwner {\n', '        require(contractIndices[_address] != 0);\n', '\n', '        // Get the last contract in the array of active contracts. This address\n', '        // will be used to overwrite the address that will be removed.\n', '        address lastActiveContract = contracts[contracts.length - 1];\n', '\n', '        // Overwrite the address that is to be removed with the value of the\n', '        // last contract in the list. There is a possibility that these are the\n', '        // same values, in which case nothing happens.\n', '        contracts[contractIndices[_address]] = lastActiveContract;\n', '\n', '        // Reduce the contracts array size by one, as the last contract address\n', '        // will have been successfully moved.\n', '        contracts.length--;\n', '\n', '        // Set the address mapping to zero, effectively rendering the contract\n', '        // banned from calling this contract.\n', '        contractIndices[_address] = 0;\n', '    }\n', '\n', '    /**\n', '     * Get the list of active contracts for this contract.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address[]\n', '     *     The list of contract addresses that are allowed to call the\n', '     *     contract-restricted methods of this contract.\n', '     */\n', '    function getActiveContracts() external view returns (address[]) {\n', '        return contracts;\n', '    }\n', '}\n', '\n', 'library Tools {\n', '    /**\n', '     * Concatenate two strings.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * stringLeft : string\n', '     *     A string to concatenate with another string. This is the left part.\n', '     * stringRight : string\n', '     *     A string to concatenate with another string. This is the right part.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The resulting string from concatenating the two given strings.\n', '     */\n', '    function concatenate(\n', '        string stringLeft,\n', '        string stringRight\n', '    )\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', '        // Get byte representations of both strings to allow for one-by-one\n', '        // character iteration.\n', '        bytes memory stringLeftBytes = bytes(stringLeft);\n', '        bytes memory stringRightBytes = bytes(stringRight);\n', '\n', '        // Initialize new string holder with the appropriate number of bytes to\n', '        // hold the concatenated string.\n', '        string memory resultString = new string(\n', '            stringLeftBytes.length + stringRightBytes.length\n', '        );\n', '\n', '        // Get a bytes representation of the result string to allow for direct\n', '        // modification.\n', '        bytes memory resultBytes = bytes(resultString);\n', '\n', '        // Initialize a number to hold the current index of the result string\n', '        // to assign a character to.\n', '        uint k = 0;\n', '\n', '        // First loop over the left string, and afterwards over the right\n', '        // string to assign each character to its proper location in the new\n', '        // string.\n', '        for (uint i = 0; i < stringLeftBytes.length; i++) {\n', '            resultBytes[k++] = stringLeftBytes[i];\n', '        }\n', '\n', '        for (i = 0; i < stringRightBytes.length; i++) {\n', '            resultBytes[k++] = stringRightBytes[i];\n', '        }\n', '\n', '        return string(resultBytes);\n', '    }\n', '\n', '    /**\n', '     * Convert 256-bit unsigned integer into a 32 bytes structure.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * value : uint256\n', '     *     The unsigned integer to convert to bytes32.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bytes32\n', '     *     The bytes32 representation of the given unsigned integer.\n', '     */\n', '    function uint256ToBytes32(uint256 value) internal pure returns (bytes32) {\n', '        if (value == 0) {\n', "            return '0';\n", '        }\n', '\n', '        bytes32 resultBytes;\n', '\n', '        while (value > 0) {\n', '            resultBytes = bytes32(uint(resultBytes) / (2 ** 8));\n', '            resultBytes |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\n', '            value /= 10;\n', '        }\n', '\n', '        return resultBytes;\n', '    }\n', '\n', '    /**\n', '     * Convert bytes32 data structure into a string.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * data : bytes32\n', '     *     The bytes to convert to a string.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The string representation of given bytes.\n', '     *\n', '     * Notes\n', '     * -----\n', '     * This method is right-padded with zero bytes.\n', '     */\n', '    function bytes32ToString(bytes32 data) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '\n', '        for (uint i = 0; i < 32; i++) {\n', '            bytes1 char = bytes1(bytes32(uint256(data) * 2 ** (8 * i)));\n', '\n', '            if (char != 0) {\n', '                bytesString[i] = char;\n', '            }\n', '        }\n', '\n', '        return string(bytesString);\n', '    }\n', '}\n', '\n', '/**\n', ' * Partial interface of former ownership contract.\n', ' *\n', ' * This interface is used to perform the migration of tokens, from the former\n', ' * ownership contract to the current version. The inclusion of the entire\n', ' * contract is too bulky, hence the partial interface.\n', ' */\n', 'interface PartialOwnership {\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * Ethergotchi Ownership Contract\n', ' *\n', ' * This contract governs the "non-fungible tokens" (NFTs) that represent the\n', ' * various Ethergotchi owned by players within Aethia.\n', ' *\n', ' * The NFTs are implemented according to the standard described in EIP-721 as\n', ' * it was on March 19th, 2018.\n', ' *\n', ' * In addition to the mentioned specification, a method was added to create new\n', ' * tokens: `add(uint256 _tokenId, address _owner)`. This method can *only* be\n', ' * called by activated Aethia game contracts.\n', ' *\n', ' * For more information on Aethia and/or Ethergotchi, visit the following\n', ' * website: https://aethia.co\n', ' */\n', 'contract EthergotchiOwnershipV2 is\n', '    Controllable,\n', '    ERC721,\n', '    ERC721Enumerable,\n', '    ERC721Metadata\n', '{\n', '    // Direct mapping to keep track of token owners.\n', '    mapping(uint256 => address) private ownerByTokenId;\n', '\n', '    // Mapping that keeps track of all tokens owned by a specific address. This\n', '    // allows for iteration by owner, and is implemented to be able to comply\n', '    // with the enumeration methods described in the ERC721Enumerable interface.\n', '    mapping(address => uint256[]) private tokenIdsByOwner;\n', '\n', '    // Mapping that keeps track of a token"s position in an owner"s list of\n', '    // tokens. This allows for constant time look-ups within the list, instead\n', '    // of needing to iterate the list of tokens.\n', '    mapping(uint256 => uint256) private ownerTokenIndexByTokenId;\n', '\n', '    // Mapping that keeps track of addresses that are approved to make a\n', '    // transfer of a token. Approval can only be given to a single address, but\n', '    // can be overridden for modification or retraction purposes.\n', '    mapping(uint256 => address) private approvedTransfers;\n', '\n', '    // Mapping that keeps track of operators that are allowed to perform\n', '    // actions on behalf of another address. An address is allowed to set more\n', '    // than one operator. Operators can perform all actions on behalf on an\n', '    // address, *except* for setting a different operator.\n', '    mapping(address => mapping(address => bool)) private operators;\n', '\n', '    // Total number of tokens governed by this contract. This allows for the\n', '    // enumeration of all tokens, provided that tokens are created with their\n', '    // identifiers being numbers, incremented by one.\n', '    uint256 private totalTokens;\n', '\n', '    // The ERC-165 identifier of the ERC-165 interface. This contract\n', '    // implements the `supportsInterface` method to check whether other types\n', '    // of standard interfaces are supported.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4(\n', '        keccak256("supportsInterface(bytes4)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 interface. This contract\n', '    // implements all methods of the ERC-721 Enumerable interface, and uses\n', '    // this identifier to supply the correct answer to a call to\n', '    // `supportsInterface`.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4(\n', '        keccak256("balanceOf(address)") ^\n', '        keccak256("ownerOf(uint256)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256,bytes)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256)") ^\n', '        keccak256("transferFrom(address,address,uint256)") ^\n', '        keccak256("approve(address,uint256)") ^\n', '        keccak256("setApprovalForAll(address,bool)") ^\n', '        keccak256("getApproved(uint256)") ^\n', '        keccak256("isApprovedForAll(address,address)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Enumerable interface. This\n', '    // contract implements all methods of the ERC-721 Enumerable interface, and\n', '    // uses this identifier to supply the correct answer to a call to\n', '    // `supportsInterface`.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4(\n', '        keccak256("totalSupply()") ^\n', '        keccak256("tokenByIndex(uint256)") ^\n', '        keccak256("tokenOfOwnerByIndex(address,uint256)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Metadata interface. This contract\n', '    // implements all methods of the ERC-721 Metadata interface, and uses the\n', '    // identifier to supply the correct answer to a `supportsInterface` call.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4(\n', '        keccak256("name()") ^\n', '        keccak256("symbol()") ^\n', '        keccak256("tokenURI(uint256)")\n', '    );\n', '\n', '    // The ERC-165 identifier of the ERC-721 Token Receiver interface. This\n', '    // is not implemented by this contract, but is used to identify the\n', '    // response given by the receiving contracts, if the `safeTransferFrom`\n', '    // method is used.\n', '    bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4(\n', '        keccak256("onERC721Received(address,uint256,bytes)")\n', '    );\n', '\n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _approved,\n', '        uint256 _tokenId\n', '    );\n', '\n', '    event ApprovalForAll(\n', '        address indexed _owner,\n', '        address indexed _operator,\n', '        bool _approved\n', '    );\n', '\n', '    /**\n', '     * Modify method to only allow calls if the token is valid.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Ethergotchi are valid if they are owned by an address that is not the\n', '     * zero address.\n', '     */\n', '    modifier onlyValidToken(uint256 _tokenId) {\n', '        require(ownerByTokenId[_tokenId] != address(0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Modify method to only allow transfers from authorized callers.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method also adds a few checks against common transfer beneficiary\n', '     * mistakes to prevent a subset of unintended transfers that cannot be\n', '     * reverted.\n', '     */\n', '    modifier onlyValidTransfers(address _from, address _to, uint256 _tokenId) {\n', '        // Get owner of the token. This is used to check against various cases\n', '        // where the caller is allowed to transfer the token.\n', '        address tokenOwner = ownerByTokenId[_tokenId];\n', '\n', '        // Check whether the caller is allowed to transfer the token with given\n', '        // identifier. The caller is allowed to perform the transfer in any of\n', '        // the following cases:\n', '        //  1. the caller is the owner of the token;\n', '        //  2. the caller is approved by the owner of the token to transfer\n', '        //     that specific token; or\n', '        //  3. the caller is approved as operator by the owner of the token, in\n', '        //     which case the caller is approved to perform any action on\n', '        //     behalf of the owner.\n', '        require(\n', '            msg.sender == tokenOwner ||\n', '            msg.sender == approvedTransfers[_tokenId] ||\n', '            operators[tokenOwner][msg.sender]\n', '        );\n', '\n', '        // Check against accidental transfers to the common "wrong" addresses.\n', '        // This includes the zero address, this ownership contract address, and\n', '        // "non-transfers" where the same address is filled in for both `_from`\n', '        // and `_to`.\n', '        require(\n', '            _to != address(0) &&\n', '            _to != address(this) &&\n', '            _to != _from\n', '        );\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Ethergotchi ownership contract constructor\n', '     *\n', '     * At the time of contract construction, an Ethergotchi is artificially\n', '     * constructed to ensure that Ethergotchi are numbered starting from one.\n', '     */\n', '    function EthergotchiOwnershipV2(\n', '        address _formerContract\n', '    )\n', '        public\n', '        Controllable()\n', '    {\n', '        ownerByTokenId[0] = address(0);\n', '        tokenIdsByOwner[address(0)].push(0);\n', '        ownerTokenIndexByTokenId[0] = 0;\n', '\n', '        // The migration index is initialized to 1 as the zeroth token need not\n', '        // be migrated; it is already created during the construction of this\n', '        // contract.\n', '        migrationIndex = 1;\n', '        formerContract = PartialOwnership(_formerContract);\n', '    }\n', '\n', '    /**\n', '     * Add new token into circulation.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to add into circulation.\n', '     * _owner : address\n', '     *     The address of the owner who receives the newly added token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method can only be called by active game contracts. Game contracts\n', '     * are added and modified manually. These additions and modifications\n', '     * always trigger an event for audit purposes.\n', '     */\n', '    function add(\n', '        uint256 _tokenId,\n', '        address _owner\n', '    )\n', '        external\n', '        onlyActiveContracts\n', '    {\n', '        // Safety checks to prevent contracts from calling this method without\n', '        // setting the proper arguments.\n', '        require(_tokenId != 0 && _owner != address(0));\n', '\n', '        _add(_tokenId, _owner);\n', '\n', '        // As per the standard, transfers of newly created tokens should always\n', '        // originate from the zero address.\n', '        Transfer(address(0), _owner, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Check whether contract supports given interface.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * interfaceID : bytes4\n', '     *     The four-bytes representation of an interface of which to check\n', '     *     whether this contract supports it.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if given interface is supported, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * It is expected that the `bytes4` values of interfaces are generated by\n', '     * calling XOR on all function signatures of the interface.\n', '     *\n', '     * Technically more interfaces are supported, as some interfaces may be\n', '     * subsets of the supported interfaces. This check is only to be used to\n', '     * verify whether "standard interfaces" are supported.\n', '     */\n', '    function supportsInterface(\n', '        bytes4 interfaceID\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721 ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721_METADATA ||\n', '            interfaceID == INTERFACE_SIGNATURE_ERC721_ENUMERABLE\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the name of the token this contract governs ownership of.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This is the collective name of the token. Individual tokens may be named\n', '     * differently by their owners.\n', '     */\n', '    function name() external pure returns (string) {\n', '        return "Ethergotchi";\n', '    }\n', '\n', '    /**\n', '     * Get the symbol of the token this contract governs ownership of.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This symbol has been explicitly changed to `ETHERGOTCHI` from `GOTCHI`\n', '     * in the `PHOENIX` patch of Aethia to prevent confusion with older tokens.\n', '     */\n', '    function symbol() external pure returns (string) {\n', '        return "ETHERGOTCHI";\n', '    }\n', '\n', '    /**\n', '     * Get the URI pointing to a JSON file with metadata for a given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to get the URI for.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * string\n', '     *     The URI pointing to a JSON file with metadata for the token with\n', '     *     given identifier.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method returns a string that may contain more than one null-byte,\n', '     * because the conversion method is not ideal.\n', '     */\n', '    function tokenURI(uint256 _tokenId) external view returns (string) {\n', '        bytes32 tokenIdBytes = Tools.uint256ToBytes32(_tokenId);\n', '\n', '        return Tools.concatenate(\n', '            "https://aethia.co/ethergotchi/",\n', '            Tools.bytes32ToString(tokenIdBytes)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Get the number of tokens assigned to given owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of the owner of which to get the number of owned tokens\n', '     *     of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The number of tokens owned by given owner.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Tokens owned by the zero address are considered invalid, as described in\n', '     * the EIP 721 standard, and queries regarding the zero address will result\n', '     * in the transaction being rejected.\n', '     */\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '        require(_owner != address(0));\n', '\n', '        return tokenIdsByOwner[_owner].length;\n', '    }\n', '\n', '    /**\n', '     * Get the address of the owner of given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token of which to get the owner"s address.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address\n', '     *     The address of the owner of given token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Tokens owned by the zero address are considered invalid, as described in\n', '     * the EIP 721 standard, and queries regarding the zero address will result\n', '     * in the transaction being rejected.\n', '     */\n', '    function ownerOf(uint256 _tokenId) external view returns (address) {\n', '        // Store the owner in a temporary variable to avoid having to do the\n', '        // lookup twice.\n', '        address _owner = ownerByTokenId[_tokenId];\n', '\n', '        require(_owner != address(0));\n', '\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     * data : bytes\n', '     *     Non-specified data to send along the transfer towards the `to`\n', '     *     address that can be processed.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a check to determine whether the receiving party is\n', '     * a smart contract by calling the `_isContract` method. This works until\n', '     * the `Serenity` update of Ethereum is deployed.\n', '     */\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes data\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '    {\n', '        // Call the internal `_safeTransferFrom` method to avoid duplicating\n', '        // the transfer code.\n', '        _safeTransferFrom(_from, _to, _tokenId, data);\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method does exactly the same as calling the `safeTransferFrom`\n', '     * method with the `data` parameter set to an empty bytes value:\n', '     *  `safeTransferFrom(_from, _to, _tokenId, "")`\n', '     */\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '    {\n', '        // Call the internal `_safeTransferFrom` method to avoid duplicating\n', '        // the transfer code.\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a few rudimentary checks to determine whether the\n', '     * receiving party can actually receive the token. However, it is still up\n', '     * to the caller to ensure this is actually the case.\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        onlyValidToken(_tokenId)\n', '        onlyValidTransfers(_from, _to, _tokenId)\n', '    {\n', '        _transfer(_to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Approve the given address for the transfer of the given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _approved : address\n', '     *     The address to approve. Approval allows the address to transfer the\n', '     *     given token to a different address.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to give transfer approval for.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * There is no specific method to revoke approvals, but the approval is\n', '     * removed after the transfer has been completed. Additionally the owner\n', '     * or operator may call the method with the zero address as `_approved` to\n', '     * effectively revoke the approval.\n', '     */\n', '    function approve(address _approved, uint256 _tokenId) external {\n', '        address _owner = ownerByTokenId[_tokenId];\n', '\n', '        // Approval can only be given by the owner or an operator approved by\n', '        // the owner.\n', '        require(msg.sender == _owner || operators[_owner][msg.sender]);\n', '\n', '        // Set address as approved for transfer. It can be the case that the\n', '        // address was already set (e.g. this method was called twice in a row)\n', '        // in which case this does not change anything.\n', '        approvedTransfers[_tokenId] = _approved;\n', '\n', '        Approval(msg.sender, _approved, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Set approval for a third-party to manage all tokens of the caller.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _operator : address\n', '     *     The address to set the operator status for.\n', '     * _approved : bool\n', '     *     The operator status. True if the given address should be allowed to\n', '     *     act on behalf of the caller, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * There is no duplicate checking done out of simplicity. Callers are thus\n', '     * able to set the same address as operator a multitude of times, even if\n', '     * it does not change the actual state of the system.\n', '     */\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        operators[msg.sender][_operator] = _approved;\n', '\n', '        ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    /**\n', '     * Get approved address for given token.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token of which to get the approved address of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * address\n', '     *     The address that is allowed to initiate a transfer of the given\n', '     *     token.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Technically this method could be implemented without the method modifier\n', '     * as the network guarantees that the address mapping is initiated with all\n', '     * addresses set to the zero address. The requirement is implemented to\n', '     * comply with the standard as described in EIP-721.\n', '     */\n', '    function getApproved(\n', '        uint256 _tokenId\n', '    )\n', '        external\n', '        view\n', '        onlyValidToken(_tokenId)\n', '        returns (address)\n', '    {\n', '        return approvedTransfers[_tokenId];\n', '    }\n', '\n', '    /**\n', '     * Check whether an address is an authorized operator of another address.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of which to check whether it has approved the other\n', '     *     address to act as operator.\n', '     * _operator : address\n', '     *     The address of which to check whether it has been approved to act\n', '     *     as operator on behalf of `_owner`.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if `_operator` is approved for all actions on behalf of\n', '     *     `_owner`.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method cannot fail, as the Ethereum network guarantees that all\n', '     * address mappings exist and are set to the zero address by default.\n', '     */\n', '    function isApprovedForAll(\n', '        address _owner,\n', '        address _operator\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return operators[_owner][_operator];\n', '    }\n', '\n', '    /**\n', '     * Get the total number of tokens currently in circulation.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The total number of tokens currently in circulation.\n', '     */\n', '    function totalSupply() external view returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    /**\n', '     * Get token identifier by index.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _index : uint256\n', '     *     The index of the token to get the identifier of.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The identifier of the token at given index.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * Ethergotchi tokens are incrementally numbered starting from zero, and\n', '     * always go up by one. The index of the token is thus equivalent to its\n', '     * identifier.\n', '     */\n', '    function tokenByIndex(uint256 _index) external view returns (uint256) {\n', '        require(_index < totalTokens);\n', '\n', '        return _index;\n', '    }\n', '\n', '    /**\n', '     * Get token of owner by index.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _owner : address\n', '     *     The address of the owner of which to get the token of.\n', '     * _index : uint256\n', '     *     The index of the token in the given owner"s list of token.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * uint256\n', '     *     The identifier of the token at given index of an owner"s list of\n', '     *     tokens.\n', '     */\n', '    function tokenOfOwnerByIndex(\n', '        address _owner,\n', '        uint256 _index\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(_index < tokenIdsByOwner[_owner].length);\n', '\n', '        return tokenIdsByOwner[_owner][_index];\n', '    }\n', '\n', '    /**\n', '     * Check whether given address is a smart contract.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _address : address\n', '     *     The address of which to check whether it is a contract.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if given address is a contract, else False.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method works as long as the `Serenity` update of Ethereum has not\n', '     * been deployed. At the time of writing, contracts cannot set their code\n', '     * size to zero, nor can "normal" addresses set their code size to anything\n', '     * non-zero. With `Serenity` the idea will be that each and every address\n', '     * is an contract, effectively rendering this method.\n', '     */\n', '    function _isContract(address _address) internal view returns (bool) {\n', '        uint size;\n', '\n', '        assembly {\n', '            size := extcodesize(_address)\n', '        }\n', '\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * Transfer the ownership of given token from one address to another.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _from : address\n', '     *     The benefactor address to transfer the given token from.\n', '     * _to : address\n', '     *     The beneficiary address to transfer the given token to.\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to transfer.\n', '     * data : bytes\n', '     *     Non-specified data to send along the transfer towards the `to`\n', '     *     address that can be processed.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs a check to determine whether the receiving party is\n', '     * a smart contract by calling the `_isContract` method. This works until\n', '     * the `Serenity` update of Ethereum is deployed.\n', '     */\n', '    function _safeTransferFrom(\n', '        address _from, \n', '        address _to, \n', '        uint256 _tokenId,\n', '        bytes data\n', '    )\n', '        internal\n', '        onlyValidTransfers(_from, _to, _tokenId)\n', '    {\n', '        // Call the method that performs the actual transfer. All common cases\n', '        // of "wrong" transfers have already been checked at this point. The\n', '        // internal transfer method does no checking.\n', '        _transfer(_to, _tokenId);\n', '\n', '        // Check whether the receiving party is a contract, and if so, call\n', '        // the `onERC721Received` method as defined in the ERC-721 standard.\n', '        if (_isContract(_to)) {\n', '\n', '            // Assume the receiving party has implemented ERC721TokenReceiver,\n', '            // as otherwise the "unsafe" `transferFrom` method should have been\n', '            // called instead.\n', '            ERC721TokenReceiver _receiver = ERC721TokenReceiver(_to);\n', '\n', '            // The response returned by `onERC721Received` of the receiving\n', '            // contract"s `on *must* be equal to the magic number defined by\n', '            // the ERC-165 signature of `ERC721TokenReceiver`. If this is not\n', '            // the case, the transaction will be reverted.\n', '            require(\n', '                _receiver.onERC721Received(\n', '                    address(this),\n', '                    _tokenId,\n', '                    data\n', '                ) == INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer token to new owner.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _to : address\n', '     *     The address of the owner-to-be of given token.\n', '     * _tokenId : _tokenId\n', '     *     The identifier of the token that is to be transferred.\n', '     *\n', '     * Notice\n', '     * ------\n', '     * This method performs no safety checks as it can only be called within\n', '     * the controlled environment of this contract.\n', '     */\n', '    function _transfer(address _to, uint256 _tokenId) internal {\n', '        // Get current owner of the token. It is technically possible that the\n', '        // owner is the same address as the address to which the token is to be\n', '        // sent to. In this case the token will be moved to the end of the list\n', '        // of tokens owned by this address.\n', '        address _from = ownerByTokenId[_tokenId];\n', '\n', '        // There are two possible scenarios for transfers when it comes to the\n', '        // removal of the token from the side that currently owns the token:\n', '        //  1: the owner has two or more tokens; or\n', '        //  2: the owner has one token.\n', '        if (tokenIdsByOwner[_from].length > 1) {\n', '\n', '            // Get the index of the token that has to be removed from the list\n', '            // of tokens owned by the current owner.\n', '            uint256 tokenIndexToDelete = ownerTokenIndexByTokenId[_tokenId];\n', '\n', '            // To keep the list of tokens without gaps, and thus reducing the\n', '            // gas cost associated with interacting with the list, the last\n', '            // token in the owner"s list of tokens is moved to fill the gap\n', '            // created by removing the token.\n', '            uint256 tokenIndexToMove = tokenIdsByOwner[_from].length - 1;\n', '\n', '            // Overwrite the token that is to be removed with the token that\n', '            // was at the end of the list. It is possible that both are one and\n', '            // the same, in which case nothing happens.\n', '            tokenIdsByOwner[_from][tokenIndexToDelete] =\n', '                tokenIdsByOwner[_from][tokenIndexToMove];\n', '        }\n', '\n', '        // Remove the last item in the list of tokens owned by the current\n', '        // owner. This item has either already been copied to the location of\n', '        // the token that is to be transferred, or is the only token of this\n', '        // owner in which case the list of tokens owned by this owner is now\n', '        // empty.\n', '        tokenIdsByOwner[_from].length--;\n', '\n', '        // Add the token to the list of tokens owned by `_to`. Items are always\n', '        // added to the very end of the list. This makes the token index of the\n', '        // new token within the owner"s list of tokens equal to the length of\n', '        // the list minus one as Solidity is a zero-based language. This token\n', '        // index is then set for this token identifier.\n', '        tokenIdsByOwner[_to].push(_tokenId);\n', '        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_to].length - 1;\n', '\n', '        // Set the direct ownership information of the token to the new owner\n', '        // after all other ownership-related mappings have been updated to make\n', '        // sure the "side" data is correct.\n', '        ownerByTokenId[_tokenId] = _to;\n', '\n', '        // Remove the approved address of this token. It may be the case there\n', '        // was no approved address, in which case nothing changes.\n', '        approvedTransfers[_tokenId] = address(0);\n', '\n', '        // Log the transfer event onto the blockchain to leave behind an audit\n', '        // trail of all transfers that have taken place.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    /**\n', '     * Add new token into circulation.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _tokenId : uint256\n', '     *     The identifier of the token to add into circulation.\n', '     * _owner : address\n', '     *     The address of the owner who receives the newly added token.\n', '     */\n', '    function _add(uint256 _tokenId, address _owner) internal {\n', '        // Ensure the token does not already exist, and prevent duplicate calls\n', '        // using the same identifier.\n', '        require(ownerByTokenId[_tokenId] == address(0));\n', '\n', '        // Update the direct ownership mapping, by setting the owner of the\n', '        // token identifier to `_owner`, and adding the token to the list of\n', '        // tokens owned by `_owner`. Arrays are always initialized to empty\n', '        // versions of of their specific type, thus ensuring that the `push`\n', '        // method will not fail.\n', '        ownerByTokenId[_tokenId] = _owner;\n', '        tokenIdsByOwner[_owner].push(_tokenId);\n', '\n', '        // Update the mapping that keeps track of a token"s index within the\n', '        // list of tokens owned by each owner. At the time of addition a token\n', '        // is always added to the end of the list, and will thus always equal\n', '        // the number of tokens already in the list, minus one, because the\n', '        // arrays within Solidity are zero-based.\n', '        ownerTokenIndexByTokenId[_tokenId] = tokenIdsByOwner[_owner].length - 1;\n', '\n', '        totalTokens += 1;\n', '    }\n', '\n', '    /*********************************************/\n', '    /** MIGRATION state variables and functions **/\n', '    /*********************************************/\n', '\n', '    // This number is used to keep track of how many tokens have been migrated.\n', '    // The number cannot exceed the number of tokens that were assigned to\n', '    // owners in the previous Ownership contract.\n', '    uint256 public migrationIndex;\n', '\n', '    // The previous token ownership contract.\n', '    PartialOwnership private formerContract;\n', '\n', '    /**\n', '     * Migrate data from the former Ethergotchi ownership contract.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _count : uint256\n', '     *     The number of tokens to migrate in a single transaction.\n', '     *\n', '     * Notice\n', '     * ------\n', "     * This method is limited in use to ensure no 'malicious' calls are made.\n", '     * Additionally, this method writes to a contract state variable to keep\n', '     * track of how many tokens have been migrated.\n', '     */\n', '    function migrate(uint256 _count) external onlyOwner {\n', '        // Ensure that the migrate function can *only* be called in a specific\n', '        // time period. This period ranges from Saturday, March 24th, 00:00:00\n', '        // UTC until Sunday, March 25th, 23:59:59 UTC.\n', '        require(1521849600 <= now && now <= 1522022399);\n', '\n', '        // Get the maximum number of tokens handed out by the previous\n', '        // ownership contract.\n', '        uint256 formerTokenCount = formerContract.totalSupply();\n', '\n', '        // The index to stop the migration at for this transaction.\n', '        uint256 endIndex = migrationIndex + _count;\n', '\n', '        // It is possible that the final transaction has a higher end index\n', '        // than there are a number of tokens. In this case, the end index is\n', '        // reduced to ensure no non-existent tokens are migrated.\n', '        if (endIndex >= formerTokenCount) {\n', '            endIndex = formerTokenCount;\n', '        }\n', '\n', '        // Loop through the token identifiers to migrate in this transaction.\n', "        // Token identifiers are equivalent to their 'index', as identifiers\n", '        // start at zero (with the zeroth token being owned by the zero\n', '        // address), and are incremented by one for each new token.\n', '        for (uint256 i = migrationIndex; i < endIndex; i++) {\n', '            address tokenOwner;\n', '\n', '            // There was a malicious account that acquired over 400 eggs via\n', '            // referral codes, which breaks the terms of use. The acquired egg\n', '            // numbers ranged from identifier 1247 up until 1688, excluding\n', '            // 1296, 1297, 1479, 1492, 1550, 1551, and 1555. This was found by\n', '            // looking at activity on the pick-up contract, and tracing it back\n', '            // to the following address:\n', '            //  `0c7a911ac29ea1e3b1d438f98f8bc053131dcaf52`\n', '            if (_isExcluded(i)) {\n', '                tokenOwner = address(0);\n', '            } else {\n', '                tokenOwner = formerContract.ownerOf(i);\n', '            }\n', '\n', '            // Assign the token to the same address that owned it in the\n', '            // previous ownership contract.\n', '            _add(i, tokenOwner);\n', '\n', "            // Log the token transfer. In this case where the token is 'newly'\n", '            // created, but actually transferred from a previous contract, the\n', '            // `_from` address is set to the previous contract address, to\n', '            // signify a migration.\n', '            Transfer(address(formerContract), tokenOwner, i);\n', '        }\n', '\n', '        // Set the new migration index to where the current transaction ended\n', '        // its migration.\n', '        migrationIndex = endIndex;\n', '    }\n', '\n', '    /**\n', '     * Check if Ethergotchi should be excluded from migration.\n', '     *\n', '     * Parameters\n', '     * ----------\n', '     * _gotchiId : uint256\n', '     *     The identifier of the Ethergotchi of which to check the exclusion\n', '     *     status.\n', '     *\n', '     * Returns\n', '     * -------\n', '     * bool\n', '     *     True if the Ethergotchi should be excluded from the migration, else\n', '     *     False.\n', '     */\n', '    function _isExcluded(uint256 _gotchiId) internal pure returns (bool) {\n', '        return\n', '            1247 <= _gotchiId && _gotchiId <= 1688 &&\n', '            _gotchiId != 1296 &&\n', '            _gotchiId != 1297 &&\n', '            _gotchiId != 1479 &&\n', '            _gotchiId != 1492 &&\n', '            _gotchiId != 1550 &&\n', '            _gotchiId != 1551 &&\n', '            _gotchiId != 1555;\n', '    }\n', '}']
