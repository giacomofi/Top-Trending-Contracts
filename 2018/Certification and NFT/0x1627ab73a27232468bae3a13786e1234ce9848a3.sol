['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/interfaces/IOwned.sol\n', '\n', '/*\n', '    Owned Contract Interface\n', '*/\n', 'contract IOwned {\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '    function transferOwnershipNow(address newContractOwner) public;\n', '}\n', '\n', '// File: contracts/utility/Owned.sol\n', '\n', '/*\n', '    This is the "owned" utility contract used by bancor with one additional function - transferOwnershipNow()\n', '    \n', '    The original unmodified version can be found here:\n', '    https://github.com/bancorprotocol/contracts/commit/63480ca28534830f184d3c4bf799c1f90d113846\n', '    \n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    /**\n', '        @dev transfers the contract ownership without needing the new owner to accept ownership\n', '        @param newContractOwner    new contract owner\n', '    */\n', '    function transferOwnershipNow(address newContractOwner) ownerOnly public {\n', '        require(newContractOwner != owner);\n', '        emit OwnerUpdate(owner, newContractOwner);\n', '        owner = newContractOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/utility/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' * From https://github.com/OpenZeppelin/openzeppelin-solidity/commit/a2e710386933d3002062888b35aae8ac0401a7b3\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', '        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', '/*\n', '    Smart Token Interface\n', '*/\n', 'contract IERC20 {\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// File: contracts/interfaces/ISmartToken.sol\n', '\n', '/**\n', '    @notice Smart Token Interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20 {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '// File: contracts/SmartToken.sol\n', '\n', '/*\n', '\n', 'This contract implements the required functionality to be considered a Bancor smart token.\n', 'Additionally it has custom token sale functionality and the ability to withdraw tokens accidentally deposited\n', '\n', '// TODO abstract this into 3 contracts and inherit from them: 1) ERC20, 2) Smart Token, 3) Native specific functionality\n', '*/\n', 'contract SmartToken is Owned, IERC20, ISmartToken {\n', '\n', '    /**\n', '        Smart Token Implementation\n', '    */\n', '\n', '    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\n', '    /// @notice Triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '    /// @notice Triggered when the total supply is increased\n', '    event Issuance(uint256 _amount);\n', '    // @notice Triggered when the total supply is decreased\n', '    event Destruction(uint256 _amount);\n', '\n', '    // @notice Verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier transfersAllowed {\n', '        assert(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    /// @notice Validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev disables/enables transfers\n', '        can only be called by the contract owner\n', '        @param _disable    true to disable transfers, false to enable them\n', '    */\n', '    function disableTransfers(bool _disable) public ownerOnly {\n', '        transfersEnabled = !_disable;\n', '    }\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account\n', '        can only be called by the contract owner\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function issue(address _to, uint256 _amount)\n', '    public\n', '    ownerOnly\n', '    validAddress(_to)\n', '    notThis(_to)\n', '    {\n', '        totalSupply = SafeMath.add(totalSupply, _amount);\n', '        balances[_to] = SafeMath.add(balances[_to], _amount);\n', '        emit Issuance(_amount);\n', '        emit Transfer(this, _to, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev removes tokens from an account and decreases the token supply\n', '        can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account\n', '        @param _from       account to remove the amount from\n', '        @param _amount     amount to decrease the supply by\n', '    */\n', '    function destroy(address _from, uint256 _amount) public {\n', '        require(msg.sender == _from || msg.sender == owner); // validate input\n', '        balances[_from] = SafeMath.sub(balances[_from], _amount);\n', '        totalSupply = SafeMath.sub(totalSupply, _amount);\n', '\n', '        emit Transfer(_from, this, _amount);\n', '        emit Destruction(_amount);\n', '    }\n', '\n', '    /**\n', '        @notice ERC20 Implementation\n', '    */\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _to != address(0)) {\n', '            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _to != address(0)) {\n', '\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            balances[_from] = SafeMath.sub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    string public version;\n', '\n', '    constructor(string _name, uint _totalSupply, uint8 _decimals, string _symbol, string _version, address sender) public {\n', '        balances[sender] = _totalSupply;               // Give the creator all initial tokens\n', '        totalSupply = _totalSupply;                        // Update total supply\n', '        name = _name;                                   // Set the name for display purposes\n', '        decimals = _decimals;                            // Amount of decimals for display purposes\n', '        symbol = _symbol;                               // Set the symbol for display purposes\n', '        version = _version;\n', '\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '    /**\n', '        @notice Token Sale Implementation\n', '    */\n', '    uint public saleStartTime;\n', '    uint public saleEndTime;\n', '    uint public price;\n', '    uint public amountRemainingForSale;\n', '    bool public buyModeEth = true;\n', '    address public beneficiary;\n', '    address public payableTokenAddress;\n', '\n', '    event TokenSaleInitialized(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, uint nowTime);\n', '    event TokensPurchased(address buyer, uint amount);\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account.  Similar to issue() but for use in token sale\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function issuePurchase(address _to, uint256 _amount)\n', '    internal\n', '    validAddress(_to)\n', '    notThis(_to)\n', '    {\n', '        totalSupply = SafeMath.add(totalSupply, _amount);\n', '        balances[_to] = SafeMath.add(balances[_to], _amount);\n', '        emit Issuance(_amount);\n', '        emit Transfer(this, _to, _amount);\n', '    }\n', '\n', '    /**\n', '        @notice Begins the token sale for this token instance\n', '        @param _saleStartTime Unix timestamp of the token sale start\n', '        @param _saleEndTime Unix timestamp of the token sale close\n', '        @param _price If sale initialized in ETH: price in Wei.\n', '                If not, token purchases are enabled and this is the amount of tokens issued per tokens paid\n', '        @param _amountForSale Amount of tokens for sale\n', '        @param _beneficiary Recipient of the token sale proceeds\n', '    */\n', '    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public ownerOnly {\n', '        // Check that the token sale has not yet been initialized\n', '        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);\n', '    }\n', '    /**\n', '        @notice Begins the token sale for this token instance\n', '        @notice Uses the same signature as initializeTokenSale() with:\n', '        @param _tokenAddress The whitelisted token address to allow payments in\n', '    */\n', '    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public ownerOnly {\n', '        buyModeEth = false;\n', '        payableTokenAddress = _tokenAddress;\n', '        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);\n', '    }\n', '\n', '    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {\n', '        // Check that the token sale has not yet been initialized\n', '        require(saleStartTime == 0);\n', '        saleStartTime = _saleStartTime;\n', '        saleEndTime = _saleEndTime;\n', '        price = _price;\n', '        amountRemainingForSale = _amountForSale;\n', '        beneficiary = _beneficiary;\n', '        emit TokenSaleInitialized(saleStartTime, saleEndTime, price, amountRemainingForSale, now);\n', '    }\n', '\n', '    function updateStartTime(uint _newSaleStartTime) public ownerOnly {\n', '        saleStartTime = _newSaleStartTime;\n', '    }\n', '\n', '    function updateEndTime(uint _newSaleEndTime) public ownerOnly {\n', '        require(_newSaleEndTime >= saleStartTime);\n', '        saleEndTime = _newSaleEndTime;\n', '    }\n', '\n', '    function updateAmountRemainingForSale(uint _newAmountRemainingForSale) public ownerOnly {\n', '        amountRemainingForSale = _newAmountRemainingForSale;\n', '    }\n', '\n', '    function updatePrice(uint _newPrice) public ownerOnly { \n', '        price = _newPrice;\n', '    }\n', '\n', '    /// @dev Allows owner to withdraw erc20 tokens that were accidentally sent to this contract\n', '    function withdrawToken(IERC20 _token, uint amount) public ownerOnly {\n', '        _token.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Allows token sale with parent token\n', '    */\n', '    function buyWithToken(IERC20 _token, uint amount) public payable {\n', '        require(_token == payableTokenAddress);\n', '        uint amountToBuy = SafeMath.mul(amount, price);\n', '        require(amountToBuy <= amountRemainingForSale);\n', '        require(now <= saleEndTime && now >= saleStartTime);\n', '        amountRemainingForSale = SafeMath.sub(amountRemainingForSale, amountToBuy);\n', '        require(_token.transferFrom(msg.sender, beneficiary, amount));\n', '        issuePurchase(msg.sender, amountToBuy);\n', '        emit TokensPurchased(msg.sender, amountToBuy);\n', '    }\n', '\n', '    function() public payable {\n', '        require(buyModeEth == true);\n', '        uint amountToBuy = SafeMath.div( SafeMath.mul(msg.value, 1 ether), price);\n', '        require(amountToBuy <= amountRemainingForSale);\n', '        require(now <= saleEndTime && now >= saleStartTime);\n', '        amountRemainingForSale = SafeMath.sub(amountRemainingForSale, amountToBuy);\n', '        issuePurchase(msg.sender, amountToBuy);\n', '        beneficiary.transfer(msg.value);\n', '        emit TokensPurchased(msg.sender, amountToBuy);\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/interfaces/IOwned.sol\n', '\n', '/*\n', '    Owned Contract Interface\n', '*/\n', 'contract IOwned {\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '    function transferOwnershipNow(address newContractOwner) public;\n', '}\n', '\n', '// File: contracts/utility/Owned.sol\n', '\n', '/*\n', '    This is the "owned" utility contract used by bancor with one additional function - transferOwnershipNow()\n', '    \n', '    The original unmodified version can be found here:\n', '    https://github.com/bancorprotocol/contracts/commit/63480ca28534830f184d3c4bf799c1f90d113846\n', '    \n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    /**\n', '        @dev transfers the contract ownership without needing the new owner to accept ownership\n', '        @param newContractOwner    new contract owner\n', '    */\n', '    function transferOwnershipNow(address newContractOwner) ownerOnly public {\n', '        require(newContractOwner != owner);\n', '        emit OwnerUpdate(owner, newContractOwner);\n', '        owner = newContractOwner;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/utility/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' * From https://github.com/OpenZeppelin/openzeppelin-solidity/commit/a2e710386933d3002062888b35aae8ac0401a7b3\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', '/*\n', '    Smart Token Interface\n', '*/\n', 'contract IERC20 {\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// File: contracts/interfaces/ISmartToken.sol\n', '\n', '/**\n', '    @notice Smart Token Interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20 {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '// File: contracts/SmartToken.sol\n', '\n', '/*\n', '\n', 'This contract implements the required functionality to be considered a Bancor smart token.\n', 'Additionally it has custom token sale functionality and the ability to withdraw tokens accidentally deposited\n', '\n', '// TODO abstract this into 3 contracts and inherit from them: 1) ERC20, 2) Smart Token, 3) Native specific functionality\n', '*/\n', 'contract SmartToken is Owned, IERC20, ISmartToken {\n', '\n', '    /**\n', '        Smart Token Implementation\n', '    */\n', '\n', '    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\n', '    /// @notice Triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '    /// @notice Triggered when the total supply is increased\n', '    event Issuance(uint256 _amount);\n', '    // @notice Triggered when the total supply is decreased\n', '    event Destruction(uint256 _amount);\n', '\n', '    // @notice Verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier transfersAllowed {\n', '        assert(transfersEnabled);\n', '        _;\n', '    }\n', '\n', "    /// @notice Validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev disables/enables transfers\n', '        can only be called by the contract owner\n', '        @param _disable    true to disable transfers, false to enable them\n', '    */\n', '    function disableTransfers(bool _disable) public ownerOnly {\n', '        transfersEnabled = !_disable;\n', '    }\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account\n', '        can only be called by the contract owner\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function issue(address _to, uint256 _amount)\n', '    public\n', '    ownerOnly\n', '    validAddress(_to)\n', '    notThis(_to)\n', '    {\n', '        totalSupply = SafeMath.add(totalSupply, _amount);\n', '        balances[_to] = SafeMath.add(balances[_to], _amount);\n', '        emit Issuance(_amount);\n', '        emit Transfer(this, _to, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev removes tokens from an account and decreases the token supply\n', '        can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account\n', '        @param _from       account to remove the amount from\n', '        @param _amount     amount to decrease the supply by\n', '    */\n', '    function destroy(address _from, uint256 _amount) public {\n', '        require(msg.sender == _from || msg.sender == owner); // validate input\n', '        balances[_from] = SafeMath.sub(balances[_from], _amount);\n', '        totalSupply = SafeMath.sub(totalSupply, _amount);\n', '\n', '        emit Transfer(_from, this, _amount);\n', '        emit Destruction(_amount);\n', '    }\n', '\n', '    /**\n', '        @notice ERC20 Implementation\n', '    */\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _to != address(0)) {\n', '            balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _to != address(0)) {\n', '\n', '            balances[_to] = SafeMath.add(balances[_to], _value);\n', '            balances[_from] = SafeMath.sub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    string public version;\n', '\n', '    constructor(string _name, uint _totalSupply, uint8 _decimals, string _symbol, string _version, address sender) public {\n', '        balances[sender] = _totalSupply;               // Give the creator all initial tokens\n', '        totalSupply = _totalSupply;                        // Update total supply\n', '        name = _name;                                   // Set the name for display purposes\n', '        decimals = _decimals;                            // Amount of decimals for display purposes\n', '        symbol = _symbol;                               // Set the symbol for display purposes\n', '        version = _version;\n', '\n', '        emit NewSmartToken(address(this));\n', '    }\n', '\n', '    /**\n', '        @notice Token Sale Implementation\n', '    */\n', '    uint public saleStartTime;\n', '    uint public saleEndTime;\n', '    uint public price;\n', '    uint public amountRemainingForSale;\n', '    bool public buyModeEth = true;\n', '    address public beneficiary;\n', '    address public payableTokenAddress;\n', '\n', '    event TokenSaleInitialized(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, uint nowTime);\n', '    event TokensPurchased(address buyer, uint amount);\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account.  Similar to issue() but for use in token sale\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function issuePurchase(address _to, uint256 _amount)\n', '    internal\n', '    validAddress(_to)\n', '    notThis(_to)\n', '    {\n', '        totalSupply = SafeMath.add(totalSupply, _amount);\n', '        balances[_to] = SafeMath.add(balances[_to], _amount);\n', '        emit Issuance(_amount);\n', '        emit Transfer(this, _to, _amount);\n', '    }\n', '\n', '    /**\n', '        @notice Begins the token sale for this token instance\n', '        @param _saleStartTime Unix timestamp of the token sale start\n', '        @param _saleEndTime Unix timestamp of the token sale close\n', '        @param _price If sale initialized in ETH: price in Wei.\n', '                If not, token purchases are enabled and this is the amount of tokens issued per tokens paid\n', '        @param _amountForSale Amount of tokens for sale\n', '        @param _beneficiary Recipient of the token sale proceeds\n', '    */\n', '    function initializeTokenSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) public ownerOnly {\n', '        // Check that the token sale has not yet been initialized\n', '        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);\n', '    }\n', '    /**\n', '        @notice Begins the token sale for this token instance\n', '        @notice Uses the same signature as initializeTokenSale() with:\n', '        @param _tokenAddress The whitelisted token address to allow payments in\n', '    */\n', '    function initializeTokenSaleWithToken(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary, address _tokenAddress) public ownerOnly {\n', '        buyModeEth = false;\n', '        payableTokenAddress = _tokenAddress;\n', '        initializeSale(_saleStartTime, _saleEndTime, _price, _amountForSale, _beneficiary);\n', '    }\n', '\n', '    function initializeSale(uint _saleStartTime, uint _saleEndTime, uint _price, uint _amountForSale, address _beneficiary) internal {\n', '        // Check that the token sale has not yet been initialized\n', '        require(saleStartTime == 0);\n', '        saleStartTime = _saleStartTime;\n', '        saleEndTime = _saleEndTime;\n', '        price = _price;\n', '        amountRemainingForSale = _amountForSale;\n', '        beneficiary = _beneficiary;\n', '        emit TokenSaleInitialized(saleStartTime, saleEndTime, price, amountRemainingForSale, now);\n', '    }\n', '\n', '    function updateStartTime(uint _newSaleStartTime) public ownerOnly {\n', '        saleStartTime = _newSaleStartTime;\n', '    }\n', '\n', '    function updateEndTime(uint _newSaleEndTime) public ownerOnly {\n', '        require(_newSaleEndTime >= saleStartTime);\n', '        saleEndTime = _newSaleEndTime;\n', '    }\n', '\n', '    function updateAmountRemainingForSale(uint _newAmountRemainingForSale) public ownerOnly {\n', '        amountRemainingForSale = _newAmountRemainingForSale;\n', '    }\n', '\n', '    function updatePrice(uint _newPrice) public ownerOnly { \n', '        price = _newPrice;\n', '    }\n', '\n', '    /// @dev Allows owner to withdraw erc20 tokens that were accidentally sent to this contract\n', '    function withdrawToken(IERC20 _token, uint amount) public ownerOnly {\n', '        _token.transfer(msg.sender, amount);\n', '    }\n', '\n', '    /**\n', '        @dev Allows token sale with parent token\n', '    */\n', '    function buyWithToken(IERC20 _token, uint amount) public payable {\n', '        require(_token == payableTokenAddress);\n', '        uint amountToBuy = SafeMath.mul(amount, price);\n', '        require(amountToBuy <= amountRemainingForSale);\n', '        require(now <= saleEndTime && now >= saleStartTime);\n', '        amountRemainingForSale = SafeMath.sub(amountRemainingForSale, amountToBuy);\n', '        require(_token.transferFrom(msg.sender, beneficiary, amount));\n', '        issuePurchase(msg.sender, amountToBuy);\n', '        emit TokensPurchased(msg.sender, amountToBuy);\n', '    }\n', '\n', '    function() public payable {\n', '        require(buyModeEth == true);\n', '        uint amountToBuy = SafeMath.div( SafeMath.mul(msg.value, 1 ether), price);\n', '        require(amountToBuy <= amountRemainingForSale);\n', '        require(now <= saleEndTime && now >= saleStartTime);\n', '        amountRemainingForSale = SafeMath.sub(amountRemainingForSale, amountToBuy);\n', '        issuePurchase(msg.sender, amountToBuy);\n', '        beneficiary.transfer(msg.value);\n', '        emit TokensPurchased(msg.sender, amountToBuy);\n', '    }\n', '}']
