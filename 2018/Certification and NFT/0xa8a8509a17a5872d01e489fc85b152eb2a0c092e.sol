['pragma solidity ^0.4.19;\n', '\n', '\n', '//\n', '// SVLightBallotBox\n', '// Single use contract to manage a ballot\n', '// Author: Max Kaye <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6e030f162e1d0b0d1b1c0b4018011a0b">[email&#160;protected]</a>>\n', '// License: MIT\n', '//\n', '// Architecture:\n', '// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\n', '// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\n', '// * These ballots are tracked by the ETH address of the sender\n', '// * Following the conclusion of the ballot, the secret key is provided\n', '//   by the ballot authority, and all users may transparently and\n', '//   independently validate the results\n', '//\n', '// Notes:\n', '// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\n', '//\n', '\n', '\n', 'contract SVLightBallotBox {\n', '    //// ** Storage Variables\n', '\n', '    // Std owner pattern\n', '    address public owner;\n', '\n', '    // test mode - operations like changing start/end times\n', '    bool public testMode = false;\n', '\n', '    // struct for ballot\n', '    struct Ballot {\n', '        bytes32 ballotData;\n', '        address sender;\n', '        // we use a uint32 here because addresses are 20 bytes and this might help\n', '        // solidity pack the block number well. gives us a little room to expand too if needed.\n', '        uint32 blockN;\n', '    }\n', '\n', '    // Maps to store ballots, along with corresponding log of voters.\n', '    // Should only be modified through `addBallotAndVoter` internal function\n', '    mapping (uint256 => Ballot) public ballotMap;\n', '    mapping (uint256 => bytes32) public associatedPubkeys;\n', '    uint256 public nVotesCast = 0;\n', '\n', '    // Use a map for voters to look up their ballot\n', '    mapping (address => uint256) public voterToBallotID;\n', '\n', '    // NOTE - We don&#39;t actually want to include the PublicKey because _it&#39;s included in the ballotSpec_.\n', '    // It&#39;s better to ensure ppl actually have the ballot spec by not including it in the contract.\n', '    // Plus we&#39;re already storing the hash of the ballotSpec anyway...\n', '\n', '    // Private key to be set after ballot conclusion - curve25519\n', '    bytes32 public ballotEncryptionSeckey;\n', '    bool seckeyRevealed = false;\n', '\n', '    // Timestamps for start and end of ballot (UTC)\n', '    uint64 public startTime;\n', '    uint64 public endTime;\n', '    uint64 public creationBlock;\n', '    uint64 public startingBlockAround;\n', '\n', '    // specHash by which to validate the ballots integrity\n', '    bytes32 public specHash;\n', '    bool public useEncryption;\n', '\n', '    // deprecation flag - doesn&#39;t actually do anything besides signal that this contract is deprecated;\n', '    bool public deprecated = false;\n', '\n', '    //// ** Events\n', '    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\n', '    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\n', '    event SuccessfulVote(address voter, bytes32 ballot);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event Error(string error);\n', '    event DeprecatedContract();\n', '    event SetOwner(address _owner);\n', '\n', '\n', '    //// ** Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier ballotOpen {\n', '        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTesting {\n', '        require(testMode);\n', '        _;\n', '    }\n', '\n', '    modifier isTrue(bool _b) {\n', '        require(_b == true);\n', '        _;\n', '    }\n', '\n', '    modifier isFalse(bool _b) {\n', '        require(_b == false);\n', '        _;\n', '    }\n', '\n', '    //// ** Functions\n', '\n', '    uint16 constant F_USE_ENC = 0;\n', '    uint16 constant F_TESTING = 1;\n', '    // Constructor function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    // flags are [_useEncryption, enableTesting]\n', '    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\n', '        owner = msg.sender;\n', '\n', '        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '        // (which someone might be able to do if they could set the timestamp in the past)\n', '        startTime = max(openPeriod[0], uint64(block.timestamp));\n', '        endTime = openPeriod[1];\n', '        useEncryption = flags[F_USE_ENC];\n', '        specHash = _specHash;\n', '        creationBlock = uint64(block.number);\n', '        // add a rough prediction of what block is the starting block\n', '        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\n', '\n', '        if (flags[F_TESTING]) {\n', '            testMode = true;\n', '            TestingEnabled();\n', '        }\n', '\n', '        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\n', '    }\n', '\n', '    // Ballot submission\n', '    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\n', '        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\n', '        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\n', '        addBallotAndVoterNoPk(ballot);\n', '        SuccessfulVote(msg.sender, ballot);\n', '    }\n', '\n', '    // Internal function to ensure atomicity of voter log\n', '    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\n', '        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\n', '        associatedPubkeys[ballotNumber] = senderPubkey;\n', '    }\n', '\n', '    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\n', '        uint256 ballotNumber = nVotesCast;\n', '        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\n', '        voterToBallotID[msg.sender] = ballotNumber;\n', '        nVotesCast += 1;\n', '        return ballotNumber;\n', '    }\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(bytes32 _secKey) onlyOwner public {\n', '        require(block.timestamp > endTime);\n', '\n', '        ballotEncryptionSeckey = _secKey;\n', '        seckeyRevealed = true; // this flag allows the contract to be locked\n', '        SeckeyRevealed(_secKey);\n', '    }\n', '\n', '    function getEncSeckey() public constant returns (bytes32) {\n', '        return ballotEncryptionSeckey;\n', '    }\n', '\n', '    // Test functions\n', '    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\n', '        endTime = newEndTime;\n', '    }\n', '\n', '    function setDeprecated() onlyOwner public {\n', '        deprecated = true;\n', '        DeprecatedContract();\n', '    }\n', '\n', '    function setOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '        SetOwner(newOwner);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '\n', '//\n', '// The Index by which democracies and ballots are tracked (and optionally deployed).\n', '// Author: Max Kaye <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ed808c95ad9e888e989f88c39b829988">[email&#160;protected]</a>>\n', '// License: MIT\n', '//\n', '\n', 'contract SVLightIndex {\n', '\n', '    address public owner;\n', '\n', '    struct Ballot {\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTs;\n', '    }\n', '\n', '    struct Democ {\n', '        string name;\n', '        address admin;\n', '        Ballot[] ballots;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) public democs;\n', '    bytes32[] public democList;\n', '\n', '    // addresses that do not have to pay for democs\n', '    mapping (address => bool) public democWhitelist;\n', '    // democs that do not have to pay for issues\n', '    mapping (address => bool) public ballotWhitelist;\n', '\n', '    // payment details\n', '    address public payTo;\n', '    // uint128&#39;s used because they account for amounts up to 3.4e38 wei or 3.4e20 ether\n', '    uint128 public democFee = 0.05 ether; // 0.05 ether; about $50 at 3 March 2018\n', '    mapping (address => uint128) democFeeFor;\n', '    uint128 public ballotFee = 0.01 ether; // 0.01 ether; about $10 at 3 March 2018\n', '    mapping (address => uint128) ballotFeeFor;\n', '    bool public paymentEnabled = true;\n', '\n', '    uint8 constant PAY_DEMOC = 0;\n', '    uint8 constant PAY_BALLOT = 1;\n', '\n', '    function getPaymentParams(uint8 paymentType) internal constant returns (bool, uint128, uint128) {\n', '        if (paymentType == PAY_DEMOC) {\n', '            return (democWhitelist[msg.sender], democFee, democFeeFor[msg.sender]);\n', '        } else if (paymentType == PAY_BALLOT) {\n', '            return (ballotWhitelist[msg.sender], ballotFee, ballotFeeFor[msg.sender]);\n', '        } else {\n', '            assert(false);\n', '        }\n', '    }\n', '\n', '    //* EVENTS /\n', '\n', '    event PaymentMade(uint128[2] valAndRemainder);\n', '    event DemocInit(string name, bytes32 democHash, address admin);\n', '    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\n', '    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\n', '    event SetFees(uint128[2] _newFees);\n', '    event PaymentEnabled(bool _feeEnabled);\n', '\n', '    //* MODIFIERS /\n', '\n', '    modifier onlyBy(address _account) {\n', '        require(msg.sender == _account);\n', '        _;\n', '    }\n', '\n', '    modifier payReq(uint8 paymentType) {\n', '        // get our whitelist, generalFee, and fee&#39;s for particular addresses\n', '        bool wl;\n', '        uint128 genFee;\n', '        uint128 feeFor;\n', '        (wl, genFee, feeFor) = getPaymentParams(paymentType);\n', '        // init v to something large in case of exploit or something\n', '        uint128 v = 1000 ether;\n', '        // check whitelists - do not require payment in some cases\n', '        if (paymentEnabled && !wl) {\n', '            v = feeFor;\n', '            if (v == 0){\n', '                // if there&#39;s no fee for the individual user then set it to the general fee\n', '                v = genFee;\n', '            }\n', '            require(msg.value >= v);\n', '\n', '            // handle payments\n', '            uint128 remainder = uint128(msg.value) - v;\n', '            payTo.transfer(v); // .transfer so it throws on failure\n', '            if (!msg.sender.send(remainder)){\n', '                payTo.transfer(remainder);\n', '            }\n', '            PaymentMade([v, remainder]);\n', '        }\n', '\n', '        // do main\n', '        _;\n', '    }\n', '\n', '\n', '    //* FUNCTIONS /\n', '\n', '\n', '    // constructor\n', '    function SVLightIndex() public {\n', '        owner = msg.sender;\n', '        payTo = msg.sender;\n', '    }\n', '\n', '    //* GLOBAL INFO */\n', '\n', '    function nDemocs() public constant returns (uint256) {\n', '        return democList.length;\n', '    }\n', '\n', '    //* PAYMENT AND OWNER FUNCTIONS */\n', '\n', '    function setPayTo(address newPayTo) onlyBy(owner) public {\n', '        payTo = newPayTo;\n', '    }\n', '\n', '    function setEth(uint128[2] newFees) onlyBy(owner) public {\n', '        democFee = newFees[PAY_DEMOC];\n', '        ballotFee = newFees[PAY_BALLOT];\n', '        SetFees([democFee, ballotFee]);\n', '    }\n', '\n', '    function setOwner(address _owner) onlyBy(owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setPaymentEnabled(bool _enabled) onlyBy(owner) public {\n', '        paymentEnabled = _enabled;\n', '        PaymentEnabled(_enabled);\n', '    }\n', '\n', '    function setWhitelistDemoc(address addr, bool _free) onlyBy(owner) public {\n', '        democWhitelist[addr] = _free;\n', '    }\n', '\n', '    function setWhitelistBallot(address addr, bool _free) onlyBy(owner) public {\n', '        ballotWhitelist[addr] = _free;\n', '    }\n', '\n', '    function setFeeFor(address addr, uint128[2] fees) onlyBy(owner) public {\n', '        democFeeFor[addr] = fees[PAY_DEMOC];\n', '        ballotFeeFor[addr] = fees[PAY_BALLOT];\n', '    }\n', '\n', '    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\n', '\n', '    function initDemoc(string democName) payReq(PAY_DEMOC) public payable returns (bytes32) {\n', '        bytes32 democHash = keccak256(democName, msg.sender, democList.length, this);\n', '        democList.push(democHash);\n', '        democs[democHash].name = democName;\n', '        democs[democHash].admin = msg.sender;\n', '        DemocInit(democName, democHash, msg.sender);\n', '        return democHash;\n', '    }\n', '\n', '    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\n', '        return (democs[democHash].name, democs[democHash].admin, democs[democHash].ballots.length);\n', '    }\n', '\n', '    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    function nBallots(bytes32 democHash) public constant returns (uint256) {\n', '        return democs[democHash].ballots.length;\n', '    }\n', '\n', '    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\n', '        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\n', '        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\n', '        BallotAdded(democHash, specHash, extraData, votingContract);\n', '    }\n', '\n', '    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\n', '                      onlyBy(democs[democHash].admin)\n', '                      payReq(PAY_BALLOT)\n', '                      public\n', '                      payable\n', '                      {\n', '        SVLightBallotBox bb = SVLightBallotBox(votingContract);\n', '        bytes32 specHash = bb.specHash();\n', '        uint64 startTs = bb.startTime();\n', '        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\n', '    }\n', '\n', '    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\n', '                          uint64[2] openPeriod, bool[2] flags)\n', '                          onlyBy(democs[democHash].admin)\n', '                          payReq(PAY_BALLOT)\n', '                          public payable {\n', '        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\n', '        // token holders who have recently acquired tokens.\n', '        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\n', '        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\n', '        votingContract.setOwner(msg.sender);\n', '        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\n', '        BallotInit(specHash, [startTs, openPeriod[1]], flags);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '\n', '//\n', '// SVLightBallotBox\n', '// Single use contract to manage a ballot\n', '// Author: Max Kaye <max@secure.vote>\n', '// License: MIT\n', '//\n', '// Architecture:\n', '// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\n', '// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\n', '// * These ballots are tracked by the ETH address of the sender\n', '// * Following the conclusion of the ballot, the secret key is provided\n', '//   by the ballot authority, and all users may transparently and\n', '//   independently validate the results\n', '//\n', '// Notes:\n', '// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\n', '//\n', '\n', '\n', 'contract SVLightBallotBox {\n', '    //// ** Storage Variables\n', '\n', '    // Std owner pattern\n', '    address public owner;\n', '\n', '    // test mode - operations like changing start/end times\n', '    bool public testMode = false;\n', '\n', '    // struct for ballot\n', '    struct Ballot {\n', '        bytes32 ballotData;\n', '        address sender;\n', '        // we use a uint32 here because addresses are 20 bytes and this might help\n', '        // solidity pack the block number well. gives us a little room to expand too if needed.\n', '        uint32 blockN;\n', '    }\n', '\n', '    // Maps to store ballots, along with corresponding log of voters.\n', '    // Should only be modified through `addBallotAndVoter` internal function\n', '    mapping (uint256 => Ballot) public ballotMap;\n', '    mapping (uint256 => bytes32) public associatedPubkeys;\n', '    uint256 public nVotesCast = 0;\n', '\n', '    // Use a map for voters to look up their ballot\n', '    mapping (address => uint256) public voterToBallotID;\n', '\n', "    // NOTE - We don't actually want to include the PublicKey because _it's included in the ballotSpec_.\n", "    // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\n", "    // Plus we're already storing the hash of the ballotSpec anyway...\n", '\n', '    // Private key to be set after ballot conclusion - curve25519\n', '    bytes32 public ballotEncryptionSeckey;\n', '    bool seckeyRevealed = false;\n', '\n', '    // Timestamps for start and end of ballot (UTC)\n', '    uint64 public startTime;\n', '    uint64 public endTime;\n', '    uint64 public creationBlock;\n', '    uint64 public startingBlockAround;\n', '\n', '    // specHash by which to validate the ballots integrity\n', '    bytes32 public specHash;\n', '    bool public useEncryption;\n', '\n', "    // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\n", '    bool public deprecated = false;\n', '\n', '    //// ** Events\n', '    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\n', '    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\n', '    event SuccessfulVote(address voter, bytes32 ballot);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event Error(string error);\n', '    event DeprecatedContract();\n', '    event SetOwner(address _owner);\n', '\n', '\n', '    //// ** Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier ballotOpen {\n', '        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\n', '        _;\n', '    }\n', '\n', '    modifier onlyTesting {\n', '        require(testMode);\n', '        _;\n', '    }\n', '\n', '    modifier isTrue(bool _b) {\n', '        require(_b == true);\n', '        _;\n', '    }\n', '\n', '    modifier isFalse(bool _b) {\n', '        require(_b == false);\n', '        _;\n', '    }\n', '\n', '    //// ** Functions\n', '\n', '    uint16 constant F_USE_ENC = 0;\n', '    uint16 constant F_TESTING = 1;\n', '    // Constructor function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    // flags are [_useEncryption, enableTesting]\n', '    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\n', '        owner = msg.sender;\n', '\n', '        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '        // (which someone might be able to do if they could set the timestamp in the past)\n', '        startTime = max(openPeriod[0], uint64(block.timestamp));\n', '        endTime = openPeriod[1];\n', '        useEncryption = flags[F_USE_ENC];\n', '        specHash = _specHash;\n', '        creationBlock = uint64(block.number);\n', '        // add a rough prediction of what block is the starting block\n', '        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\n', '\n', '        if (flags[F_TESTING]) {\n', '            testMode = true;\n', '            TestingEnabled();\n', '        }\n', '\n', '        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\n', '    }\n', '\n', '    // Ballot submission\n', '    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\n', '        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\n', '        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\n', '    }\n', '\n', '    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\n', '        addBallotAndVoterNoPk(ballot);\n', '        SuccessfulVote(msg.sender, ballot);\n', '    }\n', '\n', '    // Internal function to ensure atomicity of voter log\n', '    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\n', '        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\n', '        associatedPubkeys[ballotNumber] = senderPubkey;\n', '    }\n', '\n', '    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\n', '        uint256 ballotNumber = nVotesCast;\n', '        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\n', '        voterToBallotID[msg.sender] = ballotNumber;\n', '        nVotesCast += 1;\n', '        return ballotNumber;\n', '    }\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(bytes32 _secKey) onlyOwner public {\n', '        require(block.timestamp > endTime);\n', '\n', '        ballotEncryptionSeckey = _secKey;\n', '        seckeyRevealed = true; // this flag allows the contract to be locked\n', '        SeckeyRevealed(_secKey);\n', '    }\n', '\n', '    function getEncSeckey() public constant returns (bytes32) {\n', '        return ballotEncryptionSeckey;\n', '    }\n', '\n', '    // Test functions\n', '    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\n', '        endTime = newEndTime;\n', '    }\n', '\n', '    function setDeprecated() onlyOwner public {\n', '        deprecated = true;\n', '        DeprecatedContract();\n', '    }\n', '\n', '    function setOwner(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '        SetOwner(newOwner);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '\n', '//\n', '// The Index by which democracies and ballots are tracked (and optionally deployed).\n', '// Author: Max Kaye <max@secure.vote>\n', '// License: MIT\n', '//\n', '\n', 'contract SVLightIndex {\n', '\n', '    address public owner;\n', '\n', '    struct Ballot {\n', '        bytes32 specHash;\n', '        bytes32 extraData;\n', '        address votingContract;\n', '        uint64 startTs;\n', '    }\n', '\n', '    struct Democ {\n', '        string name;\n', '        address admin;\n', '        Ballot[] ballots;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) public democs;\n', '    bytes32[] public democList;\n', '\n', '    // addresses that do not have to pay for democs\n', '    mapping (address => bool) public democWhitelist;\n', '    // democs that do not have to pay for issues\n', '    mapping (address => bool) public ballotWhitelist;\n', '\n', '    // payment details\n', '    address public payTo;\n', "    // uint128's used because they account for amounts up to 3.4e38 wei or 3.4e20 ether\n", '    uint128 public democFee = 0.05 ether; // 0.05 ether; about $50 at 3 March 2018\n', '    mapping (address => uint128) democFeeFor;\n', '    uint128 public ballotFee = 0.01 ether; // 0.01 ether; about $10 at 3 March 2018\n', '    mapping (address => uint128) ballotFeeFor;\n', '    bool public paymentEnabled = true;\n', '\n', '    uint8 constant PAY_DEMOC = 0;\n', '    uint8 constant PAY_BALLOT = 1;\n', '\n', '    function getPaymentParams(uint8 paymentType) internal constant returns (bool, uint128, uint128) {\n', '        if (paymentType == PAY_DEMOC) {\n', '            return (democWhitelist[msg.sender], democFee, democFeeFor[msg.sender]);\n', '        } else if (paymentType == PAY_BALLOT) {\n', '            return (ballotWhitelist[msg.sender], ballotFee, ballotFeeFor[msg.sender]);\n', '        } else {\n', '            assert(false);\n', '        }\n', '    }\n', '\n', '    //* EVENTS /\n', '\n', '    event PaymentMade(uint128[2] valAndRemainder);\n', '    event DemocInit(string name, bytes32 democHash, address admin);\n', '    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\n', '    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\n', '    event SetFees(uint128[2] _newFees);\n', '    event PaymentEnabled(bool _feeEnabled);\n', '\n', '    //* MODIFIERS /\n', '\n', '    modifier onlyBy(address _account) {\n', '        require(msg.sender == _account);\n', '        _;\n', '    }\n', '\n', '    modifier payReq(uint8 paymentType) {\n', "        // get our whitelist, generalFee, and fee's for particular addresses\n", '        bool wl;\n', '        uint128 genFee;\n', '        uint128 feeFor;\n', '        (wl, genFee, feeFor) = getPaymentParams(paymentType);\n', '        // init v to something large in case of exploit or something\n', '        uint128 v = 1000 ether;\n', '        // check whitelists - do not require payment in some cases\n', '        if (paymentEnabled && !wl) {\n', '            v = feeFor;\n', '            if (v == 0){\n', "                // if there's no fee for the individual user then set it to the general fee\n", '                v = genFee;\n', '            }\n', '            require(msg.value >= v);\n', '\n', '            // handle payments\n', '            uint128 remainder = uint128(msg.value) - v;\n', '            payTo.transfer(v); // .transfer so it throws on failure\n', '            if (!msg.sender.send(remainder)){\n', '                payTo.transfer(remainder);\n', '            }\n', '            PaymentMade([v, remainder]);\n', '        }\n', '\n', '        // do main\n', '        _;\n', '    }\n', '\n', '\n', '    //* FUNCTIONS /\n', '\n', '\n', '    // constructor\n', '    function SVLightIndex() public {\n', '        owner = msg.sender;\n', '        payTo = msg.sender;\n', '    }\n', '\n', '    //* GLOBAL INFO */\n', '\n', '    function nDemocs() public constant returns (uint256) {\n', '        return democList.length;\n', '    }\n', '\n', '    //* PAYMENT AND OWNER FUNCTIONS */\n', '\n', '    function setPayTo(address newPayTo) onlyBy(owner) public {\n', '        payTo = newPayTo;\n', '    }\n', '\n', '    function setEth(uint128[2] newFees) onlyBy(owner) public {\n', '        democFee = newFees[PAY_DEMOC];\n', '        ballotFee = newFees[PAY_BALLOT];\n', '        SetFees([democFee, ballotFee]);\n', '    }\n', '\n', '    function setOwner(address _owner) onlyBy(owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setPaymentEnabled(bool _enabled) onlyBy(owner) public {\n', '        paymentEnabled = _enabled;\n', '        PaymentEnabled(_enabled);\n', '    }\n', '\n', '    function setWhitelistDemoc(address addr, bool _free) onlyBy(owner) public {\n', '        democWhitelist[addr] = _free;\n', '    }\n', '\n', '    function setWhitelistBallot(address addr, bool _free) onlyBy(owner) public {\n', '        ballotWhitelist[addr] = _free;\n', '    }\n', '\n', '    function setFeeFor(address addr, uint128[2] fees) onlyBy(owner) public {\n', '        democFeeFor[addr] = fees[PAY_DEMOC];\n', '        ballotFeeFor[addr] = fees[PAY_BALLOT];\n', '    }\n', '\n', '    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\n', '\n', '    function initDemoc(string democName) payReq(PAY_DEMOC) public payable returns (bytes32) {\n', '        bytes32 democHash = keccak256(democName, msg.sender, democList.length, this);\n', '        democList.push(democHash);\n', '        democs[democHash].name = democName;\n', '        democs[democHash].admin = msg.sender;\n', '        DemocInit(democName, democHash, msg.sender);\n', '        return democHash;\n', '    }\n', '\n', '    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\n', '        return (democs[democHash].name, democs[democHash].admin, democs[democHash].ballots.length);\n', '    }\n', '\n', '    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\n', '        democs[democHash].admin = newAdmin;\n', '    }\n', '\n', '    function nBallots(bytes32 democHash) public constant returns (uint256) {\n', '        return democs[democHash].ballots.length;\n', '    }\n', '\n', '    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\n', '        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\n', '        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\n', '        BallotAdded(democHash, specHash, extraData, votingContract);\n', '    }\n', '\n', '    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\n', '                      onlyBy(democs[democHash].admin)\n', '                      payReq(PAY_BALLOT)\n', '                      public\n', '                      payable\n', '                      {\n', '        SVLightBallotBox bb = SVLightBallotBox(votingContract);\n', '        bytes32 specHash = bb.specHash();\n', '        uint64 startTs = bb.startTime();\n', '        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\n', '    }\n', '\n', '    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\n', '                          uint64[2] openPeriod, bool[2] flags)\n', '                          onlyBy(democs[democHash].admin)\n', '                          payReq(PAY_BALLOT)\n', '                          public payable {\n', '        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\n', '        // token holders who have recently acquired tokens.\n', '        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\n', '        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\n', '        votingContract.setOwner(msg.sender);\n', '        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\n', '        BallotInit(specHash, [startTs, openPeriod[1]], flags);\n', '    }\n', '\n', '    // utils\n', '    function max(uint64 a, uint64 b) pure internal returns(uint64) {\n', '        if (a > b) {\n', '            return a;\n', '        }\n', '        return b;\n', '    }\n', '}']
