['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Interface for the polymath module registry contract\n', ' */\n', 'contract IModuleRegistry {\n', '\n', '    /**\n', '     * @notice Called by a security token to notify the registry it is using a module\n', '     * @param _moduleFactory is the address of the relevant module factory\n', '     */\n', '    function useModule(address _moduleFactory) external;\n', '\n', '    /**\n', '     * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\n', '     * @param _moduleFactory is the address of the module factory to be registered\n', '     */\n', '    function registerModule(address _moduleFactory) external returns(bool);\n', '\n', '    /**\n', '     * @notice Use to get all the tags releated to the functionality of the Module Factory.\n', '     * @param _moduleType Type of module\n', '     */\n', '    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]);\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Interface that any module factory contract should implement\n', ' */\n', 'contract IModuleFactory is Ownable {\n', '\n', '    ERC20 public polyToken;\n', '    uint256 public setupCost;\n', '    uint256 public usageCost;\n', '    uint256 public monthlySubscriptionCost;\n', '\n', '    event LogChangeFactorySetupFee(uint256 _oldSetupcost, uint256 _newSetupCost, address _moduleFactory);\n', '    event LogChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n', '    event LogChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n', '    event LogGenerateModuleFromFactory(address _module, bytes32 indexed _moduleName, address indexed _moduleFactory, address _creator, uint256 _timestamp);\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\n', '      polyToken = ERC20(_polyAddress);\n', '      setupCost = _setupCost;\n', '      usageCost = _usageCost;\n', '      monthlySubscriptionCost = _subscriptionCost;\n', '    }\n', '\n', '    //Should create an instance of the Module, or throw\n', '    function deploy(bytes _data) external returns(address);\n', '\n', '    /**\n', '     * @notice Type of the Module factory\n', '     */\n', '    function getType() public view returns(uint8);\n', '\n', '    /**\n', '     * @notice Get the name of the Module\n', '     */\n', '    function getName() public view returns(bytes32);\n', '\n', '    /**\n', '     * @notice Get the description of the Module\n', '     */\n', '    function getDescription() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the title of the Module\n', '     */\n', '    function getTitle() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the Instructions that helped to used the module\n', '     */\n', '    function getInstructions() public view returns (string);\n', '\n', '    /**\n', '     * @notice Get the tags related to the module factory\n', '     */\n', '    function getTags() public view returns (bytes32[]);\n', '\n', '    //Pull function sig from _data\n', '    function getSig(bytes _data) internal pure returns (bytes4 sig) {\n', '        uint len = _data.length < 4 ? _data.length : 4;\n', '        for (uint i = 0; i < len; i++) {\n', '            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the setup cost\n', '     * @param _newSetupCost new setup cost\n', '     */\n', '    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\n', '        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\n', '        setupCost = _newSetupCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the usage cost\n', '     * @param _newUsageCost new usage cost\n', '     */\n', '    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\n', '        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\n', '        usageCost = _newUsageCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the subscription cost\n', '     * @param _newSubscriptionCost new subscription cost\n', '     */\n', '    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\n', '        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\n', '        monthlySubscriptionCost = _newSubscriptionCost;\n', '        \n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface for the ST20 token standard\n', ' */\n', 'contract IST20 is StandardToken, DetailedERC20 {\n', '\n', '    // off-chain hash\n', '    string public tokenDetails;\n', '\n', '    //transfer, transferFrom must respect use respect the result of verifyTransfer\n', '    function verifyTransfer(address _from, address _to, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice mints new tokens and assigns them to the target _investor.\n', '     * Can only be called by the STO attached to the token (Or by the ST owner if there&#39;s no STO attached yet)\n', '     */\n', '    function mint(address _investor, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice Burn function used to burn the securityToken\n', '     * @param _value No. of token that get burned\n', '     */\n', '    function burn(uint256 _value) public;\n', '\n', '    event Minted(address indexed to, uint256 amount);\n', '    event Burnt(address indexed _burner, uint256 _value);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for all security tokens\n', ' */\n', 'contract ISecurityToken is IST20, Ownable {\n', '\n', '    uint8 public constant PERMISSIONMANAGER_KEY = 1;\n', '    uint8 public constant TRANSFERMANAGER_KEY = 2;\n', '    uint8 public constant STO_KEY = 3;\n', '    uint8 public constant CHECKPOINT_KEY = 4;\n', '    uint256 public granularity;\n', '\n', '    // Value of current checkpoint\n', '    uint256 public currentCheckpointId;\n', '\n', '    // Total number of non-zero token holders\n', '    uint256 public investorCount;\n', '\n', '    // List of token holders\n', '    address[] public investors;\n', '\n', '    // Permissions this to a Permission module, which has a key of 1\n', '    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\n', '    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\n', '\n', '    /**\n', '     * @notice returns module list for a module type\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _moduleIndex is the index of the module within the chosen type\n', '     */\n', '    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice returns module list for a module name - will return first match\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _name is the name of the module within the chosen type\n', '     */\n', '    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice Queries totalSupply as of a defined checkpoint\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Queries balances as of a defined checkpoint\n', '     * @param _investor Investor to query balance for\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n', '     */\n', '    function createCheckpoint() public returns(uint256);\n', '\n', '    /**\n', '     * @notice gets length of investors array\n', '     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\n', '     * @return length\n', '     */\n', '    function getInvestorsLength() public view returns(uint256);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath security token registry contract\n', ' */\n', 'contract ISecurityTokenRegistry {\n', '\n', '    bytes32 public protocolVersion = "0.0.1";\n', '    mapping (bytes32 => address) public protocolVersionST;\n', '\n', '    struct SecurityTokenData {\n', '        string symbol;\n', '        string tokenDetails;\n', '    }\n', '\n', '    mapping(address => SecurityTokenData) securityTokens;\n', '    mapping(string => address) symbols;\n', '\n', '    /**\n', '     * @notice Creates a new Security Token and saves it to the registry\n', '     * @param _name Name of the token\n', '     * @param _symbol Ticker symbol of the security token\n', '     * @param _tokenDetails off-chain details of the token\n', '     */\n', '    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public;\n', '\n', '    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public;\n', '\n', '    /**\n', '     * @notice Get security token address by ticker name\n', '     * @param _symbol Symbol of the Scurity token\n', '     * @return address _symbol\n', '     */\n', '    function getSecurityTokenAddress(string _symbol) public view returns (address);\n', '\n', '     /**\n', '     * @notice Get security token data by its address\n', '     * @param _securityToken Address of the Scurity token\n', '     * @return string, address, bytes32\n', '     */\n', '    function getSecurityTokenData(address _securityToken) public view returns (string, address, string);\n', '\n', '    /**\n', '    * @notice Check that Security Token is registered\n', '    * @param _securityToken Address of the Scurity token\n', '    * @return bool\n', '    */\n', '    function isSecurityToken(address _securityToken) public view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal {\n', '        require(!paused);\n', '        paused = true;\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal {\n', '        require(paused);\n', '        paused = false;\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0));\n', '        ERC20Basic token = ERC20Basic(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Get the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) view public returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice change the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public tickerRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0));\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() onlyOwner public {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress("TickerRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title Registry contract to store registered modules\n', '* @notice Anyone can register modules, but only those "approved" by Polymath will be available for issuers to add\n', '*/\n', 'contract ModuleRegistry is IModuleRegistry, Pausable, RegistryUpdater, ReclaimTokens {\n', '\n', '    // Mapping used to hold the type of module factory corresponds to the address of the Module factory contract\n', '    mapping (address => uint8) public registry;\n', '    // Mapping used to hold the reputation of the factory\n', '    mapping (address => address[]) public reputation;\n', '    // Mapping contain the list of addresses of Module factory for a particular type\n', '    mapping (uint8 => address[]) public moduleList;\n', '    // contains the list of verified modules\n', '    mapping (address => bool) public verified;\n', '    // Contains the list of the available tags corresponds to the module type\n', '    mapping (uint8 => bytes32[]) public availableTags;\n', '\n', '    // Emit when Module been used by the securityToken\n', '    event LogModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\n', '    // Emit when the Module Factory get registered with the ModuleRegistry contract\n', '    event LogModuleRegistered(address indexed _moduleFactory, address indexed _owner);\n', '    // Emit when the module get verified by the Polymath team\n', '    event LogModuleVerified(address indexed _moduleFactory, bool _verified);\n', '\n', '    constructor (address _polymathRegistry) public\n', '        RegistryUpdater(_polymathRegistry)\n', '    {\n', '    }\n', '\n', '   /**\n', '    * @notice Called by a security token to notify the registry it is using a module\n', '    * @param _moduleFactory is the address of the relevant module factory\n', '    */\n', '    function useModule(address _moduleFactory) external {\n', '        //If caller is a registered security token, then register module usage\n', '        if (ISecurityTokenRegistry(securityTokenRegistry).isSecurityToken(msg.sender)) {\n', '            require(registry[_moduleFactory] != 0, "ModuleFactory type should not be 0");\n', '            //To use a module, either it must be verified, or owned by the ST owner\n', '            require(verified[_moduleFactory]||(IModuleFactory(_moduleFactory).owner() == ISecurityToken(msg.sender).owner()),\n', '              "Module factory is not verified as well as not called by the owner");\n', '            reputation[_moduleFactory].push(msg.sender);\n', '            emit LogModuleUsed (_moduleFactory, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\n', '    * @param _moduleFactory is the address of the module factory to be registered\n', '    * @return bool\n', '    */\n', '    function registerModule(address _moduleFactory) external whenNotPaused returns(bool) {\n', '        require(registry[_moduleFactory] == 0, "Module factory should not be pre-registered");\n', '        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\n', '        require(moduleFactory.getType() != 0, "Factory type should not equal to 0");\n', '        registry[_moduleFactory] = moduleFactory.getType();\n', '        moduleList[moduleFactory.getType()].push(_moduleFactory);\n', '        reputation[_moduleFactory] = new address[](0);\n', '        emit LogModuleRegistered (_moduleFactory, moduleFactory.owner());\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Called by Polymath to verify modules for SecurityToken to use.\n', '    * @notice A module can not be used by an ST unless first approved/verified by Polymath\n', '    * @notice (The only exception to this is that the author of the module is the owner of the ST)\n', '    * @param _moduleFactory is the address of the module factory to be registered\n', '    * @return bool\n', '    */\n', '    function verifyModule(address _moduleFactory, bool _verified) external onlyOwner returns(bool) {\n', '        //Must already have been registered\n', '        require(registry[_moduleFactory] != 0, "Module factory should have been already registered");\n', '        verified[_moduleFactory] = _verified;\n', '        emit LogModuleVerified(_moduleFactory, _verified);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Use to get all the tags releated to the functionality of the Module Factory.\n', '     * @param _moduleType Type of module\n', '     * @return bytes32 array\n', '     */\n', '    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]) {\n', '        return availableTags[_moduleType];\n', '    }\n', '\n', '    /**\n', '     * @notice Add the tag for specified Module Factory\n', '     * @param _moduleType Type of module.\n', '     * @param _tag List of tags\n', '     */\n', '     function addTagByModuleType(uint8 _moduleType, bytes32[] _tag) public onlyOwner {\n', '         for (uint8 i = 0; i < _tag.length; i++) {\n', '             availableTags[_moduleType].push(_tag[i]);\n', '         }\n', '     }\n', '\n', '    /**\n', '     * @notice remove the tag for specified Module Factory\n', '     * @param _moduleType Type of module.\n', '     * @param _removedTags List of tags\n', '     */\n', '     function removeTagByModuleType(uint8 _moduleType, bytes32[] _removedTags) public onlyOwner {\n', '         for (uint8 i = 0; i < availableTags[_moduleType].length; i++) {\n', '            for (uint8 j = 0; j < _removedTags.length; j++) {\n', '                if (availableTags[_moduleType][i] == _removedTags[j]) {\n', '                    delete availableTags[_moduleType][i];\n', '                }\n', '            }\n', '        }\n', '     }\n', '\n', '     /**\n', '     * @notice pause registration function\n', '     */\n', '    function unpause() public onlyOwner  {\n', '        _unpause();\n', '    }\n', '\n', '    /**\n', '     * @notice unpause registration function\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Interface for the polymath module registry contract\n', ' */\n', 'contract IModuleRegistry {\n', '\n', '    /**\n', '     * @notice Called by a security token to notify the registry it is using a module\n', '     * @param _moduleFactory is the address of the relevant module factory\n', '     */\n', '    function useModule(address _moduleFactory) external;\n', '\n', '    /**\n', '     * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\n', '     * @param _moduleFactory is the address of the module factory to be registered\n', '     */\n', '    function registerModule(address _moduleFactory) external returns(bool);\n', '\n', '    /**\n', '     * @notice Use to get all the tags releated to the functionality of the Module Factory.\n', '     * @param _moduleType Type of module\n', '     */\n', '    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]);\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '/**\n', ' * @title Interface that any module factory contract should implement\n', ' */\n', 'contract IModuleFactory is Ownable {\n', '\n', '    ERC20 public polyToken;\n', '    uint256 public setupCost;\n', '    uint256 public usageCost;\n', '    uint256 public monthlySubscriptionCost;\n', '\n', '    event LogChangeFactorySetupFee(uint256 _oldSetupcost, uint256 _newSetupCost, address _moduleFactory);\n', '    event LogChangeFactoryUsageFee(uint256 _oldUsageCost, uint256 _newUsageCost, address _moduleFactory);\n', '    event LogChangeFactorySubscriptionFee(uint256 _oldSubscriptionCost, uint256 _newMonthlySubscriptionCost, address _moduleFactory);\n', '    event LogGenerateModuleFromFactory(address _module, bytes32 indexed _moduleName, address indexed _moduleFactory, address _creator, uint256 _timestamp);\n', '\n', '    /**\n', '     * @notice Constructor\n', '     * @param _polyAddress Address of the polytoken\n', '     */\n', '    constructor (address _polyAddress, uint256 _setupCost, uint256 _usageCost, uint256 _subscriptionCost) public {\n', '      polyToken = ERC20(_polyAddress);\n', '      setupCost = _setupCost;\n', '      usageCost = _usageCost;\n', '      monthlySubscriptionCost = _subscriptionCost;\n', '    }\n', '\n', '    //Should create an instance of the Module, or throw\n', '    function deploy(bytes _data) external returns(address);\n', '\n', '    /**\n', '     * @notice Type of the Module factory\n', '     */\n', '    function getType() public view returns(uint8);\n', '\n', '    /**\n', '     * @notice Get the name of the Module\n', '     */\n', '    function getName() public view returns(bytes32);\n', '\n', '    /**\n', '     * @notice Get the description of the Module\n', '     */\n', '    function getDescription() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the title of the Module\n', '     */\n', '    function getTitle() public view returns(string);\n', '\n', '    /**\n', '     * @notice Get the Instructions that helped to used the module\n', '     */\n', '    function getInstructions() public view returns (string);\n', '\n', '    /**\n', '     * @notice Get the tags related to the module factory\n', '     */\n', '    function getTags() public view returns (bytes32[]);\n', '\n', '    //Pull function sig from _data\n', '    function getSig(bytes _data) internal pure returns (bytes4 sig) {\n', '        uint len = _data.length < 4 ? _data.length : 4;\n', '        for (uint i = 0; i < len; i++) {\n', '            sig = bytes4(uint(sig) + uint(_data[i]) * (2 ** (8 * (len - 1 - i))));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the setup cost\n', '     * @param _newSetupCost new setup cost\n', '     */\n', '    function changeFactorySetupFee(uint256 _newSetupCost) public onlyOwner {\n', '        emit LogChangeFactorySetupFee(setupCost, _newSetupCost, address(this));\n', '        setupCost = _newSetupCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the usage cost\n', '     * @param _newUsageCost new usage cost\n', '     */\n', '    function changeFactoryUsageFee(uint256 _newUsageCost) public onlyOwner {\n', '        emit LogChangeFactoryUsageFee(usageCost, _newUsageCost, address(this));\n', '        usageCost = _newUsageCost;\n', '    }\n', '\n', '    /**\n', '     * @notice used to change the fee of the subscription cost\n', '     * @param _newSubscriptionCost new subscription cost\n', '     */\n', '    function changeFactorySubscriptionFee(uint256 _newSubscriptionCost) public onlyOwner {\n', '        emit LogChangeFactorySubscriptionFee(monthlySubscriptionCost, _newSubscriptionCost, address(this));\n', '        monthlySubscriptionCost = _newSubscriptionCost;\n', '        \n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Interface for the ST20 token standard\n', ' */\n', 'contract IST20 is StandardToken, DetailedERC20 {\n', '\n', '    // off-chain hash\n', '    string public tokenDetails;\n', '\n', '    //transfer, transferFrom must respect use respect the result of verifyTransfer\n', '    function verifyTransfer(address _from, address _to, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice mints new tokens and assigns them to the target _investor.\n', "     * Can only be called by the STO attached to the token (Or by the ST owner if there's no STO attached yet)\n", '     */\n', '    function mint(address _investor, uint256 _amount) public returns (bool success);\n', '\n', '    /**\n', '     * @notice Burn function used to burn the securityToken\n', '     * @param _value No. of token that get burned\n', '     */\n', '    function burn(uint256 _value) public;\n', '\n', '    event Minted(address indexed to, uint256 amount);\n', '    event Burnt(address indexed _burner, uint256 _value);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for all security tokens\n', ' */\n', 'contract ISecurityToken is IST20, Ownable {\n', '\n', '    uint8 public constant PERMISSIONMANAGER_KEY = 1;\n', '    uint8 public constant TRANSFERMANAGER_KEY = 2;\n', '    uint8 public constant STO_KEY = 3;\n', '    uint8 public constant CHECKPOINT_KEY = 4;\n', '    uint256 public granularity;\n', '\n', '    // Value of current checkpoint\n', '    uint256 public currentCheckpointId;\n', '\n', '    // Total number of non-zero token holders\n', '    uint256 public investorCount;\n', '\n', '    // List of token holders\n', '    address[] public investors;\n', '\n', '    // Permissions this to a Permission module, which has a key of 1\n', '    // If no Permission return false - note that IModule withPerm will allow ST owner all permissions anyway\n', '    // this allows individual modules to override this logic if needed (to not allow ST owner all permissions)\n', '    function checkPermission(address _delegate, address _module, bytes32 _perm) public view returns(bool);\n', '\n', '    /**\n', '     * @notice returns module list for a module type\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _moduleIndex is the index of the module within the chosen type\n', '     */\n', '    function getModule(uint8 _moduleType, uint _moduleIndex) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice returns module list for a module name - will return first match\n', '     * @param _moduleType is which type of module we are trying to remove\n', '     * @param _name is the name of the module within the chosen type\n', '     */\n', '    function getModuleByName(uint8 _moduleType, bytes32 _name) public view returns (bytes32, address);\n', '\n', '    /**\n', '     * @notice Queries totalSupply as of a defined checkpoint\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function totalSupplyAt(uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Queries balances as of a defined checkpoint\n', '     * @param _investor Investor to query balance for\n', '     * @param _checkpointId Checkpoint ID to query as of\n', '     */\n', '    function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256);\n', '\n', '    /**\n', '     * @notice Creates a checkpoint that can be used to query historical balances / totalSuppy\n', '     */\n', '    function createCheckpoint() public returns(uint256);\n', '\n', '    /**\n', '     * @notice gets length of investors array\n', '     * NB - this length may differ from investorCount if list has not been pruned of zero balance investors\n', '     * @return length\n', '     */\n', '    function getInvestorsLength() public view returns(uint256);\n', '\n', '}\n', '\n', '/**\n', ' * @title Interface for the polymath security token registry contract\n', ' */\n', 'contract ISecurityTokenRegistry {\n', '\n', '    bytes32 public protocolVersion = "0.0.1";\n', '    mapping (bytes32 => address) public protocolVersionST;\n', '\n', '    struct SecurityTokenData {\n', '        string symbol;\n', '        string tokenDetails;\n', '    }\n', '\n', '    mapping(address => SecurityTokenData) securityTokens;\n', '    mapping(string => address) symbols;\n', '\n', '    /**\n', '     * @notice Creates a new Security Token and saves it to the registry\n', '     * @param _name Name of the token\n', '     * @param _symbol Ticker symbol of the security token\n', '     * @param _tokenDetails off-chain details of the token\n', '     */\n', '    function generateSecurityToken(string _name, string _symbol, string _tokenDetails, bool _divisible) public;\n', '\n', '    function setProtocolVersion(address _stVersionProxyAddress, bytes32 _version) public;\n', '\n', '    /**\n', '     * @notice Get security token address by ticker name\n', '     * @param _symbol Symbol of the Scurity token\n', '     * @return address _symbol\n', '     */\n', '    function getSecurityTokenAddress(string _symbol) public view returns (address);\n', '\n', '     /**\n', '     * @notice Get security token data by its address\n', '     * @param _securityToken Address of the Scurity token\n', '     * @return string, address, bytes32\n', '     */\n', '    function getSecurityTokenData(address _securityToken) public view returns (string, address, string);\n', '\n', '    /**\n', '    * @notice Check that Security Token is registered\n', '    * @param _securityToken Address of the Scurity token\n', '    * @return bool\n', '    */\n', '    function isSecurityToken(address _securityToken) public view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow pausing and unpausing of certain functions\n', ' */\n', 'contract Pausable {\n', '\n', '    event Pause(uint256 _timestammp);\n', '    event Unpause(uint256 _timestamp);\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '   /**\n', '    * @notice called by the owner to pause, triggers stopped state\n', '    */\n', '    function _pause() internal {\n', '        require(!paused);\n', '        paused = true;\n', '        emit Pause(now);\n', '    }\n', '\n', '    /**\n', '    * @notice called by the owner to unpause, returns to normal state\n', '    */\n', '    function _unpause() internal {\n', '        require(paused);\n', '        paused = false;\n', '        emit Unpause(now);\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Utility contract to allow owner to retreive any ERC20 sent to the contract\n', ' */\n', 'contract ReclaimTokens is Ownable {\n', '\n', '    /**\n', '    * @notice Reclaim all ERC20Basic compatible tokens\n', '    * @param _tokenContract The address of the token contract\n', '    */\n', '    function reclaimERC20(address _tokenContract) external onlyOwner {\n', '        require(_tokenContract != address(0));\n', '        ERC20Basic token = ERC20Basic(_tokenContract);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(token.transfer(owner, balance));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Core functionality for registry upgradability\n', ' */\n', 'contract PolymathRegistry is ReclaimTokens {\n', '\n', '    mapping (bytes32 => address) public storedAddresses;\n', '\n', '    event LogChangeAddress(string _nameKey, address indexed _oldAddress, address indexed _newAddress);\n', '\n', '    /**\n', '     * @notice Get the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @return address\n', '     */\n', '    function getAddress(string _nameKey) view public returns(address) {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        require(storedAddresses[key] != address(0), "Invalid address key");\n', '        return storedAddresses[key];\n', '    }\n', '\n', '    /**\n', '     * @notice change the contract address\n', '     * @param _nameKey is the key for the contract address mapping\n', '     * @param _newAddress is the new contract address\n', '     */\n', '    function changeAddress(string _nameKey, address _newAddress) public onlyOwner {\n', '        bytes32 key = keccak256(bytes(_nameKey));\n', '        emit LogChangeAddress(_nameKey, storedAddresses[key], _newAddress);\n', '        storedAddresses[key] = _newAddress;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract RegistryUpdater is Ownable {\n', '\n', '    address public polymathRegistry;\n', '    address public moduleRegistry;\n', '    address public securityTokenRegistry;\n', '    address public tickerRegistry;\n', '    address public polyToken;\n', '\n', '    constructor (address _polymathRegistry) public {\n', '        require(_polymathRegistry != address(0));\n', '        polymathRegistry = _polymathRegistry;\n', '    }\n', '\n', '    function updateFromRegistry() onlyOwner public {\n', '        moduleRegistry = PolymathRegistry(polymathRegistry).getAddress("ModuleRegistry");\n', '        securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress("SecurityTokenRegistry");\n', '        tickerRegistry = PolymathRegistry(polymathRegistry).getAddress("TickerRegistry");\n', '        polyToken = PolymathRegistry(polymathRegistry).getAddress("PolyToken");\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title Registry contract to store registered modules\n', '* @notice Anyone can register modules, but only those "approved" by Polymath will be available for issuers to add\n', '*/\n', 'contract ModuleRegistry is IModuleRegistry, Pausable, RegistryUpdater, ReclaimTokens {\n', '\n', '    // Mapping used to hold the type of module factory corresponds to the address of the Module factory contract\n', '    mapping (address => uint8) public registry;\n', '    // Mapping used to hold the reputation of the factory\n', '    mapping (address => address[]) public reputation;\n', '    // Mapping contain the list of addresses of Module factory for a particular type\n', '    mapping (uint8 => address[]) public moduleList;\n', '    // contains the list of verified modules\n', '    mapping (address => bool) public verified;\n', '    // Contains the list of the available tags corresponds to the module type\n', '    mapping (uint8 => bytes32[]) public availableTags;\n', '\n', '    // Emit when Module been used by the securityToken\n', '    event LogModuleUsed(address indexed _moduleFactory, address indexed _securityToken);\n', '    // Emit when the Module Factory get registered with the ModuleRegistry contract\n', '    event LogModuleRegistered(address indexed _moduleFactory, address indexed _owner);\n', '    // Emit when the module get verified by the Polymath team\n', '    event LogModuleVerified(address indexed _moduleFactory, bool _verified);\n', '\n', '    constructor (address _polymathRegistry) public\n', '        RegistryUpdater(_polymathRegistry)\n', '    {\n', '    }\n', '\n', '   /**\n', '    * @notice Called by a security token to notify the registry it is using a module\n', '    * @param _moduleFactory is the address of the relevant module factory\n', '    */\n', '    function useModule(address _moduleFactory) external {\n', '        //If caller is a registered security token, then register module usage\n', '        if (ISecurityTokenRegistry(securityTokenRegistry).isSecurityToken(msg.sender)) {\n', '            require(registry[_moduleFactory] != 0, "ModuleFactory type should not be 0");\n', '            //To use a module, either it must be verified, or owned by the ST owner\n', '            require(verified[_moduleFactory]||(IModuleFactory(_moduleFactory).owner() == ISecurityToken(msg.sender).owner()),\n', '              "Module factory is not verified as well as not called by the owner");\n', '            reputation[_moduleFactory].push(msg.sender);\n', '            emit LogModuleUsed (_moduleFactory, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Called by moduleFactory owner to register new modules for SecurityToken to use\n', '    * @param _moduleFactory is the address of the module factory to be registered\n', '    * @return bool\n', '    */\n', '    function registerModule(address _moduleFactory) external whenNotPaused returns(bool) {\n', '        require(registry[_moduleFactory] == 0, "Module factory should not be pre-registered");\n', '        IModuleFactory moduleFactory = IModuleFactory(_moduleFactory);\n', '        require(moduleFactory.getType() != 0, "Factory type should not equal to 0");\n', '        registry[_moduleFactory] = moduleFactory.getType();\n', '        moduleList[moduleFactory.getType()].push(_moduleFactory);\n', '        reputation[_moduleFactory] = new address[](0);\n', '        emit LogModuleRegistered (_moduleFactory, moduleFactory.owner());\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Called by Polymath to verify modules for SecurityToken to use.\n', '    * @notice A module can not be used by an ST unless first approved/verified by Polymath\n', '    * @notice (The only exception to this is that the author of the module is the owner of the ST)\n', '    * @param _moduleFactory is the address of the module factory to be registered\n', '    * @return bool\n', '    */\n', '    function verifyModule(address _moduleFactory, bool _verified) external onlyOwner returns(bool) {\n', '        //Must already have been registered\n', '        require(registry[_moduleFactory] != 0, "Module factory should have been already registered");\n', '        verified[_moduleFactory] = _verified;\n', '        emit LogModuleVerified(_moduleFactory, _verified);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Use to get all the tags releated to the functionality of the Module Factory.\n', '     * @param _moduleType Type of module\n', '     * @return bytes32 array\n', '     */\n', '    function getTagByModuleType(uint8 _moduleType) public view returns(bytes32[]) {\n', '        return availableTags[_moduleType];\n', '    }\n', '\n', '    /**\n', '     * @notice Add the tag for specified Module Factory\n', '     * @param _moduleType Type of module.\n', '     * @param _tag List of tags\n', '     */\n', '     function addTagByModuleType(uint8 _moduleType, bytes32[] _tag) public onlyOwner {\n', '         for (uint8 i = 0; i < _tag.length; i++) {\n', '             availableTags[_moduleType].push(_tag[i]);\n', '         }\n', '     }\n', '\n', '    /**\n', '     * @notice remove the tag for specified Module Factory\n', '     * @param _moduleType Type of module.\n', '     * @param _removedTags List of tags\n', '     */\n', '     function removeTagByModuleType(uint8 _moduleType, bytes32[] _removedTags) public onlyOwner {\n', '         for (uint8 i = 0; i < availableTags[_moduleType].length; i++) {\n', '            for (uint8 j = 0; j < _removedTags.length; j++) {\n', '                if (availableTags[_moduleType][i] == _removedTags[j]) {\n', '                    delete availableTags[_moduleType][i];\n', '                }\n', '            }\n', '        }\n', '     }\n', '\n', '     /**\n', '     * @notice pause registration function\n', '     */\n', '    function unpause() public onlyOwner  {\n', '        _unpause();\n', '    }\n', '\n', '    /**\n', '     * @notice unpause registration function\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '\n', '}']
