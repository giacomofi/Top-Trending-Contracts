['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Utils/Math.sol\n', '\n', 'library MathUtils {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint result = a + b;\n', '\n', '        if (a == 0 || b == 0) {\n', '            return result;\n', '        }\n', '\n', '        require(result > a && result > b);\n', '\n', '        return result;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(a >= b);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint result = a * b;\n', '\n', '        require(result / a == b);\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/Utils/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function isOwner() view public returns (bool) {\n', '        return msg.sender == owner;\n', '    }\n', '\n', '    modifier grantOwner {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Crowdsale/CrowdsaleToken.sol\n', '\n', 'interface CrowdsaleToken {\n', '    function transfer(address destination, uint amount) external returns (bool);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function burn(uint amount) external;\n', '}\n', '\n', '// File: contracts/Crowdsale/CryptoPoliceCrowdsale.sol\n', '\n', 'contract CryptoPoliceCrowdsale is Ownable {\n', '    using MathUtils for uint;\n', '    \n', '    enum CrowdsaleState {\n', '        Pending, Started, Ended, Paused, SoldOut\n', '    }\n', '\n', '    struct ExchangeRate {\n', '        uint tokens;\n', '        uint price;\n', '    }\n', '\n', '    struct Participant {\n', '        bool identified;\n', '        uint processedDirectWeiAmount;\n', '        uint processedExternalWeiAmount;\n', '        uint suspendedDirectWeiAmount;\n', '        uint suspendedExternalWeiAmount;\n', '    }\n', '\n', '    event ExternalPaymentReminder(uint weiAmount, bytes32 paymentChecksum);\n', '    event PaymentSuspended(address participant);\n', '    event PaymentProcessed(uint weiAmount, address participant, bytes32 paymentChecksum, uint tokenAmount);\n', '\n', '    uint public constant THRESHOLD1 = 270000000e18;\n', '    uint public constant THRESHOLD2 = 350000000e18;\n', '    uint public constant THRESHOLD3 = 490000000e18;\n', '    uint public constant THRESHOLD4 = 510000000e18;\n', '\n', '    uint public constant RELEASE_THRESHOLD = 11111111e18;\n', '\n', '    address public admin;\n', '\n', '    /**\n', '     * Amount of tokens sold in this crowdsale\n', '     */\n', '    uint public tokensSold;\n', '\n', '    /**\n', '     * Minimum number of Wei that can be exchanged for tokens\n', '     */\n', '    uint public minSale = 0.01 ether;\n', '    \n', '    /**\n', '     * Amount of direct Wei paid to the contract that has not yet been processed\n', '     */\n', '    uint public suspendedPayments = 0;\n', '\n', '    /**\n', '     * Token that will be sold\n', '     */\n', '    CrowdsaleToken public token;\n', '    \n', '    /**\n', '     * State in which the crowdsale is in\n', '     */\n', '    CrowdsaleState public state = CrowdsaleState.Pending;\n', '\n', '    /**\n', '     * List of exchange rates for each token volume\n', '     */\n', '    ExchangeRate[4] public exchangeRates;\n', '    \n', '    bool public crowdsaleEndedSuccessfully = false;\n', '\n', '    /**\n', '     * Number of Wei that can be paid without carrying out KYC process\n', '     */\n', '    uint public unidentifiedSaleLimit = 1.45 ether;\n', '\n', '    /**\n', '     * Crowdsale participants that have made payments\n', '     */\n', '    mapping(address => Participant) public participants;\n', '\n', '    /**\n', '     * Map external payment reference hash to that payment description\n', '     */\n', '    mapping(bytes32 => string) public externalPaymentDescriptions;\n', '\n', '    /**\n', '     * Map participants to list of their external payment reference hashes\n', '     */\n', '    mapping(address => bytes32[]) public participantExternalPaymentChecksums;\n', '\n', '    mapping(address => bytes32[]) public participantSuspendedExternalPaymentChecksums;\n', '\n', '    /**\n', '     * Map external payment checksum to payment amount\n', '     */\n', '    mapping(bytes32 => uint) public suspendedExternalPayments;\n', '\n', '    mapping(address => bool) public bannedParticipants;\n', '\n', '    bool public revertSuspendedPayment = false;\n', '\n', '    /**\n', '     * 1) Process payment when crowdsale started by sending tokens in return\n', '     * 2) Issue a refund when crowdsale ended unsuccessfully \n', '     */\n', '    function () public payable {\n', '        if (state == CrowdsaleState.Ended) {\n', '            msg.sender.transfer(msg.value);\n', '            refundParticipant(msg.sender);\n', '        } else {\n', '            require(state == CrowdsaleState.Started, "Crowdsale currently inactive");\n', '            processPayment(msg.sender, msg.value, "");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Recursively caluclates number of tokens that can be exchanged for given payment \n', '     *\n', '     * @param salePosition Number of tokens processed in crowdsale so far\n', '     * @param _paymentReminder Number of Wei remaining from payment so far\n', '     * @param _processedTokenCount Number of tokens that can be exchanged so far\n', '     *\n', '     * @return paymentReminder Number of Wei remaining from payment\n', '     * @return processedTokenCount Number of tokens that can be exchanged\n', '     * @return soldOut Indicates whether or not there would be no more tokens left after this exchange\n', '     */\n', '    function exchangeCalculator(uint salePosition, uint _paymentReminder, uint _processedTokenCount)\n', '    internal view returns (uint paymentReminder, uint processedTokenCount, bool soldOut)\n', '    {\n', '        uint threshold = getTreshold(salePosition);\n', '        ExchangeRate memory currentExchangeRate = getExchangeRate(threshold);\n', '\n', '        // how many round number of portions are left for exchange\n', '        uint availablePortions = (threshold - salePosition) / currentExchangeRate.tokens;\n', '\n', '        // this indicates that there are no leftover tokens that can be exchanged\n', '        // without stepping over threshold\n', '        if (availablePortions == 0) {\n', '            if (threshold == THRESHOLD4) {\n', '                return (_paymentReminder, _processedTokenCount, true);\n', '            }\n', '            // move sale position to current threshold\n', '            return exchangeCalculator(threshold, _paymentReminder, _processedTokenCount);\n', '        }\n', '\n', '        uint requestedPortions = _paymentReminder / currentExchangeRate.price;\n', '        uint portions = requestedPortions > availablePortions ? availablePortions : requestedPortions;\n', '        uint newProcessedTokenCount = _processedTokenCount + portions * currentExchangeRate.tokens;\n', '        uint newPaymentReminder = _paymentReminder - portions * currentExchangeRate.price;\n', '        uint newSalePosition = salePosition + newProcessedTokenCount;\n', '\n', '        if (newPaymentReminder < currentExchangeRate.price) {\n', '            return (newPaymentReminder, newProcessedTokenCount, false);\n', '        }\n', '        \n', '        return exchangeCalculator(newSalePosition, newPaymentReminder, newProcessedTokenCount);\n', '    }\n', '\n', '    function processPayment(address participant, uint payment, bytes32 externalPaymentChecksum) internal {\n', '        require(payment >= minSale, "Payment must be greather or equal to sale minimum");\n', '        require(bannedParticipants[participant] == false, "Participant is banned");\n', '\n', '        uint paymentReminder;\n', '        uint processedTokenCount;\n', '        bool soldOut;\n', '\n', '        (paymentReminder, processedTokenCount, soldOut) = exchangeCalculator(tokensSold, payment, 0);\n', '\n', '        // how much was actually spent from this payment\n', '        uint spent = payment - paymentReminder;\n', '        bool directPayment = externalPaymentChecksum == "";\n', '\n', '        if (participants[participant].identified == false) {\n', '            // how much participant has spent in crowdsale so far\n', '            uint spendings = participants[participant].processedDirectWeiAmount\n', '                .add(participants[participant].processedExternalWeiAmount).add(spent);\n', '\n', '            bool hasSuspendedPayments = participants[participant].suspendedDirectWeiAmount > 0 || participants[participant].suspendedExternalWeiAmount > 0;\n', '\n', '            // due to fluctuations of unidentified payment limit, it might not be reached\n', '            // suspend current payment if participant currently has suspended payments or limit reached\n', '            if (hasSuspendedPayments || spendings > unidentifiedSaleLimit) {\n', '                require(revertSuspendedPayment == false, "Participant does not comply with KYC");\n', '\n', '                suspendedPayments = suspendedPayments + payment;\n', '\n', '                if (directPayment) {\n', '                    participants[participant].suspendedDirectWeiAmount = participants[participant].suspendedDirectWeiAmount.add(payment);\n', '                } else {\n', '                    participantSuspendedExternalPaymentChecksums[participant].push(externalPaymentChecksum);\n', '                    participants[participant].suspendedExternalWeiAmount = participants[participant].suspendedExternalWeiAmount.add(payment);\n', '                    suspendedExternalPayments[externalPaymentChecksum] = payment;\n', '                }\n', '\n', '                emit PaymentSuspended(participant);\n', '\n', '                return;\n', '            }\n', '        }\n', '\n', '        // unspent reminder must be returned back to participant\n', '        if (paymentReminder > 0) {\n', '            if (directPayment) {\n', '                participant.transfer(paymentReminder);\n', '            } else {\n', '                emit ExternalPaymentReminder(paymentReminder, externalPaymentChecksum);\n', '            }\n', '        }\n', '\n', '        if (directPayment) {\n', '            participants[participant].processedDirectWeiAmount = participants[participant].processedDirectWeiAmount.add(spent);\n', '        } else {\n', '            participants[participant].processedExternalWeiAmount = participants[participant].processedExternalWeiAmount.add(spent);\n', '        }\n', '\n', '        require(token.transfer(participant, processedTokenCount), "Failed to transfer tokens");\n', '        \n', '        if (soldOut) {\n', '            state = CrowdsaleState.SoldOut;\n', '        }\n', '        \n', '        tokensSold = tokensSold + processedTokenCount;\n', '\n', '        emit PaymentProcessed(spent, participant, externalPaymentChecksum, processedTokenCount);\n', '    }\n', '\n', '    /**\n', '     * Intended when other currencies are received and owner has to carry out exchange\n', '     * for those payments aligned to Wei\n', '     */\n', '    function proxyExchange(address beneficiary, uint payment, string description, bytes32 checksum)\n', '    public grantOwnerOrAdmin\n', '    {\n', '        require(beneficiary != address(0), "Beneficiary not specified");\n', '        require(bytes(description).length > 0, "Description not specified");\n', '        require(checksum.length > 0, "Checksum not specified");\n', '        // make sure that payment has not been processed yet\n', '        require(bytes(externalPaymentDescriptions[checksum]).length == 0, "Payment already processed");\n', '\n', '        processPayment(beneficiary, payment, checksum);\n', '        \n', '        externalPaymentDescriptions[checksum] = description;\n', '        participantExternalPaymentChecksums[beneficiary].push(checksum);\n', '    }\n', '\n', '    /**\n', '     * Command for owner to start crowdsale\n', '     */\n', '    function startCrowdsale(address crowdsaleToken, address adminAddress) public grantOwner {\n', '        require(state == CrowdsaleState.Pending);\n', '        setAdmin(adminAddress);\n', '        token = CrowdsaleToken(crowdsaleToken);\n', '        require(token.balanceOf(address(this)) == 510000000e18);\n', '        state = CrowdsaleState.Started;\n', '    }\n', '\n', '    function pauseCrowdsale() public grantOwnerOrAdmin {\n', '        require(state == CrowdsaleState.Started);\n', '        state = CrowdsaleState.Paused;\n', '    }\n', '\n', '    function unPauseCrowdsale() public grantOwnerOrAdmin {\n', '        require(state == CrowdsaleState.Paused);\n', '        state = CrowdsaleState.Started;\n', '    }\n', '\n', '    /**\n', '     * Command for owner to end crowdsale\n', '     */\n', '    function endCrowdsale(bool success) public grantOwner notEnded {\n', '        state = CrowdsaleState.Ended;\n', '        crowdsaleEndedSuccessfully = success;\n', '\n', '        uint balance = address(this).balance;\n', '\n', '        if (success && balance > 0) {\n', '            uint amount = balance.sub(suspendedPayments);\n', '            owner.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function markParticipantIdentifiend(address participant) public grantOwnerOrAdmin notEnded {\n', '        participants[participant].identified = true;\n', '\n', '        if (participants[participant].suspendedDirectWeiAmount > 0) {\n', '            processPayment(participant, participants[participant].suspendedDirectWeiAmount, "");\n', '            suspendedPayments = suspendedPayments.sub(participants[participant].suspendedDirectWeiAmount);\n', '            participants[participant].suspendedDirectWeiAmount = 0;\n', '        }\n', '\n', '        if (participants[participant].suspendedExternalWeiAmount > 0) {\n', '            bytes32[] storage checksums = participantSuspendedExternalPaymentChecksums[participant];\n', '            for (uint i = 0; i < checksums.length; i++) {\n', '                processPayment(participant, suspendedExternalPayments[checksums[i]], checksums[i]);\n', '                suspendedExternalPayments[checksums[i]] = 0;\n', '            }\n', '            participants[participant].suspendedExternalWeiAmount = 0;\n', '            participantSuspendedExternalPaymentChecksums[participant] = new bytes32[](0);\n', '        }\n', '    }\n', '\n', '    function unidentifyParticipant(address participant) public grantOwnerOrAdmin notEnded {\n', '        participants[participant].identified = false;\n', '    }\n', '\n', '    function returnSuspendedPayments(address participant) public grantOwnerOrAdmin {\n', '        returnDirectPayments(participant, false, true);\n', '        returnExternalPayments(participant, false, true);\n', '    }\n', '\n', '    function updateUnidentifiedSaleLimit(uint limit) public grantOwnerOrAdmin notEnded {\n', '        unidentifiedSaleLimit = limit;\n', '    }\n', '\n', '    function updateMinSale(uint weiAmount) public grantOwnerOrAdmin {\n', '        minSale = weiAmount;\n', '    }\n', '\n', '    /**\n', '     * Allow crowdsale participant to get refunded\n', '     */\n', '    function refundParticipant(address participant) internal {\n', '        require(state == CrowdsaleState.Ended);\n', '        require(crowdsaleEndedSuccessfully == false);\n', '        \n', '        returnDirectPayments(participant, true, true);\n', '        returnExternalPayments(participant, true, true);\n', '    }\n', '\n', '    function refund(address participant) public grantOwner {\n', '        refundParticipant(participant);\n', '    }\n', '\n', '    function burnLeftoverTokens(uint8 percentage) public grantOwner {\n', '        require(state == CrowdsaleState.Ended);\n', '        require(percentage <= 100 && percentage > 0);\n', '\n', '        uint balance = token.balanceOf(address(this));\n', '\n', '        if (balance > 0) {\n', '            uint amount = balance / (100 / percentage);\n', '            token.burn(amount);\n', '        }\n', '    }\n', '\n', '    function updateExchangeRate(uint8 idx, uint tokens, uint price) public grantOwnerOrAdmin {\n', '        require(tokens > 0 && price > 0);\n', '        require(idx >= 0 && idx <= 3);\n', '\n', '        exchangeRates[idx] = ExchangeRate({\n', '            tokens: tokens,\n', '            price: price\n', '        });\n', '    }\n', '\n', '    function ban(address participant) public grantOwnerOrAdmin {\n', '        bannedParticipants[participant] = true;\n', '    }\n', '\n', '    function unBan(address participant) public grantOwnerOrAdmin {\n', '        bannedParticipants[participant] = false;\n', '    }\n', '\n', '    function getExchangeRate(uint threshold) internal view returns (ExchangeRate) {\n', '        uint8 idx = exchangeRateIdx(threshold);\n', '\n', '        ExchangeRate storage rate = exchangeRates[idx];\n', '\n', '        require(rate.tokens > 0 && rate.price > 0, "Exchange rate not set");\n', '\n', '        return rate;\n', '    }\n', '\n', '    function getTreshold(uint salePosition) internal pure returns (uint) {\n', '        if (salePosition < THRESHOLD1) {\n', '            return THRESHOLD1;\n', '        }\n', '        if (salePosition < THRESHOLD2) {\n', '            return THRESHOLD2;\n', '        }\n', '        if (salePosition < THRESHOLD3) {\n', '            return THRESHOLD3;\n', '        }\n', '        if (salePosition < THRESHOLD4) {\n', '            return THRESHOLD4;\n', '        }\n', '\n', '        assert(false);\n', '    }\n', '\n', '    function exchangeRateIdx(uint threshold) internal pure returns (uint8) {\n', '        if (threshold == THRESHOLD1) {\n', '            return 0;\n', '        }\n', '        if (threshold == THRESHOLD2) {\n', '            return 1;\n', '        }\n', '        if (threshold == THRESHOLD3) {\n', '            return 2;\n', '        }\n', '        if (threshold == THRESHOLD4) {\n', '            return 3;\n', '        }\n', '\n', '        assert(false);\n', '    }\n', '\n', '    function updateRevertSuspendedPayment(bool value) public grantOwnerOrAdmin {\n', '        revertSuspendedPayment = value;\n', '    }\n', '\n', '    /**\n', '     * Transfer Wei sent to the contract directly back to the participant\n', '     *\n', '     * @param participant Participant\n', '     * @param processed Whether or not processed payments should be included\n', '     * @param suspended Whether or not suspended payments should be included\n', '     */\n', '    function returnDirectPayments(address participant, bool processed, bool suspended) internal {\n', '        if (processed && participants[participant].processedDirectWeiAmount > 0) {\n', '            participant.transfer(participants[participant].processedDirectWeiAmount);\n', '            participants[participant].processedDirectWeiAmount = 0;\n', '        }\n', '\n', '        if (suspended && participants[participant].suspendedDirectWeiAmount > 0) {\n', '            participant.transfer(participants[participant].suspendedDirectWeiAmount);\n', '            participants[participant].suspendedDirectWeiAmount = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Signal that externally made payments should be returned back to the participant\n', '     *\n', '     * @param participant Participant\n', '     * @param processed Whether or not processed payments should be included\n', '     * @param suspended Whether or not suspended payments should be included\n', '     */\n', '    function returnExternalPayments(address participant, bool processed, bool suspended) internal {\n', '        if (processed && participants[participant].processedExternalWeiAmount > 0) {\n', '            participants[participant].processedExternalWeiAmount = 0;\n', '        }\n', '        \n', '        if (suspended && participants[participant].suspendedExternalWeiAmount > 0) {\n', '            participants[participant].suspendedExternalWeiAmount = 0;\n', '        }\n', '    }\n', '\n', '    function setAdmin(address adminAddress) public grantOwner {\n', '        admin = adminAddress;\n', '        require(isAdminSet());\n', '    }\n', '\n', '    function transwerFunds(uint amount) public grantOwner {\n', '        require(RELEASE_THRESHOLD <= tokensSold, "There are not enaugh tokens sold");\n', '        \n', '        uint transferAmount = amount;\n', '        uint balance = address(this).balance;\n', '\n', '        if (balance < amount) {\n', '            transferAmount = balance;\n', '        }\n', '\n', '        owner.transfer(transferAmount);\n', '    } \n', '\n', '    function isAdminSet() internal view returns(bool) {\n', '        return admin != address(0);\n', '    }\n', '\n', '    function isAdmin() internal view returns(bool) {\n', '        return isAdminSet() && msg.sender == admin;\n', '    }\n', '\n', '    function isCrowdsaleSuccessful() public view returns(bool) {\n', '        return state == CrowdsaleState.Ended && crowdsaleEndedSuccessfully;\n', '    }\n', '\n', '    modifier notEnded {\n', '        require(state != CrowdsaleState.Ended, "Crowdsale ended");\n', '        _;\n', '    }\n', '\n', '    modifier grantOwnerOrAdmin() {\n', '        require(isOwner() || isAdmin());\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Utils/Math.sol\n', '\n', 'library MathUtils {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint result = a + b;\n', '\n', '        if (a == 0 || b == 0) {\n', '            return result;\n', '        }\n', '\n', '        require(result > a && result > b);\n', '\n', '        return result;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(a >= b);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint result = a * b;\n', '\n', '        require(result / a == b);\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/Utils/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function isOwner() view public returns (bool) {\n', '        return msg.sender == owner;\n', '    }\n', '\n', '    modifier grantOwner {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/Crowdsale/CrowdsaleToken.sol\n', '\n', 'interface CrowdsaleToken {\n', '    function transfer(address destination, uint amount) external returns (bool);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function burn(uint amount) external;\n', '}\n', '\n', '// File: contracts/Crowdsale/CryptoPoliceCrowdsale.sol\n', '\n', 'contract CryptoPoliceCrowdsale is Ownable {\n', '    using MathUtils for uint;\n', '    \n', '    enum CrowdsaleState {\n', '        Pending, Started, Ended, Paused, SoldOut\n', '    }\n', '\n', '    struct ExchangeRate {\n', '        uint tokens;\n', '        uint price;\n', '    }\n', '\n', '    struct Participant {\n', '        bool identified;\n', '        uint processedDirectWeiAmount;\n', '        uint processedExternalWeiAmount;\n', '        uint suspendedDirectWeiAmount;\n', '        uint suspendedExternalWeiAmount;\n', '    }\n', '\n', '    event ExternalPaymentReminder(uint weiAmount, bytes32 paymentChecksum);\n', '    event PaymentSuspended(address participant);\n', '    event PaymentProcessed(uint weiAmount, address participant, bytes32 paymentChecksum, uint tokenAmount);\n', '\n', '    uint public constant THRESHOLD1 = 270000000e18;\n', '    uint public constant THRESHOLD2 = 350000000e18;\n', '    uint public constant THRESHOLD3 = 490000000e18;\n', '    uint public constant THRESHOLD4 = 510000000e18;\n', '\n', '    uint public constant RELEASE_THRESHOLD = 11111111e18;\n', '\n', '    address public admin;\n', '\n', '    /**\n', '     * Amount of tokens sold in this crowdsale\n', '     */\n', '    uint public tokensSold;\n', '\n', '    /**\n', '     * Minimum number of Wei that can be exchanged for tokens\n', '     */\n', '    uint public minSale = 0.01 ether;\n', '    \n', '    /**\n', '     * Amount of direct Wei paid to the contract that has not yet been processed\n', '     */\n', '    uint public suspendedPayments = 0;\n', '\n', '    /**\n', '     * Token that will be sold\n', '     */\n', '    CrowdsaleToken public token;\n', '    \n', '    /**\n', '     * State in which the crowdsale is in\n', '     */\n', '    CrowdsaleState public state = CrowdsaleState.Pending;\n', '\n', '    /**\n', '     * List of exchange rates for each token volume\n', '     */\n', '    ExchangeRate[4] public exchangeRates;\n', '    \n', '    bool public crowdsaleEndedSuccessfully = false;\n', '\n', '    /**\n', '     * Number of Wei that can be paid without carrying out KYC process\n', '     */\n', '    uint public unidentifiedSaleLimit = 1.45 ether;\n', '\n', '    /**\n', '     * Crowdsale participants that have made payments\n', '     */\n', '    mapping(address => Participant) public participants;\n', '\n', '    /**\n', '     * Map external payment reference hash to that payment description\n', '     */\n', '    mapping(bytes32 => string) public externalPaymentDescriptions;\n', '\n', '    /**\n', '     * Map participants to list of their external payment reference hashes\n', '     */\n', '    mapping(address => bytes32[]) public participantExternalPaymentChecksums;\n', '\n', '    mapping(address => bytes32[]) public participantSuspendedExternalPaymentChecksums;\n', '\n', '    /**\n', '     * Map external payment checksum to payment amount\n', '     */\n', '    mapping(bytes32 => uint) public suspendedExternalPayments;\n', '\n', '    mapping(address => bool) public bannedParticipants;\n', '\n', '    bool public revertSuspendedPayment = false;\n', '\n', '    /**\n', '     * 1) Process payment when crowdsale started by sending tokens in return\n', '     * 2) Issue a refund when crowdsale ended unsuccessfully \n', '     */\n', '    function () public payable {\n', '        if (state == CrowdsaleState.Ended) {\n', '            msg.sender.transfer(msg.value);\n', '            refundParticipant(msg.sender);\n', '        } else {\n', '            require(state == CrowdsaleState.Started, "Crowdsale currently inactive");\n', '            processPayment(msg.sender, msg.value, "");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Recursively caluclates number of tokens that can be exchanged for given payment \n', '     *\n', '     * @param salePosition Number of tokens processed in crowdsale so far\n', '     * @param _paymentReminder Number of Wei remaining from payment so far\n', '     * @param _processedTokenCount Number of tokens that can be exchanged so far\n', '     *\n', '     * @return paymentReminder Number of Wei remaining from payment\n', '     * @return processedTokenCount Number of tokens that can be exchanged\n', '     * @return soldOut Indicates whether or not there would be no more tokens left after this exchange\n', '     */\n', '    function exchangeCalculator(uint salePosition, uint _paymentReminder, uint _processedTokenCount)\n', '    internal view returns (uint paymentReminder, uint processedTokenCount, bool soldOut)\n', '    {\n', '        uint threshold = getTreshold(salePosition);\n', '        ExchangeRate memory currentExchangeRate = getExchangeRate(threshold);\n', '\n', '        // how many round number of portions are left for exchange\n', '        uint availablePortions = (threshold - salePosition) / currentExchangeRate.tokens;\n', '\n', '        // this indicates that there are no leftover tokens that can be exchanged\n', '        // without stepping over threshold\n', '        if (availablePortions == 0) {\n', '            if (threshold == THRESHOLD4) {\n', '                return (_paymentReminder, _processedTokenCount, true);\n', '            }\n', '            // move sale position to current threshold\n', '            return exchangeCalculator(threshold, _paymentReminder, _processedTokenCount);\n', '        }\n', '\n', '        uint requestedPortions = _paymentReminder / currentExchangeRate.price;\n', '        uint portions = requestedPortions > availablePortions ? availablePortions : requestedPortions;\n', '        uint newProcessedTokenCount = _processedTokenCount + portions * currentExchangeRate.tokens;\n', '        uint newPaymentReminder = _paymentReminder - portions * currentExchangeRate.price;\n', '        uint newSalePosition = salePosition + newProcessedTokenCount;\n', '\n', '        if (newPaymentReminder < currentExchangeRate.price) {\n', '            return (newPaymentReminder, newProcessedTokenCount, false);\n', '        }\n', '        \n', '        return exchangeCalculator(newSalePosition, newPaymentReminder, newProcessedTokenCount);\n', '    }\n', '\n', '    function processPayment(address participant, uint payment, bytes32 externalPaymentChecksum) internal {\n', '        require(payment >= minSale, "Payment must be greather or equal to sale minimum");\n', '        require(bannedParticipants[participant] == false, "Participant is banned");\n', '\n', '        uint paymentReminder;\n', '        uint processedTokenCount;\n', '        bool soldOut;\n', '\n', '        (paymentReminder, processedTokenCount, soldOut) = exchangeCalculator(tokensSold, payment, 0);\n', '\n', '        // how much was actually spent from this payment\n', '        uint spent = payment - paymentReminder;\n', '        bool directPayment = externalPaymentChecksum == "";\n', '\n', '        if (participants[participant].identified == false) {\n', '            // how much participant has spent in crowdsale so far\n', '            uint spendings = participants[participant].processedDirectWeiAmount\n', '                .add(participants[participant].processedExternalWeiAmount).add(spent);\n', '\n', '            bool hasSuspendedPayments = participants[participant].suspendedDirectWeiAmount > 0 || participants[participant].suspendedExternalWeiAmount > 0;\n', '\n', '            // due to fluctuations of unidentified payment limit, it might not be reached\n', '            // suspend current payment if participant currently has suspended payments or limit reached\n', '            if (hasSuspendedPayments || spendings > unidentifiedSaleLimit) {\n', '                require(revertSuspendedPayment == false, "Participant does not comply with KYC");\n', '\n', '                suspendedPayments = suspendedPayments + payment;\n', '\n', '                if (directPayment) {\n', '                    participants[participant].suspendedDirectWeiAmount = participants[participant].suspendedDirectWeiAmount.add(payment);\n', '                } else {\n', '                    participantSuspendedExternalPaymentChecksums[participant].push(externalPaymentChecksum);\n', '                    participants[participant].suspendedExternalWeiAmount = participants[participant].suspendedExternalWeiAmount.add(payment);\n', '                    suspendedExternalPayments[externalPaymentChecksum] = payment;\n', '                }\n', '\n', '                emit PaymentSuspended(participant);\n', '\n', '                return;\n', '            }\n', '        }\n', '\n', '        // unspent reminder must be returned back to participant\n', '        if (paymentReminder > 0) {\n', '            if (directPayment) {\n', '                participant.transfer(paymentReminder);\n', '            } else {\n', '                emit ExternalPaymentReminder(paymentReminder, externalPaymentChecksum);\n', '            }\n', '        }\n', '\n', '        if (directPayment) {\n', '            participants[participant].processedDirectWeiAmount = participants[participant].processedDirectWeiAmount.add(spent);\n', '        } else {\n', '            participants[participant].processedExternalWeiAmount = participants[participant].processedExternalWeiAmount.add(spent);\n', '        }\n', '\n', '        require(token.transfer(participant, processedTokenCount), "Failed to transfer tokens");\n', '        \n', '        if (soldOut) {\n', '            state = CrowdsaleState.SoldOut;\n', '        }\n', '        \n', '        tokensSold = tokensSold + processedTokenCount;\n', '\n', '        emit PaymentProcessed(spent, participant, externalPaymentChecksum, processedTokenCount);\n', '    }\n', '\n', '    /**\n', '     * Intended when other currencies are received and owner has to carry out exchange\n', '     * for those payments aligned to Wei\n', '     */\n', '    function proxyExchange(address beneficiary, uint payment, string description, bytes32 checksum)\n', '    public grantOwnerOrAdmin\n', '    {\n', '        require(beneficiary != address(0), "Beneficiary not specified");\n', '        require(bytes(description).length > 0, "Description not specified");\n', '        require(checksum.length > 0, "Checksum not specified");\n', '        // make sure that payment has not been processed yet\n', '        require(bytes(externalPaymentDescriptions[checksum]).length == 0, "Payment already processed");\n', '\n', '        processPayment(beneficiary, payment, checksum);\n', '        \n', '        externalPaymentDescriptions[checksum] = description;\n', '        participantExternalPaymentChecksums[beneficiary].push(checksum);\n', '    }\n', '\n', '    /**\n', '     * Command for owner to start crowdsale\n', '     */\n', '    function startCrowdsale(address crowdsaleToken, address adminAddress) public grantOwner {\n', '        require(state == CrowdsaleState.Pending);\n', '        setAdmin(adminAddress);\n', '        token = CrowdsaleToken(crowdsaleToken);\n', '        require(token.balanceOf(address(this)) == 510000000e18);\n', '        state = CrowdsaleState.Started;\n', '    }\n', '\n', '    function pauseCrowdsale() public grantOwnerOrAdmin {\n', '        require(state == CrowdsaleState.Started);\n', '        state = CrowdsaleState.Paused;\n', '    }\n', '\n', '    function unPauseCrowdsale() public grantOwnerOrAdmin {\n', '        require(state == CrowdsaleState.Paused);\n', '        state = CrowdsaleState.Started;\n', '    }\n', '\n', '    /**\n', '     * Command for owner to end crowdsale\n', '     */\n', '    function endCrowdsale(bool success) public grantOwner notEnded {\n', '        state = CrowdsaleState.Ended;\n', '        crowdsaleEndedSuccessfully = success;\n', '\n', '        uint balance = address(this).balance;\n', '\n', '        if (success && balance > 0) {\n', '            uint amount = balance.sub(suspendedPayments);\n', '            owner.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function markParticipantIdentifiend(address participant) public grantOwnerOrAdmin notEnded {\n', '        participants[participant].identified = true;\n', '\n', '        if (participants[participant].suspendedDirectWeiAmount > 0) {\n', '            processPayment(participant, participants[participant].suspendedDirectWeiAmount, "");\n', '            suspendedPayments = suspendedPayments.sub(participants[participant].suspendedDirectWeiAmount);\n', '            participants[participant].suspendedDirectWeiAmount = 0;\n', '        }\n', '\n', '        if (participants[participant].suspendedExternalWeiAmount > 0) {\n', '            bytes32[] storage checksums = participantSuspendedExternalPaymentChecksums[participant];\n', '            for (uint i = 0; i < checksums.length; i++) {\n', '                processPayment(participant, suspendedExternalPayments[checksums[i]], checksums[i]);\n', '                suspendedExternalPayments[checksums[i]] = 0;\n', '            }\n', '            participants[participant].suspendedExternalWeiAmount = 0;\n', '            participantSuspendedExternalPaymentChecksums[participant] = new bytes32[](0);\n', '        }\n', '    }\n', '\n', '    function unidentifyParticipant(address participant) public grantOwnerOrAdmin notEnded {\n', '        participants[participant].identified = false;\n', '    }\n', '\n', '    function returnSuspendedPayments(address participant) public grantOwnerOrAdmin {\n', '        returnDirectPayments(participant, false, true);\n', '        returnExternalPayments(participant, false, true);\n', '    }\n', '\n', '    function updateUnidentifiedSaleLimit(uint limit) public grantOwnerOrAdmin notEnded {\n', '        unidentifiedSaleLimit = limit;\n', '    }\n', '\n', '    function updateMinSale(uint weiAmount) public grantOwnerOrAdmin {\n', '        minSale = weiAmount;\n', '    }\n', '\n', '    /**\n', '     * Allow crowdsale participant to get refunded\n', '     */\n', '    function refundParticipant(address participant) internal {\n', '        require(state == CrowdsaleState.Ended);\n', '        require(crowdsaleEndedSuccessfully == false);\n', '        \n', '        returnDirectPayments(participant, true, true);\n', '        returnExternalPayments(participant, true, true);\n', '    }\n', '\n', '    function refund(address participant) public grantOwner {\n', '        refundParticipant(participant);\n', '    }\n', '\n', '    function burnLeftoverTokens(uint8 percentage) public grantOwner {\n', '        require(state == CrowdsaleState.Ended);\n', '        require(percentage <= 100 && percentage > 0);\n', '\n', '        uint balance = token.balanceOf(address(this));\n', '\n', '        if (balance > 0) {\n', '            uint amount = balance / (100 / percentage);\n', '            token.burn(amount);\n', '        }\n', '    }\n', '\n', '    function updateExchangeRate(uint8 idx, uint tokens, uint price) public grantOwnerOrAdmin {\n', '        require(tokens > 0 && price > 0);\n', '        require(idx >= 0 && idx <= 3);\n', '\n', '        exchangeRates[idx] = ExchangeRate({\n', '            tokens: tokens,\n', '            price: price\n', '        });\n', '    }\n', '\n', '    function ban(address participant) public grantOwnerOrAdmin {\n', '        bannedParticipants[participant] = true;\n', '    }\n', '\n', '    function unBan(address participant) public grantOwnerOrAdmin {\n', '        bannedParticipants[participant] = false;\n', '    }\n', '\n', '    function getExchangeRate(uint threshold) internal view returns (ExchangeRate) {\n', '        uint8 idx = exchangeRateIdx(threshold);\n', '\n', '        ExchangeRate storage rate = exchangeRates[idx];\n', '\n', '        require(rate.tokens > 0 && rate.price > 0, "Exchange rate not set");\n', '\n', '        return rate;\n', '    }\n', '\n', '    function getTreshold(uint salePosition) internal pure returns (uint) {\n', '        if (salePosition < THRESHOLD1) {\n', '            return THRESHOLD1;\n', '        }\n', '        if (salePosition < THRESHOLD2) {\n', '            return THRESHOLD2;\n', '        }\n', '        if (salePosition < THRESHOLD3) {\n', '            return THRESHOLD3;\n', '        }\n', '        if (salePosition < THRESHOLD4) {\n', '            return THRESHOLD4;\n', '        }\n', '\n', '        assert(false);\n', '    }\n', '\n', '    function exchangeRateIdx(uint threshold) internal pure returns (uint8) {\n', '        if (threshold == THRESHOLD1) {\n', '            return 0;\n', '        }\n', '        if (threshold == THRESHOLD2) {\n', '            return 1;\n', '        }\n', '        if (threshold == THRESHOLD3) {\n', '            return 2;\n', '        }\n', '        if (threshold == THRESHOLD4) {\n', '            return 3;\n', '        }\n', '\n', '        assert(false);\n', '    }\n', '\n', '    function updateRevertSuspendedPayment(bool value) public grantOwnerOrAdmin {\n', '        revertSuspendedPayment = value;\n', '    }\n', '\n', '    /**\n', '     * Transfer Wei sent to the contract directly back to the participant\n', '     *\n', '     * @param participant Participant\n', '     * @param processed Whether or not processed payments should be included\n', '     * @param suspended Whether or not suspended payments should be included\n', '     */\n', '    function returnDirectPayments(address participant, bool processed, bool suspended) internal {\n', '        if (processed && participants[participant].processedDirectWeiAmount > 0) {\n', '            participant.transfer(participants[participant].processedDirectWeiAmount);\n', '            participants[participant].processedDirectWeiAmount = 0;\n', '        }\n', '\n', '        if (suspended && participants[participant].suspendedDirectWeiAmount > 0) {\n', '            participant.transfer(participants[participant].suspendedDirectWeiAmount);\n', '            participants[participant].suspendedDirectWeiAmount = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Signal that externally made payments should be returned back to the participant\n', '     *\n', '     * @param participant Participant\n', '     * @param processed Whether or not processed payments should be included\n', '     * @param suspended Whether or not suspended payments should be included\n', '     */\n', '    function returnExternalPayments(address participant, bool processed, bool suspended) internal {\n', '        if (processed && participants[participant].processedExternalWeiAmount > 0) {\n', '            participants[participant].processedExternalWeiAmount = 0;\n', '        }\n', '        \n', '        if (suspended && participants[participant].suspendedExternalWeiAmount > 0) {\n', '            participants[participant].suspendedExternalWeiAmount = 0;\n', '        }\n', '    }\n', '\n', '    function setAdmin(address adminAddress) public grantOwner {\n', '        admin = adminAddress;\n', '        require(isAdminSet());\n', '    }\n', '\n', '    function transwerFunds(uint amount) public grantOwner {\n', '        require(RELEASE_THRESHOLD <= tokensSold, "There are not enaugh tokens sold");\n', '        \n', '        uint transferAmount = amount;\n', '        uint balance = address(this).balance;\n', '\n', '        if (balance < amount) {\n', '            transferAmount = balance;\n', '        }\n', '\n', '        owner.transfer(transferAmount);\n', '    } \n', '\n', '    function isAdminSet() internal view returns(bool) {\n', '        return admin != address(0);\n', '    }\n', '\n', '    function isAdmin() internal view returns(bool) {\n', '        return isAdminSet() && msg.sender == admin;\n', '    }\n', '\n', '    function isCrowdsaleSuccessful() public view returns(bool) {\n', '        return state == CrowdsaleState.Ended && crowdsaleEndedSuccessfully;\n', '    }\n', '\n', '    modifier notEnded {\n', '        require(state != CrowdsaleState.Ended, "Crowdsale ended");\n', '        _;\n', '    }\n', '\n', '    modifier grantOwnerOrAdmin() {\n', '        require(isOwner() || isAdmin());\n', '        _;\n', '    }\n', '}']
