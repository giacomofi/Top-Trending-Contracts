['/**\n', ' * Copyright (c) 2018 blockimmo AG <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1b7772787e75687e5b797774787072767674357873">[email&#160;protected]</a>\n', ' * Non-Profit Open Software License 3.0 (NPOSL-3.0)\n', ' * https://opensource.org/licenses/NPOSL-3.0\n', ' */\n', '\n', '\n', 'pragma solidity 0.4.25;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract LandRegistryProxyInterface {\n', '  function owner() public view returns (address);\n', '}\n', '\n', '\n', 'contract TokenizedPropertyInterface {\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function emitGenericProposal(string _generic) public;\n', '  function lastTransferBlock(address _account) public view returns (uint256);\n', '  function registryProxy() public view returns (LandRegistryProxyInterface);\n', '  function setManagementCompany(string _managementCompany) public;\n', '  function totalSupply() public view returns (uint256);\n', '  function transferOwnership(address _newOwner) public;\n', '  function untokenize() public;\n', '}\n', '\n', '\n', '/**\n', ' * @title ShareholderDAO\n', ' * @dev A simple DAO attached to a `TokenizedProperty` (ownership of the property is transferred to `this`).\n', ' *\n', ' * The token holders of a property `extend` and `vote` on `Proposal`s which are either executed (over 50% consensus) or rejected.\n', ' * Proposals are `Executed` or `Rejected` at or after their `closingTime`, when a token holder or blockimmo calls `finalize` on the proposal.\n', ' * Generic information related to a proposal can be included in the `_generic` string (ie the configuration details of an outright sale&#39;s `TokenSale`).\n', ' * `Generic` proposals can also be extended. A property&#39;s management company and / or blockimmo will try to take these as suggestions.\n', ' *\n', ' * There are only a few decisions that token holders (investors in a property) can (and need) to make.\n', ' * No need to be general. We keep it simple and minimal here, enabling our users to accomplish the necessary tasks.\n', ' * - nothing more, nothing less.\n', ' *\n', ' * Just like in the real world, for commercial investment properties a `managementCompany` makes all decisions / actions involving a property.\n', ' * Investors only need to `SetManagementCompany` - a suggestion blockimmo will always take (if possible).\n', ' *\n', ' * Aside from that, the only decisions investors need to make are:\n', ' *\n', ' * `TransferOwnership` enables `this` to be easily and reliably upgraded if consensus is reached on this proposal (ie a different form of DAO or a BDFL).\n', ' *\n', ' * Upgrading:\n', ' *   1. A token holder deploys a new `ShareholderDAO`\n', ' *   2. The token holder extends a proposal to `transferOwnership` of `TokenizedProperty` to the new DAO (1).\n', ' *\n', ' * See `TokenizedProperty`&#39;s documentation for info on `Untokenize` and how / why this is used.\n', ' */\n', 'contract ShareholderDAO {\n', '  using SafeMath for uint256;\n', '\n', '  enum Actions { SetManagementCompany, TransferOwnership, Untokenize, Generic }\n', '  enum Outcomes { Pend, Accept, Reject }\n', '  enum ProposalStatus { Null, Executed, Open, Rejected }\n', '  enum VoteStatus { Null, For, Against}\n', '\n', '  struct Vote {\n', '    VoteStatus status;\n', '    uint256 clout;\n', '  }\n', '\n', '  struct Proposal {\n', '    Actions action;\n', '    uint256 closingTime;\n', '\n', '    string managementCompany;\n', '    address owner;\n', '    string generic;\n', '\n', '    address proposer;\n', '\n', '    ProposalStatus status;\n', '    uint256 tallyFor;\n', '    uint256 tallyAgainst;\n', '    uint256 blockNumber;\n', '\n', '    mapping (address => Vote) voters;\n', '  }\n', '\n', '  mapping(bytes32 => Proposal) private proposals;\n', '  TokenizedPropertyInterface public property;\n', '\n', '  event ProposalRejected(bytes32 indexed proposal);\n', '  event ProposalExecuted(bytes32 indexed proposal);\n', '  event ProposalExtended(bytes32 indexed proposal, Actions indexed action, uint256 closingTime, string managementCompany, address owner, string generic, address indexed proposer);\n', '\n', '  event Voted(bytes32 indexed proposal, address indexed voter, uint256 clout);\n', '  event VoteRescinded(bytes32 indexed proposal, address indexed voter, uint256 clout);\n', '\n', '  constructor(TokenizedPropertyInterface _property) public {\n', '    property = _property;\n', '  }\n', '\n', '  modifier isAuthorized {\n', '    require(getClout(msg.sender) > 0 || msg.sender == property.registryProxy().owner(), "must be blockimmo or tokenholder to perform this action");  // allow blockimmo to extend proposals for all properties\n', '    _;\n', '  }\n', '\n', '  function extendProposal(Actions _action, uint256 _closingTime, string _managementCompany, address _owner, string _description) public isAuthorized {\n', '    require(block.timestamp < _closingTime, "_closingTime must be in the future");\n', '\n', '    bytes32 hash = keccak256(abi.encodePacked(_action, _closingTime, _managementCompany, _description, _owner));\n', '    require(proposals[hash].status == ProposalStatus.Null, "proposal is not unique");\n', '\n', '    proposals[hash] = Proposal(_action, _closingTime, _managementCompany, _owner, _description, msg.sender, ProposalStatus.Open, 0, 0, block.number);\n', '    emit ProposalExtended(hash, _action, _closingTime, _managementCompany, _owner, _description, msg.sender);\n', '  }\n', '\n', '  function vote(bytes32 _hash, bool _isFor) public isAuthorized {\n', '    Proposal storage p = proposals[_hash];\n', '    Vote storage v = p.voters[msg.sender];\n', '\n', '    require(p.status == ProposalStatus.Open, "vote requires proposal is open");\n', '    require(block.timestamp < p.closingTime, "vote requires proposal voting period is open");\n', '    require(p.voters[msg.sender].status == VoteStatus.Null, "voter has voted");\n', '    require(p.blockNumber > property.lastTransferBlock(msg.sender), "voter ineligible due to transfer in voting period");\n', '\n', '    uint256 clout = getClout(msg.sender);\n', '    v.clout = clout;\n', '    if (_isFor) {\n', '      v.status = VoteStatus.For;\n', '      p.tallyFor = p.tallyFor.add(clout);\n', '    } else {\n', '      v.status = VoteStatus.Against;\n', '      p.tallyAgainst = p.tallyAgainst.add(clout);\n', '    }\n', '\n', '    emit Voted(_hash, msg.sender, clout);\n', '  }\n', '\n', '  function rescindVote(bytes32 _hash) public isAuthorized {\n', '    Proposal storage p = proposals[_hash];\n', '    Vote storage v = p.voters[msg.sender];\n', '\n', '    require(p.status == ProposalStatus.Open, "rescindVote requires proposal is open");\n', '    require(block.timestamp < p.closingTime, "rescindVote requires proposal voting period is open");\n', '    require(v.status != VoteStatus.Null, "voter has not voted");\n', '\n', '    uint256 clout = v.clout;\n', '    if (v.status == VoteStatus.For) {\n', '      p.tallyFor = p.tallyFor.sub(clout);\n', '    } else if (v.status == VoteStatus.Against) {\n', '      p.tallyAgainst = p.tallyAgainst.sub(clout);\n', '    }\n', '\n', '    v.status = VoteStatus.Null;\n', '    v.clout = 0;\n', '\n', '    emit VoteRescinded(_hash, msg.sender, clout);\n', '  }\n', '\n', '  function finalize(bytes32 _hash) public isAuthorized {\n', '    Proposal storage p = proposals[_hash];\n', '\n', '    require(p.status == ProposalStatus.Open, "finalize requires proposal is open");\n', '    require(block.timestamp >= p.closingTime, "finalize requires proposal voting period is closed");\n', '\n', '    Outcomes outcome = tallyVotes(p.tallyFor);\n', '    if (outcome == Outcomes.Accept) {\n', '      executeProposal(_hash);\n', '    } else if (outcome == Outcomes.Reject) {\n', '      p.status = ProposalStatus.Rejected;\n', '      emit ProposalRejected(_hash);\n', '    }\n', '  }\n', '\n', '  function getClout(address _who) internal view returns (uint256 clout) {\n', '    clout = property.balanceOf(_who);\n', '  }\n', '\n', '  function tallyVotes(uint256 _tallyFor) internal view returns (Outcomes outcome) {\n', '    if (_tallyFor > property.totalSupply() / 2) {\n', '      outcome = Outcomes.Accept;\n', '    } else {\n', '      outcome = Outcomes.Reject;\n', '    }\n', '  }\n', '\n', '  function executeProposal(bytes32 _hash) internal {\n', '    Proposal storage p = proposals[_hash];\n', '\n', '    if (p.action == Actions.SetManagementCompany) {\n', '      property.setManagementCompany(p.managementCompany);\n', '    } else if (p.action == Actions.TransferOwnership) {\n', '      property.transferOwnership(p.owner);\n', '    } else if (p.action == Actions.Untokenize) {\n', '      property.untokenize();\n', '    } else if (p.action == Actions.Generic) {\n', '      property.emitGenericProposal(p.generic);\n', '    }\n', '\n', '    p.status = ProposalStatus.Executed;\n', '    emit ProposalExecuted(_hash);\n', '  }\n', '}']