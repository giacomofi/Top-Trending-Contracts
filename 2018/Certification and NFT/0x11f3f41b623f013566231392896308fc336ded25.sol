['pragma solidity ^0.4.15;\n', '\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract AbstractSingularDTVToken is Token {\n', '\n', '}\n', '\n', '\n', '/// @title Token Creation contract - Implements token creation functionality.\n', '/// @author Stefan George - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f6858293909798d8919399849193b6959998859398858f85d8989382">[email&#160;protected]</a>>\n', '/// @author Razvan Pop - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1c6e7d666a7d72326c736c5c7f73726f79726f656f32727968">[email&#160;protected]</a>>\n', '/// @author Milad Mostavi - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c4a9ada8a5a0eaa9abb7b0a5b2ad84a7abaab7a1aab7bdb7eaaaa1b0">[email&#160;protected]</a>>\n', 'contract SingularDTVLaunch {\n', '    string public version = "0.1.0";\n', '\n', '    event Contributed(address indexed contributor, uint contribution, uint tokens);\n', '\n', '    /*\n', '     *  External contracts\n', '     */\n', '    AbstractSingularDTVToken public singularDTVToken;\n', '    address public workshop;\n', '    address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n', '    uint public SingularDTVWorkshopFee;\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    uint public CAP; // in wei scale of tokens\n', '    uint public DURATION; // in seconds\n', '    uint public TOKEN_TARGET; // Goal threshold in wei scale of tokens\n', '\n', '    /*\n', '     *  Enums\n', '     */\n', '    enum Stages {\n', '        Deployed,\n', '        GoingAndGoalNotReached,\n', '        EndedAndGoalNotReached,\n', '        GoingAndGoalReached,\n', '        EndedAndGoalReached\n', '    }\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public owner;\n', '    uint public startDate;\n', '    uint public fundBalance;\n', '    uint public valuePerToken; //in wei\n', '    uint public tokensSent;\n', '\n', '    // participant address => value in Wei\n', '    mapping (address => uint) public contributions;\n', '\n', '    // participant address => token amount in wei scale\n', '    mapping (address => uint) public sentTokens;\n', '\n', '    // Initialize stage\n', '    Stages public stage = Stages.Deployed;\n', '\n', '    modifier onlyOwner() {\n', '        // Only owner is allowed to do this action.\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier atStage(Stages _stage) {\n', '        if (stage != _stage) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier atStageOR(Stages _stage1, Stages _stage2) {\n', '        if (stage != _stage1 && stage != _stage2) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier timedTransitions() {\n', '        uint timeElapsed = now - startDate;\n', '\n', '        if (timeElapsed >= DURATION) {\n', '            if (stage == Stages.GoingAndGoalNotReached) {\n', '                stage = Stages.EndedAndGoalNotReached;\n', '            } else if (stage == Stages.GoingAndGoalReached) {\n', '                stage = Stages.EndedAndGoalReached;\n', '            }\n', '        }\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *  Contract functions\n', '     */\n', '    /// dev Validates invariants.\n', '    function checkInvariants() constant internal {\n', '        if (fundBalance > this.balance) {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Can be triggered if an invariant fails.\n', '    function emergencyCall()\n', '        public\n', '        returns (bool)\n', '    {\n', '        if (fundBalance > this.balance) {\n', '            if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n', '                revert();\n', '            }\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Allows user to create tokens if token creation is still going and cap not reached. Returns token count.\n', '    function fund()\n', '        public\n', '        timedTransitions\n', '        atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n', '        payable\n', '        returns (uint)\n', '    {\n', '        uint tokenCount = (msg.value * (10**18)) / valuePerToken; // Token count in wei is rounded down. Sent ETH should be multiples of valuePerToken.\n', '        require(tokenCount > 0);\n', '        if (tokensSent + tokenCount > CAP) {\n', '            // User wants to create more tokens than available. Set tokens to possible maximum.\n', '            tokenCount = CAP - tokensSent;\n', '        }\n', '        tokensSent += tokenCount;\n', '\n', '        uint contribution = (tokenCount * valuePerToken) / (10**18); // Ether spent by user.\n', '        // Send change back to user.\n', '        if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n', '            revert();\n', '        }\n', '        // Update fund and user&#39;s balance and total supply of tokens.\n', '        fundBalance += contribution;\n', '        contributions[msg.sender] += contribution;\n', '        sentTokens[msg.sender] += tokenCount;\n', '        if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n', '            // Tokens could not be issued.\n', '            revert();\n', '        }\n', '        // Update stage\n', '        if (stage == Stages.GoingAndGoalNotReached) {\n', '            if (tokensSent >= TOKEN_TARGET) {\n', '                stage = Stages.GoingAndGoalReached;\n', '            }\n', '        }\n', '        // not an else clause for the edge case that the CAP and TOKEN_TARGET are reached in one call\n', '        if (stage == Stages.GoingAndGoalReached) {\n', '            if (tokensSent == CAP) {\n', '                stage = Stages.EndedAndGoalReached;\n', '            }\n', '        }\n', '        checkInvariants();\n', '\n', '        Contributed(msg.sender, contribution, tokenCount);\n', '\n', '        return tokenCount;\n', '    }\n', '\n', '    /// @dev Allows user to withdraw ETH if token creation period ended and target was not reached. Returns contribution.\n', '    function withdrawContribution()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalNotReached)\n', '        returns (uint)\n', '    {\n', '        // We get back the tokens from the contributor before giving back his contribution\n', '        uint tokensReceived = sentTokens[msg.sender];\n', '        sentTokens[msg.sender] = 0;\n', '        if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n', '            revert();\n', '        }\n', '\n', '        // Update fund&#39;s and user&#39;s balance and total supply of tokens.\n', '        uint contribution = contributions[msg.sender];\n', '        contributions[msg.sender] = 0;\n', '        fundBalance -= contribution;\n', '        // Send ETH back to user.\n', '        if (contribution > 0) {\n', '            msg.sender.transfer(contribution);\n', '        }\n', '        checkInvariants();\n', '        return contribution;\n', '    }\n', '\n', '    /// @dev Withdraws ETH to workshop address. Returns success.\n', '    function withdrawForWorkshop()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalReached)\n', '        returns (bool)\n', '    {\n', '        uint value = fundBalance;\n', '        fundBalance = 0;\n', '\n', '        require(value > 0);\n', '\n', '        uint networkFee = value * SingularDTVWorkshopFee / 100;\n', '        workshop.transfer(value - networkFee);\n', '        SingularDTVWorkshop.transfer(networkFee);\n', '\n', '        uint remainingTokens = CAP - tokensSent;\n', '        if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n', '            revert();\n', '        }\n', '\n', '        checkInvariants();\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows owner to get back unsent tokens in case of launch failure (EndedAndGoalNotReached).\n', '    function withdrawUnsentTokensForOwner()\n', '        public\n', '        timedTransitions\n', '        atStage(Stages.EndedAndGoalNotReached)\n', '        returns (uint)\n', '    {\n', '        uint remainingTokens = CAP - tokensSent;\n', '        if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n', '            revert();\n', '        }\n', '\n', '        checkInvariants();\n', '        return remainingTokens;\n', '    }\n', '\n', '    /// @dev Sets token value in Wei.\n', '    /// @param valueInWei New value.\n', '    function changeValuePerToken(uint valueInWei)\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.Deployed)\n', '        returns (bool)\n', '    {\n', '        valuePerToken = valueInWei;\n', '        return true;\n', '    }\n', '\n', '    // updateStage allows calls to receive correct stage. It can be used for transactions but is not part of the regular token creation routine.\n', '    // It is not marked as constant because timedTransitions modifier is altering state and constant is not yet enforced by solc.\n', '    /// @dev returns correct stage, even if a function with timedTransitions modifier has not yet been called successfully.\n', '    function updateStage()\n', '        public\n', '        timedTransitions\n', '        returns (Stages)\n', '    {\n', '        return stage;\n', '    }\n', '\n', '    function start()\n', '        public\n', '        onlyOwner\n', '        atStage(Stages.Deployed)\n', '        returns (uint)\n', '    {\n', '        if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n', '            revert();\n', '        }\n', '\n', '        startDate = now;\n', '        stage = Stages.GoingAndGoalNotReached;\n', '\n', '        checkInvariants();\n', '        return startDate;\n', '    }\n', '\n', '    /// @dev Contract constructor function sets owner and start date.\n', '    function SingularDTVLaunch(\n', '        address singularDTVTokenAddress,\n', '        address _workshop,\n', '        address _owner,\n', '        uint _total,\n', '        uint _unit_price,\n', '        uint _duration,\n', '        uint _threshold,\n', '        uint _singulardtvwoskhop_fee\n', '        ) {\n', '        singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n', '        workshop = _workshop;\n', '        owner = _owner;\n', '        CAP = _total; // Total number of tokens (wei scale)\n', '        valuePerToken = _unit_price; // wei per token\n', '        DURATION = _duration; // in seconds\n', '        TOKEN_TARGET = _threshold; // Goal threshold\n', '        SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n', '    }\n', '\n', '    /// @dev Fallback function acts as fund() when stage GoingAndGoalNotReached\n', '    /// or GoingAndGoalReached. And act as withdrawFunding() when EndedAndGoalNotReached.\n', '    /// otherwise throw.\n', '    function ()\n', '        public\n', '        payable\n', '    {\n', '        if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n', '            fund();\n', '        else if (stage == Stages.EndedAndGoalNotReached)\n', '            withdrawContribution();\n', '        else\n', '            revert();\n', '    }\n', '}']