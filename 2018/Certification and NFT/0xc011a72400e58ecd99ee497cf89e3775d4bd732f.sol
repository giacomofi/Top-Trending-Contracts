['/* \n', ' * Havven Token Contract Proxy\n', ' * ========================\n', ' * \n', ' * This contract points to an underlying target which implements its\n', ' * actual functionality, while allowing that functionality to be upgraded.\n', ' */\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title A contract with an owner.\n', ' * @notice Contract ownership can be transferred by first nominating the new owner,\n', ' * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public nominatedOwner;\n', '\n', '    /**\n', '     * @dev Owned Constructor\n', '     */\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        emit OwnerChanged(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Nominate a new owner of this contract.\n', '     * @dev Only the current owner may nominate a new owner.\n', '     */\n', '    function nominateNewOwner(address _owner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        nominatedOwner = _owner;\n', '        emit OwnerNominated(_owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Accept the nomination to be owner.\n', '     */\n', '    function acceptOwnership()\n', '        external\n', '    {\n', '        require(msg.sender == nominatedOwner);\n', '        emit OwnerChanged(owner, nominatedOwner);\n', '        owner = nominatedOwner;\n', '        nominatedOwner = address(0);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnerNominated(address newOwner);\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '}\n', '\n', '// This contract should be treated like an abstract contract\n', 'contract Proxyable is Owned {\n', '    /* The proxy this contract exists behind. */\n', '    Proxy public proxy;\n', '\n', '    /* The caller of the proxy, passed through to this contract.\n', '     * Note that every function using this member must apply the onlyProxy or\n', '     * optionalProxy modifiers, otherwise their invocations can use stale values. */ \n', '    address messageSender; \n', '\n', '    constructor(address _proxy, address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        proxy = Proxy(_proxy);\n', '        emit ProxyUpdated(_proxy);\n', '    }\n', '\n', '    function setProxy(address _proxy)\n', '        external\n', '        onlyOwner\n', '    {\n', '        proxy = Proxy(_proxy);\n', '        emit ProxyUpdated(_proxy);\n', '    }\n', '\n', '    function setMessageSender(address sender)\n', '        external\n', '        onlyProxy\n', '    {\n', '        messageSender = sender;\n', '    }\n', '\n', '    modifier onlyProxy {\n', '        require(Proxy(msg.sender) == proxy);\n', '        _;\n', '    }\n', '\n', '    modifier optionalProxy\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier optionalProxy_onlyOwner\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        require(messageSender == owner);\n', '        _;\n', '    }\n', '\n', '    event ProxyUpdated(address proxyAddress);\n', '}\n', '\n', 'contract Proxy is Owned {\n', '\n', '    Proxyable public target;\n', '    bool public useDELEGATECALL;\n', '\n', '    constructor(address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {}\n', '\n', '    function setTarget(Proxyable _target)\n', '        external\n', '        onlyOwner\n', '    {\n', '        target = _target;\n', '        emit TargetUpdated(_target);\n', '    }\n', '\n', '    function setUseDELEGATECALL(bool value) \n', '        external\n', '        onlyOwner\n', '    {\n', '        useDELEGATECALL = value;\n', '    }\n', '\n', '    function _emit(bytes callData, uint numTopics,\n', '                   bytes32 topic1, bytes32 topic2,\n', '                   bytes32 topic3, bytes32 topic4)\n', '        external\n', '        onlyTarget\n', '    {\n', '        uint size = callData.length;\n', '        bytes memory _callData = callData;\n', '\n', '        assembly {\n', '            /* The first 32 bytes of callData contain its length (as specified by the abi). \n', '             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n', '             * in length. It is also leftpadded to be a multiple of 32 bytes.\n', '             * This means moving call_data across 32 bytes guarantees we correctly access\n', '             * the data itself. */\n', '            switch numTopics\n', '            case 0 {\n', '                log0(add(_callData, 32), size)\n', '            } \n', '            case 1 {\n', '                log1(add(_callData, 32), size, topic1)\n', '            }\n', '            case 2 {\n', '                log2(add(_callData, 32), size, topic1, topic2)\n', '            }\n', '            case 3 {\n', '                log3(add(_callData, 32), size, topic1, topic2, topic3)\n', '            }\n', '            case 4 {\n', '                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n', '            }\n', '        }\n', '    }\n', '\n', '    function()\n', '        external\n', '        payable\n', '    {\n', '        if (useDELEGATECALL) {\n', '            assembly {\n', '                /* Copy call data into free memory region. */\n', '                let free_ptr := mload(0x40)\n', '                calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                /* Forward all gas and call data to the target contract. */\n', '                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n', '                returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                /* Revert if the call failed, otherwise return the result. */\n', '                if iszero(result) { revert(free_ptr, returndatasize) }\n', '                return(free_ptr, returndatasize)\n', '            }\n', '        } else {\n', '            /* Here we are as above, but must send the messageSender explicitly \n', '             * since we are using CALL rather than DELEGATECALL. */\n', '            target.setMessageSender(msg.sender);\n', '            assembly {\n', '                let free_ptr := mload(0x40)\n', '                calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                /* We must explicitly forward ether to the underlying contract as well. */\n', '                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n', '                returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                if iszero(result) { revert(free_ptr, returndatasize) }\n', '                return(free_ptr, returndatasize)\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier onlyTarget {\n', '        require(Proxyable(msg.sender) == target);\n', '        _;\n', '    }\n', '\n', '    event TargetUpdated(Proxyable newTarget);\n', '}']
['/* \n', ' * Havven Token Contract Proxy\n', ' * ========================\n', ' * \n', ' * This contract points to an underlying target which implements its\n', ' * actual functionality, while allowing that functionality to be upgraded.\n', ' */\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title A contract with an owner.\n', ' * @notice Contract ownership can be transferred by first nominating the new owner,\n', ' * who must then accept the ownership, which prevents accidental incorrect ownership transfers.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public nominatedOwner;\n', '\n', '    /**\n', '     * @dev Owned Constructor\n', '     */\n', '    constructor(address _owner)\n', '        public\n', '    {\n', '        require(_owner != address(0));\n', '        owner = _owner;\n', '        emit OwnerChanged(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Nominate a new owner of this contract.\n', '     * @dev Only the current owner may nominate a new owner.\n', '     */\n', '    function nominateNewOwner(address _owner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        nominatedOwner = _owner;\n', '        emit OwnerNominated(_owner);\n', '    }\n', '\n', '    /**\n', '     * @notice Accept the nomination to be owner.\n', '     */\n', '    function acceptOwnership()\n', '        external\n', '    {\n', '        require(msg.sender == nominatedOwner);\n', '        emit OwnerChanged(owner, nominatedOwner);\n', '        owner = nominatedOwner;\n', '        nominatedOwner = address(0);\n', '    }\n', '\n', '    modifier onlyOwner\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnerNominated(address newOwner);\n', '    event OwnerChanged(address oldOwner, address newOwner);\n', '}\n', '\n', '// This contract should be treated like an abstract contract\n', 'contract Proxyable is Owned {\n', '    /* The proxy this contract exists behind. */\n', '    Proxy public proxy;\n', '\n', '    /* The caller of the proxy, passed through to this contract.\n', '     * Note that every function using this member must apply the onlyProxy or\n', '     * optionalProxy modifiers, otherwise their invocations can use stale values. */ \n', '    address messageSender; \n', '\n', '    constructor(address _proxy, address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {\n', '        proxy = Proxy(_proxy);\n', '        emit ProxyUpdated(_proxy);\n', '    }\n', '\n', '    function setProxy(address _proxy)\n', '        external\n', '        onlyOwner\n', '    {\n', '        proxy = Proxy(_proxy);\n', '        emit ProxyUpdated(_proxy);\n', '    }\n', '\n', '    function setMessageSender(address sender)\n', '        external\n', '        onlyProxy\n', '    {\n', '        messageSender = sender;\n', '    }\n', '\n', '    modifier onlyProxy {\n', '        require(Proxy(msg.sender) == proxy);\n', '        _;\n', '    }\n', '\n', '    modifier optionalProxy\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier optionalProxy_onlyOwner\n', '    {\n', '        if (Proxy(msg.sender) != proxy) {\n', '            messageSender = msg.sender;\n', '        }\n', '        require(messageSender == owner);\n', '        _;\n', '    }\n', '\n', '    event ProxyUpdated(address proxyAddress);\n', '}\n', '\n', 'contract Proxy is Owned {\n', '\n', '    Proxyable public target;\n', '    bool public useDELEGATECALL;\n', '\n', '    constructor(address _owner)\n', '        Owned(_owner)\n', '        public\n', '    {}\n', '\n', '    function setTarget(Proxyable _target)\n', '        external\n', '        onlyOwner\n', '    {\n', '        target = _target;\n', '        emit TargetUpdated(_target);\n', '    }\n', '\n', '    function setUseDELEGATECALL(bool value) \n', '        external\n', '        onlyOwner\n', '    {\n', '        useDELEGATECALL = value;\n', '    }\n', '\n', '    function _emit(bytes callData, uint numTopics,\n', '                   bytes32 topic1, bytes32 topic2,\n', '                   bytes32 topic3, bytes32 topic4)\n', '        external\n', '        onlyTarget\n', '    {\n', '        uint size = callData.length;\n', '        bytes memory _callData = callData;\n', '\n', '        assembly {\n', '            /* The first 32 bytes of callData contain its length (as specified by the abi). \n', '             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n', '             * in length. It is also leftpadded to be a multiple of 32 bytes.\n', '             * This means moving call_data across 32 bytes guarantees we correctly access\n', '             * the data itself. */\n', '            switch numTopics\n', '            case 0 {\n', '                log0(add(_callData, 32), size)\n', '            } \n', '            case 1 {\n', '                log1(add(_callData, 32), size, topic1)\n', '            }\n', '            case 2 {\n', '                log2(add(_callData, 32), size, topic1, topic2)\n', '            }\n', '            case 3 {\n', '                log3(add(_callData, 32), size, topic1, topic2, topic3)\n', '            }\n', '            case 4 {\n', '                log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n', '            }\n', '        }\n', '    }\n', '\n', '    function()\n', '        external\n', '        payable\n', '    {\n', '        if (useDELEGATECALL) {\n', '            assembly {\n', '                /* Copy call data into free memory region. */\n', '                let free_ptr := mload(0x40)\n', '                calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                /* Forward all gas and call data to the target contract. */\n', '                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)\n', '                returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                /* Revert if the call failed, otherwise return the result. */\n', '                if iszero(result) { revert(free_ptr, returndatasize) }\n', '                return(free_ptr, returndatasize)\n', '            }\n', '        } else {\n', '            /* Here we are as above, but must send the messageSender explicitly \n', '             * since we are using CALL rather than DELEGATECALL. */\n', '            target.setMessageSender(msg.sender);\n', '            assembly {\n', '                let free_ptr := mload(0x40)\n', '                calldatacopy(free_ptr, 0, calldatasize)\n', '\n', '                /* We must explicitly forward ether to the underlying contract as well. */\n', '                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n', '                returndatacopy(free_ptr, 0, returndatasize)\n', '\n', '                if iszero(result) { revert(free_ptr, returndatasize) }\n', '                return(free_ptr, returndatasize)\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier onlyTarget {\n', '        require(Proxyable(msg.sender) == target);\n', '        _;\n', '    }\n', '\n', '    event TargetUpdated(Proxyable newTarget);\n', '}']
