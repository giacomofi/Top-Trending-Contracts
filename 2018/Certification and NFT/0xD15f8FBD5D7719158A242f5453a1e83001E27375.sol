['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/ERC20Interface.sol\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/KyberIEOInterface.sol\n', '\n', 'interface KyberIEOInterface {\n', '    function contribute(address contributor, uint userId, uint8 v, bytes32 r, bytes32 s) external payable returns(bool);\n', '    function getContributorRemainingCap(uint userId) external view returns(uint capWei);\n', '    function getIEOId() external view returns(uint);\n', '}\n', '\n', '// File: contracts/PermissionGroups.sol\n', '\n', 'contract PermissionGroups {\n', '\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    mapping(address=>bool) internal operators;\n', '    mapping(address=>bool) internal alerters;\n', '    address[] internal operatorsGroup;\n', '    address[] internal alertersGroup;\n', '    uint constant internal MAX_GROUP_SIZE = 50;\n', '\n', '    constructor(address _admin) public {\n', '        admin = _admin;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAlerter() {\n', '        require(alerters[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function getOperators () external view returns(address[]) {\n', '        return operatorsGroup;\n', '    }\n', '\n', '    function getAlerters () external view returns(address[]) {\n', '        return alertersGroup;\n', '    }\n', '\n', '    event TransferAdminPending(address pendingAdmin);\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the pendingAdmin address.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdmin(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        emit TransferAdminPending(pendingAdmin);\n', '        pendingAdmin = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0));\n', '        emit TransferAdminPending(newAdmin);\n', '        emit AdminClaimed(newAdmin, admin);\n', '        admin = newAdmin;\n', '    }\n', '\n', '    event AdminClaimed( address newAdmin, address previousAdmin);\n', '\n', '    /**\n', '     * @dev Allows the pendingAdmin address to finalize the change admin process.\n', '     */\n', '    function claimAdmin() public {\n', '        require(pendingAdmin == msg.sender);\n', '        emit AdminClaimed(pendingAdmin, admin);\n', '        admin = pendingAdmin;\n', '        pendingAdmin = address(0);\n', '    }\n', '\n', '    event AlerterAdded (address newAlerter, bool isAdd);\n', '\n', '    function addAlerter(address newAlerter) public onlyAdmin {\n', '        require(!alerters[newAlerter]); // prevent duplicates.\n', '        require(alertersGroup.length < MAX_GROUP_SIZE);\n', '\n', '        emit AlerterAdded(newAlerter, true);\n', '        alerters[newAlerter] = true;\n', '        alertersGroup.push(newAlerter);\n', '    }\n', '\n', '    function removeAlerter (address alerter) public onlyAdmin {\n', '        require(alerters[alerter]);\n', '        alerters[alerter] = false;\n', '\n', '        for (uint i = 0; i < alertersGroup.length; ++i) {\n', '            if (alertersGroup[i] == alerter) {\n', '                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n', '                alertersGroup.length--;\n', '                emit AlerterAdded(alerter, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    event OperatorAdded(address newOperator, bool isAdd);\n', '\n', '    function addOperator(address newOperator) public onlyAdmin {\n', '        require(!operators[newOperator]); // prevent duplicates.\n', '        require(operatorsGroup.length < MAX_GROUP_SIZE);\n', '\n', '        emit OperatorAdded(newOperator, true);\n', '        operators[newOperator] = true;\n', '        operatorsGroup.push(newOperator);\n', '    }\n', '\n', '    function removeOperator (address operator) public onlyAdmin {\n', '        require(operators[operator]);\n', '        operators[operator] = false;\n', '\n', '        for (uint i = 0; i < operatorsGroup.length; ++i) {\n', '            if (operatorsGroup[i] == operator) {\n', '                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n', '                operatorsGroup.length -= 1;\n', '                emit OperatorAdded(operator, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Withdrawable.sol\n', '\n', '/**\n', ' * @title Contracts that should be able to recover tokens or ethers can inherit this contract.\n', ' * @author Ilan Doron\n', ' * @dev Allows to recover any tokens or Ethers received in a contract.\n', ' * Should prevent any accidental loss of tokens.\n', ' */\n', 'contract Withdrawable is PermissionGroups {\n', '\n', '    constructor(address _admin) PermissionGroups (_admin) public {}\n', '\n', '    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw all ERC20 compatible tokens\n', '     * @param token ERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\n', '        require(token.transfer(sendTo, amount));\n', '        emit TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    event EtherWithdraw(uint amount, address sendTo);\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\n', '        sendTo.transfer(amount);\n', '        emit EtherWithdraw(amount, sendTo);\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/KyberIEOWrapper.sol\n', '\n', 'interface KyberNetwork {\n', '    function trade(\n', '        ERC20 src,\n', '        uint srcAmount,\n', '        ERC20 dest,\n', '        address destAddress,\n', '        uint maxDestAmount,\n', '        uint minConversionRate,\n', '        address walletId) external payable returns(uint);\n', '}\n', '\n', '\n', 'contract KyberIEOWrapper is Withdrawable {\n', '\n', '    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    using SafeMath for uint;\n', '\n', '    constructor(address _admin) public Withdrawable(_admin) {}\n', '\n', '    function() public payable {}\n', '\n', '    struct ContributeData {\n', '        uint userId;\n', '        ERC20 token;\n', '        uint amountTwei;\n', '        uint minConversionRate;\n', '        uint maxDestAmountWei;\n', '        KyberNetwork network;\n', '        KyberIEOInterface kyberIEO;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    event ContributionByToken(address contributor, uint userId, ERC20 token, uint amountSentTwei, uint tradedWei,\n', '    uint changeTwei);\n', '\n', '    function contributeWithToken(\n', '        uint userId,\n', '        ERC20 token,\n', '        uint amountTwei,\n', '        uint minConversionRate,\n', '        uint maxDestAmountWei,\n', '        KyberNetwork network,\n', '        KyberIEOInterface kyberIEO,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s) external returns(bool)\n', '    {\n', '        ContributeData memory data = ContributeData(\n', '            userId,\n', '            token,\n', '            amountTwei,\n', '            minConversionRate,\n', '            maxDestAmountWei,\n', '            network,\n', '            kyberIEO,\n', '            v,\n', '            r,\n', '            s);\n', '        return contribute(data);\n', '    }\n', '\n', '    function contribute(ContributeData data) internal returns(bool) {\n', '        uint weiCap = data.kyberIEO.getContributorRemainingCap(data.userId);\n', '        if (data.maxDestAmountWei < weiCap) weiCap = data.maxDestAmountWei;\n', '        require(weiCap > 0);\n', '\n', '        uint initialTokenBalance = data.token.balanceOf(this);\n', '\n', '        require(data.token.transferFrom(msg.sender, this, data.amountTwei));\n', '        data.token.approve(address(data.network), data.amountTwei);\n', '\n', '        uint weiBefore = address(this).balance;\n', '        uint amountWei = data.network.trade(data.token, data.amountTwei, ETH_TOKEN_ADDRESS, this, weiCap,\n', '            data.minConversionRate, this);\n', '        uint weiAfter = address(this).balance;\n', '\n', '        require(amountWei == weiAfter.sub(weiBefore));\n', '\n', '        //emit event here where we still have valid "change" value\n', '        emit ContributionByToken(\n', '            msg.sender,\n', '            data.userId,\n', '            data.token,\n', '            data.amountTwei,\n', '            amountWei,\n', '            (data.token.balanceOf(this).sub(initialTokenBalance))); // solium-disable-line indentation\n', '\n', '        if (data.token.balanceOf(this) > initialTokenBalance) {\n', '            //if not all tokens were taken by network approve value is not zereod.\n', '            // must zero it so next time will not revert.\n', '            data.token.approve(address(data.network), 0);\n', '            data.token.transfer(msg.sender, (data.token.balanceOf(this).sub(initialTokenBalance)));\n', '        }\n', '\n', '        require(data.kyberIEO.contribute.value(amountWei)(msg.sender, data.userId, data.v, data.r, data.s));\n', '        return true;\n', '    }\n', '}']