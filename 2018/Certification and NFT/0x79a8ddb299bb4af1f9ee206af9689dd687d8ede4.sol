['pragma solidity ^0.4.13;\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract DBC {\n', '\n', '    // MODIFIERS\n', '\n', '    modifier pre_cond(bool condition) {\n', '        require(condition);\n', '        _;\n', '    }\n', '\n', '    modifier post_cond(bool condition) {\n', '        _;\n', '        assert(condition);\n', '    }\n', '\n', '    modifier invariant(bool condition) {\n', '        require(condition);\n', '        _;\n', '        assert(condition);\n', '    }\n', '}\n', '\n', 'contract Owned is DBC {\n', '\n', '    // FIELDS\n', '\n', '    address public owner;\n', '\n', '    // NON-CONSTANT METHODS\n', '\n', '    function Owned() { owner = msg.sender; }\n', '\n', '    function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n', '\n', '    // PRE, POST, INVARIANT CONDITIONS\n', '\n', '    function isOwner() internal returns (bool) { return msg.sender == owner; }\n', '\n', '}\n', '\n', 'contract AssetRegistrar is DBC, Owned {\n', '\n', '    // TYPES\n', '\n', '    struct Asset {\n', '        address breakIn; // Break in contract on destination chain\n', '        address breakOut; // Break out contract on this chain; A way to leave\n', '        bytes32 chainId; // On which chain this asset resides\n', '        uint decimal; // Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard\n', '        bool exists; // Is this asset registered\n', '        string ipfsHash; // Same as url but for ipfs\n', '        string name; // Human-readable name of the Asset as in ERC223 token standard\n', '        uint price; // Price of asset quoted against `QUOTE_ASSET` * 10 ** decimals\n', '        string symbol; // Human-readable symbol of the Asset as in ERC223 token standard\n', '        uint timestamp; // Timestamp of last price update of this asset\n', '        string url; // URL for additional information of Asset\n', '    }\n', '\n', '    // FIELDS\n', '\n', '    // Methods fields\n', '    mapping (address => Asset) public information;\n', '\n', '    // METHODS\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @notice Registers an Asset residing in a chain\n', '    /// @dev Pre: Only registrar owner should be able to register\n', '    /// @dev Post: Address ofAsset is registered\n', '    /// @param ofAsset Address of asset to be registered\n', '    /// @param name Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param symbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param decimal Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param url Url for extended information of the asset\n', '    /// @param ipfsHash Same as url but for ipfs\n', '    /// @param chainId Chain where the asset resides\n', '    /// @param breakIn Address of break in contract on destination chain\n', '    /// @param breakOut Address of break out contract on this chain\n', '    function register(\n', '        address ofAsset,\n', '        string name,\n', '        string symbol,\n', '        uint decimal,\n', '        string url,\n', '        string ipfsHash,\n', '        bytes32 chainId,\n', '        address breakIn,\n', '        address breakOut\n', '    )\n', '        pre_cond(isOwner())\n', '        pre_cond(!information[ofAsset].exists)\n', '    {\n', '        Asset asset = information[ofAsset];\n', '        asset.name = name;\n', '        asset.symbol = symbol;\n', '        asset.decimal = decimal;\n', '        asset.url = url;\n', '        asset.ipfsHash = ipfsHash;\n', '        asset.breakIn = breakIn;\n', '        asset.breakOut = breakOut;\n', '        asset.exists = true;\n', '        assert(information[ofAsset].exists);\n', '    }\n', '\n', '    /// @notice Updates description information of a registered Asset\n', '    /// @dev Pre: Owner can change an existing entry\n', '    /// @dev Post: Changed Name, Symbol, URL and/or IPFSHash\n', '    /// @param ofAsset Address of the asset to be updated\n', '    /// @param name Human-readable name of the Asset as in ERC223 token standard\n', '    /// @param symbol Human-readable symbol of the Asset as in ERC223 token standard\n', '    /// @param url Url for extended information of the asset\n', '    /// @param ipfsHash Same as url but for ipfs\n', '    function updateDescriptiveInformation(\n', '        address ofAsset,\n', '        string name,\n', '        string symbol,\n', '        string url,\n', '        string ipfsHash\n', '    )\n', '        pre_cond(isOwner())\n', '        pre_cond(information[ofAsset].exists)\n', '    {\n', '        Asset asset = information[ofAsset];\n', '        asset.name = name;\n', '        asset.symbol = symbol;\n', '        asset.url = url;\n', '        asset.ipfsHash = ipfsHash;\n', '    }\n', '\n', '    /// @notice Deletes an existing entry\n', '    /// @dev Owner can delete an existing entry\n', '    /// @param ofAsset address for which specific information is requested\n', '    function remove(\n', '        address ofAsset\n', '    )\n', '        pre_cond(isOwner())\n', '        pre_cond(information[ofAsset].exists)\n', '    {\n', '        delete information[ofAsset]; // Sets exists boolean to false\n', '        assert(!information[ofAsset].exists);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get asset specific information\n', '    function getName(address ofAsset) view returns (string) { return information[ofAsset].name; }\n', '    function getSymbol(address ofAsset) view returns (string) { return information[ofAsset].symbol; }\n', '    function getDecimals(address ofAsset) view returns (uint) { return information[ofAsset].decimal; }\n', '\n', '}\n', '\n', 'interface PriceFeedInterface {\n', '\n', '    // EVENTS\n', '\n', '    event PriceUpdated(uint timestamp);\n', '\n', '    // PUBLIC METHODS\n', '\n', '    function update(address[] ofAssets, uint[] newPrices);\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get asset specific information\n', '    function getName(address ofAsset) view returns (string);\n', '    function getSymbol(address ofAsset) view returns (string);\n', '    function getDecimals(address ofAsset) view returns (uint);\n', '    // Get price feed operation specific information\n', '    function getQuoteAsset() view returns (address);\n', '    function getInterval() view returns (uint);\n', '    function getValidity() view returns (uint);\n', '    function getLastUpdateId() view returns (uint);\n', '    // Get asset specific information as updated in price feed\n', '    function hasRecentPrice(address ofAsset) view returns (bool isRecent);\n', '    function hasRecentPrices(address[] ofAssets) view returns (bool areRecent);\n', '    function getPrice(address ofAsset) view returns (bool isRecent, uint price, uint decimal);\n', '    function getPrices(address[] ofAssets) view returns (bool areRecent, uint[] prices, uint[] decimals);\n', '    function getInvertedPrice(address ofAsset) view returns (bool isRecent, uint invertedPrice, uint decimal);\n', '    function getReferencePrice(address ofBase, address ofQuote) view returns (bool isRecent, uint referencePrice, uint decimal);\n', '    function getOrderPrice(\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    ) view returns (uint orderPrice);\n', '    function existsPriceOnAssetPair(address sellAsset, address buyAsset) view returns (bool isExistent);\n', '}\n', '\n', 'contract PriceFeed is PriceFeedInterface, AssetRegistrar, DSMath {\n', '\n', '    // FIELDS\n', '\n', '    // Constructor fields\n', '    address public QUOTE_ASSET; // Asset of a portfolio against which all other assets are priced\n', '    /// Note: Interval is purely self imposed and for information purposes only\n', '    uint public INTERVAL; // Frequency of updates in seconds\n', '    uint public VALIDITY; // Time in seconds for which data is considered recent\n', '    uint updateId;        // Update counter for this pricefeed; used as a check during investment\n', '\n', '    // METHODS\n', '\n', '    // CONSTRUCTOR\n', '\n', '    /// @dev Define and register a quote asset against which all prices are measured/based against\n', '    /// @param ofQuoteAsset Address of quote asset\n', '    /// @param quoteAssetName Name of quote asset\n', '    /// @param quoteAssetSymbol Symbol for quote asset\n', '    /// @param quoteAssetDecimals Decimal places for quote asset\n', '    /// @param quoteAssetUrl URL related to quote asset\n', '    /// @param quoteAssetIpfsHash IPFS hash associated with quote asset\n', '    /// @param quoteAssetChainId Chain ID associated with quote asset (e.g. "1" for main Ethereum network)\n', '    /// @param quoteAssetBreakIn Break-in address for the quote asset\n', '    /// @param quoteAssetBreakOut Break-out address for the quote asset\n', '    /// @param interval Number of seconds between pricefeed updates (this interval is not enforced on-chain, but should be followed by the datafeed maintainer)\n', '    /// @param validity Number of seconds that datafeed update information is valid for\n', '    function PriceFeed(\n', '        address ofQuoteAsset, // Inital entry in asset registrar contract is Melon (QUOTE_ASSET)\n', '        string quoteAssetName,\n', '        string quoteAssetSymbol,\n', '        uint quoteAssetDecimals,\n', '        string quoteAssetUrl,\n', '        string quoteAssetIpfsHash,\n', '        bytes32 quoteAssetChainId,\n', '        address quoteAssetBreakIn,\n', '        address quoteAssetBreakOut,\n', '        uint interval,\n', '        uint validity\n', '    ) {\n', '        QUOTE_ASSET = ofQuoteAsset;\n', '        register(\n', '            QUOTE_ASSET,\n', '            quoteAssetName,\n', '            quoteAssetSymbol,\n', '            quoteAssetDecimals,\n', '            quoteAssetUrl,\n', '            quoteAssetIpfsHash,\n', '            quoteAssetChainId,\n', '            quoteAssetBreakIn,\n', '            quoteAssetBreakOut\n', '        );\n', '        INTERVAL = interval;\n', '        VALIDITY = validity;\n', '    }\n', '\n', '    // PUBLIC METHODS\n', '\n', '    /// @dev Only Owner; Same sized input arrays\n', '    /// @dev Updates price of asset relative to QUOTE_ASSET\n', '    /** Ex:\n', '     *  Let QUOTE_ASSET == MLN (base units), let asset == EUR-T,\n', '     *  let Value of 1 EUR-T := 1 EUR == 0.080456789 MLN, hence price 0.080456789 MLN / EUR-T\n', '     *  and let EUR-T decimals == 8.\n', '     *  Input would be: information[EUR-T].price = 8045678 [MLN/ (EUR-T * 10**8)]\n', '     */\n', '    /// @param ofAssets list of asset addresses\n', '    /// @param newPrices list of prices for each of the assets\n', '    function update(address[] ofAssets, uint[] newPrices)\n', '        pre_cond(isOwner())\n', '        pre_cond(ofAssets.length == newPrices.length)\n', '    {\n', '        updateId += 1;\n', '        for (uint i = 0; i < ofAssets.length; ++i) {\n', '            require(information[ofAssets[i]].timestamp != now); // prevent two updates in one block\n', '            require(information[ofAssets[i]].exists);\n', '            information[ofAssets[i]].timestamp = now;\n', '            information[ofAssets[i]].price = newPrices[i];\n', '        }\n', '        PriceUpdated(now);\n', '    }\n', '\n', '    // PUBLIC VIEW METHODS\n', '\n', '    // Get pricefeed specific information\n', '    function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n', '    function getInterval() view returns (uint) { return INTERVAL; }\n', '    function getValidity() view returns (uint) { return VALIDITY; }\n', '    function getLastUpdateId() view returns (uint) { return updateId; }\n', '\n', '    /// @notice Whether price of asset has been updated less than VALIDITY seconds ago\n', '    /// @param ofAsset Existend asset in AssetRegistrar\n', '    /// @return isRecent Price information ofAsset is recent\n', '    function hasRecentPrice(address ofAsset)\n', '        view\n', '        pre_cond(information[ofAsset].exists)\n', '        returns (bool isRecent)\n', '    {\n', '        return sub(now, information[ofAsset].timestamp) <= VALIDITY;\n', '    }\n', '\n', '    /// @notice Whether prices of assets have been updated less than VALIDITY seconds ago\n', '    /// @param ofAssets All asstes existend in AssetRegistrar\n', '    /// @return isRecent Price information ofAssets array is recent\n', '    function hasRecentPrices(address[] ofAssets)\n', '        view\n', '        returns (bool areRecent)\n', '    {\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            if (!hasRecentPrice(ofAssets[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    @notice Gets price of an asset multiplied by ten to the power of assetDecimals\n', '    @dev Asset has been registered\n', '    @param ofAsset Asset for which price should be returned\n', '    @return {\n', '      "isRecent": "Whether the returned price is valid (as defined by VALIDITY)",\n', '      "price": "Price formatting: mul(exchangePrice, 10 ** decimal), to avoid floating numbers",\n', '      "decimal": "Decimal, order of magnitude of precision, of the Asset as in ERC223 token standard",\n', '    }\n', '    */\n', '    function getPrice(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint price, uint decimal)\n', '    {\n', '        return (\n', '            hasRecentPrice(ofAsset),\n', '            information[ofAsset].price,\n', '            information[ofAsset].decimal\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Price of a registered asset in format (bool areRecent, uint[] prices, uint[] decimals)\n', '    @dev Convention for price formatting: mul(price, 10 ** decimal), to avoid floating numbers\n', '    @param ofAssets Assets for which prices should be returned\n', '    @return {\n', '        "areRecent":    "Whether all of the prices are fresh, given VALIDITY interval",\n', '        "prices":       "Array of prices",\n', '        "decimals":     "Array of decimal places for returned assets"\n', '    }\n', '    */\n', '    function getPrices(address[] ofAssets)\n', '        view\n', '        returns (bool areRecent, uint[] prices, uint[] decimals)\n', '    {\n', '        areRecent = true;\n', '        for (uint i; i < ofAssets.length; i++) {\n', '            var (isRecent, price, decimal) = getPrice(ofAssets[i]);\n', '            if (!isRecent) {\n', '                areRecent = false;\n', '            }\n', '            prices[i] = price;\n', '            decimals[i] = decimal;\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Gets inverted price of an asset\n', '    @dev Asset has been initialised and its price is non-zero\n', '    @dev Existing price ofAssets quoted in QUOTE_ASSET (convention)\n', '    @param ofAsset Asset for which inverted price should be return\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "invertedPrice": "Price based (instead of quoted) against QUOTE_ASSET",\n', '        "decimal": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getInvertedPrice(address ofAsset)\n', '        view\n', '        returns (bool isRecent, uint invertedPrice, uint decimal)\n', '    {\n', '        // inputPrice quoted in QUOTE_ASSET and multiplied by 10 ** assetDecimal\n', '        var (isInvertedRecent, inputPrice, assetDecimal) = getPrice(ofAsset);\n', '\n', '        // outputPrice based in QUOTE_ASSET and multiplied by 10 ** quoteDecimal\n', '        uint quoteDecimal = getDecimals(QUOTE_ASSET);\n', '\n', '        return (\n', '            isInvertedRecent,\n', '            mul(10 ** uint(quoteDecimal), 10 ** uint(assetDecimal)) / inputPrice,\n', '            quoteDecimal\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice Gets reference price of an asset pair\n', '    @dev One of the address is equal to quote asset\n', '    @dev either ofBase == QUOTE_ASSET or ofQuote == QUOTE_ASSET\n', '    @param ofBase Address of base asset\n', '    @param ofQuote Address of quote asset\n', '    @return {\n', '        "isRecent": "Whether the price is fresh, given VALIDITY interval",\n', '        "referencePrice": "Reference price",\n', '        "decimal": "Decimal places for this asset"\n', '    }\n', '    */\n', '    function getReferencePrice(address ofBase, address ofQuote)\n', '        view\n', '        returns (bool isRecent, uint referencePrice, uint decimal)\n', '    {\n', '        if (getQuoteAsset() == ofQuote) {\n', '            (isRecent, referencePrice, decimal) = getPrice(ofBase);\n', '        } else if (getQuoteAsset() == ofBase) {\n', '            (isRecent, referencePrice, decimal) = getInvertedPrice(ofQuote);\n', '        } else {\n', '            revert(); // no suitable reference price available\n', '        }\n', '    }\n', '\n', '    /// @notice Gets price of Order\n', '    /// @param sellAsset Address of the asset to be sold\n', '    /// @param buyAsset Address of the asset to be bought\n', '    /// @param sellQuantity Quantity in base units being sold of sellAsset\n', '    /// @param buyQuantity Quantity in base units being bought of buyAsset\n', '    /// @return orderPrice Price as determined by an order\n', '    function getOrderPrice(\n', '        address sellAsset,\n', '        address buyAsset,\n', '        uint sellQuantity,\n', '        uint buyQuantity\n', '    )\n', '        view\n', '        returns (uint orderPrice)\n', '    {\n', '        return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\n', '    }\n', '\n', '    /// @notice Checks whether data exists for a given asset pair\n', '    /// @dev Prices are only upated against QUOTE_ASSET\n', '    /// @param sellAsset Asset for which check to be done if data exists\n', '    /// @param buyAsset Asset for which check to be done if data exists\n', '    /// @return Whether assets exist for given asset pair\n', '    function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n', '        view\n', '        returns (bool isExistent)\n', '    {\n', '        return\n', '            hasRecentPrice(sellAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            hasRecentPrice(buyAsset) && // Is tradable asset (TODO cleaner) and datafeed delivering data\n', '            (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) && // One asset must be QUOTE_ASSET\n', '            (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET); // Pair must consists of diffrent assets\n', '    }\n', '}']