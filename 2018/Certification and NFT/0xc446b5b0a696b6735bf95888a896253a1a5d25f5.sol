['pragma solidity ^0.4.18;\n', '/*\n', 'TwoXJackpot - A modification to TwoX that turns the 5% developer fee into a jackpot!\n', '- Double your ether.\n', '- 5% of purchase goes towards a jackpot.\n', '- Any purchase of 1% of the JackPot total qualifies you.\n', '- The last qualified address has a claim to the jackpot if no new qualified (1%) purchases in 6 hours.\n', '- Claim must be made, any new purchase resets the timer and invalidate the previous claim.\n', '- Admin can empty the jackpot if no new action and no claim in 30 days.\n', '*/\n', '\n', 'contract TwoXJackpot {\n', '  using SafeMath for uint256;\n', '\n', '  // Address of the contract creator\n', '  address public contractOwner;\n', '\n', '  // FIFO queue\n', '  BuyIn[] public buyIns;\n', '\n', '  // The current BuyIn queue index\n', '  uint256 public index;\n', '\n', '  // Total invested for entire contract\n', '  uint256 public contractTotalInvested;\n', '\n', '  // Dev Fee (1%)\n', '  uint256 public devFeeBalance;\n', '\n', '  // Total of Jackpot\n', '  uint256 public jackpotBalance;\n', '\n', '  // Track amount of seed money put into jackpot.\n', '  uint256 public seedAmount;\n', '\n', '  // The last qualified address to get into the jackpot.\n', '  address public jackpotLastQualified;\n', '\n', '  // Timestamp of the last action.\n', '  uint256 public lastAction;\n', '\n', '  // Timestamp of Game Start\n', '  uint256 public gameStartTime;\n', '\n', '  // Total invested for a given address\n', '  mapping (address => uint256) public totalInvested;\n', '\n', '  // Total value for a given address\n', '  mapping (address => uint256) public totalValue;\n', '\n', '  // Total paid out for a given address\n', '  mapping (address => uint256) public totalPaidOut;\n', '\n', '  struct BuyIn {\n', '    uint256 value;\n', '    address owner;\n', '  }\n', '\n', '  modifier onlyContractOwner() {\n', '    require(msg.sender == contractOwner);\n', '    _;\n', '  }\n', '\n', '  modifier isStarted() {\n', '      require(now >= gameStartTime);\n', '      _;\n', '  }\n', '\n', '  function TwoXJackpot() public {\n', '    contractOwner = msg.sender;\n', '    gameStartTime = now + 24 hours;\n', '  }\n', '\n', '  //                 //\n', '  // ADMIN FUNCTIONS //\n', '  //                 //\n', '\n', '  // return jackpot to contract creator if no purchases or claims in 30 days.\n', '  function killme() public payable onlyContractOwner {\n', '    require(now > lastAction + 30 days);\n', '    seedAmount = 0;\n', '    jackpotBalance = 0;\n', '    contractOwner.transfer(jackpotBalance);\n', '  }\n', '\n', '  // Contract owner can seed the Jackpot, and get it back whenever Jackpot is paid. See claim() function\n', '  function seed() public payable onlyContractOwner {\n', '    seedAmount += msg.value;     // Amount owner gets back on payout.\n', '    jackpotBalance += msg.value; // Increase the value of the jackpot by this much.\n', '  }\n', '\n', '  // Change the start time.\n', '  function changeStartTime(uint256 _time) public payable onlyContractOwner {\n', '    require(now < _time); // only allow changing it to something in the future.\n', '    require(now < gameStartTime); // Only change a game that has not started, prevent abuse.\n', '    gameStartTime = _time;\n', '  }\n', '\n', '  //                //\n', '  // User Functions //\n', '  //                //\n', '\n', '  function purchase() public payable isStarted {\n', '\n', '    uint256 purchaseMin = SafeMath.mul(msg.value, 20); // 5% Jackpot Min Purchase\n', '    uint256 purchaseMax = SafeMath.mul(msg.value, 2); // 50% Jackpot Min Purchase\n', '\n', '    require(purchaseMin >= jackpotBalance);\n', '    require(purchaseMax <= jackpotBalance);\n', '\n', '    // Take a 5% fee\n', '    uint256 valueAfterTax = SafeMath.div(SafeMath.mul(msg.value, 95), 100);\n', '\n', '    // Calculate the absolute number to put into pot. (5% total purchase)\n', '    uint256 potFee = SafeMath.sub(msg.value, valueAfterTax);\n', '\n', '    // Add it to the jackpot\n', '    jackpotBalance += potFee;\n', '    jackpotLastQualified = msg.sender;\n', '    lastAction = now;\n', '\n', '    // HNNNNNNGGGGGG\n', '    uint256 valueMultiplied = SafeMath.mul(msg.value, 2);\n', '\n', '    contractTotalInvested += msg.value;\n', '    totalInvested[msg.sender] += msg.value;\n', '\n', '    while (index < buyIns.length && valueAfterTax > 0) {\n', '      BuyIn storage buyIn = buyIns[index];\n', '\n', '      if (valueAfterTax < buyIn.value) {\n', '        buyIn.owner.transfer(valueAfterTax);\n', '        totalPaidOut[buyIn.owner] += valueAfterTax;\n', '        totalValue[buyIn.owner] -= valueAfterTax;\n', '        buyIn.value -= valueAfterTax;\n', '        valueAfterTax = 0;\n', '      } else {\n', '        buyIn.owner.transfer(buyIn.value);\n', '        totalPaidOut[buyIn.owner] += buyIn.value;\n', '        totalValue[buyIn.owner] -= buyIn.value;\n', '        valueAfterTax -= buyIn.value;\n', '        buyIn.value = 0;\n', '        index++;\n', '      }\n', '    }\n', '\n', '    // if buyins have been exhausted, return the remaining\n', '    // funds back to the investor\n', '    if (valueAfterTax > 0) {\n', '      msg.sender.transfer(valueAfterTax);\n', '      valueMultiplied -= valueAfterTax;\n', '      totalPaidOut[msg.sender] += valueAfterTax;\n', '    }\n', '\n', '    totalValue[msg.sender] += valueMultiplied;\n', '\n', '    buyIns.push(BuyIn({\n', '      value: valueMultiplied,\n', '      owner: msg.sender\n', '    }));\n', '  }\n', '\n', '\n', '  // Send the jackpot if no activity in 24 hours and claimant was the last person to generate activity.\n', '  function claim() public payable isStarted {\n', '    require(now > lastAction + 6 hours);\n', '\trequire(jackpotLastQualified == msg.sender);\n', '\n', '    uint256 seedPay = seedAmount;\n', '    uint256 jpotPay = jackpotBalance - seedAmount;\n', '\n', '    seedAmount = 0;\n', '    contractOwner.transfer(seedPay); // Return the initial seed to owner.\n', '\n', '    jackpotBalance = 0;\n', '\tmsg.sender.transfer(jpotPay); // payout entire jackpot minus seed.\n', '  }\n', '\n', '  // Fallback, sending any ether will call purchase() while sending 0 will call claim()\n', '  function () public payable {\n', '    if(msg.value > 0) {\n', '      purchase();\n', '    } else {\n', '      claim();\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '/*\n', 'TwoXJackpot - A modification to TwoX that turns the 5% developer fee into a jackpot!\n', '- Double your ether.\n', '- 5% of purchase goes towards a jackpot.\n', '- Any purchase of 1% of the JackPot total qualifies you.\n', '- The last qualified address has a claim to the jackpot if no new qualified (1%) purchases in 6 hours.\n', '- Claim must be made, any new purchase resets the timer and invalidate the previous claim.\n', '- Admin can empty the jackpot if no new action and no claim in 30 days.\n', '*/\n', '\n', 'contract TwoXJackpot {\n', '  using SafeMath for uint256;\n', '\n', '  // Address of the contract creator\n', '  address public contractOwner;\n', '\n', '  // FIFO queue\n', '  BuyIn[] public buyIns;\n', '\n', '  // The current BuyIn queue index\n', '  uint256 public index;\n', '\n', '  // Total invested for entire contract\n', '  uint256 public contractTotalInvested;\n', '\n', '  // Dev Fee (1%)\n', '  uint256 public devFeeBalance;\n', '\n', '  // Total of Jackpot\n', '  uint256 public jackpotBalance;\n', '\n', '  // Track amount of seed money put into jackpot.\n', '  uint256 public seedAmount;\n', '\n', '  // The last qualified address to get into the jackpot.\n', '  address public jackpotLastQualified;\n', '\n', '  // Timestamp of the last action.\n', '  uint256 public lastAction;\n', '\n', '  // Timestamp of Game Start\n', '  uint256 public gameStartTime;\n', '\n', '  // Total invested for a given address\n', '  mapping (address => uint256) public totalInvested;\n', '\n', '  // Total value for a given address\n', '  mapping (address => uint256) public totalValue;\n', '\n', '  // Total paid out for a given address\n', '  mapping (address => uint256) public totalPaidOut;\n', '\n', '  struct BuyIn {\n', '    uint256 value;\n', '    address owner;\n', '  }\n', '\n', '  modifier onlyContractOwner() {\n', '    require(msg.sender == contractOwner);\n', '    _;\n', '  }\n', '\n', '  modifier isStarted() {\n', '      require(now >= gameStartTime);\n', '      _;\n', '  }\n', '\n', '  function TwoXJackpot() public {\n', '    contractOwner = msg.sender;\n', '    gameStartTime = now + 24 hours;\n', '  }\n', '\n', '  //                 //\n', '  // ADMIN FUNCTIONS //\n', '  //                 //\n', '\n', '  // return jackpot to contract creator if no purchases or claims in 30 days.\n', '  function killme() public payable onlyContractOwner {\n', '    require(now > lastAction + 30 days);\n', '    seedAmount = 0;\n', '    jackpotBalance = 0;\n', '    contractOwner.transfer(jackpotBalance);\n', '  }\n', '\n', '  // Contract owner can seed the Jackpot, and get it back whenever Jackpot is paid. See claim() function\n', '  function seed() public payable onlyContractOwner {\n', '    seedAmount += msg.value;     // Amount owner gets back on payout.\n', '    jackpotBalance += msg.value; // Increase the value of the jackpot by this much.\n', '  }\n', '\n', '  // Change the start time.\n', '  function changeStartTime(uint256 _time) public payable onlyContractOwner {\n', '    require(now < _time); // only allow changing it to something in the future.\n', '    require(now < gameStartTime); // Only change a game that has not started, prevent abuse.\n', '    gameStartTime = _time;\n', '  }\n', '\n', '  //                //\n', '  // User Functions //\n', '  //                //\n', '\n', '  function purchase() public payable isStarted {\n', '\n', '    uint256 purchaseMin = SafeMath.mul(msg.value, 20); // 5% Jackpot Min Purchase\n', '    uint256 purchaseMax = SafeMath.mul(msg.value, 2); // 50% Jackpot Min Purchase\n', '\n', '    require(purchaseMin >= jackpotBalance);\n', '    require(purchaseMax <= jackpotBalance);\n', '\n', '    // Take a 5% fee\n', '    uint256 valueAfterTax = SafeMath.div(SafeMath.mul(msg.value, 95), 100);\n', '\n', '    // Calculate the absolute number to put into pot. (5% total purchase)\n', '    uint256 potFee = SafeMath.sub(msg.value, valueAfterTax);\n', '\n', '    // Add it to the jackpot\n', '    jackpotBalance += potFee;\n', '    jackpotLastQualified = msg.sender;\n', '    lastAction = now;\n', '\n', '    // HNNNNNNGGGGGG\n', '    uint256 valueMultiplied = SafeMath.mul(msg.value, 2);\n', '\n', '    contractTotalInvested += msg.value;\n', '    totalInvested[msg.sender] += msg.value;\n', '\n', '    while (index < buyIns.length && valueAfterTax > 0) {\n', '      BuyIn storage buyIn = buyIns[index];\n', '\n', '      if (valueAfterTax < buyIn.value) {\n', '        buyIn.owner.transfer(valueAfterTax);\n', '        totalPaidOut[buyIn.owner] += valueAfterTax;\n', '        totalValue[buyIn.owner] -= valueAfterTax;\n', '        buyIn.value -= valueAfterTax;\n', '        valueAfterTax = 0;\n', '      } else {\n', '        buyIn.owner.transfer(buyIn.value);\n', '        totalPaidOut[buyIn.owner] += buyIn.value;\n', '        totalValue[buyIn.owner] -= buyIn.value;\n', '        valueAfterTax -= buyIn.value;\n', '        buyIn.value = 0;\n', '        index++;\n', '      }\n', '    }\n', '\n', '    // if buyins have been exhausted, return the remaining\n', '    // funds back to the investor\n', '    if (valueAfterTax > 0) {\n', '      msg.sender.transfer(valueAfterTax);\n', '      valueMultiplied -= valueAfterTax;\n', '      totalPaidOut[msg.sender] += valueAfterTax;\n', '    }\n', '\n', '    totalValue[msg.sender] += valueMultiplied;\n', '\n', '    buyIns.push(BuyIn({\n', '      value: valueMultiplied,\n', '      owner: msg.sender\n', '    }));\n', '  }\n', '\n', '\n', '  // Send the jackpot if no activity in 24 hours and claimant was the last person to generate activity.\n', '  function claim() public payable isStarted {\n', '    require(now > lastAction + 6 hours);\n', '\trequire(jackpotLastQualified == msg.sender);\n', '\n', '    uint256 seedPay = seedAmount;\n', '    uint256 jpotPay = jackpotBalance - seedAmount;\n', '\n', '    seedAmount = 0;\n', '    contractOwner.transfer(seedPay); // Return the initial seed to owner.\n', '\n', '    jackpotBalance = 0;\n', '\tmsg.sender.transfer(jpotPay); // payout entire jackpot minus seed.\n', '  }\n', '\n', '  // Fallback, sending any ether will call purchase() while sending 0 will call claim()\n', '  function () public payable {\n', '    if(msg.value > 0) {\n', '      purchase();\n', '    } else {\n', '      claim();\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
