['pragma solidity ^0.4.11;\n', '\n', '/** ************************************************************************ **/\n', '/** ************************ Abstract CK Core ****************************** **/\n', '/** ************************************************************************ **/\n', '\n', '/**\n', " * @dev This can be exchanged for any ERC721 contract if we don't want to rely on CK.\n", '**/\n', 'contract KittyCore {\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/** ************************************************************************ **/\n', '/** *************************** Cuddle Data ******************************** **/ \n', '/** ************************************************************************ **/\n', '    \n', '/**\n', ' * @dev Holds the data for all kitty actions and all kitty effects.\n', " * @notice TO-DO: Haven't fully converted this to a format where effects are actions!\n", '**/\n', 'contract CuddleData is Ownable {\n', '    // Action/Effect Id => struct for actions and for effects.\n', '    mapping (uint256 => Action) public actions;\n', '    // Actions specific to personality types.\n', '    mapping (uint256 => uint256[]) typeActions;\n', '    // Actions that any personality can have.\n', '    uint256[] anyActions;\n', '\n', '    // This struct used for all moves a kitty may have.\n', '    struct Action {\n', '        uint256 energy;\n', '        uint8[6] basePets; // Each owner is an index that has a base amount of pets.\n', '        uint8[6] petsAddition; // Special effects may give extra pets.\n', '        uint16[6] critChance; // Special effects may increase (or decrease?) crit chance.\n', '        uint8[6] missChance; // Special effects may decrease (or increase?) miss chance.\n', '        uint256 turnsAffected; // If an effect occurrs\n', '    }\n', '    \n', '/** ************************** EXTERNAL VIEW ******************************* **/\n', '    \n', '    /**\n', '     * @dev Used by CuddleScience to get relevant info for a sequence of moves.\n', '     * @param _actions The 8 length array of the move sequence.\n', '     * @param _cuddleOwner The owner Id that we need info for.\n', '    **/\n', '    function returnActions(uint256[8] _actions, uint256 _cuddleOwner)\n', '      external\n', '      view\n', '    returns (uint256[8] energy, uint256[8] basePets, uint256[8] petsAddition,\n', '             uint256[8] critChance, uint256[8] missChance, uint256[8] turnsAffected)\n', '    {\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            if (_actions[i] == 0) break;\n', '            \n', '            Action memory action = actions[_actions[i]];\n', '            energy[i] = action.energy;\n', '            basePets[i] = action.basePets[_cuddleOwner];\n', '            petsAddition[i] = action.petsAddition[_cuddleOwner];\n', '            critChance[i] = action.critChance[_cuddleOwner];\n', '            missChance[i] = action.missChance[_cuddleOwner];\n', '            turnsAffected[i] = action.turnsAffected;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @NOTICE This is hardcoded for announcement until launch.\n', '     * No point in adding actions now that are just going to be changed.\n', '    **/\n', '    \n', '    /**\n', '     * @dev Returns the amount of kitty actions available.\n', '     * @param _personality If we want personality actions, this is the personality index\n', '    **/\n', '    function getActionCount(uint256 _personality)\n', '      external\n', '      view\n', '    returns (uint256 totalActions)\n', '    {\n', '        //if (_personality > 0) totalActions = typeActions[_personality].length;\n', '        //else totalActions = anyActions.length;\n', '        if (_personality == 0) return 10;\n', '        else return 5;\n', '    }\n', '    \n', '/** ******************************* ONLY OWNER ***************************** **/\n', '    \n', '    /**\n', '     * @dev Used by the owner to create/edit a new action that kitties may learn.\n', '     * @param _actionId The given ID of this action.\n', '     * @param _newEnergy The amount of energy the action will cost.\n', '     * @param _newPets The amount of base pets each owner will give to this action.\n', '     * @param _petAdditions The amount of additional pets each owner will give.\n', '     * @param _critChance The crit chance this move has against each owner.\n', '     * @param _missChance The miss chance this move has against each owner.\n', '     * @param _turnsAffected The amount of turns an effect, if any, will be applied.\n', '     * @param _personality The type/personality this move is specific to (0 for any).\n', '    **/\n', '    function addAction(uint256 _actionId, uint256 _newEnergy, uint8[6] _newPets, uint8[6] _petAdditions,\n', '            uint16[6] _critChance, uint8[6] _missChance, uint256 _turnsAffected, uint256 _personality)\n', '      public // This is called in prepActions down below.\n', '      onlyOwner\n', '    {\n', '        Action memory newAction = Action(_newEnergy, _newPets, _petAdditions, _critChance, _missChance, _turnsAffected);\n', '        actions[_actionId] = newAction;\n', '        \n', '        if (_personality > 0) typeActions[_personality].push(_actionId);\n', '        else anyActions.push(_actionId);\n', '    }\n', '    \n', '}\n', '\n', '/** ************************************************************************* **/\n', '/** **************************** Kitty Data ********************************* **/\n', '/** ************************************************************************* **/\n', '\n', '/**\n', ' * @dev Kitty data holds the core of all data for kitties. This is the most permanent\n', ' * @dev of all contracts in the CryptoCuddles system. As simple as possible because of that.\n', '**/\n', 'contract KittyData is Ownable {\n', '    address public gymContract; // Address of the gym contract.\n', '    address public specialContract; // Address of the contract used to train special kitties.\n', '    address public arenaContract; // Address of the arena contract.\n', '    \n', '    // Mapping of all kitties by CK kitty Id\n', '    mapping (uint256 => Kitty) public kitties;\n', '    \n', '    // All trained kitties\n', '    struct Kitty {\n', '        uint8[2] kittyType; // Personality/type of the kitty.\n', '        uint32[12] actionsArray; // Array of all moves.\n', '        uint16 level; // Current level of the kitty.\n', '        uint16 totalBattles; // Total battles that the kitty has "fought".\n', '    }\n', '    \n', '/** ******************************* DEFAULT ******************************** **/\n', '    \n', '    /**\n', '     * @param _arenaContract The address of the Arena so that it may level up kitties.\n', '     * @param _gymContract The address of the KittyGym so that it may train kitties.\n', '     * @param _specialContract The address of the SpecialGym so it may train specials.\n', '    **/\n', '    function KittyData(address _arenaContract, address _gymContract, address _specialContract)\n', '      public\n', '    {\n', '        arenaContract = _arenaContract;\n', '        gymContract = _gymContract;\n', '        specialContract = _specialContract;\n', '    }\n', '    \n', '/** ***************************** ONLY VERIFIED **************************** **/\n', '    \n', '    /**\n', '     * @dev Used by KittyGym to initially add a kitty.\n', '     * @param _kittyId Unique CK Id of kitty to be added.\n', '     * @param _kittyType The personality type of this kitty.\n', '     * @param _actions Array of all actions to be added to kitty.\n', '    **/\n', '    function addKitty(uint256 _kittyId, uint256 _kittyType, uint256[5] _actions)\n', '      external\n', '      onlyVerified\n', '    returns (bool success)\n', '    {\n', "        delete kitties[_kittyId]; // Wipe this kitty if it's already trained.\n", '        \n', '        kitties[_kittyId].kittyType[0] = uint8(_kittyType);\n', '        for (uint256 i = 0; i < 5; i++) { \n', '            addAction(_kittyId, _actions[i], i);\n', '        }\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Give this learned kitty with a wealthy owner a degree and new graduate-specific actions.\n', '     * @param _kittyId The unique CK Id of the kitty to graduate.\n', '     * @param _specialId The Id of the special type that is being trained.\n', '     * @param _actions The graduate-specific actions that are being given to this kitty.\n', '     * @param _slots The array indices where the new actions will go.\n', '    **/\n', '    function trainSpecial(uint256 _kittyId, uint256 _specialId, uint256[2] _actions, uint256[2] _slots)\n', '      external\n', '      onlyVerified\n', '    returns (bool success)\n', '    {\n', '        kitties[_kittyId].kittyType[1] = uint8(_specialId);\n', '        addAction(_kittyId, _actions[0], _slots[0]);\n', '        addAction(_kittyId, _actions[1], _slots[1]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Used internally and externally to add an action or replace an action.\n', '     * @param _kittyId The unique CK Id of the learning kitty.\n', '     * @param _newAction The new action to learn.\n', "     * @param _moveSlot The kitty's actionsArray index where the move shall go.\n", '    **/\n', '    function addAction(uint256 _kittyId, uint256 _newAction, uint256 _moveSlot)\n', '      public\n', '      onlyVerified\n', '    returns (bool success)\n', '    {\n', '        kitties[_kittyId].actionsArray[_moveSlot] = uint32(_newAction);\n', '        return true;\n', '    }\n', '    \n', '\n', '    /**\n', '     * @dev Arena contract uses this on either a win or lose.\n', '     * @param _kittyId The unique CK Id for the kitty being edited.\n', '     * @param _won Whether or not the kitty won the battle.\n', '    **/\n', '    function incrementBattles(uint256 _kittyId, bool _won)\n', '      external\n', '      onlyVerified\n', '    returns (bool success)\n', '    {\n', '        if (_won) kitties[_kittyId].level++;\n', '        kitties[_kittyId].totalBattles++;\n', '        return true;\n', '    }\n', '    \n', '/** ****************************** CONSTANT ******************************** **/\n', '    \n', '    /**\n', '     * @dev Used on KittyGym when rerolling a move to ensure validity.\n', '     * @param _kittyId Unique CK Id of the kitty.\n', "     * @param _moveSlot The index of the kitty's actionsArray to check.\n", '     * @return The move that occupies the _moveSlot.\n', '    **/\n', '    function fetchSlot(uint256 _kittyId, uint256 _moveSlot)\n', '      external\n', '      view\n', '    returns (uint32)\n', '    {\n', '        return kitties[_kittyId].actionsArray[_moveSlot];\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by frontend to get data for a kitty.\n', "     * @param _kittyId The unique CK Id we're querying for.\n", '    **/\n', '    function returnKitty(uint256 _kittyId)\n', '      external\n', '      view\n', '    returns (uint8[2] kittyType, uint32[12] actionsArray, uint16 level, uint16 totalBattles)\n', '    {\n', '        Kitty memory kitty = kitties[_kittyId];\n', '        kittyType = kitty.kittyType;\n', '        actionsArray = kitty.actionsArray;\n', '        level = kitty.level;\n', '        totalBattles = kitty.totalBattles;\n', '    }\n', '    \n', '/** ***************************** ONLY OWNER ******************************* **/\n', '    \n', '    /**\n', '     * @dev Owner of this contract may change the addresses of associated contracts.\n', '     * @param _gymContract The address of the new KittyGym contract.\n', '     * @param _arenaContract The address of the new Arena contract.\n', '     * @param _specialContract The address of the new SpecialGym contract.\n', '    **/\n', '    function changeContracts(address _gymContract, address _specialContract, address _arenaContract)\n', '      external\n', '      onlyOwner\n', '    {\n', '        if (_gymContract != 0) gymContract = _gymContract;\n', '        if (_specialContract != 0) specialContract = _specialContract;\n', '        if (_arenaContract != 0) arenaContract = _arenaContract;\n', '    }\n', '    \n', '/** ***************************** MODIFIERS ******************************** **/\n', '    \n', '    /**\n', '     * @dev Only the KittyGym and Arena contracts may make changes to KittyData!\n', '    **/\n', '    modifier onlyVerified()\n', '    {\n', '        require(msg.sender == gymContract || msg.sender == specialContract || \n', '                msg.sender == arenaContract);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '/** ************************************************************************ **/\n', '/** **************************** Kitty Gym ********************************* **/\n', '/** ************************************************************************ **/\n', '\n', '/**\n', ' * @dev Allows players to train kitties, reroll the training, or reroll specific moves.\n', ' * @dev Also holds all specific kitty data such as their available actions (but not action data!)\n', '**/\n', 'contract KittyGym is Ownable {\n', '    KittyCore public core;\n', '    CuddleData public cuddleData;\n', '    CuddleCoin public token;\n', '    KittyData public kittyData;\n', '    address public specialGym;\n', '\n', '    uint256 public totalKitties = 1; // Total amount of trained kitties.\n', '    uint256 public personalityTypes; // Number of personality types for randomization.\n', '\n', '    uint256 public trainFee; // In wei\n', '    uint256 public learnFee; // In CuddleCoin wei\n', '    uint256 public rerollFee; // In CuddleCoin wei\n', '    \n', '    // Unique CK Id => action Id => true if the kitty knows the action.\n', '    mapping (uint256 => mapping (uint256 => bool)) public kittyActions;\n', '\n', '    event KittyTrained(uint256 indexed kittyId, uint256 indexed kittyNumber,\n', '            uint256 indexed personality, uint256[5] learnedActions);\n', '    event MoveLearned(uint256 indexed kittyId, uint256 indexed actionId);\n', '    event MoveRerolled(uint256 indexed kittyId, uint256 indexed oldActionId,\n', '                        uint256 indexed newActionId);\n', '\n', '    /**\n', '     * @dev Initialize contract.\n', '    **/\n', '    function KittyGym(address _kittyCore, address _cuddleData, address _cuddleCoin, \n', '                    address _specialGym, address _kittyData)\n', '      public \n', '    {\n', '        core = KittyCore(_kittyCore);\n', '        cuddleData = CuddleData(_cuddleData);\n', '        token = CuddleCoin(_cuddleCoin);\n', '        kittyData = KittyData(_kittyData);\n', '        specialGym = _specialGym;\n', '        \n', '        trainFee = 0;\n', '        learnFee = 1;\n', '        rerollFee = 1;\n', '        personalityTypes = 5;\n', '    }\n', '\n', '/** ***************************** EXTERNAL ********************************* **/\n', '\n', '    /**\n', '     * @dev The owner of a kitty may train or retrain (reset everything) a kitty here.\n', '     * @param _kittyId ID of Kitty to train or retrain.\n', '    **/\n', '    function trainKitty(uint256 _kittyId)\n', '      external\n', '      payable\n', '      isNotContract\n', '    {\n', '        // Make sure trainer owns this kitty\n', '        require(core.ownerOf(_kittyId) == msg.sender);\n', '        require(msg.value == trainFee);\n', '        \n', '        // Make sure we delete all actions if the kitty has already been trained.\n', '        if (kittyData.fetchSlot(_kittyId, 0) > 0) {\n', '            var (,actionsArray,,) = kittyData.returnKitty(_kittyId);\n', '            deleteActions(_kittyId, actionsArray); // A special kitty will be thrown here.\n', '        }\n', '\n', '        uint256 newType = random(totalKitties * 11, 1, personalityTypes); // upper is inclusive here\n', '        kittyActions[_kittyId][(newType * 1000) + 1] = true;\n', '        \n', '        uint256[2] memory newTypeActions = randomizeActions(newType, _kittyId);\n', '        uint256[2] memory newAnyActions = randomizeActions(0, _kittyId);\n', '\n', '        uint256[5] memory newActions;\n', '        newActions[0] = (newType * 1000) + 1;\n', '        newActions[1] = newTypeActions[0];\n', '        newActions[2] = newTypeActions[1];\n', '        newActions[3] = newAnyActions[0];\n', '        newActions[4] = newAnyActions[1];\n', '        \n', '        kittyActions[_kittyId][newActions[1]] = true;\n', '        kittyActions[_kittyId][newActions[2]] = true;\n', '        kittyActions[_kittyId][newActions[3]] = true;\n', '        kittyActions[_kittyId][newActions[4]] = true;\n', ' \n', '        assert(kittyData.addKitty(_kittyId, newType, newActions));\n', '        KittyTrained(_kittyId, totalKitties, newType, newActions);\n', '        totalKitties++;\n', '        \n', '        owner.transfer(msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev May teach your kitty a new random move for a fee.\n', '     * @param _kittyId The ID of the kitty who shall get a move added.\n', '     * @param _moveSlot The array index that the move shall be placed in.\n', '    **/\n', '    function learnMove(uint256 _kittyId, uint256 _moveSlot)\n', '      external\n', '      isNotContract\n', '    {\n', '        require(msg.sender == core.ownerOf(_kittyId));\n', "        // Burn the learning fee from the trainer's balance\n", '        assert(token.burn(msg.sender, learnFee));\n', '        require(kittyData.fetchSlot(_kittyId, 0) > 0); // Cannot learn without training.\n', '        require(kittyData.fetchSlot(_kittyId, _moveSlot) == 0); // Must be put in blank spot.\n', '        \n', '        uint256 upper = cuddleData.getActionCount(0);\n', '        uint256 actionId = unduplicate(_kittyId * 11, 999, upper, 0); // * 11 and 99...are arbitrary\n', '        \n', "        assert(!kittyActions[_kittyId][actionId]); // Throw if a new move still wasn't found.\n", '        kittyActions[_kittyId][actionId] = true;\n', '        \n', '        assert(kittyData.addAction(_kittyId, actionId, _moveSlot));\n', '        MoveLearned(_kittyId, actionId);\n', '    }\n', '\n', '    /**\n', '     * @dev May reroll one kitty move. Cheaper than buying a new one.\n', '     * @param _kittyId The kitty who needs to retrain a move slot.\n', "     * @param _moveSlot The index of the kitty's actionsArray to replace.\n", '     * @param _typeId The personality Id of the kity.\n', '    **/\n', '    function reRollMove(uint256 _kittyId, uint256 _moveSlot, uint256 _typeId)\n', '      external\n', '      isNotContract\n', '    {\n', '        require(msg.sender == core.ownerOf(_kittyId));\n', '        \n', '        // Make sure the old action exists and is of the correct type (purposeful underflow).\n', '        uint256 oldAction = kittyData.fetchSlot(_kittyId, _moveSlot);\n', '        require(oldAction > 0);\n', '        require(oldAction - (_typeId * 1000) < 1000);\n', '        \n', "        // Burn the rerolling fee from the trainer's balance\n", '        assert(token.burn(msg.sender, rerollFee));\n', '\n', '        uint256 upper = cuddleData.getActionCount(_typeId);\n', '        uint256 actionId = unduplicate(_kittyId, oldAction, upper, _typeId);\n', '\n', '        assert(!kittyActions[_kittyId][actionId]); \n', '        kittyActions[_kittyId][oldAction] = false;\n', '        kittyActions[_kittyId][actionId] = true;\n', '        \n', '        assert(kittyData.addAction(_kittyId, actionId, _moveSlot));\n', '        MoveRerolled(_kittyId, oldAction, actionId);\n', '    }\n', '    \n', '/** ******************************* INTERNAL ******************************** **/\n', '    \n', '    /**\n', '     * @dev Return two actions for training or hybridizing a kitty using the given type.\n', '     * @param _actionType The type of actions that shall be learned. 0 for "any" actions.\n', '     * @param _kittyId The unique CK Id of the kitty.\n', '    **/ \n', '    function randomizeActions(uint256 _actionType, uint256 _kittyId)\n', '      internal\n', '      view\n', '    returns (uint256[2])\n', '    {\n', '        uint256 upper = cuddleData.getActionCount(_actionType);\n', '        uint256 action1 = unduplicate(_kittyId, 999, upper, _actionType);\n', '        uint256 action2 = unduplicate(_kittyId, action1, upper, _actionType);\n', '        return [action1,action2];\n', '    }\n', '    \n', '    /**\n', '     * @dev Used when a new action is chosen but the kitty already knows it.\n', '     * @dev If no unique actions can be found, unduplicate throws.\n', '     * @param _kittyId The unique CK Id of the kitty.\n', '     * @param _action1 The action that is already known.\n', '     * @param _upper The amount of actions that can be tried.\n', '     * @param _type The type of action that these actions are.\n', '     * @return The new action that is not a duplicate.\n', '    **/\n', '    function unduplicate(uint256 _kittyId, uint256 _action1, uint256 _upper, uint256 _type)\n', '      internal\n', '      view\n', '    returns (uint256 newAction)\n', '    {\n', "        uint256 typeBase = _type * 1000; // The base thousand for this move's type.\n", '\n', '        for (uint256 i = 1; i < 11; i++) {\n', '            newAction = random(i * 666, 1, _upper) + typeBase;\n', '            if (newAction != _action1 && !kittyActions[_kittyId][newAction]) break;\n', '        }\n', '        \n', "        // If the kitty still knows the move, increment till we find one it doesn't.\n", '        if (newAction == _action1 || kittyActions[_kittyId][newAction]) {\n', '            for (uint256 j = 1; j < _upper + 1; j++) {\n', '                uint256 incAction = ((newAction + j) % _upper) + 1;\n', '\n', '                incAction += typeBase;\n', '                if (incAction != _action1 && !kittyActions[_kittyId][incAction]) {\n', '                    newAction = incAction;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Create a random number.\n', '     * @param _rnd Seed to help randomize.\n', '     * @param _lower The lower bound of the random number (inclusive).\n', '     * @param _upper The upper bound of the random number (exclusive).\n', '    **/ \n', '    function random(uint256 _rnd, uint256 _lower, uint256 _upper) \n', '      internal\n', '      view\n', '    returns (uint256) \n', '    {\n', '        uint256 _seed = uint256(keccak256(keccak256(_rnd, _seed), now));\n', '        return (_seed % _upper) + _lower;\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by trainKitty to delete mapping values if the kitty has already been trained.\n', '     * @param _kittyId The unique CK Id of the kitty.\n', '     * @param _actions The list of all actions the kitty currently has.\n', '    **/\n', '    function deleteActions(uint256 _kittyId, uint32[12] _actions)\n', '      internal\n', '    {\n', '        for (uint256 i = 0; i < _actions.length; i++) {\n', "            // Make sure a special kitty isn't retrained. Purposeful underflow.\n", '            require(uint256(_actions[i]) - 50000 > 10000000);\n', '            \n', '            delete kittyActions[_kittyId][uint256(_actions[i])];\n', '        }\n', '    }\n', '    \n', '/** ************************* EXTERNAL CONSTANT **************************** **/\n', '    \n', '    /**\n', '     * @dev Confirms whether a kitty has chosen actions.\n', '     * @param _kittyId The id of the kitty whose actions need to be checked.\n', '     * @param _kittyActions The actions to be checked.\n', '    **/\n', '    function confirmKittyActions(uint256 _kittyId, uint256[8] _kittyActions) \n', '      external \n', '      view\n', '    returns (bool)\n', '    {\n', '        for (uint256 i = 0; i < 8; i++) {\n', '            if (!kittyActions[_kittyId][_kittyActions[i]]) return false; \n', '        }\n', '        return true;\n', '    }\n', '    \n', '/** ************************* ONLY VERIFIED/OWNER ************************** **/\n', '    \n', '    /**\n', '     * @dev Used by the SpecialGym contract when a kitty learns new special moves.\n', '     * @param _kittyId The Id of the now special kitty!\n', '     * @param _moves A 2-length array with the new special moves.\n', '    **/\n', '    function addMoves(uint256 _kittyId, uint256[2] _moves)\n', '      external\n', '      onlyVerified\n', '    returns (bool success)\n', '    {\n', '        kittyActions[_kittyId][_moves[0]] = true;\n', '        kittyActions[_kittyId][_moves[1]] = true;\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by owner to change all fees on KittyGym.\n', '     * @param _trainFee The new cost (IN ETHER WEI) of training a new cat.\n', '     * @param _learnFee The new cost (IN TOKEN WEI) of learning a new move.\n', '     * @param _rerollFee The new cost (IN TOKEN WEI) of rerolling a move.\n', '    **/\n', '    function changeFees(uint256 _trainFee, uint256 _learnFee, uint256 _rerollFee)\n', '      external\n', '      onlyOwner\n', '    {\n', '        trainFee = _trainFee;\n', '        learnFee = _learnFee;\n', '        rerollFee = _rerollFee;\n', '    }\n', '\n', '    /**\n', '     * @dev Used by owner to change the amount of actions there are.\n', '     * @param _newTypeCount The new number of personalities there are.\n', '    **/\n', '    function changeVariables(uint256 _newTypeCount)\n', '      external\n', '      onlyOwner\n', '    {\n', '        if (_newTypeCount != 0) personalityTypes = _newTypeCount;\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner may use to change any/every connected contract address.\n', '     * @dev Owner may leave params as null and nothing will happen to that variable.\n', '     * @param _newData The address of the new cuddle data contract if desired.\n', '     * @param _newCore The address of the new CK core contract if desired.\n', '     * @param _newToken The address of the new cuddle token if desired.\n', '     * @param _newKittyData The address of the new KittyData contract.\n', '     * @param _newSpecialGym The address of the new SpecialGym contract.\n', '    **/\n', '    function changeContracts(address _newData, address _newCore, address _newToken, address _newKittyData,\n', '                            address _newSpecialGym)\n', '      external\n', '      onlyOwner\n', '    {\n', '        if (_newData != 0) cuddleData = CuddleData(_newData);\n', '        if (_newCore != 0) core = KittyCore(_newCore);\n', '        if (_newToken != 0) token = CuddleCoin(_newToken);\n', '        if (_newKittyData != 0) kittyData = KittyData(_newKittyData);\n', '        if (_newSpecialGym != 0) specialGym = _newSpecialGym;\n', '    }\n', '    \n', '/** ***************************** MODIFIERS ******************************** **/\n', '    \n', '    /**\n', '    * @dev Ensure only the arena contract can call pet count.\n', '    **/\n', '    modifier onlyVerified()\n', '    {\n', '        require(msg.sender == specialGym);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Ensure the sender is not a contract. This removes most of \n', '     * @dev the possibility of abuse of our timestamp/blockhash randomizers.\n', '    **/ \n', '    modifier isNotContract() {\n', '        uint size;\n', '        address addr = msg.sender;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size == 0);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '/** ************************************************************************ **/\n', '/** **************************** Special Gym ******************************* **/\n', '/** ************************************************************************ **/\n', '\n', '/**\n', ' * @dev Special Gym is used to train kitties with special\n', ' * @dev personality types such as graduates.\n', '**/\n', 'contract SpecialGym is Ownable {\n', '    KittyCore public core;\n', '    KittyData public kittyData;\n', '    CuddleData public cuddleData;\n', '    KittyGym public kittyGym;\n', '    \n', '    // Unique CK Id => true if they already have a special.\n', '    mapping (uint256 => bool) public specialKitties;\n', '    \n', '    // Special personality Id => number left that may train. Graduates are Id 50.\n', '    mapping (uint256 => SpecialPersonality) public specialInfo;\n', '    \n', '    struct SpecialPersonality {\n', '        uint16 population; // Total amount of this special ever available.\n', '        uint16 amountLeft; // The number of special personalities available to buy.\n', '        uint256 price; // Price of this special.\n', '    }\n', '    \n', '    event SpecialTrained(uint256 indexed kittyId, uint256 indexed specialId, \n', '        uint256 indexed specialRank, uint256[2] specialMoves);\n', '    \n', '    function SpecialGym(address _kittyCore, address _kittyData, address _cuddleData, address _kittyGym)\n', '      public\n', '    {\n', '        core = KittyCore(_kittyCore);\n', '        kittyData = KittyData(_kittyData);\n', '        cuddleData = CuddleData(_cuddleData);\n', '        kittyGym = KittyGym(_kittyGym);\n', '    }\n', '    \n', '    /**\n', '     * @dev Used to buy an exclusive special personality such as graduate.\n', '     * @param _kittyId The unique CK Id of the kitty to train.\n', '     * @param _specialId The Id of the special personality being trained.\n', '     * @param _slots The two move slots where the kitty wants their new moves.\n', '    **/\n', '    function trainSpecial(uint256 _kittyId, uint256 _specialId, uint256[2] _slots)\n', '      external\n', '      payable\n', '      isNotContract\n', '    {\n', '        SpecialPersonality storage special = specialInfo[_specialId];\n', '        \n', '        require(msg.sender == core.ownerOf(_kittyId));\n', '        require(kittyData.fetchSlot(_kittyId, 0) > 0); // Require kitty has been trained.\n', '        require(!specialKitties[_kittyId]);\n', '        require(msg.value == special.price);\n', '        require(special.amountLeft > 0);\n', '\n', '        // Get two new random special moves.\n', '        uint256[2] memory randomMoves = randomizeActions(_specialId);\n', '        \n', '        assert(kittyData.trainSpecial(_kittyId, _specialId, randomMoves, _slots));\n', '        assert(kittyGym.addMoves(_kittyId, randomMoves));\n', '        \n', '        uint256 specialRank = special.population - special.amountLeft + 1;\n', '        SpecialTrained(_kittyId, _specialId, specialRank, randomMoves);\n', '    \n', '        special.amountLeft--;\n', '        specialKitties[_kittyId] = true;\n', '        owner.transfer(msg.value);\n', '    }\n', '    \n', '/** ******************************* INTERNAL ******************************* **/\n', '    \n', '    /**\n', '     * @dev Return two actions for training or hybridizing a kitty using the given type.\n', '     * @param _specialType The type of actions that shall be learned. 0 for "any" actions.\n', '     * @return Two new special moves.\n', '    **/ \n', '    function randomizeActions(uint256 _specialType)\n', '      internal\n', '      view\n', '    returns (uint256[2])\n', '    {\n', '        uint256 upper = cuddleData.getActionCount(_specialType);\n', '        \n', '        uint256 action1 = random(_specialType, 1, upper);\n', '        uint256 action2 = random(action1 + 1, 1, upper);\n', '        if (action1 == action2) {\n', '            action2 = unduplicate(action1, upper);\n', '        }\n', '\n', '        uint256 typeBase = 1000 * _specialType;\n', '        return [action1 + typeBase, action2 + typeBase];\n', '    }\n', '    \n', '    /**\n', "     * @dev Used to make sure the kitty doesn't learn two of the same move.\n", '     * @dev If no unique actions can be found, unduplicate throws.\n', '     * @param _action1 The action that is already known.\n', '     * @param _upper The amount of actions that can be tried.\n', '     * @return The new action that is not a duplicate.\n', '    **/\n', '    function unduplicate(uint256 _action1, uint256 _upper)\n', '      internal\n', '      view\n', '    returns (uint256)\n', '    {\n', '        uint256 action2;\n', '        for (uint256 i = 1; i < 10; i++) { // Start at 1 to make sure _rnd is never 1.\n', '            action2 = random(action2 + i, 1, _upper);\n', '            if (action2 != _action1) break;\n', '        }\n', '        \n', '        // If the kitty still knows the move, simply increment.\n', '        if (action2 == _action1) {\n', '            action2 = (_action1 % _upper) + 1;\n', '        }\n', '            \n', '        return action2;\n', '    }\n', '    \n', '    /**\n', '     * @dev Create a random number.\n', '     * @param _rnd Seed to help randomize.\n', '     * @param _lower The lower bound of the random number (inclusive).\n', '     * @param _upper The upper bound of the random number (exclusive).\n', '     * @return Returns a fairly random number.\n', '    **/ \n', '    function random(uint256 _rnd, uint256 _lower, uint256 _upper) \n', '      internal\n', '      view\n', '    returns (uint256) \n', '    {\n', '        uint256 _seed = uint256(keccak256(keccak256(_rnd, _seed), now));\n', '        return (_seed % _upper) + _lower;\n', '    }\n', '    \n', '/** ******************************* CONSTANT ****************************** **/\n', '    \n', '    /**\n', '     * @dev Used by frontend to get information on a special.\n', '     * @param _specialId The unique identifier of the special personality.\n', '    **/\n', '    function specialsInfo(uint256 _specialId) \n', '      external \n', '      view \n', '    returns(uint256, uint256) \n', '    { \n', '        require(_specialId > 0); \n', '        return (specialInfo[_specialId].amountLeft, specialInfo[_specialId].price); \n', '    }\n', '    \n', '/** ****************************** ONLY OWNER ****************************** **/\n', '    \n', '    /**\n', '     * @dev Used by owner to create and populate a new special personality.\n', "     * @param _specialId The special's personality Id--starts at 50\n", '     * @param _amountAvailable The maximum amount of this special that will ever be available.\n', '     * @param _price The price that the special will be sold for.\n', '    **/\n', '    function addSpecial(uint256 _specialId, uint256 _amountAvailable, uint256 _price)\n', '      external\n', '      onlyOwner\n', '    {\n', '        SpecialPersonality storage special = specialInfo[_specialId];\n', '        require(special.price == 0);\n', '        \n', '        special.population = uint16(_amountAvailable);\n', '        special.amountLeft = uint16(_amountAvailable);\n', '        special.price = _price; \n', '    }\n', '    \n', '    /**\n', '     * @dev Used by owner to change price of a special kitty or lower available population.\n', '     * @dev Owner may NOT increase available population to ensure their rarity to players.\n', '     * @param _specialId The unique Id of the special to edit (graduate is 50).\n', '     * @param _newPrice The desired new price of the special.\n', '     * @param _amountToDestroy The amount of this special that we want to lower supply for.\n', '    **/\n', '    function editSpecial(uint256 _specialId, uint256 _newPrice, uint16 _amountToDestroy)\n', '      external\n', '      onlyOwner\n', '    {\n', '        SpecialPersonality storage special = specialInfo[_specialId];\n', '        \n', '        if (_newPrice != 0) special.price = _newPrice;\n', '        if (_amountToDestroy != 0) {\n', '            require(_amountToDestroy <= special.population && _amountToDestroy <= special.amountLeft);\n', '            special.population -= _amountToDestroy;\n', '            special.amountLeft -= _amountToDestroy;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner may use to change any/every connected contract address.\n', '     * @dev Owner may leave params as null and nothing will happen to that variable.\n', '     * @param _newData The address of the new cuddle data contract if desired.\n', '     * @param _newCore The address of the new CK core contract if desired.\n', '     * @param _newKittyGym The address of the new KittyGym if desired.\n', '     * @param _newKittyData The address of the new KittyData contract.\n', '    **/\n', '    function changeContracts(address _newData, address _newCore, address _newKittyData, address _newKittyGym)\n', '      external\n', '      onlyOwner\n', '    {\n', '        if (_newData != 0) cuddleData = CuddleData(_newData);\n', '        if (_newCore != 0) core = KittyCore(_newCore);\n', '        if (_newKittyData != 0) kittyData = KittyData(_newKittyData);\n', '        if (_newKittyGym != 0) kittyGym = KittyGym(_newKittyGym);\n', '    }\n', '    \n', '/** ****************************** MODIFIERS ******************************* **/\n', '\n', '    /**\n', '     * @dev Ensure the sender is not a contract. This removes most of \n', '     * @dev the possibility of abuse of our timestamp/blockhash randomizers.\n', '    **/ \n', '    modifier isNotContract() {\n', '        uint size;\n', '        address addr = msg.sender;\n', '        assembly { size := extcodesize(addr) }\n', '        require(size == 0);\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '/**\n', ' * @title Cuddle Coin\n', ' * @dev A very straightforward ERC20 contract that also has minting abilities\n', ' * @dev for people to be able to win coins and purchase coins. EFFECTIVELY CENTRALIZED!\n', '**/\n', '\n', 'contract CuddleCoin is Ownable {\n', '    string public constant symbol = "CDL";\n', '    string public constant name = "CuddleCoin";\n', '\n', '    address arenaContract; // Needed for minting.\n', '    address vendingMachine; // Needed for minting and burning.\n', '    address kittyGym; // Needed for burning.\n', '    \n', '    // Storing small numbers is cheaper.\n', '    uint8 public constant decimals = 18;\n', '    uint256 _totalSupply = 1000000 * (10 ** 18);\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _amount);\n', '    event Approval(address indexed _from, address indexed _spender, uint256 indexed _amount);\n', '    event Mint(address indexed _to, uint256 indexed _amount);\n', '    event Burn(address indexed _from, uint256 indexed _amount);\n', '\n', '    /**\n', '     * @dev Set owner and beginning balance.\n', '    **/\n', '    function CuddleCoin(address _arenaContract, address _vendingMachine)\n', '      public\n', '    {\n', '        balances[msg.sender] = _totalSupply;\n', '        arenaContract = _arenaContract;\n', '        vendingMachine = _vendingMachine;\n', '    }\n', '\n', '    /**\n', '     * @dev Return total supply of token\n', '    **/\n', '    function totalSupply() \n', '      external\n', '      constant \n', '     returns (uint256) \n', '    {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Return balance of a certain address.\n', '     * @param _owner The address whose balance we want to check.\n', '    **/\n', '    function balanceOf(address _owner)\n', '      external\n', '      constant \n', '    returns (uint256) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers coins from one address to another.\n', '     * @param _to The recipient of the transfer amount.\n', '     * @param _amount The amount of tokens to transfer.\n', '    **/\n', '    function transfer(address _to, uint256 _amount) \n', '      external\n', '    returns (bool success)\n', '    {\n', '        // Throw if insufficient balance\n', '        require(balances[msg.sender] >= _amount);\n', '\n', '        balances[msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev An allowed address can transfer tokens from another's address.\n", '     * @param _from The owner of the tokens to be transferred.\n', '     * @param _to The address to which the tokens will be transferred.\n', '     * @param _amount The amount of tokens to be transferred.\n', '    **/\n', '    function transferFrom(address _from, address _to, uint _amount)\n', '      external\n', '    returns (bool success)\n', '    {\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);\n', '\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        \n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev Approves a wallet to transfer tokens on one's behalf.\n", '     * @param _spender The wallet approved to spend tokens.\n', '     * @param _amount The amount of tokens approved to spend.\n', '    **/\n', '    function approve(address _spender, uint256 _amount) \n', '      external\n', '    {\n', '        require(_amount == 0 || allowed[msg.sender][_spender] == 0);\n', '        require(balances[msg.sender] >= _amount);\n', '        \n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '    }\n', '\n', '    /**\n', "     * @dev Allowed amount for a user to spend of another's tokens.\n", '     * @param _owner The owner of the tokens approved to spend.\n', '     * @param _spender The address of the user allowed to spend the tokens.\n', '    **/\n', '    function allowance(address _owner, address _spender) \n', '      external\n', '      constant \n', '    returns (uint256) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /**\n', '     * @dev Used only be vending machine and arena contract to mint to\n', '     * @dev token purchases and cuddlers in a battle.\n', '     * @param _to The address to which coins will be minted.\n', '     * @param _amount The amount of coins to be minted to that address.\n', '    **/\n', '    function mint(address _to, uint256 _amount)\n', '      external\n', '      onlyMinter\n', '    returns (bool success)\n', '    {\n', '        balances[_to] += _amount;\n', '        \n', '        Mint(_to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by kitty gym and vending machine to take coins from users.\n', '     * @param _from The address that will have coins burned.\n', '     * @param _amount The amount of coins that will be burned.\n', '    **/\n', '    function burn(address _from, uint256 _amount)\n', '      external\n', '      onlyMinter\n', '    returns (bool success)\n', '    {\n', '        require(balances[_from] >= _amount);\n', '        \n', '        balances[_from] -= _amount;\n', '        Burn(_from, _amount);\n', '        return true;\n', '    }\n', '      \n', '    /**\n', '     * @dev Owner my change the contracts allowed to mint.\n', '     * @dev This gives owner full control over these tokens but since they are\n', '     * @dev not a normal cryptocurrency, centralization is not a problem.\n', '     * @param _arenaContract The first contract allowed to mint coins.\n', '     * @param _vendingMachine The second contract allowed to mint coins.\n', '    **/\n', '    function changeMinters(address _arenaContract, address _vendingMachine, address _kittyGym)\n', '      external\n', '      onlyOwner\n', '    returns (bool success)\n', '    {\n', '        if (_arenaContract != 0) arenaContract = _arenaContract;\n', '        if (_vendingMachine != 0) vendingMachine = _vendingMachine;\n', '        if (_kittyGym != 0) kittyGym = _kittyGym;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Arena contract and vending machine contract must be able to mint coins.\n', '     * @dev This modifier ensures no other contract may be able to mint.\n', '     * @dev Owner can change these permissions.\n', '    **/\n', '    modifier onlyMinter()\n', '    {\n', '        require(msg.sender == arenaContract || msg.sender == vendingMachine || msg.sender == kittyGym);\n', '        _;\n', '    }\n', '}']