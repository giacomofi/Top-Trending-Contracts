['pragma solidity 0.4.18;\n', '\n', '/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address _owner) constant public returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Basic ERC20 token contract implementation.\n', "/// @dev Based on OpenZeppelin's StandardToken.\n", 'contract BasicToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public totalSupply;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping (address => uint256) balances;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    /// @param _spender address The address which will spend the funds.\n', '    /// @param _value uint256 The amount of tokens to be spent.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve (see NOTE)\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n', '            revert();\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    /// @param _owner address The address which owns the funds.\n', '    /// @param _spender address The address which will spend the funds.\n', '    /// @return uint256 specifying the amount of tokens still available for the spender.\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /// @dev Gets the balance of the specified address.\n', '    /// @param _owner address The address to query the the balance of.\n', '    /// @return uint256 representing the amount owned by the passed address.\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev Transfer token to a specified address.\n', '    /// @param _to address The address to transfer to.\n', '    /// @param _value uint256 The amount to be transferred.\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Transfer tokens from one address to another.\n', '    /// @param _from address The address which you want to send tokens from.\n', '    /// @param _to address The address which you want to transfer to.\n', '    /// @param _value uint256 the amount of tokens to be transferred.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title ERC Token Standard #677 Interface (https://github.com/ethereum/EIPs/issues/677)\n', 'contract ERC677 is ERC20 {\n', '    function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\n', '\n', '    event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/// @title Math operations with safety checks\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // require(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function toPower2(uint256 a) internal pure returns (uint256) {\n', '        return mul(a, a);\n', '    }\n', '\n', '    function sqrt(uint256 a) internal pure returns (uint256) {\n', '        uint256 c = (a + 1) / 2;\n', '        uint256 b = a;\n', '        while (c < b) {\n', '            b = c;\n', '            c = (a / c + c) / 2;\n', '        }\n', '        return b;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Standard677Token implentation, base on https://github.com/ethereum/EIPs/issues/677\n', '\n', 'contract Standard677Token is ERC677, BasicToken {\n', '\n', '  /// @dev ERC223 safe token transfer from one address to another\n', '  /// @param _to address the address which you want to transfer to.\n', '  /// @param _value uint256 the amount of tokens to be transferred.\n', '  /// @param _data bytes data that can be attached to the token transation\n', '  function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\n', '    require(super.transfer(_to, _value)); // do a normal token transfer\n', '    TransferAndCall(msg.sender, _to, _value, _data);\n', '    //filtering if the target is a contract with bytecode inside it\n', '    if (isContract(_to)) return contractFallback(_to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  /// @dev called when transaction target is a contract\n', '  /// @param _to address the address which you want to transfer to.\n', '  /// @param _value uint256 the amount of tokens to be transferred.\n', '  /// @param _data bytes data that can be attached to the token transation\n', '  function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\n', '    ERC223Receiver receiver = ERC223Receiver(_to);\n', '    require(receiver.tokenFallback(msg.sender, _value, _data));\n', '    return true;\n', '  }\n', '\n', '  /// @dev check if the address is contract\n', '  /// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '  /// @param _addr address the address to check\n', '  function isContract(address _addr) private constant returns (bool is_contract) {\n', '    // retrieve the size of the code on target address, this needs assembly\n', '    uint length;\n', '    assembly { length := extcodesize(_addr) }\n', '    return length > 0;\n', '  }\n', '}\n', '\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization control functions,\n', '/// this simplifies the implementation of "user permissions".\n', "/// @dev Based on OpenZeppelin's Ownable.\n", '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed _by, address indexed _to);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    /// @dev Constructor sets the original `owner` of the contract to the sender account.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Reverts if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerCandidate() {\n', '        require(msg.sender == newOwnerCandidate);\n', '        _;\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n', '        require(_newOwnerCandidate != address(0));\n', '\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\n', '    function acceptOwnership() external onlyOwnerCandidate {\n', '        address previousOwner = owner;\n', '\n', '        owner = newOwnerCandidate;\n', '        newOwnerCandidate = address(0);\n', '\n', '        OwnershipTransferred(previousOwner, owner);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Token holder contract.\n', 'contract TokenHolder is Ownable {\n', '    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\n', '    /// @param _tokenAddress address The address of the ERC20 contract.\n', '    /// @param _amount uint256 The amount of tokens to be transferred.\n', '    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\n', '        return ERC20(_tokenAddress).transfer(owner, _amount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Colu Local Currency contract.\n', '/// @author Rotem Lev.\n', 'contract ColuLocalCurrency is Ownable, Standard677Token, TokenHolder {\n', '    using SafeMath for uint256;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '   \n', '    /// @dev cotract to use when issuing a CC (Local Currency)\n', '    /// @param _name string name for CC token that is created.\n', '    /// @param _symbol string symbol for CC token that is created.\n', '    /// @param _decimals uint8 percison for CC token that is created.\n', '    /// @param _totalSupply uint256 total supply of the CC token that is created. \n', '    function ColuLocalCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\n', '        require(_totalSupply != 0);     \n', '        require(bytes(_name).length != 0);\n', '        require(bytes(_symbol).length != 0);\n', '\n', '        totalSupply = _totalSupply;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '}\n', '\n', '/// @title ERC223Receiver Interface\n', '/// @dev Based on the specs form: https://github.com/ethereum/EIPs/issues/223\n', 'contract ERC223Receiver {\n', '    function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\n', '}\n', '\n', '\n', '\n', ' /// @title Standard ERC223 Token Receiver implementing tokenFallback function and tokenPayable modifier\n', '\n', 'contract Standard223Receiver is ERC223Receiver {\n', '  Tkn tkn;\n', '\n', '  struct Tkn {\n', '    address addr;\n', '    address sender; // the transaction caller\n', '    uint256 value;\n', '  }\n', '\n', '  bool __isTokenFallback;\n', '\n', '  modifier tokenPayable {\n', '    require(__isTokenFallback);\n', '    _;\n', '  }\n', '\n', '  /// @dev Called when the receiver of transfer is contract\n', '  /// @param _sender address the address of tokens sender\n', '  /// @param _value uint256 the amount of tokens to be transferred.\n', '  /// @param _data bytes data that can be attached to the token transation\n', '  function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\n', '    if (!supportsToken(msg.sender)) {\n', '      return false;\n', '    }\n', '\n', '    // Problem: This will do a sstore which is expensive gas wise. Find a way to keep it in memory.\n', '    // Solution: Remove the the data\n', '    tkn = Tkn(msg.sender, _sender, _value);\n', '    __isTokenFallback = true;\n', '    if (!address(this).delegatecall(_data)) {\n', '      __isTokenFallback = false;\n', '      return false;\n', '    }\n', '    // avoid doing an overwrite to .token, which would be more expensive\n', '    // makes accessing .tkn values outside tokenPayable functions unsafe\n', '    __isTokenFallback = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  function supportsToken(address token) public constant returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title TokenOwnable\n', '/// @dev The TokenOwnable contract adds a onlyTokenOwner modifier as a tokenReceiver with ownable addaptation\n', '\n', 'contract TokenOwnable is Standard223Receiver, Ownable {\n', '    /// @dev Reverts if called by any account other than the owner for token sending.\n', '    modifier onlyTokenOwner() {\n', '        require(tkn.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title Market Maker Interface.\n', '/// @author Tal Beja.\n', 'contract MarketMaker is ERC223Receiver {\n', '\n', '  function getCurrentPrice() public constant returns (uint _price);\n', '  function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\n', '  function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\n', '  function change(address _toToken) public returns (uint _returnAmount);\n', '  function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\n', '  function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\n', '  function openForPublicTrade() public returns (bool success);\n', '  function isOpenForPublic() public returns (bool success);\n', '\n', '  event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Ellipse Market Maker contract.\n', '/// @dev market maker, using ellipse equation.\n', '/// @author Tal Beja.\n', 'contract EllipseMarketMaker is TokenOwnable {\n', '\n', '  // precision for price representation (as in ether or tokens).\n', '  uint256 public constant PRECISION = 10 ** 18;\n', '\n', '  // The tokens pair.\n', '  ERC20 public token1;\n', '  ERC20 public token2;\n', '\n', '  // The tokens reserves.\n', '  uint256 public R1;\n', '  uint256 public R2;\n', '\n', '  // The tokens full suplly.\n', '  uint256 public S1;\n', '  uint256 public S2;\n', '\n', '  // State flags.\n', '  bool public operational;\n', '  bool public openForPublic;\n', '\n', '  // Library contract address.\n', '  address public mmLib;\n', '\n', '  /// @dev Constructor calling the library contract using delegate.\n', '  function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\n', '    require(_mmLib != address(0));\n', "    // Signature of the mmLib's constructor function\n", '    // bytes4 sig = bytes4(keccak256("constructor(address,address,address)"));\n', '    bytes4 sig = 0x6dd23b5b;\n', '\n', '    // 3 arguments of size 32\n', '    uint256 argsSize = 3 * 32;\n', '    // sig + arguments size\n', '    uint256 dataSize = 4 + argsSize;\n', '\n', '\n', '    bytes memory m_data = new bytes(dataSize);\n', '\n', '    assembly {\n', '        // Add the signature first to memory\n', '        mstore(add(m_data, 0x20), sig)\n', '        // Add the parameters\n', '        mstore(add(m_data, 0x24), _mmLib)\n', '        mstore(add(m_data, 0x44), _token1)\n', '        mstore(add(m_data, 0x64), _token2)\n', '    }\n', '\n', '    // delegatecall to the library contract\n', '    require(_mmLib.delegatecall(m_data));\n', '  }\n', '\n', '  /// @dev returns true iff token is supperted by this contract (for erc223/677 tokens calls)\n', '  /// @param token can be token1 or token2\n', '  function supportsToken(address token) public constant returns (bool) {\n', '    return (token1 == token || token2 == token);\n', '  }\n', '\n', '  /// @dev gets called when no other function matches, delegate to the lib contract.\n', '  function() public {\n', '    address _mmLib = mmLib;\n', '    if (msg.data.length > 0) {\n', '      assembly {\n', '        calldatacopy(0xff, 0, calldatasize)\n', '        let retVal := delegatecall(gas, _mmLib, 0xff, calldatasize, 0, 0x20)\n', '        switch retVal case 0 { revert(0,0) } default { return(0, 0x20) }\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Ellipse Market Maker Interfase\n', '/// @author Tal Beja\n', 'contract IEllipseMarketMaker is MarketMaker {\n', '\n', '    // precision for price representation (as in ether or tokens).\n', '    uint256 public constant PRECISION = 10 ** 18;\n', '\n', '    // The tokens pair.\n', '    ERC20 public token1;\n', '    ERC20 public token2;\n', '\n', '    // The tokens reserves.\n', '    uint256 public R1;\n', '    uint256 public R2;\n', '\n', '    // The tokens full suplly.\n', '    uint256 public S1;\n', '    uint256 public S2;\n', '\n', '    // State flags.\n', '    bool public operational;\n', '    bool public openForPublic;\n', '\n', '    // Library contract address.\n', '    address public mmLib;\n', '\n', '    function supportsToken(address token) public constant returns (bool);\n', '\n', '    function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\n', '\n', '    function validateReserves() public view returns (bool);\n', '\n', '    function withdrawExcessReserves() public returns (uint256);\n', '\n', '    function initializeAfterTransfer() public returns (bool);\n', '\n', '    function initializeOnTransfer() public returns (bool);\n', '\n', '    function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Colu Local Currency + Market Maker factory contract.\n', '/// @author Rotem Lev.\n', 'contract CurrencyFactory is Standard223Receiver, TokenHolder {\n', '\n', '  struct CurrencyStruct {\n', '    string name;\n', '    uint8 decimals;\n', '    uint256 totalSupply;\n', '    address owner;\n', '    address mmAddress;\n', '  }\n', '\n', '\n', '  // map of Market Maker owners: token address => currency struct\n', '  mapping (address => CurrencyStruct) public currencyMap;\n', '  // address of the deployed CLN contract (ERC20 Token)\n', '  address public clnAddress;\n', '  // address of the deployed elipse market maker contract\n', '  address public mmLibAddress;\n', '\n', '  address[] public tokens;\n', '\n', '  event MarketOpen(address indexed marketMaker);\n', '  event TokenCreated(address indexed token, address indexed owner);\n', '\n', '  // modifier to check if called by issuer of the token\n', '  modifier tokenIssuerOnly(address token, address owner) {\n', '    require(currencyMap[token].owner == owner);\n', '    _;\n', '  }\n', '  // modifier to only accept transferAndCall from CLN token\n', '  modifier CLNOnly() {\n', '    require(msg.sender == clnAddress);\n', '    _;\n', '  }\n', '\n', '  /// @dev constructor only reuires the address of the CLN token which must use the ERC20 interface\n', '  /// @param _mmLib address for the deployed market maker elipse contract\n', '  /// @param _clnAddress address for the deployed ERC20 CLN token\n', '  function CurrencyFactory(address _mmLib, address _clnAddress) public {\n', '  \trequire(_mmLib != address(0));\n', '  \trequire(_clnAddress != address(0));\n', '  \tmmLibAddress = _mmLib;\n', '  \tclnAddress = _clnAddress;\n', '  }\n', '\n', '  /// @dev create the MarketMaker and the CC token put all the CC token in the Market Maker reserve\n', '  /// @param _name string name for CC token that is created.\n', '  /// @param _symbol string symbol for CC token that is created.\n', '  /// @param _decimals uint8 percison for CC token that is created.\n', '  /// @param _totalSupply uint256 total supply of the CC token that is created.\n', '  function createCurrency(string _name,\n', '                          string _symbol,\n', '                          uint8 _decimals,\n', '                          uint256 _totalSupply) public\n', '                          returns (address) {\n', '\n', '  \tColuLocalCurrency subToken = new ColuLocalCurrency(_name, _symbol, _decimals, _totalSupply);\n', '  \tEllipseMarketMaker newMarketMaker = new EllipseMarketMaker(mmLibAddress, clnAddress, subToken);\n', '  \t//set allowance\n', '  \trequire(subToken.transfer(newMarketMaker, _totalSupply));\n', '  \trequire(IEllipseMarketMaker(newMarketMaker).initializeAfterTransfer());\n', '  \tcurrencyMap[subToken] = CurrencyStruct({ name: _name, decimals: _decimals, totalSupply: _totalSupply, mmAddress: newMarketMaker, owner: msg.sender});\n', '    tokens.push(subToken);\n', '  \tTokenCreated(subToken, msg.sender);\n', '  \treturn subToken;\n', '  }\n', '\n', '  /// @dev normal send cln to the market maker contract, sender must approve() before calling method. can only be called by owner\n', '  /// @dev sending CLN will return CC from the reserve to the sender.\n', '  /// @param _token address address of the cc token managed by this factory.\n', '  /// @param _clnAmount uint256 amount of CLN to transfer into the Market Maker reserve.\n', '  function insertCLNtoMarketMaker(address _token,\n', '                                  uint256 _clnAmount) public\n', '                                  tokenIssuerOnly(_token, msg.sender)\n', '                                  returns (uint256 _subTokenAmount) {\n', '  \trequire(_clnAmount > 0);\n', '  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\n', '  \trequire(ERC20(clnAddress).transferFrom(msg.sender, this, _clnAmount));\n', '  \trequire(ERC20(clnAddress).approve(marketMakerAddress, _clnAmount));\n', '  \t_subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, _clnAmount, _token);\n', '    require(ERC20(_token).transfer(msg.sender, _subTokenAmount));\n', '  }\n', '\n', '  /// @dev ERC223 transferAndCall, send cln to the market maker contract can only be called by owner (see MarketMaker)\n', '  /// @dev sending CLN will return CC from the reserve to the sender.\n', '  /// @param _token address address of the cc token managed by this factory.\n', '  function insertCLNtoMarketMaker(address _token) public\n', '                                  tokenPayable\n', '                                  CLNOnly\n', '                                  tokenIssuerOnly(_token, tkn.sender)\n', '                                  returns (uint256 _subTokenAmount) {\n', '  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\n', '  \trequire(ERC20(clnAddress).approve(marketMakerAddress, tkn.value));\n', '  \t_subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, tkn.value, _token);\n', '    require(ERC20(_token).transfer(tkn.sender, _subTokenAmount));\n', '  }\n', '\n', '  /// @dev normal send cc to the market maker contract, sender must approve() before calling method. can only be called by owner\n', '  /// @dev sending CC will return CLN from the reserve to the sender.\n', '  /// @param _token address address of the cc token managed by this factory.\n', '  /// @param _ccAmount uint256 amount of CC to transfer into the Market Maker reserve.\n', '  function extractCLNfromMarketMaker(address _token,\n', '                                     uint256 _ccAmount) public\n', '                                     tokenIssuerOnly(_token, msg.sender)\n', '                                     returns (uint256 _clnTokenAmount) {\n', '  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\n', '  \trequire(ERC20(_token).transferFrom(msg.sender, this, _ccAmount));\n', '  \trequire(ERC20(_token).approve(marketMakerAddress, _ccAmount));\n', '  \t_clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(_token, _ccAmount, clnAddress);\n', '  \trequire(ERC20(clnAddress).transfer(msg.sender, _clnTokenAmount));\n', '  }\n', '\n', '  /// @dev ERC223 transferAndCall, send CC to the market maker contract can only be called by owner (see MarketMaker)\n', '  /// @dev sending CC will return CLN from the reserve to the sender.\n', '  function extractCLNfromMarketMaker() public\n', '                                    tokenPayable\n', '                                    tokenIssuerOnly(msg.sender, tkn.sender)\n', '                                    returns (uint256 _clnTokenAmount) {\n', '  \taddress marketMakerAddress = getMarketMakerAddressFromToken(msg.sender);\n', '  \trequire(ERC20(msg.sender).approve(marketMakerAddress, tkn.value));\n', '  \t_clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(msg.sender, tkn.value, clnAddress);\n', '  \trequire(ERC20(clnAddress).transfer(tkn.sender, _clnTokenAmount));\n', '  }\n', '\n', '  /// @dev opens the Market Maker to recvice transactions from all sources.\n', '  /// @dev Request to transfer ownership of Market Maker contract to Owner instead of factory.\n', '  /// @param _token address address of the cc token managed by this factory.\n', '  function openMarket(address _token) public\n', '                      tokenIssuerOnly(_token, msg.sender)\n', '                      returns (bool) {\n', '  \taddress marketMakerAddress = getMarketMakerAddressFromToken(_token);\n', '  \trequire(MarketMaker(marketMakerAddress).openForPublicTrade());\n', '  \tOwnable(marketMakerAddress).requestOwnershipTransfer(msg.sender);\n', '  \tMarketOpen(marketMakerAddress);\n', '  \treturn true;\n', '  }\n', '\n', '  /// @dev implementation for standard 223 reciver.\n', '  /// @param _token address of the token used with transferAndCall.\n', '  function supportsToken(address _token) public constant returns (bool) {\n', '  \treturn (clnAddress == _token || currencyMap[_token].totalSupply > 0);\n', '  }\n', '\n', '  /// @dev helper function to get the market maker address form token\n', '  /// @param _token address of the token used with transferAndCall.\n', '  function getMarketMakerAddressFromToken(address _token) public constant returns (address _marketMakerAddress) {\n', '  \t_marketMakerAddress = currencyMap[_token].mmAddress;\n', '    require(_marketMakerAddress != address(0));\n', '  }\n', '}']