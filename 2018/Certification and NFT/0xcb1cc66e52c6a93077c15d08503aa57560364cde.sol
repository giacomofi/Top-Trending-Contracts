['pragma solidity ^ 0.4.21;\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'interface ERC20 {\n', '  function balanceOf(address who) view returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  function allowance(address owner, address spender) view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'interface ERC223 {\n', '    function transfer(address to, uint value, bytes data) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract ERC223ReceivingContract { \n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', 'pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction Ownable()public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction transferOwnership(address newOwner)public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\tenum State {\n', '\t\tActive,\n', '\t\tRefunding,\n', '\t\tClosed\n', '\t}\n', '\n', '\tmapping(address => uint256)public deposited;\n', '\taddress public wallet;\n', '\tState public state;\n', '\n', '\tevent Closed();\n', '\tevent RefundsEnabled();\n', '\tevent Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '\t/**\n', '\t * @param _wallet Vault address\n', '\t */\n', '\tfunction RefundVault(address _wallet)public {\n', '\t\trequire(_wallet != address(0));\n', '\t\twallet = _wallet;\n', '\t\tstate = State.Active;\n', '\t}\n', '\n', '\t/**\n', '\t * @param investor Investor address\n', '\t */\n', '\tfunction deposit(address investor)onlyOwner public payable {\n', '\t\trequire(state == State.Active);\n', '\t\tdeposited[investor] = deposited[investor].add(msg.value);\n', '\t}\n', '\n', '\tfunction close()onlyOwner public {\n', '\t\trequire(state == State.Active);\n', '\t\tstate = State.Closed;\n', '\t\temit Closed();\n', '\t\twallet.transfer(address(this).balance);\n', '\t}\n', '\n', '\tfunction enableRefunds()onlyOwner public {\n', '\t\trequire(state == State.Active);\n', '\t\tstate = State.Refunding;\n', '\t\temit RefundsEnabled();\n', '\t}\n', '\n', '\t/**\n', '\t * @param investor Investor address\n', '\t */\n', '\tfunction refund(address investor)public {\n', '\t\trequire(state == State.Refunding);\n', '\t\tuint256 depositedValue = deposited[investor];\n', '\t\tdeposited[investor] = 0;\n', '\t\tinvestor.transfer(depositedValue);\n', '\t\temit Refunded(investor, depositedValue);\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title BonusScheme\n', ' * @dev This contract is used for storing and granting tokens calculated \n', ' * according to bonus scheme while a crowdsale is in progress.\n', ' * When crowdsale ends the rest of tokens is transferred to developers.\n', ' */\n', 'contract BonusScheme is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '\t* Defining timestamps for bonuscheme from White Paper. \n', '\t* The start of bonuses is 15 May 2018 and the end is 23 June 2018. \n', '\t* There are 2 seconds in between changing the phases.  */\n', '\tuint256 startOfFirstBonus = 1525892100;\n', '\tuint256 endOfFirstBonus = (startOfFirstBonus - 1) + 5 minutes;\t\n', '\tuint256 startOfSecondBonus = (startOfFirstBonus + 1) + 5 minutes;\n', '\tuint256 endOfSecondBonus = (startOfSecondBonus - 1) + 5 minutes;\n', '\tuint256 startOfThirdBonus = (startOfSecondBonus + 1) + 5 minutes;\n', '\tuint256 endOfThirdBonus = (startOfThirdBonus - 1) + 5 minutes;\n', '\tuint256 startOfFourthBonus = (startOfThirdBonus + 1) + 5 minutes;\n', '\tuint256 endOfFourthBonus = (startOfFourthBonus - 1) + 5 minutes;\n', '\tuint256 startOfFifthBonus = (startOfFourthBonus + 1) + 5 minutes;\n', '\tuint256 endOfFifthBonus = (startOfFifthBonus - 1) + 5 minutes;\n', '\t\n', '\t/**\n', '\t* Defining bonuses according to White Paper.\n', '\t* First week there is bonus 35%.\n', '\t* Second week there is bonus 30%.\n', '\t* Third week there is bonus 20%.\n', '\t* Fourth week there is bonus 10%.\n', '\t* Fifth week there is bonus 5%.\n', '\t*/\n', '\tuint256 firstBonus = 35;\n', '\tuint256 secondBonus = 30;\n', '\tuint256 thirdBonus = 20;\n', '\tuint256 fourthBonus = 10;\n', '\tuint256 fifthBonus = 5;\n', '\n', '\tevent BonusCalculated(uint256 tokenAmount);\n', '\n', '    function BonusScheme() public {\n', '        \n', '    }\n', '\n', '\t/**\n', '\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\n', '\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\n', '\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\n', '\t */\n', '\tfunction getBonusTokens(uint256 _tokenAmount)onlyOwner public returns(uint256) {\n', '\t\tif (block.timestamp >= startOfFirstBonus && block.timestamp <= endOfFirstBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfSecondBonus && block.timestamp <= endOfSecondBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfThirdBonus && block.timestamp <= endOfThirdBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFourthBonus && block.timestamp <= endOfFourthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFifthBonus && block.timestamp <= endOfFifthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\n', '\t\t} else _tokenAmount=0;\n', '\t\temit BonusCalculated(_tokenAmount);\n', '\t\treturn _tokenAmount;\n', '\t}\n', '}\n', '\n', 'contract StandardToken is ERC20, ERC223, Ownable {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring internal _name;\n', '\tstring internal _symbol;\n', '\tuint8 internal _decimals;\n', '\tuint256 internal _totalSupply;\n', '\tuint256 internal _bonusSupply;\n', '\n', '\tuint256 public ethRate; // How many token units a buyer gets per eth\n', '\tuint256 public min_contribution; // Minimal contribution in ICO\n', '\tuint256 public totalWeiRaised; // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We&#39;ll store the total ETH raised via our ICO here.\n', '\tuint public tokensSold; // the number of tokens already sold\n', '\n', '\tuint public softCap; //softcap in tokens\n', '\tuint public start; // the start date of the crowdsale\n', '\tuint public end; // the end date of the crowdsale\n', '\tbool public crowdsaleClosed; // indicates if the crowdsale has been closed already\n', '\tRefundVault public vault; // refund vault used to hold funds while crowdsale is running\n', '\tBonusScheme public bonusScheme; // contract used to hold and give tokens according to bonus scheme from white paper\n', '\n', '\taddress public fundsWallet; // Where should the raised ETH go?\n', '\n', '\tmapping(address => bool)public frozenAccount;\n', '\tmapping(address => uint256)internal balances;\n', '\tmapping(address => mapping(address => uint256))internal allowed;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\tevent FrozenFunds(address target, bool frozen);\n', '\tevent Finalized();\n', '\tevent BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens);\n', '\n', '\t/**\n', '\t * Event for token purchase logging\n', '\t * @param purchaser who paid for the tokens\n', '\t * @param beneficiary who got the tokens\n', '\t * @param value weis paid for purchase\n', '\t * @param amount of tokens purchased\n', '\t */\n', '\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\t//TODO: correction of smart contract balance of tokens //done\n', '\t//TODO: change symbol and name of token\n', '\t//TODO: change start and end timestamps\n', '\tfunction StandardToken()public {\n', '\t\t_symbol = "AmTC1";\n', '\t\t_name = "AmTokenTestCase1";\n', '\t\t_decimals = 5;\n', '\t\t_totalSupply = 1100000 * (10 ** uint256(_decimals));\n', '\t\t//_creatorSupply = _totalSupply * 25 / 100; \t\t\t// The creator has 25% of tokens\n', '\t\t//_icoSupply = _totalSupply * 58 / 100; \t\t\t\t// Smart contract balance is 58% of tokens (638 000 tokens)\n', '\t\t_bonusSupply = _totalSupply * 17 / 100; // The Bonus scheme supply is 17% (187 000 tokens)\n', '\t\t\n', '\t\tfundsWallet = msg.sender; // The owner of the contract gets ETH\n', '\t\tvault = new RefundVault(fundsWallet);\n', '\t\tbonusScheme = new BonusScheme();\n', '\n', '\t\t//balances[this] = _icoSupply;          \t\t\t\t// Token balance to smart contract will be added manually from owners wallet\n', '\t\tbalances[msg.sender] = _totalSupply.sub(_bonusSupply);\n', '\t\tbalances[bonusScheme] = _bonusSupply;\n', '\t\tethRate = 40000000; // Set the rate of token to ether exchange for the ICO\n', '\t\tmin_contribution = 1 ether / (10**11); // 0.1 ETH is minimum deposit\n', '\t\ttotalWeiRaised = 0;\n', '\t\ttokensSold = 0;\n', '\t\tsoftCap = 20000 * 10 ** uint(_decimals);\n', '\t\tstart = 1525891800;\n', '\t\tend = 1525893600;\n', '\t\tcrowdsaleClosed = false;\n', '\t}\n', '\n', '\tmodifier beforeICO() {\n', '\t\trequire(block.timestamp <= start);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier afterDeadline() {\n', '\t\trequire(block.timestamp > end);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction name()\n', '\tpublic\n', '\tview\n', '\treturns(string) {\n', '\t\treturn _name;\n', '\t}\n', '\n', '\tfunction symbol()\n', '\tpublic\n', '\tview\n', '\treturns(string) {\n', '\t\treturn _symbol;\n', '\t}\n', '\n', '\tfunction decimals()\n', '\tpublic\n', '\tview\n', '\treturns(uint8) {\n', '\t\treturn _decimals;\n', '\t}\n', '\n', '\tfunction totalSupply()\n', '\tpublic\n', '\tview\n', '\treturns(uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale external interface\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @dev fallback function ***DO NOT OVERRIDE***\n', '\t */\n', '\tfunction ()external payable {\n', '\t\tbuyTokens(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev low level token purchase ***DO NOT OVERRIDE***\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t */\n', '\t//bad calculations, change  //should be ok\n', '\t//TODO: pre-ico phase to be defined and checked with other tokens, ICO-when closed check softcap, softcap-add pre-ico tokens, if isnt achieved revert all transactions, hardcap, timestamps&bonus scheme(will be discussed next week), minimum amount is 0,1ETH ...\n', '\tfunction buyTokens(address _beneficiary)public payable {\n', '\t\tuint256 weiAmount = msg.value;\n', '\t\t_preValidatePurchase(_beneficiary, weiAmount);\n', '\t\tuint256 tokens = _getTokenAmount(weiAmount); // calculate token amount to be sold\n', '\t\trequire(balances[this] > tokens); //check if the contract has enough tokens\n', '\n', '\t\ttotalWeiRaised = totalWeiRaised.add(weiAmount); //update state\n', '\t\ttokensSold = tokensSold.add(tokens); //update state\n', '\n', '\t\t_processPurchase(_beneficiary, tokens);\n', '\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\t\t_processBonus(_beneficiary, tokens);\n', '\n', '\t\t_updatePurchasingState(_beneficiary, weiAmount);\n', '\n', '\t\t_forwardFunds();\n', '\t\t_postValidatePurchase(_beneficiary, weiAmount);\n', '\n', '\t\t/*\n', '\t\tbalances[this] = balances[this].sub(weiAmount);\n', '\t\tbalances[_beneficiary] = balances[_beneficiary].add(weiAmount);\n', '\n', '\t\temit Transfer(this, _beneficiary, weiAmount); \t\t\t\t\t// Broadcast a message to the blockchain\n', '\t\t */\n', '\n', '\t}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale internal interface (extensible)\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount)internal view {\n', '\t\trequire(_beneficiary != address(0));\n', '\t\trequire(_weiAmount >= min_contribution);\n', '\t\trequire(!crowdsaleClosed && block.timestamp >= start && block.timestamp <= end);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _postValidatePurchase(address _beneficiary, uint256 _weiAmount)internal pure {\n', '\t\t// optional override\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _tokenAmount Number of tokens to be emitted\n', '\t */\n', '\tfunction _deliverTokens(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\tthis.transfer(_beneficiary, _tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _tokenAmount Number of tokens to be purchased\n', '\t */\n', '\tfunction _processPurchase(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\t_deliverTokens(_beneficiary, _tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Executed when a purchase has been validated and bonus tokens need to be calculated. Not necessarily emits/sends bonus tokens.\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _tokenAmount Number of tokens from which is calculated bonus amount\n', '\t */\n', '\tfunction _processBonus(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\tuint256 bonusTokens = bonusScheme.getBonusTokens(_tokenAmount); // Calculate bonus token amount\n', '\t\tif (balances[bonusScheme] < bonusTokens) { // If the bonus scheme does not have enough tokens, send all remaining\n', '\t\t\tbonusTokens = balances[bonusScheme];\n', '\t\t\tbalances[bonusScheme] = 0;\n', '\t\t}\n', '\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\n', '\t\t\tbalances[bonusScheme] = balances[bonusScheme].sub(bonusTokens);\n', '\t\t\tbalances[_beneficiary] = balances[_beneficiary].add(bonusTokens);\n', '\t\t\temit Transfer(address(bonusScheme), _beneficiary, bonusTokens);\n', '\t\t\temit BonusSent(address(bonusScheme), _beneficiary, _tokenAmount, bonusTokens);\n', '\t\t\ttokensSold = tokensSold.add(bonusTokens); // update state\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _updatePurchasingState(address _beneficiary, uint256 _weiAmount)internal {\n', '\t\t// optional override\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Override to extend the way in which ether is converted to tokens.\n', '\t * @param _weiAmount Value in wei to be converted into tokens\n', '\t * @return Number of tokens that can be purchased with the specified _weiAmount\n', '\t */\n', '\tfunction _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {\n', '\t\t_weiAmount = _weiAmount.mul(ethRate);\n', '\t\treturn _weiAmount.div(10 ** uint(18 - _decimals)); //as we have other decimals number than standard 18, we need to calculate\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Determines how ETH is stored/forwarded on purchases, sending funds to vault.\n', '\t */\n', '\tfunction _forwardFunds()internal {\n', '\t\tvault.deposit.value(msg.value)(msg.sender); //Transfer ether to vault\n', '\t}\n', '\n', '\t///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! bad function, refactor   //should be solved now\n', '\t//standard function transfer similar to ERC20 transfer with no _data\n', '\t//added due to backwards compatibility reasons\n', '\tfunction transfer(address _to, uint256 _value)public returns(bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\t//require(!isContract(_to));\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner)public view returns(uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\t//standard function transferFrom similar to ERC20 transferFrom with no _data\n', '\t//added due to backwards compatibility reasons\n', '\tfunction transferFrom(address _from, address _to, uint256 _value)public returns(bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(!frozenAccount[_from]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\trequire(_value <= balances[_from]);\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction approve(address _spender, uint256 _value)public returns(bool) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowance(address _owner, address _spender)public view returns(uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\tfunction increaseApproval(address _spender, uint _addedValue)public returns(bool) {\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue)public returns(bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\n', '\t\t}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Function that is called when a user or another contract wants to transfer funds .    ///add trasnfertocontractwithcustomfallback  //done\n', '\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public returns(bool success) {\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t}\n', '\n', '\t// Function that is called when a user or another contract wants to transfer funds .\n', '\tfunction transfer(address _to, uint _value, bytes _data)public returns(bool) {\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContract(_to, _value, _data);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t\t/*\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_value > 0 && _value <= balances[msg.sender]);\n', '\t\tif(isContract(_to)) {\n', '\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '\t\treceiver.tokenFallback(msg.sender, _value, _data);\n', '\t\treturn true;\n', '\t\t}\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\t */\n', '\t}\n', '\n', '\tfunction isContract(address _addr)private view returns(bool is_contract) {\n', '\t\tuint length;\n', '\t\tassembly {\n', '\t\t\t//retrieve the size of the code on target address, this needs assembly\n', '\t\t\tlength := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (length > 0);\n', '\t}\n', '\n', '\t//function that is called when transaction target is an address\n', '\tfunction transferToAddress(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//function that is called when transaction target is a contract\n', '\tfunction transferToContract(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '\t\treceiver.tokenFallback(msg.sender, _value, _data);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//function that is called when transaction target is a contract with custom fallback\n', '\tfunction transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei)onlyOwner beforeICO public {\n', '\t\ttokensSold = tokensSold.add(_soldTokens);\n', '\t\ttotalWeiRaised = totalWeiRaised.add(_raisedWei);\n', '\t}\n', '\t\n', '\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '\t/// @param target Address to be frozen\n', '\t/// @param freeze either to freeze it or not\n', '\tfunction freezeAccount(address target, bool freeze)onlyOwner public {\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\temit FrozenFunds(target, freeze);\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly\n', '\t *\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value)onlyOwner public returns(bool success) {\n', '\t\trequire(balances[msg.sender] >= _value); // Check if the sender has enough\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value); // Subtract from the sender\n', '\t\t_totalSupply = _totalSupply.sub(_value); // Updates totalSupply\n', '\t\temit Burn(msg.sender, _value);\n', '\t\temit Transfer(msg.sender, address(0), _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* NOT NEEDED as ethers are in vault\n', '\t//check the functionality\n', '\t// @notice Failsafe drain\n', '\tfunction withdrawEther()onlyOwner public returns(bool) {\n', '\towner.transfer(address(this).balance);\n', '\treturn true;\n', '\t}\n', '\t */\n', '\n', '\t// @notice Failsafe transfer tokens for the team to given account\n', '\tfunction withdrawTokens()onlyOwner public returns(bool) {\n', '\t\trequire(this.transfer(owner, balances[this]));\n', '\t\tuint256 bonusTokens = balances[address(bonusScheme)];\n', '\t\tbalances[address(bonusScheme)] = 0;\n', '\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\n', '\t\t\tbalances[owner] = balances[owner].add(bonusTokens);\n', '\t\t\temit Transfer(address(bonusScheme), owner, bonusTokens);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\n', '\t * @param _tokenAddress The address of the ERC20 contract.\n', '\t * @param _amount The amount of tokens to be transferred.\n', '\t */\n', '\tfunction transferAnyERC20Token(address _tokenAddress, uint256 _amount)onlyOwner public returns(bool success) {\n', '\t\treturn ERC20(_tokenAddress).transfer(owner, _amount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Investors can claim refunds here if crowdsale is unsuccessful\n', '\t */\n', '\tfunction claimRefund()public {\n', '\t\trequire(crowdsaleClosed);\n', '\t\trequire(!goalReached());\n', '\n', '\t\tvault.refund(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks whether funding goal was reached.\n', '\t * @return Whether funding goal was reached\n', '\t */\n', '\tfunction goalReached()public view returns(bool) {\n', '\t\treturn tokensSold >= softCap;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev vault finalization task, called when owner calls finalize()\n', '\t */\n', '\tfunction finalization()internal {\n', '\t\tif (goalReached()) {\n', '\t\t\tvault.close();\n', '\t\t} else {\n', '\t\t\tvault.enableRefunds();\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Must be called after crowdsale ends, to do some extra finalization\n', '\t * work. Calls the contract&#39;s finalization function.\n', '\t */\n', '\tfunction finalize()onlyOwner afterDeadline public {\n', '\t\trequire(!crowdsaleClosed);\n', '\n', '\t\tfinalization();\n', '\t\temit Finalized();\n', '\t\twithdrawTokens();\n', '\n', '\t\tcrowdsaleClosed = true;\n', '\t}\n', '\n', '}']
['pragma solidity ^ 0.4.21;\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'interface ERC20 {\n', '  function balanceOf(address who) view returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  function allowance(address owner, address spender) view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'interface ERC223 {\n', '    function transfer(address to, uint value, bytes data) returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract ERC223ReceivingContract { \n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', 'pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tfunction Ownable()public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction transferOwnership(address newOwner)public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title RefundVault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract RefundVault is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\tenum State {\n', '\t\tActive,\n', '\t\tRefunding,\n', '\t\tClosed\n', '\t}\n', '\n', '\tmapping(address => uint256)public deposited;\n', '\taddress public wallet;\n', '\tState public state;\n', '\n', '\tevent Closed();\n', '\tevent RefundsEnabled();\n', '\tevent Refunded(address indexed beneficiary, uint256 weiAmount);\n', '\n', '\t/**\n', '\t * @param _wallet Vault address\n', '\t */\n', '\tfunction RefundVault(address _wallet)public {\n', '\t\trequire(_wallet != address(0));\n', '\t\twallet = _wallet;\n', '\t\tstate = State.Active;\n', '\t}\n', '\n', '\t/**\n', '\t * @param investor Investor address\n', '\t */\n', '\tfunction deposit(address investor)onlyOwner public payable {\n', '\t\trequire(state == State.Active);\n', '\t\tdeposited[investor] = deposited[investor].add(msg.value);\n', '\t}\n', '\n', '\tfunction close()onlyOwner public {\n', '\t\trequire(state == State.Active);\n', '\t\tstate = State.Closed;\n', '\t\temit Closed();\n', '\t\twallet.transfer(address(this).balance);\n', '\t}\n', '\n', '\tfunction enableRefunds()onlyOwner public {\n', '\t\trequire(state == State.Active);\n', '\t\tstate = State.Refunding;\n', '\t\temit RefundsEnabled();\n', '\t}\n', '\n', '\t/**\n', '\t * @param investor Investor address\n', '\t */\n', '\tfunction refund(address investor)public {\n', '\t\trequire(state == State.Refunding);\n', '\t\tuint256 depositedValue = deposited[investor];\n', '\t\tdeposited[investor] = 0;\n', '\t\tinvestor.transfer(depositedValue);\n', '\t\temit Refunded(investor, depositedValue);\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title BonusScheme\n', ' * @dev This contract is used for storing and granting tokens calculated \n', ' * according to bonus scheme while a crowdsale is in progress.\n', ' * When crowdsale ends the rest of tokens is transferred to developers.\n', ' */\n', 'contract BonusScheme is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '\t* Defining timestamps for bonuscheme from White Paper. \n', '\t* The start of bonuses is 15 May 2018 and the end is 23 June 2018. \n', '\t* There are 2 seconds in between changing the phases.  */\n', '\tuint256 startOfFirstBonus = 1525892100;\n', '\tuint256 endOfFirstBonus = (startOfFirstBonus - 1) + 5 minutes;\t\n', '\tuint256 startOfSecondBonus = (startOfFirstBonus + 1) + 5 minutes;\n', '\tuint256 endOfSecondBonus = (startOfSecondBonus - 1) + 5 minutes;\n', '\tuint256 startOfThirdBonus = (startOfSecondBonus + 1) + 5 minutes;\n', '\tuint256 endOfThirdBonus = (startOfThirdBonus - 1) + 5 minutes;\n', '\tuint256 startOfFourthBonus = (startOfThirdBonus + 1) + 5 minutes;\n', '\tuint256 endOfFourthBonus = (startOfFourthBonus - 1) + 5 minutes;\n', '\tuint256 startOfFifthBonus = (startOfFourthBonus + 1) + 5 minutes;\n', '\tuint256 endOfFifthBonus = (startOfFifthBonus - 1) + 5 minutes;\n', '\t\n', '\t/**\n', '\t* Defining bonuses according to White Paper.\n', '\t* First week there is bonus 35%.\n', '\t* Second week there is bonus 30%.\n', '\t* Third week there is bonus 20%.\n', '\t* Fourth week there is bonus 10%.\n', '\t* Fifth week there is bonus 5%.\n', '\t*/\n', '\tuint256 firstBonus = 35;\n', '\tuint256 secondBonus = 30;\n', '\tuint256 thirdBonus = 20;\n', '\tuint256 fourthBonus = 10;\n', '\tuint256 fifthBonus = 5;\n', '\n', '\tevent BonusCalculated(uint256 tokenAmount);\n', '\n', '    function BonusScheme() public {\n', '        \n', '    }\n', '\n', '\t/**\n', '\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\n', '\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\n', '\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\n', '\t */\n', '\tfunction getBonusTokens(uint256 _tokenAmount)onlyOwner public returns(uint256) {\n', '\t\tif (block.timestamp >= startOfFirstBonus && block.timestamp <= endOfFirstBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfSecondBonus && block.timestamp <= endOfSecondBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfThirdBonus && block.timestamp <= endOfThirdBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFourthBonus && block.timestamp <= endOfFourthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFifthBonus && block.timestamp <= endOfFifthBonus) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\n', '\t\t} else _tokenAmount=0;\n', '\t\temit BonusCalculated(_tokenAmount);\n', '\t\treturn _tokenAmount;\n', '\t}\n', '}\n', '\n', 'contract StandardToken is ERC20, ERC223, Ownable {\n', '\tusing SafeMath for uint;\n', '\n', '\tstring internal _name;\n', '\tstring internal _symbol;\n', '\tuint8 internal _decimals;\n', '\tuint256 internal _totalSupply;\n', '\tuint256 internal _bonusSupply;\n', '\n', '\tuint256 public ethRate; // How many token units a buyer gets per eth\n', '\tuint256 public min_contribution; // Minimal contribution in ICO\n', "\tuint256 public totalWeiRaised; // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.\n", '\tuint public tokensSold; // the number of tokens already sold\n', '\n', '\tuint public softCap; //softcap in tokens\n', '\tuint public start; // the start date of the crowdsale\n', '\tuint public end; // the end date of the crowdsale\n', '\tbool public crowdsaleClosed; // indicates if the crowdsale has been closed already\n', '\tRefundVault public vault; // refund vault used to hold funds while crowdsale is running\n', '\tBonusScheme public bonusScheme; // contract used to hold and give tokens according to bonus scheme from white paper\n', '\n', '\taddress public fundsWallet; // Where should the raised ETH go?\n', '\n', '\tmapping(address => bool)public frozenAccount;\n', '\tmapping(address => uint256)internal balances;\n', '\tmapping(address => mapping(address => uint256))internal allowed;\n', '\n', '\t/* This generates a public event on the blockchain that will notify clients */\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\tevent FrozenFunds(address target, bool frozen);\n', '\tevent Finalized();\n', '\tevent BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens);\n', '\n', '\t/**\n', '\t * Event for token purchase logging\n', '\t * @param purchaser who paid for the tokens\n', '\t * @param beneficiary who got the tokens\n', '\t * @param value weis paid for purchase\n', '\t * @param amount of tokens purchased\n', '\t */\n', '\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\t//TODO: correction of smart contract balance of tokens //done\n', '\t//TODO: change symbol and name of token\n', '\t//TODO: change start and end timestamps\n', '\tfunction StandardToken()public {\n', '\t\t_symbol = "AmTC1";\n', '\t\t_name = "AmTokenTestCase1";\n', '\t\t_decimals = 5;\n', '\t\t_totalSupply = 1100000 * (10 ** uint256(_decimals));\n', '\t\t//_creatorSupply = _totalSupply * 25 / 100; \t\t\t// The creator has 25% of tokens\n', '\t\t//_icoSupply = _totalSupply * 58 / 100; \t\t\t\t// Smart contract balance is 58% of tokens (638 000 tokens)\n', '\t\t_bonusSupply = _totalSupply * 17 / 100; // The Bonus scheme supply is 17% (187 000 tokens)\n', '\t\t\n', '\t\tfundsWallet = msg.sender; // The owner of the contract gets ETH\n', '\t\tvault = new RefundVault(fundsWallet);\n', '\t\tbonusScheme = new BonusScheme();\n', '\n', '\t\t//balances[this] = _icoSupply;          \t\t\t\t// Token balance to smart contract will be added manually from owners wallet\n', '\t\tbalances[msg.sender] = _totalSupply.sub(_bonusSupply);\n', '\t\tbalances[bonusScheme] = _bonusSupply;\n', '\t\tethRate = 40000000; // Set the rate of token to ether exchange for the ICO\n', '\t\tmin_contribution = 1 ether / (10**11); // 0.1 ETH is minimum deposit\n', '\t\ttotalWeiRaised = 0;\n', '\t\ttokensSold = 0;\n', '\t\tsoftCap = 20000 * 10 ** uint(_decimals);\n', '\t\tstart = 1525891800;\n', '\t\tend = 1525893600;\n', '\t\tcrowdsaleClosed = false;\n', '\t}\n', '\n', '\tmodifier beforeICO() {\n', '\t\trequire(block.timestamp <= start);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tmodifier afterDeadline() {\n', '\t\trequire(block.timestamp > end);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction name()\n', '\tpublic\n', '\tview\n', '\treturns(string) {\n', '\t\treturn _name;\n', '\t}\n', '\n', '\tfunction symbol()\n', '\tpublic\n', '\tview\n', '\treturns(string) {\n', '\t\treturn _symbol;\n', '\t}\n', '\n', '\tfunction decimals()\n', '\tpublic\n', '\tview\n', '\treturns(uint8) {\n', '\t\treturn _decimals;\n', '\t}\n', '\n', '\tfunction totalSupply()\n', '\tpublic\n', '\tview\n', '\treturns(uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale external interface\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @dev fallback function ***DO NOT OVERRIDE***\n', '\t */\n', '\tfunction ()external payable {\n', '\t\tbuyTokens(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev low level token purchase ***DO NOT OVERRIDE***\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t */\n', '\t//bad calculations, change  //should be ok\n', '\t//TODO: pre-ico phase to be defined and checked with other tokens, ICO-when closed check softcap, softcap-add pre-ico tokens, if isnt achieved revert all transactions, hardcap, timestamps&bonus scheme(will be discussed next week), minimum amount is 0,1ETH ...\n', '\tfunction buyTokens(address _beneficiary)public payable {\n', '\t\tuint256 weiAmount = msg.value;\n', '\t\t_preValidatePurchase(_beneficiary, weiAmount);\n', '\t\tuint256 tokens = _getTokenAmount(weiAmount); // calculate token amount to be sold\n', '\t\trequire(balances[this] > tokens); //check if the contract has enough tokens\n', '\n', '\t\ttotalWeiRaised = totalWeiRaised.add(weiAmount); //update state\n', '\t\ttokensSold = tokensSold.add(tokens); //update state\n', '\n', '\t\t_processPurchase(_beneficiary, tokens);\n', '\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\t\t_processBonus(_beneficiary, tokens);\n', '\n', '\t\t_updatePurchasingState(_beneficiary, weiAmount);\n', '\n', '\t\t_forwardFunds();\n', '\t\t_postValidatePurchase(_beneficiary, weiAmount);\n', '\n', '\t\t/*\n', '\t\tbalances[this] = balances[this].sub(weiAmount);\n', '\t\tbalances[_beneficiary] = balances[_beneficiary].add(weiAmount);\n', '\n', '\t\temit Transfer(this, _beneficiary, weiAmount); \t\t\t\t\t// Broadcast a message to the blockchain\n', '\t\t */\n', '\n', '\t}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale internal interface (extensible)\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount)internal view {\n', '\t\trequire(_beneficiary != address(0));\n', '\t\trequire(_weiAmount >= min_contribution);\n', '\t\trequire(!crowdsaleClosed && block.timestamp >= start && block.timestamp <= end);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _postValidatePurchase(address _beneficiary, uint256 _weiAmount)internal pure {\n', '\t\t// optional override\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _tokenAmount Number of tokens to be emitted\n', '\t */\n', '\tfunction _deliverTokens(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\tthis.transfer(_beneficiary, _tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _tokenAmount Number of tokens to be purchased\n', '\t */\n', '\tfunction _processPurchase(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\t_deliverTokens(_beneficiary, _tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Executed when a purchase has been validated and bonus tokens need to be calculated. Not necessarily emits/sends bonus tokens.\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _tokenAmount Number of tokens from which is calculated bonus amount\n', '\t */\n', '\tfunction _processBonus(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\tuint256 bonusTokens = bonusScheme.getBonusTokens(_tokenAmount); // Calculate bonus token amount\n', '\t\tif (balances[bonusScheme] < bonusTokens) { // If the bonus scheme does not have enough tokens, send all remaining\n', '\t\t\tbonusTokens = balances[bonusScheme];\n', '\t\t\tbalances[bonusScheme] = 0;\n', '\t\t}\n', '\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\n', '\t\t\tbalances[bonusScheme] = balances[bonusScheme].sub(bonusTokens);\n', '\t\t\tbalances[_beneficiary] = balances[_beneficiary].add(bonusTokens);\n', '\t\t\temit Transfer(address(bonusScheme), _beneficiary, bonusTokens);\n', '\t\t\temit BonusSent(address(bonusScheme), _beneficiary, _tokenAmount, bonusTokens);\n', '\t\t\ttokensSold = tokensSold.add(bonusTokens); // update state\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _updatePurchasingState(address _beneficiary, uint256 _weiAmount)internal {\n', '\t\t// optional override\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Override to extend the way in which ether is converted to tokens.\n', '\t * @param _weiAmount Value in wei to be converted into tokens\n', '\t * @return Number of tokens that can be purchased with the specified _weiAmount\n', '\t */\n', '\tfunction _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {\n', '\t\t_weiAmount = _weiAmount.mul(ethRate);\n', '\t\treturn _weiAmount.div(10 ** uint(18 - _decimals)); //as we have other decimals number than standard 18, we need to calculate\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Determines how ETH is stored/forwarded on purchases, sending funds to vault.\n', '\t */\n', '\tfunction _forwardFunds()internal {\n', '\t\tvault.deposit.value(msg.value)(msg.sender); //Transfer ether to vault\n', '\t}\n', '\n', '\t///!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! bad function, refactor   //should be solved now\n', '\t//standard function transfer similar to ERC20 transfer with no _data\n', '\t//added due to backwards compatibility reasons\n', '\tfunction transfer(address _to, uint256 _value)public returns(bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_value <= balances[msg.sender]);\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\t//require(!isContract(_to));\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction balanceOf(address _owner)public view returns(uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '\t//standard function transferFrom similar to ERC20 transferFrom with no _data\n', '\t//added due to backwards compatibility reasons\n', '\tfunction transferFrom(address _from, address _to, uint256 _value)public returns(bool) {\n', '\t\trequire(_to != address(0));\n', '\t\trequire(!frozenAccount[_from]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\trequire(_value <= balances[_from]);\n', '\t\trequire(_value <= allowed[_from][msg.sender]);\n', '\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction approve(address _spender, uint256 _value)public returns(bool) {\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\temit Approval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowance(address _owner, address _spender)public view returns(uint256) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\tfunction increaseApproval(address _spender, uint _addedValue)public returns(bool) {\n', '\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue)public returns(bool) {\n', '\t\tuint oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\n', '\t\t}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Function that is called when a user or another contract wants to transfer funds .    ///add trasnfertocontractwithcustomfallback  //done\n', '\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public returns(bool success) {\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t}\n', '\n', '\t// Function that is called when a user or another contract wants to transfer funds .\n', '\tfunction transfer(address _to, uint _value, bytes _data)public returns(bool) {\n', '\t\trequire(!frozenAccount[msg.sender]); // Check if sender is frozen\n', '\t\trequire(!frozenAccount[_to]); // Check if recipient is frozen\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContract(_to, _value, _data);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t\t/*\n', '\t\trequire(_to != address(0));\n', '\t\trequire(_value > 0 && _value <= balances[msg.sender]);\n', '\t\tif(isContract(_to)) {\n', '\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '\t\treceiver.tokenFallback(msg.sender, _value, _data);\n', '\t\treturn true;\n', '\t\t}\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\t */\n', '\t}\n', '\n', '\tfunction isContract(address _addr)private view returns(bool is_contract) {\n', '\t\tuint length;\n', '\t\tassembly {\n', '\t\t\t//retrieve the size of the code on target address, this needs assembly\n', '\t\t\tlength := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (length > 0);\n', '\t}\n', '\n', '\t//function that is called when transaction target is an address\n', '\tfunction transferToAddress(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//function that is called when transaction target is a contract\n', '\tfunction transferToContract(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '\t\treceiver.tokenFallback(msg.sender, _value, _data);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t//function that is called when transaction target is a contract with custom fallback\n', '\tfunction transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback)private returns(bool success) {\n', '\t\trequire(balanceOf(msg.sender) > _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei)onlyOwner beforeICO public {\n', '\t\ttokensSold = tokensSold.add(_soldTokens);\n', '\t\ttotalWeiRaised = totalWeiRaised.add(_raisedWei);\n', '\t}\n', '\t\n', '\t/// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '\t/// @param target Address to be frozen\n', '\t/// @param freeze either to freeze it or not\n', '\tfunction freezeAccount(address target, bool freeze)onlyOwner public {\n', '\t\tfrozenAccount[target] = freeze;\n', '\t\temit FrozenFunds(target, freeze);\n', '\t}\n', '\n', '\t/**\n', '\t * Destroy tokens\n', '\t *\n', '\t * Remove `_value` tokens from the system irreversibly\n', '\t *\n', '\t * @param _value the amount of money to burn\n', '\t */\n', '\tfunction burn(uint256 _value)onlyOwner public returns(bool success) {\n', '\t\trequire(balances[msg.sender] >= _value); // Check if the sender has enough\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value); // Subtract from the sender\n', '\t\t_totalSupply = _totalSupply.sub(_value); // Updates totalSupply\n', '\t\temit Burn(msg.sender, _value);\n', '\t\temit Transfer(msg.sender, address(0), _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* NOT NEEDED as ethers are in vault\n', '\t//check the functionality\n', '\t// @notice Failsafe drain\n', '\tfunction withdrawEther()onlyOwner public returns(bool) {\n', '\towner.transfer(address(this).balance);\n', '\treturn true;\n', '\t}\n', '\t */\n', '\n', '\t// @notice Failsafe transfer tokens for the team to given account\n', '\tfunction withdrawTokens()onlyOwner public returns(bool) {\n', '\t\trequire(this.transfer(owner, balances[this]));\n', '\t\tuint256 bonusTokens = balances[address(bonusScheme)];\n', '\t\tbalances[address(bonusScheme)] = 0;\n', '\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\n', '\t\t\tbalances[owner] = balances[owner].add(bonusTokens);\n', '\t\t\temit Transfer(address(bonusScheme), owner, bonusTokens);\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\n', '\t * @param _tokenAddress The address of the ERC20 contract.\n', '\t * @param _amount The amount of tokens to be transferred.\n', '\t */\n', '\tfunction transferAnyERC20Token(address _tokenAddress, uint256 _amount)onlyOwner public returns(bool success) {\n', '\t\treturn ERC20(_tokenAddress).transfer(owner, _amount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Investors can claim refunds here if crowdsale is unsuccessful\n', '\t */\n', '\tfunction claimRefund()public {\n', '\t\trequire(crowdsaleClosed);\n', '\t\trequire(!goalReached());\n', '\n', '\t\tvault.refund(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Checks whether funding goal was reached.\n', '\t * @return Whether funding goal was reached\n', '\t */\n', '\tfunction goalReached()public view returns(bool) {\n', '\t\treturn tokensSold >= softCap;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev vault finalization task, called when owner calls finalize()\n', '\t */\n', '\tfunction finalization()internal {\n', '\t\tif (goalReached()) {\n', '\t\t\tvault.close();\n', '\t\t} else {\n', '\t\t\tvault.enableRefunds();\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Must be called after crowdsale ends, to do some extra finalization\n', "\t * work. Calls the contract's finalization function.\n", '\t */\n', '\tfunction finalize()onlyOwner afterDeadline public {\n', '\t\trequire(!crowdsaleClosed);\n', '\n', '\t\tfinalization();\n', '\t\temit Finalized();\n', '\t\twithdrawTokens();\n', '\n', '\t\tcrowdsaleClosed = true;\n', '\t}\n', '\n', '}']
