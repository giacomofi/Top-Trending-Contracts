['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require((msg.sender == owner) || (tx.origin == owner));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/Bonus.sol\n', '\n', 'contract Bonus is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) public buyerBonus;\n', '    mapping(address => bool) hasBought;\n', '    address[] public buyerList;\n', '    \n', '    function _addBonus(address _beneficiary, uint256 _bonus) internal {\n', '        if(hasBought[_beneficiary]){\n', '            buyerBonus[_beneficiary] = buyerBonus[_beneficiary].add(_bonus);\n', '        } else {\n', '            hasBought[_beneficiary] = true;\n', '            buyerList.push(_beneficiary);\n', '            buyerBonus[_beneficiary] = _bonus;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/ERC20Basic.sol\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/ERC20.sol\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/CrowdSale.sol\n', '\n', 'contract Crowdsale is Bonus {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    ERC20 public token;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // ICO exchange rate\n', '    uint256 public rate;\n', '\n', '    // ICO Time\n', '    uint256 public openingTimePeriodOne;\n', '    uint256 public closingTimePeriodOne;\n', '    uint256 public openingTimePeriodTwo;\n', '    uint256 public closingTimePeriodTwo;\n', '    uint256 public bonusDeliverTime;\n', '\n', '    // Diff bonus rate decided by time\n', '    uint256 public bonusRatePrivateSale;\n', '    uint256 public bonusRatePeriodOne;\n', '    uint256 public bonusRatePeriodTwo;\n', '\n', '    // Token decimal\n', '    uint256 decimals;\n', '    uint256 public tokenUnsold;\n', '    uint256 public bonusUnsold;\n', '    uint256 public constant minPurchaseAmount = 0.1 ether;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus);\n', '\n', '    modifier onlyWhileOpen {\n', '        require(block.timestamp <= closingTimePeriodTwo);\n', '        _;\n', '    }\n', '\n', '    constructor (uint256 _openingTimePeriodOne, uint256 _closingTimePeriodOne, uint256 _openingTimePeriodTwo, uint256 _closingTimePeriodTwo, uint256 _bonusDeliverTime,\n', '        uint256 _rate, uint256 _bonusRatePrivateSale, uint256 _bonusRatePeriodOne, uint256 _bonusRatePeriodTwo, \n', '        address _wallet, ERC20 _token, uint256 _decimals, uint256 _tokenUnsold, uint256 _bonusUnsold) public {\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '        require(_openingTimePeriodOne >= block.timestamp);\n', '        require(_closingTimePeriodOne >= _openingTimePeriodOne);\n', '        require(_openingTimePeriodTwo >= _closingTimePeriodOne);\n', '        require(_closingTimePeriodTwo >= _openingTimePeriodTwo);\n', '\n', '        wallet = _wallet;\n', '        token = _token;\n', '        openingTimePeriodOne = _openingTimePeriodOne;\n', '        closingTimePeriodOne = _closingTimePeriodOne;\n', '        openingTimePeriodTwo = _openingTimePeriodTwo;\n', '        closingTimePeriodTwo = _closingTimePeriodTwo;\n', '        bonusDeliverTime = _bonusDeliverTime;\n', '        rate = _rate;\n', '        bonusRatePrivateSale = _bonusRatePrivateSale;\n', '        bonusRatePeriodOne = _bonusRatePeriodOne;\n', '        bonusRatePeriodTwo = _bonusRatePeriodTwo;\n', '        tokenUnsold = _tokenUnsold;\n', '        bonusUnsold = _bonusUnsold;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '        uint256 weiAmount = msg.value;\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '        // calculate token amount to be sent\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            tokens\n', '        );\n', '\n', '        // calculate bonus amount to be sent\n', '        uint256 bonus = _getTokenBonus(weiAmount);\n', '        _addBonus(_beneficiary, bonus);\n', '        bonusUnsold = bonusUnsold.sub(bonus);\n', '        emit TokenBonus(\n', '            msg.sender,\n', '            _beneficiary,\n', '            bonus\n', '        );\n', '        _forwardFunds();\n', '    }\n', '\t\n', '    function isClosed() public view returns (bool) {\n', '        return block.timestamp > closingTimePeriodTwo;\n', '    }\n', '\n', '    function isOpened() public view returns (bool) {\n', '        return (block.timestamp < closingTimePeriodOne && block.timestamp > openingTimePeriodOne) || (block.timestamp < closingTimePeriodTwo && block.timestamp > openingTimePeriodTwo);\n', '    }\n', '\n', '    function privateCrowdsale(address _beneficiary, uint256 _ethAmount) external onlyOwner{\n', '        _preValidatePurchase(_beneficiary, _ethAmount);\n', '\n', '        // calculate token amount to be sent\n', '        uint256 tokens = _getTokenAmount(_ethAmount);\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            _ethAmount,\n', '            tokens\n', '        );\n', '\n', '        // calculate bonus amount to be sent\n', '        uint256 bonus = _ethAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(bonusRatePrivateSale);\n', '        _addBonus(_beneficiary, bonus);\n', '        bonusUnsold = bonusUnsold.sub(bonus);\n', '        emit TokenBonus(\n', '            msg.sender,\n', '            _beneficiary,\n', '            bonus\n', '        );\n', '    }\n', '    \n', '    function returnToken() external onlyOwner{\n', '        require(block.timestamp > closingTimePeriodTwo);\n', '        require(tokenUnsold > 0);\n', '        token.transfer(wallet,tokenUnsold);\n', '        tokenUnsold = tokenUnsold.sub(tokenUnsold);\n', '    }\n', '\n', '    /**\n', '     * WARNING: Make sure that user who owns bonus is still in whitelist!!!\n', '     */\n', '    function deliverBonus() public onlyOwner {\n', '        require(bonusDeliverTime <= block.timestamp);\n', '        for (uint i = 0; i<buyerList.length; i++){\n', '            uint256 amount = buyerBonus[buyerList[i]];\n', '            token.transfer(buyerList[i], amount);\n', '            buyerBonus[buyerList[i]] = 0;\n', '        }\n', '    }\n', '\n', '    function returnBonus() external onlyOwner{\n', '        require(block.timestamp > bonusDeliverTime);\n', '        require(bonusUnsold > 0);\n', '        token.transfer(wallet, bonusUnsold);\n', '        bonusUnsold = bonusUnsold.sub(bonusUnsold);\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen\n', '    {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount >= minPurchaseAmount);\n', '    }\n', '\n', '    function _validateMaxSellAmount(uint256 _tokenAmount) internal view onlyWhileOpen {\n', '        require(tokenUnsold >= _tokenAmount);\n', '    }\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transfer(_beneficiary, _tokenAmount);\n', '        tokenUnsold = tokenUnsold.sub(_tokenAmount);\n', '    }\n', '\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        _validateMaxSellAmount(_tokenAmount);\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    function _getTokenAmount( uint256 _weiAmount) internal view returns (uint256) {\n', '        return _weiAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(rate);\n', '    }\n', '\n', '    function _getTokenBonus(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint256 bonusRate = 0;\n', '        if(block.timestamp > openingTimePeriodOne && block.timestamp < closingTimePeriodOne){\n', '            bonusRate = bonusRatePeriodOne;\n', '        } else if(block.timestamp > openingTimePeriodTwo && block.timestamp < closingTimePeriodTwo){\n', '            bonusRate = bonusRatePeriodTwo;\n', '        }\n', '        return _weiAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(bonusRate);\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', '// File: contracts/StandardToken.sol\n', '\n', 'contract StandardToken is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 totalSupply_;\n', '    bool public transferOpen = true;\n', '\n', '    modifier onlyWhileTransferOpen {\n', '        require(transferOpen);\n', '        _;\n', '    }\n', '\n', '    function setTransfer(bool _open) external onlyOwner{\n', '        transferOpen = _open;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public onlyWhileTransferOpen returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyWhileTransferOpen returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'contract Whitelist is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    mapping(address => bool) public whitelist;\n', '    mapping(address => uint256) whitelistIndexMap;\n', '    address[] public whitelistArray;\n', '    uint256 public whitelistLength = 0;\n', '\n', '    modifier isWhitelisted(address _beneficiary) {\n', '        require(whitelist[_beneficiary]);\n', '        _;\n', '    }\n', '\n', '    function addToWhitelist(address _beneficiary) external onlyOwner {\n', '        whitelist[_beneficiary] = true;\n', '        if (whitelistIndexMap[_beneficiary] == 0){\n', '            if (whitelistArray.length <= whitelistLength){\n', '                whitelistArray.push(_beneficiary);\n', '            } else {\n', '                whitelistArray[whitelistLength] = _beneficiary;\n', '            }\n', '            whitelistLength = whitelistLength.add(1);\n', '            whitelistIndexMap[_beneficiary] = whitelistLength;\n', '        }\n', '    }\n', '\n', '    function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '            whitelist[_beneficiaries[i]] = true;\n', '        }\n', '    }\n', '\n', '    function removeFromWhitelist(address _beneficiary) external onlyOwner {\n', '        whitelist[_beneficiary] = false;\n', '        if (whitelistIndexMap[_beneficiary] > 0){\n', '            uint index = whitelistIndexMap[_beneficiary]-1;\n', '            whitelistArray[index] = whitelistArray[whitelistLength-1];\n', '            whitelistArray[whitelistLength-1] = 0;\n', '            whitelistIndexMap[_beneficiary] = 0;\n', '            whitelistLength = whitelistLength.sub(1);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/AFIToken.sol\n', '\n', 'contract AFIToken is StandardToken, Crowdsale, Whitelist {\n', '    using SafeMath for uint256;\n', '    string public constant name = "AlchemyCoin";\n', '    string public constant symbol = "AFI";\n', '    uint8 public constant decimals = 8;\n', '    uint256 constant INITIAL_SUPPLY = 125000000 * (10 ** uint256(decimals));\n', '    uint256 constant ICO_SUPPLY = 50000000 * (10 ** uint256(decimals));\n', '    uint256 constant ICO_BONUS = 12500000 * (10 ** uint256(decimals));\n', '    uint256 public minRevenueToDeliver = 0;\n', '    address public assignRevenueContract;\n', '    uint256 public snapshotBlockHeight;\n', '    mapping(address => uint256) public snapshotBalance;\n', '    // Custom Setting values ---------------------------------\n', '    uint256 constant _openingTimePeriodOne = 1531713600;\n', '    uint256 constant _closingTimePeriodOne = 1534132800;\n', '    uint256 constant _openingTimePeriodTwo = 1535342400;\n', '    uint256 constant _closingTimePeriodTwo = 1536552000;\n', '    uint256 constant _bonusDeliverTime = 1552276800;\n', '    address _wallet = 0x2Dc02F830072eB33A12Da0852053eAF896185910;\n', '    address _afiWallet = 0x991E2130f5bF113E2282A5F58E626467D2221599;\n', '    // -------------------------------------------------------\n', '    uint256 constant _rate = 1000;\n', '    uint256 constant _bonusRatePrivateSale = 250;\n', '    uint256 constant _bonusRatePeriodOne = 150;\n', '    uint256 constant _bonusRatePeriodTwo = 50;\n', '    \n', '\n', '    constructor() public \n', '    Crowdsale(_openingTimePeriodOne, _closingTimePeriodOne, _openingTimePeriodTwo, _closingTimePeriodTwo, _bonusDeliverTime,\n', '        _rate, _bonusRatePrivateSale, _bonusRatePeriodOne, _bonusRatePeriodTwo, \n', '        _wallet, this, decimals, ICO_SUPPLY, ICO_BONUS)\n', '    {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        emit Transfer(0x0, _afiWallet, INITIAL_SUPPLY - ICO_SUPPLY - ICO_BONUS);\n', '        emit Transfer(0x0, this, ICO_SUPPLY);\n', '        balances[_afiWallet] = INITIAL_SUPPLY - ICO_SUPPLY - ICO_BONUS;\n', '        \n', '        // add admin\n', '        whitelist[_afiWallet] = true;\n', '        whitelistArray.push(_afiWallet);\n', '        whitelistLength = whitelistLength.add(1);\n', '        whitelistIndexMap[_afiWallet] = whitelistLength;\n', '        \n', '        // add contract\n', '        whitelist[this] = true;\n', '        whitelistArray.push(this);\n', '        whitelistLength = whitelistLength.add(1);\n', '        whitelistIndexMap[this] = whitelistLength;\n', '        balances[this] = ICO_SUPPLY + ICO_BONUS;\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view isWhitelisted(_beneficiary){\n', '        super._preValidatePurchase(_beneficiary, _weiAmount);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public isWhitelisted(_to) isWhitelisted(msg.sender) returns (bool) {\n', '        super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public isWhitelisted(_to) isWhitelisted(_from)  returns (bool){\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function setRevenueContract(address _contract) external onlyOwner{\n', '        assignRevenueContract = _contract;\n', '    }\n', '\n', '    function createBalanceSnapshot() external onlyOwner {\n', '        snapshotBlockHeight = block.number;\n', '        for(uint256 i = 0; i < whitelistLength; i++) {\n', '            snapshotBalance[whitelistArray[i]] = balances[whitelistArray[i]];\n', '        }\n', '    }\n', '\n', '    function setMinRevenue(uint256 _minRevenue) external onlyOwner {\n', '        minRevenueToDeliver = _minRevenue;\n', '    }\n', '\n', '    function assignRevenue(uint256 _totalRevenue) external onlyOwner{\n', '        address contractAddress = assignRevenueContract;\n', '\n', '        for (uint256 i = 0; i<whitelistLength; i++){\n', '            if(whitelistArray[i] == address(this)){\n', '                continue;\n', '            }\n', '            uint256 amount = _totalRevenue.mul(snapshotBalance[whitelistArray[i]]).div(INITIAL_SUPPLY);\n', '            if(amount > minRevenueToDeliver){\n', '                bool done = contractAddress.call(bytes4(keccak256("transferRevenue(address,uint256)")),whitelistArray[i],amount);\n', '                require(done == true);\n', '            }\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require((msg.sender == owner) || (tx.origin == owner));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/Bonus.sol\n', '\n', 'contract Bonus is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) public buyerBonus;\n', '    mapping(address => bool) hasBought;\n', '    address[] public buyerList;\n', '    \n', '    function _addBonus(address _beneficiary, uint256 _bonus) internal {\n', '        if(hasBought[_beneficiary]){\n', '            buyerBonus[_beneficiary] = buyerBonus[_beneficiary].add(_bonus);\n', '        } else {\n', '            hasBought[_beneficiary] = true;\n', '            buyerList.push(_beneficiary);\n', '            buyerBonus[_beneficiary] = _bonus;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/ERC20Basic.sol\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/ERC20.sol\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/CrowdSale.sol\n', '\n', 'contract Crowdsale is Bonus {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    ERC20 public token;\n', '\n', '    // Address where funds are collected\n', '    address public wallet;\n', '\n', '    // ICO exchange rate\n', '    uint256 public rate;\n', '\n', '    // ICO Time\n', '    uint256 public openingTimePeriodOne;\n', '    uint256 public closingTimePeriodOne;\n', '    uint256 public openingTimePeriodTwo;\n', '    uint256 public closingTimePeriodTwo;\n', '    uint256 public bonusDeliverTime;\n', '\n', '    // Diff bonus rate decided by time\n', '    uint256 public bonusRatePrivateSale;\n', '    uint256 public bonusRatePeriodOne;\n', '    uint256 public bonusRatePeriodTwo;\n', '\n', '    // Token decimal\n', '    uint256 decimals;\n', '    uint256 public tokenUnsold;\n', '    uint256 public bonusUnsold;\n', '    uint256 public constant minPurchaseAmount = 0.1 ether;\n', '\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus);\n', '\n', '    modifier onlyWhileOpen {\n', '        require(block.timestamp <= closingTimePeriodTwo);\n', '        _;\n', '    }\n', '\n', '    constructor (uint256 _openingTimePeriodOne, uint256 _closingTimePeriodOne, uint256 _openingTimePeriodTwo, uint256 _closingTimePeriodTwo, uint256 _bonusDeliverTime,\n', '        uint256 _rate, uint256 _bonusRatePrivateSale, uint256 _bonusRatePeriodOne, uint256 _bonusRatePeriodTwo, \n', '        address _wallet, ERC20 _token, uint256 _decimals, uint256 _tokenUnsold, uint256 _bonusUnsold) public {\n', '        require(_wallet != address(0));\n', '        require(_token != address(0));\n', '        require(_openingTimePeriodOne >= block.timestamp);\n', '        require(_closingTimePeriodOne >= _openingTimePeriodOne);\n', '        require(_openingTimePeriodTwo >= _closingTimePeriodOne);\n', '        require(_closingTimePeriodTwo >= _openingTimePeriodTwo);\n', '\n', '        wallet = _wallet;\n', '        token = _token;\n', '        openingTimePeriodOne = _openingTimePeriodOne;\n', '        closingTimePeriodOne = _closingTimePeriodOne;\n', '        openingTimePeriodTwo = _openingTimePeriodTwo;\n', '        closingTimePeriodTwo = _closingTimePeriodTwo;\n', '        bonusDeliverTime = _bonusDeliverTime;\n', '        rate = _rate;\n', '        bonusRatePrivateSale = _bonusRatePrivateSale;\n', '        bonusRatePeriodOne = _bonusRatePeriodOne;\n', '        bonusRatePeriodTwo = _bonusRatePeriodTwo;\n', '        tokenUnsold = _tokenUnsold;\n', '        bonusUnsold = _bonusUnsold;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable {\n', '        uint256 weiAmount = msg.value;\n', '        _preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '        // calculate token amount to be sent\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            weiAmount,\n', '            tokens\n', '        );\n', '\n', '        // calculate bonus amount to be sent\n', '        uint256 bonus = _getTokenBonus(weiAmount);\n', '        _addBonus(_beneficiary, bonus);\n', '        bonusUnsold = bonusUnsold.sub(bonus);\n', '        emit TokenBonus(\n', '            msg.sender,\n', '            _beneficiary,\n', '            bonus\n', '        );\n', '        _forwardFunds();\n', '    }\n', '\t\n', '    function isClosed() public view returns (bool) {\n', '        return block.timestamp > closingTimePeriodTwo;\n', '    }\n', '\n', '    function isOpened() public view returns (bool) {\n', '        return (block.timestamp < closingTimePeriodOne && block.timestamp > openingTimePeriodOne) || (block.timestamp < closingTimePeriodTwo && block.timestamp > openingTimePeriodTwo);\n', '    }\n', '\n', '    function privateCrowdsale(address _beneficiary, uint256 _ethAmount) external onlyOwner{\n', '        _preValidatePurchase(_beneficiary, _ethAmount);\n', '\n', '        // calculate token amount to be sent\n', '        uint256 tokens = _getTokenAmount(_ethAmount);\n', '        _processPurchase(_beneficiary, tokens);\n', '        emit TokenPurchase(\n', '            msg.sender,\n', '            _beneficiary,\n', '            _ethAmount,\n', '            tokens\n', '        );\n', '\n', '        // calculate bonus amount to be sent\n', '        uint256 bonus = _ethAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(bonusRatePrivateSale);\n', '        _addBonus(_beneficiary, bonus);\n', '        bonusUnsold = bonusUnsold.sub(bonus);\n', '        emit TokenBonus(\n', '            msg.sender,\n', '            _beneficiary,\n', '            bonus\n', '        );\n', '    }\n', '    \n', '    function returnToken() external onlyOwner{\n', '        require(block.timestamp > closingTimePeriodTwo);\n', '        require(tokenUnsold > 0);\n', '        token.transfer(wallet,tokenUnsold);\n', '        tokenUnsold = tokenUnsold.sub(tokenUnsold);\n', '    }\n', '\n', '    /**\n', '     * WARNING: Make sure that user who owns bonus is still in whitelist!!!\n', '     */\n', '    function deliverBonus() public onlyOwner {\n', '        require(bonusDeliverTime <= block.timestamp);\n', '        for (uint i = 0; i<buyerList.length; i++){\n', '            uint256 amount = buyerBonus[buyerList[i]];\n', '            token.transfer(buyerList[i], amount);\n', '            buyerBonus[buyerList[i]] = 0;\n', '        }\n', '    }\n', '\n', '    function returnBonus() external onlyOwner{\n', '        require(block.timestamp > bonusDeliverTime);\n', '        require(bonusUnsold > 0);\n', '        token.transfer(wallet, bonusUnsold);\n', '        bonusUnsold = bonusUnsold.sub(bonusUnsold);\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen\n', '    {\n', '        require(_beneficiary != address(0));\n', '        require(_weiAmount >= minPurchaseAmount);\n', '    }\n', '\n', '    function _validateMaxSellAmount(uint256 _tokenAmount) internal view onlyWhileOpen {\n', '        require(tokenUnsold >= _tokenAmount);\n', '    }\n', '\n', '    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n', '        token.transfer(_beneficiary, _tokenAmount);\n', '        tokenUnsold = tokenUnsold.sub(_tokenAmount);\n', '    }\n', '\n', '    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n', '        _validateMaxSellAmount(_tokenAmount);\n', '        _deliverTokens(_beneficiary, _tokenAmount);\n', '    }\n', '\n', '    function _getTokenAmount( uint256 _weiAmount) internal view returns (uint256) {\n', '        return _weiAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(rate);\n', '    }\n', '\n', '    function _getTokenBonus(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint256 bonusRate = 0;\n', '        if(block.timestamp > openingTimePeriodOne && block.timestamp < closingTimePeriodOne){\n', '            bonusRate = bonusRatePeriodOne;\n', '        } else if(block.timestamp > openingTimePeriodTwo && block.timestamp < closingTimePeriodTwo){\n', '            bonusRate = bonusRatePeriodTwo;\n', '        }\n', '        return _weiAmount.mul(10 ** uint256(decimals)).div(1 ether).mul(bonusRate);\n', '    }\n', '\n', '    function _forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '}\n', '\n', '// File: contracts/StandardToken.sol\n', '\n', 'contract StandardToken is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 totalSupply_;\n', '    bool public transferOpen = true;\n', '\n', '    modifier onlyWhileTransferOpen {\n', '        require(transferOpen);\n', '        _;\n', '    }\n', '\n', '    function setTransfer(bool _open) external onlyOwner{\n', '        transferOpen = _open;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public onlyWhileTransferOpen returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyWhileTransferOpen returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', 'contract Whitelist is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    mapping(address => bool) public whitelist;\n', '    mapping(address => uint256) whitelistIndexMap;\n', '    address[] public whitelistArray;\n', '    uint256 public whitelistLength = 0;\n', '\n', '    modifier isWhitelisted(address _beneficiary) {\n', '        require(whitelist[_beneficiary]);\n', '        _;\n', '    }\n', '\n', '    function addToWhitelist(address _beneficiary) external onlyOwner {\n', '        whitelist[_beneficiary] = true;\n', '        if (whitelistIndexMap[_beneficiary] == 0){\n', '            if (whitelistArray.length <= whitelistLength){\n', '                whitelistArray.push(_beneficiary);\n', '            } else {\n', '                whitelistArray[whitelistLength] = _beneficiary;\n', '            }\n', '            whitelistLength = whitelistLength.add(1);\n', '            whitelistIndexMap[_beneficiary] = whitelistLength;\n', '        }\n', '    }\n', '\n', '    function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '            whitelist[_beneficiaries[i]] = true;\n', '        }\n', '    }\n', '\n', '    function removeFromWhitelist(address _beneficiary) external onlyOwner {\n', '        whitelist[_beneficiary] = false;\n', '        if (whitelistIndexMap[_beneficiary] > 0){\n', '            uint index = whitelistIndexMap[_beneficiary]-1;\n', '            whitelistArray[index] = whitelistArray[whitelistLength-1];\n', '            whitelistArray[whitelistLength-1] = 0;\n', '            whitelistIndexMap[_beneficiary] = 0;\n', '            whitelistLength = whitelistLength.sub(1);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/AFIToken.sol\n', '\n', 'contract AFIToken is StandardToken, Crowdsale, Whitelist {\n', '    using SafeMath for uint256;\n', '    string public constant name = "AlchemyCoin";\n', '    string public constant symbol = "AFI";\n', '    uint8 public constant decimals = 8;\n', '    uint256 constant INITIAL_SUPPLY = 125000000 * (10 ** uint256(decimals));\n', '    uint256 constant ICO_SUPPLY = 50000000 * (10 ** uint256(decimals));\n', '    uint256 constant ICO_BONUS = 12500000 * (10 ** uint256(decimals));\n', '    uint256 public minRevenueToDeliver = 0;\n', '    address public assignRevenueContract;\n', '    uint256 public snapshotBlockHeight;\n', '    mapping(address => uint256) public snapshotBalance;\n', '    // Custom Setting values ---------------------------------\n', '    uint256 constant _openingTimePeriodOne = 1531713600;\n', '    uint256 constant _closingTimePeriodOne = 1534132800;\n', '    uint256 constant _openingTimePeriodTwo = 1535342400;\n', '    uint256 constant _closingTimePeriodTwo = 1536552000;\n', '    uint256 constant _bonusDeliverTime = 1552276800;\n', '    address _wallet = 0x2Dc02F830072eB33A12Da0852053eAF896185910;\n', '    address _afiWallet = 0x991E2130f5bF113E2282A5F58E626467D2221599;\n', '    // -------------------------------------------------------\n', '    uint256 constant _rate = 1000;\n', '    uint256 constant _bonusRatePrivateSale = 250;\n', '    uint256 constant _bonusRatePeriodOne = 150;\n', '    uint256 constant _bonusRatePeriodTwo = 50;\n', '    \n', '\n', '    constructor() public \n', '    Crowdsale(_openingTimePeriodOne, _closingTimePeriodOne, _openingTimePeriodTwo, _closingTimePeriodTwo, _bonusDeliverTime,\n', '        _rate, _bonusRatePrivateSale, _bonusRatePeriodOne, _bonusRatePeriodTwo, \n', '        _wallet, this, decimals, ICO_SUPPLY, ICO_BONUS)\n', '    {\n', '        totalSupply_ = INITIAL_SUPPLY;\n', '        emit Transfer(0x0, _afiWallet, INITIAL_SUPPLY - ICO_SUPPLY - ICO_BONUS);\n', '        emit Transfer(0x0, this, ICO_SUPPLY);\n', '        balances[_afiWallet] = INITIAL_SUPPLY - ICO_SUPPLY - ICO_BONUS;\n', '        \n', '        // add admin\n', '        whitelist[_afiWallet] = true;\n', '        whitelistArray.push(_afiWallet);\n', '        whitelistLength = whitelistLength.add(1);\n', '        whitelistIndexMap[_afiWallet] = whitelistLength;\n', '        \n', '        // add contract\n', '        whitelist[this] = true;\n', '        whitelistArray.push(this);\n', '        whitelistLength = whitelistLength.add(1);\n', '        whitelistIndexMap[this] = whitelistLength;\n', '        balances[this] = ICO_SUPPLY + ICO_BONUS;\n', '    }\n', '\n', '    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view isWhitelisted(_beneficiary){\n', '        super._preValidatePurchase(_beneficiary, _weiAmount);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public isWhitelisted(_to) isWhitelisted(msg.sender) returns (bool) {\n', '        super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public isWhitelisted(_to) isWhitelisted(_from)  returns (bool){\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function setRevenueContract(address _contract) external onlyOwner{\n', '        assignRevenueContract = _contract;\n', '    }\n', '\n', '    function createBalanceSnapshot() external onlyOwner {\n', '        snapshotBlockHeight = block.number;\n', '        for(uint256 i = 0; i < whitelistLength; i++) {\n', '            snapshotBalance[whitelistArray[i]] = balances[whitelistArray[i]];\n', '        }\n', '    }\n', '\n', '    function setMinRevenue(uint256 _minRevenue) external onlyOwner {\n', '        minRevenueToDeliver = _minRevenue;\n', '    }\n', '\n', '    function assignRevenue(uint256 _totalRevenue) external onlyOwner{\n', '        address contractAddress = assignRevenueContract;\n', '\n', '        for (uint256 i = 0; i<whitelistLength; i++){\n', '            if(whitelistArray[i] == address(this)){\n', '                continue;\n', '            }\n', '            uint256 amount = _totalRevenue.mul(snapshotBalance[whitelistArray[i]]).div(INITIAL_SUPPLY);\n', '            if(amount > minRevenueToDeliver){\n', '                bool done = contractAddress.call(bytes4(keccak256("transferRevenue(address,uint256)")),whitelistArray[i],amount);\n', '                require(done == true);\n', '            }\n', '        }\n', '    }\n', '}']
