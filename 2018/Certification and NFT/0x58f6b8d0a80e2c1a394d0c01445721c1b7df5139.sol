['pragma solidity ^0.4.15;\n', '\n', '/*\n', '  https://cryptogs.io\n', '  --Austin Thomas Griffith for ETHDenver\n', '  PizzaParlor -- a new venue for cryptogs games\n', '  less transactions than original Cryptogs.sol assuming some\n', '  centralization and a single commit reveal for randomness\n', '*/\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract PizzaParlor {\n', '\n', '  uint8 public constant FLIPPINESS = 64;\n', '  uint8 public constant FLIPPINESSROUNDBONUS = 16;\n', '  uint8 public constant MAXROUNDS = 12; //must be greater than (255-FLIPPINESS)/FLIPPINESSROUNDBONUS\n', '  uint32 public constant BLOCKTIMEOUT = 40;// a few hours?\n', '\n', '  address public cryptogsAddress;\n', '  function PizzaParlor(address _cryptogsAddress) public {\n', '    cryptogsAddress=_cryptogsAddress;\n', '  }\n', '\n', '  //to make less transactions on-chain, game creation will happen off-chain\n', '  //at this point, two players have agreed upon the ten cryptogs that will\n', '  //be in the game, five from each player\n', '  // the server will generate a secret, reveal, and commit\n', '  // this commit is used as the game id and both players share it\n', '  // the server will pick one user at random to be the game master\n', '  // this player will get the reveal and be in charge of generating the game\n', '  // technically either player can generate the game with the reveal\n', '  // (and either player can drain the stack with the secret)\n', '\n', '    //     commit      ->      player  -> stack hash\n', '  mapping (bytes32 => mapping (address => bytes32)) public commitReceipt;\n', '\n', '    //     commit      ->      player  -> block number\n', '  mapping (bytes32 => mapping (address => uint32)) public commitBlock;\n', '\n', '  mapping (bytes32 => uint8) public stacksTransferred;\n', '\n', '  //tx1&2: players submit to a particular commit hash their stack of pogs (the two txs can happen on the same block, no one is waiting)\n', '  //these go to the Cryptogs contract and it is transferStackAndCall&#39;ed to here\n', '  function onTransferStack(address _sender, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _commit){\n', '\n', '    //make sure this came from the Cryptogs contract\n', '    require(msg.sender == cryptogsAddress);\n', '\n', '    //make sure this commit is unique / doesn&#39;t already exist\n', '    require(commitReceipt[_commit][_sender] == 0);\n', '\n', '    //make sure there aren&#39;t already two stacks submitted\n', '    require(stacksTransferred[_commit]<2);\n', '    stacksTransferred[_commit]++;\n', '\n', '    //make sure this contract now owns these tokens\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '    require(cryptogsContract.tokenIndexToOwner(_token1)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token2)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token3)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token4)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token5)==address(this));\n', '\n', '    //generate a receipt for the transfer\n', '    bytes32 receipt = keccak256(_commit,_sender,_token1,_token2,_token3,_token4,_token5);\n', '    commitReceipt[_commit][_sender] = receipt;\n', '    commitBlock[_commit][_sender] = uint32(block.number);\n', '\n', '    //fire an event for the frontend\n', '    TransferStack(_commit,_sender,receipt,now,_token1,_token2,_token3,_token4,_token5);\n', '  }\n', '  event TransferStack(bytes32 indexed _commit,address indexed _sender,bytes32 indexed _receipt,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5);\n', '\n', '  //tx3: either player, knowing the reveal, can generate the game\n', '  //this tx calculates random, generates game events, and transfers\n', '  // tokens back to winners\n', '  //in order to make game costs fair, the frontend should randomly select\n', '  // one of the two players and give them the reveal to generate the game\n', '  // in a bit you could give it to the other player too .... then after the\n', '  // timeout, they would get the secret to drain the stack\n', '  function generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\n', '    //verify that receipts are valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\n', '\n', '    //verify we are on a later block so random will work\n', '    require( uint32(block.number) > commitBlock[_commit][msg.sender]);\n', '    require( uint32(block.number) > commitBlock[_commit][_opponent]);\n', '\n', '    //verify that the reveal is correct\n', '    require(_commit == keccak256(_reveal));\n', '\n', '    //make sure there are exactly two stacks submitted\n', '    require(stacksTransferred[_commit]==2);\n', '\n', '    _generateGame(_commit,_reveal,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\n', '  }\n', '\n', '  function _generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint[10] _tokens) internal {\n', '    //create Cryptogs contract for transfers\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    //generate the random using commit / reveal and blockhash from future (now past) block\n', '    bytes32[4] memory pseudoRandoms = _generateRandom(_reveal,commitBlock[_commit][msg.sender],commitBlock[_commit][_opponent]);\n', '\n', '    bool whosTurn = uint8(pseudoRandoms[0][0])%2==0;\n', '    CoinFlip(_commit,whosTurn,whosTurn ? msg.sender : _opponent);\n', '    for(uint8 round=1;round<=MAXROUNDS;round++){\n', '      for(uint8 i=1;i<=10;i++){\n', '        //first check and see if this token has flipped yet\n', '        if(_tokens[i-1]>0){\n', '\n', '          //get the random byte between 0-255 from our pseudoRandoms array of bytes32\n', '          uint8 rand = _getRandom(pseudoRandoms,(round-1)*10 + i);\n', '\n', '          uint8 threshold = (FLIPPINESS+round*FLIPPINESSROUNDBONUS);\n', '          if( rand < threshold || round==MAXROUNDS ){\n', '            _flip(_commit,round,cryptogsContract,_tokens,i-1,_opponent,whosTurn);\n', '          }\n', '        }\n', '      }\n', '      whosTurn = !whosTurn;\n', '    }\n', '\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    delete commitReceipt[_commit][_opponent];\n', '\n', '    GenerateGame(_commit,msg.sender);\n', '  }\n', '  event CoinFlip(bytes32 indexed _commit,bool _result,address _winner);\n', '  event GenerateGame(bytes32 indexed _commit,address indexed _sender);\n', '\n', '  function _getRandom(bytes32[4] pseudoRandoms,uint8 randIndex) internal returns (uint8 rand){\n', '    if(randIndex<32){\n', '      rand = uint8(pseudoRandoms[0][randIndex]);\n', '    }else if(randIndex<64){\n', '      rand = uint8(pseudoRandoms[1][randIndex-32]);\n', '    }else if(randIndex<96){\n', '      rand = uint8(pseudoRandoms[1][randIndex-64]);\n', '    }else{\n', '      rand = uint8(pseudoRandoms[1][randIndex-96]);\n', '    }\n', '    return rand;\n', '  }\n', '\n', '  function _generateRandom(bytes32 _reveal, uint32 block1,uint32 block2) internal returns(bytes32[4] pseudoRandoms){\n', '    pseudoRandoms[0] = keccak256(_reveal,block.blockhash(max(block1,block2)));\n', '    pseudoRandoms[1] = keccak256(pseudoRandoms[0]);\n', '    pseudoRandoms[2] = keccak256(pseudoRandoms[1]);\n', '    pseudoRandoms[3] = keccak256(pseudoRandoms[2]);\n', '    return pseudoRandoms;\n', '  }\n', '\n', '  function max(uint32 a, uint32 b) private pure returns (uint32) {\n', '      return a > b ? a : b;\n', '  }\n', '\n', '  function _flip(bytes32 _commit,uint8 round,NFT cryptogsContract,uint[10] _tokens,uint8 tokenIndex,address _opponent,bool whosTurn) internal {\n', '    address flipper;\n', '    if(whosTurn) {\n', '      flipper=msg.sender;\n', '    }else{\n', '      flipper=_opponent;\n', '    }\n', '    cryptogsContract.transfer(flipper,_tokens[tokenIndex]);\n', '    Flip(_commit,round,flipper,_tokens[tokenIndex]);\n', '    _tokens[tokenIndex]=0;\n', '  }\n', '  event Flip(bytes32 indexed _commit,uint8 _round,address indexed _flipper,uint indexed _token);\n', '\n', '  //if the game times out without either player generating the game,\n', '  // (the frontend should have selected one of the players randomly to generate the game)\n', '  //the frontend should give the other player the secret to drain the game\n', '  // secret -> reveal -> commit\n', '  function drainGame(bytes32 _commit,bytes32 _secret,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\n', '    //verify that receipts are valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\n', '\n', '    //verify we are on a later block so random will work\n', '    require( uint32(block.number) > commitBlock[_commit][msg.sender]+BLOCKTIMEOUT);\n', '    require( uint32(block.number) > commitBlock[_commit][_opponent]+BLOCKTIMEOUT);\n', '\n', '    //make sure the commit is the doublehash of the secret\n', '    require(_commit == keccak256(keccak256(_secret)));\n', '\n', '    //make sure there are exactly two stacks submitted\n', '    require(stacksTransferred[_commit]==2);\n', '\n', '    _drainGame(_commit,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\n', '  }\n', '\n', '  function _drainGame(bytes32 _commit,address _opponent, uint[10] _tokens) internal {\n', '    //create Cryptogs contract for transfers\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    cryptogsContract.transfer(msg.sender,_tokens[0]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[1]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[2]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[3]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[4]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[5]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[6]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[7]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[8]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[9]);\n', '\n', '    Flip(_commit,1,msg.sender,_tokens[0]);\n', '    Flip(_commit,1,msg.sender,_tokens[1]);\n', '    Flip(_commit,1,msg.sender,_tokens[2]);\n', '    Flip(_commit,1,msg.sender,_tokens[3]);\n', '    Flip(_commit,1,msg.sender,_tokens[4]);\n', '    Flip(_commit,1,msg.sender,_tokens[5]);\n', '    Flip(_commit,1,msg.sender,_tokens[6]);\n', '    Flip(_commit,1,msg.sender,_tokens[7]);\n', '    Flip(_commit,1,msg.sender,_tokens[8]);\n', '    Flip(_commit,1,msg.sender,_tokens[9]);\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    delete commitReceipt[_commit][_opponent];\n', '    DrainGame(_commit,msg.sender);\n', '  }\n', '  event DrainGame(bytes32 indexed _commit,address indexed _sender);\n', '\n', '  //if only one player ever ends up submitting a stack, they need to be able\n', '  //to pull thier tokens back\n', '  function revokeStack(bytes32 _commit,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5){\n', '    //verify that receipt is valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '\n', '    //make sure there is exactly one stacks submitted\n', '    require(stacksTransferred[_commit]==1);\n', '\n', '    stacksTransferred[_commit]=0;\n', '\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    cryptogsContract.transfer(msg.sender,_token1);\n', '    cryptogsContract.transfer(msg.sender,_token2);\n', '    cryptogsContract.transfer(msg.sender,_token3);\n', '    cryptogsContract.transfer(msg.sender,_token4);\n', '    cryptogsContract.transfer(msg.sender,_token5);\n', '\n', '\n', '    bytes32 previousReceipt = commitReceipt[_commit][msg.sender];\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    //fire an event for the frontend\n', '    RevokeStack(_commit,msg.sender,now,_token1,_token2,_token3,_token4,_token5,previousReceipt);\n', '  }\n', '  event RevokeStack(bytes32 indexed _commit,address indexed _sender,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bytes32 _receipt);\n', '\n', '}\n', '\n', 'contract NFT {\n', '  function approve(address _to,uint256 _tokenId) public returns (bool) { }\n', '  function transfer(address _to,uint256 _tokenId) external { }\n', '  mapping (uint256 => address) public tokenIndexToOwner;\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '/*\n', '  https://cryptogs.io\n', '  --Austin Thomas Griffith for ETHDenver\n', '  PizzaParlor -- a new venue for cryptogs games\n', '  less transactions than original Cryptogs.sol assuming some\n', '  centralization and a single commit reveal for randomness\n', '*/\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract PizzaParlor {\n', '\n', '  uint8 public constant FLIPPINESS = 64;\n', '  uint8 public constant FLIPPINESSROUNDBONUS = 16;\n', '  uint8 public constant MAXROUNDS = 12; //must be greater than (255-FLIPPINESS)/FLIPPINESSROUNDBONUS\n', '  uint32 public constant BLOCKTIMEOUT = 40;// a few hours?\n', '\n', '  address public cryptogsAddress;\n', '  function PizzaParlor(address _cryptogsAddress) public {\n', '    cryptogsAddress=_cryptogsAddress;\n', '  }\n', '\n', '  //to make less transactions on-chain, game creation will happen off-chain\n', '  //at this point, two players have agreed upon the ten cryptogs that will\n', '  //be in the game, five from each player\n', '  // the server will generate a secret, reveal, and commit\n', '  // this commit is used as the game id and both players share it\n', '  // the server will pick one user at random to be the game master\n', '  // this player will get the reveal and be in charge of generating the game\n', '  // technically either player can generate the game with the reveal\n', '  // (and either player can drain the stack with the secret)\n', '\n', '    //     commit      ->      player  -> stack hash\n', '  mapping (bytes32 => mapping (address => bytes32)) public commitReceipt;\n', '\n', '    //     commit      ->      player  -> block number\n', '  mapping (bytes32 => mapping (address => uint32)) public commitBlock;\n', '\n', '  mapping (bytes32 => uint8) public stacksTransferred;\n', '\n', '  //tx1&2: players submit to a particular commit hash their stack of pogs (the two txs can happen on the same block, no one is waiting)\n', "  //these go to the Cryptogs contract and it is transferStackAndCall'ed to here\n", '  function onTransferStack(address _sender, uint _token1, uint _token2, uint _token3, uint _token4, uint _token5, bytes32 _commit){\n', '\n', '    //make sure this came from the Cryptogs contract\n', '    require(msg.sender == cryptogsAddress);\n', '\n', "    //make sure this commit is unique / doesn't already exist\n", '    require(commitReceipt[_commit][_sender] == 0);\n', '\n', "    //make sure there aren't already two stacks submitted\n", '    require(stacksTransferred[_commit]<2);\n', '    stacksTransferred[_commit]++;\n', '\n', '    //make sure this contract now owns these tokens\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '    require(cryptogsContract.tokenIndexToOwner(_token1)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token2)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token3)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token4)==address(this));\n', '    require(cryptogsContract.tokenIndexToOwner(_token5)==address(this));\n', '\n', '    //generate a receipt for the transfer\n', '    bytes32 receipt = keccak256(_commit,_sender,_token1,_token2,_token3,_token4,_token5);\n', '    commitReceipt[_commit][_sender] = receipt;\n', '    commitBlock[_commit][_sender] = uint32(block.number);\n', '\n', '    //fire an event for the frontend\n', '    TransferStack(_commit,_sender,receipt,now,_token1,_token2,_token3,_token4,_token5);\n', '  }\n', '  event TransferStack(bytes32 indexed _commit,address indexed _sender,bytes32 indexed _receipt,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5);\n', '\n', '  //tx3: either player, knowing the reveal, can generate the game\n', '  //this tx calculates random, generates game events, and transfers\n', '  // tokens back to winners\n', '  //in order to make game costs fair, the frontend should randomly select\n', '  // one of the two players and give them the reveal to generate the game\n', '  // in a bit you could give it to the other player too .... then after the\n', '  // timeout, they would get the secret to drain the stack\n', '  function generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\n', '    //verify that receipts are valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\n', '\n', '    //verify we are on a later block so random will work\n', '    require( uint32(block.number) > commitBlock[_commit][msg.sender]);\n', '    require( uint32(block.number) > commitBlock[_commit][_opponent]);\n', '\n', '    //verify that the reveal is correct\n', '    require(_commit == keccak256(_reveal));\n', '\n', '    //make sure there are exactly two stacks submitted\n', '    require(stacksTransferred[_commit]==2);\n', '\n', '    _generateGame(_commit,_reveal,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\n', '  }\n', '\n', '  function _generateGame(bytes32 _commit,bytes32 _reveal,address _opponent,uint[10] _tokens) internal {\n', '    //create Cryptogs contract for transfers\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    //generate the random using commit / reveal and blockhash from future (now past) block\n', '    bytes32[4] memory pseudoRandoms = _generateRandom(_reveal,commitBlock[_commit][msg.sender],commitBlock[_commit][_opponent]);\n', '\n', '    bool whosTurn = uint8(pseudoRandoms[0][0])%2==0;\n', '    CoinFlip(_commit,whosTurn,whosTurn ? msg.sender : _opponent);\n', '    for(uint8 round=1;round<=MAXROUNDS;round++){\n', '      for(uint8 i=1;i<=10;i++){\n', '        //first check and see if this token has flipped yet\n', '        if(_tokens[i-1]>0){\n', '\n', '          //get the random byte between 0-255 from our pseudoRandoms array of bytes32\n', '          uint8 rand = _getRandom(pseudoRandoms,(round-1)*10 + i);\n', '\n', '          uint8 threshold = (FLIPPINESS+round*FLIPPINESSROUNDBONUS);\n', '          if( rand < threshold || round==MAXROUNDS ){\n', '            _flip(_commit,round,cryptogsContract,_tokens,i-1,_opponent,whosTurn);\n', '          }\n', '        }\n', '      }\n', '      whosTurn = !whosTurn;\n', '    }\n', '\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    delete commitReceipt[_commit][_opponent];\n', '\n', '    GenerateGame(_commit,msg.sender);\n', '  }\n', '  event CoinFlip(bytes32 indexed _commit,bool _result,address _winner);\n', '  event GenerateGame(bytes32 indexed _commit,address indexed _sender);\n', '\n', '  function _getRandom(bytes32[4] pseudoRandoms,uint8 randIndex) internal returns (uint8 rand){\n', '    if(randIndex<32){\n', '      rand = uint8(pseudoRandoms[0][randIndex]);\n', '    }else if(randIndex<64){\n', '      rand = uint8(pseudoRandoms[1][randIndex-32]);\n', '    }else if(randIndex<96){\n', '      rand = uint8(pseudoRandoms[1][randIndex-64]);\n', '    }else{\n', '      rand = uint8(pseudoRandoms[1][randIndex-96]);\n', '    }\n', '    return rand;\n', '  }\n', '\n', '  function _generateRandom(bytes32 _reveal, uint32 block1,uint32 block2) internal returns(bytes32[4] pseudoRandoms){\n', '    pseudoRandoms[0] = keccak256(_reveal,block.blockhash(max(block1,block2)));\n', '    pseudoRandoms[1] = keccak256(pseudoRandoms[0]);\n', '    pseudoRandoms[2] = keccak256(pseudoRandoms[1]);\n', '    pseudoRandoms[3] = keccak256(pseudoRandoms[2]);\n', '    return pseudoRandoms;\n', '  }\n', '\n', '  function max(uint32 a, uint32 b) private pure returns (uint32) {\n', '      return a > b ? a : b;\n', '  }\n', '\n', '  function _flip(bytes32 _commit,uint8 round,NFT cryptogsContract,uint[10] _tokens,uint8 tokenIndex,address _opponent,bool whosTurn) internal {\n', '    address flipper;\n', '    if(whosTurn) {\n', '      flipper=msg.sender;\n', '    }else{\n', '      flipper=_opponent;\n', '    }\n', '    cryptogsContract.transfer(flipper,_tokens[tokenIndex]);\n', '    Flip(_commit,round,flipper,_tokens[tokenIndex]);\n', '    _tokens[tokenIndex]=0;\n', '  }\n', '  event Flip(bytes32 indexed _commit,uint8 _round,address indexed _flipper,uint indexed _token);\n', '\n', '  //if the game times out without either player generating the game,\n', '  // (the frontend should have selected one of the players randomly to generate the game)\n', '  //the frontend should give the other player the secret to drain the game\n', '  // secret -> reveal -> commit\n', '  function drainGame(bytes32 _commit,bytes32 _secret,address _opponent,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5,uint _token6, uint _token7, uint _token8, uint _token9, uint _token10){\n', '    //verify that receipts are valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '    require( commitReceipt[_commit][_opponent] == keccak256(_commit,_opponent,_token6,_token7,_token8,_token9,_token10) );\n', '\n', '    //verify we are on a later block so random will work\n', '    require( uint32(block.number) > commitBlock[_commit][msg.sender]+BLOCKTIMEOUT);\n', '    require( uint32(block.number) > commitBlock[_commit][_opponent]+BLOCKTIMEOUT);\n', '\n', '    //make sure the commit is the doublehash of the secret\n', '    require(_commit == keccak256(keccak256(_secret)));\n', '\n', '    //make sure there are exactly two stacks submitted\n', '    require(stacksTransferred[_commit]==2);\n', '\n', '    _drainGame(_commit,_opponent,[_token1,_token2,_token3,_token4,_token5,_token6,_token7,_token8,_token9,_token10]);\n', '  }\n', '\n', '  function _drainGame(bytes32 _commit,address _opponent, uint[10] _tokens) internal {\n', '    //create Cryptogs contract for transfers\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    cryptogsContract.transfer(msg.sender,_tokens[0]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[1]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[2]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[3]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[4]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[5]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[6]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[7]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[8]);\n', '    cryptogsContract.transfer(msg.sender,_tokens[9]);\n', '\n', '    Flip(_commit,1,msg.sender,_tokens[0]);\n', '    Flip(_commit,1,msg.sender,_tokens[1]);\n', '    Flip(_commit,1,msg.sender,_tokens[2]);\n', '    Flip(_commit,1,msg.sender,_tokens[3]);\n', '    Flip(_commit,1,msg.sender,_tokens[4]);\n', '    Flip(_commit,1,msg.sender,_tokens[5]);\n', '    Flip(_commit,1,msg.sender,_tokens[6]);\n', '    Flip(_commit,1,msg.sender,_tokens[7]);\n', '    Flip(_commit,1,msg.sender,_tokens[8]);\n', '    Flip(_commit,1,msg.sender,_tokens[9]);\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    delete commitReceipt[_commit][_opponent];\n', '    DrainGame(_commit,msg.sender);\n', '  }\n', '  event DrainGame(bytes32 indexed _commit,address indexed _sender);\n', '\n', '  //if only one player ever ends up submitting a stack, they need to be able\n', '  //to pull thier tokens back\n', '  function revokeStack(bytes32 _commit,uint _token1, uint _token2, uint _token3, uint _token4, uint _token5){\n', '    //verify that receipt is valid\n', '    require( commitReceipt[_commit][msg.sender] == keccak256(_commit,msg.sender,_token1,_token2,_token3,_token4,_token5) );\n', '\n', '    //make sure there is exactly one stacks submitted\n', '    require(stacksTransferred[_commit]==1);\n', '\n', '    stacksTransferred[_commit]=0;\n', '\n', '    NFT cryptogsContract = NFT(cryptogsAddress);\n', '\n', '    cryptogsContract.transfer(msg.sender,_token1);\n', '    cryptogsContract.transfer(msg.sender,_token2);\n', '    cryptogsContract.transfer(msg.sender,_token3);\n', '    cryptogsContract.transfer(msg.sender,_token4);\n', '    cryptogsContract.transfer(msg.sender,_token5);\n', '\n', '\n', '    bytes32 previousReceipt = commitReceipt[_commit][msg.sender];\n', '\n', '    delete commitReceipt[_commit][msg.sender];\n', '    //fire an event for the frontend\n', '    RevokeStack(_commit,msg.sender,now,_token1,_token2,_token3,_token4,_token5,previousReceipt);\n', '  }\n', '  event RevokeStack(bytes32 indexed _commit,address indexed _sender,uint _timestamp,uint256 _token1,uint256 _token2,uint256 _token3,uint256 _token4,uint256 _token5,bytes32 _receipt);\n', '\n', '}\n', '\n', 'contract NFT {\n', '  function approve(address _to,uint256 _tokenId) public returns (bool) { }\n', '  function transfer(address _to,uint256 _tokenId) external { }\n', '  mapping (uint256 => address) public tokenIndexToOwner;\n', '}']
