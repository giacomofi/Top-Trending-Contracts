['pragma solidity 0.4.24;\n', 'pragma experimental "v0.5.0";\n', '\n', '/*\n', '\n', '    Copyright 2018 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', '// File: canonical-weth/contracts/WETH9.sol\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() external payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        emit Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '\n', '  function max256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/lib/AccessControlledBase.sol\n', '\n', '/**\n', ' * @title AccessControlledBase\n', ' * @author dYdX\n', ' *\n', ' * Base functionality for access control. Requires an implementation to\n', ' * provide a way to grant and optionally revoke access\n', ' */\n', 'contract AccessControlledBase {\n', '    // ============ State Variables ============\n', '\n', '    mapping (address => bool) public authorized;\n', '\n', '    // ============ Events ============\n', '\n', '    event AccessGranted(\n', '        address who\n', '    );\n', '\n', '    event AccessRevoked(\n', '        address who\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier requiresAuthorization() {\n', '        require(\n', '            authorized[msg.sender],\n', '            "AccessControlledBase#requiresAuthorization: Sender not authorized"\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/StaticAccessControlled.sol\n', '\n', '/**\n', ' * @title StaticAccessControlled\n', ' * @author dYdX\n', ' *\n', ' * Allows for functions to be access controled\n', ' * Permissions cannot be changed after a grace period\n', ' */\n', 'contract StaticAccessControlled is AccessControlledBase, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Timestamp after which no additional access can be granted\n', '    uint256 public GRACE_PERIOD_EXPIRATION;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        Ownable()\n', '    {\n', '        GRACE_PERIOD_EXPIRATION = block.timestamp.add(gracePeriod);\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function grantAccess(\n', '        address who\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            block.timestamp < GRACE_PERIOD_EXPIRATION,\n', '            "StaticAccessControlled#grantAccess: Cannot grant access after grace period"\n', '        );\n', '\n', '        emit AccessGranted(who);\n', '        authorized[who] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/GeneralERC20.sol\n', '\n', '/**\n', ' * @title GeneralERC20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', ' * that we dont automatically revert when calling non-compliant tokens that have no return value for\n', ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface GeneralERC20 {\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/TokenInteract.sol\n', '\n', '/**\n', ' * @title TokenInteract\n', ' * @author dYdX\n', ' *\n', ' * This library contains functions for interacting with ERC20 tokens\n', ' */\n', 'library TokenInteract {\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        GeneralERC20(token).approve(spender, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#approve: Approval failed"\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        address from = address(this);\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transfer(to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transfer: Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transferFrom(from, to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transferFrom: TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/TokenProxy.sol\n', '\n', '/**\n', ' * @title TokenProxy\n', ' * @author dYdX\n', ' *\n', ' * Used to transfer tokens between addresses which have set allowance on this contract.\n', ' */\n', 'contract TokenProxy is StaticAccessControlled {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {}\n', '\n', '    // ============ Authorized-Only State Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy) to another address.\n', '     *\n', '     * @param  token  The address of the ERC20 token\n', '     * @param  from   The address to transfer token from\n', '     * @param  to     The address to transfer tokens to\n', '     * @param  value  The number of tokens to transfer\n', '     */\n', '    function transferTokens(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        TokenInteract.transferFrom(\n', '            token,\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Getter function to get the amount of token that the proxy is able to move for a particular\n', '     * address. The minimum of 1) the balance of that address and 2) the allowance given to proxy.\n', '     *\n', '     * @param  who    The owner of the tokens\n', '     * @param  token  The address of the ERC20 token\n', '     * @return        The number of tokens able to be moved by the proxy from the address specified\n', '     */\n', '    function available(\n', '        address who,\n', '        address token\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return Math.min256(\n', '            TokenInteract.allowance(token, who, address(this)),\n', '            TokenInteract.balanceOf(token, who)\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Vault.sol\n', '\n', '/**\n', ' * @title Vault\n', ' * @author dYdX\n', ' *\n', ' * Holds and transfers tokens in vaults denominated by id\n', ' *\n', ' * Vault only supports ERC20 tokens, and will not accept any tokens that require\n', ' * a tokenFallback or equivalent function (See ERC223, ERC777, etc.)\n', ' */\n', 'contract Vault is StaticAccessControlled\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event ExcessTokensWithdrawn(\n', '        address indexed token,\n', '        address indexed to,\n', '        address caller\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Address of the TokenProxy contract. Used for moving tokens.\n', '    address public TOKEN_PROXY;\n', '\n', '    // Map from vault ID to map from token address to amount of that token attributed to the\n', '    // particular vault ID.\n', '    mapping (bytes32 => mapping (address => uint256)) public balances;\n', '\n', '    // Map from token address to total amount of that token attributed to some account.\n', '    mapping (address => uint256) public totalBalances;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address proxy,\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {\n', '        TOKEN_PROXY = proxy;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n', '     * including (but not limited-to) token airdrops. Any tokens moved to the vault by TOKEN_PROXY\n', '     * will be accounted for and will not be withdrawable by this function.\n', '     *\n', '     * @param  token  ERC20 token address\n', '     * @param  to     Address to transfer tokens to\n', '     * @return        Amount of tokens withdrawn\n', '     */\n', '    function withdrawExcessToken(\n', '        address token,\n', '        address to\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        uint256 actualBalance = TokenInteract.balanceOf(token, address(this));\n', '        uint256 accountedBalance = totalBalances[token];\n', '        uint256 withdrawableBalance = actualBalance.sub(accountedBalance);\n', '\n', '        require(\n', '            withdrawableBalance != 0,\n', '            "Vault#withdrawExcessToken: Withdrawable token amount must be non-zero"\n', '        );\n', '\n', '        TokenInteract.transfer(token, to, withdrawableBalance);\n', '\n', '        emit ExcessTokensWithdrawn(token, to, msg.sender);\n', '\n', '        return withdrawableBalance;\n', '    }\n', '\n', '    // ============ Authorized-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has approved the proxy) to the vault.\n', '     *\n', '     * @param  id      The vault which will receive the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  from    Address from which the tokens will be taken\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferToVault(\n', '        bytes32 id,\n', '        address token,\n', '        address from,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // First send tokens to this contract\n', '        TokenProxy(TOKEN_PROXY).transferTokens(\n', '            token,\n', '            from,\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        // Then increment balances\n', '        balances[id][token] = balances[id][token].add(amount);\n', '        totalBalances[token] = totalBalances[token].add(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        validateBalance(token);\n', '    }\n', '\n', '    /**\n', '     * Transfers a certain amount of funds to an address.\n', '     *\n', '     * @param  id      The vault from which to send the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  to      Address to transfer tokens to\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferFromVault(\n', '        bytes32 id,\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // Next line also asserts that (balances[id][token] >= amount);\n', '        balances[id][token] = balances[id][token].sub(amount);\n', '\n', '        // Next line also asserts that (totalBalances[token] >= amount);\n', '        totalBalances[token] = totalBalances[token].sub(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        // Do the sending\n', '        TokenInteract.transfer(token, to, amount); // asserts transfer succeeded\n', '\n', '        // Final validation\n', '        validateBalance(token);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Verifies that this contract is in control of at least as many tokens as accounted for\n', '     *\n', '     * @param  token  Address of ERC20 token\n', '     */\n', '    function validateBalance(\n', '        address token\n', '    )\n', '        private\n', '        view\n', '    {\n', '        // The actual balance could be greater than totalBalances[token] because anyone\n', '        // can send tokens to the contract&#39;s address which cannot be accounted for\n', '        assert(TokenInteract.balanceOf(token, address(this)) >= totalBalances[token]);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author dYdX\n', ' *\n', ' * Optimized version of the well-known ReentrancyGuard contract\n', ' */\n', 'contract ReentrancyGuard {\n', '    uint256 private _guardCounter = 1;\n', '\n', '    modifier nonReentrant() {\n', '        uint256 localCounter = _guardCounter + 1;\n', '        _guardCounter = localCounter;\n', '        _;\n', '        require(\n', '            _guardCounter == localCounter,\n', '            "Reentrancy check failure"\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/lib/Fraction.sol\n', '\n', '/**\n', ' * @title Fraction\n', ' * @author dYdX\n', ' *\n', ' * This library contains implementations for fraction structs.\n', ' */\n', 'library Fraction {\n', '    struct Fraction128 {\n', '        uint128 num;\n', '        uint128 den;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FractionMath.sol\n', '\n', '/**\n', ' * @title FractionMath\n', ' * @author dYdX\n', ' *\n', ' * This library contains safe math functions for manipulating fractions.\n', ' */\n', 'library FractionMath {\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint128;\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a + b\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (sum)\n', '     */\n', '    function add(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 left = a.num.mul(b.den);\n', '        uint256 right = b.num.mul(a.den);\n', '        uint256 denominator = a.den.mul(b.den);\n', '\n', '        // if left + right overflows, prevent overflow\n', '        if (left + right < left) {\n', '            left = left.div(2);\n', '            right = right.div(2);\n', '            denominator = denominator.div(2);\n', '        }\n', '\n', '        return bound(left.add(right), denominator);\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a - (1/2)^d\n', '     *\n', '     * @param  a  The Fraction128\n', '     * @param  d  The power of (1/2)\n', '     * @return    The result\n', '     */\n', '    function sub1Over(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.den % d == 0) {\n', '            return bound(\n', '                a.num.sub(a.den.div(d)),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num.mul(d).sub(a.den),\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a / d\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  d  The divisor\n', '     * @return    The result (quotient)\n', '     */\n', '    function div(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.num % d == 0) {\n', '            return bound(\n', '                a.num.div(d),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num,\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a * b.\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (product)\n', '     */\n', '    function mul(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return bound(\n', '            a.num.mul(b.num),\n', '            a.den.mul(b.den)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction from two uint256&#39;s. Fits them into uint128 if necessary.\n', '     *\n', '     * @param  num  The numerator\n', '     * @param  den  The denominator\n', '     * @return      The Fraction128 that matches num/den most closely\n', '     */\n', '    /* solium-disable-next-line security/no-assign-params */\n', '    function bound(\n', '        uint256 num,\n', '        uint256 den\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 max = num > den ? num : den;\n', '        uint256 first128Bits = (max >> 128);\n', '        if (first128Bits != 0) {\n', '            first128Bits += 1;\n', '            num /= first128Bits;\n', '            den /= first128Bits;\n', '        }\n', '\n', '        assert(den != 0); // coverage-enable-line\n', '        assert(den < 2**128);\n', '        assert(num < 2**128);\n', '\n', '        return Fraction.Fraction128({\n', '            num: uint128(num),\n', '            den: uint128(den)\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns an in-memory copy of a Fraction128\n', '     *\n', '     * @param  a  The Fraction128 to copy\n', '     * @return    A copy of the Fraction128\n', '     */\n', '    function copy(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        validate(a);\n', '        return Fraction.Fraction128({ num: a.num, den: a.den });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\n', '     *\n', '     * @param  a  The Fraction128 to validate\n', '     */\n', '    function validate(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        assert(a.den != 0); // coverage-enable-line\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Exponent.sol\n', '\n', '/**\n', ' * @title Exponent\n', ' * @author dYdX\n', ' *\n', ' * This library contains an implementation for calculating e^X for arbitrary fraction X\n', ' */\n', 'library Exponent {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    // 2**128 - 1\n', '    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\n', '\n', '    // Number of precomputed integers, X, for E^((1/2)^X)\n', '    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\n', '\n', '    // Number of precomputed integers, X, for E^X\n', '    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns e^X for any fraction X\n', '     *\n', '     * @param  X                    The exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function exp(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        require(\n', '            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\n', '            "Exponent#exp: Precompute precision over maximum"\n', '        );\n', '\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\n', '        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\n', '\n', '        // if X is less than 1, then just calculate X\n', '        if (integerX == 0) {\n', '            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\n', '        }\n', '\n', '        // get e^integerX\n', '        Fraction.Fraction128 memory expOfInt =\n', '            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\n', '        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\n', '            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\n', '            integerX -= NUM_PRECOMPUTED_INTEGERS;\n', '        }\n', '\n', '        // multiply e^integerX by e^decimalX\n', '        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\n', '            num: Xcopy.num % Xcopy.den,\n', '            den: Xcopy.den\n', '        });\n', '        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\n', '     * Maclaurin Series approximation to reduce error.\n', '     *\n', '     * @param  X                    Exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function expHybrid(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\n', '        assert(X.num < X.den);\n', '        // will also throw if precomputePrecision is larger than the array length in getDenominator\n', '\n', '        Fraction.Fraction128 memory Xtemp = X.copy();\n', '        if (Xtemp.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '\n', '        uint256 d = 1; // 2^i\n', '        for (uint256 i = 1; i <= precomputePrecision; i++) {\n', '            d *= 2;\n', '\n', '            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\n', '            if (d.mul(Xtemp.num) >= Xtemp.den) {\n', '                Xtemp = Xtemp.sub1Over(uint128(d));\n', '                result = result.mul(getPrecomputedEToTheHalfToThe(i));\n', '            }\n', '        }\n', '        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X, using Maclaurin Series approximation\n', '     *\n', '     * e^X = SUM(X^n / n!) for n >= 0\n', '     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\n', '     *\n', '     * @param  X           Exponent\n', '     * @param  precision   Accuracy of Maclaurin terms\n', '     * @return             e^X\n', '     */\n', '    function expMaclaurin(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '        Fraction.Fraction128 memory Xtemp = ONE();\n', '        for (uint256 i = 1; i <= precision; i++) {\n', '            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\n', '            result = result.add(Xtemp);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\n', '     */\n', '    function getPrecomputedEToTheHalfToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= MAX_PRECOMPUTE_PRECISION);\n', '\n', '        uint128 denominator = [\n', '            125182886983370532117250726298150828301,\n', '            206391688497133195273760705512282642279,\n', '            265012173823417992016237332255925138361,\n', '            300298134811882980317033350418940119802,\n', '            319665700530617779809390163992561606014,\n', '            329812979126047300897653247035862915816,\n', '            335006777809430963166468914297166288162,\n', '            337634268532609249517744113622081347950,\n', '            338955731696479810470146282672867036734,\n', '            339618401537809365075354109784799900812,\n', '            339950222128463181389559457827561204959,\n', '            340116253979683015278260491021941090650,\n', '            340199300311581465057079429423749235412,\n', '            340240831081268226777032180141478221816,\n', '            340261598367316729254995498374473399540,\n', '            340271982485676106947851156443492415142,\n', '            340277174663693808406010255284800906112,\n', '            340279770782412691177936847400746725466,\n', '            340281068849199706686796915841848278311,\n', '            340281717884450116236033378667952410919,\n', '            340282042402539547492367191008339680733,\n', '            340282204661700319870089970029119685699,\n', '            340282285791309720262481214385569134454,\n', '            340282326356121674011576912006427792656,\n', '            340282346638529464274601981200276914173,\n', '            340282356779733812753265346086924801364,\n', '            340282361850336100329388676752133324799,\n', '            340282364385637272451648746721404212564,\n', '            340282365653287865596328444437856608255,\n', '            340282366287113163939555716675618384724,\n', '            340282366604025813553891209601455838559,\n', '            340282366762482138471739420386372790954,\n', '            340282366841710300958333641874363209044\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^(x) for integer x\n', '     */\n', '    function getPrecomputedEToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= NUM_PRECOMPUTED_INTEGERS);\n', '\n', '        uint128 denominator = [\n', '            340282366920938463463374607431768211455,\n', '            125182886983370532117250726298150828301,\n', '            46052210507670172419625860892627118820,\n', '            16941661466271327126146327822211253888,\n', '            6232488952727653950957829210887653621,\n', '            2292804553036637136093891217529878878,\n', '            843475657686456657683449904934172134,\n', '            310297353591408453462393329342695980,\n', '            114152017036184782947077973323212575,\n', '            41994180235864621538772677139808695,\n', '            15448795557622704876497742989562086,\n', '            5683294276510101335127414470015662,\n', '            2090767122455392675095471286328463,\n', '            769150240628514374138961856925097,\n', '            282954560699298259527814398449860,\n', '            104093165666968799599694528310221,\n', '            38293735615330848145349245349513,\n', '            14087478058534870382224480725096,\n', '            5182493555688763339001418388912,\n', '            1906532833141383353974257736699,\n', '            701374233231058797338605168652,\n', '            258021160973090761055471434334,\n', '            94920680509187392077350434438,\n', '            34919366901332874995585576427,\n', '            12846117181722897538509298435,\n', '            4725822410035083116489797150,\n', '            1738532907279185132707372378,\n', '            639570514388029575350057932,\n', '            235284843422800231081973821,\n', '            86556456714490055457751527,\n', '            31842340925906738090071268,\n', '            11714142585413118080082437,\n', '            4309392228124372433711936\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function ONE()\n', '        private\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return Fraction.Fraction128({ num: 1, den: 1 });\n', '    }\n', '}\n', '\n', '// File: contracts/lib/MathHelpers.sol\n', '\n', '/**\n', ' * @title MathHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with common math functions in Solidity\n', ' */\n', 'library MathHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              target * numerator / denominator\n', '     */\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              Rounded-up result of target * numerator / denominator\n', '     */\n', '    function getPartialAmountRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return divisionRoundedUp(numerator.mul(target), denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates division given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator.\n', '     * @param  denominator  Denominator.\n', '     * @return              Rounded-up result of numerator / denominator\n', '     */\n', '    function divisionRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(denominator != 0); // coverage-enable-line\n', '        if (numerator == 0) {\n', '            return 0;\n', '        }\n', '        return numerator.sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint256(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint32(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        return 2 ** 32 - 1;\n', '    }\n', '\n', '    /**\n', '     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n', '     *\n', '     * @param  n  The uint256 to get the number of bits in\n', '     * @return    The number of bits in n\n', '     */\n', '    function getNumBits(\n', '        uint256 n\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 first = 0;\n', '        uint256 last = 256;\n', '        while (first < last) {\n', '            uint256 check = (first + last) / 2;\n', '            if ((n >> check) == 0) {\n', '                last = check;\n', '            } else {\n', '                first = check + 1;\n', '            }\n', '        }\n', '        assert(first <= 256);\n', '        return first;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/InterestImpl.sol\n', '\n', '/**\n', ' * @title InterestImpl\n', ' * @author dYdX\n', ' *\n', ' * A library that calculates continuously compounded interest for principal, time period, and\n', ' * interest rate.\n', ' */\n', 'library InterestImpl {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\n', '\n', '    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\n', '\n', '    uint256 constant MAXIMUM_EXPONENT = 80;\n', '\n', '    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\n', '     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\n', '     * I = P * e^(R*T)\n', '     *\n', '     * @param  principal           Principal of the interest calculation\n', '     * @param  interestRate        Annual nominal interest percentage times 10**6.\n', '     *                             (example: 5% = 5e6)\n', '     * @param  secondsOfInterest   Number of seconds that interest has been accruing\n', '     * @return                     Total amount of tokens owed. Greater than tokenAmount.\n', '     */\n', '    function getCompoundedInterest(\n', '        uint256 principal,\n', '        uint256 interestRate,\n', '        uint256 secondsOfInterest\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 numerator = interestRate.mul(secondsOfInterest);\n', '        uint128 denominator = (10**8) * (365 * 1 days);\n', '\n', '        // interestRate and secondsOfInterest should both be uint32\n', '        assert(numerator < 2**128);\n', '\n', '        // fraction representing (Rate * Time)\n', '        Fraction.Fraction128 memory rt = Fraction.Fraction128({\n', '            num: uint128(numerator),\n', '            den: denominator\n', '        });\n', '\n', '        // calculate e^(RT)\n', '        Fraction.Fraction128 memory eToRT;\n', '        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\n', '            // degenerate case: cap calculation\n', '            eToRT = Fraction.Fraction128({\n', '                num: E_TO_MAXIUMUM_EXPONENT,\n', '                den: 1\n', '            });\n', '        } else {\n', '            // normal case: calculate e^(RT)\n', '            eToRT = Exponent.exp(\n', '                rt,\n', '                DEFAULT_PRECOMPUTE_PRECISION,\n', '                DEFAULT_MACLAURIN_PRECISION\n', '            );\n', '        }\n', '\n', '        // e^X for positive X should be greater-than or equal to 1\n', '        assert(eToRT.num >= eToRT.den);\n', '\n', '        return safeMultiplyUint256ByFraction(principal, eToRT);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\n', '     * and denominator of f are less than 2**128.\n', '     */\n', '    function safeMultiplyUint256ByFraction(\n', '        uint256 n,\n', '        Fraction.Fraction128 memory f\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 term1 = n.div(2 ** 128); // first 128 bits\n', '        uint256 term2 = n % (2 ** 128); // second 128 bits\n', '\n', '        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\n', '        if (term1 > 0) {\n', '            term1 = term1.mul(f.num);\n', '            uint256 numBits = MathHelpers.getNumBits(term1);\n', '\n', '            // reduce rounding error by shifting all the way to the left before dividing\n', '            term1 = MathHelpers.divisionRoundedUp(\n', '                term1 << (uint256(256).sub(numBits)),\n', '                f.den);\n', '\n', '            // continue shifting or reduce shifting to get the right number\n', '            if (numBits > 128) {\n', '                term1 = term1 << (numBits.sub(128));\n', '            } else if (numBits < 128) {\n', '                term1 = term1 >> (uint256(128).sub(numBits));\n', '            }\n', '        }\n', '\n', '        // calculates term2 = term2 * f\n', '        term2 = MathHelpers.getPartialAmountRoundedUp(\n', '            f.num,\n', '            f.den,\n', '            term2\n', '        );\n', '\n', '        return term1.add(term2);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginState.sol\n', '\n', '/**\n', ' * @title MarginState\n', ' * @author dYdX\n', ' *\n', ' * Contains state for the Margin contract. Also used by libraries that implement Margin functions.\n', ' */\n', 'library MarginState {\n', '    struct State {\n', '        // Address of the Vault contract\n', '        address VAULT;\n', '\n', '        // Address of the TokenProxy contract\n', '        address TOKEN_PROXY;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been filled.\n', '        mapping (bytes32 => uint256) loanFills;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been canceled.\n', '        mapping (bytes32 => uint256) loanCancels;\n', '\n', '        // Mapping from positionId -> Position, which stores all the open margin positions.\n', '        mapping (bytes32 => MarginCommon.Position) positions;\n', '\n', '        // Mapping from positionId -> bool, which stores whether the position has previously been\n', '        // open, but is now closed.\n', '        mapping (bytes32 => bool) closedPositions;\n', '\n', '        // Mapping from positionId -> uint256, which stores the total amount of owedToken that has\n', '        // ever been repaid to the lender for each position. Does not reset.\n', '        mapping (bytes32 => uint256) totalOwedTokenRepaidToLender;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/LoanOwner.sol\n', '\n', '/**\n', ' * @title LoanOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a loan sell via the\n', '     * transferLoan function or the atomic-assign to the "owner" field in a loan offering.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receiveLoanOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/PositionOwner.sol\n', '\n', '/**\n', ' * @title PositionOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PositionOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a position via the\n', '     * transferPosition function or the atomic-assign to the "owner" field when opening a position.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receivePositionOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/TransferInternal.sol\n', '\n', '/**\n', ' * @title TransferInternal\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for transferring ownership of loans and positions.\n', ' */\n', 'library TransferInternal {\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a postion was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Returns either the address of the new loan owner, or the address to which they wish to\n', '     * pass ownership of the loan. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the loan\n', '     * @param  newOwner    The intended owner of the loan\n', '     * @return             The address that the intended owner wishes to assign the loan to (may be\n', '     *                     the same as the intended owner).\n', '     */\n', '    function grantLoanOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit LoanTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                LoanOwner(newOwner).receiveLoanOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantLoanOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantLoanOwnership: New owner did not consent to owning loan"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '\n', '    /**\n', '     * Returns either the address of the new position owner, or the address to which they wish to\n', '     * pass ownership of the position. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the position\n', '     * @param  newOwner    The intended owner of the position\n', '     * @return             The address that the intended owner wishes to assign the position to (may\n', '     *                     be the same as the intended owner).\n', '     */\n', '    function grantPositionOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit PositionTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                PositionOwner(newOwner).receivePositionOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantPositionOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantPositionOwnership: New owner did not consent to owning position"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TimestampHelper.sol\n', '\n', '/**\n', ' * @title TimestampHelper\n', ' * @author dYdX\n', ' *\n', ' * Helper to get block timestamps in other formats\n', ' */\n', 'library TimestampHelper {\n', '    function getBlockTimestamp32()\n', '        internal\n', '        view\n', '        returns (uint32)\n', '    {\n', '        // Should not still be in-use in the year 2106\n', '        assert(uint256(uint32(block.timestamp)) == block.timestamp);\n', '\n', '        assert(block.timestamp > 0);\n', '\n', '        return uint32(block.timestamp);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginCommon.sol\n', '\n', '/**\n', ' * @title MarginCommon\n', ' * @author dYdX\n', ' *\n', ' * This library contains common functions for implementations of public facing Margin functions\n', ' */\n', 'library MarginCommon {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Position {\n', '        address owedToken;       // Immutable\n', '        address heldToken;       // Immutable\n', '        address lender;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 requiredDeposit;\n', '        uint32  callTimeLimit;   // Immutable\n', '        uint32  startTimestamp;  // Immutable, cannot be 0\n', '        uint32  callTimestamp;\n', '        uint32  maxDuration;     // Immutable\n', '        uint32  interestRate;    // Immutable\n', '        uint32  interestPeriod;  // Immutable\n', '    }\n', '\n', '    struct LoanOffering {\n', '        address   owedToken;\n', '        address   heldToken;\n', '        address   payer;\n', '        address   owner;\n', '        address   taker;\n', '        address   positionOwner;\n', '        address   feeRecipient;\n', '        address   lenderFeeToken;\n', '        address   takerFeeToken;\n', '        LoanRates rates;\n', '        uint256   expirationTimestamp;\n', '        uint32    callTimeLimit;\n', '        uint32    maxDuration;\n', '        uint256   salt;\n', '        bytes32   loanHash;\n', '        bytes     signature;\n', '    }\n', '\n', '    struct LoanRates {\n', '        uint256 maxAmount;\n', '        uint256 minAmount;\n', '        uint256 minHeldToken;\n', '        uint256 lenderFee;\n', '        uint256 takerFee;\n', '        uint32  interestRate;\n', '        uint32  interestPeriod;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function storeNewPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        Position memory position,\n', '        address loanPayer\n', '    )\n', '        internal\n', '    {\n', '        assert(!positionHasExisted(state, positionId));\n', '        assert(position.owedToken != address(0));\n', '        assert(position.heldToken != address(0));\n', '        assert(position.owedToken != position.heldToken);\n', '        assert(position.owner != address(0));\n', '        assert(position.lender != address(0));\n', '        assert(position.maxDuration != 0);\n', '        assert(position.interestPeriod <= position.maxDuration);\n', '        assert(position.callTimestamp == 0);\n', '        assert(position.requiredDeposit == 0);\n', '\n', '        state.positions[positionId].owedToken = position.owedToken;\n', '        state.positions[positionId].heldToken = position.heldToken;\n', '        state.positions[positionId].principal = position.principal;\n', '        state.positions[positionId].callTimeLimit = position.callTimeLimit;\n', '        state.positions[positionId].startTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        state.positions[positionId].maxDuration = position.maxDuration;\n', '        state.positions[positionId].interestRate = position.interestRate;\n', '        state.positions[positionId].interestPeriod = position.interestPeriod;\n', '\n', '        state.positions[positionId].owner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            (position.owner != msg.sender) ? msg.sender : address(0),\n', '            position.owner\n', '        );\n', '\n', '        state.positions[positionId].lender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            (position.lender != loanPayer) ? loanPayer : address(0),\n', '            position.lender\n', '        );\n', '    }\n', '\n', '    function getPositionIdFromNonce(\n', '        uint256 nonce\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked(msg.sender, nonce));\n', '    }\n', '\n', '    function getUnavailableLoanOfferingAmountImpl(\n', '        MarginState.State storage state,\n', '        bytes32 loanHash\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash].add(state.loanCancels[loanHash]);\n', '    }\n', '\n', '    function cleanupPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '    {\n', '        delete state.positions[positionId];\n', '        state.closedPositions[positionId] = true;\n', '    }\n', '\n', '    function calculateOwedAmount(\n', '        Position storage position,\n', '        uint256 closeAmount,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsed(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            closeAmount,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Calculates time elapsed rounded up to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsed(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round up to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = MathHelpers.divisionRoundedUp(elapsed, period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function calculateLenderAmountForIncreasePosition(\n', '        Position storage position,\n', '        uint256 principalToAdd,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsedForNewLender(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            principalToAdd,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    function getLoanOfferingHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                loanOffering.owedToken,\n', '                loanOffering.heldToken,\n', '                loanOffering.payer,\n', '                loanOffering.owner,\n', '                loanOffering.taker,\n', '                loanOffering.positionOwner,\n', '                loanOffering.feeRecipient,\n', '                loanOffering.lenderFeeToken,\n', '                loanOffering.takerFeeToken,\n', '                getValuesHash(loanOffering)\n', '            )\n', '        );\n', '    }\n', '\n', '    function getPositionBalanceImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Vault(state.VAULT).balances(positionId, state.positions[positionId].heldToken);\n', '    }\n', '\n', '    function containsPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.positions[positionId].startTimestamp != 0;\n', '    }\n', '\n', '    function positionHasExisted(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return containsPositionImpl(state, positionId) || state.closedPositions[positionId];\n', '    }\n', '\n', '    function getPositionFromStorage(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (Position storage)\n', '    {\n', '        Position storage position = state.positions[positionId];\n', '\n', '        require(\n', '            position.startTimestamp != 0,\n', '            "MarginCommon#getPositionFromStorage: The position does not exist"\n', '        );\n', '\n', '        return position;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Calculates time elapsed rounded down to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsedForNewLender(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round down to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = elapsed.div(period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function getValuesHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                loanOffering.rates.maxAmount,\n', '                loanOffering.rates.minAmount,\n', '                loanOffering.rates.minHeldToken,\n', '                loanOffering.rates.lenderFee,\n', '                loanOffering.rates.takerFee,\n', '                loanOffering.expirationTimestamp,\n', '                loanOffering.salt,\n', '                loanOffering.callTimeLimit,\n', '                loanOffering.maxDuration,\n', '                loanOffering.rates.interestRate,\n', '                loanOffering.rates.interestPeriod\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/PayoutRecipient.sol\n', '\n', '/**\n', ' * @title PayoutRecipient\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to be the payoutRecipient in a\n', ' * closePosition transaction.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PayoutRecipient {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive payout from being the payoutRecipient\n', '     * in a closePosition transaction. May redistribute any payout as necessary. Throws on error.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  closeAmount        Amount of the position that was closed\n', '     * @param  closer             Address of the account or contract that closed the position\n', '     * @param  positionOwner      Address of the owner of the position\n', '     * @param  heldToken          Address of the ERC20 heldToken\n', '     * @param  payout             Number of tokens received from the payout\n', '     * @param  totalHeldToken     Total amount of heldToken removed from vault during close\n', '     * @param  payoutInHeldToken  True if payout is in heldToken, false if in owedToken\n', '     * @return                    True if approved by the receiver\n', '     */\n', '    function receiveClosePositionPayout(\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address closer,\n', '        address positionOwner,\n', '        address heldToken,\n', '        uint256 payout,\n', '        uint256 totalHeldToken,\n', '        bool    payoutInHeldToken\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CloseLoanDelegator.sol\n', '\n', '/**\n', ' * @title CloseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CloseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * closeWithoutCounterparty().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at most) the specified amount of the loan was\n', '     * successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of closeWithoutCounterparty()\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the loan to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeLoanOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/ClosePositionDelegator.sol\n', '\n', '/**\n', ' * @title ClosePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a position\n', ' * owned by the smart contract, allowing more complex logic to control positions.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ClosePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call closePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at-most) the specified amount of the position\n', '     * was successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of the closePosition() function\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the position to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionShared.sol\n', '\n', '/**\n', ' * @title ClosePositionShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between ClosePositionImpl and\n', ' * CloseWithoutCounterpartyImpl\n', ' */\n', 'library ClosePositionShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct CloseTx {\n', '        bytes32 positionId;\n', '        uint256 originalPrincipal;\n', '        uint256 closeAmount;\n', '        uint256 owedTokenOwed;\n', '        uint256 startingHeldTokenBalance;\n', '        uint256 availableHeldToken;\n', '        address payoutRecipient;\n', '        address owedToken;\n', '        address heldToken;\n', '        address positionOwner;\n', '        address positionLender;\n', '        address exchangeWrapper;\n', '        bool    payoutInHeldToken;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function closePositionStateUpdate(\n', '        MarginState.State storage state,\n', '        CloseTx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        // Delete the position, or just decrease the principal\n', '        if (transaction.closeAmount == transaction.originalPrincipal) {\n', '            MarginCommon.cleanupPosition(state, transaction.positionId);\n', '        } else {\n', '            assert(\n', '                transaction.originalPrincipal == state.positions[transaction.positionId].principal\n', '            );\n', '            state.positions[transaction.positionId].principal =\n', '                transaction.originalPrincipal.sub(transaction.closeAmount);\n', '        }\n', '    }\n', '\n', '    function sendTokensToPayoutRecipient(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 receivedOwedToken\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 payout;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            // Send remaining heldToken to payoutRecipient\n', '            payout = transaction.availableHeldToken.sub(buybackCostInHeldToken);\n', '\n', '            Vault(state.VAULT).transferFromVault(\n', '                transaction.positionId,\n', '                transaction.heldToken,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        } else {\n', '            assert(transaction.exchangeWrapper != address(0));\n', '\n', '            payout = receivedOwedToken.sub(transaction.owedTokenOwed);\n', '\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        }\n', '\n', '        if (AddressUtils.isContract(transaction.payoutRecipient)) {\n', '            require(\n', '                PayoutRecipient(transaction.payoutRecipient).receiveClosePositionPayout(\n', '                    transaction.positionId,\n', '                    transaction.closeAmount,\n', '                    msg.sender,\n', '                    transaction.positionOwner,\n', '                    transaction.heldToken,\n', '                    payout,\n', '                    transaction.availableHeldToken,\n', '                    transaction.payoutInHeldToken\n', '                ),\n', '                "ClosePositionShared#sendTokensToPayoutRecipient: Payout recipient does not consent"\n', '            );\n', '        }\n', '\n', '        // The ending heldToken balance of the vault should be the starting heldToken balance\n', '        // minus the available heldToken amount\n', '        assert(\n', '            MarginCommon.getPositionBalanceImpl(state, transaction.positionId)\n', '            == transaction.startingHeldTokenBalance.sub(transaction.availableHeldToken)\n', '        );\n', '\n', '        return payout;\n', '    }\n', '\n', '    function createCloseTx(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        internal\n', '        returns (CloseTx memory)\n', '    {\n', '        // Validate\n', '        require(\n', '            payoutRecipient != address(0),\n', '            "ClosePositionShared#createCloseTx: Payout recipient cannot be 0"\n', '        );\n', '        require(\n', '            requestedAmount > 0,\n', '            "ClosePositionShared#createCloseTx: Requested close amount cannot be 0"\n', '        );\n', '\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 closeAmount = getApprovedAmount(\n', '            position,\n', '            positionId,\n', '            requestedAmount,\n', '            payoutRecipient,\n', '            isWithoutCounterparty\n', '        );\n', '\n', '        return parseCloseTx(\n', '            state,\n', '            position,\n', '            positionId,\n', '            closeAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            isWithoutCounterparty\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function getApprovedAmount(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        bool requireLenderApproval\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // Ensure enough principal\n', '        uint256 allowedAmount = Math.min256(requestedAmount, position.principal);\n', '\n', '        // Ensure owner consent\n', '        allowedAmount = closePositionOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            payoutRecipient,\n', '            positionId,\n', '            allowedAmount\n', '        );\n', '\n', '        // Ensure lender consent\n', '        if (requireLenderApproval) {\n', '            allowedAmount = closeLoanOnBehalfOfRecurse(\n', '                position.lender,\n', '                msg.sender,\n', '                payoutRecipient,\n', '                positionId,\n', '                allowedAmount\n', '            );\n', '        }\n', '\n', '        assert(allowedAmount > 0);\n', '        assert(allowedAmount <= position.principal);\n', '        assert(allowedAmount <= requestedAmount);\n', '\n', '        return allowedAmount;\n', '    }\n', '\n', '    function closePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = ClosePositionDelegator(contractAddr).closeOnBehalfOf(\n', '            closer,\n', '            payoutRecipient,\n', '            positionId,\n', '            closeAmount\n', '        );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    function closeLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = CloseLoanDelegator(contractAddr).closeLoanOnBehalfOf(\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                closeAmount\n', '            );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closeLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseCloseTx(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        private\n', '        view\n', '        returns (CloseTx memory)\n', '    {\n', '        uint256 startingHeldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        uint256 availableHeldToken = MathHelpers.getPartialAmount(\n', '            closeAmount,\n', '            position.principal,\n', '            startingHeldTokenBalance\n', '        );\n', '        uint256 owedTokenOwed = 0;\n', '\n', '        if (!isWithoutCounterparty) {\n', '            owedTokenOwed = MarginCommon.calculateOwedAmount(\n', '                position,\n', '                closeAmount,\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        return CloseTx({\n', '            positionId: positionId,\n', '            originalPrincipal: position.principal,\n', '            closeAmount: closeAmount,\n', '            owedTokenOwed: owedTokenOwed,\n', '            startingHeldTokenBalance: startingHeldTokenBalance,\n', '            availableHeldToken: availableHeldToken,\n', '            payoutRecipient: payoutRecipient,\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            positionOwner: position.owner,\n', '            positionLender: position.lender,\n', '            exchangeWrapper: exchangeWrapper,\n', '            payoutInHeldToken: payoutInHeldToken\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n', ' * with other smart contracts through a common interface.\n', ' */\n', 'interface ExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the transaction\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionImpl.sol\n', '\n', '/**\n', ' * @title ClosePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closePosition function of Margin\n', ' */\n', 'library ClosePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool    payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bytes memory orderData\n', '    )\n', '        public\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            false\n', '        );\n', '\n', '        (\n', '            uint256 buybackCostInHeldToken,\n', '            uint256 receivedOwedToken\n', '        ) = returnOwedTokensToLender(\n', '            state,\n', '            transaction,\n', '            orderData\n', '        );\n', '\n', '        uint256 payout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            receivedOwedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnClose(\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            payout\n', '        );\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            payout,\n', '            transaction.owedTokenOwed\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function returnOwedTokensToLender(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 buybackCostInHeldToken = 0;\n', '        uint256 receivedOwedToken = 0;\n', '        uint256 lenderOwedToken = transaction.owedTokenOwed;\n', '\n', '        // Setting exchangeWrapper to 0x000... indicates owedToken should be taken directly\n', '        // from msg.sender\n', '        if (transaction.exchangeWrapper == address(0)) {\n', '            require(\n', '                transaction.payoutInHeldToken,\n', '                "ClosePositionImpl#returnOwedTokensToLender: Cannot payout in owedToken"\n', '            );\n', '\n', '            // No DEX Order; send owedTokens directly from the closer to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                msg.sender,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        } else {\n', '            // Buy back owedTokens using DEX Order and send to lender\n', '            (buybackCostInHeldToken, receivedOwedToken) = buyBackOwedToken(\n', '                state,\n', '                transaction,\n', '                orderData\n', '            );\n', '\n', '            // If no owedToken needed for payout: give lender all owedToken, even if more than owed\n', '            if (transaction.payoutInHeldToken) {\n', '                assert(receivedOwedToken >= lenderOwedToken);\n', '                lenderOwedToken = receivedOwedToken;\n', '            }\n', '\n', '            // Transfer owedToken from the exchange wrapper to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        }\n', '\n', '        state.totalOwedTokenRepaidToLender[transaction.positionId] =\n', '            state.totalOwedTokenRepaidToLender[transaction.positionId].add(lenderOwedToken);\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function buyBackOwedToken(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        // Ask the exchange wrapper the cost in heldToken to buy back the close\n', '        // amount of owedToken\n', '        uint256 buybackCostInHeldToken;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            buybackCostInHeldToken = ExchangeWrapper(transaction.exchangeWrapper)\n', '                .getExchangeCost(\n', '                    transaction.owedToken,\n', '                    transaction.heldToken,\n', '                    transaction.owedTokenOwed,\n', '                    orderData\n', '                );\n', '\n', '            // Require enough available heldToken to pay for the buyback\n', '            require(\n', '                buybackCostInHeldToken <= transaction.availableHeldToken,\n', '                "ClosePositionImpl#buyBackOwedToken: Not enough available heldToken"\n', '            );\n', '        } else {\n', '            buybackCostInHeldToken = transaction.availableHeldToken;\n', '        }\n', '\n', '        // Send the requisite heldToken to do the buyback from vault to exchange wrapper\n', '        Vault(state.VAULT).transferFromVault(\n', '            transaction.positionId,\n', '            transaction.heldToken,\n', '            transaction.exchangeWrapper,\n', '            buybackCostInHeldToken\n', '        );\n', '\n', '        // Trade the heldToken for the owedToken\n', '        uint256 receivedOwedToken = ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '            msg.sender,\n', '            state.TOKEN_PROXY,\n', '            transaction.owedToken,\n', '            transaction.heldToken,\n', '            buybackCostInHeldToken,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            receivedOwedToken >= transaction.owedTokenOwed,\n', '            "ClosePositionImpl#buyBackOwedToken: Did not receive enough owedToken"\n', '        );\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function logEventOnClose(\n', '        ClosePositionShared.CloseTx transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 payout\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            transaction.owedTokenOwed,\n', '            payout,\n', '            buybackCostInHeldToken,\n', '            transaction.payoutInHeldToken\n', '        );\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/CloseWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title CloseWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closeWithoutCounterpartyImpl function of\n', ' * Margin\n', ' */\n', 'library CloseWithoutCounterpartyImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closeWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        public\n', '        returns (uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            true\n', '        );\n', '\n', '        uint256 heldTokenPayout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            0, // No buyback cost\n', '            0  // Did not receive any owedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnCloseWithoutCounterparty(transaction);\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            heldTokenPayout\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function logEventOnCloseWithoutCounterparty(\n', '        ClosePositionShared.CloseTx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            0,\n', '            transaction.availableHeldToken,\n', '            0,\n', '            true\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/DepositCollateralDelegator.sol\n', '\n', '/**\n', ' * @title DepositCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses deposit heldTokens\n', ' * into a position owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface DepositCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call depositCollateral().\n', '     *\n', '     * @param  depositor   Address of the caller of the depositCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  amount      Requested deposit amount\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function depositCollateralOnBehalfOf(\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/DepositCollateralImpl.sol\n', '\n', '/**\n', ' * @title DepositCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the deposit function of Margin\n', ' */\n', 'library DepositCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function depositCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            depositAmount > 0,\n', '            "DepositCollateralImpl#depositCollateralImpl: Deposit amount cannot be 0"\n', '        );\n', '\n', '        // Ensure owner consent\n', '        depositCollateralOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            depositAmount\n', '        );\n', '\n', '        // cancel margin call if applicable\n', '        bool marginCallCanceled = false;\n', '        uint256 requiredDeposit = position.requiredDeposit;\n', '        if (position.callTimestamp > 0 && requiredDeposit > 0) {\n', '            if (depositAmount >= requiredDeposit) {\n', '                position.requiredDeposit = 0;\n', '                position.callTimestamp = 0;\n', '                marginCallCanceled = true;\n', '            } else {\n', '                position.requiredDeposit = position.requiredDeposit.sub(depositAmount);\n', '            }\n', '        }\n', '\n', '        emit AdditionalCollateralDeposited(\n', '            positionId,\n', '            depositAmount,\n', '            msg.sender\n', '        );\n', '\n', '        if (marginCallCanceled) {\n', '            emit MarginCallCanceled(\n', '                positionId,\n', '                position.lender,\n', '                msg.sender,\n', '                depositAmount\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function depositCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (depositor == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            DepositCollateralDelegator(contractAddr).depositCollateralOnBehalfOf(\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '\n', '        // if not equal, recurse\n', '        if (newContractAddr != contractAddr) {\n', '            depositCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/ForceRecoverCollateralDelegator.sol\n', '\n', '/**\n', ' * @title ForceRecoverCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses\n', ' * forceRecoverCollateral() a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ForceRecoverCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * forceRecoverCollateral().\n', '     *\n', '     * NOTE: If not returning zero address (or not reverting), this contract must assume that Margin\n', '     * will either revert the entire transaction or that the collateral was forcibly recovered.\n', '     *\n', '     * @param  recoverer   Address of the caller of the forceRecoverCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function forceRecoverCollateralOnBehalfOf(\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/ForceRecoverCollateralImpl.sol\n', '\n', '/**\n', ' * @title ForceRecoverCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the forceRecoverCollateral function of Margin\n', ' */\n', 'library ForceRecoverCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function forceRecoverCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Can only force recover after either:\n', '        // 1) The loan was called and the call period has elapsed\n', '        // 2) The maxDuration of the position has elapsed\n', '        require( /* solium-disable-next-line */\n', '            (\n', '                position.callTimestamp > 0\n', '                && block.timestamp >= uint256(position.callTimestamp).add(position.callTimeLimit)\n', '            ) || (\n', '                block.timestamp >= uint256(position.startTimestamp).add(position.maxDuration)\n', '            ),\n', '            "ForceRecoverCollateralImpl#forceRecoverCollateralImpl: Cannot recover yet"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        forceRecoverCollateralOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            recipient\n', '        );\n', '\n', '        // Send the tokens\n', '        uint256 heldTokenRecovered = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '        Vault(state.VAULT).transferFromVault(\n', '            positionId,\n', '            position.heldToken,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        // Delete the position\n', '        // NOTE: Since position is a storage pointer, this will also set all fields on\n', '        //       the position variable to 0\n', '        MarginCommon.cleanupPosition(\n', '            state,\n', '            positionId\n', '        );\n', '\n', '        // Log an event\n', '        emit CollateralForceRecovered(\n', '            positionId,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        return heldTokenRecovered;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function forceRecoverCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (recoverer == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            ForceRecoverCollateralDelegator(contractAddr).forceRecoverCollateralOnBehalfOf(\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            forceRecoverCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TypedSignature.sol\n', '\n', '/**\n', ' * @title TypedSignature\n', ' * @author dYdX\n', ' *\n', ' * Allows for ecrecovery of signed hashes with three different prepended messages:\n', ' * 1) ""\n', ' * 2) "\\x19Ethereum Signed Message:\\n32"\n', ' * 3) "\\x19Ethereum Signed Message:\\n\\x20"\n', ' */\n', 'library TypedSignature {\n', '\n', '    // Solidity does not offer guarantees about enum values, so we define them explicitly\n', '    uint8 private constant SIGTYPE_INVALID = 0;\n', '    uint8 private constant SIGTYPE_ECRECOVER_DEC = 1;\n', '    uint8 private constant SIGTYPE_ECRECOVER_HEX = 2;\n', '    uint8 private constant SIGTYPE_UNSUPPORTED = 3;\n', '\n', '    // prepended message with the length of the signed hash in hexadecimal\n', '    bytes constant private PREPEND_HEX = "\\x19Ethereum Signed Message:\\n\\x20";\n', '\n', '    // prepended message with the length of the signed hash in decimal\n', '    bytes constant private PREPEND_DEC = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    /**\n', '     * Gives the address of the signer of a hash. Allows for three common prepended strings.\n', '     *\n', '     * @param  hash               Hash that was signed (does not include prepended message)\n', '     * @param  signatureWithType  Type and ECDSA signature with structure: {1:type}{1:v}{32:r}{32:s}\n', '     * @return                    address of the signer of the hash\n', '     */\n', '    function recover(\n', '        bytes32 hash,\n', '        bytes signatureWithType\n', '    )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(\n', '            signatureWithType.length == 66,\n', '            "SignatureValidator#validateSignature: invalid signature length"\n', '        );\n', '\n', '        uint8 sigType = uint8(signatureWithType[0]);\n', '\n', '        require(\n', '            sigType > uint8(SIGTYPE_INVALID),\n', '            "SignatureValidator#validateSignature: invalid signature type"\n', '        );\n', '        require(\n', '            sigType < uint8(SIGTYPE_UNSUPPORTED),\n', '            "SignatureValidator#validateSignature: unsupported signature type"\n', '        );\n', '\n', '        uint8 v = uint8(signatureWithType[1]);\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            r := mload(add(signatureWithType, 34))\n', '            s := mload(add(signatureWithType, 66))\n', '        }\n', '\n', '        bytes32 signedHash;\n', '        if (sigType == SIGTYPE_ECRECOVER_DEC) {\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\n', '        } else {\n', '            assert(sigType == SIGTYPE_ECRECOVER_HEX);\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\n', '        }\n', '\n', '        return ecrecover(\n', '            signedHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/LoanOfferingVerifier.sol\n', '\n', '/**\n', ' * @title LoanOfferingVerifier\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement to be able to make off-chain generated\n', ' * loan offerings.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOfferingVerifier {\n', '\n', '    /**\n', '     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n', '     * will be generated off-chain. The "loan owner" address will own the loan-side of the resulting\n', '     * position.\n', '     *\n', '     * If true is returned, and no errors are thrown by the Margin contract, the loan will have\n', '     * occurred. This means that verifyLoanOffering can also be used to update internal contract\n', '     * state on a loan.\n', '     *\n', '     * @param  addresses    Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan positionOwner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  positionId   Unique ID of the position\n', '     * @param  signature    Arbitrary bytes; may or may not be an ECDSA signature\n', '     * @return              This address to accept, a different address to ask that contract\n', '     */\n', '    function verifyLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/BorrowShared.sol\n', '\n', '/**\n', ' * @title BorrowShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between OpenPositionImpl and IncreasePositionImpl.\n', ' * Both use a Loan Offering and a DEX Order to open or increase a position.\n', ' */\n', 'library BorrowShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 lenderAmount;\n', '        MarginCommon.LoanOffering loanOffering;\n', '        address exchangeWrapper;\n', '        bool depositInHeldToken;\n', '        uint256 depositAmount;\n', '        uint256 collateralAmount;\n', '        uint256 heldTokenFromSell;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Validate the transaction before exchanging heldToken for owedToken\n', '     */\n', '    function validateTxPreSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        assert(transaction.lenderAmount >= transaction.principal);\n', '\n', '        require(\n', '            transaction.principal > 0,\n', '            "BorrowShared#validateTxPreSell: Positions with 0 principal are not allowed"\n', '        );\n', '\n', '        // If the taker is 0x0 then any address can take it. Otherwise only the taker can use it.\n', '        if (transaction.loanOffering.taker != address(0)) {\n', '            require(\n', '                msg.sender == transaction.loanOffering.taker,\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering taker"\n', '            );\n', '        }\n', '\n', '        // If the positionOwner is 0x0 then any address can be set as the position owner.\n', '        // Otherwise only the specified positionOwner can be set as the position owner.\n', '        if (transaction.loanOffering.positionOwner != address(0)) {\n', '            require(\n', '                transaction.owner == transaction.loanOffering.positionOwner,\n', '                "BorrowShared#validateTxPreSell: Invalid position owner"\n', '            );\n', '        }\n', '\n', '        // Require the loan offering to be approved by the payer\n', '        if (AddressUtils.isContract(transaction.loanOffering.payer)) {\n', '            getConsentFromSmartContractLender(transaction);\n', '        } else {\n', '            require(\n', '                transaction.loanOffering.payer == TypedSignature.recover(\n', '                    transaction.loanOffering.loanHash,\n', '                    transaction.loanOffering.signature\n', '                ),\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering signature"\n', '            );\n', '        }\n', '\n', '        // Validate the amount is <= than max and >= min\n', '        uint256 unavailable = MarginCommon.getUnavailableLoanOfferingAmountImpl(\n', '            state,\n', '            transaction.loanOffering.loanHash\n', '        );\n', '        require(\n', '            transaction.lenderAmount.add(unavailable) <= transaction.loanOffering.rates.maxAmount,\n', '            "BorrowShared#validateTxPreSell: Loan offering does not have enough available"\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount >= transaction.loanOffering.rates.minAmount,\n', '            "BorrowShared#validateTxPreSell: Lender amount is below loan offering minimum amount"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owedToken != transaction.loanOffering.heldToken,\n', '            "BorrowShared#validateTxPreSell: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            transaction.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Position owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Loan owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.expirationTimestamp > block.timestamp,\n', '            "BorrowShared#validateTxPreSell: Loan offering is expired"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.maxDuration > 0,\n', '            "BorrowShared#validateTxPreSell: Loan offering has 0 maximum duration"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.rates.interestPeriod <= transaction.loanOffering.maxDuration,\n', '            "BorrowShared#validateTxPreSell: Loan offering interestPeriod > maxDuration"\n', '        );\n', '\n', '        // The minimum heldToken is validated after executing the sell\n', '        // Position and loan ownership is validated in TransferInternal\n', '    }\n', '\n', '    /**\n', '     * Validate the transaction after exchanging heldToken for owedToken, pay out fees, and store\n', '     * how much of the loan was used.\n', '     */\n', '    function doPostSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        validateTxPostSell(transaction);\n', '\n', '        // Transfer feeTokens from trader and lender\n', '        transferLoanFees(state, transaction);\n', '\n', '        // Update global amounts for the loan\n', '        state.loanFills[transaction.loanOffering.loanHash] =\n', '            state.loanFills[transaction.loanOffering.loanHash].add(transaction.lenderAmount);\n', '    }\n', '\n', '    /**\n', '     * Sells the owedToken from the lender (and from the deposit if in owedToken) using the\n', '     * exchangeWrapper, then puts the resulting heldToken into the vault. Only trades for\n', '     * maxHeldTokenToBuy of heldTokens at most.\n', '     */\n', '    function doSell(\n', '        MarginState.State storage state,\n', '        Tx transaction,\n', '        bytes orderData,\n', '        uint256 maxHeldTokenToBuy\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Move owedTokens from lender to exchange wrapper\n', '        pullOwedTokensFromLender(state, transaction);\n', '\n', '        // Sell just the lender&#39;s owedToken (if trader deposit is in heldToken)\n', '        // Otherwise sell both the lender&#39;s owedToken and the trader&#39;s deposit in owedToken\n', '        uint256 sellAmount = transaction.depositInHeldToken ?\n', '            transaction.lenderAmount :\n', '            transaction.lenderAmount.add(transaction.depositAmount);\n', '\n', '        // Do the trade, taking only the maxHeldTokenToBuy if more is returned\n', '        uint256 heldTokenFromSell = Math.min256(\n', '            maxHeldTokenToBuy,\n', '            ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '                msg.sender,\n', '                state.TOKEN_PROXY,\n', '                transaction.loanOffering.heldToken,\n', '                transaction.loanOffering.owedToken,\n', '                sellAmount,\n', '                orderData\n', '            )\n', '        );\n', '\n', '        // Move the tokens to the vault\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.exchangeWrapper,\n', '            heldTokenFromSell\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(heldTokenFromSell);\n', '\n', '        return heldTokenFromSell;\n', '    }\n', '\n', '    /**\n', '     * Take the owedToken deposit from the trader and give it to the exchange wrapper so that it can\n', '     * be sold for heldToken.\n', '     */\n', '    function doDepositOwedToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            msg.sender,\n', '            transaction.exchangeWrapper,\n', '            transaction.depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Take the heldToken deposit from the trader and move it to the vault.\n', '     */\n', '    function doDepositHeldToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            msg.sender,\n', '            transaction.depositAmount\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(transaction.depositAmount);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function validateTxPostSell(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        uint256 expectedCollateral = transaction.depositInHeldToken ?\n', '            transaction.heldTokenFromSell.add(transaction.depositAmount) :\n', '            transaction.heldTokenFromSell;\n', '        assert(transaction.collateralAmount == expectedCollateral);\n', '\n', '        uint256 loanOfferingMinimumHeldToken = MathHelpers.getPartialAmountRoundedUp(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minHeldToken\n', '        );\n', '        require(\n', '            transaction.collateralAmount >= loanOfferingMinimumHeldToken,\n', '            "BorrowShared#validateTxPostSell: Loan offering minimum held token not met"\n', '        );\n', '    }\n', '\n', '    function getConsentFromSmartContractLender(\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        verifyLoanOfferingRecurse(\n', '            transaction.loanOffering.payer,\n', '            getLoanOfferingAddresses(transaction),\n', '            getLoanOfferingValues256(transaction),\n', '            getLoanOfferingValues32(transaction),\n', '            transaction.positionId,\n', '            transaction.loanOffering.signature\n', '        );\n', '    }\n', '\n', '    function verifyLoanOfferingRecurse(\n', '        address contractAddr,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        private\n', '    {\n', '        address newContractAddr = LoanOfferingVerifier(contractAddr).verifyLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            positionId,\n', '            signature\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            verifyLoanOfferingRecurse(\n', '                newContractAddr,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                positionId,\n', '                signature\n', '            );\n', '        }\n', '    }\n', '\n', '    function pullOwedTokensFromLender(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // Transfer owedToken to the exchange wrapper\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.exchangeWrapper,\n', '            transaction.lenderAmount\n', '        );\n', '    }\n', '\n', '    function transferLoanFees(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // 0 fee address indicates no fees\n', '        if (transaction.loanOffering.feeRecipient == address(0)) {\n', '            return;\n', '        }\n', '\n', '        TokenProxy proxy = TokenProxy(state.TOKEN_PROXY);\n', '\n', '        uint256 lenderFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.lenderFee\n', '        );\n', '        uint256 takerFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.takerFee\n', '        );\n', '\n', '        if (lenderFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.lenderFeeToken,\n', '                transaction.loanOffering.payer,\n', '                transaction.loanOffering.feeRecipient,\n', '                lenderFee\n', '            );\n', '        }\n', '\n', '        if (takerFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.takerFeeToken,\n', '                msg.sender,\n', '                transaction.loanOffering.feeRecipient,\n', '                takerFee\n', '            );\n', '        }\n', '    }\n', '\n', '    function getLoanOfferingAddresses(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (address[9])\n', '    {\n', '        return [\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.owner,\n', '            transaction.loanOffering.taker,\n', '            transaction.loanOffering.positionOwner,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.loanOffering.lenderFeeToken,\n', '            transaction.loanOffering.takerFeeToken\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues256(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256[7])\n', '    {\n', '        return [\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minAmount,\n', '            transaction.loanOffering.rates.minHeldToken,\n', '            transaction.loanOffering.rates.lenderFee,\n', '            transaction.loanOffering.rates.takerFee,\n', '            transaction.loanOffering.expirationTimestamp,\n', '            transaction.loanOffering.salt\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues32(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint32[4])\n', '    {\n', '        return [\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.rates.interestPeriod\n', '        ];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/IncreaseLoanDelegator.sol\n', '\n', '/**\n', ' * @title IncreaseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreaseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned loan. Margin will call this on the owner of a loan during increasePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan size was successfully increased.\n', '     *\n', '     * @param  payer           Lender adding additional funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Principal amount to be added to the position\n', '     * @param  lentAmount      Amount of owedToken lent by the lender (principal plus interest, or\n', '     *                         zero if increaseWithoutCounterparty() is used).\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increaseLoanOnBehalfOf(\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/IncreasePositionDelegator.sol\n', '\n', '/**\n', ' * @title IncreasePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreasePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned position. Margin will call this on the owner of a position during increasePosition()\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the position size was successfully increased.\n', '     *\n', '     * @param  trader          Address initiating the addition of funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount of principal to be added to the position\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increasePositionOnBehalfOf(\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/IncreasePositionImpl.sol\n', '\n', '/**\n', ' * @title IncreasePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the increasePosition function of Margin\n', ' */\n', 'library IncreasePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function increasePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        // Also ensures that the position exists\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        BorrowShared.Tx memory transaction = parseIncreasePositionTx(\n', '            position,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        validateIncrease(state, transaction, position);\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        updateState(\n', '            position,\n', '            transaction.positionId,\n', '            transaction.principal,\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.payer\n', '        );\n', '\n', '        // LOG EVENT\n', '        recordPositionIncreased(transaction, position);\n', '\n', '        return transaction.lenderAmount;\n', '    }\n', '\n', '    function increaseWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Disallow adding 0 principal\n', '        require(\n', '            principalToAdd > 0,\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot add 0 principal"\n', '        );\n', '\n', '        // Disallow additions after maximum duration\n', '        require(\n', '            block.timestamp < uint256(position.startTimestamp).add(position.maxDuration),\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot increase after maxDuration"\n', '        );\n', '\n', '        uint256 heldTokenAmount = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            position,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            heldTokenAmount\n', '        );\n', '\n', '        updateState(\n', '            position,\n', '            positionId,\n', '            principalToAdd,\n', '            0, // lent amount\n', '            msg.sender\n', '        );\n', '\n', '        emit PositionIncreased(\n', '            positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            position.owner,\n', '            position.lender,\n', '            "",\n', '            address(0),\n', '            0,\n', '            principalToAdd,\n', '            0,\n', '            heldTokenAmount,\n', '            true\n', '        );\n', '\n', '        return heldTokenAmount;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        // Calculate the number of heldTokens to add\n', '        uint256 collateralToAdd = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            state.positions[transaction.positionId],\n', '            transaction.positionId,\n', '            transaction.principal\n', '        );\n', '\n', '        // Do pre-exchange validations\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        // Calculate and deposit owedToken\n', '        uint256 maxHeldTokenFromSell = MathHelpers.maxUint256();\n', '        if (!transaction.depositInHeldToken) {\n', '            transaction.depositAmount =\n', '                getOwedTokenDeposit(transaction, collateralToAdd, orderData);\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '            maxHeldTokenFromSell = collateralToAdd;\n', '        }\n', '\n', '        // Sell owedToken for heldToken using the exchange wrapper\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            maxHeldTokenFromSell\n', '        );\n', '\n', '        // Calculate and deposit heldToken\n', '        if (transaction.depositInHeldToken) {\n', '            require(\n', '                transaction.heldTokenFromSell <= collateralToAdd,\n', '                "IncreasePositionImpl#doBorrowAndSell: DEX order gives too much heldToken"\n', '            );\n', '            transaction.depositAmount = collateralToAdd.sub(transaction.heldTokenFromSell);\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        }\n', '\n', '        // Make sure the actual added collateral is what is expected\n', '        assert(transaction.collateralAmount == collateralToAdd);\n', '\n', '        // Do post-exchange validations\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function getOwedTokenDeposit(\n', '        BorrowShared.Tx transaction,\n', '        uint256 collateralToAdd,\n', '        bytes orderData\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalOwedToken = ExchangeWrapper(transaction.exchangeWrapper).getExchangeCost(\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.owedToken,\n', '            collateralToAdd,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount <= totalOwedToken,\n', '            "IncreasePositionImpl#getOwedTokenDeposit: Lender amount is more than required"\n', '        );\n', '\n', '        return totalOwedToken.sub(transaction.lenderAmount);\n', '    }\n', '\n', '    function validateIncrease(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '        view\n', '    {\n', '        assert(MarginCommon.containsPositionImpl(state, transaction.positionId));\n', '\n', '        require(\n', '            position.callTimeLimit <= transaction.loanOffering.callTimeLimit,\n', '            "IncreasePositionImpl#validateIncrease: Loan callTimeLimit is less than the position"\n', '        );\n', '\n', '        // require the position to end no later than the loanOffering&#39;s maximum acceptable end time\n', '        uint256 positionEndTimestamp = uint256(position.startTimestamp).add(position.maxDuration);\n', '        uint256 offeringEndTimestamp = block.timestamp.add(transaction.loanOffering.maxDuration);\n', '        require(\n', '            positionEndTimestamp <= offeringEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Loan end timestamp is less than the position"\n', '        );\n', '\n', '        require(\n', '            block.timestamp < positionEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Position has passed its maximum duration"\n', '        );\n', '    }\n', '\n', '    function getCollateralNeededForAddedPrincipal(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 heldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        return MathHelpers.getPartialAmountRoundedUp(\n', '            principalToAdd,\n', '            position.principal,\n', '            heldTokenBalance\n', '        );\n', '    }\n', '\n', '    function updateState(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 owedTokenLent,\n', '        address loanPayer\n', '    )\n', '        private\n', '    {\n', '        position.principal = position.principal.add(principalAdded);\n', '\n', '        address owner = position.owner;\n', '        address lender = position.lender;\n', '\n', '        // Ensure owner consent\n', '        increasePositionOnBehalfOfRecurse(\n', '            owner,\n', '            msg.sender,\n', '            positionId,\n', '            principalAdded\n', '        );\n', '\n', '        // Ensure lender consent\n', '        increaseLoanOnBehalfOfRecurse(\n', '            lender,\n', '            loanPayer,\n', '            positionId,\n', '            principalAdded,\n', '            owedTokenLent\n', '        );\n', '    }\n', '\n', '    function increasePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        private\n', '    {\n', '        // Assume owner approval if not a smart contract and they increased their own position\n', '        if (trader == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreasePositionDelegator(contractAddr).increasePositionOnBehalfOf(\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increasePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '        }\n', '    }\n', '\n', '    function increaseLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 amountLent\n', '    )\n', '        private\n', '    {\n', '        // Assume lender approval if not a smart contract and they increased their own loan\n', '        if (payer == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreaseLoanDelegator(contractAddr).increaseLoanOnBehalfOf(\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increaseLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '        }\n', '    }\n', '\n', '    function recordPositionIncreased(\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '    {\n', '        emit PositionIncreased(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            position.owner,\n', '            position.lender,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.lenderAmount,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        uint256 principal = values256[7];\n', '\n', '        uint256 lenderAmount = MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principal,\n', '            block.timestamp\n', '        );\n', '        assert(lenderAmount >= principal);\n', '\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: positionId,\n', '            owner: position.owner,\n', '            principal: principal,\n', '            lenderAmount: lenderAmount,\n', '            loanOffering: parseLoanOfferingFromIncreasePositionTx(\n', '                position,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[6],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: 0, // set later\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOfferingFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            payer: addresses[0],\n', '            owner: position.lender,\n', '            taker: addresses[1],\n', '            positionOwner: addresses[2],\n', '            feeRecipient: addresses[3],\n', '            lenderFeeToken: addresses[4],\n', '            takerFeeToken: addresses[5],\n', '            rates: parseLoanOfferingRatesFromIncreasePositionTx(position, values256),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferingRatesFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        uint256[8] values256\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: position.interestRate,\n', '            interestPeriod: position.interestPeriod\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginStorage.sol\n', '\n', '/**\n', ' * @title MarginStorage\n', ' * @author dYdX\n', ' *\n', ' * This contract serves as the storage for the entire state of MarginStorage\n', ' */\n', 'contract MarginStorage {\n', '\n', '    MarginState.State state;\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/LoanGetters.sol\n', '\n', '/**\n', ' * @title LoanGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any loan\n', ' * offering stored in the dYdX protocol.\n', ' */\n', 'contract LoanGetters is MarginStorage {\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the principal amount of a loan offering that is no longer available.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total unavailable amount of the loan offering, which is equal to the\n', '     *                   filled amount plus the canceled amount.\n', '     */\n', '    function getLoanUnavailableAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanHash);\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owed token lent for a loan.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total filled amount of the loan offering.\n', '     */\n', '    function getLoanFilledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of a loan offering that has been canceled.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total canceled amount of the loan offering.\n', '     */\n', '    function getLoanCanceledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanCancels[loanHash];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CancelMarginCallDelegator.sol\n', '\n', '/**\n', ' * @title CancelMarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses cancel a\n', ' * margin-call for a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CancelMarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the margin-call was successfully canceled.\n', '     *\n', '     * @param  canceler    Address of the caller of the cancelMarginCall function\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function cancelMarginCallOnBehalfOf(\n', '        address canceler,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/MarginCallDelegator.sol\n', '\n', '/**\n', ' * @title MarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses margin-call a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface MarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call marginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan was successfully margin-called.\n', '     *\n', '     * @param  caller         Address of the caller of the marginCall function\n', '     * @param  positionId     Unique ID of the position\n', '     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n', '     * @return                This address to accept, a different address to ask that contract\n', '     */\n', '    function marginCallOnBehalfOf(\n', '        address caller,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/LoanImpl.sol\n', '\n', '/**\n', ' * @title LoanImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the following functions of Margin:\n', ' *\n', ' *      - marginCall\n', ' *      - cancelMarginCallImpl\n', ' *      - cancelLoanOffering\n', ' */\n', 'library LoanImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function marginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp == 0,\n', '            "LoanImpl#marginCallImpl: The position has already been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        marginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '\n', '        position.callTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        position.requiredDeposit = requiredDeposit;\n', '\n', '        emit MarginCallInitiated(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    function cancelMarginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp > 0,\n', '            "LoanImpl#cancelMarginCallImpl: Position has not been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        cancelMarginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId\n', '        );\n', '\n', '        state.positions[positionId].callTimestamp = 0;\n', '        state.positions[positionId].requiredDeposit = 0;\n', '\n', '        emit MarginCallCanceled(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            0\n', '        );\n', '    }\n', '\n', '    function cancelLoanOfferingImpl(\n', '        MarginState.State storage state,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32,\n', '        uint256    cancelAmount\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        require(\n', '            msg.sender == loanOffering.payer,\n', '            "LoanImpl#cancelLoanOfferingImpl: Only loan offering payer can cancel"\n', '        );\n', '        require(\n', '            loanOffering.expirationTimestamp > block.timestamp,\n', '            "LoanImpl#cancelLoanOfferingImpl: Loan offering has already expired"\n', '        );\n', '\n', '        uint256 remainingAmount = loanOffering.rates.maxAmount.sub(\n', '            MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanOffering.loanHash)\n', '        );\n', '        uint256 amountToCancel = Math.min256(remainingAmount, cancelAmount);\n', '\n', '        // If the loan was already fully canceled, then just return 0 amount was canceled\n', '        if (amountToCancel == 0) {\n', '            return 0;\n', '        }\n', '\n', '        state.loanCancels[loanOffering.loanHash] =\n', '            state.loanCancels[loanOffering.loanHash].add(amountToCancel);\n', '\n', '        emit LoanOfferingCanceled(\n', '            loanOffering.loanHash,\n', '            loanOffering.payer,\n', '            loanOffering.feeRecipient,\n', '            amountToCancel\n', '        );\n', '\n', '        return amountToCancel;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function marginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            MarginCallDelegator(contractAddr).marginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            marginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '        }\n', '    }\n', '\n', '    function cancelMarginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            CancelMarginCallDelegator(contractAddr).cancelMarginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            cancelMarginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            payer: addresses[2],\n', '            owner: addresses[3],\n', '            taker: addresses[4],\n', '            positionOwner: addresses[5],\n', '            feeRecipient: addresses[6],\n', '            lenderFeeToken: addresses[7],\n', '            takerFeeToken: addresses[8],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: new bytes(0)\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[7] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            interestRate: values32[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginAdmin.sol\n', '\n', '/**\n', ' * @title MarginAdmin\n', ' * @author dYdX\n', ' *\n', ' * Contains admin functions for the Margin contract\n', ' * The owner can put Margin into various close-only modes, which will disallow new position creation\n', ' */\n', 'contract MarginAdmin is Ownable {\n', '    // ============ Enums ============\n', '\n', '    // All functionality enabled\n', '    uint8 private constant OPERATION_STATE_OPERATIONAL = 0;\n', '\n', '    // Only closing functions + cancelLoanOffering allowed (marginCall, closePosition,\n', '    // cancelLoanOffering, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY = 1;\n', '\n', '    // Only closing functions allowed (marginCall, closePosition, closePositionDirectly,\n', '    // forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_ONLY = 2;\n', '\n', '    // Only closing functions allowed (marginCall, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_DIRECTLY_ONLY = 3;\n', '\n', '    // This operation state (and any higher) is invalid\n', '    uint8 private constant OPERATION_STATE_INVALID = 4;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Event indicating the operation state has changed\n', '     */\n', '    event OperationStateChanged(\n', '        uint8 from,\n', '        uint8 to\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    uint8 public operationState;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor()\n', '        public\n', '        Ownable()\n', '    {\n', '        operationState = OPERATION_STATE_OPERATIONAL;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyWhileOperational() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL,\n', '            "MarginAdmin#onlyWhileOperational: Can only call while operational"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier cancelLoanOfferingStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY,\n', '            "MarginAdmin#cancelLoanOfferingStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY\n', '            || operationState == OPERATION_STATE_CLOSE_ONLY,\n', '            "MarginAdmin#closePositionStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionDirectlyStateControl() {\n', '        _;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function setOperationState(\n', '        uint8 newState\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newState < OPERATION_STATE_INVALID,\n', '            "MarginAdmin#setOperationState: newState is not a valid operation state"\n', '        );\n', '\n', '        if (newState != operationState) {\n', '            emit OperationStateChanged(\n', '                operationState,\n', '                newState\n', '            );\n', '            operationState = newState;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginEvents.sol\n', '\n', '/**\n', ' * @title MarginEvents\n', ' * @author dYdX\n', ' *\n', ' * Contains events for the Margin contract.\n', ' *\n', ' * NOTE: Any Margin function libraries that use events will need to both define the event here\n', ' *       and copy the event into the library itself as libraries don&#39;t support sharing events\n', ' */\n', 'contract MarginEvents {\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a position was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '}\n', '\n', '// File: contracts/margin/impl/OpenPositionImpl.sol\n', '\n', '/**\n', ' * @title OpenPositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openPosition function of Margin\n', ' */\n', 'library OpenPositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openPositionImpl(\n', '        MarginState.State storage state,\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        BorrowShared.Tx memory transaction = parseOpenTx(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, transaction.positionId),\n', '            "OpenPositionImpl#openPositionImpl: positionId already exists"\n', '        );\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        // Before doStoreNewPosition() so that PositionOpened event is before Transferred events\n', '        recordPositionOpened(\n', '            transaction\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            transaction\n', '        );\n', '\n', '        return transaction.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        if (transaction.depositInHeldToken) {\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        } else {\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '        }\n', '\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            MathHelpers.maxUint256()\n', '        );\n', '\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            transaction.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: transaction.loanOffering.owedToken,\n', '                heldToken: transaction.loanOffering.heldToken,\n', '                lender: transaction.loanOffering.owner,\n', '                owner: transaction.owner,\n', '                principal: transaction.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: transaction.loanOffering.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: transaction.loanOffering.maxDuration,\n', '                interestRate: transaction.loanOffering.rates.interestRate,\n', '                interestPeriod: transaction.loanOffering.rates.interestPeriod\n', '            }),\n', '            transaction.loanOffering.payer\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        BorrowShared.Tx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseOpenTx(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[9]),\n', '            owner: addresses[0],\n', '            principal: values256[7],\n', '            lenderAmount: values256[7],\n', '            loanOffering: parseLoanOffering(\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[10],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: values256[8],\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOffering(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bytes       signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            payer: addresses[3],\n', '            owner: addresses[4],\n', '            taker: addresses[5],\n', '            positionOwner: addresses[6],\n', '            feeRecipient: addresses[7],\n', '            lenderFeeToken: addresses[8],\n', '            takerFeeToken: addresses[9],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[10] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/OpenWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title OpenWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openWithoutCounterparty\n', ' * function of Margin\n', ' */\n', 'library OpenWithoutCounterpartyImpl {\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address positionOwner;\n', '        address owedToken;\n', '        address heldToken;\n', '        address loanOwner;\n', '        uint256 principal;\n', '        uint256 deposit;\n', '        uint32 callTimeLimit;\n', '        uint32 maxDuration;\n', '        uint32 interestRate;\n', '        uint32 interestPeriod;\n', '    }\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        Tx memory openTx = parseTx(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        validate(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            openTx.positionId,\n', '            openTx.heldToken,\n', '            msg.sender,\n', '            openTx.deposit\n', '        );\n', '\n', '        recordPositionOpened(\n', '            openTx\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        return openTx.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            openTx.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: openTx.owedToken,\n', '                heldToken: openTx.heldToken,\n', '                lender: openTx.loanOwner,\n', '                owner: openTx.positionOwner,\n', '                principal: openTx.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: openTx.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: openTx.maxDuration,\n', '                interestRate: openTx.interestRate,\n', '                interestPeriod: openTx.interestPeriod\n', '            }),\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    function validate(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '        view\n', '    {\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, openTx.positionId),\n', '            "openWithoutCounterpartyImpl#validate: positionId already exists"\n', '        );\n', '\n', '        require(\n', '            openTx.principal > 0,\n', '            "openWithoutCounterpartyImpl#validate: principal cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != address(0),\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != openTx.heldToken,\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            openTx.positionOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: positionOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.loanOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: loanOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.maxDuration > 0,\n', '            "openWithoutCounterpartyImpl#validate: maxDuration cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.interestPeriod <= openTx.maxDuration,\n', '            "openWithoutCounterpartyImpl#validate: interestPeriod must be <= maxDuration"\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            openTx.positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            bytes32(0),\n', '            openTx.owedToken,\n', '            openTx.heldToken,\n', '            address(0),\n', '            openTx.principal,\n', '            0,\n', '            openTx.deposit,\n', '            openTx.interestRate,\n', '            openTx.callTimeLimit,\n', '            openTx.maxDuration,\n', '            true\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseTx(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (Tx memory)\n', '    {\n', '        Tx memory openTx = Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[2]),\n', '            positionOwner: addresses[0],\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            loanOwner: addresses[3],\n', '            principal: values256[0],\n', '            deposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return openTx;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/PositionGetters.sol\n', '\n', '/**\n', ' * @title PositionGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any position\n', ' * stored in the dYdX protocol.\n', ' */\n', 'contract PositionGetters is MarginStorage {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets if a position is currently open.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is exists and is open\n', '     */\n', '    function containsPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return MarginCommon.containsPositionImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position is currently margin-called.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is margin-called\n', '     */\n', '    function isPositionCalled(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (state.positions[positionId].callTimestamp > 0);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position was previously open and is now closed.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is now closed\n', '     */\n', '    function isPositionClosed(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.closedPositions[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owedToken ever repaid to the lender for a position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Total amount of owedToken ever repaid\n', '     */\n', '    function getTotalOwedTokenRepaidToLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.totalOwedTokenRepaidToLender[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of heldToken currently locked up in Vault for a particular position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The amount of heldToken\n', '     */\n', '    function getPositionBalance(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getPositionBalanceImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets the time until the interest fee charged for the position will increase.\n', '     * Returns 1 if the interest fee increases every second.\n', '     * Returns 0 if the interest fee will never increase again.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of seconds until the interest fee will increase\n', '     */\n', '    function getTimeUntilInterestIncrease(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 effectiveTimeElapsed = MarginCommon.calculateEffectiveTimeElapsed(\n', '            position,\n', '            block.timestamp\n', '        );\n', '\n', '        uint256 absoluteTimeElapsed = block.timestamp.sub(position.startTimestamp);\n', '        if (absoluteTimeElapsed > effectiveTimeElapsed) { // past maxDuration\n', '            return 0;\n', '        } else {\n', '            // nextStep is the final second at which the calculated interest fee is the same as it\n', '            // is currently, so add 1 to get the correct value\n', '            return effectiveTimeElapsed.add(1).sub(absoluteTimeElapsed);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens currently needed to close the position completely, including\n', '     * interest fees.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of owedTokens\n', '     */\n', '    function getPositionOwedAmount(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            position.principal,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens needed to close a given principal amount of the position at a\n', '     * given time, including interest fees.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  principalToClose   Amount of principal being closed\n', '     * @param  timestamp          Block timestamp in seconds of close\n', '     * @return                    The number of owedTokens owed\n', '     */\n', '    function getPositionOwedAmountAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToClose,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getPositionOwedAmountAtTime: Requested time before position started"\n', '        );\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            principalToClose,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens that can be borrowed from a lender to add a given principal\n', '     * amount to the position at a given time.\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Amount being added to principal\n', '     * @param  timestamp       Block timestamp in seconds of addition\n', '     * @return                 The number of owedTokens that will be borrowed\n', '     */\n', '    function getLenderAmountForIncreasePositionAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getLenderAmountForIncreasePositionAtTime: timestamp < position start"\n', '        );\n', '\n', '        return MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principalToAdd,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    // ============ All Properties ============\n', '\n', '    /**\n', '     * Get a Position by id. This does not validate the position exists. If the position does not\n', '     * exist, all 0&#39;s will be returned.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Addresses corresponding to:\n', '     *\n', '     *                     [0] = owedToken\n', '     *                     [1] = heldToken\n', '     *                     [2] = lender\n', '     *                     [3] = owner\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = principal\n', '     *                     [1] = requiredDeposit\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = callTimeLimit\n', '     *                     [1] = startTimestamp\n', '     *                     [2] = callTimestamp\n', '     *                     [3] = maxDuration\n', '     *                     [4] = interestRate\n', '     *                     [5] = interestPeriod\n', '     */\n', '    function getPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            address[4],\n', '            uint256[2],\n', '            uint32[6]\n', '        )\n', '    {\n', '        MarginCommon.Position storage position = state.positions[positionId];\n', '\n', '        return (\n', '            [\n', '                position.owedToken,\n', '                position.heldToken,\n', '                position.lender,\n', '                position.owner\n', '            ],\n', '            [\n', '                position.principal,\n', '                position.requiredDeposit\n', '            ],\n', '            [\n', '                position.callTimeLimit,\n', '                position.startTimestamp,\n', '                position.callTimestamp,\n', '                position.maxDuration,\n', '                position.interestRate,\n', '                position.interestPeriod\n', '            ]\n', '        );\n', '    }\n', '\n', '    // ============ Individual Properties ============\n', '\n', '    function getPositionLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].lender;\n', '    }\n', '\n', '    function getPositionOwner(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owner;\n', '    }\n', '\n', '    function getPositionHeldToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].heldToken;\n', '    }\n', '\n', '    function getPositionOwedToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owedToken;\n', '    }\n', '\n', '    function getPositionPrincipal(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].principal;\n', '    }\n', '\n', '    function getPositionInterestRate(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].interestRate;\n', '    }\n', '\n', '    function getPositionRequiredDeposit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].requiredDeposit;\n', '    }\n', '\n', '    function getPositionStartTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].startTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimeLimit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimeLimit;\n', '    }\n', '\n', '    function getPositionMaxDuration(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].maxDuration;\n', '    }\n', '\n', '    function getPositioninterestPeriod(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].interestPeriod;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/TransferImpl.sol\n', '\n', '/**\n', ' * @title TransferImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the transferPosition and transferLoan functions of\n', ' * Margin\n', ' */\n', 'library TransferImpl {\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function transferLoanImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newLender\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferLoanImpl: Position does not exist"\n', '        );\n', '\n', '        address originalLender = state.positions[positionId].lender;\n', '\n', '        require(\n', '            msg.sender == originalLender,\n', '            "TransferImpl#transferLoanImpl: Only lender can transfer ownership"\n', '        );\n', '        require(\n', '            newLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', '        // Doesn&#39;t change the state of positionId; figures out the final owner of loan.\n', '        // That is, newLender may pass ownership to a different address.\n', '        address finalLender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            originalLender,\n', '            newLender);\n', '\n', '        require(\n', '            finalLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].lender = finalLender;\n', '    }\n', '\n', '    function transferPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newOwner\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferPositionImpl: Position does not exist"\n', '        );\n', '\n', '        address originalOwner = state.positions[positionId].owner;\n', '\n', '        require(\n', '            msg.sender == originalOwner,\n', '            "TransferImpl#transferPositionImpl: Only position owner can transfer ownership"\n', '        );\n', '        require(\n', '            newOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', '        // Doesn&#39;t change the state of positionId; figures out the final owner of position.\n', '        // That is, newOwner may pass ownership to a different address.\n', '        address finalOwner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            originalOwner,\n', '            newOwner);\n', '\n', '        require(\n', '            finalOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].owner = finalOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Margin.sol\n', '\n', '/**\n', ' * @title Margin\n', ' * @author dYdX\n', ' *\n', ' * This contract is used to facilitate margin trading as per the dYdX protocol\n', ' */\n', 'contract Margin is\n', '    ReentrancyGuard,\n', '    MarginStorage,\n', '    MarginEvents,\n', '    MarginAdmin,\n', '    LoanGetters,\n', '    PositionGetters\n', '{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address vault,\n', '        address proxy\n', '    )\n', '        public\n', '        MarginAdmin()\n', '    {\n', '        state = MarginState.State({\n', '            VAULT: vault,\n', '            TOKEN_PROXY: proxy\n', '        });\n', '    }\n', '\n', '    // ============ Public State Changing Functions ============\n', '\n', '    /**\n', '     * Open a margin position. Called by the margin trader who must provide both a\n', '     * signed loan offering as well as a DEX Order with which to sell the owedToken.\n', '     *\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan payer\n', '     *  [4]  = loan owner\n', '     *  [5]  = loan taker\n', '     *  [6]  = loan position owner\n', '     *  [7]  = loan fee recipient\n', '     *  [8]  = loan lender fee token\n', '     *  [9]  = loan taker fee token\n', '     *  [10]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = position amount of principal\n', '     *  [8]  = deposit amount\n', '     *  [9]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Unique ID for the new position\n', '     */\n', '    function openPosition(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bool        depositInHeldToken,\n', '        bytes       signature,\n', '        bytes       order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenPositionImpl.openPositionImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Open a margin position without a counterparty. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  addresses    Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan owner\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0]  = principal\n', '     *  [1]  = deposit amount\n', '     *  [2]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = call time limit (in seconds)\n', '     *  [1] = maxDuration (in seconds)\n', '     *  [2] = interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = interest update period (in seconds)\n', '     *\n', '     * @return              Unique ID for the new position\n', '     */\n', '    function openWithoutCounterparty(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenWithoutCounterpartyImpl.openWithoutCounterpartyImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase the size of a position. Funds will be borrowed from the loan payer and sold as per\n', '     * the position. The amount of owedToken borrowed from the lender will be >= the amount of\n', '     * principal added, as it will incorporate interest already earned by the position so far.\n', '     *\n', '     * @param  positionId          Unique ID of the position\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = loan payer\n', '     *  [1]  = loan taker\n', '     *  [2]  = loan position owner\n', '     *  [3]  = loan fee recipient\n', '     *  [4]  = loan lender fee token\n', '     *  [5]  = loan taker fee token\n', '     *  [6]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = amount of principal to add to the position (NOTE: the amount pulled from the lender\n', '     *                                                           will be >= this amount)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be pulled in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Amount of owedTokens pulled from the lender\n', '     */\n', '    function increasePosition(\n', '        bytes32    positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2]  values32,\n', '        bool       depositInHeldToken,\n', '        bytes      signature,\n', '        bytes      order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increasePositionImpl(\n', '            state,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase a position directly by putting up heldToken. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Principal amount to add to the position\n', '     * @return                 Amount of heldToken pulled from the msg.sender\n', '     */\n', '    function increaseWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increaseWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Close a position. May be called by the owner or with the approval of the owner. May provide\n', '     * an order and exchangeWrapper to facilitate the closing of the position. The payoutRecipient\n', '     * is sent the resulting payout.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @param  exchangeWrapper       Address of the exchange wrapper\n', '     * @param  payoutInHeldToken     True to pay out the payoutRecipient in heldToken,\n', '     *                               False to pay out the payoutRecipient in owedToken\n', '     * @param  order                 Order object to be passed to the exchange wrapper\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal of position closed\n', '     *                               2) Amount of tokens (heldToken if payoutInHeldtoken is true,\n', '     *                                  owedToken otherwise) received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePosition(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool    payoutInHeldToken,\n', '        bytes   order\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Helper to close a position by paying owedToken directly rather than using an exchangeWrapper.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePositionDirectly(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionDirectlyStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            new bytes(0)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Reduce the size of a position and withdraw a proportional amount of heldToken from the vault.\n', '     * Must be approved by both the position owner and lender.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     *                               3) The amount allowed by the lender if closer != lender\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the msg.sender\n', '     */\n', '    function closeWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256)\n', '    {\n', '        return CloseWithoutCounterpartyImpl.closeWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Margin-call a position. Only callable with the approval of the position lender. After the\n', '     * call, the position owner will have time equal to the callTimeLimit of the position to close\n', '     * the position. If the owner does not close the position, the lender can recover the collateral\n', '     * in the position.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requiredDeposit  Amount of deposit the position owner will have to put up to cancel\n', '     *                          the margin-call. Passing in 0 means the margin call cannot be\n', '     *                          canceled by depositing\n', '     */\n', '    function marginCall(\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        LoanImpl.marginCallImpl(\n', '            state,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Cancel a margin-call. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     */\n', '    function cancelMarginCall(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        LoanImpl.cancelMarginCallImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Used to recover the heldTokens held as collateral. Is callable after the maximum duration of\n', '     * the loan has expired or the loan has been margin-called for the duration of the callTimeLimit\n', '     * but remains unclosed. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             Amount of heldToken recovered\n', '     */\n', '    function forceRecoverCollateral(\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return ForceRecoverCollateralImpl.forceRecoverCollateralImpl(\n', '            state,\n', '            positionId,\n', '            recipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Deposit additional heldToken as collateral for a position. Cancels margin-call if:\n', '     * 0 < position.requiredDeposit < depositAmount. Only callable by the position owner.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  depositAmount    Additional amount in heldToken to deposit\n', '     */\n', '    function depositCollateral(\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        DepositCollateralImpl.depositCollateralImpl(\n', '            state,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Cancel an amount of a loan offering. Only callable by the loan offering&#39;s payer.\n', '     *\n', '     * @param  addresses     Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan position owner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256     Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32      Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  cancelAmount  Amount to cancel\n', '     * @return               Amount that was canceled\n', '     */\n', '    function cancelLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7]  values256,\n', '        uint32[4]   values32,\n', '        uint256     cancelAmount\n', '    )\n', '        external\n', '        cancelLoanOfferingStateControl\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return LoanImpl.cancelLoanOfferingImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            cancelAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a loan to a new address. This new address will be entitled to all\n', '     * payouts for this loan. Only callable by the lender for a position. If "who" is a contract, it\n', '     * must implement the LoanOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the loan\n', '     */\n', '    function transferLoan(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferLoanImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a position to a new address. This new address will be entitled to all\n', '     * payouts. Only callable by the owner of a position. If "who" is a contract, it must implement\n', '     * the PositionOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the position\n', '     */\n', '    function transferPosition(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferPositionImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the address of the Vault contract that holds and accounts for tokens.\n', '     *\n', '     * @return  The address of the Vault contract\n', '     */\n', '    function getVaultAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.VAULT;\n', '    }\n', '\n', '    /**\n', '     * Gets the address of the TokenProxy contract that accounts must set allowance on in order to\n', '     * make loans or open/close positions.\n', '     *\n', '     * @return  The address of the TokenProxy contract\n', '     */\n', '    function getTokenProxyAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.TOKEN_PROXY;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/OnlyMargin.sol\n', '\n', '/**\n', ' * @title OnlyMargin\n', ' * @author dYdX\n', ' *\n', ' * Contract to store the address of the main Margin contract and trust only that address to call\n', ' * certain functions.\n', ' */\n', 'contract OnlyMargin {\n', '\n', '    // ============ Constants ============\n', '\n', '    // Address of the known and trusted Margin contract on the blockchain\n', '    address public DYDX_MARGIN;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address margin\n', '    )\n', '        public\n', '    {\n', '        DYDX_MARGIN = margin;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyMargin()\n', '    {\n', '        require(\n', '            msg.sender == DYDX_MARGIN,\n', '            "OnlyMargin#onlyMargin: Only Margin can call"\n', '        );\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/lib/LoanOfferingParser.sol\n', '\n', '/**\n', ' * @title LoanOfferingParser\n', ' * @author dYdX\n', ' *\n', ' * Contract for LoanOfferingVerifiers to parse arguments\n', ' */\n', 'contract LoanOfferingParser {\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes signature\n', '    )\n', '        internal\n', '        pure\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering;\n', '\n', '        fillLoanOfferingAddresses(loanOffering, addresses);\n', '        fillLoanOfferingValues256(loanOffering, values256);\n', '        fillLoanOfferingValues32(loanOffering, values32);\n', '        loanOffering.signature = signature;\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function fillLoanOfferingAddresses(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        address[9] addresses\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.owedToken = addresses[0];\n', '        loanOffering.heldToken = addresses[1];\n', '        loanOffering.payer = addresses[2];\n', '        loanOffering.owner = addresses[3];\n', '        loanOffering.taker = addresses[4];\n', '        loanOffering.positionOwner = addresses[5];\n', '        loanOffering.feeRecipient = addresses[6];\n', '        loanOffering.lenderFeeToken = addresses[7];\n', '        loanOffering.takerFeeToken = addresses[8];\n', '    }\n', '\n', '    function fillLoanOfferingValues256(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        uint256[7] values256\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.rates.maxAmount = values256[0];\n', '        loanOffering.rates.minAmount = values256[1];\n', '        loanOffering.rates.minHeldToken = values256[2];\n', '        loanOffering.rates.lenderFee = values256[3];\n', '        loanOffering.rates.takerFee = values256[4];\n', '        loanOffering.expirationTimestamp = values256[5];\n', '        loanOffering.salt = values256[6];\n', '    }\n', '\n', '    function fillLoanOfferingValues32(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.callTimeLimit = values32[0];\n', '        loanOffering.maxDuration = values32[1];\n', '        loanOffering.rates.interestRate = values32[2];\n', '        loanOffering.rates.interestPeriod = values32[3];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/lib/MarginHelper.sol\n', '\n', '/**\n', ' * @title MarginHelper\n', ' * @author dYdX\n', ' *\n', ' * This library contains helper functions for interacting with Margin\n', ' */\n', 'library MarginHelper {\n', '    function getPosition(\n', '        address DYDX_MARGIN,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (MarginCommon.Position memory)\n', '    {\n', '        (\n', '            address[4] memory addresses,\n', '            uint256[2] memory values256,\n', '            uint32[6]  memory values32\n', '        ) = Margin(DYDX_MARGIN).getPosition(positionId);\n', '\n', '        return MarginCommon.Position({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            lender: addresses[2],\n', '            owner: addresses[3],\n', '            principal: values256[0],\n', '            requiredDeposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            startTimestamp: values32[1],\n', '            callTimestamp: values32[2],\n', '            maxDuration: values32[3],\n', '            interestRate: values32[4],\n', '            interestPeriod: values32[5]\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/BucketLender/BucketLender.sol\n', '\n', '/**\n', ' * @title BucketLender\n', ' * @author dYdX\n', ' *\n', ' * On-chain shared lender that allows anyone to deposit tokens into this contract to be used to\n', ' * lend tokens for a particular margin position.\n', ' *\n', ' * - Each bucket has three variables:\n', ' *   - Available Amount\n', ' *     - The available amount of tokens that the bucket has to lend out\n', ' *   - Outstanding Principal\n', ' *     - The amount of principal that the bucket is responsible for in the margin position\n', ' *   - Weight\n', ' *     - Used to keep track of each account&#39;s weighted ownership within a bucket\n', ' *     - Relative weight between buckets is meaningless\n', ' *     - Only accounts&#39; relative weight within a bucket matters\n', ' *\n', ' * - Token Deposits:\n', ' *   - Go into a particular bucket, determined by time since the start of the position\n', ' *     - If the position has not started: bucket = 0\n', ' *     - If the position has started:     bucket = ceiling(time_since_start / BUCKET_TIME)\n', ' *     - This is always the highest bucket; no higher bucket yet exists\n', ' *   - Increase the bucket&#39;s Available Amount\n', ' *   - Increase the bucket&#39;s weight and the account&#39;s weight in that bucket\n', ' *\n', ' * - Token Withdrawals:\n', ' *   - Can be from any bucket with available amount\n', ' *   - Decrease the bucket&#39;s Available Amount\n', ' *   - Decrease the bucket&#39;s weight and the account&#39;s weight in that bucket\n', ' *\n', ' * - Increasing the Position (Lending):\n', ' *   - The lowest buckets with Available Amount are used first\n', ' *   - Decreases Available Amount\n', ' *   - Increases Outstanding Principal\n', ' *\n', ' * - Decreasing the Position (Being Paid-Back)\n', ' *   - The highest buckets with Outstanding Principal are paid back first\n', ' *   - Decreases Outstanding Principal\n', ' *   - Increases Available Amount\n', ' *\n', ' *\n', ' * - Over time, this gives highest interest rates to earlier buckets, but disallows withdrawals from\n', ' *   those buckets for a longer period of time.\n', ' * - Deposits in the same bucket earn the same interest rate.\n', ' * - Lenders can withdraw their funds at any time if they are not being lent (and are therefore not\n', ' *   making the maximum interest).\n', ' * - The highest bucket with Outstanding Principal is always less-than-or-equal-to the lowest bucket\n', '     with Available Amount\n', ' */\n', 'contract BucketLender is\n', '    Ownable,\n', '    OnlyMargin,\n', '    LoanOwner,\n', '    IncreaseLoanDelegator,\n', '    MarginCallDelegator,\n', '    CancelMarginCallDelegator,\n', '    ForceRecoverCollateralDelegator,\n', '    LoanOfferingParser,\n', '    LoanOfferingVerifier,\n', '    ReentrancyGuard\n', '{\n', '    using SafeMath for uint256;\n', '    using TokenInteract for address;\n', '\n', '    // ============ Events ============\n', '\n', '    event Deposit(\n', '        address indexed beneficiary,\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        uint256 weight\n', '    );\n', '\n', '    event Withdraw(\n', '        address indexed withdrawer,\n', '        uint256 bucket,\n', '        uint256 weight,\n', '        uint256 owedTokenWithdrawn,\n', '        uint256 heldTokenWithdrawn\n', '    );\n', '\n', '    event PrincipalIncreased(\n', '        uint256 principalTotal,\n', '        uint256 bucketNumber,\n', '        uint256 principalForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event PrincipalDecreased(\n', '        uint256 principalTotal,\n', '        uint256 bucketNumber,\n', '        uint256 principalForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event AvailableIncreased(\n', '        uint256 availableTotal,\n', '        uint256 bucketNumber,\n', '        uint256 availableForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event AvailableDecreased(\n', '        uint256 availableTotal,\n', '        uint256 bucketNumber,\n', '        uint256 availableForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    /**\n', '     * Available Amount is the amount of tokens that is available to be lent by each bucket.\n', '     * These tokens are also available to be withdrawn by the accounts that have weight in the\n', '     * bucket.\n', '     */\n', '    // Available Amount for each bucket\n', '    mapping(uint256 => uint256) public availableForBucket;\n', '\n', '    // Total Available Amount\n', '    uint256 public availableTotal;\n', '\n', '    /**\n', '     * Outstanding Principal is the share of the margin position&#39;s principal that each bucket\n', '     * is responsible for. That is, each bucket with Outstanding Principal is owed\n', '     * (Outstanding Principal)*E^(RT) owedTokens in repayment.\n', '     */\n', '    // Outstanding Principal for each bucket\n', '    mapping(uint256 => uint256) public principalForBucket;\n', '\n', '    // Total Outstanding Principal\n', '    uint256 public principalTotal;\n', '\n', '    /**\n', '     * Weight determines an account&#39;s proportional share of a bucket. Relative weights have no\n', '     * meaning if they are not for the same bucket. Likewise, the relative weight of two buckets has\n', '     * no meaning. However, the relative weight of two accounts within the same bucket is equal to\n', '     * the accounts&#39; shares in the bucket and are therefore proportional to the payout that they\n', '     * should expect from withdrawing from that bucket.\n', '     */\n', '    // Weight for each account in each bucket\n', '    mapping(uint256 => mapping(address => uint256)) public weightForBucketForAccount;\n', '\n', '    // Total Weight for each bucket\n', '    mapping(uint256 => uint256) public weightForBucket;\n', '\n', '    /**\n', '     * The critical bucket is:\n', '     * - Greater-than-or-equal-to The highest bucket with Outstanding Principal\n', '     * - Less-than-or-equal-to the lowest bucket with Available Amount\n', '     *\n', '     * It is equal to both of these values in most cases except in an edge cases where the two\n', '     * buckets are different. This value is cached to find such a bucket faster than looping through\n', '     * all possible buckets.\n', '     */\n', '    uint256 public criticalBucket = 0;\n', '\n', '    /**\n', '     * Latest cached value for totalOwedTokenRepaidToLender.\n', '     * This number updates on the dYdX Margin base protocol whenever the position is\n', '     * partially-closed, but this contract is not notified at that time. Therefore, it is updated\n', '     * upon increasing the position or when depositing/withdrawing\n', '     */\n', '    uint256 public cachedRepaidAmount = 0;\n', '\n', '    // True if the position was closed from force-recovering the collateral\n', '    bool public wasForceClosed = false;\n', '\n', '    // ============ Constants ============\n', '\n', '    // Unique ID of the position\n', '    bytes32 public POSITION_ID;\n', '\n', '    // Address of the token held in the position as collateral\n', '    address public HELD_TOKEN;\n', '\n', '    // Address of the token being lent\n', '    address public OWED_TOKEN;\n', '\n', '    // Time between new buckets\n', '    uint32 public BUCKET_TIME;\n', '\n', '    // Interest rate of the position\n', '    uint32 public INTEREST_RATE;\n', '\n', '    // Interest period of the position\n', '    uint32 public INTEREST_PERIOD;\n', '\n', '    // Maximum duration of the position\n', '    uint32 public MAX_DURATION;\n', '\n', '    // Margin-call time-limit of the position\n', '    uint32 public CALL_TIMELIMIT;\n', '\n', '    // (NUMERATOR/DENOMINATOR) denotes the minimum collateralization ratio of the position\n', '    uint32 public MIN_HELD_TOKEN_NUMERATOR;\n', '    uint32 public MIN_HELD_TOKEN_DENOMINATOR;\n', '\n', '    // Accounts that are permitted to margin-call positions (or cancel the margin call)\n', '    mapping(address => bool) public TRUSTED_MARGIN_CALLERS;\n', '\n', '    // Accounts that are permitted to withdraw on behalf of any address\n', '    mapping(address => bool) public TRUSTED_WITHDRAWERS;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address margin,\n', '        bytes32 positionId,\n', '        address heldToken,\n', '        address owedToken,\n', '        uint32[7] parameters,\n', '        address[] trustedMarginCallers,\n', '        address[] trustedWithdrawers\n', '    )\n', '        public\n', '        OnlyMargin(margin)\n', '    {\n', '        POSITION_ID = positionId;\n', '        HELD_TOKEN = heldToken;\n', '        OWED_TOKEN = owedToken;\n', '\n', '        require(\n', '            parameters[0] != 0,\n', '            "BucketLender#constructor: BUCKET_TIME cannot be zero"\n', '        );\n', '        BUCKET_TIME = parameters[0];\n', '        INTEREST_RATE = parameters[1];\n', '        INTEREST_PERIOD = parameters[2];\n', '        MAX_DURATION = parameters[3];\n', '        CALL_TIMELIMIT = parameters[4];\n', '        MIN_HELD_TOKEN_NUMERATOR = parameters[5];\n', '        MIN_HELD_TOKEN_DENOMINATOR = parameters[6];\n', '\n', '        // Initialize TRUSTED_MARGIN_CALLERS and TRUSTED_WITHDRAWERS\n', '        uint256 i = 0;\n', '        for (i = 0; i < trustedMarginCallers.length; i++) {\n', '            TRUSTED_MARGIN_CALLERS[trustedMarginCallers[i]] = true;\n', '        }\n', '        for (i = 0; i < trustedWithdrawers.length; i++) {\n', '            TRUSTED_WITHDRAWERS[trustedWithdrawers[i]] = true;\n', '        }\n', '\n', '        // Set maximum allowance on proxy\n', '        OWED_TOKEN.approve(\n', '            Margin(margin).getTokenProxyAddress(),\n', '            MathHelpers.maxUint256()\n', '        );\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyPosition(bytes32 positionId) {\n', '        require(\n', '            POSITION_ID == positionId,\n', '            "BucketLender#onlyPosition: Incorrect position"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Margin-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n', '     * will be generated off-chain. The "loan owner" address will own the loan-side of the resulting\n', '     * position.\n', '     *\n', '     * @param  addresses    Loan offering addresses\n', '     * @param  values256    Loan offering uint256s\n', '     * @param  values32     Loan offering uint32s\n', '     * @param  positionId   Unique ID of the position\n', '     * @param  signature    Arbitrary bytes\n', '     * @return              This address to accept, a different address to ask that contract\n', '     */\n', '    function verifyLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            Margin(DYDX_MARGIN).containsPosition(POSITION_ID),\n', '            "BucketLender#verifyLoanOffering: This contract should not open a new position"\n', '        );\n', '\n', '        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            signature\n', '        );\n', '\n', '        // CHECK ADDRESSES\n', '        assert(loanOffering.owedToken == OWED_TOKEN);\n', '        assert(loanOffering.heldToken == HELD_TOKEN);\n', '        assert(loanOffering.payer == address(this));\n', '        assert(loanOffering.owner == address(this));\n', '        require(\n', '            loanOffering.taker == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.taker is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.feeRecipient == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.feeRecipient is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.positionOwner == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.positionOwner is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.lenderFeeToken == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.lenderFeeToken is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.takerFeeToken == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.takerFeeToken is non-zero"\n', '        );\n', '\n', '        // CHECK VALUES256\n', '        require(\n', '            loanOffering.rates.maxAmount == MathHelpers.maxUint256(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.maxAmount is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.rates.minAmount == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.minAmount is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.minHeldToken == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.minHeldToken is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.lenderFee == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.lenderFee is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.takerFee == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.takerFee is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.expirationTimestamp == MathHelpers.maxUint256(),\n', '            "BucketLender#verifyLoanOffering: expirationTimestamp is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.salt == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.salt is non-zero"\n', '        );\n', '\n', '        // CHECK VALUES32\n', '        require(\n', '            loanOffering.callTimeLimit == MathHelpers.maxUint32(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.callTimelimit is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.maxDuration == MathHelpers.maxUint32(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.maxDuration is incorrect"\n', '        );\n', '        assert(loanOffering.rates.interestRate == INTEREST_RATE);\n', '        assert(loanOffering.rates.interestPeriod == INTEREST_PERIOD);\n', '\n', '        // no need to require anything about loanOffering.signature\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Called by the Margin contract when anyone transfers ownership of a loan to this contract.\n', '     * This function initializes this contract and returns this address to indicate to Margin\n', '     * that it is willing to take ownership of the loan.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address on success, throw otherwise\n', '     */\n', '    function receiveLoanOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, POSITION_ID);\n', '        uint256 initialPrincipal = position.principal;\n', '        uint256 minHeldToken = MathHelpers.getPartialAmount(\n', '            uint256(MIN_HELD_TOKEN_NUMERATOR),\n', '            uint256(MIN_HELD_TOKEN_DENOMINATOR),\n', '            initialPrincipal\n', '        );\n', '\n', '        assert(initialPrincipal > 0);\n', '        assert(principalTotal == 0);\n', '        assert(from != address(this)); // position must be opened without lending from this position\n', '\n', '        require(\n', '            position.owedToken == OWED_TOKEN,\n', '            "BucketLender#receiveLoanOwnership: Position owedToken mismatch"\n', '        );\n', '        require(\n', '            position.heldToken == HELD_TOKEN,\n', '            "BucketLender#receiveLoanOwnership: Position heldToken mismatch"\n', '        );\n', '        require(\n', '            position.maxDuration == MAX_DURATION,\n', '            "BucketLender#receiveLoanOwnership: Position maxDuration mismatch"\n', '        );\n', '        require(\n', '            position.callTimeLimit == CALL_TIMELIMIT,\n', '            "BucketLender#receiveLoanOwnership: Position callTimeLimit mismatch"\n', '        );\n', '        require(\n', '            position.interestRate == INTEREST_RATE,\n', '            "BucketLender#receiveLoanOwnership: Position interestRate mismatch"\n', '        );\n', '        require(\n', '            position.interestPeriod == INTEREST_PERIOD,\n', '            "BucketLender#receiveLoanOwnership: Position interestPeriod mismatch"\n', '        );\n', '        require(\n', '            Margin(DYDX_MARGIN).getPositionBalance(POSITION_ID) >= minHeldToken,\n', '            "BucketLender#receiveLoanOwnership: Not enough heldToken as collateral"\n', '        );\n', '\n', '        // set relevant constants\n', '        principalForBucket[0] = initialPrincipal;\n', '        principalTotal = initialPrincipal;\n', '        weightForBucket[0] = weightForBucket[0].add(initialPrincipal);\n', '        weightForBucketForAccount[0][from] =\n', '            weightForBucketForAccount[0][from].add(initialPrincipal);\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Called by Margin when additional value is added onto the position this contract\n', '     * is lending for. Balance is added to the address that loaned the additional tokens.\n', '     *\n', '     * @param  payer           Address that loaned the additional tokens\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount that was added to the position\n', '     * @param  lentAmount      Amount of owedToken lent\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increaseLoanOnBehalfOf(\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '\n', '        require(\n', '            payer == address(this),\n', '            "BucketLender#increaseLoanOnBehalfOf: Other lenders cannot lend for this position"\n', '        );\n', '        require(\n', '            !margin.isPositionCalled(POSITION_ID),\n', '            "BucketLender#increaseLoanOnBehalfOf: No lending while the position is margin-called"\n', '        );\n', '\n', '        // This function is only called after the state has been updated in the base protocol;\n', '        // thus, the principal in the base protocol will equal the principal after the increase\n', '        uint256 principalAfterIncrease = margin.getPositionPrincipal(POSITION_ID);\n', '        uint256 principalBeforeIncrease = principalAfterIncrease.sub(principalAdded);\n', '\n', '        // principalTotal was the principal after the previous increase\n', '        accountForClose(principalTotal.sub(principalBeforeIncrease));\n', '\n', '        accountForIncrease(principalAdded, lentAmount);\n', '\n', '        assert(principalTotal == principalAfterIncrease);\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call marginCall().\n', '     *\n', '     * @param  caller         Address of the caller of the marginCall function\n', '     * @param  positionId     Unique ID of the position\n', '     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n', '     * @return                This address to accept, a different address to ask that contract\n', '     */\n', '    function marginCallOnBehalfOf(\n', '        address caller,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            TRUSTED_MARGIN_CALLERS[caller],\n', '            "BucketLender#marginCallOnBehalfOf: Margin-caller must be trusted"\n', '        );\n', '        require(\n', '            depositAmount == 0, // prevents depositing from canceling the margin-call\n', '            "BucketLender#marginCallOnBehalfOf: Deposit amount must be zero"\n', '        );\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n', '     *\n', '     * @param  canceler    Address of the caller of the cancelMarginCall function\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function cancelMarginCallOnBehalfOf(\n', '        address canceler,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            TRUSTED_MARGIN_CALLERS[canceler],\n', '            "BucketLender#cancelMarginCallOnBehalfOf: Margin-call-canceler must be trusted"\n', '        );\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * forceRecoverCollateral().\n', '     *\n', '     *  param  recoverer   Address of the caller of the forceRecoverCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function forceRecoverCollateralOnBehalfOf(\n', '        address /* recoverer */,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        return forceRecoverCollateralInternal(recipient);\n', '    }\n', '\n', '    // ============ Public State-Changing Functions ============\n', '\n', '    /**\n', '     * Allow anyone to recalculate the Outstanding Principal and Available Amount for the buckets if\n', '     * part of the position has been closed since the last position increase.\n', '     */\n', '    function rebalanceBuckets()\n', '        external\n', '        nonReentrant\n', '    {\n', '        rebalanceBucketsInternal();\n', '    }\n', '\n', '    /**\n', '     * Allows users to deposit owedToken into this contract. Allowance must be set on this contract\n', '     * for "token" in at least the amount "amount".\n', '     *\n', '     * @param  beneficiary  The account that will be entitled to this depoit\n', '     * @param  amount       The amount of owedToken to deposit\n', '     * @return              The bucket number that was deposited into\n', '     */\n', '    function deposit(\n', '        address beneficiary,\n', '        uint256 amount\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '        bytes32 positionId = POSITION_ID;\n', '\n', '        require(\n', '            beneficiary != address(0),\n', '            "BucketLender#deposit: Beneficiary cannot be the zero address"\n', '        );\n', '        require(\n', '            amount != 0,\n', '            "BucketLender#deposit: Cannot deposit zero tokens"\n', '        );\n', '        require(\n', '            !margin.isPositionClosed(positionId),\n', '            "BucketLender#deposit: Cannot deposit after the position is closed"\n', '        );\n', '        require(\n', '            !margin.isPositionCalled(positionId),\n', '            "BucketLender#deposit: Cannot deposit while the position is margin-called"\n', '        );\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        OWED_TOKEN.transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        uint256 bucket = getCurrentBucket();\n', '\n', '        uint256 effectiveAmount = availableForBucket[bucket].add(getBucketOwedAmount(bucket));\n', '\n', '        uint256 weightToAdd = 0;\n', '        if (effectiveAmount == 0) {\n', '            weightToAdd = amount; // first deposit in bucket\n', '        } else {\n', '            weightToAdd = MathHelpers.getPartialAmount(\n', '                amount,\n', '                effectiveAmount,\n', '                weightForBucket[bucket]\n', '            );\n', '        }\n', '\n', '        require(\n', '            weightToAdd != 0,\n', '            "BucketLender#deposit: Cannot deposit for zero weight"\n', '        );\n', '\n', '        // update state\n', '        updateAvailable(bucket, amount, true);\n', '        weightForBucketForAccount[bucket][beneficiary] =\n', '            weightForBucketForAccount[bucket][beneficiary].add(weightToAdd);\n', '        weightForBucket[bucket] = weightForBucket[bucket].add(weightToAdd);\n', '\n', '        emit Deposit(\n', '            beneficiary,\n', '            bucket,\n', '            amount,\n', '            weightToAdd\n', '        );\n', '\n', '        return bucket;\n', '    }\n', '\n', '    /**\n', '     * Allows users to withdraw their lent funds. An account can withdraw its weighted share of the\n', '     * bucket.\n', '     *\n', '     * While the position is open, a bucket&#39;s share is equal to:\n', '     *   Owed Token: (Available Amount) + (Outstanding Principal) * (1 + interest)\n', '     *   Held Token: 0\n', '     *\n', '     * After the position is closed, a bucket&#39;s share is equal to:\n', '     *   Owed Token: (Available Amount)\n', '     *   Held Token: (Held Token Balance) * (Outstanding Principal) / (Total Outstanding Principal)\n', '     *\n', '     * @param  buckets      The bucket numbers to withdraw from\n', '     * @param  maxWeights   The maximum weight to withdraw from each bucket. The amount of tokens\n', '     *                      withdrawn will be at least this amount, but not necessarily more.\n', '     *                      Withdrawing the same weight from different buckets does not necessarily\n', '     *                      return the same amounts from those buckets. In order to withdraw as many\n', '     *                      tokens as possible, use the maximum uint256.\n', '     * @param  onBehalfOf   The address to withdraw on behalf of\n', '     * @return              1) The number of owedTokens withdrawn\n', '     *                      2) The number of heldTokens withdrawn\n', '     */\n', '    function withdraw(\n', '        uint256[] buckets,\n', '        uint256[] maxWeights,\n', '        address onBehalfOf\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256, uint256)\n', '    {\n', '        require(\n', '            buckets.length == maxWeights.length,\n', '            "BucketLender#withdraw: The lengths of the input arrays must match"\n', '        );\n', '        if (onBehalfOf != msg.sender) {\n', '            require(\n', '                TRUSTED_WITHDRAWERS[msg.sender],\n', '                "BucketLender#withdraw: Only trusted withdrawers can withdraw on behalf of others"\n', '            );\n', '        }\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        // decide if some bucket is unable to be withdrawn from (is locked)\n', '        // the zero value represents no-lock\n', '        uint256 lockedBucket = 0;\n', '        if (\n', '            Margin(DYDX_MARGIN).containsPosition(POSITION_ID) &&\n', '            criticalBucket == getCurrentBucket()\n', '        ) {\n', '            lockedBucket = criticalBucket;\n', '        }\n', '\n', '        uint256[2] memory results; // [0] = totalOwedToken, [1] = totalHeldToken\n', '\n', '        uint256 maxHeldToken = 0;\n', '        if (wasForceClosed) {\n', '            maxHeldToken = HELD_TOKEN.balanceOf(address(this));\n', '        }\n', '\n', '        for (uint256 i = 0; i < buckets.length; i++) {\n', '            uint256 bucket = buckets[i];\n', '\n', '            // prevent withdrawing from the current bucket if it is also the critical bucket\n', '            if ((bucket != 0) && (bucket == lockedBucket)) {\n', '                continue;\n', '            }\n', '\n', '            (uint256 owedTokenForBucket, uint256 heldTokenForBucket) = withdrawSingleBucket(\n', '                onBehalfOf,\n', '                bucket,\n', '                maxWeights[i],\n', '                maxHeldToken\n', '            );\n', '\n', '            results[0] = results[0].add(owedTokenForBucket);\n', '            results[1] = results[1].add(heldTokenForBucket);\n', '        }\n', '\n', '        // Transfer share of owedToken\n', '        OWED_TOKEN.transfer(msg.sender, results[0]);\n', '        HELD_TOKEN.transfer(msg.sender, results[1]);\n', '\n', '        return (results[0], results[1]);\n', '    }\n', '\n', '    /**\n', '     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n', '     * including (but not limited-to) token airdrops. Any tokens moved to this contract by calling\n', '     * deposit() will be accounted for and will not be withdrawable by this function.\n', '     *\n', '     * @param  token  ERC20 token address\n', '     * @param  to     Address to transfer tokens to\n', '     * @return        Amount of tokens withdrawn\n', '     */\n', '    function withdrawExcessToken(\n', '        address token,\n', '        address to\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        rebalanceBucketsInternal();\n', '\n', '        uint256 amount = token.balanceOf(address(this));\n', '\n', '        if (token == OWED_TOKEN) {\n', '            amount = amount.sub(availableTotal);\n', '        } else if (token == HELD_TOKEN) {\n', '            require(\n', '                !wasForceClosed,\n', '                "BucketLender#withdrawExcessToken: heldToken cannot be withdrawn if force-closed"\n', '            );\n', '        }\n', '\n', '        token.transfer(to, amount);\n', '        return amount;\n', '    }\n', '\n', '    // ============ Public Getter Functions ============\n', '\n', '    /**\n', '     * Get the current bucket number that funds will be deposited into. This is also the highest\n', '     * bucket so far.\n', '     *\n', '     * @return The highest bucket and the one that funds will be deposited into\n', '     */\n', '    function getCurrentBucket()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // load variables from storage;\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '        bytes32 positionId = POSITION_ID;\n', '        uint32 bucketTime = BUCKET_TIME;\n', '\n', '        assert(!margin.isPositionClosed(positionId));\n', '\n', '        // if position not created, allow deposits in the first bucket\n', '        if (!margin.containsPosition(positionId)) {\n', '            return 0;\n', '        }\n', '\n', '        // return the number of BUCKET_TIME periods elapsed since the position start, rounded-up\n', '        uint256 startTimestamp = margin.getPositionStartTimestamp(positionId);\n', '        return block.timestamp.sub(startTimestamp).div(bucketTime).add(1);\n', '    }\n', '\n', '    /**\n', '     * Gets the outstanding amount of owedToken owed to a bucket. This is the principal amount of\n', '     * the bucket multiplied by the interest accrued in the position. If the position is closed,\n', '     * then any outstanding principal will never be repaid in the form of owedToken.\n', '     *\n', '     * @param  bucket  The bucket number\n', '     * @return         The amount of owedToken that this bucket expects to be paid-back if the posi\n', '     */\n', '    function getBucketOwedAmount(\n', '        uint256 bucket\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // if the position is completely closed, then the outstanding principal will never be repaid\n', '        if (Margin(DYDX_MARGIN).isPositionClosed(POSITION_ID)) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 lentPrincipal = principalForBucket[bucket];\n', '\n', '        // the bucket has no outstanding principal\n', '        if (lentPrincipal == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // get the total amount of owedToken that would be paid back at this time\n', '        uint256 owedAmount = Margin(DYDX_MARGIN).getPositionOwedAmountAtTime(\n', '            POSITION_ID,\n', '            principalTotal,\n', '            uint32(block.timestamp)\n', '        );\n', '\n', '        // return the bucket&#39;s share\n', '        return MathHelpers.getPartialAmount(\n', '            lentPrincipal,\n', '            principalTotal,\n', '            owedAmount\n', '        );\n', '    }\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    function forceRecoverCollateralInternal(\n', '        address recipient\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        require(\n', '            recipient == address(this),\n', '            "BucketLender#forceRecoverCollateralOnBehalfOf: Recipient must be this contract"\n', '        );\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        wasForceClosed = true;\n', '\n', '        return address(this);\n', '    }\n', '\n', '    // ============ Private Helper Functions ============\n', '\n', '    /**\n', '     * Recalculates the Outstanding Principal and Available Amount for the buckets. Only changes the\n', '     * state if part of the position has been closed since the last position increase.\n', '     */\n', '    function rebalanceBucketsInternal()\n', '        private\n', '    {\n', '        // if force-closed, don&#39;t update the outstanding principal values; they are needed to repay\n', '        // lenders with heldToken\n', '        if (wasForceClosed) {\n', '            return;\n', '        }\n', '\n', '        uint256 marginPrincipal = Margin(DYDX_MARGIN).getPositionPrincipal(POSITION_ID);\n', '\n', '        accountForClose(principalTotal.sub(marginPrincipal));\n', '\n', '        assert(principalTotal == marginPrincipal);\n', '    }\n', '\n', '    /**\n', '     * Updates the state variables at any time. Only does anything after the position has been\n', '     * closed or partially-closed since the last time this function was called.\n', '     *\n', '     * - Increases the available amount in the highest buckets with outstanding principal\n', '     * - Decreases the principal amount in those buckets\n', '     *\n', '     * @param  principalRemoved  Amount of principal closed since the last update\n', '     */\n', '    function accountForClose(\n', '        uint256 principalRemoved\n', '    )\n', '        private\n', '    {\n', '        if (principalRemoved == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newRepaidAmount = Margin(DYDX_MARGIN).getTotalOwedTokenRepaidToLender(POSITION_ID);\n', '        assert(newRepaidAmount.sub(cachedRepaidAmount) >= principalRemoved);\n', '\n', '        uint256 principalToSub = principalRemoved;\n', '        uint256 availableToAdd = newRepaidAmount.sub(cachedRepaidAmount);\n', '        uint256 criticalBucketTemp = criticalBucket;\n', '\n', '        // loop over buckets in reverse order starting with the critical bucket\n', '        for (\n', '            uint256 bucket = criticalBucketTemp;\n', '            principalToSub > 0;\n', '            bucket--\n', '        ) {\n', '            assert(bucket <= criticalBucketTemp); // no underflow on bucket\n', '\n', '            uint256 principalTemp = Math.min256(principalToSub, principalForBucket[bucket]);\n', '            if (principalTemp == 0) {\n', '                continue;\n', '            }\n', '            uint256 availableTemp = MathHelpers.getPartialAmount(\n', '                principalTemp,\n', '                principalToSub,\n', '                availableToAdd\n', '            );\n', '\n', '            updateAvailable(bucket, availableTemp, true);\n', '            updatePrincipal(bucket, principalTemp, false);\n', '\n', '            principalToSub = principalToSub.sub(principalTemp);\n', '            availableToAdd = availableToAdd.sub(availableTemp);\n', '\n', '            criticalBucketTemp = bucket;\n', '        }\n', '\n', '        assert(principalToSub == 0);\n', '        assert(availableToAdd == 0);\n', '\n', '        setCriticalBucket(criticalBucketTemp);\n', '\n', '        cachedRepaidAmount = newRepaidAmount;\n', '    }\n', '\n', '    /**\n', '     * Updates the state variables when a position is increased.\n', '     *\n', '     * - Decreases the available amount in the lowest buckets with available token\n', '     * - Increases the principal amount in those buckets\n', '     *\n', '     * @param  principalAdded  Amount of principal added to the position\n', '     * @param  lentAmount      Amount of owedToken lent\n', '     */\n', '    function accountForIncrease(\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        private\n', '    {\n', '        require(\n', '            lentAmount <= availableTotal,\n', '            "BucketLender#accountForIncrease: No lending not-accounted-for funds"\n', '        );\n', '\n', '        uint256 principalToAdd = principalAdded;\n', '        uint256 availableToSub = lentAmount;\n', '        uint256 criticalBucketTemp;\n', '\n', '        // loop over buckets in order starting from the critical bucket\n', '        uint256 lastBucket = getCurrentBucket();\n', '        for (\n', '            uint256 bucket = criticalBucket;\n', '            principalToAdd > 0;\n', '            bucket++\n', '        ) {\n', '            assert(bucket <= lastBucket); // should never go past the last bucket\n', '\n', '            uint256 availableTemp = Math.min256(availableToSub, availableForBucket[bucket]);\n', '            if (availableTemp == 0) {\n', '                continue;\n', '            }\n', '            uint256 principalTemp = MathHelpers.getPartialAmount(\n', '                availableTemp,\n', '                availableToSub,\n', '                principalToAdd\n', '            );\n', '\n', '            updateAvailable(bucket, availableTemp, false);\n', '            updatePrincipal(bucket, principalTemp, true);\n', '\n', '            principalToAdd = principalToAdd.sub(principalTemp);\n', '            availableToSub = availableToSub.sub(availableTemp);\n', '\n', '            criticalBucketTemp = bucket;\n', '        }\n', '\n', '        assert(principalToAdd == 0);\n', '        assert(availableToSub == 0);\n', '\n', '        setCriticalBucket(criticalBucketTemp);\n', '    }\n', '\n', '    /**\n', '     * Withdraw\n', '     *\n', '     * @param  onBehalfOf    The account for which to withdraw for\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  maxWeight     The maximum weight to withdraw\n', '     * @param  maxHeldToken  The total amount of heldToken that has been force-recovered\n', '     * @return               1) The number of owedTokens withdrawn\n', '     *                       2) The number of heldTokens withdrawn\n', '     */\n', '    function withdrawSingleBucket(\n', '        address onBehalfOf,\n', '        uint256 bucket,\n', '        uint256 maxWeight,\n', '        uint256 maxHeldToken\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        // calculate the user&#39;s share\n', '        uint256 bucketWeight = weightForBucket[bucket];\n', '        if (bucketWeight == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 userWeight = weightForBucketForAccount[bucket][onBehalfOf];\n', '        uint256 weightToWithdraw = Math.min256(maxWeight, userWeight);\n', '        if (weightToWithdraw == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        // update state\n', '        weightForBucket[bucket] = weightForBucket[bucket].sub(weightToWithdraw);\n', '        weightForBucketForAccount[bucket][onBehalfOf] = userWeight.sub(weightToWithdraw);\n', '\n', '        // calculate for owedToken\n', '        uint256 owedTokenToWithdraw = withdrawOwedToken(\n', '            bucket,\n', '            weightToWithdraw,\n', '            bucketWeight\n', '        );\n', '\n', '        // calculate for heldToken\n', '        uint256 heldTokenToWithdraw = withdrawHeldToken(\n', '            bucket,\n', '            weightToWithdraw,\n', '            bucketWeight,\n', '            maxHeldToken\n', '        );\n', '\n', '        emit Withdraw(\n', '            onBehalfOf,\n', '            bucket,\n', '            weightToWithdraw,\n', '            owedTokenToWithdraw,\n', '            heldTokenToWithdraw\n', '        );\n', '\n', '        return (owedTokenToWithdraw, heldTokenToWithdraw);\n', '    }\n', '\n', '    /**\n', '     * Helper function to withdraw earned owedToken from this contract.\n', '     *\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  userWeight    The amount of weight the user is using to withdraw\n', '     * @param  bucketWeight  The total weight of the bucket\n', '     * @return               The amount of owedToken being withdrawn\n', '     */\n', '    function withdrawOwedToken(\n', '        uint256 bucket,\n', '        uint256 userWeight,\n', '        uint256 bucketWeight\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // amount to return for the bucket\n', '        uint256 owedTokenToWithdraw = MathHelpers.getPartialAmount(\n', '            userWeight,\n', '            bucketWeight,\n', '            availableForBucket[bucket].add(getBucketOwedAmount(bucket))\n', '        );\n', '\n', '        // check that there is enough token to give back\n', '        require(\n', '            owedTokenToWithdraw <= availableForBucket[bucket],\n', '            "BucketLender#withdrawOwedToken: There must be enough available owedToken"\n', '        );\n', '\n', '        // update amounts\n', '        updateAvailable(bucket, owedTokenToWithdraw, false);\n', '\n', '        return owedTokenToWithdraw;\n', '    }\n', '\n', '    /**\n', '     * Helper function to withdraw heldToken from this contract.\n', '     *\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  userWeight    The amount of weight the user is using to withdraw\n', '     * @param  bucketWeight  The total weight of the bucket\n', '     * @param  maxHeldToken  The total amount of heldToken available to withdraw\n', '     * @return               The amount of heldToken being withdrawn\n', '     */\n', '    function withdrawHeldToken(\n', '        uint256 bucket,\n', '        uint256 userWeight,\n', '        uint256 bucketWeight,\n', '        uint256 maxHeldToken\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        if (maxHeldToken == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // user&#39;s principal for the bucket\n', '        uint256 principalForBucketForAccount = MathHelpers.getPartialAmount(\n', '            userWeight,\n', '            bucketWeight,\n', '            principalForBucket[bucket]\n', '        );\n', '\n', '        uint256 heldTokenToWithdraw = MathHelpers.getPartialAmount(\n', '            principalForBucketForAccount,\n', '            principalTotal,\n', '            maxHeldToken\n', '        );\n', '\n', '        updatePrincipal(bucket, principalForBucketForAccount, false);\n', '\n', '        return heldTokenToWithdraw;\n', '    }\n', '\n', '    // ============ Setter Functions ============\n', '\n', '    /**\n', '     * Changes the critical bucket variable\n', '     *\n', '     * @param  bucket  The value to set criticalBucket to\n', '     */\n', '    function setCriticalBucket(\n', '        uint256 bucket\n', '    )\n', '        private\n', '    {\n', '        // don&#39;t spend the gas to sstore unless we need to change the value\n', '        if (criticalBucket == bucket) {\n', '            return;\n', '        }\n', '\n', '        criticalBucket = bucket;\n', '    }\n', '\n', '    /**\n', '     * Changes the available owedToken amount. This changes both the variable to track the total\n', '     * amount as well as the variable to track a particular bucket.\n', '     *\n', '     * @param  bucket    The bucket number\n', '     * @param  amount    The amount to change the available amount by\n', '     * @param  increase  True if positive change, false if negative change\n', '     */\n', '    function updateAvailable(\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        bool increase\n', '    )\n', '        private\n', '    {\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newTotal;\n', '        uint256 newForBucket;\n', '\n', '        if (increase) {\n', '            newTotal = availableTotal.add(amount);\n', '            newForBucket = availableForBucket[bucket].add(amount);\n', '            emit AvailableIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        } else {\n', '            newTotal = availableTotal.sub(amount);\n', '            newForBucket = availableForBucket[bucket].sub(amount);\n', '            emit AvailableDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        }\n', '\n', '        availableTotal = newTotal;\n', '        availableForBucket[bucket] = newForBucket;\n', '    }\n', '\n', '    /**\n', '     * Changes the principal amount. This changes both the variable to track the total\n', '     * amount as well as the variable to track a particular bucket.\n', '     *\n', '     * @param  bucket    The bucket number\n', '     * @param  amount    The amount to change the principal amount by\n', '     * @param  increase  True if positive change, false if negative change\n', '     */\n', '    function updatePrincipal(\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        bool increase\n', '    )\n', '        private\n', '    {\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newTotal;\n', '        uint256 newForBucket;\n', '\n', '        if (increase) {\n', '            newTotal = principalTotal.add(amount);\n', '            newForBucket = principalForBucket[bucket].add(amount);\n', '            emit PrincipalIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        } else {\n', '            newTotal = principalTotal.sub(amount);\n', '            newForBucket = principalForBucket[bucket].sub(amount);\n', '            emit PrincipalDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        }\n', '\n', '        principalTotal = newTotal;\n', '        principalForBucket[bucket] = newForBucket;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/BucketLender/EthWrapperForBucketLender.sol\n', '\n', '/**\n', ' * @title EthWrapperForBucketLender\n', ' * @author dYdX\n', ' *\n', ' * Takes ETH directly, wraps it, then sends it to a bucket lender on behalf of a user.\n', ' */\n', 'contract EthWrapperForBucketLender\n', '{\n', '    using TokenInteract for address;\n', '\n', '    // ============ Constants ============\n', '\n', '    // Address of the WETH token\n', '    address public WETH;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address weth\n', '    )\n', '        public\n', '    {\n', '        WETH = weth;\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Fallback function. Disallows ether to be sent to this contract without data except when\n', '     * unwrapping WETH.\n', '     */\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        require( // coverage-disable-line\n', '            msg.sender == WETH,\n', '            "EthWrapperForBucketLender#fallback: Cannot recieve ETH directly unless unwrapping WETH"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Allows users to send eth directly to this contract and have it be wrapped and sent to a\n', '     * BucketLender to be lent for some margin position.\n', '     *\n', '     * @param  bucketLender  The address of the BucketLender contract to deposit money into\n', '     * @param  beneficiary   The address that will retain rights to the deposit\n', '     * @return               The bucket number that was deposited into\n', '     */\n', '    function depositEth(\n', '        address bucketLender,\n', '        address beneficiary\n', '    )\n', '        external\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        uint256 amount = msg.value;\n', '\n', '        require(\n', '            amount != 0,\n', '            "EthWrapperForBucketLender#depositEth: Cannot deposit zero amount"\n', '        );\n', '\n', '        // wrap the eth\n', '        WETH9(WETH).deposit.value(amount)();\n', '        assert(WETH.balanceOf(address(this)) >= amount);\n', '\n', '        // ensure enough allowance\n', '        if (WETH.allowance(address(this), bucketLender) == 0) {\n', '            // approve for "unlimited amount". WETH9 leaves this value as-is when doing transferFrom\n', '            WETH.approve(bucketLender, MathHelpers.maxUint256());\n', '        }\n', '\n', '        // deposit the tokens\n', '        return BucketLender(bucketLender).deposit(beneficiary, amount);\n', '    }\n', '\n', '    /**\n', '     * Allows users to send eth directly to this contract and have it be wrapped and sent to a\n', '     * BucketLender to be lent for some margin position.\n', '     *\n', '     * @param  bucketLender  The address of the BucketLender contract to deposit money into\n', '     * @return               The bucket number that was deposited into\n', '     */\n', '    function withdrawEth(\n', '        address bucketLender,\n', '        uint256[] buckets,\n', '        uint256[] maxWeights\n', '    )\n', '        external\n', '        returns (uint256, uint256)\n', '    {\n', '        address owedToken = BucketLender(bucketLender).OWED_TOKEN();\n', '        address heldToken = BucketLender(bucketLender).HELD_TOKEN();\n', '        require(\n', '            owedToken == WETH,\n', '            "EthWrapperForBucketLender: Cannot withdraw from non-WETH BucketLender"\n', '        );\n', '\n', '        // withdraw the weth\n', '        (\n', '            uint256 owedTokenAmount,\n', '            uint256 heldTokenAmount\n', '        ) = BucketLender(bucketLender).withdraw(\n', '            buckets,\n', '            maxWeights,\n', '            msg.sender\n', '        );\n', '\n', '        // send all eth to msg.sender\n', '        if (owedTokenAmount != 0) {\n', '            WETH9(owedToken).withdraw(owedTokenAmount);\n', '            msg.sender.transfer(owedTokenAmount);\n', '        }\n', '\n', '        // send all other tokens to msg.sender\n', '        if (heldTokenAmount != 0) {\n', '            heldToken.transfer(msg.sender, heldTokenAmount);\n', '        }\n', '\n', '        return (owedTokenAmount, heldTokenAmount);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', 'pragma experimental "v0.5.0";\n', '\n', '/*\n', '\n', '    Copyright 2018 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', '// File: canonical-weth/contracts/WETH9.sol\n', '\n', 'contract WETH9 {\n', '    string public name     = "Wrapped Ether";\n', '    string public symbol   = "WETH";\n', '    uint8  public decimals = 18;\n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '\n', '    function() external payable {\n', '        deposit();\n', '    }\n', '    function deposit() public payable {\n', '        balanceOf[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    function withdraw(uint wad) public {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        emit Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min64(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '\n', '  function max256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a >= _b ? _a : _b;\n', '  }\n', '\n', '  function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    return _a < _b ? _a : _b;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/lib/AccessControlledBase.sol\n', '\n', '/**\n', ' * @title AccessControlledBase\n', ' * @author dYdX\n', ' *\n', ' * Base functionality for access control. Requires an implementation to\n', ' * provide a way to grant and optionally revoke access\n', ' */\n', 'contract AccessControlledBase {\n', '    // ============ State Variables ============\n', '\n', '    mapping (address => bool) public authorized;\n', '\n', '    // ============ Events ============\n', '\n', '    event AccessGranted(\n', '        address who\n', '    );\n', '\n', '    event AccessRevoked(\n', '        address who\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier requiresAuthorization() {\n', '        require(\n', '            authorized[msg.sender],\n', '            "AccessControlledBase#requiresAuthorization: Sender not authorized"\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/StaticAccessControlled.sol\n', '\n', '/**\n', ' * @title StaticAccessControlled\n', ' * @author dYdX\n', ' *\n', ' * Allows for functions to be access controled\n', ' * Permissions cannot be changed after a grace period\n', ' */\n', 'contract StaticAccessControlled is AccessControlledBase, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Timestamp after which no additional access can be granted\n', '    uint256 public GRACE_PERIOD_EXPIRATION;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        Ownable()\n', '    {\n', '        GRACE_PERIOD_EXPIRATION = block.timestamp.add(gracePeriod);\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function grantAccess(\n', '        address who\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            block.timestamp < GRACE_PERIOD_EXPIRATION,\n', '            "StaticAccessControlled#grantAccess: Cannot grant access after grace period"\n', '        );\n', '\n', '        emit AccessGranted(who);\n', '        authorized[who] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/GeneralERC20.sol\n', '\n', '/**\n', ' * @title GeneralERC20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', ' * that we dont automatically revert when calling non-compliant tokens that have no return value for\n', ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface GeneralERC20 {\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/TokenInteract.sol\n', '\n', '/**\n', ' * @title TokenInteract\n', ' * @author dYdX\n', ' *\n', ' * This library contains functions for interacting with ERC20 tokens\n', ' */\n', 'library TokenInteract {\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        GeneralERC20(token).approve(spender, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#approve: Approval failed"\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        address from = address(this);\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transfer(to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transfer: Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transferFrom(from, to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transferFrom: TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/TokenProxy.sol\n', '\n', '/**\n', ' * @title TokenProxy\n', ' * @author dYdX\n', ' *\n', ' * Used to transfer tokens between addresses which have set allowance on this contract.\n', ' */\n', 'contract TokenProxy is StaticAccessControlled {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {}\n', '\n', '    // ============ Authorized-Only State Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy) to another address.\n', '     *\n', '     * @param  token  The address of the ERC20 token\n', '     * @param  from   The address to transfer token from\n', '     * @param  to     The address to transfer tokens to\n', '     * @param  value  The number of tokens to transfer\n', '     */\n', '    function transferTokens(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        TokenInteract.transferFrom(\n', '            token,\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Getter function to get the amount of token that the proxy is able to move for a particular\n', '     * address. The minimum of 1) the balance of that address and 2) the allowance given to proxy.\n', '     *\n', '     * @param  who    The owner of the tokens\n', '     * @param  token  The address of the ERC20 token\n', '     * @return        The number of tokens able to be moved by the proxy from the address specified\n', '     */\n', '    function available(\n', '        address who,\n', '        address token\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return Math.min256(\n', '            TokenInteract.allowance(token, who, address(this)),\n', '            TokenInteract.balanceOf(token, who)\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Vault.sol\n', '\n', '/**\n', ' * @title Vault\n', ' * @author dYdX\n', ' *\n', ' * Holds and transfers tokens in vaults denominated by id\n', ' *\n', ' * Vault only supports ERC20 tokens, and will not accept any tokens that require\n', ' * a tokenFallback or equivalent function (See ERC223, ERC777, etc.)\n', ' */\n', 'contract Vault is StaticAccessControlled\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event ExcessTokensWithdrawn(\n', '        address indexed token,\n', '        address indexed to,\n', '        address caller\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    // Address of the TokenProxy contract. Used for moving tokens.\n', '    address public TOKEN_PROXY;\n', '\n', '    // Map from vault ID to map from token address to amount of that token attributed to the\n', '    // particular vault ID.\n', '    mapping (bytes32 => mapping (address => uint256)) public balances;\n', '\n', '    // Map from token address to total amount of that token attributed to some account.\n', '    mapping (address => uint256) public totalBalances;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address proxy,\n', '        uint256 gracePeriod\n', '    )\n', '        public\n', '        StaticAccessControlled(gracePeriod)\n', '    {\n', '        TOKEN_PROXY = proxy;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n', '     * including (but not limited-to) token airdrops. Any tokens moved to the vault by TOKEN_PROXY\n', '     * will be accounted for and will not be withdrawable by this function.\n', '     *\n', '     * @param  token  ERC20 token address\n', '     * @param  to     Address to transfer tokens to\n', '     * @return        Amount of tokens withdrawn\n', '     */\n', '    function withdrawExcessToken(\n', '        address token,\n', '        address to\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        uint256 actualBalance = TokenInteract.balanceOf(token, address(this));\n', '        uint256 accountedBalance = totalBalances[token];\n', '        uint256 withdrawableBalance = actualBalance.sub(accountedBalance);\n', '\n', '        require(\n', '            withdrawableBalance != 0,\n', '            "Vault#withdrawExcessToken: Withdrawable token amount must be non-zero"\n', '        );\n', '\n', '        TokenInteract.transfer(token, to, withdrawableBalance);\n', '\n', '        emit ExcessTokensWithdrawn(token, to, msg.sender);\n', '\n', '        return withdrawableBalance;\n', '    }\n', '\n', '    // ============ Authorized-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has approved the proxy) to the vault.\n', '     *\n', '     * @param  id      The vault which will receive the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  from    Address from which the tokens will be taken\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferToVault(\n', '        bytes32 id,\n', '        address token,\n', '        address from,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // First send tokens to this contract\n', '        TokenProxy(TOKEN_PROXY).transferTokens(\n', '            token,\n', '            from,\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        // Then increment balances\n', '        balances[id][token] = balances[id][token].add(amount);\n', '        totalBalances[token] = totalBalances[token].add(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        validateBalance(token);\n', '    }\n', '\n', '    /**\n', '     * Transfers a certain amount of funds to an address.\n', '     *\n', '     * @param  id      The vault from which to send the tokens\n', '     * @param  token   ERC20 token address\n', '     * @param  to      Address to transfer tokens to\n', '     * @param  amount  Number of the token to be sent\n', '     */\n', '    function transferFromVault(\n', '        bytes32 id,\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        requiresAuthorization\n', '    {\n', '        // Next line also asserts that (balances[id][token] >= amount);\n', '        balances[id][token] = balances[id][token].sub(amount);\n', '\n', '        // Next line also asserts that (totalBalances[token] >= amount);\n', '        totalBalances[token] = totalBalances[token].sub(amount);\n', '\n', '        // This should always be true. If not, something is very wrong\n', '        assert(totalBalances[token] >= balances[id][token]);\n', '\n', '        // Do the sending\n', '        TokenInteract.transfer(token, to, amount); // asserts transfer succeeded\n', '\n', '        // Final validation\n', '        validateBalance(token);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Verifies that this contract is in control of at least as many tokens as accounted for\n', '     *\n', '     * @param  token  Address of ERC20 token\n', '     */\n', '    function validateBalance(\n', '        address token\n', '    )\n', '        private\n', '        view\n', '    {\n', '        // The actual balance could be greater than totalBalances[token] because anyone\n', "        // can send tokens to the contract's address which cannot be accounted for\n", '        assert(TokenInteract.balanceOf(token, address(this)) >= totalBalances[token]);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author dYdX\n', ' *\n', ' * Optimized version of the well-known ReentrancyGuard contract\n', ' */\n', 'contract ReentrancyGuard {\n', '    uint256 private _guardCounter = 1;\n', '\n', '    modifier nonReentrant() {\n', '        uint256 localCounter = _guardCounter + 1;\n', '        _guardCounter = localCounter;\n', '        _;\n', '        require(\n', '            _guardCounter == localCounter,\n', '            "Reentrancy check failure"\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param _addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address _addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(_addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/lib/Fraction.sol\n', '\n', '/**\n', ' * @title Fraction\n', ' * @author dYdX\n', ' *\n', ' * This library contains implementations for fraction structs.\n', ' */\n', 'library Fraction {\n', '    struct Fraction128 {\n', '        uint128 num;\n', '        uint128 den;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FractionMath.sol\n', '\n', '/**\n', ' * @title FractionMath\n', ' * @author dYdX\n', ' *\n', ' * This library contains safe math functions for manipulating fractions.\n', ' */\n', 'library FractionMath {\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint128;\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a + b\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (sum)\n', '     */\n', '    function add(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 left = a.num.mul(b.den);\n', '        uint256 right = b.num.mul(a.den);\n', '        uint256 denominator = a.den.mul(b.den);\n', '\n', '        // if left + right overflows, prevent overflow\n', '        if (left + right < left) {\n', '            left = left.div(2);\n', '            right = right.div(2);\n', '            denominator = denominator.div(2);\n', '        }\n', '\n', '        return bound(left.add(right), denominator);\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a - (1/2)^d\n', '     *\n', '     * @param  a  The Fraction128\n', '     * @param  d  The power of (1/2)\n', '     * @return    The result\n', '     */\n', '    function sub1Over(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.den % d == 0) {\n', '            return bound(\n', '                a.num.sub(a.den.div(d)),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num.mul(d).sub(a.den),\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a / d\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  d  The divisor\n', '     * @return    The result (quotient)\n', '     */\n', '    function div(\n', '        Fraction.Fraction128 memory a,\n', '        uint128 d\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        if (a.num % d == 0) {\n', '            return bound(\n', '                a.num.div(d),\n', '                a.den\n', '            );\n', '        }\n', '        return bound(\n', '            a.num,\n', '            a.den.mul(d)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Returns a Fraction128 that is equal to a * b.\n', '     *\n', '     * @param  a  The first Fraction128\n', '     * @param  b  The second Fraction128\n', '     * @return    The result (product)\n', '     */\n', '    function mul(\n', '        Fraction.Fraction128 memory a,\n', '        Fraction.Fraction128 memory b\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return bound(\n', '            a.num.mul(b.num),\n', '            a.den.mul(b.den)\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Returns a fraction from two uint256's. Fits them into uint128 if necessary.\n", '     *\n', '     * @param  num  The numerator\n', '     * @param  den  The denominator\n', '     * @return      The Fraction128 that matches num/den most closely\n', '     */\n', '    /* solium-disable-next-line security/no-assign-params */\n', '    function bound(\n', '        uint256 num,\n', '        uint256 den\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        uint256 max = num > den ? num : den;\n', '        uint256 first128Bits = (max >> 128);\n', '        if (first128Bits != 0) {\n', '            first128Bits += 1;\n', '            num /= first128Bits;\n', '            den /= first128Bits;\n', '        }\n', '\n', '        assert(den != 0); // coverage-enable-line\n', '        assert(den < 2**128);\n', '        assert(num < 2**128);\n', '\n', '        return Fraction.Fraction128({\n', '            num: uint128(num),\n', '            den: uint128(den)\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns an in-memory copy of a Fraction128\n', '     *\n', '     * @param  a  The Fraction128 to copy\n', '     * @return    A copy of the Fraction128\n', '     */\n', '    function copy(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        validate(a);\n', '        return Fraction.Fraction128({ num: a.num, den: a.den });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Asserts that a Fraction128 is valid (i.e. the denominator is non-zero)\n', '     *\n', '     * @param  a  The Fraction128 to validate\n', '     */\n', '    function validate(\n', '        Fraction.Fraction128 memory a\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        assert(a.den != 0); // coverage-enable-line\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Exponent.sol\n', '\n', '/**\n', ' * @title Exponent\n', ' * @author dYdX\n', ' *\n', ' * This library contains an implementation for calculating e^X for arbitrary fraction X\n', ' */\n', 'library Exponent {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    // 2**128 - 1\n', '    uint128 constant public MAX_NUMERATOR = 340282366920938463463374607431768211455;\n', '\n', '    // Number of precomputed integers, X, for E^((1/2)^X)\n', '    uint256 constant public MAX_PRECOMPUTE_PRECISION = 32;\n', '\n', '    // Number of precomputed integers, X, for E^X\n', '    uint256 constant public NUM_PRECOMPUTED_INTEGERS = 32;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns e^X for any fraction X\n', '     *\n', '     * @param  X                    The exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function exp(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        require(\n', '            precomputePrecision <= MAX_PRECOMPUTE_PRECISION,\n', '            "Exponent#exp: Precompute precision over maximum"\n', '        );\n', '\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        // get the integer value of the fraction (example: 9/4 is 2.25 so has integerValue of 2)\n', '        uint256 integerX = uint256(Xcopy.num).div(Xcopy.den);\n', '\n', '        // if X is less than 1, then just calculate X\n', '        if (integerX == 0) {\n', '            return expHybrid(Xcopy, precomputePrecision, maclaurinPrecision);\n', '        }\n', '\n', '        // get e^integerX\n', '        Fraction.Fraction128 memory expOfInt =\n', '            getPrecomputedEToThe(integerX % NUM_PRECOMPUTED_INTEGERS);\n', '        while (integerX >= NUM_PRECOMPUTED_INTEGERS) {\n', '            expOfInt = expOfInt.mul(getPrecomputedEToThe(NUM_PRECOMPUTED_INTEGERS));\n', '            integerX -= NUM_PRECOMPUTED_INTEGERS;\n', '        }\n', '\n', '        // multiply e^integerX by e^decimalX\n', '        Fraction.Fraction128 memory decimalX = Fraction.Fraction128({\n', '            num: Xcopy.num % Xcopy.den,\n', '            den: Xcopy.den\n', '        });\n', '        return expHybrid(decimalX, precomputePrecision, maclaurinPrecision).mul(expOfInt);\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X < 1. Multiplies precomputed values to get close to the real value, then\n', '     * Maclaurin Series approximation to reduce error.\n', '     *\n', '     * @param  X                    Exponent\n', '     * @param  precomputePrecision  Accuracy of precomputed terms\n', '     * @param  maclaurinPrecision   Accuracy of Maclaurin terms\n', '     * @return                      e^X\n', '     */\n', '    function expHybrid(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precomputePrecision,\n', '        uint256 maclaurinPrecision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(precomputePrecision <= MAX_PRECOMPUTE_PRECISION);\n', '        assert(X.num < X.den);\n', '        // will also throw if precomputePrecision is larger than the array length in getDenominator\n', '\n', '        Fraction.Fraction128 memory Xtemp = X.copy();\n', '        if (Xtemp.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '\n', '        uint256 d = 1; // 2^i\n', '        for (uint256 i = 1; i <= precomputePrecision; i++) {\n', '            d *= 2;\n', '\n', '            // if Fraction > 1/d, subtract 1/d and multiply result by precomputed e^(1/d)\n', '            if (d.mul(Xtemp.num) >= Xtemp.den) {\n', '                Xtemp = Xtemp.sub1Over(uint128(d));\n', '                result = result.mul(getPrecomputedEToTheHalfToThe(i));\n', '            }\n', '        }\n', '        return result.mul(expMaclaurin(Xtemp, maclaurinPrecision));\n', '    }\n', '\n', '    /**\n', '     * Returns e^X for any X, using Maclaurin Series approximation\n', '     *\n', '     * e^X = SUM(X^n / n!) for n >= 0\n', '     * e^X = 1 + X/1! + X^2/2! + X^3/3! ...\n', '     *\n', '     * @param  X           Exponent\n', '     * @param  precision   Accuracy of Maclaurin terms\n', '     * @return             e^X\n', '     */\n', '    function expMaclaurin(\n', '        Fraction.Fraction128 memory X,\n', '        uint256 precision\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        Fraction.Fraction128 memory Xcopy = X.copy();\n', '        if (Xcopy.num == 0) { // e^0 = 1\n', '            return ONE();\n', '        }\n', '\n', '        Fraction.Fraction128 memory result = ONE();\n', '        Fraction.Fraction128 memory Xtemp = ONE();\n', '        for (uint256 i = 1; i <= precision; i++) {\n', '            Xtemp = Xtemp.mul(Xcopy.div(uint128(i)));\n', '            result = result.add(Xtemp);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^((1/2)^x) for integer x\n', '     */\n', '    function getPrecomputedEToTheHalfToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= MAX_PRECOMPUTE_PRECISION);\n', '\n', '        uint128 denominator = [\n', '            125182886983370532117250726298150828301,\n', '            206391688497133195273760705512282642279,\n', '            265012173823417992016237332255925138361,\n', '            300298134811882980317033350418940119802,\n', '            319665700530617779809390163992561606014,\n', '            329812979126047300897653247035862915816,\n', '            335006777809430963166468914297166288162,\n', '            337634268532609249517744113622081347950,\n', '            338955731696479810470146282672867036734,\n', '            339618401537809365075354109784799900812,\n', '            339950222128463181389559457827561204959,\n', '            340116253979683015278260491021941090650,\n', '            340199300311581465057079429423749235412,\n', '            340240831081268226777032180141478221816,\n', '            340261598367316729254995498374473399540,\n', '            340271982485676106947851156443492415142,\n', '            340277174663693808406010255284800906112,\n', '            340279770782412691177936847400746725466,\n', '            340281068849199706686796915841848278311,\n', '            340281717884450116236033378667952410919,\n', '            340282042402539547492367191008339680733,\n', '            340282204661700319870089970029119685699,\n', '            340282285791309720262481214385569134454,\n', '            340282326356121674011576912006427792656,\n', '            340282346638529464274601981200276914173,\n', '            340282356779733812753265346086924801364,\n', '            340282361850336100329388676752133324799,\n', '            340282364385637272451648746721404212564,\n', '            340282365653287865596328444437856608255,\n', '            340282366287113163939555716675618384724,\n', '            340282366604025813553891209601455838559,\n', '            340282366762482138471739420386372790954,\n', '            340282366841710300958333641874363209044\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns a fraction roughly equaling E^(x) for integer x\n', '     */\n', '    function getPrecomputedEToThe(\n', '        uint256 x\n', '    )\n', '        internal\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        assert(x <= NUM_PRECOMPUTED_INTEGERS);\n', '\n', '        uint128 denominator = [\n', '            340282366920938463463374607431768211455,\n', '            125182886983370532117250726298150828301,\n', '            46052210507670172419625860892627118820,\n', '            16941661466271327126146327822211253888,\n', '            6232488952727653950957829210887653621,\n', '            2292804553036637136093891217529878878,\n', '            843475657686456657683449904934172134,\n', '            310297353591408453462393329342695980,\n', '            114152017036184782947077973323212575,\n', '            41994180235864621538772677139808695,\n', '            15448795557622704876497742989562086,\n', '            5683294276510101335127414470015662,\n', '            2090767122455392675095471286328463,\n', '            769150240628514374138961856925097,\n', '            282954560699298259527814398449860,\n', '            104093165666968799599694528310221,\n', '            38293735615330848145349245349513,\n', '            14087478058534870382224480725096,\n', '            5182493555688763339001418388912,\n', '            1906532833141383353974257736699,\n', '            701374233231058797338605168652,\n', '            258021160973090761055471434334,\n', '            94920680509187392077350434438,\n', '            34919366901332874995585576427,\n', '            12846117181722897538509298435,\n', '            4725822410035083116489797150,\n', '            1738532907279185132707372378,\n', '            639570514388029575350057932,\n', '            235284843422800231081973821,\n', '            86556456714490055457751527,\n', '            31842340925906738090071268,\n', '            11714142585413118080082437,\n', '            4309392228124372433711936\n', '        ][x];\n', '        return Fraction.Fraction128({\n', '            num: MAX_NUMERATOR,\n', '            den: denominator\n', '        });\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function ONE()\n', '        private\n', '        pure\n', '        returns (Fraction.Fraction128 memory)\n', '    {\n', '        return Fraction.Fraction128({ num: 1, den: 1 });\n', '    }\n', '}\n', '\n', '// File: contracts/lib/MathHelpers.sol\n', '\n', '/**\n', ' * @title MathHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with common math functions in Solidity\n', ' */\n', 'library MathHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              target * numerator / denominator\n', '     */\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              Rounded-up result of target * numerator / denominator\n', '     */\n', '    function getPartialAmountRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return divisionRoundedUp(numerator.mul(target), denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates division given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator.\n', '     * @param  denominator  Denominator.\n', '     * @return              Rounded-up result of numerator / denominator\n', '     */\n', '    function divisionRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(denominator != 0); // coverage-enable-line\n', '        if (numerator == 0) {\n', '            return 0;\n', '        }\n', '        return numerator.sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint256(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint32(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        return 2 ** 32 - 1;\n', '    }\n', '\n', '    /**\n', '     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n', '     *\n', '     * @param  n  The uint256 to get the number of bits in\n', '     * @return    The number of bits in n\n', '     */\n', '    function getNumBits(\n', '        uint256 n\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 first = 0;\n', '        uint256 last = 256;\n', '        while (first < last) {\n', '            uint256 check = (first + last) / 2;\n', '            if ((n >> check) == 0) {\n', '                last = check;\n', '            } else {\n', '                first = check + 1;\n', '            }\n', '        }\n', '        assert(first <= 256);\n', '        return first;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/InterestImpl.sol\n', '\n', '/**\n', ' * @title InterestImpl\n', ' * @author dYdX\n', ' *\n', ' * A library that calculates continuously compounded interest for principal, time period, and\n', ' * interest rate.\n', ' */\n', 'library InterestImpl {\n', '    using SafeMath for uint256;\n', '    using FractionMath for Fraction.Fraction128;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant DEFAULT_PRECOMPUTE_PRECISION = 11;\n', '\n', '    uint256 constant DEFAULT_MACLAURIN_PRECISION = 5;\n', '\n', '    uint256 constant MAXIMUM_EXPONENT = 80;\n', '\n', '    uint128 constant E_TO_MAXIUMUM_EXPONENT = 55406223843935100525711733958316613;\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    /**\n', '     * Returns total tokens owed after accruing interest. Continuously compounding and accurate to\n', '     * roughly 10^18 decimal places. Continuously compounding interest follows the formula:\n', '     * I = P * e^(R*T)\n', '     *\n', '     * @param  principal           Principal of the interest calculation\n', '     * @param  interestRate        Annual nominal interest percentage times 10**6.\n', '     *                             (example: 5% = 5e6)\n', '     * @param  secondsOfInterest   Number of seconds that interest has been accruing\n', '     * @return                     Total amount of tokens owed. Greater than tokenAmount.\n', '     */\n', '    function getCompoundedInterest(\n', '        uint256 principal,\n', '        uint256 interestRate,\n', '        uint256 secondsOfInterest\n', '    )\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 numerator = interestRate.mul(secondsOfInterest);\n', '        uint128 denominator = (10**8) * (365 * 1 days);\n', '\n', '        // interestRate and secondsOfInterest should both be uint32\n', '        assert(numerator < 2**128);\n', '\n', '        // fraction representing (Rate * Time)\n', '        Fraction.Fraction128 memory rt = Fraction.Fraction128({\n', '            num: uint128(numerator),\n', '            den: denominator\n', '        });\n', '\n', '        // calculate e^(RT)\n', '        Fraction.Fraction128 memory eToRT;\n', '        if (numerator.div(denominator) >= MAXIMUM_EXPONENT) {\n', '            // degenerate case: cap calculation\n', '            eToRT = Fraction.Fraction128({\n', '                num: E_TO_MAXIUMUM_EXPONENT,\n', '                den: 1\n', '            });\n', '        } else {\n', '            // normal case: calculate e^(RT)\n', '            eToRT = Exponent.exp(\n', '                rt,\n', '                DEFAULT_PRECOMPUTE_PRECISION,\n', '                DEFAULT_MACLAURIN_PRECISION\n', '            );\n', '        }\n', '\n', '        // e^X for positive X should be greater-than or equal to 1\n', '        assert(eToRT.num >= eToRT.den);\n', '\n', '        return safeMultiplyUint256ByFraction(principal, eToRT);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Returns n * f, trying to prevent overflow as much as possible. Assumes that the numerator\n', '     * and denominator of f are less than 2**128.\n', '     */\n', '    function safeMultiplyUint256ByFraction(\n', '        uint256 n,\n', '        Fraction.Fraction128 memory f\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 term1 = n.div(2 ** 128); // first 128 bits\n', '        uint256 term2 = n % (2 ** 128); // second 128 bits\n', '\n', '        // uncommon scenario, requires n >= 2**128. calculates term1 = term1 * f\n', '        if (term1 > 0) {\n', '            term1 = term1.mul(f.num);\n', '            uint256 numBits = MathHelpers.getNumBits(term1);\n', '\n', '            // reduce rounding error by shifting all the way to the left before dividing\n', '            term1 = MathHelpers.divisionRoundedUp(\n', '                term1 << (uint256(256).sub(numBits)),\n', '                f.den);\n', '\n', '            // continue shifting or reduce shifting to get the right number\n', '            if (numBits > 128) {\n', '                term1 = term1 << (numBits.sub(128));\n', '            } else if (numBits < 128) {\n', '                term1 = term1 >> (uint256(128).sub(numBits));\n', '            }\n', '        }\n', '\n', '        // calculates term2 = term2 * f\n', '        term2 = MathHelpers.getPartialAmountRoundedUp(\n', '            f.num,\n', '            f.den,\n', '            term2\n', '        );\n', '\n', '        return term1.add(term2);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginState.sol\n', '\n', '/**\n', ' * @title MarginState\n', ' * @author dYdX\n', ' *\n', ' * Contains state for the Margin contract. Also used by libraries that implement Margin functions.\n', ' */\n', 'library MarginState {\n', '    struct State {\n', '        // Address of the Vault contract\n', '        address VAULT;\n', '\n', '        // Address of the TokenProxy contract\n', '        address TOKEN_PROXY;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been filled.\n', '        mapping (bytes32 => uint256) loanFills;\n', '\n', '        // Mapping from loanHash -> amount, which stores the amount of a loan which has\n', '        // already been canceled.\n', '        mapping (bytes32 => uint256) loanCancels;\n', '\n', '        // Mapping from positionId -> Position, which stores all the open margin positions.\n', '        mapping (bytes32 => MarginCommon.Position) positions;\n', '\n', '        // Mapping from positionId -> bool, which stores whether the position has previously been\n', '        // open, but is now closed.\n', '        mapping (bytes32 => bool) closedPositions;\n', '\n', '        // Mapping from positionId -> uint256, which stores the total amount of owedToken that has\n', '        // ever been repaid to the lender for each position. Does not reset.\n', '        mapping (bytes32 => uint256) totalOwedTokenRepaidToLender;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/LoanOwner.sol\n', '\n', '/**\n', ' * @title LoanOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a loan sell via the\n', '     * transferLoan function or the atomic-assign to the "owner" field in a loan offering.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receiveLoanOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/PositionOwner.sol\n', '\n', '/**\n', ' * @title PositionOwner\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PositionOwner {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive ownership of a position via the\n', '     * transferPosition function or the atomic-assign to the "owner" field when opening a position.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to keep ownership, a different address to pass-on ownership\n', '     */\n', '    function receivePositionOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/TransferInternal.sol\n', '\n', '/**\n', ' * @title TransferInternal\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for transferring ownership of loans and positions.\n', ' */\n', 'library TransferInternal {\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a postion was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Returns either the address of the new loan owner, or the address to which they wish to\n', '     * pass ownership of the loan. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the loan\n', '     * @param  newOwner    The intended owner of the loan\n', '     * @return             The address that the intended owner wishes to assign the loan to (may be\n', '     *                     the same as the intended owner).\n', '     */\n', '    function grantLoanOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit LoanTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                LoanOwner(newOwner).receiveLoanOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantLoanOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantLoanOwnership: New owner did not consent to owning loan"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '\n', '    /**\n', '     * Returns either the address of the new position owner, or the address to which they wish to\n', '     * pass ownership of the position. This function does not actually set the state of the position\n', '     *\n', '     * @param  positionId  The Unique ID of the position\n', '     * @param  oldOwner    The previous owner of the position\n', '     * @param  newOwner    The intended owner of the position\n', '     * @return             The address that the intended owner wishes to assign the position to (may\n', '     *                     be the same as the intended owner).\n', '     */\n', '    function grantPositionOwnership(\n', '        bytes32 positionId,\n', '        address oldOwner,\n', '        address newOwner\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        // log event except upon position creation\n', '        if (oldOwner != address(0)) {\n', '            emit PositionTransferred(positionId, oldOwner, newOwner);\n', '        }\n', '\n', '        if (AddressUtils.isContract(newOwner)) {\n', '            address nextOwner =\n', '                PositionOwner(newOwner).receivePositionOwnership(oldOwner, positionId);\n', '            if (nextOwner != newOwner) {\n', '                return grantPositionOwnership(positionId, newOwner, nextOwner);\n', '            }\n', '        }\n', '\n', '        require(\n', '            newOwner != address(0),\n', '            "TransferInternal#grantPositionOwnership: New owner did not consent to owning position"\n', '        );\n', '\n', '        return newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TimestampHelper.sol\n', '\n', '/**\n', ' * @title TimestampHelper\n', ' * @author dYdX\n', ' *\n', ' * Helper to get block timestamps in other formats\n', ' */\n', 'library TimestampHelper {\n', '    function getBlockTimestamp32()\n', '        internal\n', '        view\n', '        returns (uint32)\n', '    {\n', '        // Should not still be in-use in the year 2106\n', '        assert(uint256(uint32(block.timestamp)) == block.timestamp);\n', '\n', '        assert(block.timestamp > 0);\n', '\n', '        return uint32(block.timestamp);\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginCommon.sol\n', '\n', '/**\n', ' * @title MarginCommon\n', ' * @author dYdX\n', ' *\n', ' * This library contains common functions for implementations of public facing Margin functions\n', ' */\n', 'library MarginCommon {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Position {\n', '        address owedToken;       // Immutable\n', '        address heldToken;       // Immutable\n', '        address lender;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 requiredDeposit;\n', '        uint32  callTimeLimit;   // Immutable\n', '        uint32  startTimestamp;  // Immutable, cannot be 0\n', '        uint32  callTimestamp;\n', '        uint32  maxDuration;     // Immutable\n', '        uint32  interestRate;    // Immutable\n', '        uint32  interestPeriod;  // Immutable\n', '    }\n', '\n', '    struct LoanOffering {\n', '        address   owedToken;\n', '        address   heldToken;\n', '        address   payer;\n', '        address   owner;\n', '        address   taker;\n', '        address   positionOwner;\n', '        address   feeRecipient;\n', '        address   lenderFeeToken;\n', '        address   takerFeeToken;\n', '        LoanRates rates;\n', '        uint256   expirationTimestamp;\n', '        uint32    callTimeLimit;\n', '        uint32    maxDuration;\n', '        uint256   salt;\n', '        bytes32   loanHash;\n', '        bytes     signature;\n', '    }\n', '\n', '    struct LoanRates {\n', '        uint256 maxAmount;\n', '        uint256 minAmount;\n', '        uint256 minHeldToken;\n', '        uint256 lenderFee;\n', '        uint256 takerFee;\n', '        uint32  interestRate;\n', '        uint32  interestPeriod;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function storeNewPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        Position memory position,\n', '        address loanPayer\n', '    )\n', '        internal\n', '    {\n', '        assert(!positionHasExisted(state, positionId));\n', '        assert(position.owedToken != address(0));\n', '        assert(position.heldToken != address(0));\n', '        assert(position.owedToken != position.heldToken);\n', '        assert(position.owner != address(0));\n', '        assert(position.lender != address(0));\n', '        assert(position.maxDuration != 0);\n', '        assert(position.interestPeriod <= position.maxDuration);\n', '        assert(position.callTimestamp == 0);\n', '        assert(position.requiredDeposit == 0);\n', '\n', '        state.positions[positionId].owedToken = position.owedToken;\n', '        state.positions[positionId].heldToken = position.heldToken;\n', '        state.positions[positionId].principal = position.principal;\n', '        state.positions[positionId].callTimeLimit = position.callTimeLimit;\n', '        state.positions[positionId].startTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        state.positions[positionId].maxDuration = position.maxDuration;\n', '        state.positions[positionId].interestRate = position.interestRate;\n', '        state.positions[positionId].interestPeriod = position.interestPeriod;\n', '\n', '        state.positions[positionId].owner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            (position.owner != msg.sender) ? msg.sender : address(0),\n', '            position.owner\n', '        );\n', '\n', '        state.positions[positionId].lender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            (position.lender != loanPayer) ? loanPayer : address(0),\n', '            position.lender\n', '        );\n', '    }\n', '\n', '    function getPositionIdFromNonce(\n', '        uint256 nonce\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked(msg.sender, nonce));\n', '    }\n', '\n', '    function getUnavailableLoanOfferingAmountImpl(\n', '        MarginState.State storage state,\n', '        bytes32 loanHash\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash].add(state.loanCancels[loanHash]);\n', '    }\n', '\n', '    function cleanupPosition(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '    {\n', '        delete state.positions[positionId];\n', '        state.closedPositions[positionId] = true;\n', '    }\n', '\n', '    function calculateOwedAmount(\n', '        Position storage position,\n', '        uint256 closeAmount,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsed(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            closeAmount,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Calculates time elapsed rounded up to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsed(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round up to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = MathHelpers.divisionRoundedUp(elapsed, period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function calculateLenderAmountForIncreasePosition(\n', '        Position storage position,\n', '        uint256 principalToAdd,\n', '        uint256 endTimestamp\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 timeElapsed = calculateEffectiveTimeElapsedForNewLender(position, endTimestamp);\n', '\n', '        return InterestImpl.getCompoundedInterest(\n', '            principalToAdd,\n', '            position.interestRate,\n', '            timeElapsed\n', '        );\n', '    }\n', '\n', '    function getLoanOfferingHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                address(this),\n', '                loanOffering.owedToken,\n', '                loanOffering.heldToken,\n', '                loanOffering.payer,\n', '                loanOffering.owner,\n', '                loanOffering.taker,\n', '                loanOffering.positionOwner,\n', '                loanOffering.feeRecipient,\n', '                loanOffering.lenderFeeToken,\n', '                loanOffering.takerFeeToken,\n', '                getValuesHash(loanOffering)\n', '            )\n', '        );\n', '    }\n', '\n', '    function getPositionBalanceImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return Vault(state.VAULT).balances(positionId, state.positions[positionId].heldToken);\n', '    }\n', '\n', '    function containsPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.positions[positionId].startTimestamp != 0;\n', '    }\n', '\n', '    function positionHasExisted(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return containsPositionImpl(state, positionId) || state.closedPositions[positionId];\n', '    }\n', '\n', '    function getPositionFromStorage(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (Position storage)\n', '    {\n', '        Position storage position = state.positions[positionId];\n', '\n', '        require(\n', '            position.startTimestamp != 0,\n', '            "MarginCommon#getPositionFromStorage: The position does not exist"\n', '        );\n', '\n', '        return position;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Calculates time elapsed rounded down to the nearest interestPeriod\n', '     */\n', '    function calculateEffectiveTimeElapsedForNewLender(\n', '        Position storage position,\n', '        uint256 timestamp\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 elapsed = timestamp.sub(position.startTimestamp);\n', '\n', '        // round down to interestPeriod\n', '        uint256 period = position.interestPeriod;\n', '        if (period > 1) {\n', '            elapsed = elapsed.div(period).mul(period);\n', '        }\n', '\n', '        // bound by maxDuration\n', '        return Math.min256(\n', '            elapsed,\n', '            position.maxDuration\n', '        );\n', '    }\n', '\n', '    function getValuesHash(\n', '        LoanOffering loanOffering\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                loanOffering.rates.maxAmount,\n', '                loanOffering.rates.minAmount,\n', '                loanOffering.rates.minHeldToken,\n', '                loanOffering.rates.lenderFee,\n', '                loanOffering.rates.takerFee,\n', '                loanOffering.expirationTimestamp,\n', '                loanOffering.salt,\n', '                loanOffering.callTimeLimit,\n', '                loanOffering.maxDuration,\n', '                loanOffering.rates.interestRate,\n', '                loanOffering.rates.interestPeriod\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/PayoutRecipient.sol\n', '\n', '/**\n', ' * @title PayoutRecipient\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to be the payoutRecipient in a\n', ' * closePosition transaction.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface PayoutRecipient {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to receive payout from being the payoutRecipient\n', '     * in a closePosition transaction. May redistribute any payout as necessary. Throws on error.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  closeAmount        Amount of the position that was closed\n', '     * @param  closer             Address of the account or contract that closed the position\n', '     * @param  positionOwner      Address of the owner of the position\n', '     * @param  heldToken          Address of the ERC20 heldToken\n', '     * @param  payout             Number of tokens received from the payout\n', '     * @param  totalHeldToken     Total amount of heldToken removed from vault during close\n', '     * @param  payoutInHeldToken  True if payout is in heldToken, false if in owedToken\n', '     * @return                    True if approved by the receiver\n', '     */\n', '    function receiveClosePositionPayout(\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address closer,\n', '        address positionOwner,\n', '        address heldToken,\n', '        uint256 payout,\n', '        uint256 totalHeldToken,\n', '        bool    payoutInHeldToken\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CloseLoanDelegator.sol\n', '\n', '/**\n', ' * @title CloseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CloseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * closeWithoutCounterparty().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at most) the specified amount of the loan was\n', '     * successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of closeWithoutCounterparty()\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the loan to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeLoanOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/ClosePositionDelegator.sol\n', '\n', '/**\n', ' * @title ClosePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses close a position\n', ' * owned by the smart contract, allowing more complex logic to control positions.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ClosePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call closePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that (at-most) the specified amount of the position\n', '     * was successfully closed.\n', '     *\n', '     * @param  closer           Address of the caller of the closePosition() function\n', '     * @param  payoutRecipient  Address of the recipient of tokens paid out from closing\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requestedAmount  Requested principal amount of the position to close\n', '     * @return                  1) This address to accept, a different address to ask that contract\n', '     *                          2) The maximum amount that this contract is allowing\n', '     */\n', '    function closeOnBehalfOf(\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address, uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionShared.sol\n', '\n', '/**\n', ' * @title ClosePositionShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between ClosePositionImpl and\n', ' * CloseWithoutCounterpartyImpl\n', ' */\n', 'library ClosePositionShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct CloseTx {\n', '        bytes32 positionId;\n', '        uint256 originalPrincipal;\n', '        uint256 closeAmount;\n', '        uint256 owedTokenOwed;\n', '        uint256 startingHeldTokenBalance;\n', '        uint256 availableHeldToken;\n', '        address payoutRecipient;\n', '        address owedToken;\n', '        address heldToken;\n', '        address positionOwner;\n', '        address positionLender;\n', '        address exchangeWrapper;\n', '        bool    payoutInHeldToken;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    function closePositionStateUpdate(\n', '        MarginState.State storage state,\n', '        CloseTx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        // Delete the position, or just decrease the principal\n', '        if (transaction.closeAmount == transaction.originalPrincipal) {\n', '            MarginCommon.cleanupPosition(state, transaction.positionId);\n', '        } else {\n', '            assert(\n', '                transaction.originalPrincipal == state.positions[transaction.positionId].principal\n', '            );\n', '            state.positions[transaction.positionId].principal =\n', '                transaction.originalPrincipal.sub(transaction.closeAmount);\n', '        }\n', '    }\n', '\n', '    function sendTokensToPayoutRecipient(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 receivedOwedToken\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 payout;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            // Send remaining heldToken to payoutRecipient\n', '            payout = transaction.availableHeldToken.sub(buybackCostInHeldToken);\n', '\n', '            Vault(state.VAULT).transferFromVault(\n', '                transaction.positionId,\n', '                transaction.heldToken,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        } else {\n', '            assert(transaction.exchangeWrapper != address(0));\n', '\n', '            payout = receivedOwedToken.sub(transaction.owedTokenOwed);\n', '\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.payoutRecipient,\n', '                payout\n', '            );\n', '        }\n', '\n', '        if (AddressUtils.isContract(transaction.payoutRecipient)) {\n', '            require(\n', '                PayoutRecipient(transaction.payoutRecipient).receiveClosePositionPayout(\n', '                    transaction.positionId,\n', '                    transaction.closeAmount,\n', '                    msg.sender,\n', '                    transaction.positionOwner,\n', '                    transaction.heldToken,\n', '                    payout,\n', '                    transaction.availableHeldToken,\n', '                    transaction.payoutInHeldToken\n', '                ),\n', '                "ClosePositionShared#sendTokensToPayoutRecipient: Payout recipient does not consent"\n', '            );\n', '        }\n', '\n', '        // The ending heldToken balance of the vault should be the starting heldToken balance\n', '        // minus the available heldToken amount\n', '        assert(\n', '            MarginCommon.getPositionBalanceImpl(state, transaction.positionId)\n', '            == transaction.startingHeldTokenBalance.sub(transaction.availableHeldToken)\n', '        );\n', '\n', '        return payout;\n', '    }\n', '\n', '    function createCloseTx(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        internal\n', '        returns (CloseTx memory)\n', '    {\n', '        // Validate\n', '        require(\n', '            payoutRecipient != address(0),\n', '            "ClosePositionShared#createCloseTx: Payout recipient cannot be 0"\n', '        );\n', '        require(\n', '            requestedAmount > 0,\n', '            "ClosePositionShared#createCloseTx: Requested close amount cannot be 0"\n', '        );\n', '\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 closeAmount = getApprovedAmount(\n', '            position,\n', '            positionId,\n', '            requestedAmount,\n', '            payoutRecipient,\n', '            isWithoutCounterparty\n', '        );\n', '\n', '        return parseCloseTx(\n', '            state,\n', '            position,\n', '            positionId,\n', '            closeAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            isWithoutCounterparty\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function getApprovedAmount(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 requestedAmount,\n', '        address payoutRecipient,\n', '        bool requireLenderApproval\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // Ensure enough principal\n', '        uint256 allowedAmount = Math.min256(requestedAmount, position.principal);\n', '\n', '        // Ensure owner consent\n', '        allowedAmount = closePositionOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            payoutRecipient,\n', '            positionId,\n', '            allowedAmount\n', '        );\n', '\n', '        // Ensure lender consent\n', '        if (requireLenderApproval) {\n', '            allowedAmount = closeLoanOnBehalfOfRecurse(\n', '                position.lender,\n', '                msg.sender,\n', '                payoutRecipient,\n', '                positionId,\n', '                allowedAmount\n', '            );\n', '        }\n', '\n', '        assert(allowedAmount > 0);\n', '        assert(allowedAmount <= position.principal);\n', '        assert(allowedAmount <= requestedAmount);\n', '\n', '        return allowedAmount;\n', '    }\n', '\n', '    function closePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = ClosePositionDelegator(contractAddr).closeOnBehalfOf(\n', '            closer,\n', '            payoutRecipient,\n', '            positionId,\n', '            closeAmount\n', '        );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closePositionRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    function closeLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address closer,\n', '        address payoutRecipient,\n', '        bytes32 positionId,\n', '        uint256 closeAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // no need to ask for permission\n', '        if (closer == contractAddr) {\n', '            return closeAmount;\n', '        }\n', '\n', '        (\n', '            address newContractAddr,\n', '            uint256 newCloseAmount\n', '        ) = CloseLoanDelegator(contractAddr).closeLoanOnBehalfOf(\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                closeAmount\n', '            );\n', '\n', '        require(\n', '            newCloseAmount <= closeAmount,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is greater than closeAmount"\n', '        );\n', '        require(\n', '            newCloseAmount > 0,\n', '            "ClosePositionShared#closeLoanRecurse: newCloseAmount is zero"\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            closeLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                closer,\n', '                payoutRecipient,\n', '                positionId,\n', '                newCloseAmount\n', '            );\n', '        }\n', '\n', '        return newCloseAmount;\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseCloseTx(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 closeAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bool isWithoutCounterparty\n', '    )\n', '        private\n', '        view\n', '        returns (CloseTx memory)\n', '    {\n', '        uint256 startingHeldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        uint256 availableHeldToken = MathHelpers.getPartialAmount(\n', '            closeAmount,\n', '            position.principal,\n', '            startingHeldTokenBalance\n', '        );\n', '        uint256 owedTokenOwed = 0;\n', '\n', '        if (!isWithoutCounterparty) {\n', '            owedTokenOwed = MarginCommon.calculateOwedAmount(\n', '                position,\n', '                closeAmount,\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        return CloseTx({\n', '            positionId: positionId,\n', '            originalPrincipal: position.principal,\n', '            closeAmount: closeAmount,\n', '            owedTokenOwed: owedTokenOwed,\n', '            startingHeldTokenBalance: startingHeldTokenBalance,\n', '            availableHeldToken: availableHeldToken,\n', '            payoutRecipient: payoutRecipient,\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            positionOwner: position.owner,\n', '            positionLender: position.lender,\n', '            exchangeWrapper: exchangeWrapper,\n', '            payoutInHeldToken: payoutInHeldToken\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n', ' * with other smart contracts through a common interface.\n', ' */\n', 'interface ExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the transaction\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/impl/ClosePositionImpl.sol\n', '\n', '/**\n', ' * @title ClosePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closePosition function of Margin\n', ' */\n', 'library ClosePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool    payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool payoutInHeldToken,\n', '        bytes memory orderData\n', '    )\n', '        public\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            false\n', '        );\n', '\n', '        (\n', '            uint256 buybackCostInHeldToken,\n', '            uint256 receivedOwedToken\n', '        ) = returnOwedTokensToLender(\n', '            state,\n', '            transaction,\n', '            orderData\n', '        );\n', '\n', '        uint256 payout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            receivedOwedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnClose(\n', '            transaction,\n', '            buybackCostInHeldToken,\n', '            payout\n', '        );\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            payout,\n', '            transaction.owedTokenOwed\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function returnOwedTokensToLender(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx memory transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 buybackCostInHeldToken = 0;\n', '        uint256 receivedOwedToken = 0;\n', '        uint256 lenderOwedToken = transaction.owedTokenOwed;\n', '\n', '        // Setting exchangeWrapper to 0x000... indicates owedToken should be taken directly\n', '        // from msg.sender\n', '        if (transaction.exchangeWrapper == address(0)) {\n', '            require(\n', '                transaction.payoutInHeldToken,\n', '                "ClosePositionImpl#returnOwedTokensToLender: Cannot payout in owedToken"\n', '            );\n', '\n', '            // No DEX Order; send owedTokens directly from the closer to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                msg.sender,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        } else {\n', '            // Buy back owedTokens using DEX Order and send to lender\n', '            (buybackCostInHeldToken, receivedOwedToken) = buyBackOwedToken(\n', '                state,\n', '                transaction,\n', '                orderData\n', '            );\n', '\n', '            // If no owedToken needed for payout: give lender all owedToken, even if more than owed\n', '            if (transaction.payoutInHeldToken) {\n', '                assert(receivedOwedToken >= lenderOwedToken);\n', '                lenderOwedToken = receivedOwedToken;\n', '            }\n', '\n', '            // Transfer owedToken from the exchange wrapper to the lender\n', '            TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '                transaction.owedToken,\n', '                transaction.exchangeWrapper,\n', '                transaction.positionLender,\n', '                lenderOwedToken\n', '            );\n', '        }\n', '\n', '        state.totalOwedTokenRepaidToLender[transaction.positionId] =\n', '            state.totalOwedTokenRepaidToLender[transaction.positionId].add(lenderOwedToken);\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function buyBackOwedToken(\n', '        MarginState.State storage state,\n', '        ClosePositionShared.CloseTx transaction,\n', '        bytes memory orderData\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', '        // Ask the exchange wrapper the cost in heldToken to buy back the close\n', '        // amount of owedToken\n', '        uint256 buybackCostInHeldToken;\n', '\n', '        if (transaction.payoutInHeldToken) {\n', '            buybackCostInHeldToken = ExchangeWrapper(transaction.exchangeWrapper)\n', '                .getExchangeCost(\n', '                    transaction.owedToken,\n', '                    transaction.heldToken,\n', '                    transaction.owedTokenOwed,\n', '                    orderData\n', '                );\n', '\n', '            // Require enough available heldToken to pay for the buyback\n', '            require(\n', '                buybackCostInHeldToken <= transaction.availableHeldToken,\n', '                "ClosePositionImpl#buyBackOwedToken: Not enough available heldToken"\n', '            );\n', '        } else {\n', '            buybackCostInHeldToken = transaction.availableHeldToken;\n', '        }\n', '\n', '        // Send the requisite heldToken to do the buyback from vault to exchange wrapper\n', '        Vault(state.VAULT).transferFromVault(\n', '            transaction.positionId,\n', '            transaction.heldToken,\n', '            transaction.exchangeWrapper,\n', '            buybackCostInHeldToken\n', '        );\n', '\n', '        // Trade the heldToken for the owedToken\n', '        uint256 receivedOwedToken = ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '            msg.sender,\n', '            state.TOKEN_PROXY,\n', '            transaction.owedToken,\n', '            transaction.heldToken,\n', '            buybackCostInHeldToken,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            receivedOwedToken >= transaction.owedTokenOwed,\n', '            "ClosePositionImpl#buyBackOwedToken: Did not receive enough owedToken"\n', '        );\n', '\n', '        return (buybackCostInHeldToken, receivedOwedToken);\n', '    }\n', '\n', '    function logEventOnClose(\n', '        ClosePositionShared.CloseTx transaction,\n', '        uint256 buybackCostInHeldToken,\n', '        uint256 payout\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            transaction.owedTokenOwed,\n', '            payout,\n', '            buybackCostInHeldToken,\n', '            transaction.payoutInHeldToken\n', '        );\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/CloseWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title CloseWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the closeWithoutCounterpartyImpl function of\n', ' * Margin\n', ' */\n', 'library CloseWithoutCounterpartyImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function closeWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        public\n', '        returns (uint256, uint256)\n', '    {\n', '        ClosePositionShared.CloseTx memory transaction = ClosePositionShared.createCloseTx(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            true\n', '        );\n', '\n', '        uint256 heldTokenPayout = ClosePositionShared.sendTokensToPayoutRecipient(\n', '            state,\n', '            transaction,\n', '            0, // No buyback cost\n', '            0  // Did not receive any owedToken\n', '        );\n', '\n', '        ClosePositionShared.closePositionStateUpdate(state, transaction);\n', '\n', '        logEventOnCloseWithoutCounterparty(transaction);\n', '\n', '        return (\n', '            transaction.closeAmount,\n', '            heldTokenPayout\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function logEventOnCloseWithoutCounterparty(\n', '        ClosePositionShared.CloseTx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionClosed(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.payoutRecipient,\n', '            transaction.closeAmount,\n', '            transaction.originalPrincipal.sub(transaction.closeAmount),\n', '            0,\n', '            transaction.availableHeldToken,\n', '            0,\n', '            true\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/DepositCollateralDelegator.sol\n', '\n', '/**\n', ' * @title DepositCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses deposit heldTokens\n', ' * into a position owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface DepositCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call depositCollateral().\n', '     *\n', '     * @param  depositor   Address of the caller of the depositCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  amount      Requested deposit amount\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function depositCollateralOnBehalfOf(\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/DepositCollateralImpl.sol\n', '\n', '/**\n', ' * @title DepositCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the deposit function of Margin\n', ' */\n', 'library DepositCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function depositCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            depositAmount > 0,\n', '            "DepositCollateralImpl#depositCollateralImpl: Deposit amount cannot be 0"\n', '        );\n', '\n', '        // Ensure owner consent\n', '        depositCollateralOnBehalfOfRecurse(\n', '            position.owner,\n', '            msg.sender,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            depositAmount\n', '        );\n', '\n', '        // cancel margin call if applicable\n', '        bool marginCallCanceled = false;\n', '        uint256 requiredDeposit = position.requiredDeposit;\n', '        if (position.callTimestamp > 0 && requiredDeposit > 0) {\n', '            if (depositAmount >= requiredDeposit) {\n', '                position.requiredDeposit = 0;\n', '                position.callTimestamp = 0;\n', '                marginCallCanceled = true;\n', '            } else {\n', '                position.requiredDeposit = position.requiredDeposit.sub(depositAmount);\n', '            }\n', '        }\n', '\n', '        emit AdditionalCollateralDeposited(\n', '            positionId,\n', '            depositAmount,\n', '            msg.sender\n', '        );\n', '\n', '        if (marginCallCanceled) {\n', '            emit MarginCallCanceled(\n', '                positionId,\n', '                position.lender,\n', '                msg.sender,\n', '                depositAmount\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function depositCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address depositor,\n', '        bytes32 positionId,\n', '        uint256 amount\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (depositor == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            DepositCollateralDelegator(contractAddr).depositCollateralOnBehalfOf(\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '\n', '        // if not equal, recurse\n', '        if (newContractAddr != contractAddr) {\n', '            depositCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                depositor,\n', '                positionId,\n', '                amount\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/ForceRecoverCollateralDelegator.sol\n', '\n', '/**\n', ' * @title ForceRecoverCollateralDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses\n', ' * forceRecoverCollateral() a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface ForceRecoverCollateralDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * forceRecoverCollateral().\n', '     *\n', '     * NOTE: If not returning zero address (or not reverting), this contract must assume that Margin\n', '     * will either revert the entire transaction or that the collateral was forcibly recovered.\n', '     *\n', '     * @param  recoverer   Address of the caller of the forceRecoverCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function forceRecoverCollateralOnBehalfOf(\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/ForceRecoverCollateralImpl.sol\n', '\n', '/**\n', ' * @title ForceRecoverCollateralImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the forceRecoverCollateral function of Margin\n', ' */\n', 'library ForceRecoverCollateralImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function forceRecoverCollateralImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Can only force recover after either:\n', '        // 1) The loan was called and the call period has elapsed\n', '        // 2) The maxDuration of the position has elapsed\n', '        require( /* solium-disable-next-line */\n', '            (\n', '                position.callTimestamp > 0\n', '                && block.timestamp >= uint256(position.callTimestamp).add(position.callTimeLimit)\n', '            ) || (\n', '                block.timestamp >= uint256(position.startTimestamp).add(position.maxDuration)\n', '            ),\n', '            "ForceRecoverCollateralImpl#forceRecoverCollateralImpl: Cannot recover yet"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        forceRecoverCollateralOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            recipient\n', '        );\n', '\n', '        // Send the tokens\n', '        uint256 heldTokenRecovered = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '        Vault(state.VAULT).transferFromVault(\n', '            positionId,\n', '            position.heldToken,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        // Delete the position\n', '        // NOTE: Since position is a storage pointer, this will also set all fields on\n', '        //       the position variable to 0\n', '        MarginCommon.cleanupPosition(\n', '            state,\n', '            positionId\n', '        );\n', '\n', '        // Log an event\n', '        emit CollateralForceRecovered(\n', '            positionId,\n', '            recipient,\n', '            heldTokenRecovered\n', '        );\n', '\n', '        return heldTokenRecovered;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function forceRecoverCollateralOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address recoverer,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (recoverer == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            ForceRecoverCollateralDelegator(contractAddr).forceRecoverCollateralOnBehalfOf(\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            forceRecoverCollateralOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                recoverer,\n', '                positionId,\n', '                recipient\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/TypedSignature.sol\n', '\n', '/**\n', ' * @title TypedSignature\n', ' * @author dYdX\n', ' *\n', ' * Allows for ecrecovery of signed hashes with three different prepended messages:\n', ' * 1) ""\n', ' * 2) "\\x19Ethereum Signed Message:\\n32"\n', ' * 3) "\\x19Ethereum Signed Message:\\n\\x20"\n', ' */\n', 'library TypedSignature {\n', '\n', '    // Solidity does not offer guarantees about enum values, so we define them explicitly\n', '    uint8 private constant SIGTYPE_INVALID = 0;\n', '    uint8 private constant SIGTYPE_ECRECOVER_DEC = 1;\n', '    uint8 private constant SIGTYPE_ECRECOVER_HEX = 2;\n', '    uint8 private constant SIGTYPE_UNSUPPORTED = 3;\n', '\n', '    // prepended message with the length of the signed hash in hexadecimal\n', '    bytes constant private PREPEND_HEX = "\\x19Ethereum Signed Message:\\n\\x20";\n', '\n', '    // prepended message with the length of the signed hash in decimal\n', '    bytes constant private PREPEND_DEC = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    /**\n', '     * Gives the address of the signer of a hash. Allows for three common prepended strings.\n', '     *\n', '     * @param  hash               Hash that was signed (does not include prepended message)\n', '     * @param  signatureWithType  Type and ECDSA signature with structure: {1:type}{1:v}{32:r}{32:s}\n', '     * @return                    address of the signer of the hash\n', '     */\n', '    function recover(\n', '        bytes32 hash,\n', '        bytes signatureWithType\n', '    )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(\n', '            signatureWithType.length == 66,\n', '            "SignatureValidator#validateSignature: invalid signature length"\n', '        );\n', '\n', '        uint8 sigType = uint8(signatureWithType[0]);\n', '\n', '        require(\n', '            sigType > uint8(SIGTYPE_INVALID),\n', '            "SignatureValidator#validateSignature: invalid signature type"\n', '        );\n', '        require(\n', '            sigType < uint8(SIGTYPE_UNSUPPORTED),\n', '            "SignatureValidator#validateSignature: unsupported signature type"\n', '        );\n', '\n', '        uint8 v = uint8(signatureWithType[1]);\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            r := mload(add(signatureWithType, 34))\n', '            s := mload(add(signatureWithType, 66))\n', '        }\n', '\n', '        bytes32 signedHash;\n', '        if (sigType == SIGTYPE_ECRECOVER_DEC) {\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\n', '        } else {\n', '            assert(sigType == SIGTYPE_ECRECOVER_HEX);\n', '            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\n', '        }\n', '\n', '        return ecrecover(\n', '            signedHash,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/LoanOfferingVerifier.sol\n', '\n', '/**\n', ' * @title LoanOfferingVerifier\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement to be able to make off-chain generated\n', ' * loan offerings.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface LoanOfferingVerifier {\n', '\n', '    /**\n', '     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n', '     * will be generated off-chain. The "loan owner" address will own the loan-side of the resulting\n', '     * position.\n', '     *\n', '     * If true is returned, and no errors are thrown by the Margin contract, the loan will have\n', '     * occurred. This means that verifyLoanOffering can also be used to update internal contract\n', '     * state on a loan.\n', '     *\n', '     * @param  addresses    Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan positionOwner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  positionId   Unique ID of the position\n', '     * @param  signature    Arbitrary bytes; may or may not be an ECDSA signature\n', '     * @return              This address to accept, a different address to ask that contract\n', '     */\n', '    function verifyLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/BorrowShared.sol\n', '\n', '/**\n', ' * @title BorrowShared\n', ' * @author dYdX\n', ' *\n', ' * This library contains shared functionality between OpenPositionImpl and IncreasePositionImpl.\n', ' * Both use a Loan Offering and a DEX Order to open or increase a position.\n', ' */\n', 'library BorrowShared {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address owner;\n', '        uint256 principal;\n', '        uint256 lenderAmount;\n', '        MarginCommon.LoanOffering loanOffering;\n', '        address exchangeWrapper;\n', '        bool depositInHeldToken;\n', '        uint256 depositAmount;\n', '        uint256 collateralAmount;\n', '        uint256 heldTokenFromSell;\n', '    }\n', '\n', '    // ============ Internal Implementation Functions ============\n', '\n', '    /**\n', '     * Validate the transaction before exchanging heldToken for owedToken\n', '     */\n', '    function validateTxPreSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        assert(transaction.lenderAmount >= transaction.principal);\n', '\n', '        require(\n', '            transaction.principal > 0,\n', '            "BorrowShared#validateTxPreSell: Positions with 0 principal are not allowed"\n', '        );\n', '\n', '        // If the taker is 0x0 then any address can take it. Otherwise only the taker can use it.\n', '        if (transaction.loanOffering.taker != address(0)) {\n', '            require(\n', '                msg.sender == transaction.loanOffering.taker,\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering taker"\n', '            );\n', '        }\n', '\n', '        // If the positionOwner is 0x0 then any address can be set as the position owner.\n', '        // Otherwise only the specified positionOwner can be set as the position owner.\n', '        if (transaction.loanOffering.positionOwner != address(0)) {\n', '            require(\n', '                transaction.owner == transaction.loanOffering.positionOwner,\n', '                "BorrowShared#validateTxPreSell: Invalid position owner"\n', '            );\n', '        }\n', '\n', '        // Require the loan offering to be approved by the payer\n', '        if (AddressUtils.isContract(transaction.loanOffering.payer)) {\n', '            getConsentFromSmartContractLender(transaction);\n', '        } else {\n', '            require(\n', '                transaction.loanOffering.payer == TypedSignature.recover(\n', '                    transaction.loanOffering.loanHash,\n', '                    transaction.loanOffering.signature\n', '                ),\n', '                "BorrowShared#validateTxPreSell: Invalid loan offering signature"\n', '            );\n', '        }\n', '\n', '        // Validate the amount is <= than max and >= min\n', '        uint256 unavailable = MarginCommon.getUnavailableLoanOfferingAmountImpl(\n', '            state,\n', '            transaction.loanOffering.loanHash\n', '        );\n', '        require(\n', '            transaction.lenderAmount.add(unavailable) <= transaction.loanOffering.rates.maxAmount,\n', '            "BorrowShared#validateTxPreSell: Loan offering does not have enough available"\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount >= transaction.loanOffering.rates.minAmount,\n', '            "BorrowShared#validateTxPreSell: Lender amount is below loan offering minimum amount"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owedToken != transaction.loanOffering.heldToken,\n', '            "BorrowShared#validateTxPreSell: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            transaction.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Position owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.owner != address(0),\n', '            "BorrowShared#validateTxPreSell: Loan owner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.expirationTimestamp > block.timestamp,\n', '            "BorrowShared#validateTxPreSell: Loan offering is expired"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.maxDuration > 0,\n', '            "BorrowShared#validateTxPreSell: Loan offering has 0 maximum duration"\n', '        );\n', '\n', '        require(\n', '            transaction.loanOffering.rates.interestPeriod <= transaction.loanOffering.maxDuration,\n', '            "BorrowShared#validateTxPreSell: Loan offering interestPeriod > maxDuration"\n', '        );\n', '\n', '        // The minimum heldToken is validated after executing the sell\n', '        // Position and loan ownership is validated in TransferInternal\n', '    }\n', '\n', '    /**\n', '     * Validate the transaction after exchanging heldToken for owedToken, pay out fees, and store\n', '     * how much of the loan was used.\n', '     */\n', '    function doPostSell(\n', '        MarginState.State storage state,\n', '        Tx memory transaction\n', '    )\n', '        internal\n', '    {\n', '        validateTxPostSell(transaction);\n', '\n', '        // Transfer feeTokens from trader and lender\n', '        transferLoanFees(state, transaction);\n', '\n', '        // Update global amounts for the loan\n', '        state.loanFills[transaction.loanOffering.loanHash] =\n', '            state.loanFills[transaction.loanOffering.loanHash].add(transaction.lenderAmount);\n', '    }\n', '\n', '    /**\n', '     * Sells the owedToken from the lender (and from the deposit if in owedToken) using the\n', '     * exchangeWrapper, then puts the resulting heldToken into the vault. Only trades for\n', '     * maxHeldTokenToBuy of heldTokens at most.\n', '     */\n', '    function doSell(\n', '        MarginState.State storage state,\n', '        Tx transaction,\n', '        bytes orderData,\n', '        uint256 maxHeldTokenToBuy\n', '    )\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // Move owedTokens from lender to exchange wrapper\n', '        pullOwedTokensFromLender(state, transaction);\n', '\n', "        // Sell just the lender's owedToken (if trader deposit is in heldToken)\n", "        // Otherwise sell both the lender's owedToken and the trader's deposit in owedToken\n", '        uint256 sellAmount = transaction.depositInHeldToken ?\n', '            transaction.lenderAmount :\n', '            transaction.lenderAmount.add(transaction.depositAmount);\n', '\n', '        // Do the trade, taking only the maxHeldTokenToBuy if more is returned\n', '        uint256 heldTokenFromSell = Math.min256(\n', '            maxHeldTokenToBuy,\n', '            ExchangeWrapper(transaction.exchangeWrapper).exchange(\n', '                msg.sender,\n', '                state.TOKEN_PROXY,\n', '                transaction.loanOffering.heldToken,\n', '                transaction.loanOffering.owedToken,\n', '                sellAmount,\n', '                orderData\n', '            )\n', '        );\n', '\n', '        // Move the tokens to the vault\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.exchangeWrapper,\n', '            heldTokenFromSell\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(heldTokenFromSell);\n', '\n', '        return heldTokenFromSell;\n', '    }\n', '\n', '    /**\n', '     * Take the owedToken deposit from the trader and give it to the exchange wrapper so that it can\n', '     * be sold for heldToken.\n', '     */\n', '    function doDepositOwedToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            msg.sender,\n', '            transaction.exchangeWrapper,\n', '            transaction.depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Take the heldToken deposit from the trader and move it to the vault.\n', '     */\n', '    function doDepositHeldToken(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        internal\n', '    {\n', '        Vault(state.VAULT).transferToVault(\n', '            transaction.positionId,\n', '            transaction.loanOffering.heldToken,\n', '            msg.sender,\n', '            transaction.depositAmount\n', '        );\n', '\n', '        // Update collateral amount\n', '        transaction.collateralAmount = transaction.collateralAmount.add(transaction.depositAmount);\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function validateTxPostSell(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        uint256 expectedCollateral = transaction.depositInHeldToken ?\n', '            transaction.heldTokenFromSell.add(transaction.depositAmount) :\n', '            transaction.heldTokenFromSell;\n', '        assert(transaction.collateralAmount == expectedCollateral);\n', '\n', '        uint256 loanOfferingMinimumHeldToken = MathHelpers.getPartialAmountRoundedUp(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minHeldToken\n', '        );\n', '        require(\n', '            transaction.collateralAmount >= loanOfferingMinimumHeldToken,\n', '            "BorrowShared#validateTxPostSell: Loan offering minimum held token not met"\n', '        );\n', '    }\n', '\n', '    function getConsentFromSmartContractLender(\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        verifyLoanOfferingRecurse(\n', '            transaction.loanOffering.payer,\n', '            getLoanOfferingAddresses(transaction),\n', '            getLoanOfferingValues256(transaction),\n', '            getLoanOfferingValues32(transaction),\n', '            transaction.positionId,\n', '            transaction.loanOffering.signature\n', '        );\n', '    }\n', '\n', '    function verifyLoanOfferingRecurse(\n', '        address contractAddr,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        private\n', '    {\n', '        address newContractAddr = LoanOfferingVerifier(contractAddr).verifyLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            positionId,\n', '            signature\n', '        );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            verifyLoanOfferingRecurse(\n', '                newContractAddr,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                positionId,\n', '                signature\n', '            );\n', '        }\n', '    }\n', '\n', '    function pullOwedTokensFromLender(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // Transfer owedToken to the exchange wrapper\n', '        TokenProxy(state.TOKEN_PROXY).transferTokens(\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.exchangeWrapper,\n', '            transaction.lenderAmount\n', '        );\n', '    }\n', '\n', '    function transferLoanFees(\n', '        MarginState.State storage state,\n', '        Tx transaction\n', '    )\n', '        private\n', '    {\n', '        // 0 fee address indicates no fees\n', '        if (transaction.loanOffering.feeRecipient == address(0)) {\n', '            return;\n', '        }\n', '\n', '        TokenProxy proxy = TokenProxy(state.TOKEN_PROXY);\n', '\n', '        uint256 lenderFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.lenderFee\n', '        );\n', '        uint256 takerFee = MathHelpers.getPartialAmount(\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.takerFee\n', '        );\n', '\n', '        if (lenderFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.lenderFeeToken,\n', '                transaction.loanOffering.payer,\n', '                transaction.loanOffering.feeRecipient,\n', '                lenderFee\n', '            );\n', '        }\n', '\n', '        if (takerFee > 0) {\n', '            proxy.transferTokens(\n', '                transaction.loanOffering.takerFeeToken,\n', '                msg.sender,\n', '                transaction.loanOffering.feeRecipient,\n', '                takerFee\n', '            );\n', '        }\n', '    }\n', '\n', '    function getLoanOfferingAddresses(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (address[9])\n', '    {\n', '        return [\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.owner,\n', '            transaction.loanOffering.taker,\n', '            transaction.loanOffering.positionOwner,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.loanOffering.lenderFeeToken,\n', '            transaction.loanOffering.takerFeeToken\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues256(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256[7])\n', '    {\n', '        return [\n', '            transaction.loanOffering.rates.maxAmount,\n', '            transaction.loanOffering.rates.minAmount,\n', '            transaction.loanOffering.rates.minHeldToken,\n', '            transaction.loanOffering.rates.lenderFee,\n', '            transaction.loanOffering.rates.takerFee,\n', '            transaction.loanOffering.expirationTimestamp,\n', '            transaction.loanOffering.salt\n', '        ];\n', '    }\n', '\n', '    function getLoanOfferingValues32(\n', '        Tx transaction\n', '    )\n', '        private\n', '        pure\n', '        returns (uint32[4])\n', '    {\n', '        return [\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.rates.interestPeriod\n', '        ];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/IncreaseLoanDelegator.sol\n', '\n', '/**\n', ' * @title IncreaseLoanDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own loans on behalf of other accounts.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreaseLoanDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned loan. Margin will call this on the owner of a loan during increasePosition().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan size was successfully increased.\n', '     *\n', '     * @param  payer           Lender adding additional funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Principal amount to be added to the position\n', '     * @param  lentAmount      Amount of owedToken lent by the lender (principal plus interest, or\n', '     *                         zero if increaseWithoutCounterparty() is used).\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increaseLoanOnBehalfOf(\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/owner/IncreasePositionDelegator.sol\n', '\n', '/**\n', ' * @title IncreasePositionDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to own position on behalf of other\n', ' * accounts\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface IncreasePositionDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to allow additional value to be added onto\n', '     * an owned position. Margin will call this on the owner of a position during increasePosition()\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the position size was successfully increased.\n', '     *\n', '     * @param  trader          Address initiating the addition of funds to the position\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount of principal to be added to the position\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increasePositionOnBehalfOf(\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/IncreasePositionImpl.sol\n', '\n', '/**\n', ' * @title IncreasePositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the increasePosition function of Margin\n', ' */\n', 'library IncreasePositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function increasePositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        // Also ensures that the position exists\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        BorrowShared.Tx memory transaction = parseIncreasePositionTx(\n', '            position,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        validateIncrease(state, transaction, position);\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        updateState(\n', '            position,\n', '            transaction.positionId,\n', '            transaction.principal,\n', '            transaction.lenderAmount,\n', '            transaction.loanOffering.payer\n', '        );\n', '\n', '        // LOG EVENT\n', '        recordPositionIncreased(transaction, position);\n', '\n', '        return transaction.lenderAmount;\n', '    }\n', '\n', '    function increaseWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        // Disallow adding 0 principal\n', '        require(\n', '            principalToAdd > 0,\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot add 0 principal"\n', '        );\n', '\n', '        // Disallow additions after maximum duration\n', '        require(\n', '            block.timestamp < uint256(position.startTimestamp).add(position.maxDuration),\n', '            "IncreasePositionImpl#increaseWithoutCounterpartyImpl: Cannot increase after maxDuration"\n', '        );\n', '\n', '        uint256 heldTokenAmount = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            position,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            positionId,\n', '            position.heldToken,\n', '            msg.sender,\n', '            heldTokenAmount\n', '        );\n', '\n', '        updateState(\n', '            position,\n', '            positionId,\n', '            principalToAdd,\n', '            0, // lent amount\n', '            msg.sender\n', '        );\n', '\n', '        emit PositionIncreased(\n', '            positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            position.owner,\n', '            position.lender,\n', '            "",\n', '            address(0),\n', '            0,\n', '            principalToAdd,\n', '            0,\n', '            heldTokenAmount,\n', '            true\n', '        );\n', '\n', '        return heldTokenAmount;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        // Calculate the number of heldTokens to add\n', '        uint256 collateralToAdd = getCollateralNeededForAddedPrincipal(\n', '            state,\n', '            state.positions[transaction.positionId],\n', '            transaction.positionId,\n', '            transaction.principal\n', '        );\n', '\n', '        // Do pre-exchange validations\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        // Calculate and deposit owedToken\n', '        uint256 maxHeldTokenFromSell = MathHelpers.maxUint256();\n', '        if (!transaction.depositInHeldToken) {\n', '            transaction.depositAmount =\n', '                getOwedTokenDeposit(transaction, collateralToAdd, orderData);\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '            maxHeldTokenFromSell = collateralToAdd;\n', '        }\n', '\n', '        // Sell owedToken for heldToken using the exchange wrapper\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            maxHeldTokenFromSell\n', '        );\n', '\n', '        // Calculate and deposit heldToken\n', '        if (transaction.depositInHeldToken) {\n', '            require(\n', '                transaction.heldTokenFromSell <= collateralToAdd,\n', '                "IncreasePositionImpl#doBorrowAndSell: DEX order gives too much heldToken"\n', '            );\n', '            transaction.depositAmount = collateralToAdd.sub(transaction.heldTokenFromSell);\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        }\n', '\n', '        // Make sure the actual added collateral is what is expected\n', '        assert(transaction.collateralAmount == collateralToAdd);\n', '\n', '        // Do post-exchange validations\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function getOwedTokenDeposit(\n', '        BorrowShared.Tx transaction,\n', '        uint256 collateralToAdd,\n', '        bytes orderData\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalOwedToken = ExchangeWrapper(transaction.exchangeWrapper).getExchangeCost(\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.owedToken,\n', '            collateralToAdd,\n', '            orderData\n', '        );\n', '\n', '        require(\n', '            transaction.lenderAmount <= totalOwedToken,\n', '            "IncreasePositionImpl#getOwedTokenDeposit: Lender amount is more than required"\n', '        );\n', '\n', '        return totalOwedToken.sub(transaction.lenderAmount);\n', '    }\n', '\n', '    function validateIncrease(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '        view\n', '    {\n', '        assert(MarginCommon.containsPositionImpl(state, transaction.positionId));\n', '\n', '        require(\n', '            position.callTimeLimit <= transaction.loanOffering.callTimeLimit,\n', '            "IncreasePositionImpl#validateIncrease: Loan callTimeLimit is less than the position"\n', '        );\n', '\n', "        // require the position to end no later than the loanOffering's maximum acceptable end time\n", '        uint256 positionEndTimestamp = uint256(position.startTimestamp).add(position.maxDuration);\n', '        uint256 offeringEndTimestamp = block.timestamp.add(transaction.loanOffering.maxDuration);\n', '        require(\n', '            positionEndTimestamp <= offeringEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Loan end timestamp is less than the position"\n', '        );\n', '\n', '        require(\n', '            block.timestamp < positionEndTimestamp,\n', '            "IncreasePositionImpl#validateIncrease: Position has passed its maximum duration"\n', '        );\n', '    }\n', '\n', '    function getCollateralNeededForAddedPrincipal(\n', '        MarginState.State storage state,\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 heldTokenBalance = MarginCommon.getPositionBalanceImpl(state, positionId);\n', '\n', '        return MathHelpers.getPartialAmountRoundedUp(\n', '            principalToAdd,\n', '            position.principal,\n', '            heldTokenBalance\n', '        );\n', '    }\n', '\n', '    function updateState(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 owedTokenLent,\n', '        address loanPayer\n', '    )\n', '        private\n', '    {\n', '        position.principal = position.principal.add(principalAdded);\n', '\n', '        address owner = position.owner;\n', '        address lender = position.lender;\n', '\n', '        // Ensure owner consent\n', '        increasePositionOnBehalfOfRecurse(\n', '            owner,\n', '            msg.sender,\n', '            positionId,\n', '            principalAdded\n', '        );\n', '\n', '        // Ensure lender consent\n', '        increaseLoanOnBehalfOfRecurse(\n', '            lender,\n', '            loanPayer,\n', '            positionId,\n', '            principalAdded,\n', '            owedTokenLent\n', '        );\n', '    }\n', '\n', '    function increasePositionOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address trader,\n', '        bytes32 positionId,\n', '        uint256 principalAdded\n', '    )\n', '        private\n', '    {\n', '        // Assume owner approval if not a smart contract and they increased their own position\n', '        if (trader == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreasePositionDelegator(contractAddr).increasePositionOnBehalfOf(\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increasePositionOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                trader,\n', '                positionId,\n', '                principalAdded\n', '            );\n', '        }\n', '    }\n', '\n', '    function increaseLoanOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 amountLent\n', '    )\n', '        private\n', '    {\n', '        // Assume lender approval if not a smart contract and they increased their own loan\n', '        if (payer == contractAddr && !AddressUtils.isContract(contractAddr)) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            IncreaseLoanDelegator(contractAddr).increaseLoanOnBehalfOf(\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            increaseLoanOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                payer,\n', '                positionId,\n', '                principalAdded,\n', '                amountLent\n', '            );\n', '        }\n', '    }\n', '\n', '    function recordPositionIncreased(\n', '        BorrowShared.Tx transaction,\n', '        MarginCommon.Position storage position\n', '    )\n', '        private\n', '    {\n', '        emit PositionIncreased(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            position.owner,\n', '            position.lender,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.lenderAmount,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        bytes32 positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        uint256 principal = values256[7];\n', '\n', '        uint256 lenderAmount = MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principal,\n', '            block.timestamp\n', '        );\n', '        assert(lenderAmount >= principal);\n', '\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: positionId,\n', '            owner: position.owner,\n', '            principal: principal,\n', '            lenderAmount: lenderAmount,\n', '            loanOffering: parseLoanOfferingFromIncreasePositionTx(\n', '                position,\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[6],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: 0, // set later\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOfferingFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2] values32,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: position.owedToken,\n', '            heldToken: position.heldToken,\n', '            payer: addresses[0],\n', '            owner: position.lender,\n', '            taker: addresses[1],\n', '            positionOwner: addresses[2],\n', '            feeRecipient: addresses[3],\n', '            lenderFeeToken: addresses[4],\n', '            takerFeeToken: addresses[5],\n', '            rates: parseLoanOfferingRatesFromIncreasePositionTx(position, values256),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferingRatesFromIncreasePositionTx(\n', '        MarginCommon.Position storage position,\n', '        uint256[8] values256\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: position.interestRate,\n', '            interestPeriod: position.interestPeriod\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginStorage.sol\n', '\n', '/**\n', ' * @title MarginStorage\n', ' * @author dYdX\n', ' *\n', ' * This contract serves as the storage for the entire state of MarginStorage\n', ' */\n', 'contract MarginStorage {\n', '\n', '    MarginState.State state;\n', '\n', '}\n', '\n', '// File: contracts/margin/impl/LoanGetters.sol\n', '\n', '/**\n', ' * @title LoanGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any loan\n', ' * offering stored in the dYdX protocol.\n', ' */\n', 'contract LoanGetters is MarginStorage {\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the principal amount of a loan offering that is no longer available.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total unavailable amount of the loan offering, which is equal to the\n', '     *                   filled amount plus the canceled amount.\n', '     */\n', '    function getLoanUnavailableAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanHash);\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owed token lent for a loan.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total filled amount of the loan offering.\n', '     */\n', '    function getLoanFilledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanFills[loanHash];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of a loan offering that has been canceled.\n', '     *\n', '     * @param  loanHash  Unique hash of the loan offering\n', '     * @return           The total canceled amount of the loan offering.\n', '     */\n', '    function getLoanCanceledAmount(\n', '        bytes32 loanHash\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.loanCancels[loanHash];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/CancelMarginCallDelegator.sol\n', '\n', '/**\n', ' * @title CancelMarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses cancel a\n', ' * margin-call for a loan owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface CancelMarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the margin-call was successfully canceled.\n', '     *\n', '     * @param  canceler    Address of the caller of the cancelMarginCall function\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function cancelMarginCallOnBehalfOf(\n', '        address canceler,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/interfaces/lender/MarginCallDelegator.sol\n', '\n', '/**\n', ' * @title MarginCallDelegator\n', ' * @author dYdX\n', ' *\n', ' * Interface that smart contracts must implement in order to let other addresses margin-call a loan\n', ' * owned by the smart contract.\n', ' *\n', ' * NOTE: Any contract implementing this interface should also use OnlyMargin to control access\n', ' *       to these functions\n', ' */\n', 'interface MarginCallDelegator {\n', '\n', '    // ============ Public Interface functions ============\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call marginCall().\n', '     *\n', '     * NOTE: If not returning zero (or not reverting), this contract must assume that Margin will\n', '     * either revert the entire transaction or that the loan was successfully margin-called.\n', '     *\n', '     * @param  caller         Address of the caller of the marginCall function\n', '     * @param  positionId     Unique ID of the position\n', '     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n', '     * @return                This address to accept, a different address to ask that contract\n', '     */\n', '    function marginCallOnBehalfOf(\n', '        address caller,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        /* onlyMargin */\n', '        returns (address);\n', '}\n', '\n', '// File: contracts/margin/impl/LoanImpl.sol\n', '\n', '/**\n', ' * @title LoanImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the following functions of Margin:\n', ' *\n', ' *      - marginCall\n', ' *      - cancelMarginCallImpl\n', ' *      - cancelLoanOffering\n', ' */\n', 'library LoanImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function marginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp == 0,\n', '            "LoanImpl#marginCallImpl: The position has already been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        marginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '\n', '        position.callTimestamp = TimestampHelper.getBlockTimestamp32();\n', '        position.requiredDeposit = requiredDeposit;\n', '\n', '        emit MarginCallInitiated(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    function cancelMarginCallImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId\n', '    )\n', '        public\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            position.callTimestamp > 0,\n', '            "LoanImpl#cancelMarginCallImpl: Position has not been margin-called"\n', '        );\n', '\n', '        // Ensure lender consent\n', '        cancelMarginCallOnBehalfOfRecurse(\n', '            position.lender,\n', '            msg.sender,\n', '            positionId\n', '        );\n', '\n', '        state.positions[positionId].callTimestamp = 0;\n', '        state.positions[positionId].requiredDeposit = 0;\n', '\n', '        emit MarginCallCanceled(\n', '            positionId,\n', '            position.lender,\n', '            position.owner,\n', '            0\n', '        );\n', '    }\n', '\n', '    function cancelLoanOfferingImpl(\n', '        MarginState.State storage state,\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32,\n', '        uint256    cancelAmount\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        require(\n', '            msg.sender == loanOffering.payer,\n', '            "LoanImpl#cancelLoanOfferingImpl: Only loan offering payer can cancel"\n', '        );\n', '        require(\n', '            loanOffering.expirationTimestamp > block.timestamp,\n', '            "LoanImpl#cancelLoanOfferingImpl: Loan offering has already expired"\n', '        );\n', '\n', '        uint256 remainingAmount = loanOffering.rates.maxAmount.sub(\n', '            MarginCommon.getUnavailableLoanOfferingAmountImpl(state, loanOffering.loanHash)\n', '        );\n', '        uint256 amountToCancel = Math.min256(remainingAmount, cancelAmount);\n', '\n', '        // If the loan was already fully canceled, then just return 0 amount was canceled\n', '        if (amountToCancel == 0) {\n', '            return 0;\n', '        }\n', '\n', '        state.loanCancels[loanOffering.loanHash] =\n', '            state.loanCancels[loanOffering.loanHash].add(amountToCancel);\n', '\n', '        emit LoanOfferingCanceled(\n', '            loanOffering.loanHash,\n', '            loanOffering.payer,\n', '            loanOffering.feeRecipient,\n', '            amountToCancel\n', '        );\n', '\n', '        return amountToCancel;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function marginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            MarginCallDelegator(contractAddr).marginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            marginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId,\n', '                requiredDeposit\n', '            );\n', '        }\n', '    }\n', '\n', '    function cancelMarginCallOnBehalfOfRecurse(\n', '        address contractAddr,\n', '        address who,\n', '        bytes32 positionId\n', '    )\n', '        private\n', '    {\n', '        // no need to ask for permission\n', '        if (who == contractAddr) {\n', '            return;\n', '        }\n', '\n', '        address newContractAddr =\n', '            CancelMarginCallDelegator(contractAddr).cancelMarginCallOnBehalfOf(\n', '                msg.sender,\n', '                positionId\n', '            );\n', '\n', '        if (newContractAddr != contractAddr) {\n', '            cancelMarginCallOnBehalfOfRecurse(\n', '                newContractAddr,\n', '                who,\n', '                positionId\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            payer: addresses[2],\n', '            owner: addresses[3],\n', '            taker: addresses[4],\n', '            positionOwner: addresses[5],\n', '            feeRecipient: addresses[6],\n', '            lenderFeeToken: addresses[7],\n', '            takerFeeToken: addresses[8],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: new bytes(0)\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[7] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            interestRate: values32[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginAdmin.sol\n', '\n', '/**\n', ' * @title MarginAdmin\n', ' * @author dYdX\n', ' *\n', ' * Contains admin functions for the Margin contract\n', ' * The owner can put Margin into various close-only modes, which will disallow new position creation\n', ' */\n', 'contract MarginAdmin is Ownable {\n', '    // ============ Enums ============\n', '\n', '    // All functionality enabled\n', '    uint8 private constant OPERATION_STATE_OPERATIONAL = 0;\n', '\n', '    // Only closing functions + cancelLoanOffering allowed (marginCall, closePosition,\n', '    // cancelLoanOffering, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY = 1;\n', '\n', '    // Only closing functions allowed (marginCall, closePosition, closePositionDirectly,\n', '    // forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_ONLY = 2;\n', '\n', '    // Only closing functions allowed (marginCall, closePositionDirectly, forceRecoverCollateral)\n', '    uint8 private constant OPERATION_STATE_CLOSE_DIRECTLY_ONLY = 3;\n', '\n', '    // This operation state (and any higher) is invalid\n', '    uint8 private constant OPERATION_STATE_INVALID = 4;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * Event indicating the operation state has changed\n', '     */\n', '    event OperationStateChanged(\n', '        uint8 from,\n', '        uint8 to\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    uint8 public operationState;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor()\n', '        public\n', '        Ownable()\n', '    {\n', '        operationState = OPERATION_STATE_OPERATIONAL;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyWhileOperational() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL,\n', '            "MarginAdmin#onlyWhileOperational: Can only call while operational"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier cancelLoanOfferingStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY,\n', '            "MarginAdmin#cancelLoanOfferingStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionStateControl() {\n', '        require(\n', '            operationState == OPERATION_STATE_OPERATIONAL\n', '            || operationState == OPERATION_STATE_CLOSE_AND_CANCEL_LOAN_ONLY\n', '            || operationState == OPERATION_STATE_CLOSE_ONLY,\n', '            "MarginAdmin#closePositionStateControl: Invalid operation state"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier closePositionDirectlyStateControl() {\n', '        _;\n', '    }\n', '\n', '    // ============ Owner-Only State-Changing Functions ============\n', '\n', '    function setOperationState(\n', '        uint8 newState\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newState < OPERATION_STATE_INVALID,\n', '            "MarginAdmin#setOperationState: newState is not a valid operation state"\n', '        );\n', '\n', '        if (newState != operationState) {\n', '            emit OperationStateChanged(\n', '                operationState,\n', '                newState\n', '            );\n', '            operationState = newState;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/MarginEvents.sol\n', '\n', '/**\n', ' * @title MarginEvents\n', ' * @author dYdX\n', ' *\n', ' * Contains events for the Margin contract.\n', ' *\n', ' * NOTE: Any Margin function libraries that use events will need to both define the event here\n', " *       and copy the event into the library itself as libraries don't support sharing events\n", ' */\n', 'contract MarginEvents {\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /*\n', '     * A position was increased\n', '     */\n', '    event PositionIncreased(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        address positionOwner,\n', '        address loanOwner,\n', '        bytes32 loanHash,\n', '        address loanFeeRecipient,\n', '        uint256 amountBorrowed,\n', '        uint256 principalAdded,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    /**\n', '     * A position was closed or partially closed\n', '     */\n', '    event PositionClosed(\n', '        bytes32 indexed positionId,\n', '        address indexed closer,\n', '        address indexed payoutRecipient,\n', '        uint256 closeAmount,\n', '        uint256 remainingAmount,\n', '        uint256 owedTokenPaidToLender,\n', '        uint256 payoutAmount,\n', '        uint256 buybackCostInHeldToken,\n', '        bool payoutInHeldToken\n', '    );\n', '\n', '    /**\n', '     * Collateral for a position was forcibly recovered\n', '     */\n', '    event CollateralForceRecovered(\n', '        bytes32 indexed positionId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    /**\n', '     * A position was margin-called\n', '     */\n', '    event MarginCallInitiated(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 requiredDeposit\n', '    );\n', '\n', '    /**\n', '     * A margin call was canceled\n', '     */\n', '    event MarginCallCanceled(\n', '        bytes32 indexed positionId,\n', '        address indexed lender,\n', '        address indexed owner,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    /**\n', '     * A loan offering was canceled before it was used. Any amount less than the\n', '     * total for the loan offering can be canceled.\n', '     */\n', '    event LoanOfferingCanceled(\n', '        bytes32 indexed loanHash,\n', '        address indexed payer,\n', '        address indexed feeRecipient,\n', '        uint256 cancelAmount\n', '    );\n', '\n', '    /**\n', '     * Additional collateral for a position was posted by the owner\n', '     */\n', '    event AdditionalCollateralDeposited(\n', '        bytes32 indexed positionId,\n', '        uint256 amount,\n', '        address depositor\n', '    );\n', '\n', '    /**\n', '     * Ownership of a loan was transferred to a new address\n', '     */\n', '    event LoanTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '\n', '    /**\n', '     * Ownership of a position was transferred to a new address\n', '     */\n', '    event PositionTransferred(\n', '        bytes32 indexed positionId,\n', '        address indexed from,\n', '        address indexed to\n', '    );\n', '}\n', '\n', '// File: contracts/margin/impl/OpenPositionImpl.sol\n', '\n', '/**\n', ' * @title OpenPositionImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openPosition function of Margin\n', ' */\n', 'library OpenPositionImpl {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openPositionImpl(\n', '        MarginState.State storage state,\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature,\n', '        bytes orderData\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        BorrowShared.Tx memory transaction = parseOpenTx(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature\n', '        );\n', '\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, transaction.positionId),\n', '            "OpenPositionImpl#openPositionImpl: positionId already exists"\n', '        );\n', '\n', '        doBorrowAndSell(state, transaction, orderData);\n', '\n', '        // Before doStoreNewPosition() so that PositionOpened event is before Transferred events\n', '        recordPositionOpened(\n', '            transaction\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            transaction\n', '        );\n', '\n', '        return transaction.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doBorrowAndSell(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction,\n', '        bytes orderData\n', '    )\n', '        private\n', '    {\n', '        BorrowShared.validateTxPreSell(state, transaction);\n', '\n', '        if (transaction.depositInHeldToken) {\n', '            BorrowShared.doDepositHeldToken(state, transaction);\n', '        } else {\n', '            BorrowShared.doDepositOwedToken(state, transaction);\n', '        }\n', '\n', '        transaction.heldTokenFromSell = BorrowShared.doSell(\n', '            state,\n', '            transaction,\n', '            orderData,\n', '            MathHelpers.maxUint256()\n', '        );\n', '\n', '        BorrowShared.doPostSell(state, transaction);\n', '    }\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        BorrowShared.Tx memory transaction\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            transaction.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: transaction.loanOffering.owedToken,\n', '                heldToken: transaction.loanOffering.heldToken,\n', '                lender: transaction.loanOffering.owner,\n', '                owner: transaction.owner,\n', '                principal: transaction.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: transaction.loanOffering.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: transaction.loanOffering.maxDuration,\n', '                interestRate: transaction.loanOffering.rates.interestRate,\n', '                interestPeriod: transaction.loanOffering.rates.interestPeriod\n', '            }),\n', '            transaction.loanOffering.payer\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        BorrowShared.Tx transaction\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            transaction.positionId,\n', '            msg.sender,\n', '            transaction.loanOffering.payer,\n', '            transaction.loanOffering.loanHash,\n', '            transaction.loanOffering.owedToken,\n', '            transaction.loanOffering.heldToken,\n', '            transaction.loanOffering.feeRecipient,\n', '            transaction.principal,\n', '            transaction.heldTokenFromSell,\n', '            transaction.depositAmount,\n', '            transaction.loanOffering.rates.interestRate,\n', '            transaction.loanOffering.callTimeLimit,\n', '            transaction.loanOffering.maxDuration,\n', '            transaction.depositInHeldToken\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseOpenTx(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4] values32,\n', '        bool depositInHeldToken,\n', '        bytes signature\n', '    )\n', '        private\n', '        view\n', '        returns (BorrowShared.Tx memory)\n', '    {\n', '        BorrowShared.Tx memory transaction = BorrowShared.Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[9]),\n', '            owner: addresses[0],\n', '            principal: values256[7],\n', '            lenderAmount: values256[7],\n', '            loanOffering: parseLoanOffering(\n', '                addresses,\n', '                values256,\n', '                values32,\n', '                signature\n', '            ),\n', '            exchangeWrapper: addresses[10],\n', '            depositInHeldToken: depositInHeldToken,\n', '            depositAmount: values256[8],\n', '            collateralAmount: 0, // set later\n', '            heldTokenFromSell: 0 // set later\n', '        });\n', '\n', '        return transaction;\n', '    }\n', '\n', '    function parseLoanOffering(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bytes       signature\n', '    )\n', '        private\n', '        view\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering = MarginCommon.LoanOffering({\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            payer: addresses[3],\n', '            owner: addresses[4],\n', '            taker: addresses[5],\n', '            positionOwner: addresses[6],\n', '            feeRecipient: addresses[7],\n', '            lenderFeeToken: addresses[8],\n', '            takerFeeToken: addresses[9],\n', '            rates: parseLoanOfferRates(values256, values32),\n', '            expirationTimestamp: values256[5],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            salt: values256[6],\n', '            loanHash: 0,\n', '            signature: signature\n', '        });\n', '\n', '        loanOffering.loanHash = MarginCommon.getLoanOfferingHash(loanOffering);\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function parseLoanOfferRates(\n', '        uint256[10] values256,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '        returns (MarginCommon.LoanRates memory)\n', '    {\n', '        MarginCommon.LoanRates memory rates = MarginCommon.LoanRates({\n', '            maxAmount: values256[0],\n', '            minAmount: values256[1],\n', '            minHeldToken: values256[2],\n', '            lenderFee: values256[3],\n', '            takerFee: values256[4],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return rates;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/OpenWithoutCounterpartyImpl.sol\n', '\n', '/**\n', ' * @title OpenWithoutCounterpartyImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the openWithoutCounterparty\n', ' * function of Margin\n', ' */\n', 'library OpenWithoutCounterpartyImpl {\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Tx {\n', '        bytes32 positionId;\n', '        address positionOwner;\n', '        address owedToken;\n', '        address heldToken;\n', '        address loanOwner;\n', '        uint256 principal;\n', '        uint256 deposit;\n', '        uint32 callTimeLimit;\n', '        uint32 maxDuration;\n', '        uint32 interestRate;\n', '        uint32 interestPeriod;\n', '    }\n', '\n', '    // ============ Events ============\n', '\n', '    /**\n', '     * A position was opened\n', '     */\n', '    event PositionOpened(\n', '        bytes32 indexed positionId,\n', '        address indexed trader,\n', '        address indexed lender,\n', '        bytes32 loanHash,\n', '        address owedToken,\n', '        address heldToken,\n', '        address loanFeeRecipient,\n', '        uint256 principal,\n', '        uint256 heldTokenFromSell,\n', '        uint256 depositAmount,\n', '        uint256 interestRate,\n', '        uint32  callTimeLimit,\n', '        uint32  maxDuration,\n', '        bool    depositInHeldToken\n', '    );\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function openWithoutCounterpartyImpl(\n', '        MarginState.State storage state,\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        public\n', '        returns (bytes32)\n', '    {\n', '        Tx memory openTx = parseTx(\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '\n', '        validate(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        Vault(state.VAULT).transferToVault(\n', '            openTx.positionId,\n', '            openTx.heldToken,\n', '            msg.sender,\n', '            openTx.deposit\n', '        );\n', '\n', '        recordPositionOpened(\n', '            openTx\n', '        );\n', '\n', '        doStoreNewPosition(\n', '            state,\n', '            openTx\n', '        );\n', '\n', '        return openTx.positionId;\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    function doStoreNewPosition(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        MarginCommon.storeNewPosition(\n', '            state,\n', '            openTx.positionId,\n', '            MarginCommon.Position({\n', '                owedToken: openTx.owedToken,\n', '                heldToken: openTx.heldToken,\n', '                lender: openTx.loanOwner,\n', '                owner: openTx.positionOwner,\n', '                principal: openTx.principal,\n', '                requiredDeposit: 0,\n', '                callTimeLimit: openTx.callTimeLimit,\n', '                startTimestamp: 0,\n', '                callTimestamp: 0,\n', '                maxDuration: openTx.maxDuration,\n', '                interestRate: openTx.interestRate,\n', '                interestPeriod: openTx.interestPeriod\n', '            }),\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    function validate(\n', '        MarginState.State storage state,\n', '        Tx memory openTx\n', '    )\n', '        private\n', '        view\n', '    {\n', '        require(\n', '            !MarginCommon.positionHasExisted(state, openTx.positionId),\n', '            "openWithoutCounterpartyImpl#validate: positionId already exists"\n', '        );\n', '\n', '        require(\n', '            openTx.principal > 0,\n', '            "openWithoutCounterpartyImpl#validate: principal cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != address(0),\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.owedToken != openTx.heldToken,\n', '            "openWithoutCounterpartyImpl#validate: owedToken cannot be equal to heldToken"\n', '        );\n', '\n', '        require(\n', '            openTx.positionOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: positionOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.loanOwner != address(0),\n', '            "openWithoutCounterpartyImpl#validate: loanOwner cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.maxDuration > 0,\n', '            "openWithoutCounterpartyImpl#validate: maxDuration cannot be 0"\n', '        );\n', '\n', '        require(\n', '            openTx.interestPeriod <= openTx.maxDuration,\n', '            "openWithoutCounterpartyImpl#validate: interestPeriod must be <= maxDuration"\n', '        );\n', '    }\n', '\n', '    function recordPositionOpened(\n', '        Tx memory openTx\n', '    )\n', '        private\n', '    {\n', '        emit PositionOpened(\n', '            openTx.positionId,\n', '            msg.sender,\n', '            msg.sender,\n', '            bytes32(0),\n', '            openTx.owedToken,\n', '            openTx.heldToken,\n', '            address(0),\n', '            openTx.principal,\n', '            0,\n', '            openTx.deposit,\n', '            openTx.interestRate,\n', '            openTx.callTimeLimit,\n', '            openTx.maxDuration,\n', '            true\n', '        );\n', '    }\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseTx(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        private\n', '        view\n', '        returns (Tx memory)\n', '    {\n', '        Tx memory openTx = Tx({\n', '            positionId: MarginCommon.getPositionIdFromNonce(values256[2]),\n', '            positionOwner: addresses[0],\n', '            owedToken: addresses[1],\n', '            heldToken: addresses[2],\n', '            loanOwner: addresses[3],\n', '            principal: values256[0],\n', '            deposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            maxDuration: values32[1],\n', '            interestRate: values32[2],\n', '            interestPeriod: values32[3]\n', '        });\n', '\n', '        return openTx;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/PositionGetters.sol\n', '\n', '/**\n', ' * @title PositionGetters\n', ' * @author dYdX\n', ' *\n', ' * A collection of public constant getter functions that allows reading of the state of any position\n', ' * stored in the dYdX protocol.\n', ' */\n', 'contract PositionGetters is MarginStorage {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets if a position is currently open.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is exists and is open\n', '     */\n', '    function containsPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return MarginCommon.containsPositionImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position is currently margin-called.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is margin-called\n', '     */\n', '    function isPositionCalled(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (state.positions[positionId].callTimestamp > 0);\n', '    }\n', '\n', '    /**\n', '     * Gets if a position was previously open and is now closed.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             True if the position is now closed\n', '     */\n', '    function isPositionClosed(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return state.closedPositions[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the total amount of owedToken ever repaid to the lender for a position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Total amount of owedToken ever repaid\n', '     */\n', '    function getTotalOwedTokenRepaidToLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.totalOwedTokenRepaidToLender[positionId];\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of heldToken currently locked up in Vault for a particular position.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The amount of heldToken\n', '     */\n', '    function getPositionBalance(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return MarginCommon.getPositionBalanceImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Gets the time until the interest fee charged for the position will increase.\n', '     * Returns 1 if the interest fee increases every second.\n', '     * Returns 0 if the interest fee will never increase again.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of seconds until the interest fee will increase\n', '     */\n', '    function getTimeUntilInterestIncrease(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        uint256 effectiveTimeElapsed = MarginCommon.calculateEffectiveTimeElapsed(\n', '            position,\n', '            block.timestamp\n', '        );\n', '\n', '        uint256 absoluteTimeElapsed = block.timestamp.sub(position.startTimestamp);\n', '        if (absoluteTimeElapsed > effectiveTimeElapsed) { // past maxDuration\n', '            return 0;\n', '        } else {\n', '            // nextStep is the final second at which the calculated interest fee is the same as it\n', '            // is currently, so add 1 to get the correct value\n', '            return effectiveTimeElapsed.add(1).sub(absoluteTimeElapsed);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens currently needed to close the position completely, including\n', '     * interest fees.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             The number of owedTokens\n', '     */\n', '    function getPositionOwedAmount(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            position.principal,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens needed to close a given principal amount of the position at a\n', '     * given time, including interest fees.\n', '     *\n', '     * @param  positionId         Unique ID of the position\n', '     * @param  principalToClose   Amount of principal being closed\n', '     * @param  timestamp          Block timestamp in seconds of close\n', '     * @return                    The number of owedTokens owed\n', '     */\n', '    function getPositionOwedAmountAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToClose,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getPositionOwedAmountAtTime: Requested time before position started"\n', '        );\n', '\n', '        return MarginCommon.calculateOwedAmount(\n', '            position,\n', '            principalToClose,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Gets the amount of owedTokens that can be borrowed from a lender to add a given principal\n', '     * amount to the position at a given time.\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Amount being added to principal\n', '     * @param  timestamp       Block timestamp in seconds of addition\n', '     * @return                 The number of owedTokens that will be borrowed\n', '     */\n', '    function getLenderAmountForIncreasePositionAtTime(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd,\n', '        uint32  timestamp\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        MarginCommon.Position storage position =\n', '            MarginCommon.getPositionFromStorage(state, positionId);\n', '\n', '        require(\n', '            timestamp >= position.startTimestamp,\n', '            "PositionGetters#getLenderAmountForIncreasePositionAtTime: timestamp < position start"\n', '        );\n', '\n', '        return MarginCommon.calculateLenderAmountForIncreasePosition(\n', '            position,\n', '            principalToAdd,\n', '            timestamp\n', '        );\n', '    }\n', '\n', '    // ============ All Properties ============\n', '\n', '    /**\n', '     * Get a Position by id. This does not validate the position exists. If the position does not\n', "     * exist, all 0's will be returned.\n", '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             Addresses corresponding to:\n', '     *\n', '     *                     [0] = owedToken\n', '     *                     [1] = heldToken\n', '     *                     [2] = lender\n', '     *                     [3] = owner\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = principal\n', '     *                     [1] = requiredDeposit\n', '     *\n', '     *                     Values corresponding to:\n', '     *\n', '     *                     [0] = callTimeLimit\n', '     *                     [1] = startTimestamp\n', '     *                     [2] = callTimestamp\n', '     *                     [3] = maxDuration\n', '     *                     [4] = interestRate\n', '     *                     [5] = interestPeriod\n', '     */\n', '    function getPosition(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            address[4],\n', '            uint256[2],\n', '            uint32[6]\n', '        )\n', '    {\n', '        MarginCommon.Position storage position = state.positions[positionId];\n', '\n', '        return (\n', '            [\n', '                position.owedToken,\n', '                position.heldToken,\n', '                position.lender,\n', '                position.owner\n', '            ],\n', '            [\n', '                position.principal,\n', '                position.requiredDeposit\n', '            ],\n', '            [\n', '                position.callTimeLimit,\n', '                position.startTimestamp,\n', '                position.callTimestamp,\n', '                position.maxDuration,\n', '                position.interestRate,\n', '                position.interestPeriod\n', '            ]\n', '        );\n', '    }\n', '\n', '    // ============ Individual Properties ============\n', '\n', '    function getPositionLender(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].lender;\n', '    }\n', '\n', '    function getPositionOwner(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owner;\n', '    }\n', '\n', '    function getPositionHeldToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].heldToken;\n', '    }\n', '\n', '    function getPositionOwedToken(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.positions[positionId].owedToken;\n', '    }\n', '\n', '    function getPositionPrincipal(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].principal;\n', '    }\n', '\n', '    function getPositionInterestRate(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].interestRate;\n', '    }\n', '\n', '    function getPositionRequiredDeposit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return state.positions[positionId].requiredDeposit;\n', '    }\n', '\n', '    function getPositionStartTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].startTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimestamp(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimestamp;\n', '    }\n', '\n', '    function getPositionCallTimeLimit(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].callTimeLimit;\n', '    }\n', '\n', '    function getPositionMaxDuration(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].maxDuration;\n', '    }\n', '\n', '    function getPositioninterestPeriod(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        view\n', '        returns (uint32)\n', '    {\n', '        return state.positions[positionId].interestPeriod;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/impl/TransferImpl.sol\n', '\n', '/**\n', ' * @title TransferImpl\n', ' * @author dYdX\n', ' *\n', ' * This library contains the implementation for the transferPosition and transferLoan functions of\n', ' * Margin\n', ' */\n', 'library TransferImpl {\n', '\n', '    // ============ Public Implementation Functions ============\n', '\n', '    function transferLoanImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newLender\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferLoanImpl: Position does not exist"\n', '        );\n', '\n', '        address originalLender = state.positions[positionId].lender;\n', '\n', '        require(\n', '            msg.sender == originalLender,\n', '            "TransferImpl#transferLoanImpl: Only lender can transfer ownership"\n', '        );\n', '        require(\n', '            newLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', "        // Doesn't change the state of positionId; figures out the final owner of loan.\n", '        // That is, newLender may pass ownership to a different address.\n', '        address finalLender = TransferInternal.grantLoanOwnership(\n', '            positionId,\n', '            originalLender,\n', '            newLender);\n', '\n', '        require(\n', '            finalLender != originalLender,\n', '            "TransferImpl#transferLoanImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].lender = finalLender;\n', '    }\n', '\n', '    function transferPositionImpl(\n', '        MarginState.State storage state,\n', '        bytes32 positionId,\n', '        address newOwner\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            MarginCommon.containsPositionImpl(state, positionId),\n', '            "TransferImpl#transferPositionImpl: Position does not exist"\n', '        );\n', '\n', '        address originalOwner = state.positions[positionId].owner;\n', '\n', '        require(\n', '            msg.sender == originalOwner,\n', '            "TransferImpl#transferPositionImpl: Only position owner can transfer ownership"\n', '        );\n', '        require(\n', '            newOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot transfer ownership to self"\n', '        );\n', '\n', "        // Doesn't change the state of positionId; figures out the final owner of position.\n", '        // That is, newOwner may pass ownership to a different address.\n', '        address finalOwner = TransferInternal.grantPositionOwnership(\n', '            positionId,\n', '            originalOwner,\n', '            newOwner);\n', '\n', '        require(\n', '            finalOwner != originalOwner,\n', '            "TransferImpl#transferPositionImpl: Cannot ultimately transfer ownership to self"\n', '        );\n', '\n', '        // Set state only after resolving the new owner (to reduce the number of storage calls)\n', '        state.positions[positionId].owner = finalOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/Margin.sol\n', '\n', '/**\n', ' * @title Margin\n', ' * @author dYdX\n', ' *\n', ' * This contract is used to facilitate margin trading as per the dYdX protocol\n', ' */\n', 'contract Margin is\n', '    ReentrancyGuard,\n', '    MarginStorage,\n', '    MarginEvents,\n', '    MarginAdmin,\n', '    LoanGetters,\n', '    PositionGetters\n', '{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address vault,\n', '        address proxy\n', '    )\n', '        public\n', '        MarginAdmin()\n', '    {\n', '        state = MarginState.State({\n', '            VAULT: vault,\n', '            TOKEN_PROXY: proxy\n', '        });\n', '    }\n', '\n', '    // ============ Public State Changing Functions ============\n', '\n', '    /**\n', '     * Open a margin position. Called by the margin trader who must provide both a\n', '     * signed loan offering as well as a DEX Order with which to sell the owedToken.\n', '     *\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan payer\n', '     *  [4]  = loan owner\n', '     *  [5]  = loan taker\n', '     *  [6]  = loan position owner\n', '     *  [7]  = loan fee recipient\n', '     *  [8]  = loan lender fee token\n', '     *  [9]  = loan taker fee token\n', '     *  [10]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = position amount of principal\n', '     *  [8]  = deposit amount\n', '     *  [9]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Unique ID for the new position\n', '     */\n', '    function openPosition(\n', '        address[11] addresses,\n', '        uint256[10] values256,\n', '        uint32[4]   values32,\n', '        bool        depositInHeldToken,\n', '        bytes       signature,\n', '        bytes       order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenPositionImpl.openPositionImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Open a margin position without a counterparty. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  addresses    Addresses corresponding to:\n', '     *\n', '     *  [0]  = position owner\n', '     *  [1]  = owedToken\n', '     *  [2]  = heldToken\n', '     *  [3]  = loan owner\n', '     *\n', '     * @param  values256    Values corresponding to:\n', '     *\n', '     *  [0]  = principal\n', '     *  [1]  = deposit amount\n', '     *  [2]  = nonce (used to calculate positionId)\n', '     *\n', '     * @param  values32     Values corresponding to:\n', '     *\n', '     *  [0] = call time limit (in seconds)\n', '     *  [1] = maxDuration (in seconds)\n', '     *  [2] = interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = interest update period (in seconds)\n', '     *\n', '     * @return              Unique ID for the new position\n', '     */\n', '    function openWithoutCounterparty(\n', '        address[4] addresses,\n', '        uint256[3] values256,\n', '        uint32[4]  values32\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (bytes32)\n', '    {\n', '        return OpenWithoutCounterpartyImpl.openWithoutCounterpartyImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase the size of a position. Funds will be borrowed from the loan payer and sold as per\n', '     * the position. The amount of owedToken borrowed from the lender will be >= the amount of\n', '     * principal added, as it will incorporate interest already earned by the position so far.\n', '     *\n', '     * @param  positionId          Unique ID of the position\n', '     * @param  addresses           Addresses corresponding to:\n', '     *\n', '     *  [0]  = loan payer\n', '     *  [1]  = loan taker\n', '     *  [2]  = loan position owner\n', '     *  [3]  = loan fee recipient\n', '     *  [4]  = loan lender fee token\n', '     *  [5]  = loan taker fee token\n', '     *  [6]  = exchange wrapper address\n', '     *\n', '     * @param  values256           Values corresponding to:\n', '     *\n', '     *  [0]  = loan maximum amount\n', '     *  [1]  = loan minimum amount\n', '     *  [2]  = loan minimum heldToken\n', '     *  [3]  = loan lender fee\n', '     *  [4]  = loan taker fee\n', '     *  [5]  = loan expiration timestamp (in seconds)\n', '     *  [6]  = loan salt\n', '     *  [7]  = amount of principal to add to the position (NOTE: the amount pulled from the lender\n', '     *                                                           will be >= this amount)\n', '     *\n', '     * @param  values32            Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *\n', '     * @param  depositInHeldToken  True if the trader wishes to pay the margin deposit in heldToken.\n', '     *                             False if the margin deposit will be pulled in owedToken\n', '     *                             and then sold along with the owedToken borrowed from the lender\n', '     * @param  signature           If loan payer is an account, then this must be the tightly-packed\n', '     *                             ECDSA V/R/S parameters from signing the loan hash. If loan payer\n', '     *                             is a smart contract, these are arbitrary bytes that the contract\n', '     *                             will recieve when choosing whether to approve the loan.\n', '     * @param  order               Order object to be passed to the exchange wrapper\n', '     * @return                     Amount of owedTokens pulled from the lender\n', '     */\n', '    function increasePosition(\n', '        bytes32    positionId,\n', '        address[7] addresses,\n', '        uint256[8] values256,\n', '        uint32[2]  values32,\n', '        bool       depositInHeldToken,\n', '        bytes      signature,\n', '        bytes      order\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increasePositionImpl(\n', '            state,\n', '            positionId,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            depositInHeldToken,\n', '            signature,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Increase a position directly by putting up heldToken. The caller will serve as both the\n', '     * lender and the position owner\n', '     *\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalToAdd  Principal amount to add to the position\n', '     * @return                 Amount of heldToken pulled from the msg.sender\n', '     */\n', '    function increaseWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 principalToAdd\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return IncreasePositionImpl.increaseWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            principalToAdd\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Close a position. May be called by the owner or with the approval of the owner. May provide\n', '     * an order and exchangeWrapper to facilitate the closing of the position. The payoutRecipient\n', '     * is sent the resulting payout.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @param  exchangeWrapper       Address of the exchange wrapper\n', '     * @param  payoutInHeldToken     True to pay out the payoutRecipient in heldToken,\n', '     *                               False to pay out the payoutRecipient in owedToken\n', '     * @param  order                 Order object to be passed to the exchange wrapper\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal of position closed\n', '     *                               2) Amount of tokens (heldToken if payoutInHeldtoken is true,\n', '     *                                  owedToken otherwise) received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePosition(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient,\n', '        address exchangeWrapper,\n', '        bool    payoutInHeldToken,\n', '        bytes   order\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            exchangeWrapper,\n', '            payoutInHeldToken,\n', '            order\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Helper to close a position by paying owedToken directly rather than using an exchangeWrapper.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     * @param  payoutRecipient       Address of the recipient of tokens paid out from closing\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the payoutRecipient\n', '     *                               3) Amount of owedToken paid (incl. interest fee) to the lender\n', '     */\n', '    function closePositionDirectly(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionDirectlyStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return ClosePositionImpl.closePositionImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient,\n', '            address(0),\n', '            true,\n', '            new bytes(0)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Reduce the size of a position and withdraw a proportional amount of heldToken from the vault.\n', '     * Must be approved by both the position owner and lender.\n', '     *\n', '     * @param  positionId            Unique ID of the position\n', '     * @param  requestedCloseAmount  Principal amount of the position to close. The actual amount\n', '     *                               closed is also bounded by:\n', '     *                               1) The principal of the position\n', '     *                               2) The amount allowed by the owner if closer != owner\n', '     *                               3) The amount allowed by the lender if closer != lender\n', '     * @return                       Values corresponding to:\n', '     *                               1) Principal amount of position closed\n', '     *                               2) Amount of heldToken received by the msg.sender\n', '     */\n', '    function closeWithoutCounterparty(\n', '        bytes32 positionId,\n', '        uint256 requestedCloseAmount,\n', '        address payoutRecipient\n', '    )\n', '        external\n', '        closePositionStateControl\n', '        nonReentrant\n', '        returns (uint256, uint256)\n', '    {\n', '        return CloseWithoutCounterpartyImpl.closeWithoutCounterpartyImpl(\n', '            state,\n', '            positionId,\n', '            requestedCloseAmount,\n', '            payoutRecipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Margin-call a position. Only callable with the approval of the position lender. After the\n', '     * call, the position owner will have time equal to the callTimeLimit of the position to close\n', '     * the position. If the owner does not close the position, the lender can recover the collateral\n', '     * in the position.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  requiredDeposit  Amount of deposit the position owner will have to put up to cancel\n', '     *                          the margin-call. Passing in 0 means the margin call cannot be\n', '     *                          canceled by depositing\n', '     */\n', '    function marginCall(\n', '        bytes32 positionId,\n', '        uint256 requiredDeposit\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        LoanImpl.marginCallImpl(\n', '            state,\n', '            positionId,\n', '            requiredDeposit\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Cancel a margin-call. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     */\n', '    function cancelMarginCall(\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        LoanImpl.cancelMarginCallImpl(state, positionId);\n', '    }\n', '\n', '    /**\n', '     * Used to recover the heldTokens held as collateral. Is callable after the maximum duration of\n', '     * the loan has expired or the loan has been margin-called for the duration of the callTimeLimit\n', '     * but remains unclosed. Only callable with the approval of the position lender.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             Amount of heldToken recovered\n', '     */\n', '    function forceRecoverCollateral(\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return ForceRecoverCollateralImpl.forceRecoverCollateralImpl(\n', '            state,\n', '            positionId,\n', '            recipient\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Deposit additional heldToken as collateral for a position. Cancels margin-call if:\n', '     * 0 < position.requiredDeposit < depositAmount. Only callable by the position owner.\n', '     *\n', '     * @param  positionId       Unique ID of the position\n', '     * @param  depositAmount    Additional amount in heldToken to deposit\n', '     */\n', '    function depositCollateral(\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        onlyWhileOperational\n', '        nonReentrant\n', '    {\n', '        DepositCollateralImpl.depositCollateralImpl(\n', '            state,\n', '            positionId,\n', '            depositAmount\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Cancel an amount of a loan offering. Only callable by the loan offering's payer.\n", '     *\n', '     * @param  addresses     Array of addresses:\n', '     *\n', '     *  [0] = owedToken\n', '     *  [1] = heldToken\n', '     *  [2] = loan payer\n', '     *  [3] = loan owner\n', '     *  [4] = loan taker\n', '     *  [5] = loan position owner\n', '     *  [6] = loan fee recipient\n', '     *  [7] = loan lender fee token\n', '     *  [8] = loan taker fee token\n', '     *\n', '     * @param  values256     Values corresponding to:\n', '     *\n', '     *  [0] = loan maximum amount\n', '     *  [1] = loan minimum amount\n', '     *  [2] = loan minimum heldToken\n', '     *  [3] = loan lender fee\n', '     *  [4] = loan taker fee\n', '     *  [5] = loan expiration timestamp (in seconds)\n', '     *  [6] = loan salt\n', '     *\n', '     * @param  values32      Values corresponding to:\n', '     *\n', '     *  [0] = loan call time limit (in seconds)\n', '     *  [1] = loan maxDuration (in seconds)\n', '     *  [2] = loan interest rate (annual nominal percentage times 10**6)\n', '     *  [3] = loan interest update period (in seconds)\n', '     *\n', '     * @param  cancelAmount  Amount to cancel\n', '     * @return               Amount that was canceled\n', '     */\n', '    function cancelLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7]  values256,\n', '        uint32[4]   values32,\n', '        uint256     cancelAmount\n', '    )\n', '        external\n', '        cancelLoanOfferingStateControl\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        return LoanImpl.cancelLoanOfferingImpl(\n', '            state,\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            cancelAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a loan to a new address. This new address will be entitled to all\n', '     * payouts for this loan. Only callable by the lender for a position. If "who" is a contract, it\n', '     * must implement the LoanOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the loan\n', '     */\n', '    function transferLoan(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferLoanImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership of a position to a new address. This new address will be entitled to all\n', '     * payouts. Only callable by the owner of a position. If "who" is a contract, it must implement\n', '     * the PositionOwner interface.\n', '     *\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  who         New owner of the position\n', '     */\n', '    function transferPosition(\n', '        bytes32 positionId,\n', '        address who\n', '    )\n', '        external\n', '        nonReentrant\n', '    {\n', '        TransferImpl.transferPositionImpl(\n', '            state,\n', '            positionId,\n', '            who);\n', '    }\n', '\n', '    // ============ Public Constant Functions ============\n', '\n', '    /**\n', '     * Gets the address of the Vault contract that holds and accounts for tokens.\n', '     *\n', '     * @return  The address of the Vault contract\n', '     */\n', '    function getVaultAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.VAULT;\n', '    }\n', '\n', '    /**\n', '     * Gets the address of the TokenProxy contract that accounts must set allowance on in order to\n', '     * make loans or open/close positions.\n', '     *\n', '     * @return  The address of the TokenProxy contract\n', '     */\n', '    function getTokenProxyAddress()\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return state.TOKEN_PROXY;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/OnlyMargin.sol\n', '\n', '/**\n', ' * @title OnlyMargin\n', ' * @author dYdX\n', ' *\n', ' * Contract to store the address of the main Margin contract and trust only that address to call\n', ' * certain functions.\n', ' */\n', 'contract OnlyMargin {\n', '\n', '    // ============ Constants ============\n', '\n', '    // Address of the known and trusted Margin contract on the blockchain\n', '    address public DYDX_MARGIN;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address margin\n', '    )\n', '        public\n', '    {\n', '        DYDX_MARGIN = margin;\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyMargin()\n', '    {\n', '        require(\n', '            msg.sender == DYDX_MARGIN,\n', '            "OnlyMargin#onlyMargin: Only Margin can call"\n', '        );\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/lib/LoanOfferingParser.sol\n', '\n', '/**\n', ' * @title LoanOfferingParser\n', ' * @author dYdX\n', ' *\n', ' * Contract for LoanOfferingVerifiers to parse arguments\n', ' */\n', 'contract LoanOfferingParser {\n', '\n', '    // ============ Parsing Functions ============\n', '\n', '    function parseLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes signature\n', '    )\n', '        internal\n', '        pure\n', '        returns (MarginCommon.LoanOffering memory)\n', '    {\n', '        MarginCommon.LoanOffering memory loanOffering;\n', '\n', '        fillLoanOfferingAddresses(loanOffering, addresses);\n', '        fillLoanOfferingValues256(loanOffering, values256);\n', '        fillLoanOfferingValues32(loanOffering, values32);\n', '        loanOffering.signature = signature;\n', '\n', '        return loanOffering;\n', '    }\n', '\n', '    function fillLoanOfferingAddresses(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        address[9] addresses\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.owedToken = addresses[0];\n', '        loanOffering.heldToken = addresses[1];\n', '        loanOffering.payer = addresses[2];\n', '        loanOffering.owner = addresses[3];\n', '        loanOffering.taker = addresses[4];\n', '        loanOffering.positionOwner = addresses[5];\n', '        loanOffering.feeRecipient = addresses[6];\n', '        loanOffering.lenderFeeToken = addresses[7];\n', '        loanOffering.takerFeeToken = addresses[8];\n', '    }\n', '\n', '    function fillLoanOfferingValues256(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        uint256[7] values256\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.rates.maxAmount = values256[0];\n', '        loanOffering.rates.minAmount = values256[1];\n', '        loanOffering.rates.minHeldToken = values256[2];\n', '        loanOffering.rates.lenderFee = values256[3];\n', '        loanOffering.rates.takerFee = values256[4];\n', '        loanOffering.expirationTimestamp = values256[5];\n', '        loanOffering.salt = values256[6];\n', '    }\n', '\n', '    function fillLoanOfferingValues32(\n', '        MarginCommon.LoanOffering memory loanOffering,\n', '        uint32[4] values32\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        loanOffering.callTimeLimit = values32[0];\n', '        loanOffering.maxDuration = values32[1];\n', '        loanOffering.rates.interestRate = values32[2];\n', '        loanOffering.rates.interestPeriod = values32[3];\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/lib/MarginHelper.sol\n', '\n', '/**\n', ' * @title MarginHelper\n', ' * @author dYdX\n', ' *\n', ' * This library contains helper functions for interacting with Margin\n', ' */\n', 'library MarginHelper {\n', '    function getPosition(\n', '        address DYDX_MARGIN,\n', '        bytes32 positionId\n', '    )\n', '        internal\n', '        view\n', '        returns (MarginCommon.Position memory)\n', '    {\n', '        (\n', '            address[4] memory addresses,\n', '            uint256[2] memory values256,\n', '            uint32[6]  memory values32\n', '        ) = Margin(DYDX_MARGIN).getPosition(positionId);\n', '\n', '        return MarginCommon.Position({\n', '            owedToken: addresses[0],\n', '            heldToken: addresses[1],\n', '            lender: addresses[2],\n', '            owner: addresses[3],\n', '            principal: values256[0],\n', '            requiredDeposit: values256[1],\n', '            callTimeLimit: values32[0],\n', '            startTimestamp: values32[1],\n', '            callTimestamp: values32[2],\n', '            maxDuration: values32[3],\n', '            interestRate: values32[4],\n', '            interestPeriod: values32[5]\n', '        });\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/BucketLender/BucketLender.sol\n', '\n', '/**\n', ' * @title BucketLender\n', ' * @author dYdX\n', ' *\n', ' * On-chain shared lender that allows anyone to deposit tokens into this contract to be used to\n', ' * lend tokens for a particular margin position.\n', ' *\n', ' * - Each bucket has three variables:\n', ' *   - Available Amount\n', ' *     - The available amount of tokens that the bucket has to lend out\n', ' *   - Outstanding Principal\n', ' *     - The amount of principal that the bucket is responsible for in the margin position\n', ' *   - Weight\n', " *     - Used to keep track of each account's weighted ownership within a bucket\n", ' *     - Relative weight between buckets is meaningless\n', " *     - Only accounts' relative weight within a bucket matters\n", ' *\n', ' * - Token Deposits:\n', ' *   - Go into a particular bucket, determined by time since the start of the position\n', ' *     - If the position has not started: bucket = 0\n', ' *     - If the position has started:     bucket = ceiling(time_since_start / BUCKET_TIME)\n', ' *     - This is always the highest bucket; no higher bucket yet exists\n', " *   - Increase the bucket's Available Amount\n", " *   - Increase the bucket's weight and the account's weight in that bucket\n", ' *\n', ' * - Token Withdrawals:\n', ' *   - Can be from any bucket with available amount\n', " *   - Decrease the bucket's Available Amount\n", " *   - Decrease the bucket's weight and the account's weight in that bucket\n", ' *\n', ' * - Increasing the Position (Lending):\n', ' *   - The lowest buckets with Available Amount are used first\n', ' *   - Decreases Available Amount\n', ' *   - Increases Outstanding Principal\n', ' *\n', ' * - Decreasing the Position (Being Paid-Back)\n', ' *   - The highest buckets with Outstanding Principal are paid back first\n', ' *   - Decreases Outstanding Principal\n', ' *   - Increases Available Amount\n', ' *\n', ' *\n', ' * - Over time, this gives highest interest rates to earlier buckets, but disallows withdrawals from\n', ' *   those buckets for a longer period of time.\n', ' * - Deposits in the same bucket earn the same interest rate.\n', ' * - Lenders can withdraw their funds at any time if they are not being lent (and are therefore not\n', ' *   making the maximum interest).\n', ' * - The highest bucket with Outstanding Principal is always less-than-or-equal-to the lowest bucket\n', '     with Available Amount\n', ' */\n', 'contract BucketLender is\n', '    Ownable,\n', '    OnlyMargin,\n', '    LoanOwner,\n', '    IncreaseLoanDelegator,\n', '    MarginCallDelegator,\n', '    CancelMarginCallDelegator,\n', '    ForceRecoverCollateralDelegator,\n', '    LoanOfferingParser,\n', '    LoanOfferingVerifier,\n', '    ReentrancyGuard\n', '{\n', '    using SafeMath for uint256;\n', '    using TokenInteract for address;\n', '\n', '    // ============ Events ============\n', '\n', '    event Deposit(\n', '        address indexed beneficiary,\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        uint256 weight\n', '    );\n', '\n', '    event Withdraw(\n', '        address indexed withdrawer,\n', '        uint256 bucket,\n', '        uint256 weight,\n', '        uint256 owedTokenWithdrawn,\n', '        uint256 heldTokenWithdrawn\n', '    );\n', '\n', '    event PrincipalIncreased(\n', '        uint256 principalTotal,\n', '        uint256 bucketNumber,\n', '        uint256 principalForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event PrincipalDecreased(\n', '        uint256 principalTotal,\n', '        uint256 bucketNumber,\n', '        uint256 principalForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event AvailableIncreased(\n', '        uint256 availableTotal,\n', '        uint256 bucketNumber,\n', '        uint256 availableForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    event AvailableDecreased(\n', '        uint256 availableTotal,\n', '        uint256 bucketNumber,\n', '        uint256 availableForBucket,\n', '        uint256 amount\n', '    );\n', '\n', '    // ============ State Variables ============\n', '\n', '    /**\n', '     * Available Amount is the amount of tokens that is available to be lent by each bucket.\n', '     * These tokens are also available to be withdrawn by the accounts that have weight in the\n', '     * bucket.\n', '     */\n', '    // Available Amount for each bucket\n', '    mapping(uint256 => uint256) public availableForBucket;\n', '\n', '    // Total Available Amount\n', '    uint256 public availableTotal;\n', '\n', '    /**\n', "     * Outstanding Principal is the share of the margin position's principal that each bucket\n", '     * is responsible for. That is, each bucket with Outstanding Principal is owed\n', '     * (Outstanding Principal)*E^(RT) owedTokens in repayment.\n', '     */\n', '    // Outstanding Principal for each bucket\n', '    mapping(uint256 => uint256) public principalForBucket;\n', '\n', '    // Total Outstanding Principal\n', '    uint256 public principalTotal;\n', '\n', '    /**\n', "     * Weight determines an account's proportional share of a bucket. Relative weights have no\n", '     * meaning if they are not for the same bucket. Likewise, the relative weight of two buckets has\n', '     * no meaning. However, the relative weight of two accounts within the same bucket is equal to\n', "     * the accounts' shares in the bucket and are therefore proportional to the payout that they\n", '     * should expect from withdrawing from that bucket.\n', '     */\n', '    // Weight for each account in each bucket\n', '    mapping(uint256 => mapping(address => uint256)) public weightForBucketForAccount;\n', '\n', '    // Total Weight for each bucket\n', '    mapping(uint256 => uint256) public weightForBucket;\n', '\n', '    /**\n', '     * The critical bucket is:\n', '     * - Greater-than-or-equal-to The highest bucket with Outstanding Principal\n', '     * - Less-than-or-equal-to the lowest bucket with Available Amount\n', '     *\n', '     * It is equal to both of these values in most cases except in an edge cases where the two\n', '     * buckets are different. This value is cached to find such a bucket faster than looping through\n', '     * all possible buckets.\n', '     */\n', '    uint256 public criticalBucket = 0;\n', '\n', '    /**\n', '     * Latest cached value for totalOwedTokenRepaidToLender.\n', '     * This number updates on the dYdX Margin base protocol whenever the position is\n', '     * partially-closed, but this contract is not notified at that time. Therefore, it is updated\n', '     * upon increasing the position or when depositing/withdrawing\n', '     */\n', '    uint256 public cachedRepaidAmount = 0;\n', '\n', '    // True if the position was closed from force-recovering the collateral\n', '    bool public wasForceClosed = false;\n', '\n', '    // ============ Constants ============\n', '\n', '    // Unique ID of the position\n', '    bytes32 public POSITION_ID;\n', '\n', '    // Address of the token held in the position as collateral\n', '    address public HELD_TOKEN;\n', '\n', '    // Address of the token being lent\n', '    address public OWED_TOKEN;\n', '\n', '    // Time between new buckets\n', '    uint32 public BUCKET_TIME;\n', '\n', '    // Interest rate of the position\n', '    uint32 public INTEREST_RATE;\n', '\n', '    // Interest period of the position\n', '    uint32 public INTEREST_PERIOD;\n', '\n', '    // Maximum duration of the position\n', '    uint32 public MAX_DURATION;\n', '\n', '    // Margin-call time-limit of the position\n', '    uint32 public CALL_TIMELIMIT;\n', '\n', '    // (NUMERATOR/DENOMINATOR) denotes the minimum collateralization ratio of the position\n', '    uint32 public MIN_HELD_TOKEN_NUMERATOR;\n', '    uint32 public MIN_HELD_TOKEN_DENOMINATOR;\n', '\n', '    // Accounts that are permitted to margin-call positions (or cancel the margin call)\n', '    mapping(address => bool) public TRUSTED_MARGIN_CALLERS;\n', '\n', '    // Accounts that are permitted to withdraw on behalf of any address\n', '    mapping(address => bool) public TRUSTED_WITHDRAWERS;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address margin,\n', '        bytes32 positionId,\n', '        address heldToken,\n', '        address owedToken,\n', '        uint32[7] parameters,\n', '        address[] trustedMarginCallers,\n', '        address[] trustedWithdrawers\n', '    )\n', '        public\n', '        OnlyMargin(margin)\n', '    {\n', '        POSITION_ID = positionId;\n', '        HELD_TOKEN = heldToken;\n', '        OWED_TOKEN = owedToken;\n', '\n', '        require(\n', '            parameters[0] != 0,\n', '            "BucketLender#constructor: BUCKET_TIME cannot be zero"\n', '        );\n', '        BUCKET_TIME = parameters[0];\n', '        INTEREST_RATE = parameters[1];\n', '        INTEREST_PERIOD = parameters[2];\n', '        MAX_DURATION = parameters[3];\n', '        CALL_TIMELIMIT = parameters[4];\n', '        MIN_HELD_TOKEN_NUMERATOR = parameters[5];\n', '        MIN_HELD_TOKEN_DENOMINATOR = parameters[6];\n', '\n', '        // Initialize TRUSTED_MARGIN_CALLERS and TRUSTED_WITHDRAWERS\n', '        uint256 i = 0;\n', '        for (i = 0; i < trustedMarginCallers.length; i++) {\n', '            TRUSTED_MARGIN_CALLERS[trustedMarginCallers[i]] = true;\n', '        }\n', '        for (i = 0; i < trustedWithdrawers.length; i++) {\n', '            TRUSTED_WITHDRAWERS[trustedWithdrawers[i]] = true;\n', '        }\n', '\n', '        // Set maximum allowance on proxy\n', '        OWED_TOKEN.approve(\n', '            Margin(margin).getTokenProxyAddress(),\n', '            MathHelpers.maxUint256()\n', '        );\n', '    }\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyPosition(bytes32 positionId) {\n', '        require(\n', '            POSITION_ID == positionId,\n', '            "BucketLender#onlyPosition: Incorrect position"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Margin-Only State-Changing Functions ============\n', '\n', '    /**\n', '     * Function a smart contract must implement to be able to consent to a loan. The loan offering\n', '     * will be generated off-chain. The "loan owner" address will own the loan-side of the resulting\n', '     * position.\n', '     *\n', '     * @param  addresses    Loan offering addresses\n', '     * @param  values256    Loan offering uint256s\n', '     * @param  values32     Loan offering uint32s\n', '     * @param  positionId   Unique ID of the position\n', '     * @param  signature    Arbitrary bytes\n', '     * @return              This address to accept, a different address to ask that contract\n', '     */\n', '    function verifyLoanOffering(\n', '        address[9] addresses,\n', '        uint256[7] values256,\n', '        uint32[4] values32,\n', '        bytes32 positionId,\n', '        bytes signature\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            Margin(DYDX_MARGIN).containsPosition(POSITION_ID),\n', '            "BucketLender#verifyLoanOffering: This contract should not open a new position"\n', '        );\n', '\n', '        MarginCommon.LoanOffering memory loanOffering = parseLoanOffering(\n', '            addresses,\n', '            values256,\n', '            values32,\n', '            signature\n', '        );\n', '\n', '        // CHECK ADDRESSES\n', '        assert(loanOffering.owedToken == OWED_TOKEN);\n', '        assert(loanOffering.heldToken == HELD_TOKEN);\n', '        assert(loanOffering.payer == address(this));\n', '        assert(loanOffering.owner == address(this));\n', '        require(\n', '            loanOffering.taker == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.taker is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.feeRecipient == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.feeRecipient is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.positionOwner == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.positionOwner is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.lenderFeeToken == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.lenderFeeToken is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.takerFeeToken == address(0),\n', '            "BucketLender#verifyLoanOffering: loanOffering.takerFeeToken is non-zero"\n', '        );\n', '\n', '        // CHECK VALUES256\n', '        require(\n', '            loanOffering.rates.maxAmount == MathHelpers.maxUint256(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.maxAmount is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.rates.minAmount == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.minAmount is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.minHeldToken == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.minHeldToken is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.lenderFee == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.lenderFee is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.rates.takerFee == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.takerFee is non-zero"\n', '        );\n', '        require(\n', '            loanOffering.expirationTimestamp == MathHelpers.maxUint256(),\n', '            "BucketLender#verifyLoanOffering: expirationTimestamp is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.salt == 0,\n', '            "BucketLender#verifyLoanOffering: loanOffering.salt is non-zero"\n', '        );\n', '\n', '        // CHECK VALUES32\n', '        require(\n', '            loanOffering.callTimeLimit == MathHelpers.maxUint32(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.callTimelimit is incorrect"\n', '        );\n', '        require(\n', '            loanOffering.maxDuration == MathHelpers.maxUint32(),\n', '            "BucketLender#verifyLoanOffering: loanOffering.maxDuration is incorrect"\n', '        );\n', '        assert(loanOffering.rates.interestRate == INTEREST_RATE);\n', '        assert(loanOffering.rates.interestPeriod == INTEREST_PERIOD);\n', '\n', '        // no need to require anything about loanOffering.signature\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Called by the Margin contract when anyone transfers ownership of a loan to this contract.\n', '     * This function initializes this contract and returns this address to indicate to Margin\n', '     * that it is willing to take ownership of the loan.\n', '     *\n', '     * @param  from        Address of the previous owner\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address on success, throw otherwise\n', '     */\n', '    function receiveLoanOwnership(\n', '        address from,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        MarginCommon.Position memory position = MarginHelper.getPosition(DYDX_MARGIN, POSITION_ID);\n', '        uint256 initialPrincipal = position.principal;\n', '        uint256 minHeldToken = MathHelpers.getPartialAmount(\n', '            uint256(MIN_HELD_TOKEN_NUMERATOR),\n', '            uint256(MIN_HELD_TOKEN_DENOMINATOR),\n', '            initialPrincipal\n', '        );\n', '\n', '        assert(initialPrincipal > 0);\n', '        assert(principalTotal == 0);\n', '        assert(from != address(this)); // position must be opened without lending from this position\n', '\n', '        require(\n', '            position.owedToken == OWED_TOKEN,\n', '            "BucketLender#receiveLoanOwnership: Position owedToken mismatch"\n', '        );\n', '        require(\n', '            position.heldToken == HELD_TOKEN,\n', '            "BucketLender#receiveLoanOwnership: Position heldToken mismatch"\n', '        );\n', '        require(\n', '            position.maxDuration == MAX_DURATION,\n', '            "BucketLender#receiveLoanOwnership: Position maxDuration mismatch"\n', '        );\n', '        require(\n', '            position.callTimeLimit == CALL_TIMELIMIT,\n', '            "BucketLender#receiveLoanOwnership: Position callTimeLimit mismatch"\n', '        );\n', '        require(\n', '            position.interestRate == INTEREST_RATE,\n', '            "BucketLender#receiveLoanOwnership: Position interestRate mismatch"\n', '        );\n', '        require(\n', '            position.interestPeriod == INTEREST_PERIOD,\n', '            "BucketLender#receiveLoanOwnership: Position interestPeriod mismatch"\n', '        );\n', '        require(\n', '            Margin(DYDX_MARGIN).getPositionBalance(POSITION_ID) >= minHeldToken,\n', '            "BucketLender#receiveLoanOwnership: Not enough heldToken as collateral"\n', '        );\n', '\n', '        // set relevant constants\n', '        principalForBucket[0] = initialPrincipal;\n', '        principalTotal = initialPrincipal;\n', '        weightForBucket[0] = weightForBucket[0].add(initialPrincipal);\n', '        weightForBucketForAccount[0][from] =\n', '            weightForBucketForAccount[0][from].add(initialPrincipal);\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Called by Margin when additional value is added onto the position this contract\n', '     * is lending for. Balance is added to the address that loaned the additional tokens.\n', '     *\n', '     * @param  payer           Address that loaned the additional tokens\n', '     * @param  positionId      Unique ID of the position\n', '     * @param  principalAdded  Amount that was added to the position\n', '     * @param  lentAmount      Amount of owedToken lent\n', '     * @return                 This address to accept, a different address to ask that contract\n', '     */\n', '    function increaseLoanOnBehalfOf(\n', '        address payer,\n', '        bytes32 positionId,\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '\n', '        require(\n', '            payer == address(this),\n', '            "BucketLender#increaseLoanOnBehalfOf: Other lenders cannot lend for this position"\n', '        );\n', '        require(\n', '            !margin.isPositionCalled(POSITION_ID),\n', '            "BucketLender#increaseLoanOnBehalfOf: No lending while the position is margin-called"\n', '        );\n', '\n', '        // This function is only called after the state has been updated in the base protocol;\n', '        // thus, the principal in the base protocol will equal the principal after the increase\n', '        uint256 principalAfterIncrease = margin.getPositionPrincipal(POSITION_ID);\n', '        uint256 principalBeforeIncrease = principalAfterIncrease.sub(principalAdded);\n', '\n', '        // principalTotal was the principal after the previous increase\n', '        accountForClose(principalTotal.sub(principalBeforeIncrease));\n', '\n', '        accountForIncrease(principalAdded, lentAmount);\n', '\n', '        assert(principalTotal == principalAfterIncrease);\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call marginCall().\n', '     *\n', '     * @param  caller         Address of the caller of the marginCall function\n', '     * @param  positionId     Unique ID of the position\n', '     * @param  depositAmount  Amount of heldToken deposit that will be required to cancel the call\n', '     * @return                This address to accept, a different address to ask that contract\n', '     */\n', '    function marginCallOnBehalfOf(\n', '        address caller,\n', '        bytes32 positionId,\n', '        uint256 depositAmount\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            TRUSTED_MARGIN_CALLERS[caller],\n', '            "BucketLender#marginCallOnBehalfOf: Margin-caller must be trusted"\n', '        );\n', '        require(\n', '            depositAmount == 0, // prevents depositing from canceling the margin-call\n', '            "BucketLender#marginCallOnBehalfOf: Deposit amount must be zero"\n', '        );\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call cancelMarginCall().\n', '     *\n', '     * @param  canceler    Address of the caller of the cancelMarginCall function\n', '     * @param  positionId  Unique ID of the position\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function cancelMarginCallOnBehalfOf(\n', '        address canceler,\n', '        bytes32 positionId\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        require(\n', '            TRUSTED_MARGIN_CALLERS[canceler],\n', '            "BucketLender#cancelMarginCallOnBehalfOf: Margin-call-canceler must be trusted"\n', '        );\n', '\n', '        return address(this);\n', '    }\n', '\n', '    /**\n', '     * Function a contract must implement in order to let other addresses call\n', '     * forceRecoverCollateral().\n', '     *\n', '     *  param  recoverer   Address of the caller of the forceRecoverCollateral() function\n', '     * @param  positionId  Unique ID of the position\n', '     * @param  recipient   Address to send the recovered tokens to\n', '     * @return             This address to accept, a different address to ask that contract\n', '     */\n', '    function forceRecoverCollateralOnBehalfOf(\n', '        address /* recoverer */,\n', '        bytes32 positionId,\n', '        address recipient\n', '    )\n', '        external\n', '        onlyMargin\n', '        nonReentrant\n', '        onlyPosition(positionId)\n', '        returns (address)\n', '    {\n', '        return forceRecoverCollateralInternal(recipient);\n', '    }\n', '\n', '    // ============ Public State-Changing Functions ============\n', '\n', '    /**\n', '     * Allow anyone to recalculate the Outstanding Principal and Available Amount for the buckets if\n', '     * part of the position has been closed since the last position increase.\n', '     */\n', '    function rebalanceBuckets()\n', '        external\n', '        nonReentrant\n', '    {\n', '        rebalanceBucketsInternal();\n', '    }\n', '\n', '    /**\n', '     * Allows users to deposit owedToken into this contract. Allowance must be set on this contract\n', '     * for "token" in at least the amount "amount".\n', '     *\n', '     * @param  beneficiary  The account that will be entitled to this depoit\n', '     * @param  amount       The amount of owedToken to deposit\n', '     * @return              The bucket number that was deposited into\n', '     */\n', '    function deposit(\n', '        address beneficiary,\n', '        uint256 amount\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256)\n', '    {\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '        bytes32 positionId = POSITION_ID;\n', '\n', '        require(\n', '            beneficiary != address(0),\n', '            "BucketLender#deposit: Beneficiary cannot be the zero address"\n', '        );\n', '        require(\n', '            amount != 0,\n', '            "BucketLender#deposit: Cannot deposit zero tokens"\n', '        );\n', '        require(\n', '            !margin.isPositionClosed(positionId),\n', '            "BucketLender#deposit: Cannot deposit after the position is closed"\n', '        );\n', '        require(\n', '            !margin.isPositionCalled(positionId),\n', '            "BucketLender#deposit: Cannot deposit while the position is margin-called"\n', '        );\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        OWED_TOKEN.transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        uint256 bucket = getCurrentBucket();\n', '\n', '        uint256 effectiveAmount = availableForBucket[bucket].add(getBucketOwedAmount(bucket));\n', '\n', '        uint256 weightToAdd = 0;\n', '        if (effectiveAmount == 0) {\n', '            weightToAdd = amount; // first deposit in bucket\n', '        } else {\n', '            weightToAdd = MathHelpers.getPartialAmount(\n', '                amount,\n', '                effectiveAmount,\n', '                weightForBucket[bucket]\n', '            );\n', '        }\n', '\n', '        require(\n', '            weightToAdd != 0,\n', '            "BucketLender#deposit: Cannot deposit for zero weight"\n', '        );\n', '\n', '        // update state\n', '        updateAvailable(bucket, amount, true);\n', '        weightForBucketForAccount[bucket][beneficiary] =\n', '            weightForBucketForAccount[bucket][beneficiary].add(weightToAdd);\n', '        weightForBucket[bucket] = weightForBucket[bucket].add(weightToAdd);\n', '\n', '        emit Deposit(\n', '            beneficiary,\n', '            bucket,\n', '            amount,\n', '            weightToAdd\n', '        );\n', '\n', '        return bucket;\n', '    }\n', '\n', '    /**\n', '     * Allows users to withdraw their lent funds. An account can withdraw its weighted share of the\n', '     * bucket.\n', '     *\n', "     * While the position is open, a bucket's share is equal to:\n", '     *   Owed Token: (Available Amount) + (Outstanding Principal) * (1 + interest)\n', '     *   Held Token: 0\n', '     *\n', "     * After the position is closed, a bucket's share is equal to:\n", '     *   Owed Token: (Available Amount)\n', '     *   Held Token: (Held Token Balance) * (Outstanding Principal) / (Total Outstanding Principal)\n', '     *\n', '     * @param  buckets      The bucket numbers to withdraw from\n', '     * @param  maxWeights   The maximum weight to withdraw from each bucket. The amount of tokens\n', '     *                      withdrawn will be at least this amount, but not necessarily more.\n', '     *                      Withdrawing the same weight from different buckets does not necessarily\n', '     *                      return the same amounts from those buckets. In order to withdraw as many\n', '     *                      tokens as possible, use the maximum uint256.\n', '     * @param  onBehalfOf   The address to withdraw on behalf of\n', '     * @return              1) The number of owedTokens withdrawn\n', '     *                      2) The number of heldTokens withdrawn\n', '     */\n', '    function withdraw(\n', '        uint256[] buckets,\n', '        uint256[] maxWeights,\n', '        address onBehalfOf\n', '    )\n', '        external\n', '        nonReentrant\n', '        returns (uint256, uint256)\n', '    {\n', '        require(\n', '            buckets.length == maxWeights.length,\n', '            "BucketLender#withdraw: The lengths of the input arrays must match"\n', '        );\n', '        if (onBehalfOf != msg.sender) {\n', '            require(\n', '                TRUSTED_WITHDRAWERS[msg.sender],\n', '                "BucketLender#withdraw: Only trusted withdrawers can withdraw on behalf of others"\n', '            );\n', '        }\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        // decide if some bucket is unable to be withdrawn from (is locked)\n', '        // the zero value represents no-lock\n', '        uint256 lockedBucket = 0;\n', '        if (\n', '            Margin(DYDX_MARGIN).containsPosition(POSITION_ID) &&\n', '            criticalBucket == getCurrentBucket()\n', '        ) {\n', '            lockedBucket = criticalBucket;\n', '        }\n', '\n', '        uint256[2] memory results; // [0] = totalOwedToken, [1] = totalHeldToken\n', '\n', '        uint256 maxHeldToken = 0;\n', '        if (wasForceClosed) {\n', '            maxHeldToken = HELD_TOKEN.balanceOf(address(this));\n', '        }\n', '\n', '        for (uint256 i = 0; i < buckets.length; i++) {\n', '            uint256 bucket = buckets[i];\n', '\n', '            // prevent withdrawing from the current bucket if it is also the critical bucket\n', '            if ((bucket != 0) && (bucket == lockedBucket)) {\n', '                continue;\n', '            }\n', '\n', '            (uint256 owedTokenForBucket, uint256 heldTokenForBucket) = withdrawSingleBucket(\n', '                onBehalfOf,\n', '                bucket,\n', '                maxWeights[i],\n', '                maxHeldToken\n', '            );\n', '\n', '            results[0] = results[0].add(owedTokenForBucket);\n', '            results[1] = results[1].add(heldTokenForBucket);\n', '        }\n', '\n', '        // Transfer share of owedToken\n', '        OWED_TOKEN.transfer(msg.sender, results[0]);\n', '        HELD_TOKEN.transfer(msg.sender, results[1]);\n', '\n', '        return (results[0], results[1]);\n', '    }\n', '\n', '    /**\n', '     * Allows the owner to withdraw any excess tokens sent to the vault by unconventional means,\n', '     * including (but not limited-to) token airdrops. Any tokens moved to this contract by calling\n', '     * deposit() will be accounted for and will not be withdrawable by this function.\n', '     *\n', '     * @param  token  ERC20 token address\n', '     * @param  to     Address to transfer tokens to\n', '     * @return        Amount of tokens withdrawn\n', '     */\n', '    function withdrawExcessToken(\n', '        address token,\n', '        address to\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        rebalanceBucketsInternal();\n', '\n', '        uint256 amount = token.balanceOf(address(this));\n', '\n', '        if (token == OWED_TOKEN) {\n', '            amount = amount.sub(availableTotal);\n', '        } else if (token == HELD_TOKEN) {\n', '            require(\n', '                !wasForceClosed,\n', '                "BucketLender#withdrawExcessToken: heldToken cannot be withdrawn if force-closed"\n', '            );\n', '        }\n', '\n', '        token.transfer(to, amount);\n', '        return amount;\n', '    }\n', '\n', '    // ============ Public Getter Functions ============\n', '\n', '    /**\n', '     * Get the current bucket number that funds will be deposited into. This is also the highest\n', '     * bucket so far.\n', '     *\n', '     * @return The highest bucket and the one that funds will be deposited into\n', '     */\n', '    function getCurrentBucket()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // load variables from storage;\n', '        Margin margin = Margin(DYDX_MARGIN);\n', '        bytes32 positionId = POSITION_ID;\n', '        uint32 bucketTime = BUCKET_TIME;\n', '\n', '        assert(!margin.isPositionClosed(positionId));\n', '\n', '        // if position not created, allow deposits in the first bucket\n', '        if (!margin.containsPosition(positionId)) {\n', '            return 0;\n', '        }\n', '\n', '        // return the number of BUCKET_TIME periods elapsed since the position start, rounded-up\n', '        uint256 startTimestamp = margin.getPositionStartTimestamp(positionId);\n', '        return block.timestamp.sub(startTimestamp).div(bucketTime).add(1);\n', '    }\n', '\n', '    /**\n', '     * Gets the outstanding amount of owedToken owed to a bucket. This is the principal amount of\n', '     * the bucket multiplied by the interest accrued in the position. If the position is closed,\n', '     * then any outstanding principal will never be repaid in the form of owedToken.\n', '     *\n', '     * @param  bucket  The bucket number\n', '     * @return         The amount of owedToken that this bucket expects to be paid-back if the posi\n', '     */\n', '    function getBucketOwedAmount(\n', '        uint256 bucket\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // if the position is completely closed, then the outstanding principal will never be repaid\n', '        if (Margin(DYDX_MARGIN).isPositionClosed(POSITION_ID)) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 lentPrincipal = principalForBucket[bucket];\n', '\n', '        // the bucket has no outstanding principal\n', '        if (lentPrincipal == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // get the total amount of owedToken that would be paid back at this time\n', '        uint256 owedAmount = Margin(DYDX_MARGIN).getPositionOwedAmountAtTime(\n', '            POSITION_ID,\n', '            principalTotal,\n', '            uint32(block.timestamp)\n', '        );\n', '\n', "        // return the bucket's share\n", '        return MathHelpers.getPartialAmount(\n', '            lentPrincipal,\n', '            principalTotal,\n', '            owedAmount\n', '        );\n', '    }\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    function forceRecoverCollateralInternal(\n', '        address recipient\n', '    )\n', '        internal\n', '        returns (address)\n', '    {\n', '        require(\n', '            recipient == address(this),\n', '            "BucketLender#forceRecoverCollateralOnBehalfOf: Recipient must be this contract"\n', '        );\n', '\n', '        rebalanceBucketsInternal();\n', '\n', '        wasForceClosed = true;\n', '\n', '        return address(this);\n', '    }\n', '\n', '    // ============ Private Helper Functions ============\n', '\n', '    /**\n', '     * Recalculates the Outstanding Principal and Available Amount for the buckets. Only changes the\n', '     * state if part of the position has been closed since the last position increase.\n', '     */\n', '    function rebalanceBucketsInternal()\n', '        private\n', '    {\n', "        // if force-closed, don't update the outstanding principal values; they are needed to repay\n", '        // lenders with heldToken\n', '        if (wasForceClosed) {\n', '            return;\n', '        }\n', '\n', '        uint256 marginPrincipal = Margin(DYDX_MARGIN).getPositionPrincipal(POSITION_ID);\n', '\n', '        accountForClose(principalTotal.sub(marginPrincipal));\n', '\n', '        assert(principalTotal == marginPrincipal);\n', '    }\n', '\n', '    /**\n', '     * Updates the state variables at any time. Only does anything after the position has been\n', '     * closed or partially-closed since the last time this function was called.\n', '     *\n', '     * - Increases the available amount in the highest buckets with outstanding principal\n', '     * - Decreases the principal amount in those buckets\n', '     *\n', '     * @param  principalRemoved  Amount of principal closed since the last update\n', '     */\n', '    function accountForClose(\n', '        uint256 principalRemoved\n', '    )\n', '        private\n', '    {\n', '        if (principalRemoved == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newRepaidAmount = Margin(DYDX_MARGIN).getTotalOwedTokenRepaidToLender(POSITION_ID);\n', '        assert(newRepaidAmount.sub(cachedRepaidAmount) >= principalRemoved);\n', '\n', '        uint256 principalToSub = principalRemoved;\n', '        uint256 availableToAdd = newRepaidAmount.sub(cachedRepaidAmount);\n', '        uint256 criticalBucketTemp = criticalBucket;\n', '\n', '        // loop over buckets in reverse order starting with the critical bucket\n', '        for (\n', '            uint256 bucket = criticalBucketTemp;\n', '            principalToSub > 0;\n', '            bucket--\n', '        ) {\n', '            assert(bucket <= criticalBucketTemp); // no underflow on bucket\n', '\n', '            uint256 principalTemp = Math.min256(principalToSub, principalForBucket[bucket]);\n', '            if (principalTemp == 0) {\n', '                continue;\n', '            }\n', '            uint256 availableTemp = MathHelpers.getPartialAmount(\n', '                principalTemp,\n', '                principalToSub,\n', '                availableToAdd\n', '            );\n', '\n', '            updateAvailable(bucket, availableTemp, true);\n', '            updatePrincipal(bucket, principalTemp, false);\n', '\n', '            principalToSub = principalToSub.sub(principalTemp);\n', '            availableToAdd = availableToAdd.sub(availableTemp);\n', '\n', '            criticalBucketTemp = bucket;\n', '        }\n', '\n', '        assert(principalToSub == 0);\n', '        assert(availableToAdd == 0);\n', '\n', '        setCriticalBucket(criticalBucketTemp);\n', '\n', '        cachedRepaidAmount = newRepaidAmount;\n', '    }\n', '\n', '    /**\n', '     * Updates the state variables when a position is increased.\n', '     *\n', '     * - Decreases the available amount in the lowest buckets with available token\n', '     * - Increases the principal amount in those buckets\n', '     *\n', '     * @param  principalAdded  Amount of principal added to the position\n', '     * @param  lentAmount      Amount of owedToken lent\n', '     */\n', '    function accountForIncrease(\n', '        uint256 principalAdded,\n', '        uint256 lentAmount\n', '    )\n', '        private\n', '    {\n', '        require(\n', '            lentAmount <= availableTotal,\n', '            "BucketLender#accountForIncrease: No lending not-accounted-for funds"\n', '        );\n', '\n', '        uint256 principalToAdd = principalAdded;\n', '        uint256 availableToSub = lentAmount;\n', '        uint256 criticalBucketTemp;\n', '\n', '        // loop over buckets in order starting from the critical bucket\n', '        uint256 lastBucket = getCurrentBucket();\n', '        for (\n', '            uint256 bucket = criticalBucket;\n', '            principalToAdd > 0;\n', '            bucket++\n', '        ) {\n', '            assert(bucket <= lastBucket); // should never go past the last bucket\n', '\n', '            uint256 availableTemp = Math.min256(availableToSub, availableForBucket[bucket]);\n', '            if (availableTemp == 0) {\n', '                continue;\n', '            }\n', '            uint256 principalTemp = MathHelpers.getPartialAmount(\n', '                availableTemp,\n', '                availableToSub,\n', '                principalToAdd\n', '            );\n', '\n', '            updateAvailable(bucket, availableTemp, false);\n', '            updatePrincipal(bucket, principalTemp, true);\n', '\n', '            principalToAdd = principalToAdd.sub(principalTemp);\n', '            availableToSub = availableToSub.sub(availableTemp);\n', '\n', '            criticalBucketTemp = bucket;\n', '        }\n', '\n', '        assert(principalToAdd == 0);\n', '        assert(availableToSub == 0);\n', '\n', '        setCriticalBucket(criticalBucketTemp);\n', '    }\n', '\n', '    /**\n', '     * Withdraw\n', '     *\n', '     * @param  onBehalfOf    The account for which to withdraw for\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  maxWeight     The maximum weight to withdraw\n', '     * @param  maxHeldToken  The total amount of heldToken that has been force-recovered\n', '     * @return               1) The number of owedTokens withdrawn\n', '     *                       2) The number of heldTokens withdrawn\n', '     */\n', '    function withdrawSingleBucket(\n', '        address onBehalfOf,\n', '        uint256 bucket,\n', '        uint256 maxWeight,\n', '        uint256 maxHeldToken\n', '    )\n', '        private\n', '        returns (uint256, uint256)\n', '    {\n', "        // calculate the user's share\n", '        uint256 bucketWeight = weightForBucket[bucket];\n', '        if (bucketWeight == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 userWeight = weightForBucketForAccount[bucket][onBehalfOf];\n', '        uint256 weightToWithdraw = Math.min256(maxWeight, userWeight);\n', '        if (weightToWithdraw == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        // update state\n', '        weightForBucket[bucket] = weightForBucket[bucket].sub(weightToWithdraw);\n', '        weightForBucketForAccount[bucket][onBehalfOf] = userWeight.sub(weightToWithdraw);\n', '\n', '        // calculate for owedToken\n', '        uint256 owedTokenToWithdraw = withdrawOwedToken(\n', '            bucket,\n', '            weightToWithdraw,\n', '            bucketWeight\n', '        );\n', '\n', '        // calculate for heldToken\n', '        uint256 heldTokenToWithdraw = withdrawHeldToken(\n', '            bucket,\n', '            weightToWithdraw,\n', '            bucketWeight,\n', '            maxHeldToken\n', '        );\n', '\n', '        emit Withdraw(\n', '            onBehalfOf,\n', '            bucket,\n', '            weightToWithdraw,\n', '            owedTokenToWithdraw,\n', '            heldTokenToWithdraw\n', '        );\n', '\n', '        return (owedTokenToWithdraw, heldTokenToWithdraw);\n', '    }\n', '\n', '    /**\n', '     * Helper function to withdraw earned owedToken from this contract.\n', '     *\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  userWeight    The amount of weight the user is using to withdraw\n', '     * @param  bucketWeight  The total weight of the bucket\n', '     * @return               The amount of owedToken being withdrawn\n', '     */\n', '    function withdrawOwedToken(\n', '        uint256 bucket,\n', '        uint256 userWeight,\n', '        uint256 bucketWeight\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        // amount to return for the bucket\n', '        uint256 owedTokenToWithdraw = MathHelpers.getPartialAmount(\n', '            userWeight,\n', '            bucketWeight,\n', '            availableForBucket[bucket].add(getBucketOwedAmount(bucket))\n', '        );\n', '\n', '        // check that there is enough token to give back\n', '        require(\n', '            owedTokenToWithdraw <= availableForBucket[bucket],\n', '            "BucketLender#withdrawOwedToken: There must be enough available owedToken"\n', '        );\n', '\n', '        // update amounts\n', '        updateAvailable(bucket, owedTokenToWithdraw, false);\n', '\n', '        return owedTokenToWithdraw;\n', '    }\n', '\n', '    /**\n', '     * Helper function to withdraw heldToken from this contract.\n', '     *\n', '     * @param  bucket        The bucket number to withdraw from\n', '     * @param  userWeight    The amount of weight the user is using to withdraw\n', '     * @param  bucketWeight  The total weight of the bucket\n', '     * @param  maxHeldToken  The total amount of heldToken available to withdraw\n', '     * @return               The amount of heldToken being withdrawn\n', '     */\n', '    function withdrawHeldToken(\n', '        uint256 bucket,\n', '        uint256 userWeight,\n', '        uint256 bucketWeight,\n', '        uint256 maxHeldToken\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        if (maxHeldToken == 0) {\n', '            return 0;\n', '        }\n', '\n', "        // user's principal for the bucket\n", '        uint256 principalForBucketForAccount = MathHelpers.getPartialAmount(\n', '            userWeight,\n', '            bucketWeight,\n', '            principalForBucket[bucket]\n', '        );\n', '\n', '        uint256 heldTokenToWithdraw = MathHelpers.getPartialAmount(\n', '            principalForBucketForAccount,\n', '            principalTotal,\n', '            maxHeldToken\n', '        );\n', '\n', '        updatePrincipal(bucket, principalForBucketForAccount, false);\n', '\n', '        return heldTokenToWithdraw;\n', '    }\n', '\n', '    // ============ Setter Functions ============\n', '\n', '    /**\n', '     * Changes the critical bucket variable\n', '     *\n', '     * @param  bucket  The value to set criticalBucket to\n', '     */\n', '    function setCriticalBucket(\n', '        uint256 bucket\n', '    )\n', '        private\n', '    {\n', "        // don't spend the gas to sstore unless we need to change the value\n", '        if (criticalBucket == bucket) {\n', '            return;\n', '        }\n', '\n', '        criticalBucket = bucket;\n', '    }\n', '\n', '    /**\n', '     * Changes the available owedToken amount. This changes both the variable to track the total\n', '     * amount as well as the variable to track a particular bucket.\n', '     *\n', '     * @param  bucket    The bucket number\n', '     * @param  amount    The amount to change the available amount by\n', '     * @param  increase  True if positive change, false if negative change\n', '     */\n', '    function updateAvailable(\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        bool increase\n', '    )\n', '        private\n', '    {\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newTotal;\n', '        uint256 newForBucket;\n', '\n', '        if (increase) {\n', '            newTotal = availableTotal.add(amount);\n', '            newForBucket = availableForBucket[bucket].add(amount);\n', '            emit AvailableIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        } else {\n', '            newTotal = availableTotal.sub(amount);\n', '            newForBucket = availableForBucket[bucket].sub(amount);\n', '            emit AvailableDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        }\n', '\n', '        availableTotal = newTotal;\n', '        availableForBucket[bucket] = newForBucket;\n', '    }\n', '\n', '    /**\n', '     * Changes the principal amount. This changes both the variable to track the total\n', '     * amount as well as the variable to track a particular bucket.\n', '     *\n', '     * @param  bucket    The bucket number\n', '     * @param  amount    The amount to change the principal amount by\n', '     * @param  increase  True if positive change, false if negative change\n', '     */\n', '    function updatePrincipal(\n', '        uint256 bucket,\n', '        uint256 amount,\n', '        bool increase\n', '    )\n', '        private\n', '    {\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 newTotal;\n', '        uint256 newForBucket;\n', '\n', '        if (increase) {\n', '            newTotal = principalTotal.add(amount);\n', '            newForBucket = principalForBucket[bucket].add(amount);\n', '            emit PrincipalIncreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        } else {\n', '            newTotal = principalTotal.sub(amount);\n', '            newForBucket = principalForBucket[bucket].sub(amount);\n', '            emit PrincipalDecreased(newTotal, bucket, newForBucket, amount); // solium-disable-line\n', '        }\n', '\n', '        principalTotal = newTotal;\n', '        principalForBucket[bucket] = newForBucket;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/external/BucketLender/EthWrapperForBucketLender.sol\n', '\n', '/**\n', ' * @title EthWrapperForBucketLender\n', ' * @author dYdX\n', ' *\n', ' * Takes ETH directly, wraps it, then sends it to a bucket lender on behalf of a user.\n', ' */\n', 'contract EthWrapperForBucketLender\n', '{\n', '    using TokenInteract for address;\n', '\n', '    // ============ Constants ============\n', '\n', '    // Address of the WETH token\n', '    address public WETH;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address weth\n', '    )\n', '        public\n', '    {\n', '        WETH = weth;\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Fallback function. Disallows ether to be sent to this contract without data except when\n', '     * unwrapping WETH.\n', '     */\n', '    function ()\n', '        external\n', '        payable\n', '    {\n', '        require( // coverage-disable-line\n', '            msg.sender == WETH,\n', '            "EthWrapperForBucketLender#fallback: Cannot recieve ETH directly unless unwrapping WETH"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Allows users to send eth directly to this contract and have it be wrapped and sent to a\n', '     * BucketLender to be lent for some margin position.\n', '     *\n', '     * @param  bucketLender  The address of the BucketLender contract to deposit money into\n', '     * @param  beneficiary   The address that will retain rights to the deposit\n', '     * @return               The bucket number that was deposited into\n', '     */\n', '    function depositEth(\n', '        address bucketLender,\n', '        address beneficiary\n', '    )\n', '        external\n', '        payable\n', '        returns (uint256)\n', '    {\n', '        uint256 amount = msg.value;\n', '\n', '        require(\n', '            amount != 0,\n', '            "EthWrapperForBucketLender#depositEth: Cannot deposit zero amount"\n', '        );\n', '\n', '        // wrap the eth\n', '        WETH9(WETH).deposit.value(amount)();\n', '        assert(WETH.balanceOf(address(this)) >= amount);\n', '\n', '        // ensure enough allowance\n', '        if (WETH.allowance(address(this), bucketLender) == 0) {\n', '            // approve for "unlimited amount". WETH9 leaves this value as-is when doing transferFrom\n', '            WETH.approve(bucketLender, MathHelpers.maxUint256());\n', '        }\n', '\n', '        // deposit the tokens\n', '        return BucketLender(bucketLender).deposit(beneficiary, amount);\n', '    }\n', '\n', '    /**\n', '     * Allows users to send eth directly to this contract and have it be wrapped and sent to a\n', '     * BucketLender to be lent for some margin position.\n', '     *\n', '     * @param  bucketLender  The address of the BucketLender contract to deposit money into\n', '     * @return               The bucket number that was deposited into\n', '     */\n', '    function withdrawEth(\n', '        address bucketLender,\n', '        uint256[] buckets,\n', '        uint256[] maxWeights\n', '    )\n', '        external\n', '        returns (uint256, uint256)\n', '    {\n', '        address owedToken = BucketLender(bucketLender).OWED_TOKEN();\n', '        address heldToken = BucketLender(bucketLender).HELD_TOKEN();\n', '        require(\n', '            owedToken == WETH,\n', '            "EthWrapperForBucketLender: Cannot withdraw from non-WETH BucketLender"\n', '        );\n', '\n', '        // withdraw the weth\n', '        (\n', '            uint256 owedTokenAmount,\n', '            uint256 heldTokenAmount\n', '        ) = BucketLender(bucketLender).withdraw(\n', '            buckets,\n', '            maxWeights,\n', '            msg.sender\n', '        );\n', '\n', '        // send all eth to msg.sender\n', '        if (owedTokenAmount != 0) {\n', '            WETH9(owedToken).withdraw(owedTokenAmount);\n', '            msg.sender.transfer(owedTokenAmount);\n', '        }\n', '\n', '        // send all other tokens to msg.sender\n', '        if (heldTokenAmount != 0) {\n', '            heldToken.transfer(msg.sender, heldTokenAmount);\n', '        }\n', '\n', '        return (owedTokenAmount, heldTokenAmount);\n', '    }\n', '}']
