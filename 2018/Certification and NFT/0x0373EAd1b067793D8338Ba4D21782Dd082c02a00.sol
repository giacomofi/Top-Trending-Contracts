['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', 'contract SuperHeroes is Pausable {\n', '    \n', '  /*** CONSTANTS ***/\n', '\n', '  string public constant name = "SuperHero";\n', '  string public constant symbol = "SH";\n', '  \n', '  /** VARIABLES **/\n', '  uint256 public fee = 2;\n', '  uint256 public snatch = 24 hours;\n', '\n', '  /*** DATA TYPES ***/\n', '\n', '  struct Token {\n', '    string name;\n', '    uint256 price;\n', '    uint256 purchased;\n', '  }\n', '\n', '  /*** STORAGE ***/\n', '\n', '  Token[] tokens;\n', '\n', '  mapping (uint256 => address) public tokenIndexToOwner;\n', '  mapping (address => uint256) ownershipTokenCount;\n', '  mapping (uint256 => address) public tokenIndexToApproved;\n', '  mapping (uint256 => Token) public herosForSale;\n', '\n', '  /*** INTERNAL FUNCTIONS ***/\n', '\n', '  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return tokenIndexToOwner[_tokenId] == _claimant;\n', '  }\n', '\n', '  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n', '    return tokenIndexToApproved[_tokenId] == _claimant;\n', '  }\n', '\n', '  function _approve(address _to, uint256 _tokenId) internal {\n', '    tokenIndexToApproved[_tokenId] = _to;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n', '    ownershipTokenCount[_to]++;\n', '    tokenIndexToOwner[_tokenId] = _to;\n', '\n', '    if (_from != address(0)) {\n', '      ownershipTokenCount[_from]--;\n', '      delete tokenIndexToApproved[_tokenId];\n', '    }\n', '  }\n', '\n', '  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n', '    require(tokens.length < 250, "Max amount of superheroes is reached");  \n', '    Token memory token = Token({\n', '      name: _name,\n', '      price: _price,\n', '      purchased: now\n', '    });\n', '    tokenId = tokens.push(token) - 1;\n', '    \n', '    _transfer(0, owner, tokenId);\n', '  }\n', '\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return tokens.length;\n', '  }\n', '\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return ownershipTokenCount[_owner];\n', '  }\n', '\n', '  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n', '    owner = tokenIndexToOwner[_tokenId];\n', '\n', '    require(owner != address(0));\n', '  }\n', '\n', '  function approve(address _to, uint256 _tokenId) external {\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    _approve(_to, _tokenId);\n', '  }\n', '\n', '  function transfer(address _to, uint256 _tokenId) external {\n', '    require(_to != address(0));\n', '    require(_to != address(this));\n', '    require(_owns(msg.sender, _tokenId));\n', '\n', '    _transfer(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n', '    require(_to != address(0));\n', '    require(_to != address(this));\n', '    require(_approvedFor(msg.sender, _tokenId));\n', '    require(_owns(_from, _tokenId));\n', '\n', '    _transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n', '    uint256 balance = balanceOf(_owner);\n', '\n', '    if (balance == 0) {\n', '      return new uint256[](0);\n', '    } else {\n', '      uint256[] memory result = new uint256[](balance);\n', '      uint256 maxTokenId = totalSupply();\n', '      uint256 idx = 0;\n', '\n', '      uint256 tokenId;\n', '      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n', '        if (tokenIndexToOwner[tokenId] == _owner) {\n', '          result[idx] = tokenId;\n', '          idx++;\n', '        }\n', '      }\n', '    }\n', '\n', '    return result;\n', '  }\n', '\n', '\n', '  /*** EXTERNAL FUNCTIONS ***/\n', '\n', '  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n', '    uint256 pricerecalc = _price;\n', '    return _mint(_name, pricerecalc);\n', '  }\n', '\n', '  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n', '    Token memory token = tokens[_tokenId];\n', '\n', '    _name = token.name;\n', '    _price = token.price;\n', '    _purchased = token.purchased;\n', '  }\n', '  \n', '  function snatchHero(uint256 _id) external payable whenNotPaused {\n', '      require(now - tokens[_id].purchased <= snatch);\n', '      uint256 pricerecalc = tokens[_id].price;\n', '      require(pricerecalc <= msg.value);\n', '      address previos = tokenIndexToOwner[_id];\n', '      uint256 realPriceFee = msg.value * fee / 100;\n', '      uint256 realPrice = msg.value - realPriceFee;\n', '      uint256 newPriceRise = pricerecalc * 120 / 100;\n', '      // owner.transfer(realPriceFee);\n', '      previos.transfer(realPrice);\n', '      _transfer(previos, msg.sender, _id);\n', '      tokens[_id].purchased = now;\n', '      tokens[_id].price = newPriceRise;\n', '  }\n', '  \n', '  function buyHero(uint256 _id) external payable whenNotPaused {\n', '      require(herosForSale[_id].price != 0);\n', '      uint256 pricerecalc = herosForSale[_id].price;\n', '      require(msg.value >= pricerecalc);\n', '      // owner.transfer(msg.value);\n', '      _transfer(owner, msg.sender, _id);\n', '      uint256 newPriceRise = pricerecalc * 120 / 100;\n', '      tokens[_id].purchased = now;\n', '      tokens[_id].price = newPriceRise;\n', '      \n', '      delete herosForSale[_id];\n', '  }\n', '  \n', '  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n', '      require(msg.sender == tokenIndexToOwner[_id]);\n', '      herosForSale[_id] = tokens[_id];\n', '  }\n', '\n', '  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n', '      require(msg.sender == tokenIndexToOwner[_id]);\n', '      tokens[_id].price = _price;\n', '  }\n', '  \n', '  function withdraw(address to, uint256 amount) external onlyOwner {\n', '      to.transfer(amount);\n', '  }\n', '}']