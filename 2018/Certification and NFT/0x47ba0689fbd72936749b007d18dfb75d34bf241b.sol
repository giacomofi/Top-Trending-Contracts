['pragma solidity ^0.4.1;\n', '\n', '// File: contracts/OwnerValidator.sol\n', '\n', 'contract TokenContract {\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function decimals() constant returns(uint8 units);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, address _msgSender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, address _msgSender, uint256 _value) returns (bool success);\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, address _msgSender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', 'contract OwnerValidator {\n', '    function validate(address addr) constant returns (bool);\n', '}\n', '\n', 'contract Owned {\n', '    function ownerValidate(address addr) constant returns (bool);\n', '    bool public isWorking;\n', '\n', '    function Owned() {\n', '        isWorking = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (!ownerValidate(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyWorking {\n', '        if (!isWorking) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyNotWorking {\n', '        if (isWorking) throw;\n', '        _;\n', '    }\n', '\n', '    function setWorking(bool _isWorking) onlyOwner {\n', '        isWorking = _isWorking;\n', '    }\n', '}\n', '\n', 'contract OwnerValidatorImpl is OwnerValidator, Owned {\n', '\n', '    address[] public owners;\n', '\n', '\n', '    TokenContract public tokenContract;\n', '\n', '    function OwnerValidatorImpl() {\n', '        owners.push(msg.sender);\n', '    }\n', '\n', '\n', '    function indexOfOwners(address _address) private constant returns (uint pos) {\n', '        pos = 0;\n', '        for (uint i = 0; i < owners.length; i++) {\n', '            if (owners[i] == _address) {\n', '                pos = i + 1;\n', '                break;\n', '            }\n', '        }\n', '        return pos;                \n', '    }\n', '\n', '    function validate(address addr) constant returns (bool) {\n', '        return (indexOfOwners(addr) != 0);\n', '    }\n', '        \n', '    function getOwners() constant returns (address[]) {\n', '        return owners;\n', '    } \n', '\n', '    function addOwner(address addr) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            if (!validate(addr)) {\n', '                owners.push(addr);\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeOwner(address addr) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            uint pos = indexOfOwners(addr);\n', '            if (pos > 0) {\n', '                owners[pos - 1] = 0x0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return validate(addr);\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!validate(msg.sender)) throw;\n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/OffChainManager.sol\n', '\n', 'contract OffChainManager {\n', '    function isToOffChainAddress(address addr) constant returns (bool);\n', '    function getOffChainRootAddress() constant returns (address);\n', '}\n', '\n', 'contract OffChainManagerImpl is OffChainManager, Owned {\n', '    address public rootAddress;\n', '    address[] public offChainAddreses;\n', '\n', '    mapping (address => uint256) refOffChainAddresses; \n', '\n', '    OwnerValidator public ownerValidator;\n', '\n', '    TokenContract public tokenContract;\n', '\n', '    function OffChainManagerImpl(\n', '        address _rootAddress,\n', '        address _ownerValidator\n', '    ) {\n', '        rootAddress = _rootAddress;\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '    }\n', '\n', '    function setRootAddress(address _address) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            rootAddress = _address;\n', '        }\n', '    }\n', '\n', '    function setOwnerValidatorAddress(address _ownerValidator) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function offChainAddresesValidCount() constant returns (uint) {\n', '        uint cnt = 0;\n', '        for (uint i = 0; i < offChainAddreses.length; i++) {\n', '            if (offChainAddreses[i] != 0) {\n', '                cnt++;\n', '            }\n', '        }\n', '        return cnt;\n', '    }\n', '\n', '    function addOffChainAddress(address _address) private {\n', '        if (!isToOffChainAddress(_address)) {\n', '            offChainAddreses.push(_address);\n', '            refOffChainAddresses[_address] = offChainAddreses.length;\n', '        }\n', '    }\n', '\n', '    function removeOffChainAddress(address _address) private {\n', '        uint pos = refOffChainAddresses[_address];\n', '        if (pos > 0) {\n', '            offChainAddreses[pos - 1] = 0;\n', '            refOffChainAddresses[_address] = 0x0;\n', '        }\n', '    }\n', '\n', '    function addOffChainAddresses(address[] _addresses) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            for (uint i = 0; i < _addresses.length; i++) {\n', '                addOffChainAddress(_addresses[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeOffChainAddresses(address[] _addresses) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            for (uint i = 0; i < _addresses.length; i++) {\n', '                removeOffChainAddress(_addresses[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return ownerValidator.validate(addr);\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function isToOffChainAddress(address addr) constant returns (bool) {\n', '        return refOffChainAddresses[addr] > 0;\n', '    }\n', '\n', '    function getOffChainRootAddress() constant returns (address) {\n', '        return rootAddress;\n', '    }\n', '\n', '    function getOffChainAddresses() constant returns (address[]) {\n', '        return offChainAddreses;\n', '    } \n', '\n', '    function isToOffChainAddresses(address[] _addresses) constant returns (bool) {\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            if (!isToOffChainAddress(_addresses[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/TokenContract.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '// assert(b > 0);\n', '    uint256 c = a / b;\n', '// assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TokenContractImpl is TokenContract, Owned {\n', '    using SafeMath for uint256;\n', '    string public standard = "Token 0.1";\n', '    uint256 _totalSupply;\n', '    uint8 _decimals;\n', '    address public _mainAddress;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    OwnerValidator public ownerValidator;\n', '    OffChainManager public offChainManager;\n', '\n', '    bool public isRedenominated;\n', '    uint256 public redenomiValue;\n', '    mapping (address => uint256) public redenominatedBalances;\n', '    mapping (address => mapping (address => uint256)) public redenominatedAllowed;\n', '\n', '    function TokenContractImpl(\n', '        uint256 initialSupply,\n', '        uint8 decimals,\n', '        address _ownerValidator,\n', '        address _offChainManager\n', '    ){\n', '        balances[msg.sender] = initialSupply;\n', '        _totalSupply = initialSupply;\n', '        _decimals = decimals;\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '        offChainManager = OffChainManager(_offChainManager);\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        if (isRedenominated) {\n', '            return redenominatedValue(_totalSupply);\n', '        }\n', '        return _totalSupply;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_owner] > 0) {\n', '                return redenominatedBalances[_owner];\n', '            }\n', '            return redenominatedValue(balances[_owner]);\n', '        }\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        if (isRedenominated) {\n', '            if (redenominatedAllowed[_owner][_spender] > 0) {\n', '                return redenominatedAllowed[_owner][_spender];\n', '            }\n', '            return redenominatedValue(allowed[_owner][_spender]);\n', '        }\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function redenominatedValue(uint256 _value) private returns (uint256) {\n', '        return _value.mul(redenomiValue);\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return ownerValidator.validate(addr);\n', '    }\n', '\n', '\n', '    function redenominate(uint256 _redenomiValue) {\n', '        if (isRedenominated) throw;\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            redenomiValue = _redenomiValue;\n', '            Redenominate(msg.sender, isRedenominated, redenomiValue);\n', '        }\n', '    }   \n', '\n', '\n', '    function applyRedenomination() onlyNotWorking {\n', '        if (isRedenominated) throw;\n', '        if (redenomiValue == 0) throw;\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            isRedenominated = true;\n', '            ApplyRedenomination(msg.sender, isRedenominated, redenomiValue);\n', '        }\n', '    }   \n', '\n', '    function setOwnerValidatorAddress(address _ownerValidator) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setOffChainManagerAddress(address _offChainManager) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            offChainManager = OffChainManager(_offChainManager);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        return transferProcess(_msgSender, _to, _value);\n', '    }\n', '\n', '    function transferProcess(address _from, address _to, uint256 _value) private returns (bool success) {\n', '        if (balanceOf(_from) < _value) throw;\n', '        subtractBalance(_from, _value);\n', '        if (offChainManager.isToOffChainAddress(_to)) {\n', '            addBalance(offChainManager.getOffChainRootAddress(), _value);\n', '            ToOffChainTransfer(_from, _to, _to, _value);\n', '        } else {\n', '            addBalance(_to, _value);\n', '        }\n', '        return true;        \n', '    }\n', '\n', '    function addBalance(address _address, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_address] == 0) {\n', '                if (balances[_address] > 0) {\n', '                    redenominatedBalances[_address] = redenominatedValue(balances[_address]);\n', '                    balances[_address] = 0;\n', '                }\n', '            }\n', '            redenominatedBalances[_address] = redenominatedBalances[_address].add(_value);\n', '        } else {\n', '            balances[_address] = balances[_address].add(_value);\n', '        }\n', '    }\n', '\n', '    function subtractBalance(address _address, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_address] == 0) {\n', '                if (balances[_address] > 0) {\n', '                    redenominatedBalances[_address] = redenominatedValue(balances[_address]);\n', '                    balances[_address] = 0;\n', '                }\n', '            }\n', '            redenominatedBalances[_address] = redenominatedBalances[_address].sub(_value);\n', '        } else {\n', '            balances[_address] = balances[_address].sub(_value);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        if (balanceOf(_from) < _value) throw;\n', '        if (balanceOf(_to).add(_value) < balanceOf(_to)) throw;\n', '        if (_value > allowance(_from, _msgSender)) throw;\n', '        subtractBalance(_from, _value);\n', '        if (offChainManager.isToOffChainAddress(_to)) {\n', '            addBalance(offChainManager.getOffChainRootAddress(), _value);\n', '            ToOffChainTransfer(_msgSender, _to, _to, _value);\n', '        } else {\n', '            addBalance(_to, _value);\n', '        }\n', '        subtractAllowed(_from, _msgSender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFromSender(address _to, uint256 _value) onlyWorking returns (bool success) {\n', '        if (!transferProcess(msg.sender, _to, _value)) throw;\n', '        TransferFromSender(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFromOwn(address _to, uint256 _value) onlyWorking returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        if (!transferProcess(this, _to, _value)) throw;\n', '        TransferFromSender(this, _to, _value);    \n', '        return true;\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        setAllowed(_msgSender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function subtractAllowed(address _from, address _spender, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedAllowed[_from][_spender] == 0) {\n', '                if (allowed[_from][_spender] > 0) {\n', '                    redenominatedAllowed[_from][_spender] = redenominatedValue(allowed[_from][_spender]);\n', '                    allowed[_from][_spender] = 0;\n', '                }\n', '            }\n', '            redenominatedAllowed[_from][_spender] = redenominatedAllowed[_from][_spender].sub(_value);\n', '        } else {\n', '            allowed[_from][_spender] = allowed[_from][_spender].sub(_value);\n', '        }\n', '    }\n', '\n', '    function setAllowed(address _owner, address _spender, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            redenominatedAllowed[_owner][_spender] = _value;\n', '        } else {\n', '            allowed[_owner][_spender] = _value;\n', '        }\n', '    }\n', '\n', '    function setMainAddress(address _address) onlyOwner {\n', '        _mainAddress = _address;\n', '    }\n', '\n', '    event TransferFromSender(address indexed _from, address indexed _to, uint256 _value);\n', '    event ToOffChainTransfer(address indexed _from, address indexed _toKey, address _to, uint256 _value);\n', '    event Redenominate(address _owner, bool _isRedenominated, uint256 _redenomiVakye);\n', '    event ApplyRedenomination(address _owner, bool _isRedenominated, uint256 _redenomiVakye);\n', '}\n', '\n', '// File: contracts/MainContract.sol\n', '\n', 'contract MainContract {\n', '    string public standard = "Token 0.1";\n', '    string public name;\n', '    string public symbol;\n', '\n', '    OwnerValidator public ownerValidator;\n', '    TokenContract public tokenContract;\n', '\n', '    function MainContract(\n', '        string _tokenName,\n', '        address _ownerValidator,\n', '        address _tokenContract,\n', '        string _symbol\n', '    ) {\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '        tokenContract = TokenContract(_tokenContract);\n', '        name = _tokenName;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    function totalSupply() constant returns(uint256 totalSupply) {\n', '        return tokenContract.totalSupply();\n', '    }\n', '\n', '    function decimals() constant returns(uint8 decimals) {\n', '        return tokenContract.decimals();\n', '    }\n', '\n', '    function setOwnerValidateAddress(address _ownerValidator) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return uint256(tokenContract.balanceOf(_owner));\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (tokenContract.transfer(_to, msg.sender, _value)) {\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (tokenContract.transferFrom(_from, _to, msg.sender, _value)) {\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if (tokenContract.approve(_spender,msg.sender,_value)) {\n', '            Approval(msg.sender,_spender,_value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return tokenContract.allowance(_owner,_spender);\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
['pragma solidity ^0.4.1;\n', '\n', '// File: contracts/OwnerValidator.sol\n', '\n', 'contract TokenContract {\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function decimals() constant returns(uint8 units);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, address _msgSender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, address _msgSender, uint256 _value) returns (bool success);\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, address _msgSender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', 'contract OwnerValidator {\n', '    function validate(address addr) constant returns (bool);\n', '}\n', '\n', 'contract Owned {\n', '    function ownerValidate(address addr) constant returns (bool);\n', '    bool public isWorking;\n', '\n', '    function Owned() {\n', '        isWorking = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (!ownerValidate(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyWorking {\n', '        if (!isWorking) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyNotWorking {\n', '        if (isWorking) throw;\n', '        _;\n', '    }\n', '\n', '    function setWorking(bool _isWorking) onlyOwner {\n', '        isWorking = _isWorking;\n', '    }\n', '}\n', '\n', 'contract OwnerValidatorImpl is OwnerValidator, Owned {\n', '\n', '    address[] public owners;\n', '\n', '\n', '    TokenContract public tokenContract;\n', '\n', '    function OwnerValidatorImpl() {\n', '        owners.push(msg.sender);\n', '    }\n', '\n', '\n', '    function indexOfOwners(address _address) private constant returns (uint pos) {\n', '        pos = 0;\n', '        for (uint i = 0; i < owners.length; i++) {\n', '            if (owners[i] == _address) {\n', '                pos = i + 1;\n', '                break;\n', '            }\n', '        }\n', '        return pos;                \n', '    }\n', '\n', '    function validate(address addr) constant returns (bool) {\n', '        return (indexOfOwners(addr) != 0);\n', '    }\n', '        \n', '    function getOwners() constant returns (address[]) {\n', '        return owners;\n', '    } \n', '\n', '    function addOwner(address addr) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            if (!validate(addr)) {\n', '                owners.push(addr);\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeOwner(address addr) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            uint pos = indexOfOwners(addr);\n', '            if (pos > 0) {\n', '                owners[pos - 1] = 0x0;\n', '            }\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) onlyWorking {\n', '        if (validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return validate(addr);\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!validate(msg.sender)) throw;\n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/OffChainManager.sol\n', '\n', 'contract OffChainManager {\n', '    function isToOffChainAddress(address addr) constant returns (bool);\n', '    function getOffChainRootAddress() constant returns (address);\n', '}\n', '\n', 'contract OffChainManagerImpl is OffChainManager, Owned {\n', '    address public rootAddress;\n', '    address[] public offChainAddreses;\n', '\n', '    mapping (address => uint256) refOffChainAddresses; \n', '\n', '    OwnerValidator public ownerValidator;\n', '\n', '    TokenContract public tokenContract;\n', '\n', '    function OffChainManagerImpl(\n', '        address _rootAddress,\n', '        address _ownerValidator\n', '    ) {\n', '        rootAddress = _rootAddress;\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '    }\n', '\n', '    function setRootAddress(address _address) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            rootAddress = _address;\n', '        }\n', '    }\n', '\n', '    function setOwnerValidatorAddress(address _ownerValidator) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function offChainAddresesValidCount() constant returns (uint) {\n', '        uint cnt = 0;\n', '        for (uint i = 0; i < offChainAddreses.length; i++) {\n', '            if (offChainAddreses[i] != 0) {\n', '                cnt++;\n', '            }\n', '        }\n', '        return cnt;\n', '    }\n', '\n', '    function addOffChainAddress(address _address) private {\n', '        if (!isToOffChainAddress(_address)) {\n', '            offChainAddreses.push(_address);\n', '            refOffChainAddresses[_address] = offChainAddreses.length;\n', '        }\n', '    }\n', '\n', '    function removeOffChainAddress(address _address) private {\n', '        uint pos = refOffChainAddresses[_address];\n', '        if (pos > 0) {\n', '            offChainAddreses[pos - 1] = 0;\n', '            refOffChainAddresses[_address] = 0x0;\n', '        }\n', '    }\n', '\n', '    function addOffChainAddresses(address[] _addresses) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            for (uint i = 0; i < _addresses.length; i++) {\n', '                addOffChainAddress(_addresses[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeOffChainAddresses(address[] _addresses) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            for (uint i = 0; i < _addresses.length; i++) {\n', '                removeOffChainAddress(_addresses[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return ownerValidator.validate(addr);\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function isToOffChainAddress(address addr) constant returns (bool) {\n', '        return refOffChainAddresses[addr] > 0;\n', '    }\n', '\n', '    function getOffChainRootAddress() constant returns (address) {\n', '        return rootAddress;\n', '    }\n', '\n', '    function getOffChainAddresses() constant returns (address[]) {\n', '        return offChainAddreses;\n', '    } \n', '\n', '    function isToOffChainAddresses(address[] _addresses) constant returns (bool) {\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            if (!isToOffChainAddress(_addresses[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/TokenContract.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '// assert(b > 0);\n', '    uint256 c = a / b;\n', '// assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract TokenContractImpl is TokenContract, Owned {\n', '    using SafeMath for uint256;\n', '    string public standard = "Token 0.1";\n', '    uint256 _totalSupply;\n', '    uint8 _decimals;\n', '    address public _mainAddress;\n', '\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    OwnerValidator public ownerValidator;\n', '    OffChainManager public offChainManager;\n', '\n', '    bool public isRedenominated;\n', '    uint256 public redenomiValue;\n', '    mapping (address => uint256) public redenominatedBalances;\n', '    mapping (address => mapping (address => uint256)) public redenominatedAllowed;\n', '\n', '    function TokenContractImpl(\n', '        uint256 initialSupply,\n', '        uint8 decimals,\n', '        address _ownerValidator,\n', '        address _offChainManager\n', '    ){\n', '        balances[msg.sender] = initialSupply;\n', '        _totalSupply = initialSupply;\n', '        _decimals = decimals;\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '        offChainManager = OffChainManager(_offChainManager);\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        if (isRedenominated) {\n', '            return redenominatedValue(_totalSupply);\n', '        }\n', '        return _totalSupply;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 decimals) {\n', '        return _decimals;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_owner] > 0) {\n', '                return redenominatedBalances[_owner];\n', '            }\n', '            return redenominatedValue(balances[_owner]);\n', '        }\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        if (isRedenominated) {\n', '            if (redenominatedAllowed[_owner][_spender] > 0) {\n', '                return redenominatedAllowed[_owner][_spender];\n', '            }\n', '            return redenominatedValue(allowed[_owner][_spender]);\n', '        }\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function redenominatedValue(uint256 _value) private returns (uint256) {\n', '        return _value.mul(redenomiValue);\n', '    }\n', '\n', '    function ownerValidate(address addr) constant returns (bool) {\n', '        return ownerValidator.validate(addr);\n', '    }\n', '\n', '\n', '    function redenominate(uint256 _redenomiValue) {\n', '        if (isRedenominated) throw;\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            redenomiValue = _redenomiValue;\n', '            Redenominate(msg.sender, isRedenominated, redenomiValue);\n', '        }\n', '    }   \n', '\n', '\n', '    function applyRedenomination() onlyNotWorking {\n', '        if (isRedenominated) throw;\n', '        if (redenomiValue == 0) throw;\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            isRedenominated = true;\n', '            ApplyRedenomination(msg.sender, isRedenominated, redenomiValue);\n', '        }\n', '    }   \n', '\n', '    function setOwnerValidatorAddress(address _ownerValidator) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setOffChainManagerAddress(address _offChainManager) onlyWorking {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            offChainManager = OffChainManager(_offChainManager);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        return transferProcess(_msgSender, _to, _value);\n', '    }\n', '\n', '    function transferProcess(address _from, address _to, uint256 _value) private returns (bool success) {\n', '        if (balanceOf(_from) < _value) throw;\n', '        subtractBalance(_from, _value);\n', '        if (offChainManager.isToOffChainAddress(_to)) {\n', '            addBalance(offChainManager.getOffChainRootAddress(), _value);\n', '            ToOffChainTransfer(_from, _to, _to, _value);\n', '        } else {\n', '            addBalance(_to, _value);\n', '        }\n', '        return true;        \n', '    }\n', '\n', '    function addBalance(address _address, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_address] == 0) {\n', '                if (balances[_address] > 0) {\n', '                    redenominatedBalances[_address] = redenominatedValue(balances[_address]);\n', '                    balances[_address] = 0;\n', '                }\n', '            }\n', '            redenominatedBalances[_address] = redenominatedBalances[_address].add(_value);\n', '        } else {\n', '            balances[_address] = balances[_address].add(_value);\n', '        }\n', '    }\n', '\n', '    function subtractBalance(address _address, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedBalances[_address] == 0) {\n', '                if (balances[_address] > 0) {\n', '                    redenominatedBalances[_address] = redenominatedValue(balances[_address]);\n', '                    balances[_address] = 0;\n', '                }\n', '            }\n', '            redenominatedBalances[_address] = redenominatedBalances[_address].sub(_value);\n', '        } else {\n', '            balances[_address] = balances[_address].sub(_value);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        if (balanceOf(_from) < _value) throw;\n', '        if (balanceOf(_to).add(_value) < balanceOf(_to)) throw;\n', '        if (_value > allowance(_from, _msgSender)) throw;\n', '        subtractBalance(_from, _value);\n', '        if (offChainManager.isToOffChainAddress(_to)) {\n', '            addBalance(offChainManager.getOffChainRootAddress(), _value);\n', '            ToOffChainTransfer(_msgSender, _to, _to, _value);\n', '        } else {\n', '            addBalance(_to, _value);\n', '        }\n', '        subtractAllowed(_from, _msgSender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFromSender(address _to, uint256 _value) onlyWorking returns (bool success) {\n', '        if (!transferProcess(msg.sender, _to, _value)) throw;\n', '        TransferFromSender(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFromOwn(address _to, uint256 _value) onlyWorking returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        if (!transferProcess(this, _to, _value)) throw;\n', '        TransferFromSender(this, _to, _value);    \n', '        return true;\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, address _msgSender, uint256 _value) onlyWorking returns (bool success) {\n', '        if (msg.sender != _mainAddress) throw; \n', '        setAllowed(_msgSender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function subtractAllowed(address _from, address _spender, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            if (redenominatedAllowed[_from][_spender] == 0) {\n', '                if (allowed[_from][_spender] > 0) {\n', '                    redenominatedAllowed[_from][_spender] = redenominatedValue(allowed[_from][_spender]);\n', '                    allowed[_from][_spender] = 0;\n', '                }\n', '            }\n', '            redenominatedAllowed[_from][_spender] = redenominatedAllowed[_from][_spender].sub(_value);\n', '        } else {\n', '            allowed[_from][_spender] = allowed[_from][_spender].sub(_value);\n', '        }\n', '    }\n', '\n', '    function setAllowed(address _owner, address _spender, uint256 _value) private {\n', '        if (isRedenominated) {\n', '            redenominatedAllowed[_owner][_spender] = _value;\n', '        } else {\n', '            allowed[_owner][_spender] = _value;\n', '        }\n', '    }\n', '\n', '    function setMainAddress(address _address) onlyOwner {\n', '        _mainAddress = _address;\n', '    }\n', '\n', '    event TransferFromSender(address indexed _from, address indexed _to, uint256 _value);\n', '    event ToOffChainTransfer(address indexed _from, address indexed _toKey, address _to, uint256 _value);\n', '    event Redenominate(address _owner, bool _isRedenominated, uint256 _redenomiVakye);\n', '    event ApplyRedenomination(address _owner, bool _isRedenominated, uint256 _redenomiVakye);\n', '}\n', '\n', '// File: contracts/MainContract.sol\n', '\n', 'contract MainContract {\n', '    string public standard = "Token 0.1";\n', '    string public name;\n', '    string public symbol;\n', '\n', '    OwnerValidator public ownerValidator;\n', '    TokenContract public tokenContract;\n', '\n', '    function MainContract(\n', '        string _tokenName,\n', '        address _ownerValidator,\n', '        address _tokenContract,\n', '        string _symbol\n', '    ) {\n', '        ownerValidator = OwnerValidator(_ownerValidator);\n', '        tokenContract = TokenContract(_tokenContract);\n', '        name = _tokenName;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    function totalSupply() constant returns(uint256 totalSupply) {\n', '        return tokenContract.totalSupply();\n', '    }\n', '\n', '    function decimals() constant returns(uint8 decimals) {\n', '        return tokenContract.decimals();\n', '    }\n', '\n', '    function setOwnerValidateAddress(address _ownerValidator) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            ownerValidator = OwnerValidator(_ownerValidator);\n', '        }\n', '    }\n', '\n', '    function setTokenContract(address _tokenContract) {\n', '        if (ownerValidator.validate(msg.sender)) {\n', '            tokenContract = TokenContract(_tokenContract);\n', '        }\n', '    }\n', '\n', '    function transferFromSender(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw;\n', '        return tokenContract.transferFromSender(_to, _value);\n', '    }\n', '\n', '    function sendFromOwn(address _to, uint256 _value) returns (bool success) {\n', '        if (!ownerValidator.validate(msg.sender)) throw; \n', '        if (!_to.send(_value)) throw;\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return uint256(tokenContract.balanceOf(_owner));\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (tokenContract.transfer(_to, msg.sender, _value)) {\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (tokenContract.transferFrom(_from, _to, msg.sender, _value)) {\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if (tokenContract.approve(_spender,msg.sender,_value)) {\n', '            Approval(msg.sender,_spender,_value);\n', '            return true;\n', '        } else {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return tokenContract.allowance(_owner,_spender);\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
