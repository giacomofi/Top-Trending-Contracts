['pragma solidity ^0.4.24;\n', '\n', '/*\n', '// © 2018 SafeBlocks LTD.  All rights reserved.\n', '\n', '  _____            __          ____    _                  _\n', ' / ____|          / _|        |  _ \\  | |                | |\n', '| (___     __ _  | |_    ___  | |_) | | |   ___     ___  | | __  ___\n', ' \\___ \\   / _` | |  _|  / _ \\ |  _ <  | |  / _ \\   / __| | |/ / / __|\n', ' ____) | | (_| | | |   |  __/ | |_) | | | | (_) | | (__  |   <  \\__ \\\n', '|_____/   \\__,_| |_|    \\___| |____/  |_|  \\___/   \\___| |_|\\_\\ |___/\n', '\n', '\n', '// @author SafeBlocks\n', '// @date 30/04/2018\n', '*/\n', 'contract SafeBlocksFirewall {\n', '\n', '    event EnquireResult(address sourceAddress, bool approved, address token, uint amount, address destination, uint blockNumber, string msg);\n', '    event PolicyChanged(address contractAddress, address destination, address tokenAdress, uint limit);\n', '    event ConfigurationChanged(address sender, address newConfiguration, string message);\n', '\n', '    address owner;\n', '    address rulesOwner;\n', '    address proxyContract;\n', '    bool verbose;\n', '\n', '    mapping(address /*contractId*/ => LimitsRule) limitsRule;\n', '    mapping(address /*contractId*/ => uint) lastSuccessPerContract;\n', '    mapping(address /*contractId*/ => mapping(address /*destination*/ => uint)) lastSuccessPerContractPerDestination;\n', '    mapping(address /*contractId*/ => bool) blockAll;\n', '    mapping(address /*contractId*/ => bool) enforceBypass;\n', '    mapping(address /*contractId*/ => mapping(address /*destination*/ => mapping(address /*tokenAddress*/ => uint256 /*limit*/))) customerRules;\n', '\n', '    struct LimitsRule {\n', '        uint perAddressLimit;\n', '        uint globalLimit;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        verbose = true;\n', '    }\n', '\n', '    //*************************************** modifiers ****************************************\n', '\n', '    modifier onlyContractOwner {\n', '        require(owner == msg.sender, "You are not allowed to run this function, required role: Contract-Owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyRulesOwner {\n', '        require(rulesOwner == msg.sender, "You are not allowed to run this function, required role: Rules-Owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyProxy {\n', '        require(proxyContract == msg.sender, "You are not allowed to run this function, required role: SafeBlocks-Proxy");\n', '        _;\n', '    }\n', '\n', '    //*************************************** setters ****************************************\n', '\n', '    function setProxyContract(address _proxy)\n', '    onlyContractOwner\n', '    public {\n', '        proxyContract = _proxy;\n', '        emit ConfigurationChanged(msg.sender, _proxy, "a new proxy contract address has been assigned");\n', '    }\n', '\n', '    function setRulesOwner(address _rulesOwner)\n', '    public\n', '    onlyContractOwner {\n', '        rulesOwner = _rulesOwner;\n', '        emit ConfigurationChanged(msg.sender, _rulesOwner, "a new Rules-Owner has been assigned");\n', '    }\n', '\n', '    function setVerbose(bool _verbose)\n', '    onlyContractOwner\n', '    public {\n', '        verbose = _verbose;\n', '        emit ConfigurationChanged(msg.sender, msg.sender, "a new Verbose-Mode has been assigned");\n', '    }\n', '\n', '    //*************************************** firewall functionality ****************************************\n', '\n', '    function setBypassPerContract(address _contractAddress, bool _bypass)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractAddress, address(0), address(0), _bypass ? 1 : 0);\n', '        enforceBypass[_contractAddress] = _bypass;\n', '        //to maintain default true we check if the enforce is set to *false*\n', '    }\n', '\n', '    function setBlockAllPerContract(address _contractId, bool _isBlocked)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractId, address(0), address(0), 0);\n', '        blockAll[_contractId] = _isBlocked;\n', '    }\n', '\n', '    function setPerAddressLimit(address _contractId, uint _limit)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractId, address(0), address(0), _limit);\n', '        limitsRule[_contractId].perAddressLimit = _limit;\n', '    }\n', '\n', '    function setGlobalLimit(address _contractId, uint _limit)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractId, address(0), address(0), _limit);\n', '        limitsRule[_contractId].globalLimit = _limit;\n', '    }\n', '\n', '    function addRule(address _contractId, address _destination, address _token, uint256 _tokenLimit)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractId, _destination, _token, _tokenLimit);\n', '        customerRules[_contractId][_destination][_token] = _tokenLimit;\n', '    }\n', '\n', '    function removeRule(address _contractId, address _destination, address _token)\n', '    onlyRulesOwner\n', '    public {\n', '        if (verbose) emit PolicyChanged(_contractId, _destination, _token, 0);\n', '        delete customerRules[_contractId][_destination][_token];\n', '    }\n', '\n', '    function allowTransaction(address _contractAddress, uint _amount, address _destination, address _token)\n', '    public\n', '    onlyProxy\n', '    returns (bool){\n', '        if (enforceBypass[_contractAddress]) {\n', '            if (verbose) emit EnquireResult(_contractAddress, true, _token, _amount, _destination, block.number, "1");\n', '            return true;\n', '        }\n', '        if (blockAll[_contractAddress]) {//if block all activated for this contract, deny all\n', '            if (verbose) emit EnquireResult(_contractAddress, false, _token, _amount, _destination, block.number, "2");\n', '            return false;\n', '        }\n', '        uint256 limit = customerRules[_contractAddress][_destination][_token];\n', '        uint256 anyDestinationLimit = customerRules[_contractAddress][0x0][_token];\n', '\n', '        if (limit == 0 && anyDestinationLimit == 0) {//no rules ?? deny all\n', '            if (verbose) emit EnquireResult(_contractAddress, false, _token, _amount, _destination, block.number, "3");\n', '            return false;\n', '        }\n', '        if (anyDestinationLimit > 0 && limit == 0) {\n', '            limit = anyDestinationLimit;\n', '        }\n', '        if (_amount <= limit) {\n', '            if (limitsRule[_contractAddress].perAddressLimit == 0 && limitsRule[_contractAddress].globalLimit == 0) {\n', '                if (verbose) emit EnquireResult(_contractAddress, true, _token, _amount, _destination, block.number, "4");\n', '                return true;\n', '            }\n', '            // no need to record and check rate limits;\n', '            if (checkTimeFrameLimit(_contractAddress)) {\n', '                if (checkAddressLimit(_contractAddress, _destination)) {\n', '                    lastSuccessPerContract[_contractAddress] = block.number;\n', '                    lastSuccessPerContractPerDestination[_contractAddress][_destination] = block.number;\n', '                    if (verbose) emit EnquireResult(_contractAddress, true, _token, _amount, _destination, block.number, "5");\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        if (verbose) emit EnquireResult(_contractAddress, false, _token, _amount, _destination, block.number, "6");\n', '        return false;\n', '    }\n', '\n', '    //*************************************** private ****************************************\n', '\n', '    function checkAddressLimit(address _contractId, address _destination)\n', '    private\n', '    view\n', '    returns (bool){\n', '        if (lastSuccessPerContractPerDestination[_contractId][_destination] > 0) {\n', '            if (block.number - lastSuccessPerContractPerDestination[_contractId][_destination] < limitsRule[_contractId].perAddressLimit) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function checkTimeFrameLimit(address _contractId)\n', '    private\n', '    view\n', '    returns (bool) {\n', '        if (lastSuccessPerContract[_contractId] > 0) {\n', '            if (block.number - lastSuccessPerContract[_contractId] < limitsRule[_contractId].globalLimit) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //*************************************** getters ****************************************\n', '\n', '    function getLimits(address _contractId)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (uint, uint){\n', '        return (limitsRule[_contractId].perAddressLimit, limitsRule[_contractId].globalLimit);\n', '    }\n', '\n', '    function getLastSuccessPerContract(address _contractId)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (uint){\n', '        return (lastSuccessPerContract[_contractId]);\n', '    }\n', '\n', '    function getLastSuccessPerContractPerDestination(address _contractId, address _destination)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (uint){\n', '        return (lastSuccessPerContractPerDestination[_contractId][_destination]);\n', '    }\n', '\n', '    function getBlockAll(address _contractId)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (bool){\n', '        return (blockAll[_contractId]);\n', '    }\n', '\n', '    function getEnforceBypass(address _contractId)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (bool){\n', '        return (enforceBypass[_contractId]);\n', '    }\n', '\n', '    function getCustomerRules(address _contractId, address _destination, address _tokenAddress)\n', '    public\n', '    view\n', '    onlyContractOwner\n', '    returns (uint256){\n', '        return (customerRules[_contractId][_destination][_tokenAddress]);\n', '    }\n', '}\n', '// © 2018 SafeBlocks LTD.  All rights reserved.']