['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', '        // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', '    // NB: using bytes32 rather than the string type because it&#39;s cheaper gas-wise:\n', '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '  }\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '\n', '}\n', '\n', 'interface TokenReceiver {\n', '    function transferNotification(address from, uint256 amount, uint data) external;\n', '}\n', '\n', '\n', 'contract AugmintTokenInterface is Restricted, ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    bytes32 public peggedSymbol;\n', '    uint8 public decimals;\n', '\n', '    uint public totalSupply;\n', '    mapping(address => uint256) public balances; // Balances for each account\n', '    mapping(address => mapping (address => uint256)) public allowed; // allowances added with approve()\n', '\n', '    address public stabilityBoardProxy;\n', '    TransferFeeInterface public feeAccount;\n', '    mapping(bytes32 => bool) public delegatedTxHashesUsed; // record txHashes used by delegatedTransfer\n', '\n', '    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event AugmintTransfer(address indexed from, address indexed to, uint amount, string narrative, uint fee);\n', '    event TokenIssued(uint amount);\n', '    event TokenBurned(uint amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function increaseApproval(address spender, uint addedValue) external returns (bool);\n', '    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\n', '\n', '    function issueTo(address to, uint amount) external; // restrict it to "MonetarySupervisor" in impl.;\n', '    function burn(uint amount) external;\n', '\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external;\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external;\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external;\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    function balanceOf(address who) external view returns (uint);\n', '\n', '\n', '}\n', '\n', 'interface TransferFeeInterface {\n', '    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee);\n', '}\n', '\n', '\n', 'contract AugmintToken is AugmintTokenInterface {\n', '\n', '    event FeeAccountChanged(TransferFeeInterface newFeeAccount);\n', '\n', '    constructor(address permissionGranterContract, string _name, string _symbol, bytes32 _peggedSymbol, uint8 _decimals, TransferFeeInterface _feeAccount)\n', '    public Restricted(permissionGranterContract) {\n', '        require(_feeAccount != address(0), "feeAccount must be set");\n', '        require(bytes(_name).length > 0, "name must be set");\n', '        require(bytes(_symbol).length > 0, "symbol must be set");\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        peggedSymbol = _peggedSymbol;\n', '        decimals = _decimals;\n', '\n', '        feeAccount = _feeAccount;\n', '\n', '    }\n', '    function transfer(address to, uint256 amount) external returns (bool) {\n', '        _transfer(msg.sender, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    /* Transfers based on an offline signed transfer instruction. */\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, to, amount, narrative, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, to, amount, narrative);\n', '    }\n', '\n', '    function approve(address _spender, uint256 amount) external returns (bool) {\n', '        require(_spender != 0x0, "spender must be set");\n', '        allowed[msg.sender][_spender] = amount;\n', '        emit Approval(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     ERC20 transferFrom attack protection: https://github.com/DecentLabs/dcm-poc/issues/57\n', '     approve should be called when allowed[_spender] == 0. To increment allowed value is better\n', '     to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '     Based on MonolithDAO Token.sol */\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool) {\n', '        return _increaseApproval(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n', '        _transferFrom(from, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    // Issue tokens. See MonetarySupervisor but as a rule of thumb issueTo is only allowed:\n', '    //      - on new loan (by trusted Lender contracts)\n', '    //      - when converting old tokens using MonetarySupervisor\n', '    //      - strictly to reserve by Stability Board (via MonetarySupervisor)\n', '    function issueTo(address to, uint amount) external restrict("MonetarySupervisor") {\n', '        balances[to] = balances[to].add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '        emit Transfer(0x0, to, amount);\n', '        emit AugmintTransfer(0x0, to, amount, "", 0);\n', '    }\n', '\n', '    // Burn tokens. Anyone can burn from its own account. YOLO.\n', '    // Used by to burn from Augmint reserve or by Lender contract after loan repayment\n', '    function burn(uint amount) external {\n', '        require(balances[msg.sender] >= amount, "balance must be >= amount");\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Transfer(msg.sender, 0x0, amount);\n', '        emit AugmintTransfer(msg.sender, 0x0, amount, "", 0);\n', '    }\n', '\n', '    /* to upgrade feeAccount (eg. for fee calculation changes) */\n', '    function setFeeAccount(TransferFeeInterface newFeeAccount) external restrict("StabilityBoard") {\n', '        feeAccount = newFeeAccount;\n', '        emit FeeAccountChanged(newFeeAccount);\n', '    }\n', '\n', '    /*  transferAndNotify can be used by contracts which require tokens to have only 1 tx (instead of approve + call)\n', '        Eg. repay loan, lock funds, token sell order on exchange\n', '        Reverts on failue:\n', '            - transfer fails\n', '            - if transferNotification fails (callee must revert on failure)\n', '            - if targetContract is an account or targetContract doesn&#39;t have neither transferNotification or fallback fx\n', '        TODO: make data param generic bytes (see receiver code attempt in Locker.transferNotification)\n', '    */\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external {\n', '        _transfer(msg.sender, target, amount, "");\n', '\n', '        target.transferNotification(msg.sender, amount, data);\n', '    }\n', '\n', '    /* transferAndNotify based on an  instruction signed offline  */\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, target, amount, data, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, target, amount, "");\n', '        target.transferNotification(from, amount, data);\n', '    }\n', '\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external {\n', '        _transfer(msg.sender, to, amount, narrative);\n', '    }\n', '\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external {\n', '        _transferFrom(from, to, amount, narrative);\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function _checkHashAndTransferExecutorFee(bytes32 txHash, bytes signature, address signer,\n', '                                                uint maxExecutorFeeInToken, uint requestedExecutorFeeInToken) private {\n', '        require(requestedExecutorFeeInToken <= maxExecutorFeeInToken, "requestedExecutorFee must be <= maxExecutorFee");\n', '        require(!delegatedTxHashesUsed[txHash], "txHash already used");\n', '        delegatedTxHashesUsed[txHash] = true;\n', '\n', '        address recovered = ECRecovery.recover(ECRecovery.toEthSignedMessageHash(txHash), signature);\n', '        require(recovered == signer, "invalid signature");\n', '\n', '        _transfer(signer, msg.sender, requestedExecutorFeeInToken, "Delegated transfer fee", 0);\n', '    }\n', '\n', '    function _increaseApproval(address _approver, address _spender, uint _addedValue) private returns (bool) {\n', '        allowed[_approver][_spender] = allowed[_approver][_spender].add(_addedValue);\n', '        emit Approval(_approver, _spender, allowed[_approver][_spender]);\n', '    }\n', '\n', '    function _transferFrom(address from, address to, uint256 amount, string narrative) private {\n', '        require(balances[from] >= amount, "balance must >= amount");\n', '        require(allowed[from][msg.sender] >= amount, "allowance must be >= amount");\n', '        // don&#39;t allow 0 transferFrom if no approval:\n', '        require(allowed[from][msg.sender] > 0, "allowance must be >= 0 even with 0 amount");\n', '\n', '        /* NB: fee is deducted from owner. It can result that transferFrom of amount x to fail\n', '                when x + fee is not availale on owner balance */\n', '        _transfer(from, to, amount, narrative);\n', '\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative) private {\n', '        uint fee = feeAccount.calculateTransferFee(from, to, transferAmount);\n', '\n', '        _transfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative, uint fee) private {\n', '        require(to != 0x0, "to must be set");\n', '        uint amountWithFee = transferAmount.add(fee);\n', '        // to emit proper reason instead of failing on from.sub()\n', '        require(balances[from] >= amountWithFee, "balance must be >= amount + transfer fee");\n', '\n', '        if (fee > 0) {\n', '            balances[feeAccount] = balances[feeAccount].add(fee);\n', '            emit Transfer(from, feeAccount, fee);\n', '        }\n', '\n', '        balances[from] = balances[from].sub(amountWithFee);\n', '        balances[to] = balances[to].add(transferAmount);\n', '\n', '        emit Transfer(from, to, transferAmount);\n', '        emit AugmintTransfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '}\n', '\n', 'contract SystemAccount is Restricted {\n', '    event WithdrawFromSystemAccount(address tokenAddress, address to, uint tokenAmount, uint weiAmount,\n', '                                    string narrative);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    /* TODO: this is only for first pilots to avoid funds stuck in contract due to bugs.\n', '      remove this function for higher volume pilots */\n', '    function withdraw(AugmintToken tokenAddress, address to, uint tokenAmount, uint weiAmount, string narrative)\n', '    external restrict("StabilityBoard") {\n', '        tokenAddress.transferWithNarrative(to, tokenAmount, narrative);\n', '        if (weiAmount > 0) {\n', '            to.transfer(weiAmount);\n', '        }\n', '\n', '        emit WithdrawFromSystemAccount(tokenAddress, to, tokenAmount, weiAmount, narrative);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold Augmint reserves (ETH & Token)\n', '    - ETH as regular ETH balance of the contract\n', '    - ERC20 token reserve (stored as regular Token balance under the contract address)\n', '\n', 'NB: reserves are held under the contract address, therefore any transaction on the reserve is limited to the\n', '    tx-s defined here (i.e. transfer is not allowed even by the contract owner or StabilityBoard or MonetarySupervisor)\n', '\n', ' */\n', 'contract AugmintReserves is SystemAccount {\n', '\n', '    function () public payable { // solhint-disable-line no-empty-blocks\n', '        // to accept ETH sent into reserve (from defaulted loan&#39;s collateral )\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function burn(AugmintTokenInterface augmintToken, uint amount) external restrict("MonetarySupervisor") {\n', '        augmintToken.burn(amount);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold earned interest from loans repaid\n', '   premiums for locks are being accrued (i.e. transferred) to Locker */\n', 'contract InterestEarnedAccount is SystemAccount {\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function transferInterest(AugmintTokenInterface augmintToken, address locker, uint interestAmount)\n', '    external restrict("MonetarySupervisor") {\n', '        augmintToken.transfer(locker, interestAmount);\n', '    }\n', '\n', '}\n', '\n', '\n', '/* MonetarySupervisor\n', '    - maintains system wide KPIs (eg totalLockAmount, totalLoanAmount)\n', '    - holds system wide parameters/limits\n', '    - enforces system wide limits\n', '    - burns and issues to AugmintReserves\n', '    - Send funds from reserve to exchange when intervening (not implemented yet)\n', '    - Converts older versions of AugmintTokens in 1:1 to new\n', '*/\n', 'contract MonetarySupervisor is Restricted, TokenReceiver { // solhint-disable-line no-empty-blocks\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant PERCENT_100 = 1000000;\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    InterestEarnedAccount public interestEarnedAccount;\n', '    AugmintReserves public augmintReserves;\n', '\n', '    uint public issuedByStabilityBoard; // token issued  by Stability Board\n', '\n', '    uint public totalLoanAmount; // total amount of all loans without interest, in token\n', '    uint public totalLockedAmount; // total amount of all locks without premium, in token\n', '\n', '    /**********\n', '        Parameters to ensure totalLoanAmount or totalLockedAmount difference is within limits and system also works\n', '        when total loan or lock amounts are low.\n', '            for test calculations: https://docs.google.com/spreadsheets/d/1MeWYPYZRIm1n9lzpvbq8kLfQg1hhvk5oJY6NrR401S0\n', '    **********/\n', '    struct LtdParams {\n', '        uint  lockDifferenceLimit; /* only allow a new lock if Loan To Deposit ratio would stay above\n', '                                            (1 - lockDifferenceLimit) with new lock. Stored as parts per million */\n', '        uint  loanDifferenceLimit; /* only allow a new loan if Loan To Deposit ratio would stay above\n', '                                            (1 + loanDifferenceLimit) with new loan. Stored as parts per million */\n', '        /* allowedDifferenceAmount param is to ensure the system is not "freezing" when totalLoanAmount or\n', '            totalLockAmount is low.\n', '        It allows a new loan or lock (up to an amount to reach this difference) even if LTD will go below / above\n', '            lockDifferenceLimit / loanDifferenceLimit with the new lock/loan */\n', '        uint  allowedDifferenceAmount;\n', '    }\n', '\n', '    LtdParams public ltdParams;\n', '\n', '    /* Previously deployed AugmintTokens which are accepted for conversion (see transferNotification() )\n', '        NB: it&#39;s not iterable so old version addresses needs to be added for UI manually after each deploy */\n', '    mapping(address => bool) public acceptedLegacyAugmintTokens;\n', '\n', '    event LtdParamsChanged(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount);\n', '\n', '    event AcceptedLegacyAugmintTokenChanged(address augmintTokenAddress, bool newAcceptedState);\n', '\n', '    event LegacyTokenConverted(address oldTokenAddress, address account, uint amount);\n', '\n', '    event KPIsAdjusted(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment);\n', '\n', '    event SystemContractsChanged(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, AugmintReserves _augmintReserves,\n', '        InterestEarnedAccount _interestEarnedAccount,\n', '        uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        augmintReserves = _augmintReserves;\n', '        interestEarnedAccount = _interestEarnedAccount;\n', '\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    function issueToReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.add(amount);\n', '        augmintToken.issueTo(augmintReserves, amount);\n', '    }\n', '\n', '    function burnFromReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.sub(amount);\n', '        augmintReserves.burn(augmintToken, amount);\n', '    }\n', '\n', '    /* Locker requesting interest when locking funds. Enforcing LTD to stay within range allowed by LTD params\n', '        NB: it does not know about min loan amount, it&#39;s the loan contract&#39;s responsibility to enforce it  */\n', '    function requestInterest(uint amountToLock, uint interestAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        require(amountToLock <= getMaxLockAmountAllowedByLtd(), "amountToLock must be <= maxLockAmountAllowedByLtd");\n', '\n', '        totalLockedAmount = totalLockedAmount.add(amountToLock);\n', '        // next line would revert but require to emit reason:\n', '        require(augmintToken.balanceOf(address(interestEarnedAccount)) >= interestAmount,\n', '            "interestEarnedAccount balance must be >= interestAmount");\n', '        interestEarnedAccount.transferInterest(augmintToken, msg.sender, interestAmount); // transfer interest to Locker\n', '    }\n', '\n', '    // Locker notifying when releasing funds to update KPIs\n', '    function releaseFundsNotification(uint lockedAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        totalLockedAmount = totalLockedAmount.sub(lockedAmount);\n', '    }\n', '\n', '    /* Issue loan if LTD stays within range allowed by LTD params\n', '        NB: it does not know about min loan amount, it&#39;s the loan contract&#39;s responsibility to enforce it */\n', '    function issueLoan(address borrower, uint loanAmount) external {\n', '         // only whitelisted LoanManager contracts\n', '        require(permissions[msg.sender]["LoanManager"],\n', '            "msg.sender must have LoanManager permission");\n', '        require(loanAmount <= getMaxLoanAmountAllowedByLtd(), "loanAmount must be <= maxLoanAmountAllowedByLtd");\n', '        totalLoanAmount = totalLoanAmount.add(loanAmount);\n', '        augmintToken.issueTo(borrower, loanAmount);\n', '    }\n', '\n', '    function loanRepaymentNotification(uint loanAmount) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(loanAmount);\n', '    }\n', '\n', '    // NB: this is called by Lender contract with the sum of all loans collected in batch\n', '    function loanCollectionNotification(uint totalLoanAmountCollected) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(totalLoanAmountCollected);\n', '    }\n', '\n', '    function setAcceptedLegacyAugmintToken(address legacyAugmintTokenAddress, bool newAcceptedState)\n', '    external restrict("StabilityBoard") {\n', '        acceptedLegacyAugmintTokens[legacyAugmintTokenAddress] = newAcceptedState;\n', '        emit AcceptedLegacyAugmintTokenChanged(legacyAugmintTokenAddress, newAcceptedState);\n', '    }\n', '\n', '    function setLtdParams(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    external restrict("StabilityBoard") {\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '\n', '        emit LtdParamsChanged(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    /* function to migrate old totalLoanAmount and totalLockedAmount from old monetarySupervisor contract\n', '        when it&#39;s upgraded.\n', '        Set new monetarySupervisor contract in all locker and loanManager contracts before executing this */\n', '    function adjustKPIs(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment)\n', '    external restrict("StabilityBoard") {\n', '        totalLoanAmount = totalLoanAmount.add(totalLoanAmountAdjustment);\n', '        totalLockedAmount = totalLockedAmount.add(totalLockedAmountAdjustment);\n', '\n', '        emit KPIsAdjusted(totalLoanAmountAdjustment, totalLockedAmountAdjustment);\n', '    }\n', '\n', '    /* to allow upgrades of InterestEarnedAccount and AugmintReserves contracts. */\n', '    function setSystemContracts(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves)\n', '    external restrict("StabilityBoard") {\n', '        interestEarnedAccount = newInterestEarnedAccount;\n', '        augmintReserves = newAugmintReserves;\n', '        emit SystemContractsChanged(newInterestEarnedAccount, newAugmintReserves);\n', '    }\n', '\n', '    /* User can request to convert their tokens from older AugmintToken versions in 1:1\n', '      transferNotification is called from AugmintToken&#39;s transferAndNotify\n', '     Flow for converting old tokens:\n', '        1) user calls old token contract&#39;s transferAndNotify with the amount to convert,\n', '                addressing the new MonetarySupervisor Contract\n', '        2) transferAndNotify transfers user&#39;s old tokens to the current MonetarySupervisor contract&#39;s address\n', '        3) transferAndNotify calls MonetarySupervisor.transferNotification\n', '        4) MonetarySupervisor checks if old AugmintToken is permitted\n', '        5) MonetarySupervisor issues new tokens to user&#39;s account in current AugmintToken\n', '        6) MonetarySupervisor burns old tokens from own balance\n', '    */\n', '    function transferNotification(address from, uint amount, uint /* data, not used */ ) external {\n', '        AugmintTokenInterface legacyToken = AugmintTokenInterface(msg.sender);\n', '        require(acceptedLegacyAugmintTokens[legacyToken], "msg.sender must be allowed in acceptedLegacyAugmintTokens");\n', '\n', '        legacyToken.burn(amount);\n', '        augmintToken.issueTo(from, amount);\n', '        emit LegacyTokenConverted(msg.sender, from, amount);\n', '    }\n', '\n', '    function getLoanToDepositRatio() external view returns (uint loanToDepositRatio) {\n', '        loanToDepositRatio = totalLockedAmount == 0 ? 0 : totalLockedAmount.mul(PERCENT_100).div(totalLoanAmount);\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max lock amount based on minLockAmount, interestPt, using LTD params & interestEarnedAccount balance */\n', '    function getMaxLockAmount(uint minLockAmount, uint interestPt) external view returns (uint maxLock) {\n', '        uint allowedByEarning = augmintToken.balanceOf(address(interestEarnedAccount)).mul(PERCENT_100).div(interestPt);\n', '        uint allowedByLtd = getMaxLockAmountAllowedByLtd();\n', '        maxLock = allowedByEarning < allowedByLtd ? allowedByEarning : allowedByLtd;\n', '        maxLock = maxLock < minLockAmount ? 0 : maxLock;\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max loan amount based on minLoanAmont using LTD params */\n', '    function getMaxLoanAmount(uint minLoanAmount) external view returns (uint maxLoan) {\n', '        uint allowedByLtd = getMaxLoanAmountAllowedByLtd();\n', '        maxLoan = allowedByLtd < minLoanAmount ? 0 : allowedByLtd;\n', '    }\n', '\n', '    /* returns maximum lockable token amount allowed by LTD params. */\n', '    function getMaxLockAmountAllowedByLtd() public view returns(uint maxLockByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLoanAmount.mul(PERCENT_100).div(PERCENT_100\n', '                                            .sub(ltdParams.lockDifferenceLimit));\n', '        allowedByLtdDifferencePt = totalLockedAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLockedAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLockedAmount >= totalLoanAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLoanAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLockedAmount);\n', '\n', '        maxLockByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '    /* returns maximum borrowable token amount allowed by LTD params */\n', '    function getMaxLoanAmountAllowedByLtd() public view returns(uint maxLoanByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLockedAmount.mul(ltdParams.loanDifferenceLimit.add(PERCENT_100))\n', '                                            .div(PERCENT_100);\n', '        allowedByLtdDifferencePt = totalLoanAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLoanAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLoanAmount >= totalLockedAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLockedAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLoanAmount);\n', '\n', '        maxLoanByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', "        // require(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', "    // NB: using bytes32 rather than the string type because it's cheaper gas-wise:\n", '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '  }\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '\n', '}\n', '\n', 'interface TokenReceiver {\n', '    function transferNotification(address from, uint256 amount, uint data) external;\n', '}\n', '\n', '\n', 'contract AugmintTokenInterface is Restricted, ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    bytes32 public peggedSymbol;\n', '    uint8 public decimals;\n', '\n', '    uint public totalSupply;\n', '    mapping(address => uint256) public balances; // Balances for each account\n', '    mapping(address => mapping (address => uint256)) public allowed; // allowances added with approve()\n', '\n', '    address public stabilityBoardProxy;\n', '    TransferFeeInterface public feeAccount;\n', '    mapping(bytes32 => bool) public delegatedTxHashesUsed; // record txHashes used by delegatedTransfer\n', '\n', '    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event AugmintTransfer(address indexed from, address indexed to, uint amount, string narrative, uint fee);\n', '    event TokenIssued(uint amount);\n', '    event TokenBurned(uint amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function increaseApproval(address spender, uint addedValue) external returns (bool);\n', '    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\n', '\n', '    function issueTo(address to, uint amount) external; // restrict it to "MonetarySupervisor" in impl.;\n', '    function burn(uint amount) external;\n', '\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external;\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external;\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external;\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    function balanceOf(address who) external view returns (uint);\n', '\n', '\n', '}\n', '\n', 'interface TransferFeeInterface {\n', '    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee);\n', '}\n', '\n', '\n', 'contract AugmintToken is AugmintTokenInterface {\n', '\n', '    event FeeAccountChanged(TransferFeeInterface newFeeAccount);\n', '\n', '    constructor(address permissionGranterContract, string _name, string _symbol, bytes32 _peggedSymbol, uint8 _decimals, TransferFeeInterface _feeAccount)\n', '    public Restricted(permissionGranterContract) {\n', '        require(_feeAccount != address(0), "feeAccount must be set");\n', '        require(bytes(_name).length > 0, "name must be set");\n', '        require(bytes(_symbol).length > 0, "symbol must be set");\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        peggedSymbol = _peggedSymbol;\n', '        decimals = _decimals;\n', '\n', '        feeAccount = _feeAccount;\n', '\n', '    }\n', '    function transfer(address to, uint256 amount) external returns (bool) {\n', '        _transfer(msg.sender, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    /* Transfers based on an offline signed transfer instruction. */\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, to, amount, narrative, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, to, amount, narrative);\n', '    }\n', '\n', '    function approve(address _spender, uint256 amount) external returns (bool) {\n', '        require(_spender != 0x0, "spender must be set");\n', '        allowed[msg.sender][_spender] = amount;\n', '        emit Approval(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     ERC20 transferFrom attack protection: https://github.com/DecentLabs/dcm-poc/issues/57\n', '     approve should be called when allowed[_spender] == 0. To increment allowed value is better\n', '     to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '     Based on MonolithDAO Token.sol */\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool) {\n', '        return _increaseApproval(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n', '        _transferFrom(from, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    // Issue tokens. See MonetarySupervisor but as a rule of thumb issueTo is only allowed:\n', '    //      - on new loan (by trusted Lender contracts)\n', '    //      - when converting old tokens using MonetarySupervisor\n', '    //      - strictly to reserve by Stability Board (via MonetarySupervisor)\n', '    function issueTo(address to, uint amount) external restrict("MonetarySupervisor") {\n', '        balances[to] = balances[to].add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '        emit Transfer(0x0, to, amount);\n', '        emit AugmintTransfer(0x0, to, amount, "", 0);\n', '    }\n', '\n', '    // Burn tokens. Anyone can burn from its own account. YOLO.\n', '    // Used by to burn from Augmint reserve or by Lender contract after loan repayment\n', '    function burn(uint amount) external {\n', '        require(balances[msg.sender] >= amount, "balance must be >= amount");\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Transfer(msg.sender, 0x0, amount);\n', '        emit AugmintTransfer(msg.sender, 0x0, amount, "", 0);\n', '    }\n', '\n', '    /* to upgrade feeAccount (eg. for fee calculation changes) */\n', '    function setFeeAccount(TransferFeeInterface newFeeAccount) external restrict("StabilityBoard") {\n', '        feeAccount = newFeeAccount;\n', '        emit FeeAccountChanged(newFeeAccount);\n', '    }\n', '\n', '    /*  transferAndNotify can be used by contracts which require tokens to have only 1 tx (instead of approve + call)\n', '        Eg. repay loan, lock funds, token sell order on exchange\n', '        Reverts on failue:\n', '            - transfer fails\n', '            - if transferNotification fails (callee must revert on failure)\n', "            - if targetContract is an account or targetContract doesn't have neither transferNotification or fallback fx\n", '        TODO: make data param generic bytes (see receiver code attempt in Locker.transferNotification)\n', '    */\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external {\n', '        _transfer(msg.sender, target, amount, "");\n', '\n', '        target.transferNotification(msg.sender, amount, data);\n', '    }\n', '\n', '    /* transferAndNotify based on an  instruction signed offline  */\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, target, amount, data, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, target, amount, "");\n', '        target.transferNotification(from, amount, data);\n', '    }\n', '\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external {\n', '        _transfer(msg.sender, to, amount, narrative);\n', '    }\n', '\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external {\n', '        _transferFrom(from, to, amount, narrative);\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function _checkHashAndTransferExecutorFee(bytes32 txHash, bytes signature, address signer,\n', '                                                uint maxExecutorFeeInToken, uint requestedExecutorFeeInToken) private {\n', '        require(requestedExecutorFeeInToken <= maxExecutorFeeInToken, "requestedExecutorFee must be <= maxExecutorFee");\n', '        require(!delegatedTxHashesUsed[txHash], "txHash already used");\n', '        delegatedTxHashesUsed[txHash] = true;\n', '\n', '        address recovered = ECRecovery.recover(ECRecovery.toEthSignedMessageHash(txHash), signature);\n', '        require(recovered == signer, "invalid signature");\n', '\n', '        _transfer(signer, msg.sender, requestedExecutorFeeInToken, "Delegated transfer fee", 0);\n', '    }\n', '\n', '    function _increaseApproval(address _approver, address _spender, uint _addedValue) private returns (bool) {\n', '        allowed[_approver][_spender] = allowed[_approver][_spender].add(_addedValue);\n', '        emit Approval(_approver, _spender, allowed[_approver][_spender]);\n', '    }\n', '\n', '    function _transferFrom(address from, address to, uint256 amount, string narrative) private {\n', '        require(balances[from] >= amount, "balance must >= amount");\n', '        require(allowed[from][msg.sender] >= amount, "allowance must be >= amount");\n', "        // don't allow 0 transferFrom if no approval:\n", '        require(allowed[from][msg.sender] > 0, "allowance must be >= 0 even with 0 amount");\n', '\n', '        /* NB: fee is deducted from owner. It can result that transferFrom of amount x to fail\n', '                when x + fee is not availale on owner balance */\n', '        _transfer(from, to, amount, narrative);\n', '\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative) private {\n', '        uint fee = feeAccount.calculateTransferFee(from, to, transferAmount);\n', '\n', '        _transfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative, uint fee) private {\n', '        require(to != 0x0, "to must be set");\n', '        uint amountWithFee = transferAmount.add(fee);\n', '        // to emit proper reason instead of failing on from.sub()\n', '        require(balances[from] >= amountWithFee, "balance must be >= amount + transfer fee");\n', '\n', '        if (fee > 0) {\n', '            balances[feeAccount] = balances[feeAccount].add(fee);\n', '            emit Transfer(from, feeAccount, fee);\n', '        }\n', '\n', '        balances[from] = balances[from].sub(amountWithFee);\n', '        balances[to] = balances[to].add(transferAmount);\n', '\n', '        emit Transfer(from, to, transferAmount);\n', '        emit AugmintTransfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '}\n', '\n', 'contract SystemAccount is Restricted {\n', '    event WithdrawFromSystemAccount(address tokenAddress, address to, uint tokenAmount, uint weiAmount,\n', '                                    string narrative);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    /* TODO: this is only for first pilots to avoid funds stuck in contract due to bugs.\n', '      remove this function for higher volume pilots */\n', '    function withdraw(AugmintToken tokenAddress, address to, uint tokenAmount, uint weiAmount, string narrative)\n', '    external restrict("StabilityBoard") {\n', '        tokenAddress.transferWithNarrative(to, tokenAmount, narrative);\n', '        if (weiAmount > 0) {\n', '            to.transfer(weiAmount);\n', '        }\n', '\n', '        emit WithdrawFromSystemAccount(tokenAddress, to, tokenAmount, weiAmount, narrative);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold Augmint reserves (ETH & Token)\n', '    - ETH as regular ETH balance of the contract\n', '    - ERC20 token reserve (stored as regular Token balance under the contract address)\n', '\n', 'NB: reserves are held under the contract address, therefore any transaction on the reserve is limited to the\n', '    tx-s defined here (i.e. transfer is not allowed even by the contract owner or StabilityBoard or MonetarySupervisor)\n', '\n', ' */\n', 'contract AugmintReserves is SystemAccount {\n', '\n', '    function () public payable { // solhint-disable-line no-empty-blocks\n', "        // to accept ETH sent into reserve (from defaulted loan's collateral )\n", '    }\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function burn(AugmintTokenInterface augmintToken, uint amount) external restrict("MonetarySupervisor") {\n', '        augmintToken.burn(amount);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold earned interest from loans repaid\n', '   premiums for locks are being accrued (i.e. transferred) to Locker */\n', 'contract InterestEarnedAccount is SystemAccount {\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function transferInterest(AugmintTokenInterface augmintToken, address locker, uint interestAmount)\n', '    external restrict("MonetarySupervisor") {\n', '        augmintToken.transfer(locker, interestAmount);\n', '    }\n', '\n', '}\n', '\n', '\n', '/* MonetarySupervisor\n', '    - maintains system wide KPIs (eg totalLockAmount, totalLoanAmount)\n', '    - holds system wide parameters/limits\n', '    - enforces system wide limits\n', '    - burns and issues to AugmintReserves\n', '    - Send funds from reserve to exchange when intervening (not implemented yet)\n', '    - Converts older versions of AugmintTokens in 1:1 to new\n', '*/\n', 'contract MonetarySupervisor is Restricted, TokenReceiver { // solhint-disable-line no-empty-blocks\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant PERCENT_100 = 1000000;\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    InterestEarnedAccount public interestEarnedAccount;\n', '    AugmintReserves public augmintReserves;\n', '\n', '    uint public issuedByStabilityBoard; // token issued  by Stability Board\n', '\n', '    uint public totalLoanAmount; // total amount of all loans without interest, in token\n', '    uint public totalLockedAmount; // total amount of all locks without premium, in token\n', '\n', '    /**********\n', '        Parameters to ensure totalLoanAmount or totalLockedAmount difference is within limits and system also works\n', '        when total loan or lock amounts are low.\n', '            for test calculations: https://docs.google.com/spreadsheets/d/1MeWYPYZRIm1n9lzpvbq8kLfQg1hhvk5oJY6NrR401S0\n', '    **********/\n', '    struct LtdParams {\n', '        uint  lockDifferenceLimit; /* only allow a new lock if Loan To Deposit ratio would stay above\n', '                                            (1 - lockDifferenceLimit) with new lock. Stored as parts per million */\n', '        uint  loanDifferenceLimit; /* only allow a new loan if Loan To Deposit ratio would stay above\n', '                                            (1 + loanDifferenceLimit) with new loan. Stored as parts per million */\n', '        /* allowedDifferenceAmount param is to ensure the system is not "freezing" when totalLoanAmount or\n', '            totalLockAmount is low.\n', '        It allows a new loan or lock (up to an amount to reach this difference) even if LTD will go below / above\n', '            lockDifferenceLimit / loanDifferenceLimit with the new lock/loan */\n', '        uint  allowedDifferenceAmount;\n', '    }\n', '\n', '    LtdParams public ltdParams;\n', '\n', '    /* Previously deployed AugmintTokens which are accepted for conversion (see transferNotification() )\n', "        NB: it's not iterable so old version addresses needs to be added for UI manually after each deploy */\n", '    mapping(address => bool) public acceptedLegacyAugmintTokens;\n', '\n', '    event LtdParamsChanged(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount);\n', '\n', '    event AcceptedLegacyAugmintTokenChanged(address augmintTokenAddress, bool newAcceptedState);\n', '\n', '    event LegacyTokenConverted(address oldTokenAddress, address account, uint amount);\n', '\n', '    event KPIsAdjusted(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment);\n', '\n', '    event SystemContractsChanged(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, AugmintReserves _augmintReserves,\n', '        InterestEarnedAccount _interestEarnedAccount,\n', '        uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        augmintReserves = _augmintReserves;\n', '        interestEarnedAccount = _interestEarnedAccount;\n', '\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    function issueToReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.add(amount);\n', '        augmintToken.issueTo(augmintReserves, amount);\n', '    }\n', '\n', '    function burnFromReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.sub(amount);\n', '        augmintReserves.burn(augmintToken, amount);\n', '    }\n', '\n', '    /* Locker requesting interest when locking funds. Enforcing LTD to stay within range allowed by LTD params\n', "        NB: it does not know about min loan amount, it's the loan contract's responsibility to enforce it  */\n", '    function requestInterest(uint amountToLock, uint interestAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        require(amountToLock <= getMaxLockAmountAllowedByLtd(), "amountToLock must be <= maxLockAmountAllowedByLtd");\n', '\n', '        totalLockedAmount = totalLockedAmount.add(amountToLock);\n', '        // next line would revert but require to emit reason:\n', '        require(augmintToken.balanceOf(address(interestEarnedAccount)) >= interestAmount,\n', '            "interestEarnedAccount balance must be >= interestAmount");\n', '        interestEarnedAccount.transferInterest(augmintToken, msg.sender, interestAmount); // transfer interest to Locker\n', '    }\n', '\n', '    // Locker notifying when releasing funds to update KPIs\n', '    function releaseFundsNotification(uint lockedAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        totalLockedAmount = totalLockedAmount.sub(lockedAmount);\n', '    }\n', '\n', '    /* Issue loan if LTD stays within range allowed by LTD params\n', "        NB: it does not know about min loan amount, it's the loan contract's responsibility to enforce it */\n", '    function issueLoan(address borrower, uint loanAmount) external {\n', '         // only whitelisted LoanManager contracts\n', '        require(permissions[msg.sender]["LoanManager"],\n', '            "msg.sender must have LoanManager permission");\n', '        require(loanAmount <= getMaxLoanAmountAllowedByLtd(), "loanAmount must be <= maxLoanAmountAllowedByLtd");\n', '        totalLoanAmount = totalLoanAmount.add(loanAmount);\n', '        augmintToken.issueTo(borrower, loanAmount);\n', '    }\n', '\n', '    function loanRepaymentNotification(uint loanAmount) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(loanAmount);\n', '    }\n', '\n', '    // NB: this is called by Lender contract with the sum of all loans collected in batch\n', '    function loanCollectionNotification(uint totalLoanAmountCollected) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(totalLoanAmountCollected);\n', '    }\n', '\n', '    function setAcceptedLegacyAugmintToken(address legacyAugmintTokenAddress, bool newAcceptedState)\n', '    external restrict("StabilityBoard") {\n', '        acceptedLegacyAugmintTokens[legacyAugmintTokenAddress] = newAcceptedState;\n', '        emit AcceptedLegacyAugmintTokenChanged(legacyAugmintTokenAddress, newAcceptedState);\n', '    }\n', '\n', '    function setLtdParams(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    external restrict("StabilityBoard") {\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '\n', '        emit LtdParamsChanged(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    /* function to migrate old totalLoanAmount and totalLockedAmount from old monetarySupervisor contract\n', "        when it's upgraded.\n", '        Set new monetarySupervisor contract in all locker and loanManager contracts before executing this */\n', '    function adjustKPIs(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment)\n', '    external restrict("StabilityBoard") {\n', '        totalLoanAmount = totalLoanAmount.add(totalLoanAmountAdjustment);\n', '        totalLockedAmount = totalLockedAmount.add(totalLockedAmountAdjustment);\n', '\n', '        emit KPIsAdjusted(totalLoanAmountAdjustment, totalLockedAmountAdjustment);\n', '    }\n', '\n', '    /* to allow upgrades of InterestEarnedAccount and AugmintReserves contracts. */\n', '    function setSystemContracts(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves)\n', '    external restrict("StabilityBoard") {\n', '        interestEarnedAccount = newInterestEarnedAccount;\n', '        augmintReserves = newAugmintReserves;\n', '        emit SystemContractsChanged(newInterestEarnedAccount, newAugmintReserves);\n', '    }\n', '\n', '    /* User can request to convert their tokens from older AugmintToken versions in 1:1\n', "      transferNotification is called from AugmintToken's transferAndNotify\n", '     Flow for converting old tokens:\n', "        1) user calls old token contract's transferAndNotify with the amount to convert,\n", '                addressing the new MonetarySupervisor Contract\n', "        2) transferAndNotify transfers user's old tokens to the current MonetarySupervisor contract's address\n", '        3) transferAndNotify calls MonetarySupervisor.transferNotification\n', '        4) MonetarySupervisor checks if old AugmintToken is permitted\n', "        5) MonetarySupervisor issues new tokens to user's account in current AugmintToken\n", '        6) MonetarySupervisor burns old tokens from own balance\n', '    */\n', '    function transferNotification(address from, uint amount, uint /* data, not used */ ) external {\n', '        AugmintTokenInterface legacyToken = AugmintTokenInterface(msg.sender);\n', '        require(acceptedLegacyAugmintTokens[legacyToken], "msg.sender must be allowed in acceptedLegacyAugmintTokens");\n', '\n', '        legacyToken.burn(amount);\n', '        augmintToken.issueTo(from, amount);\n', '        emit LegacyTokenConverted(msg.sender, from, amount);\n', '    }\n', '\n', '    function getLoanToDepositRatio() external view returns (uint loanToDepositRatio) {\n', '        loanToDepositRatio = totalLockedAmount == 0 ? 0 : totalLockedAmount.mul(PERCENT_100).div(totalLoanAmount);\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max lock amount based on minLockAmount, interestPt, using LTD params & interestEarnedAccount balance */\n', '    function getMaxLockAmount(uint minLockAmount, uint interestPt) external view returns (uint maxLock) {\n', '        uint allowedByEarning = augmintToken.balanceOf(address(interestEarnedAccount)).mul(PERCENT_100).div(interestPt);\n', '        uint allowedByLtd = getMaxLockAmountAllowedByLtd();\n', '        maxLock = allowedByEarning < allowedByLtd ? allowedByEarning : allowedByLtd;\n', '        maxLock = maxLock < minLockAmount ? 0 : maxLock;\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max loan amount based on minLoanAmont using LTD params */\n', '    function getMaxLoanAmount(uint minLoanAmount) external view returns (uint maxLoan) {\n', '        uint allowedByLtd = getMaxLoanAmountAllowedByLtd();\n', '        maxLoan = allowedByLtd < minLoanAmount ? 0 : allowedByLtd;\n', '    }\n', '\n', '    /* returns maximum lockable token amount allowed by LTD params. */\n', '    function getMaxLockAmountAllowedByLtd() public view returns(uint maxLockByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLoanAmount.mul(PERCENT_100).div(PERCENT_100\n', '                                            .sub(ltdParams.lockDifferenceLimit));\n', '        allowedByLtdDifferencePt = totalLockedAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLockedAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLockedAmount >= totalLoanAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLoanAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLockedAmount);\n', '\n', '        maxLockByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '    /* returns maximum borrowable token amount allowed by LTD params */\n', '    function getMaxLoanAmountAllowedByLtd() public view returns(uint maxLoanByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLockedAmount.mul(ltdParams.loanDifferenceLimit.add(PERCENT_100))\n', '                                            .div(PERCENT_100);\n', '        allowedByLtdDifferencePt = totalLoanAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLoanAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLoanAmount >= totalLockedAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLockedAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLoanAmount);\n', '\n', '        maxLoanByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '}']
