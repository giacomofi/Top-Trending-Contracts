['pragma solidity 0.4.19;\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/DisbursementHandler.sol\n', '\n', '/// @title Disbursement handler - Manages time locked disbursements of ERC20 tokens\n', 'contract DisbursementHandler is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Disbursement {\n', '        // Tokens cannot be withdrawn before this timestamp\n', '        uint256 timestamp;\n', '\n', '        // Amount of tokens to be disbursed\n', '        uint256 tokens;\n', '    }\n', '\n', '    event LogSetup(address indexed vestor, uint256 timestamp, uint256 tokens);\n', '    event LogWithdraw(address indexed to, uint256 value);\n', '\n', '    ERC20 public token;\n', '    uint256 public totalAmount;\n', '    mapping(address => Disbursement[]) public disbursements;\n', '    mapping(address => uint256) public withdrawnTokens;\n', '\n', '    function DisbursementHandler(address _token) public {\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    /// @dev Called by the sale contract to create a disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param tokens Amount of tokens to be locked.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    function setupDisbursement(\n', '        address vestor,\n', '        uint256 tokens,\n', '        uint256 timestamp\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        disbursements[vestor].push(Disbursement(timestamp, tokens));\n', '        totalAmount = totalAmount.add(tokens);\n', '        LogSetup(vestor, timestamp, tokens);\n', '    }\n', '\n', '    /// @dev Transfers tokens to the withdrawer\n', '    function withdraw()\n', '        external\n', '    {\n', '        uint256 withdrawAmount = calcMaxWithdraw(msg.sender);\n', '        require(withdrawAmount != 0);\n', '        withdrawnTokens[msg.sender] = withdrawnTokens[msg.sender].add(withdrawAmount);\n', '        require(token.transfer(msg.sender, withdrawAmount));\n', '        LogWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /// @dev Calculates the maximum amount of vested tokens\n', '    /// @return Number of vested tokens that can be withdrawn\n', '    function calcMaxWithdraw(address beneficiary)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 maxTokens = 0;\n', '\n', '        // Go over all the disbursements and calculate how many tokens can be withdrawn\n', '        Disbursement[] storage temp = disbursements[beneficiary];\n', '        uint256 tempLength = temp.length;\n', '        for (uint256 i = 0; i < tempLength; i++) {\n', '            if (block.timestamp > temp[i].timestamp) {\n', '                maxTokens = maxTokens.add(temp[i].tokens);\n', '            }\n', '        }\n', '\n', '        // Return the computed amount minus the tokens already withdrawn\n', '        return maxTokens.sub(withdrawnTokens[beneficiary]);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Vault.sol\n', '\n', '// Adapted from Open Zeppelin&#39;s RefundVault\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Success, Refunding, Closed }\n', '\n', '    uint256 public constant DISBURSEMENT_DURATION = 4 weeks;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    uint256 public disbursementAmount; // The amount to be disbursed to the wallet every month\n', '    address public trustedWallet; // Wallet from the project team\n', '\n', '    uint256 public initialAmount; // The eth amount the team will get initially if the sale is successful\n', '\n', '    uint256 public lastDisbursement; // Timestamp of the last disbursement made\n', '\n', '    uint256 public totalDeposited; // Total amount that was deposited\n', '    uint256 public refundable; // Amount that can be refunded\n', '\n', '    uint256 public closingDuration;\n', '    uint256 public closingDeadline; // Vault can&#39;t be closed before this deadline\n', '\n', '    State public state;\n', '\n', '    event LogClosed();\n', '    event LogRefundsEnabled();\n', '    event LogRefunded(address indexed contributor, uint256 amount);\n', '\n', '    modifier atState(State _state) {\n', '        require(state == _state);\n', '        _;\n', '    }\n', '\n', '    function Vault(\n', '        address wallet,\n', '        uint256 _initialAmount,\n', '        uint256 _disbursementAmount,\n', '        uint256 _closingDuration\n', '    ) \n', '        public \n', '    {\n', '        require(wallet != address(0));\n', '        require(_disbursementAmount != 0);\n', '        require(_closingDuration != 0);\n', '        trustedWallet = wallet;\n', '        initialAmount = _initialAmount;\n', '        disbursementAmount = _disbursementAmount;\n', '        closingDuration = _closingDuration;\n', '        state = State.Active;\n', '    }\n', '\n', '    /// @dev Called by the sale contract to deposit ether for a contributor.\n', '    function deposit(address contributor) onlyOwner external payable {\n', '        require(state == State.Active || state == State.Success);\n', '        totalDeposited = totalDeposited.add(msg.value);\n', '        refundable = refundable.add(msg.value);\n', '        deposited[contributor] = deposited[contributor].add(msg.value);\n', '    }\n', '\n', '    /// @dev Sends initial funds to the wallet.\n', '    function saleSuccessful() onlyOwner external atState(State.Active){\n', '        state = State.Success;\n', '        refundable = refundable.sub(initialAmount);\n', '        if (initialAmount != 0) {\n', '          trustedWallet.transfer(initialAmount);\n', '        }\n', '    }\n', '\n', '    /// @dev Called by the owner if the project didn&#39;t deliver the testnet contracts or if we need to stop disbursements for any reasone.\n', '    function enableRefunds() onlyOwner external {\n', '        state = State.Refunding;\n', '        LogRefundsEnabled();\n', '    }\n', '\n', '    /// @dev Refunds ether to the contributors if in the Refunding state.\n', '    function refund(address contributor) external atState(State.Refunding) {\n', '        uint256 refundAmount = deposited[contributor].mul(refundable).div(totalDeposited);\n', '        deposited[contributor] = 0;\n', '        contributor.transfer(refundAmount);\n', '        LogRefunded(contributor, refundAmount);\n', '    }\n', '\n', '    /// @dev Sets the closingDeadline variable\n', '    function beginClosingPeriod() external onlyOwner atState(State.Success) {\n', '        require(closingDeadline == 0);\n', '        closingDeadline = now.add(closingDuration);\n', '    }\n', '\n', '    /// @dev Called by anyone if the sale was successful and the project delivered.\n', '    function close() external atState(State.Success) {\n', '        require(closingDeadline != 0 && closingDeadline <= now);\n', '        state = State.Closed;\n', '        LogClosed();\n', '    }\n', '\n', '    /// @dev Sends the disbursement amount to the wallet after the disbursement period has passed. Can be called by anyone.\n', '    function sendFundsToWallet() external atState(State.Closed) {\n', '        require(lastDisbursement.add(DISBURSEMENT_DURATION) <= now);\n', '\n', '        lastDisbursement = now;\n', '        uint256 amountToSend = Math.min256(address(this).balance, disbursementAmount);\n', '        refundable = refundable.sub(amountToSend);\n', '        trustedWallet.transfer(amountToSend);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev This contract is used to implement a signature based whitelisting mechanism\n', ' */\n', 'contract Whitelistable is Ownable {\n', '    bytes constant PREFIX = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    address public whitelistAdmin;\n', '\n', '    // addresses map to false by default\n', '    mapping(address => bool) public blacklist;\n', '\n', '    event LogAdminUpdated(address indexed newAdmin);\n', '\n', '    modifier validAdmin(address _admin) {\n', '        require(_admin != 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == whitelistAdmin);\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor for Whitelistable contract\n', '    /// @param _admin the address of the admin that will generate the signatures\n', '    function Whitelistable(address _admin) public validAdmin(_admin) {\n', '        whitelistAdmin = _admin;        \n', '    }\n', '\n', '    /// @dev Updates whitelistAdmin address \n', '    /// @dev Can only be called by the current owner\n', '    /// @param _admin the new admin address\n', '    function changeAdmin(address _admin)\n', '        external\n', '        onlyOwner\n', '        validAdmin(_admin)\n', '    {\n', '        LogAdminUpdated(_admin);\n', '        whitelistAdmin = _admin;\n', '    }\n', '\n', '    // @dev blacklists the given address to ban them from contributing\n', '    // @param _contributor Address of the contributor to blacklist \n', '    function addToBlacklist(address _contributor)\n', '        external\n', '        onlyAdmin\n', '    {\n', '        blacklist[_contributor] = true;\n', '    }\n', '\n', '    // @dev removes a previously blacklisted contributor from the blacklist\n', '    // @param _contributor Address of the contributor remove \n', '    function removeFromBlacklist(address _contributor)\n', '        external\n', '        onlyAdmin\n', '    {\n', '        blacklist[_contributor] = false;\n', '    }\n', '\n', '    /// @dev Checks if contributor is whitelisted (main Whitelistable function)\n', '    /// @param contributor Address of who was whitelisted\n', '    /// @param contributionLimit Limit for the user contribution\n', '    /// @param currentSaleCap Cap of contributions to the sale at the current point in time\n', '    /// @param v Recovery id\n', '    /// @param r Component of the ECDSA signature\n', '    /// @param s Component of the ECDSA signature\n', '    /// @return Is the signature correct?\n', '    function checkWhitelisted(\n', '        address contributor,\n', '        uint256 contributionLimit,\n', '        uint256 currentSaleCap,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public view returns(bool) {\n', '        bytes32 prefixed = keccak256(PREFIX, keccak256(contributor, contributionLimit, currentSaleCap));\n', '        return !(blacklist[contributor]) && (whitelistAdmin == ecrecover(prefixed, v, r, s));\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/StateMachine.sol\n', '\n', 'contract StateMachine {\n', '\n', '    struct State { \n', '        bytes32 nextStateId;\n', '        mapping(bytes4 => bool) allowedFunctions;\n', '        function() internal[] transitionCallbacks;\n', '        function(bytes32) internal returns(bool)[] startConditions;\n', '    }\n', '\n', '    mapping(bytes32 => State) states;\n', '\n', '    // The current state id\n', '    bytes32 private currentStateId;\n', '\n', '    event LogTransition(bytes32 stateId, uint256 blockNumber);\n', '\n', '    /* This modifier performs the conditional transitions and checks that the function \n', '     * to be executed is allowed in the current State\n', '     */\n', '    modifier checkAllowed {\n', '        conditionalTransitions();\n', '        require(states[currentStateId].allowedFunctions[msg.sig]);\n', '        _;\n', '    }\n', '\n', '    ///@dev transitions the state machine into the state it should currently be in\n', '    ///@dev by taking into account the current conditions and how many further transitions can occur \n', '    function conditionalTransitions() public {\n', '\n', '        bytes32 next = states[currentStateId].nextStateId;\n', '        bool stateChanged;\n', '\n', '        while (next != 0) {\n', '            // If one of the next state&#39;s conditions is met, go to this state and continue\n', '            stateChanged = false;\n', '            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n', '                if (states[next].startConditions[i](next)) {\n', '                    goToNextState();\n', '                    next = states[next].nextStateId;\n', '                    stateChanged = true;\n', '                    break;\n', '                }\n', '            }\n', '            // If none of the next state&#39;s conditions are met, then we are in the right current state\n', '            if (!stateChanged) break;\n', '        }\n', '    }\n', '\n', '    function getCurrentStateId() view public returns(bytes32) {\n', '        return currentStateId;\n', '    }\n', '\n', '\n', '    /// @dev Setup the state machine with the given states.\n', '    /// @param _stateIds Array of state ids.\n', '    function setStates(bytes32[] _stateIds) internal {\n', '        require(_stateIds.length > 0);\n', '        require(currentStateId == 0);\n', '\n', '        require(_stateIds[0] != 0);\n', '\n', '        currentStateId = _stateIds[0];\n', '\n', '        for (uint256 i = 1; i < _stateIds.length; i++) {\n', '            require(_stateIds[i] != 0);\n', '\n', '            states[_stateIds[i - 1]].nextStateId = _stateIds[i];\n', '\n', '            // Check that the state appears only once in the array\n', '            require(states[_stateIds[i]].nextStateId == 0);\n', '        }\n', '    }\n', '\n', '    /// @dev Allow a function in the given state.\n', '    /// @param _stateId The id of the state\n', '    /// @param _functionSelector A function selector (bytes4[keccak256(functionSignature)])\n', '    function allowFunction(bytes32 _stateId, bytes4 _functionSelector) internal {\n', '        states[_stateId].allowedFunctions[_functionSelector] = true;\n', '    }\n', '\n', '    /// @dev Goes to the next state if possible (if the next state is valid)\n', '    function goToNextState() internal {\n', '        bytes32 next = states[currentStateId].nextStateId;\n', '        require(next != 0);\n', '\n', '        currentStateId = next;\n', '        for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\n', '            states[next].transitionCallbacks[i]();\n', '        }\n', '\n', '        LogTransition(next, block.number);\n', '    }\n', '\n', '    ///@dev add a function returning a boolean as a start condition for a state\n', '    ///@param _stateId The ID of the state to add the condition for\n', '    ///@param _condition Start condition function - returns true if a start condition (for a given state ID) is met\n', '    function addStartCondition(bytes32 _stateId, function(bytes32) internal returns(bool) _condition) internal {\n', '        states[_stateId].startConditions.push(_condition);\n', '    }\n', '\n', '    ///@dev add a callback function for a state\n', '    ///@param _stateId The ID of the state to add a callback function for\n', '    ///@param _callback The callback function to add\n', '    function addCallback(bytes32 _stateId, function() internal _callback) internal {\n', '        states[_stateId].transitionCallbacks.push(_callback);\n', '    }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/TimedStateMachine.sol\n', '\n', '/// @title A contract that implements the state machine pattern and adds time dependant transitions.\n', 'contract TimedStateMachine is StateMachine {\n', '\n', '    event LogSetStateStartTime(bytes32 indexed _stateId, uint256 _startTime);\n', '\n', '    // Stores the start timestamp for each state (the value is 0 if the state doesn&#39;t have a start timestamp).\n', '    mapping(bytes32 => uint256) private startTime;\n', '\n', '    /// @dev Returns the timestamp for the given state id.\n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\n', '        return startTime[_stateId];\n', '    }\n', '\n', '    /// @dev Sets the starting timestamp for a state.\n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    /// @param _timestamp The start timestamp for the given state. It should be bigger than the current one.\n', '    function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\n', '        require(block.timestamp < _timestamp);\n', '\n', '        if (startTime[_stateId] == 0) {\n', '            addStartCondition(_stateId, hasStartTimePassed);\n', '        }\n', '\n', '        startTime[_stateId] = _timestamp;\n', '\n', '        LogSetStateStartTime(_stateId, _timestamp);\n', '    }\n', '\n', '    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n', '        return startTime[_stateId] <= block.timestamp;\n', '    }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/TokenControllerI.sol\n', '\n', '/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\n', 'contract TokenControllerI {\n', '\n', '    /// @dev Specifies whether a transfer is allowed or not.\n', '    /// @return True if the transfer is allowed\n', '    function transferAllowed(address _from, address _to) external view returns (bool);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '   * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/ControllableToken.sol\n', '\n', '/**\n', ' * @title Controllable ERC20 token\n', ' *\n', ' * @dev Token that queries a token controller contract to check if a transfer is allowed.\n', ' * @dev controller state var is going to be set with the address of a TokenControllerI contract that has \n', ' * implemented transferAllowed() function.\n', ' */\n', 'contract ControllableToken is Ownable, StandardToken {\n', '    TokenControllerI public controller;\n', '\n', '    /// @dev Executes transferAllowed() function from the Controller. \n', '    modifier isAllowed(address _from, address _to) {\n', '        require(controller.transferAllowed(_from, _to));\n', '        _;\n', '    }\n', '\n', '    /// @dev Sets the controller that is going to be used by isAllowed modifier\n', '    function setController(TokenControllerI _controller) onlyOwner public {\n', '        require(_controller != address(0));\n', '        controller = _controller;\n', '    }\n', '\n', '    /// @dev It calls parent BasicToken.transfer() function. It will transfer an amount of tokens to an specific address\n', '    /// @return True if the token is transfered with success\n', '    function transfer(address _to, uint256 _value) isAllowed(msg.sender, _to) public returns (bool) {        \n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @dev It calls parent StandardToken.transferFrom() function. It will transfer from an address a certain amount of tokens to another address \n', '    /// @return True if the token is transfered with success \n', '    function transferFrom(address _from, address _to, uint256 _value) isAllowed(_from, _to) public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/Token.sol\n', '\n', '/**\n', ' * @title Token base contract - Defines basic structure for a token\n', ' *\n', ' * @dev ControllableToken is a StandardToken, an OpenZeppelin ERC20 implementation library. DetailedERC20 is also an OpenZeppelin contract.\n', ' * More info about them is available here: https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\n', ' */\n', 'contract Token is ControllableToken, DetailedERC20 {\n', '\n', '\t/**\n', '\t* @dev Transfer is an event inherited from ERC20Basic.sol interface (OpenZeppelin).\n', '\t* @param _supply Total supply of tokens.\n', '    * @param _name Is the long name by which the token contract should be known\n', '    * @param _symbol The set of capital letters used to represent the token e.g. DTH.\n', '    * @param _decimals The number of decimal places the tokens can be split up into. This should be between 0 and 18.\n', '\t*/\n', '    function Token(\n', '        uint256 _supply,\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals\n', '    ) DetailedERC20(_name, _symbol, _decimals) public {\n', '        require(_supply != 0);\n', '        totalSupply_ = _supply;\n', '        balances[msg.sender] = _supply;\n', '        Transfer(address(0), msg.sender, _supply);  //event\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Sale.sol\n', '\n', '/// @title Sale base contract\n', 'contract Sale is Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\n', '    using SafeMath for uint256;\n', '\n', '    // State machine states\n', '    bytes32 private constant SETUP = &#39;setup&#39;;\n', '    bytes32 private constant FREEZE = &#39;freeze&#39;;\n', '    bytes32 private constant SALE_IN_PROGRESS = &#39;saleInProgress&#39;;\n', '    bytes32 private constant SALE_ENDED = &#39;saleEnded&#39;;\n', '    bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\n', '\n', '    // Stores the contribution for each user\n', '    mapping(address => uint256) public contributions;\n', '    // Records which users have contributed throughout the sale\n', '    mapping(address => bool) public hasContributed;\n', '\n', '    DisbursementHandler public disbursementHandler;\n', '\n', '    uint256 public weiContributed = 0;\n', '    uint256 public totalSaleCap;\n', '    uint256 public minContribution;\n', '    uint256 public minThreshold;\n', '\n', '    // How many tokens a user will receive per each wei contributed\n', '    uint256 public tokensPerWei;\n', '    uint256 public tokensForSale;\n', '\n', '    Token public trustedToken;\n', '    Vault public trustedVault;\n', '\n', '    event LogContribution(address indexed contributor, uint256 value, uint256 excess);\n', '    event LogTokensAllocated(address indexed contributor, uint256 amount);\n', '\n', '    function Sale(\n', '        uint256 _totalSaleCap,\n', '        uint256 _minContribution,\n', '        uint256 _minThreshold,\n', '        uint256 _maxTokens,\n', '        address _whitelistAdmin,\n', '        address _wallet,\n', '        uint256 _closingDuration,\n', '        uint256 _vaultInitialAmount,\n', '        uint256 _vaultDisbursementAmount,\n', '        uint256 _startTime,\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals\n', '    ) \n', '        Whitelistable(_whitelistAdmin)\n', '        public \n', '    {\n', '        require(_totalSaleCap != 0);\n', '        require(_maxTokens != 0);\n', '        require(_wallet != 0);\n', '        require(_minThreshold <= _totalSaleCap);\n', '        require(_vaultInitialAmount <= _minThreshold);\n', '        require(now < _startTime);\n', '\n', '        totalSaleCap = _totalSaleCap;\n', '        minContribution = _minContribution;\n', '        minThreshold = _minThreshold;\n', '\n', '        // Setup the necessary contracts\n', '        trustedToken = new Token(_maxTokens, _tokenName, _tokenSymbol, _tokenDecimals);\n', '        disbursementHandler = new DisbursementHandler(trustedToken);\n', '\n', '        trustedToken.setController(this);\n', '\n', '        trustedVault = new Vault(\n', '            _wallet,\n', '            _vaultInitialAmount,\n', '            _vaultDisbursementAmount, // disbursement amount\n', '            _closingDuration\n', '        );\n', '\n', '        // Set the states\n', '        setStates(states);\n', '\n', '        allowFunction(SETUP, this.setup.selector);\n', '        allowFunction(FREEZE, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\n', '        allowFunction(SALE_ENDED, this.allocateTokens.selector);\n', '\n', '        // End the sale when the cap is reached\n', '        addStartCondition(SALE_ENDED, wasCapReached);\n', '\n', '        // Set the onSaleEnded callback (will be called when the sale ends)\n', '        addCallback(SALE_ENDED, onSaleEnded);\n', '\n', '        // Set the start and end times for the sale\n', '        setStateStartTime(SALE_IN_PROGRESS, _startTime);\n', '    }\n', '\n', '    /// @dev Setup the disbursements and tokens for sale.\n', '    /// @dev This needs to be outside the constructor because the token needs to query the sale for allowed transfers.\n', '    function setup() public onlyOwner checkAllowed {\n', '        require(trustedToken.transfer(disbursementHandler, disbursementHandler.totalAmount()));\n', '        tokensForSale = trustedToken.balanceOf(this);       \n', '        require(tokensForSale >= totalSaleCap);\n', '\n', '        // Go to freeze state\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev Called by users to contribute ETH to the sale.\n', '    function contribute(uint256 contributionLimit, uint256 currentSaleCap, uint8 v, bytes32 r, bytes32 s) \n', '        external \n', '        payable\n', '        checkAllowed \n', '    {\n', '        // Check that the signature is valid\n', '        require(currentSaleCap <= totalSaleCap);\n', '        require(weiContributed < currentSaleCap);\n', '        require(checkWhitelisted(msg.sender, contributionLimit, currentSaleCap, v, r, s));\n', '\n', '        uint256 current = contributions[msg.sender];\n', '        require(current < contributionLimit);\n', '\n', '        // Get the max amount that the user can contribute\n', '        uint256 remaining = Math.min256(contributionLimit.sub(current), currentSaleCap.sub(weiContributed));\n', '\n', '        // Check if it goes over the contribution limit of the user or the eth cap. \n', '        uint256 contribution = Math.min256(msg.value, remaining);\n', '\n', '        // Get the total contribution for the contributor after the previous checks\n', '        uint256 totalContribution = current.add(contribution);\n', '        require(totalContribution >= minContribution);\n', '\n', '        contributions[msg.sender] = totalContribution;\n', '        hasContributed[msg.sender] = true;\n', '\n', '        weiContributed = weiContributed.add(contribution);\n', '\n', '        trustedVault.deposit.value(contribution)(msg.sender);\n', '\n', '        if (weiContributed >= minThreshold && trustedVault.state() != Vault.State.Success) trustedVault.saleSuccessful();\n', '\n', '        // If there is an excess, return it to the user\n', '        uint256 excess = msg.value.sub(contribution);\n', '        if (excess > 0) msg.sender.transfer(excess);\n', '\n', '        LogContribution(msg.sender, contribution, excess);\n', '\n', '        assert(totalContribution <= contributionLimit);\n', '    }\n', '\n', '    /// @dev Sets the end time for the sale\n', '    /// @param _endTime The timestamp at which the sale will end.\n', '    function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\n', '        require(now < _endTime);\n', '        require(getStateStartTime(SALE_ENDED) == 0);\n', '        setStateStartTime(SALE_ENDED, _endTime);\n', '    }\n', '\n', '    /// @dev Called to allocate the tokens depending on eth contributed by the end of the sale.\n', '    /// @param _contributor The address of the contributor.\n', '    function allocateTokens(address _contributor) external checkAllowed {\n', '        require(contributions[_contributor] != 0);\n', '\n', '        // Transfer the respective tokens to the contributor\n', '        uint256 amount = contributions[_contributor].mul(tokensPerWei);\n', '\n', '        // Set contributions to 0\n', '        contributions[_contributor] = 0;\n', '\n', '        require(trustedToken.transfer(_contributor, amount));\n', '\n', '        LogTokensAllocated(_contributor, amount);\n', '    }\n', '\n', '    /// @dev Called to end the sale by the owner. Can only be called in SALE_IN_PROGRESS state\n', '    function endSale() external onlyOwner checkAllowed {\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev Since Sale is TokenControllerI, it has to implement transferAllowed() function\n', '    /// @notice only the Sale and DisbursementHandler can disburse the initial tokens to their future owners\n', '    function transferAllowed(address _from, address) external view returns (bool) {\n', '        return _from == address(this) || _from == address(disbursementHandler);\n', '    }\n', '\n', '    /// @dev Called internally by the sale to setup a disbursement (it has to be called in the constructor of child sales)\n', '    /// param _beneficiary Tokens will be disbursed to this address.\n', '    /// param _amount Number of tokens to be disbursed.\n', '    /// param _duration Tokens will be locked for this long.\n', '    function setupDisbursement(address _beneficiary, uint256 _amount, uint256 _duration) internal {\n', '        require(tokensForSale == 0);\n', '        disbursementHandler.setupDisbursement(_beneficiary, _amount, now.add(_duration));\n', '    }\n', '   \n', '    /// @dev Returns true if the cap was reached.\n', '    function wasCapReached(bytes32) internal returns (bool) {\n', '        return totalSaleCap <= weiContributed;\n', '    }\n', '\n', '    /// @dev Callback that gets called when entering the SALE_ENDED state.\n', '    function onSaleEnded() internal {\n', '        // If the minimum threshold wasn&#39;t reached, enable refunds\n', '        if (weiContributed < minThreshold) {\n', '            trustedVault.enableRefunds();\n', '        } else {\n', '            trustedVault.beginClosingPeriod();\n', '            tokensPerWei = tokensForSale.div(weiContributed);\n', '        }\n', '\n', '        trustedToken.transferOwnership(owner); \n', '        trustedVault.transferOwnership(owner);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/VirtuePokerSale.sol\n', '\n', 'contract VirtuePokerSale is Sale {\n', '\n', '    function VirtuePokerSale() \n', '        Sale(\n', '            25000 ether, // Total sale cap\n', '            1 ether, // Min contribution\n', '            12000 ether, // Min threshold\n', '            500000000 * (10 ** 18), // Max tokens\n', '            0x13ebf15f2e32d05ea944927ef5e6a3cad8187440, // Whitelist Admin\n', '            0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, // Wallet\n', '            28 days, // Closing duration\n', '            12000 ether, // Vault initial amount\n', '            25000 ether, // Vault disbursement amount\n', '            1524218400, // Start time\n', '            "Virtue Player Points", // Token name\n', '            "VPP", // Token symbol\n', '            18 // Token decimals\n', '        )\n', '        public \n', '    {\n', '        // Team Wallet (50,000,000 VPP, 25% per year)\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 4 years);\n', '\n', '        // Company Wallet (250,000,000 VPP, no lock-up)\n', '        setupDisbursement(0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, 250000000 * (10 ** 18), 1 days);\n', '\n', '        // Founder Allocations (total 100,000,000, 12.5% per 6 months)\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 4 years);\n', '\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 4 years);\n', '\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 4 years);\n', '    }\n', '}']
['pragma solidity 0.4.19;\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/DisbursementHandler.sol\n', '\n', '/// @title Disbursement handler - Manages time locked disbursements of ERC20 tokens\n', 'contract DisbursementHandler is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct Disbursement {\n', '        // Tokens cannot be withdrawn before this timestamp\n', '        uint256 timestamp;\n', '\n', '        // Amount of tokens to be disbursed\n', '        uint256 tokens;\n', '    }\n', '\n', '    event LogSetup(address indexed vestor, uint256 timestamp, uint256 tokens);\n', '    event LogWithdraw(address indexed to, uint256 value);\n', '\n', '    ERC20 public token;\n', '    uint256 public totalAmount;\n', '    mapping(address => Disbursement[]) public disbursements;\n', '    mapping(address => uint256) public withdrawnTokens;\n', '\n', '    function DisbursementHandler(address _token) public {\n', '        token = ERC20(_token);\n', '    }\n', '\n', '    /// @dev Called by the sale contract to create a disbursement.\n', '    /// @param vestor The address of the beneficiary.\n', '    /// @param tokens Amount of tokens to be locked.\n', '    /// @param timestamp Funds will be locked until this timestamp.\n', '    function setupDisbursement(\n', '        address vestor,\n', '        uint256 tokens,\n', '        uint256 timestamp\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(block.timestamp < timestamp);\n', '        disbursements[vestor].push(Disbursement(timestamp, tokens));\n', '        totalAmount = totalAmount.add(tokens);\n', '        LogSetup(vestor, timestamp, tokens);\n', '    }\n', '\n', '    /// @dev Transfers tokens to the withdrawer\n', '    function withdraw()\n', '        external\n', '    {\n', '        uint256 withdrawAmount = calcMaxWithdraw(msg.sender);\n', '        require(withdrawAmount != 0);\n', '        withdrawnTokens[msg.sender] = withdrawnTokens[msg.sender].add(withdrawAmount);\n', '        require(token.transfer(msg.sender, withdrawAmount));\n', '        LogWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /// @dev Calculates the maximum amount of vested tokens\n', '    /// @return Number of vested tokens that can be withdrawn\n', '    function calcMaxWithdraw(address beneficiary)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 maxTokens = 0;\n', '\n', '        // Go over all the disbursements and calculate how many tokens can be withdrawn\n', '        Disbursement[] storage temp = disbursements[beneficiary];\n', '        uint256 tempLength = temp.length;\n', '        for (uint256 i = 0; i < tempLength; i++) {\n', '            if (block.timestamp > temp[i].timestamp) {\n', '                maxTokens = maxTokens.add(temp[i].tokens);\n', '            }\n', '        }\n', '\n', '        // Return the computed amount minus the tokens already withdrawn\n', '        return maxTokens.sub(withdrawnTokens[beneficiary]);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Vault.sol\n', '\n', "// Adapted from Open Zeppelin's RefundVault\n", '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Success, Refunding, Closed }\n', '\n', '    uint256 public constant DISBURSEMENT_DURATION = 4 weeks;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    uint256 public disbursementAmount; // The amount to be disbursed to the wallet every month\n', '    address public trustedWallet; // Wallet from the project team\n', '\n', '    uint256 public initialAmount; // The eth amount the team will get initially if the sale is successful\n', '\n', '    uint256 public lastDisbursement; // Timestamp of the last disbursement made\n', '\n', '    uint256 public totalDeposited; // Total amount that was deposited\n', '    uint256 public refundable; // Amount that can be refunded\n', '\n', '    uint256 public closingDuration;\n', "    uint256 public closingDeadline; // Vault can't be closed before this deadline\n", '\n', '    State public state;\n', '\n', '    event LogClosed();\n', '    event LogRefundsEnabled();\n', '    event LogRefunded(address indexed contributor, uint256 amount);\n', '\n', '    modifier atState(State _state) {\n', '        require(state == _state);\n', '        _;\n', '    }\n', '\n', '    function Vault(\n', '        address wallet,\n', '        uint256 _initialAmount,\n', '        uint256 _disbursementAmount,\n', '        uint256 _closingDuration\n', '    ) \n', '        public \n', '    {\n', '        require(wallet != address(0));\n', '        require(_disbursementAmount != 0);\n', '        require(_closingDuration != 0);\n', '        trustedWallet = wallet;\n', '        initialAmount = _initialAmount;\n', '        disbursementAmount = _disbursementAmount;\n', '        closingDuration = _closingDuration;\n', '        state = State.Active;\n', '    }\n', '\n', '    /// @dev Called by the sale contract to deposit ether for a contributor.\n', '    function deposit(address contributor) onlyOwner external payable {\n', '        require(state == State.Active || state == State.Success);\n', '        totalDeposited = totalDeposited.add(msg.value);\n', '        refundable = refundable.add(msg.value);\n', '        deposited[contributor] = deposited[contributor].add(msg.value);\n', '    }\n', '\n', '    /// @dev Sends initial funds to the wallet.\n', '    function saleSuccessful() onlyOwner external atState(State.Active){\n', '        state = State.Success;\n', '        refundable = refundable.sub(initialAmount);\n', '        if (initialAmount != 0) {\n', '          trustedWallet.transfer(initialAmount);\n', '        }\n', '    }\n', '\n', "    /// @dev Called by the owner if the project didn't deliver the testnet contracts or if we need to stop disbursements for any reasone.\n", '    function enableRefunds() onlyOwner external {\n', '        state = State.Refunding;\n', '        LogRefundsEnabled();\n', '    }\n', '\n', '    /// @dev Refunds ether to the contributors if in the Refunding state.\n', '    function refund(address contributor) external atState(State.Refunding) {\n', '        uint256 refundAmount = deposited[contributor].mul(refundable).div(totalDeposited);\n', '        deposited[contributor] = 0;\n', '        contributor.transfer(refundAmount);\n', '        LogRefunded(contributor, refundAmount);\n', '    }\n', '\n', '    /// @dev Sets the closingDeadline variable\n', '    function beginClosingPeriod() external onlyOwner atState(State.Success) {\n', '        require(closingDeadline == 0);\n', '        closingDeadline = now.add(closingDuration);\n', '    }\n', '\n', '    /// @dev Called by anyone if the sale was successful and the project delivered.\n', '    function close() external atState(State.Success) {\n', '        require(closingDeadline != 0 && closingDeadline <= now);\n', '        state = State.Closed;\n', '        LogClosed();\n', '    }\n', '\n', '    /// @dev Sends the disbursement amount to the wallet after the disbursement period has passed. Can be called by anyone.\n', '    function sendFundsToWallet() external atState(State.Closed) {\n', '        require(lastDisbursement.add(DISBURSEMENT_DURATION) <= now);\n', '\n', '        lastDisbursement = now;\n', '        uint256 amountToSend = Math.min256(address(this).balance, disbursementAmount);\n', '        refundable = refundable.sub(amountToSend);\n', '        trustedWallet.transfer(amountToSend);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev This contract is used to implement a signature based whitelisting mechanism\n', ' */\n', 'contract Whitelistable is Ownable {\n', '    bytes constant PREFIX = "\\x19Ethereum Signed Message:\\n32";\n', '\n', '    address public whitelistAdmin;\n', '\n', '    // addresses map to false by default\n', '    mapping(address => bool) public blacklist;\n', '\n', '    event LogAdminUpdated(address indexed newAdmin);\n', '\n', '    modifier validAdmin(address _admin) {\n', '        require(_admin != 0);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == whitelistAdmin);\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor for Whitelistable contract\n', '    /// @param _admin the address of the admin that will generate the signatures\n', '    function Whitelistable(address _admin) public validAdmin(_admin) {\n', '        whitelistAdmin = _admin;        \n', '    }\n', '\n', '    /// @dev Updates whitelistAdmin address \n', '    /// @dev Can only be called by the current owner\n', '    /// @param _admin the new admin address\n', '    function changeAdmin(address _admin)\n', '        external\n', '        onlyOwner\n', '        validAdmin(_admin)\n', '    {\n', '        LogAdminUpdated(_admin);\n', '        whitelistAdmin = _admin;\n', '    }\n', '\n', '    // @dev blacklists the given address to ban them from contributing\n', '    // @param _contributor Address of the contributor to blacklist \n', '    function addToBlacklist(address _contributor)\n', '        external\n', '        onlyAdmin\n', '    {\n', '        blacklist[_contributor] = true;\n', '    }\n', '\n', '    // @dev removes a previously blacklisted contributor from the blacklist\n', '    // @param _contributor Address of the contributor remove \n', '    function removeFromBlacklist(address _contributor)\n', '        external\n', '        onlyAdmin\n', '    {\n', '        blacklist[_contributor] = false;\n', '    }\n', '\n', '    /// @dev Checks if contributor is whitelisted (main Whitelistable function)\n', '    /// @param contributor Address of who was whitelisted\n', '    /// @param contributionLimit Limit for the user contribution\n', '    /// @param currentSaleCap Cap of contributions to the sale at the current point in time\n', '    /// @param v Recovery id\n', '    /// @param r Component of the ECDSA signature\n', '    /// @param s Component of the ECDSA signature\n', '    /// @return Is the signature correct?\n', '    function checkWhitelisted(\n', '        address contributor,\n', '        uint256 contributionLimit,\n', '        uint256 currentSaleCap,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public view returns(bool) {\n', '        bytes32 prefixed = keccak256(PREFIX, keccak256(contributor, contributionLimit, currentSaleCap));\n', '        return !(blacklist[contributor]) && (whitelistAdmin == ecrecover(prefixed, v, r, s));\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/StateMachine.sol\n', '\n', 'contract StateMachine {\n', '\n', '    struct State { \n', '        bytes32 nextStateId;\n', '        mapping(bytes4 => bool) allowedFunctions;\n', '        function() internal[] transitionCallbacks;\n', '        function(bytes32) internal returns(bool)[] startConditions;\n', '    }\n', '\n', '    mapping(bytes32 => State) states;\n', '\n', '    // The current state id\n', '    bytes32 private currentStateId;\n', '\n', '    event LogTransition(bytes32 stateId, uint256 blockNumber);\n', '\n', '    /* This modifier performs the conditional transitions and checks that the function \n', '     * to be executed is allowed in the current State\n', '     */\n', '    modifier checkAllowed {\n', '        conditionalTransitions();\n', '        require(states[currentStateId].allowedFunctions[msg.sig]);\n', '        _;\n', '    }\n', '\n', '    ///@dev transitions the state machine into the state it should currently be in\n', '    ///@dev by taking into account the current conditions and how many further transitions can occur \n', '    function conditionalTransitions() public {\n', '\n', '        bytes32 next = states[currentStateId].nextStateId;\n', '        bool stateChanged;\n', '\n', '        while (next != 0) {\n', "            // If one of the next state's conditions is met, go to this state and continue\n", '            stateChanged = false;\n', '            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n', '                if (states[next].startConditions[i](next)) {\n', '                    goToNextState();\n', '                    next = states[next].nextStateId;\n', '                    stateChanged = true;\n', '                    break;\n', '                }\n', '            }\n', "            // If none of the next state's conditions are met, then we are in the right current state\n", '            if (!stateChanged) break;\n', '        }\n', '    }\n', '\n', '    function getCurrentStateId() view public returns(bytes32) {\n', '        return currentStateId;\n', '    }\n', '\n', '\n', '    /// @dev Setup the state machine with the given states.\n', '    /// @param _stateIds Array of state ids.\n', '    function setStates(bytes32[] _stateIds) internal {\n', '        require(_stateIds.length > 0);\n', '        require(currentStateId == 0);\n', '\n', '        require(_stateIds[0] != 0);\n', '\n', '        currentStateId = _stateIds[0];\n', '\n', '        for (uint256 i = 1; i < _stateIds.length; i++) {\n', '            require(_stateIds[i] != 0);\n', '\n', '            states[_stateIds[i - 1]].nextStateId = _stateIds[i];\n', '\n', '            // Check that the state appears only once in the array\n', '            require(states[_stateIds[i]].nextStateId == 0);\n', '        }\n', '    }\n', '\n', '    /// @dev Allow a function in the given state.\n', '    /// @param _stateId The id of the state\n', '    /// @param _functionSelector A function selector (bytes4[keccak256(functionSignature)])\n', '    function allowFunction(bytes32 _stateId, bytes4 _functionSelector) internal {\n', '        states[_stateId].allowedFunctions[_functionSelector] = true;\n', '    }\n', '\n', '    /// @dev Goes to the next state if possible (if the next state is valid)\n', '    function goToNextState() internal {\n', '        bytes32 next = states[currentStateId].nextStateId;\n', '        require(next != 0);\n', '\n', '        currentStateId = next;\n', '        for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\n', '            states[next].transitionCallbacks[i]();\n', '        }\n', '\n', '        LogTransition(next, block.number);\n', '    }\n', '\n', '    ///@dev add a function returning a boolean as a start condition for a state\n', '    ///@param _stateId The ID of the state to add the condition for\n', '    ///@param _condition Start condition function - returns true if a start condition (for a given state ID) is met\n', '    function addStartCondition(bytes32 _stateId, function(bytes32) internal returns(bool) _condition) internal {\n', '        states[_stateId].startConditions.push(_condition);\n', '    }\n', '\n', '    ///@dev add a callback function for a state\n', '    ///@param _stateId The ID of the state to add a callback function for\n', '    ///@param _callback The callback function to add\n', '    function addCallback(bytes32 _stateId, function() internal _callback) internal {\n', '        states[_stateId].transitionCallbacks.push(_callback);\n', '    }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/TimedStateMachine.sol\n', '\n', '/// @title A contract that implements the state machine pattern and adds time dependant transitions.\n', 'contract TimedStateMachine is StateMachine {\n', '\n', '    event LogSetStateStartTime(bytes32 indexed _stateId, uint256 _startTime);\n', '\n', "    // Stores the start timestamp for each state (the value is 0 if the state doesn't have a start timestamp).\n", '    mapping(bytes32 => uint256) private startTime;\n', '\n', '    /// @dev Returns the timestamp for the given state id.\n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\n', '        return startTime[_stateId];\n', '    }\n', '\n', '    /// @dev Sets the starting timestamp for a state.\n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    /// @param _timestamp The start timestamp for the given state. It should be bigger than the current one.\n', '    function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\n', '        require(block.timestamp < _timestamp);\n', '\n', '        if (startTime[_stateId] == 0) {\n', '            addStartCondition(_stateId, hasStartTimePassed);\n', '        }\n', '\n', '        startTime[_stateId] = _timestamp;\n', '\n', '        LogSetStateStartTime(_stateId, _timestamp);\n', '    }\n', '\n', '    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n', '        return startTime[_stateId] <= block.timestamp;\n', '    }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/TokenControllerI.sol\n', '\n', '/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\n', 'contract TokenControllerI {\n', '\n', '    /// @dev Specifies whether a transfer is allowed or not.\n', '    /// @return True if the transfer is allowed\n', '    function transferAllowed(address _from, address _to) external view returns (bool);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/ControllableToken.sol\n', '\n', '/**\n', ' * @title Controllable ERC20 token\n', ' *\n', ' * @dev Token that queries a token controller contract to check if a transfer is allowed.\n', ' * @dev controller state var is going to be set with the address of a TokenControllerI contract that has \n', ' * implemented transferAllowed() function.\n', ' */\n', 'contract ControllableToken is Ownable, StandardToken {\n', '    TokenControllerI public controller;\n', '\n', '    /// @dev Executes transferAllowed() function from the Controller. \n', '    modifier isAllowed(address _from, address _to) {\n', '        require(controller.transferAllowed(_from, _to));\n', '        _;\n', '    }\n', '\n', '    /// @dev Sets the controller that is going to be used by isAllowed modifier\n', '    function setController(TokenControllerI _controller) onlyOwner public {\n', '        require(_controller != address(0));\n', '        controller = _controller;\n', '    }\n', '\n', '    /// @dev It calls parent BasicToken.transfer() function. It will transfer an amount of tokens to an specific address\n', '    /// @return True if the token is transfered with success\n', '    function transfer(address _to, uint256 _value) isAllowed(msg.sender, _to) public returns (bool) {        \n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @dev It calls parent StandardToken.transferFrom() function. It will transfer from an address a certain amount of tokens to another address \n', '    /// @return True if the token is transfered with success \n', '    function transferFrom(address _from, address _to, uint256 _value) isAllowed(_from, _to) public returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/Token.sol\n', '\n', '/**\n', ' * @title Token base contract - Defines basic structure for a token\n', ' *\n', ' * @dev ControllableToken is a StandardToken, an OpenZeppelin ERC20 implementation library. DetailedERC20 is also an OpenZeppelin contract.\n', ' * More info about them is available here: https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\n', ' */\n', 'contract Token is ControllableToken, DetailedERC20 {\n', '\n', '\t/**\n', '\t* @dev Transfer is an event inherited from ERC20Basic.sol interface (OpenZeppelin).\n', '\t* @param _supply Total supply of tokens.\n', '    * @param _name Is the long name by which the token contract should be known\n', '    * @param _symbol The set of capital letters used to represent the token e.g. DTH.\n', '    * @param _decimals The number of decimal places the tokens can be split up into. This should be between 0 and 18.\n', '\t*/\n', '    function Token(\n', '        uint256 _supply,\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals\n', '    ) DetailedERC20(_name, _symbol, _decimals) public {\n', '        require(_supply != 0);\n', '        totalSupply_ = _supply;\n', '        balances[msg.sender] = _supply;\n', '        Transfer(address(0), msg.sender, _supply);  //event\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Sale.sol\n', '\n', '/// @title Sale base contract\n', 'contract Sale is Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\n', '    using SafeMath for uint256;\n', '\n', '    // State machine states\n', "    bytes32 private constant SETUP = 'setup';\n", "    bytes32 private constant FREEZE = 'freeze';\n", "    bytes32 private constant SALE_IN_PROGRESS = 'saleInProgress';\n", "    bytes32 private constant SALE_ENDED = 'saleEnded';\n", '    bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\n', '\n', '    // Stores the contribution for each user\n', '    mapping(address => uint256) public contributions;\n', '    // Records which users have contributed throughout the sale\n', '    mapping(address => bool) public hasContributed;\n', '\n', '    DisbursementHandler public disbursementHandler;\n', '\n', '    uint256 public weiContributed = 0;\n', '    uint256 public totalSaleCap;\n', '    uint256 public minContribution;\n', '    uint256 public minThreshold;\n', '\n', '    // How many tokens a user will receive per each wei contributed\n', '    uint256 public tokensPerWei;\n', '    uint256 public tokensForSale;\n', '\n', '    Token public trustedToken;\n', '    Vault public trustedVault;\n', '\n', '    event LogContribution(address indexed contributor, uint256 value, uint256 excess);\n', '    event LogTokensAllocated(address indexed contributor, uint256 amount);\n', '\n', '    function Sale(\n', '        uint256 _totalSaleCap,\n', '        uint256 _minContribution,\n', '        uint256 _minThreshold,\n', '        uint256 _maxTokens,\n', '        address _whitelistAdmin,\n', '        address _wallet,\n', '        uint256 _closingDuration,\n', '        uint256 _vaultInitialAmount,\n', '        uint256 _vaultDisbursementAmount,\n', '        uint256 _startTime,\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals\n', '    ) \n', '        Whitelistable(_whitelistAdmin)\n', '        public \n', '    {\n', '        require(_totalSaleCap != 0);\n', '        require(_maxTokens != 0);\n', '        require(_wallet != 0);\n', '        require(_minThreshold <= _totalSaleCap);\n', '        require(_vaultInitialAmount <= _minThreshold);\n', '        require(now < _startTime);\n', '\n', '        totalSaleCap = _totalSaleCap;\n', '        minContribution = _minContribution;\n', '        minThreshold = _minThreshold;\n', '\n', '        // Setup the necessary contracts\n', '        trustedToken = new Token(_maxTokens, _tokenName, _tokenSymbol, _tokenDecimals);\n', '        disbursementHandler = new DisbursementHandler(trustedToken);\n', '\n', '        trustedToken.setController(this);\n', '\n', '        trustedVault = new Vault(\n', '            _wallet,\n', '            _vaultInitialAmount,\n', '            _vaultDisbursementAmount, // disbursement amount\n', '            _closingDuration\n', '        );\n', '\n', '        // Set the states\n', '        setStates(states);\n', '\n', '        allowFunction(SETUP, this.setup.selector);\n', '        allowFunction(FREEZE, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\n', '        allowFunction(SALE_ENDED, this.allocateTokens.selector);\n', '\n', '        // End the sale when the cap is reached\n', '        addStartCondition(SALE_ENDED, wasCapReached);\n', '\n', '        // Set the onSaleEnded callback (will be called when the sale ends)\n', '        addCallback(SALE_ENDED, onSaleEnded);\n', '\n', '        // Set the start and end times for the sale\n', '        setStateStartTime(SALE_IN_PROGRESS, _startTime);\n', '    }\n', '\n', '    /// @dev Setup the disbursements and tokens for sale.\n', '    /// @dev This needs to be outside the constructor because the token needs to query the sale for allowed transfers.\n', '    function setup() public onlyOwner checkAllowed {\n', '        require(trustedToken.transfer(disbursementHandler, disbursementHandler.totalAmount()));\n', '        tokensForSale = trustedToken.balanceOf(this);       \n', '        require(tokensForSale >= totalSaleCap);\n', '\n', '        // Go to freeze state\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev Called by users to contribute ETH to the sale.\n', '    function contribute(uint256 contributionLimit, uint256 currentSaleCap, uint8 v, bytes32 r, bytes32 s) \n', '        external \n', '        payable\n', '        checkAllowed \n', '    {\n', '        // Check that the signature is valid\n', '        require(currentSaleCap <= totalSaleCap);\n', '        require(weiContributed < currentSaleCap);\n', '        require(checkWhitelisted(msg.sender, contributionLimit, currentSaleCap, v, r, s));\n', '\n', '        uint256 current = contributions[msg.sender];\n', '        require(current < contributionLimit);\n', '\n', '        // Get the max amount that the user can contribute\n', '        uint256 remaining = Math.min256(contributionLimit.sub(current), currentSaleCap.sub(weiContributed));\n', '\n', '        // Check if it goes over the contribution limit of the user or the eth cap. \n', '        uint256 contribution = Math.min256(msg.value, remaining);\n', '\n', '        // Get the total contribution for the contributor after the previous checks\n', '        uint256 totalContribution = current.add(contribution);\n', '        require(totalContribution >= minContribution);\n', '\n', '        contributions[msg.sender] = totalContribution;\n', '        hasContributed[msg.sender] = true;\n', '\n', '        weiContributed = weiContributed.add(contribution);\n', '\n', '        trustedVault.deposit.value(contribution)(msg.sender);\n', '\n', '        if (weiContributed >= minThreshold && trustedVault.state() != Vault.State.Success) trustedVault.saleSuccessful();\n', '\n', '        // If there is an excess, return it to the user\n', '        uint256 excess = msg.value.sub(contribution);\n', '        if (excess > 0) msg.sender.transfer(excess);\n', '\n', '        LogContribution(msg.sender, contribution, excess);\n', '\n', '        assert(totalContribution <= contributionLimit);\n', '    }\n', '\n', '    /// @dev Sets the end time for the sale\n', '    /// @param _endTime The timestamp at which the sale will end.\n', '    function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\n', '        require(now < _endTime);\n', '        require(getStateStartTime(SALE_ENDED) == 0);\n', '        setStateStartTime(SALE_ENDED, _endTime);\n', '    }\n', '\n', '    /// @dev Called to allocate the tokens depending on eth contributed by the end of the sale.\n', '    /// @param _contributor The address of the contributor.\n', '    function allocateTokens(address _contributor) external checkAllowed {\n', '        require(contributions[_contributor] != 0);\n', '\n', '        // Transfer the respective tokens to the contributor\n', '        uint256 amount = contributions[_contributor].mul(tokensPerWei);\n', '\n', '        // Set contributions to 0\n', '        contributions[_contributor] = 0;\n', '\n', '        require(trustedToken.transfer(_contributor, amount));\n', '\n', '        LogTokensAllocated(_contributor, amount);\n', '    }\n', '\n', '    /// @dev Called to end the sale by the owner. Can only be called in SALE_IN_PROGRESS state\n', '    function endSale() external onlyOwner checkAllowed {\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev Since Sale is TokenControllerI, it has to implement transferAllowed() function\n', '    /// @notice only the Sale and DisbursementHandler can disburse the initial tokens to their future owners\n', '    function transferAllowed(address _from, address) external view returns (bool) {\n', '        return _from == address(this) || _from == address(disbursementHandler);\n', '    }\n', '\n', '    /// @dev Called internally by the sale to setup a disbursement (it has to be called in the constructor of child sales)\n', '    /// param _beneficiary Tokens will be disbursed to this address.\n', '    /// param _amount Number of tokens to be disbursed.\n', '    /// param _duration Tokens will be locked for this long.\n', '    function setupDisbursement(address _beneficiary, uint256 _amount, uint256 _duration) internal {\n', '        require(tokensForSale == 0);\n', '        disbursementHandler.setupDisbursement(_beneficiary, _amount, now.add(_duration));\n', '    }\n', '   \n', '    /// @dev Returns true if the cap was reached.\n', '    function wasCapReached(bytes32) internal returns (bool) {\n', '        return totalSaleCap <= weiContributed;\n', '    }\n', '\n', '    /// @dev Callback that gets called when entering the SALE_ENDED state.\n', '    function onSaleEnded() internal {\n', "        // If the minimum threshold wasn't reached, enable refunds\n", '        if (weiContributed < minThreshold) {\n', '            trustedVault.enableRefunds();\n', '        } else {\n', '            trustedVault.beginClosingPeriod();\n', '            tokensPerWei = tokensForSale.div(weiContributed);\n', '        }\n', '\n', '        trustedToken.transferOwnership(owner); \n', '        trustedVault.transferOwnership(owner);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/VirtuePokerSale.sol\n', '\n', 'contract VirtuePokerSale is Sale {\n', '\n', '    function VirtuePokerSale() \n', '        Sale(\n', '            25000 ether, // Total sale cap\n', '            1 ether, // Min contribution\n', '            12000 ether, // Min threshold\n', '            500000000 * (10 ** 18), // Max tokens\n', '            0x13ebf15f2e32d05ea944927ef5e6a3cad8187440, // Whitelist Admin\n', '            0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, // Wallet\n', '            28 days, // Closing duration\n', '            12000 ether, // Vault initial amount\n', '            25000 ether, // Vault disbursement amount\n', '            1524218400, // Start time\n', '            "Virtue Player Points", // Token name\n', '            "VPP", // Token symbol\n', '            18 // Token decimals\n', '        )\n', '        public \n', '    {\n', '        // Team Wallet (50,000,000 VPP, 25% per year)\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x2e286dA6Ee6E8e0Afb2c1CfADb1B74669a3cD642, 12500000 * (10 ** 18), 4 years);\n', '\n', '        // Company Wallet (250,000,000 VPP, no lock-up)\n', '        setupDisbursement(0xaa0aE3459F9f3472d1237015CaFC1aAfc6F03C63, 250000000 * (10 ** 18), 1 days);\n', '\n', '        // Founder Allocations (total 100,000,000, 12.5% per 6 months)\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0x5ca71f050865092468CF8184D09e087F3DC58e31, 8000000 * (10 ** 18), 4 years);\n', '\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0x35fc8cA81E1b5992a0727c6Aa87DbeB8cca42094, 2250000 * (10 ** 18), 4 years);\n', '\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 0.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 1.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 2.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 3.5 years);\n', '        setupDisbursement(0xce3EFA6763e23DF21aF74DA46C6489736F96d4B6, 2250000 * (10 ** 18), 4 years);\n', '    }\n', '}']
