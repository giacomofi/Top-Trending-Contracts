['pragma solidity ^0.4.24;\n', 'pragma experimental "v0.5.0";\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract ERC20 {\n', '  function balanceOf (address owner) public view returns (uint256);\n', '  function allowance (address owner, address spender) public view returns (uint256);\n', '  function transfer (address to, uint256 value) public returns (bool);\n', '  function transferFrom (address from, address to, uint256 value) public returns (bool);\n', '  function approve (address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract SalesPool {\n', '  using Math for uint256;\n', '\n', '  address public owner;\n', '\n', '  ERC20         public smartToken;\n', '  Math.Fraction public tokenPrice;\n', '\n', '  uint256 public pipeIndex = 1;\n', '  mapping (uint256 => SalesPipe) public indexToPipe;\n', '  mapping (address => uint256)   public pipeToIndex;\n', '\n', '  struct Commission {\n', '    uint256 gt;\n', '    uint256 lte;\n', '    uint256 pa;\n', '  }\n', '\n', '  struct Commissions {\n', '    Commission[] array;\n', '    uint256      length;\n', '  }\n', '\n', '  uint256 termsIndex = 1;\n', '  mapping (uint256 => Commissions) public terms;\n', '\n', '  event CreateSalesPipe(address salesPipe);\n', '\n', '  constructor (\n', '    address _smartTokenAddress,\n', '    uint256 _priceNumerator,\n', '    uint256 _priceDenominator\n', '  ) public {\n', '    owner      = msg.sender;\n', '    smartToken = ERC20(_smartTokenAddress);\n', '\n', '    tokenPrice.numerator   = _priceNumerator;\n', '    tokenPrice.denominator = _priceDenominator;\n', '\n', '    uint256 maxUint256 =\n', '      115792089237316195423570985008687907853269984665640564039457584007913129639935;\n', '\n', '    terms[1].array.push(Commission(0 ether, 2000 ether, 5));\n', '    terms[1].array.push(Commission(2000 ether, 10000 ether, 8));\n', '    terms[1].array.push(Commission(10000 ether, maxUint256, 10));\n', '    terms[1].length = terms[1].array.length;\n', '\n', '    terms[2].array.push(Commission(0 ether, maxUint256, 5));\n', '    terms[2].length = terms[2].array.length;\n', '\n', '    terms[3].array.push(Commission(0 ether, maxUint256, 15));\n', '    terms[3].length = terms[3].array.length;\n', '\n', '    termsIndex = 4;\n', '  }\n', '\n', '  function pushTerms (Commission[] _array) public {\n', '    require(msg.sender == owner);\n', '\n', '    for (uint256 i = 0; i < _array.length; i++) {\n', '      terms[termsIndex].array.push(Commission(_array[i].gt, _array[i].lte, _array[i].pa));\n', '    }\n', '\n', '    terms[termsIndex].length = terms[termsIndex].array.length;\n', '\n', '    termsIndex++;\n', '  }\n', '\n', '  function createPipe (\n', '    uint256 _termsNumber,\n', '    uint256 _allowance,\n', '    bytes32 _secretHash\n', '  ) public {\n', '    require(msg.sender == owner);\n', '\n', '    SalesPipe pipe = new SalesPipe(owner, _termsNumber, smartToken, _secretHash);\n', '\n', '    address pipeAddress = address(pipe);\n', '\n', '    smartToken.approve(pipeAddress, _allowance);\n', '\n', '    indexToPipe[pipeIndex]   = pipe;\n', '    pipeToIndex[pipeAddress] = pipeIndex;\n', '    pipeIndex++;\n', '\n', '    emit CreateSalesPipe(pipeAddress);\n', '  }\n', '\n', '  function setSalesPipeAllowance (address _pipeAddress, uint256 _value) public {\n', '    require(msg.sender == owner);\n', '    smartToken.approve(_pipeAddress, _value);\n', '  }\n', '\n', '  function poolTokenAmount () public view returns (uint256) {\n', '    return smartToken.balanceOf(address(this));\n', '  }\n', '\n', '  function transferEther(address _to, uint256 _value) public {\n', '    require(msg.sender == owner);\n', '    _to.transfer(_value);\n', '  }\n', '\n', '  function transferToken(ERC20 erc20, address _to, uint256 _value) public {\n', '    require(msg.sender == owner);\n', '    erc20.transfer(_to, _value);\n', '  }\n', '\n', '  function setOwner (address _owner) public {\n', '    require(msg.sender == owner);\n', '    owner = _owner;\n', '  }\n', '\n', '  function setSmartToken(address _smartTokenAddress) public {\n', '    require(msg.sender == owner);\n', '    smartToken = ERC20(_smartTokenAddress);\n', '  }\n', '\n', '  function setTokenPrice(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == owner);\n', '    require(\n', '      numerator   > 0 &&\n', '      denominator > 0\n', '    );\n', '\n', '    tokenPrice.numerator   = numerator;\n', '    tokenPrice.denominator = denominator;\n', '  }\n', '\n', '  function getTokenPrice () public view returns (uint256, uint256) {\n', '    return (tokenPrice.numerator, tokenPrice.denominator);\n', '  }\n', '\n', '  function getCommissions (uint256 _termsNumber) public view returns (Commissions) {\n', '    return terms[_termsNumber];\n', '  }\n', '  \n', '  function () payable external {}\n', '\n', '}\n', '\n', 'contract SalesPipe {\n', '  using Math for uint256;\n', '\n', '  SalesPool public pool;\n', '  address   public owner;\n', '\n', '  uint256 public termsNumber;\n', '\n', '  ERC20 public smartToken;\n', '\n', '  address public rf = address(0);\n', '  bytes32 public secretHash;\n', '\n', '  bool public available = true;\n', '  bool public finalized = false;\n', '\n', '  uint256 public totalEtherReceived = 0;\n', '\n', '  event TokenPurchase(\n', '    ERC20 indexed smartToken,\n', '    address indexed buyer,\n', '    address indexed receiver,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '\n', '  event RFDeclare (address rf);\n', '  event Finalize  (uint256 fstkRevenue, uint256 rfReceived);\n', '\n', '  constructor (\n', '    address _owner,\n', '    uint256 _termsNumber,\n', '    ERC20   _smartToken,\n', '    bytes32 _secretHash\n', '  ) public {\n', '    pool  = SalesPool(msg.sender);\n', '    owner = _owner;\n', '\n', '    termsNumber = _termsNumber;\n', '    smartToken  = _smartToken;\n', '\n', '    secretHash = _secretHash;\n', '  }\n', '\n', '  function () external payable {\n', '    Math.Fraction memory tokenPrice;\n', '    (tokenPrice.numerator, tokenPrice.denominator) = pool.getTokenPrice();\n', '\n', '    address poolAddress = address(pool);\n', '\n', '    uint256 availableAmount =\n', '      Math.min(\n', '        smartToken.allowance(poolAddress, address(this)),\n', '        smartToken.balanceOf(poolAddress)\n', '      );\n', '    uint256 revenue;\n', '    uint256 purchaseAmount = msg.value.div(tokenPrice);\n', '\n', '    require(\n', '      available &&\n', '      finalized == false &&\n', '      availableAmount > 0 &&\n', '      purchaseAmount  > 0\n', '    );\n', '\n', '    if (availableAmount >= purchaseAmount) {\n', '      revenue = msg.value;\n', '\n', '      if (availableAmount == purchaseAmount) {\n', '        available = false;\n', '      }\n', '    } else {\n', '      purchaseAmount = availableAmount;\n', '      revenue = availableAmount.mulCeil(tokenPrice);\n', '      available = false;\n', '\n', '      msg.sender.transfer(msg.value - revenue);\n', '    }\n', '\n', '    smartToken.transferFrom(poolAddress, msg.sender, purchaseAmount);\n', '\n', '    emit TokenPurchase(smartToken, msg.sender, msg.sender, revenue, purchaseAmount);\n', '\n', '    totalEtherReceived += revenue;\n', '  }\n', '\n', '  function declareRF(string _secret) public {\n', '    require(\n', '      secretHash == keccak256(abi.encodePacked(_secret)) &&\n', '      rf         == address(0)\n', '    );\n', '\n', '    rf = msg.sender;\n', '\n', '    emit RFDeclare(rf);\n', '  }\n', '\n', '  function finalize () public {\n', '    require(\n', '      msg.sender == owner &&\n', '      available  == false &&\n', '      finalized  == false &&\n', '      rf         != address(0)\n', '    );\n', '\n', '    finalized = true;\n', '\n', '    address poolAddress = address(pool);\n', '\n', '    uint256 rfEther   = calculateCommission(address(this).balance, termsNumber);\n', '    uint256 fstkEther = address(this).balance - rfEther;\n', '\n', '    rf.transfer(rfEther);\n', '    poolAddress.transfer(fstkEther);\n', '\n', '    emit Finalize(fstkEther, rfEther);\n', '  }\n', '\n', '  function calculateCommission (\n', '    uint256 _totalReceivedEther,\n', '    uint256 _termsNumber\n', '  ) public view returns (uint256) {\n', '    SalesPool.Commissions memory commissions = pool.getCommissions(_termsNumber);\n', '\n', '    for (uint256 i = 0; i < commissions.length; i++) {\n', '      SalesPool.Commission memory commission = commissions.array[i];\n', '      if (_totalReceivedEther > commission.gt && _totalReceivedEther <= commission.lte) {\n', '        return _totalReceivedEther * commission.pa / 100;\n', '      }\n', '    }\n', '\n', '    return 0;\n', '  }\n', '\n', '  function setOwner (address _owner) public {\n', '    require(msg.sender == owner);\n', '    owner = _owner;\n', '  }\n', '\n', '  function setTermsNumber (uint256 _termsNumber) public {\n', '    require(msg.sender == owner);\n', '    termsNumber = _termsNumber;\n', '  }\n', '\n', '  function setAvailability (bool _available) public {\n', '    require(msg.sender == owner);\n', '    available = _available;\n', '  }\n', '\n', '}\n', '\n', 'library Math {\n', '\n', '  struct Fraction {\n', '    uint256 numerator;\n', '    uint256 denominator;\n', '  }\n', '\n', '  function isPositive(Fraction memory fraction) internal pure returns (bool) {\n', '    return fraction.numerator > 0 && fraction.denominator > 0;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a * b;\n', '    require((a == 0) || (r / a == b));\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    r = a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a - b) <= a);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n', '    require((r = a + b) >= a);\n', '  }\n', '\n', '  function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x <= y ? x : y;\n', '  }\n', '\n', '  function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n', '    return x >= y ? x : y;\n', '  }\n', '\n', '  function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // if mul not overflow\n', '      r /= d;\n', '    } else {\n', '      // else div first\n', '      r = mul(value / d, m);\n', '    }\n', '  }\n', '\n', '  function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n', '    // try mul\n', '    r = value * m;\n', '    if (r / value == m) {\n', '      // mul not overflow\n', '      if (r % d == 0) {\n', '        r /= d;\n', '      } else {\n', '        r = (r / d) + 1;\n', '      }\n', '    } else {\n', '      // mul overflow then div first\n', '      r = mul(value / d, m);\n', '      if (value % d != 0) {\n', '        r += 1;\n', '      }\n', '    }\n', '  }\n', '\n', '  function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.numerator, f.denominator);\n', '  }\n', '\n', '  function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDiv(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n', '    return mulDivCeil(x, f.denominator, f.numerator);\n', '  }\n', '\n', '  function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n', '    return Math.Fraction({\n', '      numerator: mul(x.numerator, y.numerator),\n', '      denominator: mul(x.denominator, y.denominator)\n', '    });\n', '  }\n', '}']