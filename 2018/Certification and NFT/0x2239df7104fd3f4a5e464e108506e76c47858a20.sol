['pragma solidity^0.4.24;\n', '\n', '/**\n', '*\n', '*\n', '* Contacts: support (at) bankofeth.app\n', '*           https://twitter.com/bankofeth\n', '*           https://discord.gg/d5c7pfn\n', '*           https://t.me/bankofeth\n', '*           https://reddit.com/r/bankofeth\n', '*\n', '* PLAY NOW: https://heist.bankofeth.app/heist.htm\n', '*  \n', '* --- BANK OF ETH - BANK HEIST! ------------------------------------------------\n', '*\n', '* Hold the final key to complete the bank heist and win the entire vault funds!\n', '* \n', '* = Passive income while the vault time lock runs down - as others buy into the \n', '* game you earn $ETH! \n', '* \n', '* = Buy enough keys for a chance to open the safety bank deposit boxes for a \n', '* instant win! \n', '* \n', '* = Game designed with 4 dimensions of income for you, the players!\n', '*   (See https://heist.bankofeth.app/heist.htm for details)\n', '* \n', '* = Can you hold the last key to win the game!\n', '* = Can you win the safety deposit box!\n', '*\n', '* = Play NOW: https://heist.bankofeth.app/heist.htm\n', '*\n', '* Keys priced as low as 0.001 $ETH!\n', '*\n', '* Also - invest min 0.1 ETH for a chance to open a safety deposit box and \n', '* instantly win a bonus prize!\n', '* \n', '* The more keys you own in each round, the more distributed ETH you&#39;ll earn!\n', '* \n', '* All profits from thi game feed back into the main BankOfEth contract where \n', '* you can also be an investor in and earn a return on!\n', '*\n', '*\n', '* --- COPYRIGHT ----------------------------------------------------------------\n', '* \n', '*   This source code is provided for verification and audit purposes only and \n', '*   no license of re-use is granted.\n', '*   \n', '*   (C) Copyright 2018 BankOfEth.app\n', '*   \n', '*   \n', '*   Sub-license, white-label, solidity or Ethereum development enquiries please \n', '*   contact support (at) bankofeth.app\n', '*   \n', '*   \n', '* PLAY NOW: https://heist.bankofeth.app/heist.htm\n', '* \n', '*/\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', 'library Percent {\n', '\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', 'interface BankOfEth {\n', '    function receiveExternalProfits() external payable;\n', '}\n', '\n', 'contract BankOfEthVaultBreaker {\n', '    \n', '    using SafeMath for uint256;\n', '    using Percent for Percent.percent;\n', '    using Zero for *;\n', '    using ToAddress for *;\n', '\n', '    // Events    \n', '    event KeysIssued(address indexed to, uint keys, uint timestamp);\n', '    event EthDistributed(uint amount, uint timestamp);\n', '    event ReturnsWithdrawn(address indexed by, uint amount, uint timestamp);\n', '    event JackpotWon(address by, uint amount, uint timestamp);\n', '    event AirdropWon(address by, uint amount, uint timestamp);\n', '    event RoundStarted(uint indexed ID, uint hardDeadline, uint timestamp);\n', '    \n', '    address owner;\n', '    address devAddress;\n', '    address bankOfEthAddress = 0xd70c3f752Feb69Ecf8Eb31E48B20A97D979e8e5e;\n', '\n', '    BankOfEth localBankOfEth;\n', '    \n', '\n', '    // settings\n', '    uint public constant STARTING_KEY_PRICE = 1 finney; // 0.01 eth\n', '    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\n', '    \n', '    uint public constant TIME_PER_KEY = 5 minutes; // how much time is added to the soft deadline per key purchased\n', '    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '    \n', '    Percent.percent private m_currentRoundJackpotPercent = Percent.percent(15, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_investorsPercent = Percent.percent(65, 100); // 65/100*100% = 65%\n', '    Percent.percent private m_devPercent = Percent.percent(10, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_nextRoundSeedPercent = Percent.percent(5, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_airdropPercent = Percent.percent(2, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_bankOfEthProfitPercent = Percent.percent(3, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 15%\n', '    \n', '    struct SafeBreaker {\n', '        //uint lastCumulativeReturnsPoints;\n', '        uint lastCumulativeReturnsPoints;\n', '        uint keys;\n', '    }\n', '    \n', '    struct GameRound {\n', '        uint totalInvested;        \n', '        uint jackpot;\n', '        uint airdropPot;\n', '        uint totalKeys;\n', '        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of keys changes\n', '        uint hardDeadline;\n', '        uint softDeadline;\n', '        uint price;\n', '        uint lastPriceIncreaseTime;\n', '        address lastInvestor;\n', '        bool finalized;\n', '        mapping (address => SafeBreaker) safeBreakers;\n', '    }\n', '    \n', '    struct Vault {\n', '        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \n', '        uint refReturns; // how much of the total is from referrals\n', '    }\n', '\n', '    mapping (address => Vault) vaults;\n', '\n', '    uint public latestRoundID;// the first round has an ID of 0\n', '    GameRound[] rounds;\n', '    \n', '    \n', '    uint256 public minInvestment = 1 finney; // 0.01 eth\n', '    uint256 public maxInvestment = 2000 ether; \n', '    uint256 public roundDuration = (24 hours);\n', '    uint public soft_deadline_duration = 1 days; // max soft deadline\n', '    bool public gamePaused = false;\n', '    bool public limitedReferralsMode = true;\n', '    \n', '    mapping(address => bool) private m_referrals; // we only pay out on the first set of referrals\n', '    \n', '    \n', '    // Game vars\n', '    uint public jackpotSeed;// Jackpot from previous rounds\n', '    \n', '    uint public unclaimedReturns;\n', '    uint public constant MULTIPLIER = RAY;\n', '    \n', '    // Main stats:\n', '    uint public totalJackpotsWon;\n', '    uint public totalKeysSold;\n', '    uint public totalEarningsGenerated;\n', '\n', '    \n', '    // modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notOnPause() {\n', '        require(gamePaused == false, "Game Paused");\n', '        _;\n', '    }\n', '    \n', '    \n', '\n', '    \n', '    constructor() public {\n', '\n', '        owner = msg.sender;\n', '        devAddress = msg.sender;\n', '        localBankOfEth = BankOfEth(bankOfEthAddress);\n', '        \n', '        rounds.length++;\n', '        GameRound storage rnd = rounds[0];\n', '        latestRoundID = 0;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_KEY_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + soft_deadline_duration;\n', '        jackpotSeed = 0; \n', '        rnd.jackpot = jackpotSeed;\n', '        \n', '\n', '        \n', '    }\n', '    \n', '    function () public payable {\n', '        buyKeys(address(0x0));\n', '    }\n', '    \n', '    function investorInfo(address investor, uint roundID) external view\n', '    returns(uint keys, uint totalReturns, uint referralReturns) \n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        keys = rnd.safeBreakers[investor].keys;\n', '        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\n', '    }\n', '    function estimateReturns(address investor, uint roundID) public view \n', '    returns (uint totalReturns, uint refReturns) \n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        uint outstanding;\n', '        if(rounds.length > 1) {\n', '            if(hasReturns(investor, roundID - 1)) {\n', '                GameRound storage prevRnd = rounds[roundID - 1];\n', '                outstanding = _outstandingReturns(investor, prevRnd);\n', '            }\n', '        }\n', '\n', '        outstanding += _outstandingReturns(investor, rnd);\n', '        \n', '        totalReturns = vaults[investor].totalReturns + outstanding;\n', '        refReturns = vaults[investor].refReturns;\n', '    }\n', '    \n', '    function roundInfo(uint roundID) external view \n', '    returns(\n', '        address leader, \n', '        uint price,\n', '        uint jackpot, \n', '        uint airdrop, \n', '        uint keys, \n', '        uint totalInvested,\n', '        uint distributedReturns,\n', '        uint _hardDeadline,\n', '        uint _softDeadline,\n', '        bool finalized\n', '        )\n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        leader = rnd.lastInvestor;\n', '        price = rnd.price;\n', '        jackpot = rnd.jackpot;\n', '        airdrop = rnd.airdropPot;\n', '        keys = rnd.totalKeys;\n', '        totalInvested = rnd.totalInvested;\n', '        distributedReturns = m_currentRoundJackpotPercent.mul(rnd.totalInvested);\n', '        //wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        _hardDeadline = rnd.hardDeadline;\n', '        _softDeadline = rnd.softDeadline;\n', '        finalized = rnd.finalized;\n', '    }\n', '    \n', '    function totalsInfo() external view \n', '    returns(\n', '        uint totalReturns,\n', '        uint totalKeys,\n', '        uint totalJackpots\n', '    ) {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        if(rnd.softDeadline > now) {\n', '            totalKeys = totalKeysSold + rnd.totalKeys;\n', '            totalReturns = totalEarningsGenerated + m_currentRoundJackpotPercent.mul(rnd.totalInvested); \n', '            // wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        } else {\n', '            totalKeys = totalKeysSold;\n', '            totalReturns = totalEarningsGenerated;\n', '        }\n', '        totalJackpots = totalJackpotsWon;\n', '    }\n', '\n', '    \n', '    function reinvestReturns(uint value) public {        \n', '        reinvestReturns(value, address(0x0));\n', '    }\n', '\n', '    function reinvestReturns(uint value, address ref) public {        \n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        _updateReturns(msg.sender, rnd);        \n', '        require(vaults[msg.sender].totalReturns >= value, "Can&#39;t spend what you don&#39;t have");        \n', '        vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.sub(value);\n', '        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\n', '        unclaimedReturns = unclaimedReturns.sub(value);\n', '        _purchase(rnd, value, ref);\n', '    }\n', '    function withdrawReturns() public {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '\n', '        if(rounds.length > 1) {// check if they also have returns from before\n', '            if(hasReturns(msg.sender, latestRoundID - 1)) {\n', '                GameRound storage prevRnd = rounds[latestRoundID - 1];\n', '                _updateReturns(msg.sender, prevRnd);\n', '            }\n', '        }\n', '        _updateReturns(msg.sender, rnd);\n', '        uint amount = vaults[msg.sender].totalReturns;\n', '        require(amount > 0, "Nothing to withdraw!");\n', '        unclaimedReturns = unclaimedReturns.sub(amount);\n', '        vaults[msg.sender].totalReturns = 0;\n', '        vaults[msg.sender].refReturns = 0;\n', '        \n', '        rnd.safeBreakers[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit ReturnsWithdrawn(msg.sender, amount, now);\n', '    }\n', '    function hasReturns(address investor, uint roundID) public view returns (bool) {\n', '        GameRound storage rnd = rounds[roundID];\n', '        return rnd.cumulativeReturnsPoints > rnd.safeBreakers[investor].lastCumulativeReturnsPoints;\n', '    }\n', '    function updateMyReturns(uint roundID) public {\n', '        GameRound storage rnd = rounds[roundID];\n', '        _updateReturns(msg.sender, rnd);\n', '    }\n', '    \n', '    function finalizeLastRound() public {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        _finalizeRound(rnd);\n', '    }\n', '    function finalizeAndRestart() public payable {\n', '        finalizeLastRound();\n', '        startNewRound(address(0x0));\n', '    }\n', '    \n', '    function finalizeAndRestart(address _referer) public payable {\n', '        finalizeLastRound();\n', '        startNewRound(_referer);\n', '    }\n', '    \n', '    event debugLog(uint _num, string _string);\n', '    \n', '    function startNewRound(address _referer) public payable {\n', '        \n', '        require(rounds[latestRoundID].finalized, "Previous round not finalized");\n', '        require(rounds[latestRoundID].softDeadline < now, "Previous round still running");\n', '        \n', '        uint _rID = rounds.length++; // first round is 0\n', '        GameRound storage rnd = rounds[_rID];\n', '        latestRoundID = _rID;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_KEY_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + soft_deadline_duration;\n', '        rnd.jackpot = jackpotSeed;\n', '        jackpotSeed = 0; \n', '\n', '        _purchase(rnd, msg.value, _referer);\n', '        emit RoundStarted(_rID, rnd.hardDeadline, now);\n', '    }\n', '    \n', '    \n', '    function buyKeys(address _referer) public payable notOnPause {\n', '        require(msg.value >= minInvestment);\n', '        if(rounds.length > 0) {\n', '            GameRound storage rnd = rounds[latestRoundID];   \n', '               \n', '            _purchase(rnd, msg.value, _referer);            \n', '        } else {\n', '            revert("Not yet started");\n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    function _purchase(GameRound storage rnd, uint value, address referer) internal {\n', '        require(rnd.softDeadline >= now, "After deadline!");\n', '        require(value >= rnd.price/10, "Not enough Ether!");\n', '        rnd.totalInvested = rnd.totalInvested.add(value);\n', '\n', '        // Set the last investor (to win the jackpot after the deadline)\n', '        if(value >= rnd.price)\n', '            rnd.lastInvestor = msg.sender;\n', '        \n', '        \n', '        _airDrop(rnd, value);\n', '        \n', '\n', '        _splitRevenue(rnd, value, referer);\n', '        \n', '        _updateReturns(msg.sender, rnd);\n', '        \n', '        uint newKeys = _issueKeys(rnd, msg.sender, value);\n', '\n', '\n', '        uint timeIncreases = newKeys/WAD;// since 1 key is represented by 1 * 10^18, divide by 10^18\n', '        // adjust soft deadline to new soft deadline\n', '        uint newDeadline = rnd.softDeadline.add( timeIncreases.mul(TIME_PER_KEY));\n', '        \n', '        rnd.softDeadline = min(newDeadline, now + soft_deadline_duration);\n', '        // If after hard deadline, double the price every price increase periods\n', '        if(now > rnd.hardDeadline) {\n', '            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\n', '                rnd.price = rnd.price * 2;\n', '                rnd.lastPriceIncreaseTime = now;\n', '            }\n', '        }\n', '    }\n', '    function _issueKeys(GameRound storage rnd, address _safeBreaker, uint value) internal returns(uint) {    \n', '        if(rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints == 0) {\n', '            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        }    \n', '        \n', '        uint newKeys = wdiv(value, rnd.price);\n', '        \n', '        //bonuses:\n', '        if(value >= 100 ether) {\n', '            newKeys = newKeys.mul(2);//get double keys if you paid more than 100 ether\n', '        } else if(value >= 10 ether) {\n', '            newKeys = newKeys.add(newKeys/2);//50% bonus\n', '        } else if(value >= 1 ether) {\n', '            newKeys = newKeys.add(newKeys/3);//33% bonus\n', '        } else if(value >= 100 finney) {\n', '            newKeys = newKeys.add(newKeys/10);//10% bonus\n', '        }\n', '\n', '        rnd.safeBreakers[_safeBreaker].keys = rnd.safeBreakers[_safeBreaker].keys.add(newKeys);\n', '        rnd.totalKeys = rnd.totalKeys.add(newKeys);\n', '        emit KeysIssued(_safeBreaker, newKeys, now);\n', '        return newKeys;\n', '    }    \n', '    function _updateReturns(address _safeBreaker, GameRound storage rnd) internal {\n', '        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\n', '            return;\n', '        }\n', '        \n', '        uint outstanding = _outstandingReturns(_safeBreaker, rnd);\n', '\n', '        // if there are any returns, transfer them to the investor&#39;s vaults\n', '        if (outstanding > 0) {\n', '            vaults[_safeBreaker].totalReturns = vaults[_safeBreaker].totalReturns.add(outstanding);\n', '        }\n', '\n', '        rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '    }\n', '    function _outstandingReturns(address _safeBreaker, GameRound storage rnd) internal view returns(uint) {\n', '        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\n', '            return 0;\n', '        }\n', '        // check if there&#39;ve been new returns\n', '        uint newReturns = rnd.cumulativeReturnsPoints.sub(\n', '            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints\n', '            );\n', '\n', '        uint outstanding = 0;\n', '        if(newReturns != 0) { \n', '            // outstanding returns = (total new returns points * ivestor keys) / MULTIPLIER\n', '            // The MULTIPLIER is used also at the point of returns disbursment\n', '            outstanding = newReturns.mul(rnd.safeBreakers[_safeBreaker].keys) / MULTIPLIER;\n', '        }\n', '\n', '        return outstanding;\n', '    }\n', '    function _splitRevenue(GameRound storage rnd, uint value, address ref) internal {\n', '        uint roundReturns; // how much to pay in dividends to round players\n', '        \n', '\n', '        if(ref != address(0x0)) {\n', '\n', '            // only pay referrals for the first investment of each player\n', '            if(\n', '                (!m_referrals[msg.sender] && limitedReferralsMode == true)\n', '                ||\n', '                limitedReferralsMode == false\n', '                ) {\n', '            \n', '            \n', '                uint _referralEarning = m_refPercent.mul(value);\n', '                unclaimedReturns = unclaimedReturns.add(_referralEarning);\n', '                vaults[ref].totalReturns = vaults[ref].totalReturns.add(_referralEarning);\n', '                vaults[ref].refReturns = vaults[ref].refReturns.add(_referralEarning);\n', '                \n', '                value = value.sub(_referralEarning);\n', '                \n', '                m_referrals[msg.sender] = true;\n', '                \n', '            }\n', '        } else {\n', '        }\n', '        \n', '        roundReturns = m_investorsPercent.mul(value); // 65%\n', '        \n', '        uint airdrop_value = m_airdropPercent.mul(value);\n', '        \n', '        uint jackpot_value = m_currentRoundJackpotPercent.mul(value); //15%\n', '        \n', '        uint dev_value = m_devPercent.mul(value);\n', '        \n', '        uint bankOfEth_profit = m_bankOfEthProfitPercent.mul(value);\n', '        localBankOfEth.receiveExternalProfits.value(bankOfEth_profit)();\n', '        \n', '        // if this is the first purchase, roundReturns goes to jackpot (no one can claim these returns otherwise)\n', '        if(rnd.totalKeys == 0) {\n', '            rnd.jackpot = rnd.jackpot.add(roundReturns);\n', '        } else {\n', '            _disburseReturns(rnd, roundReturns);\n', '        }\n', '        \n', '        rnd.airdropPot = rnd.airdropPot.add(airdrop_value);\n', '        rnd.jackpot = rnd.jackpot.add(jackpot_value);\n', '        \n', '        devAddress.transfer(dev_value);\n', '        \n', '    }\n', '    function _disburseReturns(GameRound storage rnd, uint value) internal {\n', '        emit EthDistributed(value, now);\n', '        unclaimedReturns = unclaimedReturns.add(value);// keep track of unclaimed returns\n', '        // The returns points represent returns*MULTIPLIER/totalkeys (at the point of purchase)\n', '        // This allows us to keep outstanding balances of keyholders when the total supply changes in real time\n', '        if(rnd.totalKeys == 0) {\n', '            //rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\n', '            rnd.cumulativeReturnsPoints = value.mul(MULTIPLIER) / wdiv(value, rnd.price);\n', '        } else {\n', '            rnd.cumulativeReturnsPoints = rnd.cumulativeReturnsPoints.add(\n', '                value.mul(MULTIPLIER) / rnd.totalKeys\n', '            );\n', '        }\n', '    }\n', '    function _airDrop(GameRound storage rnd, uint value) internal {\n', '        require(msg.sender == tx.origin, "Only Humans Allowed! (or scripts that don&#39;t use smart contracts)!");\n', '        if(value > 100 finney) {\n', '            /**\n', '                Creates a random number from the last block hash and current timestamp.\n', '                One could add more seemingly random data like the msg.sender, etc, but that doesn&#39;t \n', '                make it harder for a miner to manipulate the result in their favor (if they intended to).\n', '             */\n', '            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\n', '            if(chance % 200 == 0) {// once in 200 times\n', '                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\n', '                rnd.airdropPot = rnd.airdropPot / 2;\n', '                vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.add(prize);\n', '                unclaimedReturns = unclaimedReturns.add(prize);\n', '                totalJackpotsWon += prize;\n', '                emit AirdropWon(msg.sender, prize, now);\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function _finalizeRound(GameRound storage rnd) internal {\n', '        require(!rnd.finalized, "Already finalized!");\n', '        require(rnd.softDeadline < now, "Round still running!");\n', '\n', '\n', '        // Transfer jackpot to winner&#39;s vault\n', '        vaults[rnd.lastInvestor].totalReturns = vaults[rnd.lastInvestor].totalReturns.add(rnd.jackpot);\n', '        unclaimedReturns = unclaimedReturns.add(rnd.jackpot);\n', '        \n', '        emit JackpotWon(rnd.lastInvestor, rnd.jackpot, now);\n', '        totalJackpotsWon += rnd.jackpot;\n', '        // transfer the leftover to the next round&#39;s jackpot\n', '        jackpotSeed = jackpotSeed.add( m_nextRoundSeedPercent.mul(rnd.totalInvested));\n', '            \n', '        //Empty the AD pot if it has a balance.\n', '        jackpotSeed = jackpotSeed.add(rnd.airdropPot);\n', '        \n', '        //Send out dividends to token holders\n', '        //uint _div;\n', '        \n', '        //_div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \n', '        \n', '        //token.disburseDividends.value(_div)();\n', '        //totalDividendsPaid += _div;\n', '        totalKeysSold += rnd.totalKeys;\n', '        totalEarningsGenerated += m_currentRoundJackpotPercent.mul(rnd.totalInvested);\n', '\n', '        rnd.finalized = true;\n', '    }\n', '    \n', '    // Owner only functions    \n', '    function p_setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '    function p_setDevAddress(address _devAddress) public onlyOwner {\n', '        devAddress = _devAddress;\n', '    }\n', '    function p_setCurrentRoundJackpotPercent(uint num, uint dem) public onlyOwner {\n', '        m_currentRoundJackpotPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setInvestorsPercent(uint num, uint dem) public onlyOwner {\n', '        m_investorsPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setDevPercent(uint num, uint dem) public onlyOwner {\n', '        m_devPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setNextRoundSeedPercent(uint num, uint dem) public onlyOwner {\n', '        m_nextRoundSeedPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setAirdropPercent(uint num, uint dem) public onlyOwner {\n', '        m_airdropPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setBankOfEthProfitPercent(uint num, uint dem) public onlyOwner {\n', '        m_bankOfEthProfitPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setMinInvestment(uint _minInvestment) public onlyOwner {\n', '        minInvestment = _minInvestment;\n', '    }\n', '    function p_setMaxInvestment(uint _maxInvestment) public onlyOwner {\n', '        maxInvestment = _maxInvestment;\n', '    }\n', '    function p_setGamePaused(bool _gamePaused) public onlyOwner {\n', '        gamePaused = _gamePaused;\n', '    }\n', '    function p_setRoundDuration(uint256 _roundDuration) public onlyOwner {\n', '        roundDuration = _roundDuration;\n', '    }\n', '    function p_setBankOfEthAddress(address _bankOfEthAddress) public onlyOwner {\n', '        bankOfEthAddress = _bankOfEthAddress;\n', '        localBankOfEth = BankOfEth(bankOfEthAddress);\n', '    }\n', '    function p_setLimitedReferralsMode(bool _limitedReferralsMode) public onlyOwner {\n', '        limitedReferralsMode = _limitedReferralsMode;\n', '    }\n', '    function p_setSoft_deadline_duration(uint _soft_deadline_duration) public onlyOwner {\n', '        soft_deadline_duration = _soft_deadline_duration;\n', '    }\n', '    // Util functions\n', '    function notZeroAndNotSender(address addr) internal view returns(bool) {\n', '        return addr.notZero() && addr != msg.sender;\n', '    }\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(y).add(WAD/2) / WAD;\n', '        //z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(y).add(RAY/2) / RAY;\n', '        //z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(WAD).add(y/2)/y;\n', '        //z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(RAY).add(y/2)/y;\n', '        //z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '    \n', '    uint op;\n', '    function gameOp() public {\n', '        op++;\n', '    }\n', '\n', '}']
['pragma solidity^0.4.24;\n', '\n', '/**\n', '*\n', '*\n', '* Contacts: support (at) bankofeth.app\n', '*           https://twitter.com/bankofeth\n', '*           https://discord.gg/d5c7pfn\n', '*           https://t.me/bankofeth\n', '*           https://reddit.com/r/bankofeth\n', '*\n', '* PLAY NOW: https://heist.bankofeth.app/heist.htm\n', '*  \n', '* --- BANK OF ETH - BANK HEIST! ------------------------------------------------\n', '*\n', '* Hold the final key to complete the bank heist and win the entire vault funds!\n', '* \n', '* = Passive income while the vault time lock runs down - as others buy into the \n', '* game you earn $ETH! \n', '* \n', '* = Buy enough keys for a chance to open the safety bank deposit boxes for a \n', '* instant win! \n', '* \n', '* = Game designed with 4 dimensions of income for you, the players!\n', '*   (See https://heist.bankofeth.app/heist.htm for details)\n', '* \n', '* = Can you hold the last key to win the game!\n', '* = Can you win the safety deposit box!\n', '*\n', '* = Play NOW: https://heist.bankofeth.app/heist.htm\n', '*\n', '* Keys priced as low as 0.001 $ETH!\n', '*\n', '* Also - invest min 0.1 ETH for a chance to open a safety deposit box and \n', '* instantly win a bonus prize!\n', '* \n', "* The more keys you own in each round, the more distributed ETH you'll earn!\n", '* \n', '* All profits from thi game feed back into the main BankOfEth contract where \n', '* you can also be an investor in and earn a return on!\n', '*\n', '*\n', '* --- COPYRIGHT ----------------------------------------------------------------\n', '* \n', '*   This source code is provided for verification and audit purposes only and \n', '*   no license of re-use is granted.\n', '*   \n', '*   (C) Copyright 2018 BankOfEth.app\n', '*   \n', '*   \n', '*   Sub-license, white-label, solidity or Ethereum development enquiries please \n', '*   contact support (at) bankofeth.app\n', '*   \n', '*   \n', '* PLAY NOW: https://heist.bankofeth.app/heist.htm\n', '* \n', '*/\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', 'library Percent {\n', '\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', 'interface BankOfEth {\n', '    function receiveExternalProfits() external payable;\n', '}\n', '\n', 'contract BankOfEthVaultBreaker {\n', '    \n', '    using SafeMath for uint256;\n', '    using Percent for Percent.percent;\n', '    using Zero for *;\n', '    using ToAddress for *;\n', '\n', '    // Events    \n', '    event KeysIssued(address indexed to, uint keys, uint timestamp);\n', '    event EthDistributed(uint amount, uint timestamp);\n', '    event ReturnsWithdrawn(address indexed by, uint amount, uint timestamp);\n', '    event JackpotWon(address by, uint amount, uint timestamp);\n', '    event AirdropWon(address by, uint amount, uint timestamp);\n', '    event RoundStarted(uint indexed ID, uint hardDeadline, uint timestamp);\n', '    \n', '    address owner;\n', '    address devAddress;\n', '    address bankOfEthAddress = 0xd70c3f752Feb69Ecf8Eb31E48B20A97D979e8e5e;\n', '\n', '    BankOfEth localBankOfEth;\n', '    \n', '\n', '    // settings\n', '    uint public constant STARTING_KEY_PRICE = 1 finney; // 0.01 eth\n', '    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\n', '    \n', '    uint public constant TIME_PER_KEY = 5 minutes; // how much time is added to the soft deadline per key purchased\n', '    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '    \n', '    Percent.percent private m_currentRoundJackpotPercent = Percent.percent(15, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_investorsPercent = Percent.percent(65, 100); // 65/100*100% = 65%\n', '    Percent.percent private m_devPercent = Percent.percent(10, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_nextRoundSeedPercent = Percent.percent(5, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_airdropPercent = Percent.percent(2, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_bankOfEthProfitPercent = Percent.percent(3, 100); // 15/100*100% = 15%\n', '    Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 15%\n', '    \n', '    struct SafeBreaker {\n', '        //uint lastCumulativeReturnsPoints;\n', '        uint lastCumulativeReturnsPoints;\n', '        uint keys;\n', '    }\n', '    \n', '    struct GameRound {\n', '        uint totalInvested;        \n', '        uint jackpot;\n', '        uint airdropPot;\n', '        uint totalKeys;\n', '        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of keys changes\n', '        uint hardDeadline;\n', '        uint softDeadline;\n', '        uint price;\n', '        uint lastPriceIncreaseTime;\n', '        address lastInvestor;\n', '        bool finalized;\n', '        mapping (address => SafeBreaker) safeBreakers;\n', '    }\n', '    \n', '    struct Vault {\n', '        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \n', '        uint refReturns; // how much of the total is from referrals\n', '    }\n', '\n', '    mapping (address => Vault) vaults;\n', '\n', '    uint public latestRoundID;// the first round has an ID of 0\n', '    GameRound[] rounds;\n', '    \n', '    \n', '    uint256 public minInvestment = 1 finney; // 0.01 eth\n', '    uint256 public maxInvestment = 2000 ether; \n', '    uint256 public roundDuration = (24 hours);\n', '    uint public soft_deadline_duration = 1 days; // max soft deadline\n', '    bool public gamePaused = false;\n', '    bool public limitedReferralsMode = true;\n', '    \n', '    mapping(address => bool) private m_referrals; // we only pay out on the first set of referrals\n', '    \n', '    \n', '    // Game vars\n', '    uint public jackpotSeed;// Jackpot from previous rounds\n', '    \n', '    uint public unclaimedReturns;\n', '    uint public constant MULTIPLIER = RAY;\n', '    \n', '    // Main stats:\n', '    uint public totalJackpotsWon;\n', '    uint public totalKeysSold;\n', '    uint public totalEarningsGenerated;\n', '\n', '    \n', '    // modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notOnPause() {\n', '        require(gamePaused == false, "Game Paused");\n', '        _;\n', '    }\n', '    \n', '    \n', '\n', '    \n', '    constructor() public {\n', '\n', '        owner = msg.sender;\n', '        devAddress = msg.sender;\n', '        localBankOfEth = BankOfEth(bankOfEthAddress);\n', '        \n', '        rounds.length++;\n', '        GameRound storage rnd = rounds[0];\n', '        latestRoundID = 0;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_KEY_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + soft_deadline_duration;\n', '        jackpotSeed = 0; \n', '        rnd.jackpot = jackpotSeed;\n', '        \n', '\n', '        \n', '    }\n', '    \n', '    function () public payable {\n', '        buyKeys(address(0x0));\n', '    }\n', '    \n', '    function investorInfo(address investor, uint roundID) external view\n', '    returns(uint keys, uint totalReturns, uint referralReturns) \n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        keys = rnd.safeBreakers[investor].keys;\n', '        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\n', '    }\n', '    function estimateReturns(address investor, uint roundID) public view \n', '    returns (uint totalReturns, uint refReturns) \n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        uint outstanding;\n', '        if(rounds.length > 1) {\n', '            if(hasReturns(investor, roundID - 1)) {\n', '                GameRound storage prevRnd = rounds[roundID - 1];\n', '                outstanding = _outstandingReturns(investor, prevRnd);\n', '            }\n', '        }\n', '\n', '        outstanding += _outstandingReturns(investor, rnd);\n', '        \n', '        totalReturns = vaults[investor].totalReturns + outstanding;\n', '        refReturns = vaults[investor].refReturns;\n', '    }\n', '    \n', '    function roundInfo(uint roundID) external view \n', '    returns(\n', '        address leader, \n', '        uint price,\n', '        uint jackpot, \n', '        uint airdrop, \n', '        uint keys, \n', '        uint totalInvested,\n', '        uint distributedReturns,\n', '        uint _hardDeadline,\n', '        uint _softDeadline,\n', '        bool finalized\n', '        )\n', '    {\n', '        GameRound storage rnd = rounds[roundID];\n', '        leader = rnd.lastInvestor;\n', '        price = rnd.price;\n', '        jackpot = rnd.jackpot;\n', '        airdrop = rnd.airdropPot;\n', '        keys = rnd.totalKeys;\n', '        totalInvested = rnd.totalInvested;\n', '        distributedReturns = m_currentRoundJackpotPercent.mul(rnd.totalInvested);\n', '        //wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        _hardDeadline = rnd.hardDeadline;\n', '        _softDeadline = rnd.softDeadline;\n', '        finalized = rnd.finalized;\n', '    }\n', '    \n', '    function totalsInfo() external view \n', '    returns(\n', '        uint totalReturns,\n', '        uint totalKeys,\n', '        uint totalJackpots\n', '    ) {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        if(rnd.softDeadline > now) {\n', '            totalKeys = totalKeysSold + rnd.totalKeys;\n', '            totalReturns = totalEarningsGenerated + m_currentRoundJackpotPercent.mul(rnd.totalInvested); \n', '            // wmul(rnd.totalInvested, RETURNS_FRACTION);\n', '        } else {\n', '            totalKeys = totalKeysSold;\n', '            totalReturns = totalEarningsGenerated;\n', '        }\n', '        totalJackpots = totalJackpotsWon;\n', '    }\n', '\n', '    \n', '    function reinvestReturns(uint value) public {        \n', '        reinvestReturns(value, address(0x0));\n', '    }\n', '\n', '    function reinvestReturns(uint value, address ref) public {        \n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        _updateReturns(msg.sender, rnd);        \n', '        require(vaults[msg.sender].totalReturns >= value, "Can\'t spend what you don\'t have");        \n', '        vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.sub(value);\n', '        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\n', '        unclaimedReturns = unclaimedReturns.sub(value);\n', '        _purchase(rnd, value, ref);\n', '    }\n', '    function withdrawReturns() public {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '\n', '        if(rounds.length > 1) {// check if they also have returns from before\n', '            if(hasReturns(msg.sender, latestRoundID - 1)) {\n', '                GameRound storage prevRnd = rounds[latestRoundID - 1];\n', '                _updateReturns(msg.sender, prevRnd);\n', '            }\n', '        }\n', '        _updateReturns(msg.sender, rnd);\n', '        uint amount = vaults[msg.sender].totalReturns;\n', '        require(amount > 0, "Nothing to withdraw!");\n', '        unclaimedReturns = unclaimedReturns.sub(amount);\n', '        vaults[msg.sender].totalReturns = 0;\n', '        vaults[msg.sender].refReturns = 0;\n', '        \n', '        rnd.safeBreakers[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit ReturnsWithdrawn(msg.sender, amount, now);\n', '    }\n', '    function hasReturns(address investor, uint roundID) public view returns (bool) {\n', '        GameRound storage rnd = rounds[roundID];\n', '        return rnd.cumulativeReturnsPoints > rnd.safeBreakers[investor].lastCumulativeReturnsPoints;\n', '    }\n', '    function updateMyReturns(uint roundID) public {\n', '        GameRound storage rnd = rounds[roundID];\n', '        _updateReturns(msg.sender, rnd);\n', '    }\n', '    \n', '    function finalizeLastRound() public {\n', '        GameRound storage rnd = rounds[latestRoundID];\n', '        _finalizeRound(rnd);\n', '    }\n', '    function finalizeAndRestart() public payable {\n', '        finalizeLastRound();\n', '        startNewRound(address(0x0));\n', '    }\n', '    \n', '    function finalizeAndRestart(address _referer) public payable {\n', '        finalizeLastRound();\n', '        startNewRound(_referer);\n', '    }\n', '    \n', '    event debugLog(uint _num, string _string);\n', '    \n', '    function startNewRound(address _referer) public payable {\n', '        \n', '        require(rounds[latestRoundID].finalized, "Previous round not finalized");\n', '        require(rounds[latestRoundID].softDeadline < now, "Previous round still running");\n', '        \n', '        uint _rID = rounds.length++; // first round is 0\n', '        GameRound storage rnd = rounds[_rID];\n', '        latestRoundID = _rID;\n', '\n', '        rnd.lastInvestor = msg.sender;\n', '        rnd.price = STARTING_KEY_PRICE;\n', '        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\n', '        rnd.softDeadline = now + soft_deadline_duration;\n', '        rnd.jackpot = jackpotSeed;\n', '        jackpotSeed = 0; \n', '\n', '        _purchase(rnd, msg.value, _referer);\n', '        emit RoundStarted(_rID, rnd.hardDeadline, now);\n', '    }\n', '    \n', '    \n', '    function buyKeys(address _referer) public payable notOnPause {\n', '        require(msg.value >= minInvestment);\n', '        if(rounds.length > 0) {\n', '            GameRound storage rnd = rounds[latestRoundID];   \n', '               \n', '            _purchase(rnd, msg.value, _referer);            \n', '        } else {\n', '            revert("Not yet started");\n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    function _purchase(GameRound storage rnd, uint value, address referer) internal {\n', '        require(rnd.softDeadline >= now, "After deadline!");\n', '        require(value >= rnd.price/10, "Not enough Ether!");\n', '        rnd.totalInvested = rnd.totalInvested.add(value);\n', '\n', '        // Set the last investor (to win the jackpot after the deadline)\n', '        if(value >= rnd.price)\n', '            rnd.lastInvestor = msg.sender;\n', '        \n', '        \n', '        _airDrop(rnd, value);\n', '        \n', '\n', '        _splitRevenue(rnd, value, referer);\n', '        \n', '        _updateReturns(msg.sender, rnd);\n', '        \n', '        uint newKeys = _issueKeys(rnd, msg.sender, value);\n', '\n', '\n', '        uint timeIncreases = newKeys/WAD;// since 1 key is represented by 1 * 10^18, divide by 10^18\n', '        // adjust soft deadline to new soft deadline\n', '        uint newDeadline = rnd.softDeadline.add( timeIncreases.mul(TIME_PER_KEY));\n', '        \n', '        rnd.softDeadline = min(newDeadline, now + soft_deadline_duration);\n', '        // If after hard deadline, double the price every price increase periods\n', '        if(now > rnd.hardDeadline) {\n', '            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\n', '                rnd.price = rnd.price * 2;\n', '                rnd.lastPriceIncreaseTime = now;\n', '            }\n', '        }\n', '    }\n', '    function _issueKeys(GameRound storage rnd, address _safeBreaker, uint value) internal returns(uint) {    \n', '        if(rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints == 0) {\n', '            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '        }    \n', '        \n', '        uint newKeys = wdiv(value, rnd.price);\n', '        \n', '        //bonuses:\n', '        if(value >= 100 ether) {\n', '            newKeys = newKeys.mul(2);//get double keys if you paid more than 100 ether\n', '        } else if(value >= 10 ether) {\n', '            newKeys = newKeys.add(newKeys/2);//50% bonus\n', '        } else if(value >= 1 ether) {\n', '            newKeys = newKeys.add(newKeys/3);//33% bonus\n', '        } else if(value >= 100 finney) {\n', '            newKeys = newKeys.add(newKeys/10);//10% bonus\n', '        }\n', '\n', '        rnd.safeBreakers[_safeBreaker].keys = rnd.safeBreakers[_safeBreaker].keys.add(newKeys);\n', '        rnd.totalKeys = rnd.totalKeys.add(newKeys);\n', '        emit KeysIssued(_safeBreaker, newKeys, now);\n', '        return newKeys;\n', '    }    \n', '    function _updateReturns(address _safeBreaker, GameRound storage rnd) internal {\n', '        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\n', '            return;\n', '        }\n', '        \n', '        uint outstanding = _outstandingReturns(_safeBreaker, rnd);\n', '\n', "        // if there are any returns, transfer them to the investor's vaults\n", '        if (outstanding > 0) {\n', '            vaults[_safeBreaker].totalReturns = vaults[_safeBreaker].totalReturns.add(outstanding);\n', '        }\n', '\n', '        rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\n', '    }\n', '    function _outstandingReturns(address _safeBreaker, GameRound storage rnd) internal view returns(uint) {\n', '        if(rnd.safeBreakers[_safeBreaker].keys == 0) {\n', '            return 0;\n', '        }\n', "        // check if there've been new returns\n", '        uint newReturns = rnd.cumulativeReturnsPoints.sub(\n', '            rnd.safeBreakers[_safeBreaker].lastCumulativeReturnsPoints\n', '            );\n', '\n', '        uint outstanding = 0;\n', '        if(newReturns != 0) { \n', '            // outstanding returns = (total new returns points * ivestor keys) / MULTIPLIER\n', '            // The MULTIPLIER is used also at the point of returns disbursment\n', '            outstanding = newReturns.mul(rnd.safeBreakers[_safeBreaker].keys) / MULTIPLIER;\n', '        }\n', '\n', '        return outstanding;\n', '    }\n', '    function _splitRevenue(GameRound storage rnd, uint value, address ref) internal {\n', '        uint roundReturns; // how much to pay in dividends to round players\n', '        \n', '\n', '        if(ref != address(0x0)) {\n', '\n', '            // only pay referrals for the first investment of each player\n', '            if(\n', '                (!m_referrals[msg.sender] && limitedReferralsMode == true)\n', '                ||\n', '                limitedReferralsMode == false\n', '                ) {\n', '            \n', '            \n', '                uint _referralEarning = m_refPercent.mul(value);\n', '                unclaimedReturns = unclaimedReturns.add(_referralEarning);\n', '                vaults[ref].totalReturns = vaults[ref].totalReturns.add(_referralEarning);\n', '                vaults[ref].refReturns = vaults[ref].refReturns.add(_referralEarning);\n', '                \n', '                value = value.sub(_referralEarning);\n', '                \n', '                m_referrals[msg.sender] = true;\n', '                \n', '            }\n', '        } else {\n', '        }\n', '        \n', '        roundReturns = m_investorsPercent.mul(value); // 65%\n', '        \n', '        uint airdrop_value = m_airdropPercent.mul(value);\n', '        \n', '        uint jackpot_value = m_currentRoundJackpotPercent.mul(value); //15%\n', '        \n', '        uint dev_value = m_devPercent.mul(value);\n', '        \n', '        uint bankOfEth_profit = m_bankOfEthProfitPercent.mul(value);\n', '        localBankOfEth.receiveExternalProfits.value(bankOfEth_profit)();\n', '        \n', '        // if this is the first purchase, roundReturns goes to jackpot (no one can claim these returns otherwise)\n', '        if(rnd.totalKeys == 0) {\n', '            rnd.jackpot = rnd.jackpot.add(roundReturns);\n', '        } else {\n', '            _disburseReturns(rnd, roundReturns);\n', '        }\n', '        \n', '        rnd.airdropPot = rnd.airdropPot.add(airdrop_value);\n', '        rnd.jackpot = rnd.jackpot.add(jackpot_value);\n', '        \n', '        devAddress.transfer(dev_value);\n', '        \n', '    }\n', '    function _disburseReturns(GameRound storage rnd, uint value) internal {\n', '        emit EthDistributed(value, now);\n', '        unclaimedReturns = unclaimedReturns.add(value);// keep track of unclaimed returns\n', '        // The returns points represent returns*MULTIPLIER/totalkeys (at the point of purchase)\n', '        // This allows us to keep outstanding balances of keyholders when the total supply changes in real time\n', '        if(rnd.totalKeys == 0) {\n', '            //rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\n', '            rnd.cumulativeReturnsPoints = value.mul(MULTIPLIER) / wdiv(value, rnd.price);\n', '        } else {\n', '            rnd.cumulativeReturnsPoints = rnd.cumulativeReturnsPoints.add(\n', '                value.mul(MULTIPLIER) / rnd.totalKeys\n', '            );\n', '        }\n', '    }\n', '    function _airDrop(GameRound storage rnd, uint value) internal {\n', '        require(msg.sender == tx.origin, "Only Humans Allowed! (or scripts that don\'t use smart contracts)!");\n', '        if(value > 100 finney) {\n', '            /**\n', '                Creates a random number from the last block hash and current timestamp.\n', "                One could add more seemingly random data like the msg.sender, etc, but that doesn't \n", '                make it harder for a miner to manipulate the result in their favor (if they intended to).\n', '             */\n', '            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\n', '            if(chance % 200 == 0) {// once in 200 times\n', '                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\n', '                rnd.airdropPot = rnd.airdropPot / 2;\n', '                vaults[msg.sender].totalReturns = vaults[msg.sender].totalReturns.add(prize);\n', '                unclaimedReturns = unclaimedReturns.add(prize);\n', '                totalJackpotsWon += prize;\n', '                emit AirdropWon(msg.sender, prize, now);\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function _finalizeRound(GameRound storage rnd) internal {\n', '        require(!rnd.finalized, "Already finalized!");\n', '        require(rnd.softDeadline < now, "Round still running!");\n', '\n', '\n', "        // Transfer jackpot to winner's vault\n", '        vaults[rnd.lastInvestor].totalReturns = vaults[rnd.lastInvestor].totalReturns.add(rnd.jackpot);\n', '        unclaimedReturns = unclaimedReturns.add(rnd.jackpot);\n', '        \n', '        emit JackpotWon(rnd.lastInvestor, rnd.jackpot, now);\n', '        totalJackpotsWon += rnd.jackpot;\n', "        // transfer the leftover to the next round's jackpot\n", '        jackpotSeed = jackpotSeed.add( m_nextRoundSeedPercent.mul(rnd.totalInvested));\n', '            \n', '        //Empty the AD pot if it has a balance.\n', '        jackpotSeed = jackpotSeed.add(rnd.airdropPot);\n', '        \n', '        //Send out dividends to token holders\n', '        //uint _div;\n', '        \n', '        //_div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \n', '        \n', '        //token.disburseDividends.value(_div)();\n', '        //totalDividendsPaid += _div;\n', '        totalKeysSold += rnd.totalKeys;\n', '        totalEarningsGenerated += m_currentRoundJackpotPercent.mul(rnd.totalInvested);\n', '\n', '        rnd.finalized = true;\n', '    }\n', '    \n', '    // Owner only functions    \n', '    function p_setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '    }\n', '    function p_setDevAddress(address _devAddress) public onlyOwner {\n', '        devAddress = _devAddress;\n', '    }\n', '    function p_setCurrentRoundJackpotPercent(uint num, uint dem) public onlyOwner {\n', '        m_currentRoundJackpotPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setInvestorsPercent(uint num, uint dem) public onlyOwner {\n', '        m_investorsPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setDevPercent(uint num, uint dem) public onlyOwner {\n', '        m_devPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setNextRoundSeedPercent(uint num, uint dem) public onlyOwner {\n', '        m_nextRoundSeedPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setAirdropPercent(uint num, uint dem) public onlyOwner {\n', '        m_airdropPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setBankOfEthProfitPercent(uint num, uint dem) public onlyOwner {\n', '        m_bankOfEthProfitPercent = Percent.percent(num, dem);\n', '    }\n', '    function p_setMinInvestment(uint _minInvestment) public onlyOwner {\n', '        minInvestment = _minInvestment;\n', '    }\n', '    function p_setMaxInvestment(uint _maxInvestment) public onlyOwner {\n', '        maxInvestment = _maxInvestment;\n', '    }\n', '    function p_setGamePaused(bool _gamePaused) public onlyOwner {\n', '        gamePaused = _gamePaused;\n', '    }\n', '    function p_setRoundDuration(uint256 _roundDuration) public onlyOwner {\n', '        roundDuration = _roundDuration;\n', '    }\n', '    function p_setBankOfEthAddress(address _bankOfEthAddress) public onlyOwner {\n', '        bankOfEthAddress = _bankOfEthAddress;\n', '        localBankOfEth = BankOfEth(bankOfEthAddress);\n', '    }\n', '    function p_setLimitedReferralsMode(bool _limitedReferralsMode) public onlyOwner {\n', '        limitedReferralsMode = _limitedReferralsMode;\n', '    }\n', '    function p_setSoft_deadline_duration(uint _soft_deadline_duration) public onlyOwner {\n', '        soft_deadline_duration = _soft_deadline_duration;\n', '    }\n', '    // Util functions\n', '    function notZeroAndNotSender(address addr) internal view returns(bool) {\n', '        return addr.notZero() && addr != msg.sender;\n', '    }\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(y).add(WAD/2) / WAD;\n', '        //z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(y).add(RAY/2) / RAY;\n', '        //z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(WAD).add(y/2)/y;\n', '        //z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = x.mul(RAY).add(y/2)/y;\n', '        //z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '    \n', '    uint op;\n', '    function gameOp() public {\n', '        op++;\n', '    }\n', '\n', '}']
