['/*\n', '\tVerified Crypto Company token\n', '\n', '\tCopyright (C) Fusion Solutions KFT <contact@fusionsolutions.io> - All Rights Reserved\n', '\n', '\tThis file is part of Verified Crypto Company token project.\n', '\tUnauthorized copying of this file or source, via any medium is strictly prohibited\n', '\tProprietary and confidential\n', '\tThis file can not be copied and/or distributed without the express permission of the Author.\n', '\n', '\tWritten by Andor Rajci, August 2018\n', '*/\n', 'pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '    /* Internals */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a + b;\n', '        assert( c >= a );\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a - b;\n', '        assert( c <= a );\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a * b;\n', '        assert( c == 0 || c / a == b );\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a / b;\n', '    }\n', '    function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a ** b;\n', '        assert( c % a == 0 );\n', '        return a ** b;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '\t/* Declarations */\n', '\tusing SafeMath for uint256;\n', '\t/* Structures */\n', '\tstruct action_s {\n', '\t\taddress origin;\n', '\t\tuint256 voteCounter;\n', '\t\tuint256 uid;\n', '\t\tmapping(address => uint256) voters;\n', '\t}\n', '\t/* Variables */\n', '\tstring  public name = "Verified Crypto Company token";\n', '\tstring  public symbol = "VRFD";\n', '\tuint8   public decimals = 0;\n', '\tuint256 public totalSupply = 1e6;\n', '\tuint256 public actionVotedRate;\n', '\tuint256 public ownerCounter;\n', '\tuint256 public voteUID;\n', '\taddress public admin;\n', '\tmapping(address => uint256) public balanceOf;\n', '\tmapping(address => string) public nameOf;\n', '\tmapping(address => bool) public owners;\n', '\tmapping(bytes32 => action_s) public actions;\n', '\t/* Constructor */\n', '\tconstructor(address _admin, uint256 _actionVotedRate, address[] _owners) public {\n', '\t\tuint256 i;\n', '\t\trequire( _actionVotedRate <= 100 );\n', '\t\tactionVotedRate = _actionVotedRate;\n', '\t\tfor ( i=0 ; i<_owners.length ; i++ ) {\n', '\t\t\towners[_owners[i]] = true;\n', '\t\t}\n', '\t\townerCounter = _owners.length;\n', '\t\tbalanceOf[address(this)] = totalSupply;\n', '\t\temit Mint(address(this), totalSupply);\n', '\t\tadmin = _admin;\n', '\t}\n', '\t/* Fallback */\n', '\tfunction () public { revert(); }\n', '\t/* Externals */\n', '\tfunction setStatus(address _target, uint256 _status, string _name) external forAdmin {\n', '\t\trequire( balanceOf[_target] == 0 );\n', '\t\tbalanceOf[address(this)] = balanceOf[address(this)].sub(_status);\n', '\t\tbalanceOf[_target] = _status;\n', '\t\tnameOf[_target] = _name;\n', '\t\temit Transfer(address(this), _target, _status);\n', '\t}\n', '\tfunction delStatus(address _target) external forAdmin {\n', '\t\trequire( balanceOf[_target] > 0 );\n', '\t\tbalanceOf[address(this)] = balanceOf[address(this)].add(balanceOf[_target]);\n', '\t\temit Transfer(_target,  address(this), balanceOf[_target]);\n', '\t\tdelete balanceOf[_target];\n', '\t\tdelete nameOf[_target];\n', '\t}\n', '\tfunction changeAdmin(address _newAdmin) external forOwner {\n', '\t\tbytes32 _hash;\n', "\t\t_hash = keccak256('changeAdmin', _newAdmin);\n", '\t\tif ( actions[_hash].origin == 0x00 ) {\n', '\t\t\temit newAdminAction(_hash, _newAdmin, msg.sender);\n', '\t\t}\n', '\t\tif ( doVote(_hash) ) {\n', '\t\t\tadmin = _newAdmin;\n', '\t\t}\n', '\t}\n', '\tfunction newOwner(address _owner) external forOwner {\n', '\t\tbytes32 _hash;\n', '\t\trequire( ! owners[_owner] );\n', "\t\t_hash = keccak256('addNewOwner', _owner);\n", '\t\tif ( actions[_hash].origin == 0x00 ) {\n', '\t\t\temit newAddNewOwnerAction(_hash, _owner, msg.sender);\n', '\t\t}\n', '\t\tif ( doVote(_hash) ) {\n', '\t\t\townerCounter = ownerCounter.add(1);\n', '\t\t\towners[_owner] = true;\n', '\t\t}\n', '\t}\n', '\tfunction delOwner(address _owner) external forOwner {\n', '\t\tbytes32 _hash;\n', '\t\trequire( owners[_owner] );\n', "\t\t_hash = keccak256('delOwner', _owner);\n", '\t\tif ( actions[_hash].origin == 0x00 ) {\n', '\t\t\temit newDelOwnerAction(_hash, _owner, msg.sender);\n', '\t\t}\n', '\t\tif ( doVote(_hash) ) {\n', '\t\t\townerCounter = ownerCounter.sub(1);\n', '\t\t\towners[_owner] = false;\n', '\t\t}\n', '\t}\n', '\t/* Internals */\n', '\tfunction doVote(bytes32 _hash) internal returns (bool _voted) {\n', '\t\trequire( owners[msg.sender] );\n', '\t\tif ( actions[_hash].origin == 0x00 ) {\n', '\t\t\tvoteUID = voteUID.add(1);\n', '\t\t\tactions[_hash].origin = msg.sender;\n', '\t\t\tactions[_hash].voteCounter = 1;\n', '\t\t\tactions[_hash].uid = voteUID;\n', '\t\t} else if ( ( actions[_hash].voters[msg.sender] != actions[_hash].uid ) && actions[_hash].origin != msg.sender ) {\n', '\t\t\tactions[_hash].voters[msg.sender] = actions[_hash].uid;\n', '\t\t\tactions[_hash].voteCounter = actions[_hash].voteCounter.add(1);\n', '\t\t\temit vote(_hash, msg.sender);\n', '\t\t}\n', '\t\tif ( actions[_hash].voteCounter.mul(100).div(ownerCounter) >= actionVotedRate ) {\n', '\t\t\t_voted = true;\n', '\t\t\temit votedAction(_hash);\n', '\t\t\tdelete actions[_hash];\n', '\t\t}\n', '\t}\n', '\t/* Modifiers */\n', '\tmodifier forAdmin {\n', '\t\trequire( msg.sender == admin );\n', '\t\t_;\n', '\t}\n', '\tmodifier forOwner {\n', '\t\trequire( owners[msg.sender] );\n', '\t\t_;\n', '\t}\n', '\t/* Events */\n', '\tevent Mint(address indexed _addr, uint256 indexed _value);\n', '\tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '\tevent newAddNewOwnerAction(bytes32 _hash, address _owner, address _origin);\n', '\tevent newDelOwnerAction(bytes32 _hash, address _owner, address _origin);\n', '\tevent newAdminAction(bytes32 _hash, address _newAdmin, address _origin);\n', '\tevent vote(bytes32 _hash, address _voter);\n', '\tevent votedAction(bytes32 _hash);\n', '}']