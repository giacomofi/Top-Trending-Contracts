['pragma solidity ^0.4.18;\n', '\n', 'contract SimpleMultiSig {\n', '\n', '  uint public nonce;                 // (only) mutable state\n', '  uint public threshold;             // immutable state\n', '  mapping (address => bool) isOwner; // immutable state\n', '  address[] public ownersArr;        // immutable state\n', '\n', '  function SimpleMultiSig(uint threshold_, address[] owners_) public {\n', '    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0);\n', '\n', '    address lastAdd = address(0); \n', '    for (uint i = 0; i < owners_.length; i++) {\n', '      require(owners_[i] > lastAdd);\n', '      isOwner[owners_[i]] = true;\n', '      lastAdd = owners_[i];\n', '    }\n', '    ownersArr = owners_;\n', '    threshold = threshold_;\n', '  }\n', '\n', '  // Note that address recovered from signatures must be strictly increasing\n', '  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {\n', '    require(sigR.length == threshold);\n', '    require(sigR.length == sigS.length && sigR.length == sigV.length);\n', '\n', '    // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191\n', '    bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce);\n', '\n', '    address lastAdd = address(0); // cannot have address(0) as an owner\n', '    for (uint i = 0; i < threshold; i++) {\n', '      address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);\n', '      require(recovered > lastAdd && isOwner[recovered]);\n', '      lastAdd = recovered;\n', '    }\n', '\n', '    // If we make it here all signatures are accounted for\n', '    nonce = nonce + 1;\n', '    require(executeCall(destination, value, data));\n', '  }\n', '\n', '  // The address.call() syntax is no longer recommended, see:\n', '  // https://github.com/ethereum/solidity/issues/2884\n', '  function executeCall(address to, uint256 value, bytes data) internal returns (bool success) {\n', '    assembly {\n', '      success := call(gas, to, value, add(data, 0x20), mload(data), 0, 0)\n', '    }\n', '  }\n', '\n', '  function () payable public {}\n', '}']