['pragma solidity 0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract AMBToken {\n', '    using SafeMath for uint256;\n', '\n', '    string  public constant name     = "Ambit token";\n', '    string  public constant symbol   = "AMBT";\n', '    uint8   public constant decimals = 18;\n', '    uint256 public totalSupply;\n', '\n', '    bool internal contractIsWorking = true;\n', '\n', '    struct Investor {\n', '        uint256 tokenBalance;\n', '        uint256 icoInvest;\n', '        bool    activated;\n', '    }\n', '    mapping(address => Investor) internal investors;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    /*\n', '            Dividend&#39;s Structures\n', '    */\n', '    uint256   internal dividendCandidate = 0;\n', '    uint256[] internal dividends;\n', '\n', '    enum ProfitStatus {Initial, StartFixed, EndFixed, Claimed}\n', '    struct InvestorProfitData {\n', '        uint256      start_balance;\n', '        uint256      end_balance;\n', '        ProfitStatus status;\n', '    }\n', '\n', '    mapping(address => mapping(uint32 => InvestorProfitData)) internal profits;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return investors[_owner].tokenBalance;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function _approve(address _spender, uint256 _value) internal returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        require(investors[msg.sender].activated && contractIsWorking);\n', '        return _approve(_spender, _value);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value <= investors[_from].tokenBalance);\n', '\n', '        fixDividendBalances(_to, false);\n', '\n', '        investors[_from].tokenBalance = investors[_from].tokenBalance.sub(_value);\n', '        investors[_to].tokenBalance = investors[_to].tokenBalance.add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(investors[msg.sender].activated && contractIsWorking);\n', '        fixDividendBalances(msg.sender, false);\n', '        return _transfer( msg.sender, _to,  _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(investors[msg.sender].activated && investors[_from].activated && contractIsWorking);\n', '        require(_to != address(0));\n', '        require(_value <= investors[_from].tokenBalance);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        fixDividendBalances(_from, false);\n', '        fixDividendBalances(_to, false);\n', '\n', '        investors[_from].tokenBalance = investors[_from].tokenBalance.sub(_value);\n', '        investors[_to].tokenBalance   = investors[_to].tokenBalance.add(_value);\n', '        allowed[_from][msg.sender]    = allowed[_from][msg.sender].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Eligible token and balance helper function\n', '     */\n', '    function fixDividendBalances(address investor, bool revertIfClaimed) internal\n', '        returns (InvestorProfitData storage current_profit, uint256 profit_per_token){\n', '\n', '        uint32 next_id      = uint32(dividends.length);\n', '        uint32 current_id   = next_id - 1;\n', '        current_profit      = profits[investor][current_id];\n', '\n', '        if (revertIfClaimed) require(current_profit.status != ProfitStatus.Claimed);\n', '        InvestorProfitData storage next_profit      = profits[investor][next_id];\n', '\n', '        if (current_profit.status == ProfitStatus.Initial) {\n', '\n', '            current_profit.start_balance = investors[investor].tokenBalance;\n', '            current_profit.end_balance   = investors[investor].tokenBalance;\n', '            current_profit.status        = ProfitStatus.EndFixed;\n', '            next_profit.start_balance = investors[investor].tokenBalance;\n', '            next_profit.status        = ProfitStatus.StartFixed;\n', '\n', '        } else if (current_profit.status == ProfitStatus.StartFixed) {\n', '\n', '            current_profit.end_balance = investors[investor].tokenBalance;\n', '            current_profit.status      = ProfitStatus.EndFixed;\n', '            next_profit.start_balance = investors[investor].tokenBalance;\n', '            next_profit.status        = ProfitStatus.StartFixed;\n', '        }\n', '        profit_per_token = dividends[current_id];\n', '    }\n', '}\n', '\n', 'contract AMBTICO is AMBToken {\n', '    uint256 internal constant ONE_TOKEN           = 10 ** uint256(decimals);//just for convenience\n', '    uint256 internal constant MILLION             = 1000000;                //just for convenience\n', '\n', '    uint256 internal constant BOUNTY_QUANTITY     = 3120000;\n', '    uint256 internal constant RESERV_QUANTITY     = 12480000;\n', '\n', '    uint256 internal constant TOKEN_MAX_SUPPLY    = 104 * MILLION   * ONE_TOKEN;\n', '    uint256 internal constant BOUNTY_TOKENS       = BOUNTY_QUANTITY * ONE_TOKEN;\n', '    uint256 internal constant RESERV_TOKENS       = RESERV_QUANTITY * ONE_TOKEN;\n', '    uint256 internal constant MIN_SOLD_TOKENS     = 200             * ONE_TOKEN;\n', '    uint256 internal constant SOFTCAP             = BOUNTY_TOKENS + RESERV_TOKENS + 6 * MILLION * ONE_TOKEN;\n', '\n', '    uint256 internal constant REFUND_PERIOD       = 60 days;\n', '    uint256 internal constant KYC_REVIEW_PERIOD   = 60 days;\n', '\n', '    address internal owner;\n', '    address internal bountyManager;\n', '    address internal dividendManager;\n', '    address internal dApp;\n', '\n', '    enum ContractMode {Initial, TokenSale, UnderSoftCap, DividendDistribution, Destroyed}\n', '    ContractMode public mode = ContractMode.Initial;\n', '\n', '    uint256 public icoFinishTime = 0;\n', '    uint256 public tokenSold = 0;\n', '    uint256 public etherCollected = 0;\n', '\n', '    uint8   public currentSection = 0;\n', '    uint[4] public saleSectionDiscounts = [ uint8(20), 10, 5];\n', '    uint[4] public saleSectionPrice     = [ uint256(1000000000000000), 1125000000000000, 1187500000000000, 1250000000000000];//price: 0.40 0.45 0.475 0.50 cent | ETH/USD initial rate: 400\n', '    uint[4] public saleSectionCount     = [ uint256(17 * MILLION), 20 * MILLION, 20 * MILLION, 47 * MILLION - (BOUNTY_QUANTITY+RESERV_QUANTITY)];\n', '    uint[4] public saleSectionInvest    = [ uint256(saleSectionCount[0] * saleSectionPrice[0]),\n', '                                                    saleSectionCount[1] * saleSectionPrice[1],\n', '                                                    saleSectionCount[2] * saleSectionPrice[2],\n', '                                                    saleSectionCount[3] * saleSectionPrice[3]];\n', '    uint256 public buyBackPriceWei = 0 ether;\n', '\n', '    event OwnershipTransferred          (address previousOwner, address newOwner);\n', '    event BountyManagerAssigned         (address previousBountyManager, address newBountyManager);\n', '    event DividendManagerAssigned       (address previousDividendManager, address newDividendManager);\n', '    event DAppAssigned                  (address previousDApp, address newDApp);\n', '    event ModeChanged                   (ContractMode  newMode, uint256 tokenBalance);\n', '    event DividendDeclared              (uint32 indexed dividendID, uint256 profitPerToken);\n', '    event DividendClaimed               (address indexed investor, uint256 amount);\n', '    event BuyBack                       (address indexed requestor);\n', '    event Refund                        (address indexed investor, uint256 amount);\n', '    event Handbrake                     (ContractMode current_mode, bool functioning);\n', '    event FundsAdded                    (address owner, uint256 amount);\n', '    event FundsWithdrawal               (address owner, uint256 amount);\n', '    event BountyTransfered              (address recipient, uint256 amount);\n', '    event PriceChanged                  (uint256 newPrice);\n', '    event BurnToken                     (uint256 amount);\n', '\n', '    modifier grantOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier grantBountyManager() {\n', '        require(msg.sender == bountyManager);\n', '        _;\n', '    }\n', '\n', '    modifier grantDividendManager() {\n', '        require(msg.sender == dividendManager);\n', '        _;\n', '    }\n', '\n', '    modifier grantDApp() {\n', '        require(msg.sender == dApp);\n', '        _;\n', '    }\n', '    function AMBTICO() public {\n', '        owner = msg.sender;\n', '        dividends.push(0);\n', '    }\n', '\n', '    function setTokenPrice(uint256 new_wei_price) public grantDApp {\n', '        require(new_wei_price > 0);\n', '        uint8 len = uint8(saleSectionPrice.length)-1;\n', '        for (uint8 i=0; i<=len; i++) {\n', '            uint256 prdsc = 100 - saleSectionDiscounts[i];\n', '            saleSectionPrice[i]  = prdsc.mul(new_wei_price ).div(100);\n', '            saleSectionInvest[i] = saleSectionPrice[i] * saleSectionCount[i];\n', '        }\n', '        emit PriceChanged(new_wei_price);\n', '    }\n', '\n', '    function startICO() public grantOwner {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.Initial);\n', '        require(bountyManager != 0x0);\n', '\n', '        totalSupply = TOKEN_MAX_SUPPLY;\n', '\n', '        investors[this].tokenBalance            = TOKEN_MAX_SUPPLY-(BOUNTY_TOKENS+RESERV_TOKENS);\n', '        investors[bountyManager].tokenBalance   = BOUNTY_TOKENS;\n', '        investors[owner].tokenBalance           = RESERV_TOKENS;\n', '\n', '        tokenSold = investors[bountyManager].tokenBalance + investors[owner].tokenBalance;\n', '\n', '        mode = ContractMode.TokenSale;\n', '        emit ModeChanged(mode, investors[this].tokenBalance);\n', '    }\n', '\n', '    function getCurrentTokenPrice() public view returns(uint256) {\n', '        require(currentSection < saleSectionCount.length);\n', '        return saleSectionPrice[currentSection];\n', '    }\n', '\n', '    function () public payable {\n', '        invest();\n', '    }\n', '    function invest() public payable {\n', '       _invest(msg.sender,msg.value);\n', '    }\n', '    /* Used by ĐApp to accept Bitcoin transfers.*/\n', '    function investWithBitcoin(address ethAddress, uint256 ethWEI) public grantDApp {\n', '        _invest(ethAddress,ethWEI);\n', '    }\n', '\n', '\n', '    function _invest(address msg_sender, uint256 msg_value) internal {\n', '        require(contractIsWorking);\n', '        require(currentSection < saleSectionCount.length);\n', '        require(mode == ContractMode.TokenSale);\n', '        require(msg_sender != bountyManager);\n', '\n', '        uint wei_value = msg_value;\n', '        uint _tokens = 0;\n', '\n', '        while (wei_value > 0 && (currentSection < saleSectionCount.length)) {\n', '            if (saleSectionInvest[currentSection] >= wei_value) {\n', '                _tokens += ONE_TOKEN.mul(wei_value).div(saleSectionPrice[currentSection]);\n', '                saleSectionInvest[currentSection] -= wei_value;\n', '                wei_value =0;\n', '            } else {\n', '                _tokens += ONE_TOKEN.mul(saleSectionInvest[currentSection]).div(saleSectionPrice[currentSection]);\n', '                wei_value -= saleSectionInvest[currentSection];\n', '                saleSectionInvest[currentSection] = 0;\n', '            }\n', '            if (saleSectionInvest[currentSection] <= 0) currentSection++;\n', '        }\n', '\n', '        require(_tokens >= MIN_SOLD_TOKENS);\n', '\n', '        require(_transfer(this, msg_sender, _tokens));\n', '\n', '        profits[msg_sender][1] = InvestorProfitData({\n', '            start_balance:  investors[msg_sender].tokenBalance,\n', '            end_balance:    investors[msg_sender].tokenBalance,\n', '            status:         ProfitStatus.StartFixed\n', '            });\n', '\n', '        investors[msg_sender].icoInvest += (msg_value - wei_value);\n', '\n', '        tokenSold      += _tokens;\n', '        etherCollected += (msg_value - wei_value);\n', '\n', '        if (saleSectionInvest[saleSectionInvest.length-1] == 0 ) {\n', '            _finishICO();\n', '        }\n', '\n', '        if (wei_value > 0) {\n', '            msg_sender.transfer(wei_value);\n', '        }\n', '    }\n', '\n', '    function _finishICO() internal {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.TokenSale);\n', '\n', '        if (tokenSold >= SOFTCAP) {\n', '            mode = ContractMode.DividendDistribution;\n', '        } else {\n', '            mode = ContractMode.UnderSoftCap;\n', '        }\n', '\n', '        investors[this].tokenBalance = 0;\n', '        icoFinishTime                = now;\n', '        totalSupply                  = tokenSold;\n', '\n', '        emit ModeChanged(mode, investors[this].tokenBalance);\n', '    }\n', '\n', '    function finishICO() public grantOwner  {\n', '        _finishICO();\n', '    }\n', '\n', '    function getInvestedAmount(address investor) public view returns(uint256) {\n', '        return investors[investor].icoInvest;\n', '    }\n', '\n', '    function activateAddress(address investor, bool status) public grantDApp {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.DividendDistribution);\n', '        require((now - icoFinishTime) < KYC_REVIEW_PERIOD);\n', '        investors[investor].activated = status;\n', '    }\n', '\n', '    function isAddressActivated(address investor) public view returns (bool) {\n', '        return investors[investor].activated;\n', '    }\n', '\n', '    /*******\n', '            Dividend Declaration Section\n', '    *********/\n', '    function declareDividend(uint256 profit_per_token) public grantDividendManager {\n', '        dividendCandidate = profit_per_token;\n', '    }\n', '\n', '    function confirmDividend(uint256 profit_per_token) public grantOwner {\n', '        require(contractIsWorking);\n', '        require(dividendCandidate == profit_per_token);\n', '        require(mode == ContractMode.DividendDistribution);\n', '\n', '        dividends.push(dividendCandidate);\n', '        emit DividendDeclared(uint32(dividends.length), dividendCandidate);\n', '        dividendCandidate = 0;\n', '    }\n', '\n', '    function claimDividend() public {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.DividendDistribution);\n', '        require(investors[msg.sender].activated);\n', '\n', '        InvestorProfitData storage current_profit;\n', '        uint256 price_per_token;\n', '        (current_profit, price_per_token) = fixDividendBalances(msg.sender, true);\n', '\n', '        uint256 investorProfitWei =\n', '                    (current_profit.start_balance < current_profit.end_balance ?\n', '                     current_profit.start_balance : current_profit.end_balance ).div(ONE_TOKEN).mul(price_per_token);\n', '\n', '        current_profit.status = ProfitStatus.Claimed;\n', '        emit DividendClaimed(msg.sender, investorProfitWei);\n', '\n', '        msg.sender.transfer(investorProfitWei);\n', '    }\n', '\n', '    function getDividendInfo() public view returns(uint256) {\n', '        return dividends[dividends.length - 1];\n', '    }\n', '\n', '    /*******\n', '                emit BuyBack\n', '    ********/\n', '    function setBuyBackPrice(uint256 token_buyback_price) public grantOwner {\n', '        require(mode == ContractMode.DividendDistribution);\n', '        buyBackPriceWei = token_buyback_price;\n', '    }\n', '\n', '    function buyback() public {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.DividendDistribution);\n', '        require(buyBackPriceWei > 0);\n', '\n', '        uint256 token_amount = investors[msg.sender].tokenBalance;\n', '        uint256 ether_amount = calcTokenToWei(token_amount);\n', '\n', '        require(address(this).balance > ether_amount);\n', '\n', '        if (transfer(this, token_amount)){\n', '            emit BuyBack(msg.sender);\n', '            msg.sender.transfer(ether_amount);\n', '        }\n', '    }\n', '\n', '    /********\n', '                Under SoftCap Section\n', '    *********/\n', '    function refund() public {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.UnderSoftCap);\n', '        require(investors[msg.sender].tokenBalance >0);\n', '        require(investors[msg.sender].icoInvest>0);\n', '\n', '        require (address(this).balance > investors[msg.sender].icoInvest);\n', '\n', '        if (_transfer(msg.sender, this, investors[msg.sender].tokenBalance)){\n', '            emit Refund(msg.sender, investors[msg.sender].icoInvest);\n', '            msg.sender.transfer(investors[msg.sender].icoInvest);\n', '        }\n', '    }\n', '\n', '    function destroyContract() public grantOwner {\n', '        require(mode == ContractMode.UnderSoftCap);\n', '        require((now - icoFinishTime) > REFUND_PERIOD);\n', '        selfdestruct(owner);\n', '    }\n', '    /********\n', '                Permission related\n', '    ********/\n', '\n', '    function transferOwnership(address new_owner) public grantOwner {\n', '        require(contractIsWorking);\n', '        require(new_owner != address(0));\n', '        emit OwnershipTransferred(owner, new_owner);\n', '        owner = new_owner;\n', '    }\n', '\n', '    function setBountyManager(address new_bounty_manager) public grantOwner {\n', '        require(investors[new_bounty_manager].tokenBalance ==0);\n', '        if (mode == ContractMode.Initial) {\n', '            emit BountyManagerAssigned(bountyManager, new_bounty_manager);\n', '            bountyManager = new_bounty_manager;\n', '        } else if (mode == ContractMode.TokenSale) {\n', '            emit BountyManagerAssigned(bountyManager, new_bounty_manager);\n', '            address old_bounty_manager = bountyManager;\n', '            bountyManager              = new_bounty_manager;\n', '            require(_transfer(old_bounty_manager, new_bounty_manager, investors[old_bounty_manager].tokenBalance));\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function setDividendManager(address new_dividend_manager) public grantOwner {\n', '        emit DividendManagerAssigned(dividendManager, new_dividend_manager);\n', '        dividendManager = new_dividend_manager;\n', '    }\n', '\n', '    function setDApp(address new_dapp) public grantOwner {\n', '        emit DAppAssigned(dApp, new_dapp);\n', '        dApp = new_dapp;\n', '    }\n', '\n', '\n', '\n', '    /********\n', '                Security and funds section\n', '    ********/\n', '\n', '    function transferBounty(address _to, uint256 _amount) public grantBountyManager {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.DividendDistribution);\n', '        if (_transfer(bountyManager, _to, _amount)) {\n', '            emit BountyTransfered(_to, _amount);\n', '        }\n', '    }\n', '\n', '    function burnTokens(uint256 tokenAmount) public grantOwner {\n', '        require(contractIsWorking);\n', '        require(mode == ContractMode.DividendDistribution);\n', '        require(investors[msg.sender].tokenBalance > tokenAmount);\n', '\n', '        investors[msg.sender].tokenBalance -= tokenAmount;\n', '        totalSupply = totalSupply.sub(tokenAmount);\n', '        emit BurnToken(tokenAmount);\n', '    }\n', '\n', '    function withdrawFunds(uint wei_value) grantOwner external {\n', '        require(mode != ContractMode.UnderSoftCap);\n', '        require(address(this).balance >= wei_value);\n', '\n', '        emit FundsWithdrawal(msg.sender, wei_value);\n', '        msg.sender.transfer(wei_value);\n', '    }\n', '\n', '    function addFunds() public payable grantOwner {\n', '        require(contractIsWorking);\n', '        emit FundsAdded(msg.sender, msg.value);\n', '    }\n', '\n', '    function pauseContract() public grantOwner {\n', '        require(contractIsWorking);\n', '        contractIsWorking = false;\n', '        emit Handbrake(mode, contractIsWorking);\n', '    }\n', '\n', '    function restoreContract() public grantOwner {\n', '        require(!contractIsWorking);\n', '        contractIsWorking = true;\n', '        emit Handbrake(mode, contractIsWorking);\n', '    }\n', '\n', '    /********\n', '                Helper functions\n', '    ********/\n', '    function calcTokenToWei(uint256 token_amount) internal view returns (uint256) {\n', '        return buyBackPriceWei.mul(token_amount).div(ONE_TOKEN);\n', '    }\n', '}']