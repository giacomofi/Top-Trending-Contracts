['pragma solidity ^0.4.18;\n', '\n', '/*\n', ' * Ponzi Trust Token Smart Contracts \n', ' * Code is published on https://github.com/PonziTrust/Token\n', ' * Ponzi Trust https://ponzitrust.com/\n', '*/\n', '\n', '\n', '// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20 {\n', '  function name() public view returns (string);\n', '  function symbol() public view returns (string);\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/issues/677\n', 'contract ERC677Token {\n', '  function transferAndCall(address receiver, uint amount, bytes data) public returns (bool success);\n', '  function contractFallback(address to, uint value, bytes data) internal;\n', '  function isContract(address addr) internal view returns (bool hasCode);\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/issues/677\n', 'contract ERC677Recipient {\n', '  function tokenFallback(address from, uint256 amount, bytes data) public returns (bool success);\n', '}  \n', '\n', '\n', '/**\n', '* @dev The token implement ERC20 and ERC677 standarts(see above).\n', '* use Withdrawal, Restricting Access, State Machine patterns.\n', '* see: http://solidity.readthedocs.io/en/develop/common-patterns.html\n', '* use SafeMath library, see above.\n', '* The owner can intervene in the work of the token only before the expiration\n', '* DURATION_TO_ACCESS_FOR_OWNER = 144 days. Contract has thee state of working:\n', '* 1.PreSale - only owner can access to transfer tokens. 2.Sale - contract to sale\n', '* tokens by func byToken() of fallback, contact and owner can access to transfer tokens. \n', '* Token price setting by owner or price setter. 3.PublicUse - anyone can transfer tokens.\n', '*/\n', 'contract PonziToken is ERC20, ERC677Token {\n', '  using SafeMath for uint256;\n', '\n', '  enum State {\n', '    PreSale,   //PRE_SALE_STR\n', '    Sale,      //SALE_STR\n', '    PublicUse  //PUBLIC_USE_STR\n', '  }\n', '  // we need returns string representation of state\n', '  // because enums are not supported by the ABI, they are just supported by Solidity.\n', '  // see: http://solidity.readthedocs.io/en/develop/frequently-asked-questions.html#if-i-return-an-enum-i-only-get-integer-values-in-web3-js-how-to-get-the-named-values\n', '  string private constant PRE_SALE_STR = "PreSale";\n', '  string private constant SALE_STR = "Sale";\n', '  string private constant PUBLIC_USE_STR = "PublicUse";\n', '  State private m_state;\n', '\n', '  uint256 private constant DURATION_TO_ACCESS_FOR_OWNER = 144 days;\n', '  \n', '  uint256 private m_maxTokensPerAddress;\n', '  uint256 private m_firstEntranceToSaleStateUNIX;\n', '  address private m_owner;\n', '  address private m_priceSetter;\n', '  address private m_bank;\n', '  uint256 private m_tokenPriceInWei;\n', '  uint256 private m_totalSupply;\n', '  uint256 private m_myDebtInWei;\n', '  string private m_name;\n', '  string private m_symbol;\n', '  uint8 private m_decimals;\n', '  bool private m_isFixedTokenPrice;\n', '  \n', '  mapping(address => mapping (address => uint256)) private m_allowed;\n', '  mapping(address => uint256) private m_balances;\n', '  mapping(address => uint256) private m_pendingWithdrawals;\n', '\n', '////////////////\n', '// EVENTS\n', '//\n', '  event StateChanged(address indexed who, State newState);\n', '  event PriceChanged(address indexed who, uint newPrice, bool isFixed);\n', '  event TokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\n', '  event Withdrawal(address indexed to, uint sumInWei);\n', '\n', '////////////////\n', '// MODIFIERS - Restricting Access and State Machine patterns\n', '//\n', '  modifier atState(State state) {\n', '    require(m_state == state);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == m_owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwnerOrAtState(State state) {\n', '    require(msg.sender == m_owner || m_state == state); \n', '    _;\n', '  }\n', '  \n', '  modifier checkAccess() {\n', '    require(m_firstEntranceToSaleStateUNIX == 0 // solium-disable-line indentation, operator-whitespace\n', '      || now.sub(m_firstEntranceToSaleStateUNIX) <= DURATION_TO_ACCESS_FOR_OWNER \n', '      || m_state != State.PublicUse\n', '    ); \n', '    _;\n', '    // owner has not access if duration To Access For Owner was passed \n', '    // and (&&) contract in PublicUse state.\n', '  }\n', '  \n', '  modifier validRecipient(address recipient) {\n', '    require(recipient != address(0) && recipient != address(this));\n', '    _;\n', '  }\n', '\n', '///////////////\n', '// CONSTRUCTOR\n', '//  \n', '  /**\n', '  * @dev Constructor PonziToken.\n', '  */\n', '  function PonziToken() public {\n', '    m_owner = msg.sender;\n', '    m_bank = msg.sender;\n', '    m_state = State.PreSale;\n', '    m_decimals = 8;\n', '    m_name = "Ponzi";\n', '    m_symbol = "PT";\n', '  }\n', '\n', '  /**\n', '  * do not forget about:\n', '  * https://medium.com/codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\n', '  * \n', '  * @dev Initialize the contract, only owner can call and only once.\n', '  * @return Whether successful or not.\n', '  */\n', '  function initContract() \n', '    public \n', '    onlyOwner() \n', '    returns (bool)\n', '  {\n', '    require(m_maxTokensPerAddress == 0 && m_decimals > 0);\n', '    m_maxTokensPerAddress = uint256(1000).mul(uint256(10)**uint256(m_decimals));\n', '\n', '    m_totalSupply = uint256(100000000).mul(uint256(10)**uint256(m_decimals));\n', '    // 70% for owner\n', '    m_balances[msg.sender] = m_totalSupply.mul(uint256(70)).div(uint256(100));\n', '    // 30% for sale\n', '    m_balances[address(this)] = m_totalSupply.sub(m_balances[msg.sender]);\n', '\n', '    // allow owner to transfer token from this  \n', '    m_allowed[address(this)][m_owner] = m_balances[address(this)];\n', '    return true;\n', '  }\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '// get from https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\n', '//\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return m_balances[owner];\n', '  }\n', '  \n', '  /**\n', '  * @dev The name of the token.\n', '  * @return The name of the token.\n', '  */\n', '  function name() public view returns (string) {\n', '    return m_name;\n', '  }\n', '\n', '  /**\n', '  * @dev The symbol of the token.\n', '  * @return The symbol of the token.\n', '  */\n', '  function symbol() public view returns (string) {\n', '    return m_symbol;\n', '  }\n', '\n', '  /**\n', '  * @dev The number of decimals the token.\n', '  * @return The number of decimals the token.\n', '  * @notice Uses - e.g. 8, means to divide the token.\n', '  * amount by 100000000 to get its user representation.\n', '  */\n', '  function decimals() public view returns (uint8) {\n', '    return m_decimals;\n', '  }\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence.\n', '  * @return Total number of tokens in existence.\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return m_totalSupply;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transfer(address to, uint256 value) \n', '    public \n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool) \n', '  {\n', '    // require(value <= m_balances[msg.sender]);\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another.\n', '   * @param from Address The address which you want to send tokens from.\n', '   * @param to Address The address which you want to transfer to.\n', '   * @param value Uint256 the amount of tokens to be transferred.\n', '   * @return Whether successful or not.\n', '   */\n', '  function transferFrom(address from, address to, uint256 value) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool) \n', '  {\n', '    // require(value <= m_balances[from]);\n', '    // require(value <= m_allowed[from][msg.sender]);\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[from] = m_balances[from].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    m_allowed[from][msg.sender] = m_allowed[from][msg.sender].sub(value);\n', '    Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param value The amount of tokens to be spent.\n', '   * @return Whether successful or not.\n', '   */\n', '  function approve(address spender, uint256 value) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    // allowance to zero by calling `approve(spender,0)` if it is not\n', '    // already 0 to mitigate the race condition described here:\n', '    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((value == 0) || (m_allowed[msg.sender][spender] == 0));\n', '\n', '    m_allowed[msg.sender][spender] = value;\n', '    Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param owner Address The address which owns the funds.\n', '   * @param spender Address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address owner, address spender) \n', '    public \n', '    view\n', '    returns (uint256) \n', '  {\n', '    return m_allowed[owner][spender];\n', '  }\n', '  \n', '  /**\n', '   * approve should be called when allowed[spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol.\n', '   *\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param addedValue The amount of tokens to increase the allowance by.\n', '   * @return Whether successful or not.\n', '   */\n', '  function increaseApproval(address spender, uint addedValue) \n', '    public \n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    m_allowed[msg.sender][spender] = m_allowed[msg.sender][spender].add(addedValue);\n', '    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '   /**\n', '   * Approve should be called when allowed[spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol.\n', '   *\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '   * @return Whether successful or not.\n', '   */\n', '  function decreaseApproval(address spender, uint subtractedValue) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    uint oldValue = m_allowed[msg.sender][spender];\n', '    if (subtractedValue > oldValue) {\n', '      m_allowed[msg.sender][spender] = 0;\n', '    } else {\n', '      m_allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\n', '    }\n', '    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '///////////////////\n', '// ERC677 Methods\n', '//\n', '  /**\n', '  * @dev Transfer token to a contract address with additional data if the recipient is a contact.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  * @param extraData The extra data to be passed to the receiving contract.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transferAndCall(address to, uint256 value, bytes extraData) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool)\n', '  {\n', '    // require(value <= m_balances[msg.sender]);\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    Transfer(msg.sender, to, value);\n', '    if (isContract(to)) {\n', '      contractFallback(to, value, extraData);\n', '      Transfer(msg.sender, to, value, extraData);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token all tokens to a contract address with additional data if the recipient is a contact.\n', '  * @param to The address to transfer all to.\n', '  * @param extraData The extra data to be passed to the receiving contract.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transferAllAndCall(address to, bytes extraData) \n', '    external\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    returns (bool) \n', '  {\n', '    return transferAndCall(to, m_balances[msg.sender], extraData);\n', '  }\n', '  \n', '  /**\n', '  * @dev Call ERC677 tokenFallback for ERC677Recipient contract.\n', '  * @param to The address of ERC677Recipient.\n', '  * @param value Amount of tokens with was sended\n', '  * @param data Sended to ERC677Recipient.\n', '  * @return Whether contract or not.\n', '  */\n', '  function contractFallback(address to, uint value, bytes data)\n', '    internal\n', '  {\n', '    ERC677Recipient recipient = ERC677Recipient(to);\n', '    recipient.tokenFallback(msg.sender, value, data);\n', '  }\n', '\n', '  /**\n', '  * @dev Check addr if is contract.\n', '  * @param addr The address that checking.\n', '  * @return Whether contract or not.\n', '  */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint length;\n', '    assembly { length := extcodesize(addr) }\n', '    return length > 0;\n', '  }\n', '  \n', '  \n', '///////////////////\n', '// payable Methods\n', '// use withdrawal pattern \n', '// see: http://solidity.readthedocs.io/en/develop/common-patterns.html#withdrawal-from-contracts\n', '// see: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n', '//\n', '  /**\n', '  * Recived ETH converted to tokens amount for price. sender has max limit for tokens \n', '  * amount as m_maxTokensPerAddress - balanceOf(sender). if amount <= max limit\n', '  * then transfer amount from this to sender and 95%ETH to bank, 5%ETH to owner.\n', '  * else amount > max limit then we calc cost of max limit of tokens,\n', '  * store this cost in m_pendingWithdrawals[sender] and m_myDebtInWei and \n', '  * transfer max limit of tokens from this to sender and 95% max limit cost to bank\n', '  * 5% max limit cost to owner.\n', '  *\n', '  * @dev Contract receive ETH (payable) from sender and transfer some amount of tokens to him.\n', '  */\n', '  function byTokens() public payable atState(State.Sale) {\n', '    // check if msg.sender can to by tokens \n', '    require(m_balances[msg.sender] < m_maxTokensPerAddress);\n', '\n', '    // get actual token price and set it\n', '    m_tokenPriceInWei = calcTokenPriceInWei();\n', '    \n', '    // check if msg.value has enough for by 1 token\n', '    require(msg.value >= m_tokenPriceInWei);\n', '    \n', '    // calc max available tokens for sender\n', '    uint256 maxAvailableTokens = m_maxTokensPerAddress.sub(m_balances[msg.sender]);\n', '    \n', '    // convert msg.value(wei) to tokens\n', '    uint256 tokensAmount = weiToTokens(msg.value, m_tokenPriceInWei);\n', '    \n', '    if (tokensAmount > maxAvailableTokens) {\n', '      // we CANT transfer all tokens amount, ONLY max available tokens \n', '      // calc cost in wei of max available tokens\n', '      // subtract cost from msg.value and store it as debt for sender\n', '      tokensAmount = maxAvailableTokens;  \n', '      // calc cost\n', '      uint256 tokensAmountCostInWei = tokensToWei(tokensAmount, m_tokenPriceInWei);\n', '      // calc debt\n', '      uint256 debt = msg.value.sub(tokensAmountCostInWei);\n', '      // Withdrawal pattern avoid Re-Entrancy (dont use transfer to unknow address)\n', '      // update pending withdrawals\n', '      m_pendingWithdrawals[msg.sender] = m_pendingWithdrawals[msg.sender].add(debt);\n', '      // update my debt\n', '      m_myDebtInWei = m_myDebtInWei.add(debt);\n', '    }\n', '    // transfer tokensAmount tokens form this to sender\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[address(this)] = m_balances[address(this)].sub(tokensAmount);\n', '    m_balances[msg.sender] = m_balances[msg.sender].add(tokensAmount);\n', '\n', '    // we can transfer eth to owner and bank, because we know that they \n', '    // dont use Re-Entrancy and other attacks.\n', '    // transfer 5% of eht-myDebt to owner\n', '    // owner cant be equal address(0) because this function to be accessible\n', '    // only in State.Sale but owner can be equal address(0), only in State.PublicUse\n', '    // State.Sale not equal State.PublicUse!\n', '    m_owner.transfer(this.balance.sub(m_myDebtInWei).mul(uint256(5)).div(uint256(100)));\n', '    // transfer 95% of eht-myDebt to bank\n', '    // bank cant be equal address(0) see setBank() and PonziToken()\n', '    m_bank.transfer(this.balance.sub(m_myDebtInWei));\n', '    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\n', '    Transfer(address(this), msg.sender, tokensAmount);\n', '    TokensSold(tokensAmount, msg.sender, m_tokenPriceInWei); \n', '  }\n', '  \n', '  /**\n', '  * @dev Sender receive his pending withdrawals(if > 0).\n', '  */\n', '  function withdraw() external {\n', '    uint amount = m_pendingWithdrawals[msg.sender];\n', '    require(amount > 0);\n', '    // set zero the pending refund before\n', '    // sending to prevent Re-Entrancy \n', '    m_pendingWithdrawals[msg.sender] = 0;\n', '    m_myDebtInWei = m_myDebtInWei.sub(amount);\n', '    msg.sender.transfer(amount);\n', '    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\n', '    Withdrawal(msg.sender, amount);\n', '  }\n', '\n', '  /**\n', '  * @notice http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '  * we dont need recieve ETH always, only in State.Sale from externally accounts.\n', '  *\n', '  * @dev Fallback func, call byTokens().\n', '  */\n', '  function() public payable atState(State.Sale) {\n', '    byTokens();\n', '  }\n', '    \n', '  \n', '////////////////////////\n', '// external view methods\n', '// everyone outside has access \n', '//\n', '  /**\n', '  * @dev Gets the pending withdrawals of the specified address.\n', '  * @param owner The address to query the pending withdrawals of.\n', '  * @return An uint256 representing the amount withdrawals owned by the passed address.\n', '  */\n', '  function pendingWithdrawals(address owner) external view returns (uint256) {\n', '    return m_pendingWithdrawals[owner];\n', '  }\n', '  \n', '  /**\n', '  * @dev Get contract work state.\n', '  * @return Contract work state via string.\n', '  */\n', '  function state() external view returns (string stateString) {\n', '    if (m_state == State.PreSale) {\n', '      stateString = PRE_SALE_STR;\n', '    } else if (m_state == State.Sale) {\n', '      stateString = SALE_STR;\n', '    } else if (m_state == State.PublicUse) {\n', '      stateString = PUBLIC_USE_STR;\n', '    }\n', '  }\n', '  \n', '  /**\n', '  * @dev Get price of one token in wei.\n', '  * @return Price of one token in wei.\n', '  */\n', '  function tokenPriceInWei() public view returns (uint256) {\n', '    return calcTokenPriceInWei();\n', '  }\n', '  \n', '  /**\n', '  * @dev Get address of the bank.\n', '  * @return Address of the bank. \n', '  */\n', '  function bank() external view returns(address) {\n', '    return m_bank;\n', '  }\n', '  \n', '  /**\n', '  * @dev Get timestamp of first entrance to sale state.\n', '  * @return Timestamp of first entrance to sale state.\n', '  */\n', '  function firstEntranceToSaleStateUNIX() \n', '    external\n', '    view \n', '    returns(uint256) \n', '  {\n', '    return m_firstEntranceToSaleStateUNIX;\n', '  }\n', '  \n', '  /**\n', '  * @dev Get address of the price setter.\n', '  * @return Address of the price setter.\n', '  */\n', '  function priceSetter() external view returns (address) {\n', '    return m_priceSetter;\n', '  }\n', '\n', '////////////////////\n', '// public methods\n', '// only for owner\n', '//\n', '  /**\n', '  * @dev Owner do disown.\n', '  */ \n', '  function disown() external atState(State.PublicUse) onlyOwner() {\n', '    delete m_owner;\n', '  }\n', '  \n', '  /**\n', '  * @dev Set state of contract working.\n', '  * @param newState String representation of new state.\n', '  */ \n', '  function setState(string newState) \n', '    external \n', '    onlyOwner()\n', '    checkAccess()\n', '  {\n', '    if (keccak256(newState) == keccak256(PRE_SALE_STR)) {\n', '      m_state = State.PreSale;\n', '    } else if (keccak256(newState) == keccak256(SALE_STR)) {\n', '      if (m_firstEntranceToSaleStateUNIX == 0) \n', '        m_firstEntranceToSaleStateUNIX = now;\n', '        \n', '      m_state = State.Sale;\n', '    } else if (keccak256(newState) == keccak256(PUBLIC_USE_STR)) {\n', '      m_state = State.PublicUse;\n', '    } else {\n', '      // if newState not valid string\n', '      revert();\n', '    }\n', '    StateChanged(msg.sender, m_state);\n', '  }\n', '\n', '  /**\n', '  * If token price not fix then actual price \n', '  * always will be tokenPriceInWeiForDay(day).\n', '  *\n', '  * @dev Set price of one token in wei and fix it.\n', '  * @param newTokenPriceInWei Price of one token in wei.\n', '  */ \n', '  function setAndFixTokenPriceInWei(uint256 newTokenPriceInWei) \n', '    external\n', '    checkAccess()\n', '  {\n', '    require(msg.sender == m_owner || msg.sender == m_priceSetter);\n', '    m_isFixedTokenPrice = true;\n', '    m_tokenPriceInWei = newTokenPriceInWei;\n', '    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\n', '  }\n', '  \n', '  /**\n', '  * If token price is unfixed then actual will be tokenPriceInWeiForDay(day).\n', '  * \n', '  * @dev Set unfix token price to true.\n', '  */\n', '  function unfixTokenPriceInWei() \n', '    external\n', '    checkAccess()\n', '  {\n', '    require(msg.sender == m_owner || msg.sender == m_priceSetter);\n', '    m_isFixedTokenPrice = false;\n', '    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\n', '  }\n', '  \n', '  /**\n', '  * @dev Set the PriceSetter address, which has access to set one token price in wei.\n', '  * @param newPriceSetter The address of new PriceSetter.\n', '  */\n', '  function setPriceSetter(address newPriceSetter) \n', '    external \n', '    onlyOwner() \n', '    checkAccess()\n', '  {\n', '    m_priceSetter = newPriceSetter;\n', '  }\n', '\n', '  /**\n', '  * @dev Set the bank, which receive 95%ETH from tokens sale.\n', '  * @param newBank The address of new bank.\n', '  */\n', '  function setBank(address newBank) \n', '    external\n', '    validRecipient(newBank) \n', '    onlyOwner()\n', '    checkAccess()\n', '  {\n', '    require(newBank != address(0));\n', '    m_bank = newBank;\n', '  }\n', '\n', '////////////////////////\n', '// internal pure methods\n', '//\n', '  /**\n', '  * @dev Convert token to wei.\n', '  * @param tokensAmount Amout of tokens.\n', '  * @param tokenPrice One token price in wei.\n', '  * @return weiAmount Result amount of convertation. \n', '  */\n', '  function tokensToWei(uint256 tokensAmount, uint256 tokenPrice) \n', '    internal\n', '    pure\n', '    returns(uint256 weiAmount)\n', '  {\n', '    weiAmount = tokensAmount.mul(tokenPrice); \n', '  }\n', '  \n', '  /**\n', '  * @dev Conver wei to token.\n', '  * @param weiAmount Wei amout.\n', '  * @param tokenPrice One token price in wei.\n', '  * @return tokensAmount Result amount of convertation.\n', '  */\n', '  function weiToTokens(uint256 weiAmount, uint256 tokenPrice) \n', '    internal \n', '    pure \n', '    returns(uint256 tokensAmount) \n', '  {\n', '    tokensAmount = weiAmount.div(tokenPrice);\n', '  }\n', ' \n', '////////////////////////\n', '// private view methods\n', '//\n', '  /**\n', '  * @dev Get actual token price.\n', '  * @return price One token price in wei. \n', '  */\n', '  function calcTokenPriceInWei() \n', '    private \n', '    view \n', '    returns(uint256 price) \n', '  {\n', '    if (m_isFixedTokenPrice) {\n', '      // price is fixed, return current val\n', '      price = m_tokenPriceInWei;\n', '    } else {\n', '      // price not fixed, we must to calc price\n', '      if (m_firstEntranceToSaleStateUNIX == 0) {\n', '        // if contract dont enter to SaleState then price = 0 \n', '        price = 0;\n', '      } else {\n', '        // calculate day after first Entrance To Sale State\n', '        uint256 day = now.sub(m_firstEntranceToSaleStateUNIX).div(1 days);\n', '        // use special formula for calcutation price\n', '        price = tokenPriceInWeiForDay(day);\n', '      }\n', '    } \n', '  }\n', '  \n', '  /**\n', '  * @dev Get token price for specific day after starting sale tokens.\n', '  * @param day Secific day.\n', '  * @return price One token price in wei for specific day. \n', '  */\n', '  function tokenPriceInWeiForDay(uint256 day) \n', '    private \n', '    view \n', '    returns(uint256 price)\n', '  {\n', '    // day 1:   price 1*10^(decimals) TOKEN = 0.001 ETH\n', '    //          price 1 TOKEN = 1 * 10^(-3) ETH / 10^(decimals), in ETH\n', '    //          convert to wei:\n', '    //          price 1 TOKEN = 1 * 10^(-3) * wei * 10^(-decimals)\n', '    //          price 1 TOKEN = 1 * 10^(-3) * 10^(18) * 10^(-decimals)\n', '    //          price 1 TOKEN = 1 * 10^(15) * 10^(-decimals), in WEI\n', '    \n', '    // day 2:   price 1*10^(decimals) TOKEN = 0.002 ETH;\n', '    //          price 1 TOKEN = 2 * 10^(15) * 10^(-decimals), in WEI\n', '    // ...\n', '    // day 12:  price 1*10^(decimals) TOKEN = 0.012 ETH;\n', '    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\n', '    \n', '    // day >12: price 1*10^(decimals) TOKEN = 0.012 ETH;\n', '    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\n', '\n', '    // from 0 to 11 - sum is 12 days\n', '    if (day <= 11) \n', '      price = day.add(1);// because from >0h to <24h after start day will be 0, \n', '    else                 // but for calc price it must be 1;\n', '      price = 12;\n', '    // convert to WEI\n', '    price = price.mul(uint256(10**15)).div(10**uint256(m_decimals));\n', '  }\n', '  \n', '  /**\n', '  * @notice It is always must be true, for correct withdrawals and receivers ETH.\n', '  *\n', '  * Check if this.balance >= m_myDebtInWei.\n', '  */\n', '  function checkValidityOfBalance() private view {\n', '    // assertion is not a strict equality of the balance because the contract \n', '    // can be forcibly sent ether without going through the byTokens() func.\n', '    // selfdestruct does not trigger a contract&#39;s fallback function. \n', '    // see: http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    assert(this.balance >= m_myDebtInWei);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', ' * Ponzi Trust Token Smart Contracts \n', ' * Code is published on https://github.com/PonziTrust/Token\n', ' * Ponzi Trust https://ponzitrust.com/\n', '*/\n', '\n', '\n', '// see: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', 'contract ERC20 {\n', '  function name() public view returns (string);\n', '  function symbol() public view returns (string);\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/issues/677\n', 'contract ERC677Token {\n', '  function transferAndCall(address receiver, uint amount, bytes data) public returns (bool success);\n', '  function contractFallback(address to, uint value, bytes data) internal;\n', '  function isContract(address addr) internal view returns (bool hasCode);\n', '  event Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '\n', '// see: https://github.com/ethereum/EIPs/issues/677\n', 'contract ERC677Recipient {\n', '  function tokenFallback(address from, uint256 amount, bytes data) public returns (bool success);\n', '}  \n', '\n', '\n', '/**\n', '* @dev The token implement ERC20 and ERC677 standarts(see above).\n', '* use Withdrawal, Restricting Access, State Machine patterns.\n', '* see: http://solidity.readthedocs.io/en/develop/common-patterns.html\n', '* use SafeMath library, see above.\n', '* The owner can intervene in the work of the token only before the expiration\n', '* DURATION_TO_ACCESS_FOR_OWNER = 144 days. Contract has thee state of working:\n', '* 1.PreSale - only owner can access to transfer tokens. 2.Sale - contract to sale\n', '* tokens by func byToken() of fallback, contact and owner can access to transfer tokens. \n', '* Token price setting by owner or price setter. 3.PublicUse - anyone can transfer tokens.\n', '*/\n', 'contract PonziToken is ERC20, ERC677Token {\n', '  using SafeMath for uint256;\n', '\n', '  enum State {\n', '    PreSale,   //PRE_SALE_STR\n', '    Sale,      //SALE_STR\n', '    PublicUse  //PUBLIC_USE_STR\n', '  }\n', '  // we need returns string representation of state\n', '  // because enums are not supported by the ABI, they are just supported by Solidity.\n', '  // see: http://solidity.readthedocs.io/en/develop/frequently-asked-questions.html#if-i-return-an-enum-i-only-get-integer-values-in-web3-js-how-to-get-the-named-values\n', '  string private constant PRE_SALE_STR = "PreSale";\n', '  string private constant SALE_STR = "Sale";\n', '  string private constant PUBLIC_USE_STR = "PublicUse";\n', '  State private m_state;\n', '\n', '  uint256 private constant DURATION_TO_ACCESS_FOR_OWNER = 144 days;\n', '  \n', '  uint256 private m_maxTokensPerAddress;\n', '  uint256 private m_firstEntranceToSaleStateUNIX;\n', '  address private m_owner;\n', '  address private m_priceSetter;\n', '  address private m_bank;\n', '  uint256 private m_tokenPriceInWei;\n', '  uint256 private m_totalSupply;\n', '  uint256 private m_myDebtInWei;\n', '  string private m_name;\n', '  string private m_symbol;\n', '  uint8 private m_decimals;\n', '  bool private m_isFixedTokenPrice;\n', '  \n', '  mapping(address => mapping (address => uint256)) private m_allowed;\n', '  mapping(address => uint256) private m_balances;\n', '  mapping(address => uint256) private m_pendingWithdrawals;\n', '\n', '////////////////\n', '// EVENTS\n', '//\n', '  event StateChanged(address indexed who, State newState);\n', '  event PriceChanged(address indexed who, uint newPrice, bool isFixed);\n', '  event TokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\n', '  event Withdrawal(address indexed to, uint sumInWei);\n', '\n', '////////////////\n', '// MODIFIERS - Restricting Access and State Machine patterns\n', '//\n', '  modifier atState(State state) {\n', '    require(m_state == state);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == m_owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyOwnerOrAtState(State state) {\n', '    require(msg.sender == m_owner || m_state == state); \n', '    _;\n', '  }\n', '  \n', '  modifier checkAccess() {\n', '    require(m_firstEntranceToSaleStateUNIX == 0 // solium-disable-line indentation, operator-whitespace\n', '      || now.sub(m_firstEntranceToSaleStateUNIX) <= DURATION_TO_ACCESS_FOR_OWNER \n', '      || m_state != State.PublicUse\n', '    ); \n', '    _;\n', '    // owner has not access if duration To Access For Owner was passed \n', '    // and (&&) contract in PublicUse state.\n', '  }\n', '  \n', '  modifier validRecipient(address recipient) {\n', '    require(recipient != address(0) && recipient != address(this));\n', '    _;\n', '  }\n', '\n', '///////////////\n', '// CONSTRUCTOR\n', '//  \n', '  /**\n', '  * @dev Constructor PonziToken.\n', '  */\n', '  function PonziToken() public {\n', '    m_owner = msg.sender;\n', '    m_bank = msg.sender;\n', '    m_state = State.PreSale;\n', '    m_decimals = 8;\n', '    m_name = "Ponzi";\n', '    m_symbol = "PT";\n', '  }\n', '\n', '  /**\n', '  * do not forget about:\n', '  * https://medium.com/codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\n', '  * \n', '  * @dev Initialize the contract, only owner can call and only once.\n', '  * @return Whether successful or not.\n', '  */\n', '  function initContract() \n', '    public \n', '    onlyOwner() \n', '    returns (bool)\n', '  {\n', '    require(m_maxTokensPerAddress == 0 && m_decimals > 0);\n', '    m_maxTokensPerAddress = uint256(1000).mul(uint256(10)**uint256(m_decimals));\n', '\n', '    m_totalSupply = uint256(100000000).mul(uint256(10)**uint256(m_decimals));\n', '    // 70% for owner\n', '    m_balances[msg.sender] = m_totalSupply.mul(uint256(70)).div(uint256(100));\n', '    // 30% for sale\n', '    m_balances[address(this)] = m_totalSupply.sub(m_balances[msg.sender]);\n', '\n', '    // allow owner to transfer token from this  \n', '    m_allowed[address(this)][m_owner] = m_balances[address(this)];\n', '    return true;\n', '  }\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '// get from https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\n', '//\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return m_balances[owner];\n', '  }\n', '  \n', '  /**\n', '  * @dev The name of the token.\n', '  * @return The name of the token.\n', '  */\n', '  function name() public view returns (string) {\n', '    return m_name;\n', '  }\n', '\n', '  /**\n', '  * @dev The symbol of the token.\n', '  * @return The symbol of the token.\n', '  */\n', '  function symbol() public view returns (string) {\n', '    return m_symbol;\n', '  }\n', '\n', '  /**\n', '  * @dev The number of decimals the token.\n', '  * @return The number of decimals the token.\n', '  * @notice Uses - e.g. 8, means to divide the token.\n', '  * amount by 100000000 to get its user representation.\n', '  */\n', '  function decimals() public view returns (uint8) {\n', '    return m_decimals;\n', '  }\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence.\n', '  * @return Total number of tokens in existence.\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return m_totalSupply;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transfer(address to, uint256 value) \n', '    public \n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool) \n', '  {\n', '    // require(value <= m_balances[msg.sender]);\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another.\n', '   * @param from Address The address which you want to send tokens from.\n', '   * @param to Address The address which you want to transfer to.\n', '   * @param value Uint256 the amount of tokens to be transferred.\n', '   * @return Whether successful or not.\n', '   */\n', '  function transferFrom(address from, address to, uint256 value) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool) \n', '  {\n', '    // require(value <= m_balances[from]);\n', '    // require(value <= m_allowed[from][msg.sender]);\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[from] = m_balances[from].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    m_allowed[from][msg.sender] = m_allowed[from][msg.sender].sub(value);\n', '    Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param value The amount of tokens to be spent.\n', '   * @return Whether successful or not.\n', '   */\n', '  function approve(address spender, uint256 value) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    // allowance to zero by calling `approve(spender,0)` if it is not\n', '    // already 0 to mitigate the race condition described here:\n', '    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((value == 0) || (m_allowed[msg.sender][spender] == 0));\n', '\n', '    m_allowed[msg.sender][spender] = value;\n', '    Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param owner Address The address which owns the funds.\n', '   * @param spender Address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address owner, address spender) \n', '    public \n', '    view\n', '    returns (uint256) \n', '  {\n', '    return m_allowed[owner][spender];\n', '  }\n', '  \n', '  /**\n', '   * approve should be called when allowed[spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol.\n', '   *\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param addedValue The amount of tokens to increase the allowance by.\n', '   * @return Whether successful or not.\n', '   */\n', '  function increaseApproval(address spender, uint addedValue) \n', '    public \n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    m_allowed[msg.sender][spender] = m_allowed[msg.sender][spender].add(addedValue);\n', '    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '   /**\n', '   * Approve should be called when allowed[spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol.\n', '   *\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * @param spender The address which will spend the funds.\n', '   * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '   * @return Whether successful or not.\n', '   */\n', '  function decreaseApproval(address spender, uint subtractedValue) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(spender)\n', '    returns (bool) \n', '  {\n', '    uint oldValue = m_allowed[msg.sender][spender];\n', '    if (subtractedValue > oldValue) {\n', '      m_allowed[msg.sender][spender] = 0;\n', '    } else {\n', '      m_allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\n', '    }\n', '    Approval(msg.sender, spender, m_allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '///////////////////\n', '// ERC677 Methods\n', '//\n', '  /**\n', '  * @dev Transfer token to a contract address with additional data if the recipient is a contact.\n', '  * @param to The address to transfer to.\n', '  * @param value The amount to be transferred.\n', '  * @param extraData The extra data to be passed to the receiving contract.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transferAndCall(address to, uint256 value, bytes extraData) \n', '    public\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    validRecipient(to)\n', '    returns (bool)\n', '  {\n', '    // require(value <= m_balances[msg.sender]);\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    m_balances[msg.sender] = m_balances[msg.sender].sub(value);\n', '    m_balances[to] = m_balances[to].add(value);\n', '    Transfer(msg.sender, to, value);\n', '    if (isContract(to)) {\n', '      contractFallback(to, value, extraData);\n', '      Transfer(msg.sender, to, value, extraData);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token all tokens to a contract address with additional data if the recipient is a contact.\n', '  * @param to The address to transfer all to.\n', '  * @param extraData The extra data to be passed to the receiving contract.\n', '  * @return Whether successful or not.\n', '  */\n', '  function transferAllAndCall(address to, bytes extraData) \n', '    external\n', '    onlyOwnerOrAtState(State.PublicUse)\n', '    returns (bool) \n', '  {\n', '    return transferAndCall(to, m_balances[msg.sender], extraData);\n', '  }\n', '  \n', '  /**\n', '  * @dev Call ERC677 tokenFallback for ERC677Recipient contract.\n', '  * @param to The address of ERC677Recipient.\n', '  * @param value Amount of tokens with was sended\n', '  * @param data Sended to ERC677Recipient.\n', '  * @return Whether contract or not.\n', '  */\n', '  function contractFallback(address to, uint value, bytes data)\n', '    internal\n', '  {\n', '    ERC677Recipient recipient = ERC677Recipient(to);\n', '    recipient.tokenFallback(msg.sender, value, data);\n', '  }\n', '\n', '  /**\n', '  * @dev Check addr if is contract.\n', '  * @param addr The address that checking.\n', '  * @return Whether contract or not.\n', '  */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint length;\n', '    assembly { length := extcodesize(addr) }\n', '    return length > 0;\n', '  }\n', '  \n', '  \n', '///////////////////\n', '// payable Methods\n', '// use withdrawal pattern \n', '// see: http://solidity.readthedocs.io/en/develop/common-patterns.html#withdrawal-from-contracts\n', '// see: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n', '//\n', '  /**\n', '  * Recived ETH converted to tokens amount for price. sender has max limit for tokens \n', '  * amount as m_maxTokensPerAddress - balanceOf(sender). if amount <= max limit\n', '  * then transfer amount from this to sender and 95%ETH to bank, 5%ETH to owner.\n', '  * else amount > max limit then we calc cost of max limit of tokens,\n', '  * store this cost in m_pendingWithdrawals[sender] and m_myDebtInWei and \n', '  * transfer max limit of tokens from this to sender and 95% max limit cost to bank\n', '  * 5% max limit cost to owner.\n', '  *\n', '  * @dev Contract receive ETH (payable) from sender and transfer some amount of tokens to him.\n', '  */\n', '  function byTokens() public payable atState(State.Sale) {\n', '    // check if msg.sender can to by tokens \n', '    require(m_balances[msg.sender] < m_maxTokensPerAddress);\n', '\n', '    // get actual token price and set it\n', '    m_tokenPriceInWei = calcTokenPriceInWei();\n', '    \n', '    // check if msg.value has enough for by 1 token\n', '    require(msg.value >= m_tokenPriceInWei);\n', '    \n', '    // calc max available tokens for sender\n', '    uint256 maxAvailableTokens = m_maxTokensPerAddress.sub(m_balances[msg.sender]);\n', '    \n', '    // convert msg.value(wei) to tokens\n', '    uint256 tokensAmount = weiToTokens(msg.value, m_tokenPriceInWei);\n', '    \n', '    if (tokensAmount > maxAvailableTokens) {\n', '      // we CANT transfer all tokens amount, ONLY max available tokens \n', '      // calc cost in wei of max available tokens\n', '      // subtract cost from msg.value and store it as debt for sender\n', '      tokensAmount = maxAvailableTokens;  \n', '      // calc cost\n', '      uint256 tokensAmountCostInWei = tokensToWei(tokensAmount, m_tokenPriceInWei);\n', '      // calc debt\n', '      uint256 debt = msg.value.sub(tokensAmountCostInWei);\n', '      // Withdrawal pattern avoid Re-Entrancy (dont use transfer to unknow address)\n', '      // update pending withdrawals\n', '      m_pendingWithdrawals[msg.sender] = m_pendingWithdrawals[msg.sender].add(debt);\n', '      // update my debt\n', '      m_myDebtInWei = m_myDebtInWei.add(debt);\n', '    }\n', '    // transfer tokensAmount tokens form this to sender\n', '    // SafeMath.sub will already throw if this condition is not met\n', '    m_balances[address(this)] = m_balances[address(this)].sub(tokensAmount);\n', '    m_balances[msg.sender] = m_balances[msg.sender].add(tokensAmount);\n', '\n', '    // we can transfer eth to owner and bank, because we know that they \n', '    // dont use Re-Entrancy and other attacks.\n', '    // transfer 5% of eht-myDebt to owner\n', '    // owner cant be equal address(0) because this function to be accessible\n', '    // only in State.Sale but owner can be equal address(0), only in State.PublicUse\n', '    // State.Sale not equal State.PublicUse!\n', '    m_owner.transfer(this.balance.sub(m_myDebtInWei).mul(uint256(5)).div(uint256(100)));\n', '    // transfer 95% of eht-myDebt to bank\n', '    // bank cant be equal address(0) see setBank() and PonziToken()\n', '    m_bank.transfer(this.balance.sub(m_myDebtInWei));\n', '    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\n', '    Transfer(address(this), msg.sender, tokensAmount);\n', '    TokensSold(tokensAmount, msg.sender, m_tokenPriceInWei); \n', '  }\n', '  \n', '  /**\n', '  * @dev Sender receive his pending withdrawals(if > 0).\n', '  */\n', '  function withdraw() external {\n', '    uint amount = m_pendingWithdrawals[msg.sender];\n', '    require(amount > 0);\n', '    // set zero the pending refund before\n', '    // sending to prevent Re-Entrancy \n', '    m_pendingWithdrawals[msg.sender] = 0;\n', '    m_myDebtInWei = m_myDebtInWei.sub(amount);\n', '    msg.sender.transfer(amount);\n', '    checkValidityOfBalance(); // this.balance >= m_myDebtInWei\n', '    Withdrawal(msg.sender, amount);\n', '  }\n', '\n', '  /**\n', '  * @notice http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '  * we dont need recieve ETH always, only in State.Sale from externally accounts.\n', '  *\n', '  * @dev Fallback func, call byTokens().\n', '  */\n', '  function() public payable atState(State.Sale) {\n', '    byTokens();\n', '  }\n', '    \n', '  \n', '////////////////////////\n', '// external view methods\n', '// everyone outside has access \n', '//\n', '  /**\n', '  * @dev Gets the pending withdrawals of the specified address.\n', '  * @param owner The address to query the pending withdrawals of.\n', '  * @return An uint256 representing the amount withdrawals owned by the passed address.\n', '  */\n', '  function pendingWithdrawals(address owner) external view returns (uint256) {\n', '    return m_pendingWithdrawals[owner];\n', '  }\n', '  \n', '  /**\n', '  * @dev Get contract work state.\n', '  * @return Contract work state via string.\n', '  */\n', '  function state() external view returns (string stateString) {\n', '    if (m_state == State.PreSale) {\n', '      stateString = PRE_SALE_STR;\n', '    } else if (m_state == State.Sale) {\n', '      stateString = SALE_STR;\n', '    } else if (m_state == State.PublicUse) {\n', '      stateString = PUBLIC_USE_STR;\n', '    }\n', '  }\n', '  \n', '  /**\n', '  * @dev Get price of one token in wei.\n', '  * @return Price of one token in wei.\n', '  */\n', '  function tokenPriceInWei() public view returns (uint256) {\n', '    return calcTokenPriceInWei();\n', '  }\n', '  \n', '  /**\n', '  * @dev Get address of the bank.\n', '  * @return Address of the bank. \n', '  */\n', '  function bank() external view returns(address) {\n', '    return m_bank;\n', '  }\n', '  \n', '  /**\n', '  * @dev Get timestamp of first entrance to sale state.\n', '  * @return Timestamp of first entrance to sale state.\n', '  */\n', '  function firstEntranceToSaleStateUNIX() \n', '    external\n', '    view \n', '    returns(uint256) \n', '  {\n', '    return m_firstEntranceToSaleStateUNIX;\n', '  }\n', '  \n', '  /**\n', '  * @dev Get address of the price setter.\n', '  * @return Address of the price setter.\n', '  */\n', '  function priceSetter() external view returns (address) {\n', '    return m_priceSetter;\n', '  }\n', '\n', '////////////////////\n', '// public methods\n', '// only for owner\n', '//\n', '  /**\n', '  * @dev Owner do disown.\n', '  */ \n', '  function disown() external atState(State.PublicUse) onlyOwner() {\n', '    delete m_owner;\n', '  }\n', '  \n', '  /**\n', '  * @dev Set state of contract working.\n', '  * @param newState String representation of new state.\n', '  */ \n', '  function setState(string newState) \n', '    external \n', '    onlyOwner()\n', '    checkAccess()\n', '  {\n', '    if (keccak256(newState) == keccak256(PRE_SALE_STR)) {\n', '      m_state = State.PreSale;\n', '    } else if (keccak256(newState) == keccak256(SALE_STR)) {\n', '      if (m_firstEntranceToSaleStateUNIX == 0) \n', '        m_firstEntranceToSaleStateUNIX = now;\n', '        \n', '      m_state = State.Sale;\n', '    } else if (keccak256(newState) == keccak256(PUBLIC_USE_STR)) {\n', '      m_state = State.PublicUse;\n', '    } else {\n', '      // if newState not valid string\n', '      revert();\n', '    }\n', '    StateChanged(msg.sender, m_state);\n', '  }\n', '\n', '  /**\n', '  * If token price not fix then actual price \n', '  * always will be tokenPriceInWeiForDay(day).\n', '  *\n', '  * @dev Set price of one token in wei and fix it.\n', '  * @param newTokenPriceInWei Price of one token in wei.\n', '  */ \n', '  function setAndFixTokenPriceInWei(uint256 newTokenPriceInWei) \n', '    external\n', '    checkAccess()\n', '  {\n', '    require(msg.sender == m_owner || msg.sender == m_priceSetter);\n', '    m_isFixedTokenPrice = true;\n', '    m_tokenPriceInWei = newTokenPriceInWei;\n', '    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\n', '  }\n', '  \n', '  /**\n', '  * If token price is unfixed then actual will be tokenPriceInWeiForDay(day).\n', '  * \n', '  * @dev Set unfix token price to true.\n', '  */\n', '  function unfixTokenPriceInWei() \n', '    external\n', '    checkAccess()\n', '  {\n', '    require(msg.sender == m_owner || msg.sender == m_priceSetter);\n', '    m_isFixedTokenPrice = false;\n', '    PriceChanged(msg.sender, m_tokenPriceInWei, m_isFixedTokenPrice);\n', '  }\n', '  \n', '  /**\n', '  * @dev Set the PriceSetter address, which has access to set one token price in wei.\n', '  * @param newPriceSetter The address of new PriceSetter.\n', '  */\n', '  function setPriceSetter(address newPriceSetter) \n', '    external \n', '    onlyOwner() \n', '    checkAccess()\n', '  {\n', '    m_priceSetter = newPriceSetter;\n', '  }\n', '\n', '  /**\n', '  * @dev Set the bank, which receive 95%ETH from tokens sale.\n', '  * @param newBank The address of new bank.\n', '  */\n', '  function setBank(address newBank) \n', '    external\n', '    validRecipient(newBank) \n', '    onlyOwner()\n', '    checkAccess()\n', '  {\n', '    require(newBank != address(0));\n', '    m_bank = newBank;\n', '  }\n', '\n', '////////////////////////\n', '// internal pure methods\n', '//\n', '  /**\n', '  * @dev Convert token to wei.\n', '  * @param tokensAmount Amout of tokens.\n', '  * @param tokenPrice One token price in wei.\n', '  * @return weiAmount Result amount of convertation. \n', '  */\n', '  function tokensToWei(uint256 tokensAmount, uint256 tokenPrice) \n', '    internal\n', '    pure\n', '    returns(uint256 weiAmount)\n', '  {\n', '    weiAmount = tokensAmount.mul(tokenPrice); \n', '  }\n', '  \n', '  /**\n', '  * @dev Conver wei to token.\n', '  * @param weiAmount Wei amout.\n', '  * @param tokenPrice One token price in wei.\n', '  * @return tokensAmount Result amount of convertation.\n', '  */\n', '  function weiToTokens(uint256 weiAmount, uint256 tokenPrice) \n', '    internal \n', '    pure \n', '    returns(uint256 tokensAmount) \n', '  {\n', '    tokensAmount = weiAmount.div(tokenPrice);\n', '  }\n', ' \n', '////////////////////////\n', '// private view methods\n', '//\n', '  /**\n', '  * @dev Get actual token price.\n', '  * @return price One token price in wei. \n', '  */\n', '  function calcTokenPriceInWei() \n', '    private \n', '    view \n', '    returns(uint256 price) \n', '  {\n', '    if (m_isFixedTokenPrice) {\n', '      // price is fixed, return current val\n', '      price = m_tokenPriceInWei;\n', '    } else {\n', '      // price not fixed, we must to calc price\n', '      if (m_firstEntranceToSaleStateUNIX == 0) {\n', '        // if contract dont enter to SaleState then price = 0 \n', '        price = 0;\n', '      } else {\n', '        // calculate day after first Entrance To Sale State\n', '        uint256 day = now.sub(m_firstEntranceToSaleStateUNIX).div(1 days);\n', '        // use special formula for calcutation price\n', '        price = tokenPriceInWeiForDay(day);\n', '      }\n', '    } \n', '  }\n', '  \n', '  /**\n', '  * @dev Get token price for specific day after starting sale tokens.\n', '  * @param day Secific day.\n', '  * @return price One token price in wei for specific day. \n', '  */\n', '  function tokenPriceInWeiForDay(uint256 day) \n', '    private \n', '    view \n', '    returns(uint256 price)\n', '  {\n', '    // day 1:   price 1*10^(decimals) TOKEN = 0.001 ETH\n', '    //          price 1 TOKEN = 1 * 10^(-3) ETH / 10^(decimals), in ETH\n', '    //          convert to wei:\n', '    //          price 1 TOKEN = 1 * 10^(-3) * wei * 10^(-decimals)\n', '    //          price 1 TOKEN = 1 * 10^(-3) * 10^(18) * 10^(-decimals)\n', '    //          price 1 TOKEN = 1 * 10^(15) * 10^(-decimals), in WEI\n', '    \n', '    // day 2:   price 1*10^(decimals) TOKEN = 0.002 ETH;\n', '    //          price 1 TOKEN = 2 * 10^(15) * 10^(-decimals), in WEI\n', '    // ...\n', '    // day 12:  price 1*10^(decimals) TOKEN = 0.012 ETH;\n', '    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\n', '    \n', '    // day >12: price 1*10^(decimals) TOKEN = 0.012 ETH;\n', '    //          price 1 TOKEN = 12 * 10^(15) * 10^(-decimals), in WEI\n', '\n', '    // from 0 to 11 - sum is 12 days\n', '    if (day <= 11) \n', '      price = day.add(1);// because from >0h to <24h after start day will be 0, \n', '    else                 // but for calc price it must be 1;\n', '      price = 12;\n', '    // convert to WEI\n', '    price = price.mul(uint256(10**15)).div(10**uint256(m_decimals));\n', '  }\n', '  \n', '  /**\n', '  * @notice It is always must be true, for correct withdrawals and receivers ETH.\n', '  *\n', '  * Check if this.balance >= m_myDebtInWei.\n', '  */\n', '  function checkValidityOfBalance() private view {\n', '    // assertion is not a strict equality of the balance because the contract \n', '    // can be forcibly sent ether without going through the byTokens() func.\n', "    // selfdestruct does not trigger a contract's fallback function. \n", '    // see: http://solidity.readthedocs.io/en/develop/contracts.html#fallback-function\n', '    assert(this.balance >= m_myDebtInWei);\n', '  }\n', '}']
