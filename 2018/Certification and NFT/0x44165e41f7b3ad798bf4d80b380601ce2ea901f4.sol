['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title General MultiEventsHistory user.\n', ' *\n', ' */\n', 'contract MultiEventsHistoryAdapter {\n', '\n', '    /**\n', '    *   @dev It is address of MultiEventsHistory caller assuming we are inside of delegate call.\n', '    */\n', '    function _self() constant internal returns (address) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', '/// @title Fund Tokens Platform Emitter.\n', '///\n', '/// Contains all the original event emitting function definitions and events.\n', '/// In case of new events needed later, additional emitters can be developed.\n', '/// All the functions is meant to be called using delegatecall.\n', 'contract Emitter is MultiEventsHistoryAdapter {\n', '\n', '    event Transfer(address indexed from, address indexed to, bytes32 indexed symbol, uint value, string reference);\n', '    event Issue(bytes32 indexed symbol, uint value, address indexed by);\n', '    event Revoke(bytes32 indexed symbol, uint value, address indexed by);\n', '    event OwnershipChange(address indexed from, address indexed to, bytes32 indexed symbol);\n', '    event Approve(address indexed from, address indexed spender, bytes32 indexed symbol, uint value);\n', '    event Recovery(address indexed from, address indexed to, address by);\n', '    event Error(uint errorCode);\n', '\n', '    function emitTransfer(address _from, address _to, bytes32 _symbol, uint _value, string _reference) public {\n', '        Transfer(_from, _to, _symbol, _value, _reference);\n', '    }\n', '\n', '    function emitIssue(bytes32 _symbol, uint _value, address _by) public {\n', '        Issue(_symbol, _value, _by);\n', '    }\n', '\n', '    function emitRevoke(bytes32 _symbol, uint _value, address _by) public {\n', '        Revoke(_symbol, _value, _by);\n', '    }\n', '\n', '    function emitOwnershipChange(address _from, address _to, bytes32 _symbol) public {\n', '        OwnershipChange(_from, _to, _symbol);\n', '    }\n', '\n', '    function emitApprove(address _from, address _spender, bytes32 _symbol, uint _value) public {\n', '        Approve(_from, _spender, _symbol, _value);\n', '    }\n', '\n', '    function emitRecovery(address _from, address _to, address _by) public {\n', '        Recovery(_from, _to, _by);\n', '    }\n', '\n', '    function emitError(uint _errorCode) public {\n', '        Error(_errorCode);\n', '    }\n', '}\n', '\n', '\n', 'contract ProxyEventsEmitter {\n', '    function emitTransfer(address _from, address _to, uint _value) public;\n', '    function emitApprove(address _from, address _spender, uint _value) public;\n', '}\n', '\n', '\n', '/// @title Fund Tokens Platform.\n', '///\n', '/// Platform uses MultiEventsHistory contract to keep events, so that in case it needs to be redeployed\n', '/// at some point, all the events keep appearing at the same place.\n', '///\n', '/// Every asset is meant to be used through a proxy contract. Only one proxy contract have access\n', '/// rights for a particular asset.\n', '///\n', '/// Features: transfers, allowances, supply adjustments, lost wallet access recovery.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', '/// didn&#39;t happen yet.\n', '/// BMCPlatformInterface compatibility\n', 'contract ATxPlatform is Object, Emitter {\n', '\n', '    uint constant ATX_PLATFORM_SCOPE = 80000;\n', '    uint constant ATX_PLATFORM_PROXY_ALREADY_EXISTS = ATX_PLATFORM_SCOPE + 1;\n', '    uint constant ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF = ATX_PLATFORM_SCOPE + 2;\n', '    uint constant ATX_PLATFORM_INVALID_VALUE = ATX_PLATFORM_SCOPE + 3;\n', '    uint constant ATX_PLATFORM_INSUFFICIENT_BALANCE = ATX_PLATFORM_SCOPE + 4;\n', '    uint constant ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE = ATX_PLATFORM_SCOPE + 5;\n', '    uint constant ATX_PLATFORM_ASSET_ALREADY_ISSUED = ATX_PLATFORM_SCOPE + 6;\n', '    uint constant ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE = ATX_PLATFORM_SCOPE + 7;\n', '    uint constant ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET = ATX_PLATFORM_SCOPE + 8;\n', '    uint constant ATX_PLATFORM_SUPPLY_OVERFLOW = ATX_PLATFORM_SCOPE + 9;\n', '    uint constant ATX_PLATFORM_NOT_ENOUGH_TOKENS = ATX_PLATFORM_SCOPE + 10;\n', '    uint constant ATX_PLATFORM_INVALID_NEW_OWNER = ATX_PLATFORM_SCOPE + 11;\n', '    uint constant ATX_PLATFORM_ALREADY_TRUSTED = ATX_PLATFORM_SCOPE + 12;\n', '    uint constant ATX_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS = ATX_PLATFORM_SCOPE + 13;\n', '    uint constant ATX_PLATFORM_ASSET_IS_NOT_ISSUED = ATX_PLATFORM_SCOPE + 14;\n', '    uint constant ATX_PLATFORM_INVALID_INVOCATION = ATX_PLATFORM_SCOPE + 15;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /// @title Structure of a particular asset.\n', '    struct Asset {\n', '        uint owner;                       // Asset&#39;s owner id.\n', '        uint totalSupply;                 // Asset&#39;s total supply.\n', '        string name;                      // Asset&#39;s name, for information purposes.\n', '        string description;               // Asset&#39;s description, for information purposes.\n', '        bool isReissuable;                // Indicates if asset have dynamic or fixed supply.\n', '        uint8 baseUnit;                   // Proposed number of decimals.\n', '        mapping(uint => Wallet) wallets;  // Holders wallets.\n', '        mapping(uint => bool) partowners; // Part-owners of an asset; have less access rights than owner\n', '    }\n', '\n', '    /// @title Structure of an asset holder wallet for particular asset.\n', '    struct Wallet {\n', '        uint balance;\n', '        mapping(uint => uint) allowance;\n', '    }\n', '\n', '    /// @title Structure of an asset holder.\n', '    struct Holder {\n', '        address addr;                    // Current address of the holder.\n', '        mapping(address => bool) trust;  // Addresses that are trusted with recovery proocedure.\n', '    }\n', '\n', '    /// @dev Iterable mapping pattern is used for holders.\n', '    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public holdersCount;\n', '    mapping(uint => Holder) public holders;\n', '    mapping(address => uint) holderIndex;\n', '\n', '    /// @dev List of symbols that exist in a platform\n', '    bytes32[] public symbols;\n', '\n', '    /// @dev Asset symbol to asset mapping.\n', '    mapping(bytes32 => Asset) public assets;\n', '\n', '    /// @dev Asset symbol to asset proxy mapping.\n', '    mapping(bytes32 => address) public proxies;\n', '\n', '    /// @dev Co-owners of a platform. Has less access rights than a root contract owner\n', '    mapping(address => bool) public partowners;\n', '\n', '    /// @dev Should use interface of the emitter, but address of events history.\n', '    address public eventsHistory;\n', '\n', '    /// @dev Emits Error if called not by asset owner.\n', '    modifier onlyOwner(bytes32 _symbol) {\n', '        if (isOwner(msg.sender, _symbol)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev UNAUTHORIZED if called not by one of symbol&#39;s partowners or owner\n', '    modifier onlyOneOfOwners(bytes32 _symbol) {\n', '        if (hasAssetRights(msg.sender, _symbol)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev UNAUTHORIZED if called not by one of partowners or contract&#39;s owner\n', '    modifier onlyOneOfContractOwners() {\n', '        if (contractOwner == msg.sender || partowners[msg.sender]) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev Emits Error if called not by asset proxy.\n', '    modifier onlyProxy(bytes32 _symbol) {\n', '        if (proxies[_symbol] == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev Emits Error if _from doesn&#39;t trust _to.\n', '    modifier checkTrust(address _from, address _to) {\n', '        if (isTrusted(_from, _to)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Trust an address to perform recovery procedure for the caller.\n', '    ///\n', '    /// @return success.\n', '    function trust() external returns (uint) {\n', '        uint fromId = _createHolderId(msg.sender);\n', '        // Should trust to another address.\n', '        if (msg.sender == contractOwner) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        // Should trust to yet untrusted.\n', '        if (isTrusted(msg.sender, contractOwner)) {\n', '            return _error(ATX_PLATFORM_ALREADY_TRUSTED);\n', '        }\n', '\n', '        holders[fromId].trust[contractOwner] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Revoke trust to perform recovery procedure from an address.\n', '    ///\n', '    /// @return success.\n', '    function distrust() external checkTrust(msg.sender, contractOwner) returns (uint) {\n', '        holders[getHolderId(msg.sender)].trust[contractOwner] = false;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds a co-owner of a contract. Might be more than one co-owner\n', '    ///\n', '    /// @dev Allowed to only contract onwer\n', '    ///\n', '    /// @param _partowner a co-owner of a contract\n', '    ///\n', '    /// @return result code of an operation\n', '    function addPartOwner(address _partowner) external onlyContractOwner returns (uint) {\n', '        partowners[_partowner] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice emoves a co-owner of a contract\n', '    ///\n', '    /// @dev Should be performed only by root contract owner\n', '    ///\n', '    /// @param _partowner a co-owner of a contract\n', '    ///\n', '    /// @return result code of an operation\n', '    function removePartOwner(address _partowner) external onlyContractOwner returns (uint) {\n', '        delete partowners[_partowner];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sets EventsHstory contract address.\n', '    ///\n', '    /// @dev Can be set only by owner.\n', '    ///\n', '    /// @param _eventsHistory MultiEventsHistory contract address.\n', '    ///\n', '    /// @return success.\n', '    function setupEventsHistory(address _eventsHistory) external onlyContractOwner returns (uint errorCode) {\n', '        eventsHistory = _eventsHistory;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds a co-owner for an asset with provided symbol.\n', '    /// @dev Should be performed by a contract owner or its co-owners\n', '    ///\n', '    /// @param _symbol asset&#39;s symbol\n', '    /// @param _partowner a co-owner of an asset\n', '    ///\n', '    /// @return errorCode result code of an operation\n', '    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {\n', '        uint holderId = _createHolderId(_partowner);\n', '        assets[_symbol].partowners[holderId] = true;\n', '        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Removes a co-owner for an asset with provided symbol.\n', '    /// @dev Should be performed by a contract owner or its co-owners\n', '    ///\n', '    /// @param _symbol asset&#39;s symbol\n', '    /// @param _partowner a co-owner of an asset\n', '    ///\n', '    /// @return errorCode result code of an operation\n', '    function removeAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {\n', '        uint holderId = getHolderId(_partowner);\n', '        delete assets[_symbol].partowners[holderId];\n', '        Emitter(eventsHistory).emitOwnershipChange(_partowner, 0x0, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    function massTransfer(address[] addresses, uint[] values, bytes32 _symbol) external onlyOneOfOwners(_symbol) returns (uint errorCode, uint count) {\n', '        require(addresses.length == values.length);\n', '        require(_symbol != 0x0);\n', '\n', '        uint senderId = _createHolderId(msg.sender);\n', '\n', '        uint success = 0;\n', '        for (uint idx = 0; idx < addresses.length && msg.gas > 110000; ++idx) {\n', '            uint value = values[idx];\n', '\n', '            if (value == 0) {\n', '                _error(ATX_PLATFORM_INVALID_VALUE);\n', '                continue;\n', '            }\n', '\n', '            if (_balanceOf(senderId, _symbol) < value) {\n', '                _error(ATX_PLATFORM_INSUFFICIENT_BALANCE);\n', '                continue;\n', '            }\n', '\n', '            if (msg.sender == addresses[idx]) {\n', '                _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '                continue;\n', '            }\n', '\n', '            uint holderId = _createHolderId(addresses[idx]);\n', '\n', '            _transferDirect(senderId, holderId, value, _symbol);\n', '            Emitter(eventsHistory).emitTransfer(msg.sender, addresses[idx], _symbol, value, "");\n', '\n', '            ++success;\n', '        }\n', '\n', '        return (OK, success);\n', '    }\n', '\n', '    /// @notice Provides a cheap way to get number of symbols registered in a platform\n', '    ///\n', '    /// @return number of symbols\n', '    function symbolsCount() public view returns (uint) {\n', '        return symbols.length;\n', '    }\n', '\n', '    /// @notice Check asset existance.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset existance.\n', '    function isCreated(bytes32 _symbol) public view returns (bool) {\n', '        return assets[_symbol].owner != 0;\n', '    }\n', '\n', '    /// @notice Returns asset decimals.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset decimals.\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8) {\n', '        return assets[_symbol].baseUnit;\n', '    }\n', '\n', '    /// @notice Returns asset name.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset name.\n', '    function name(bytes32 _symbol) public view returns (string) {\n', '        return assets[_symbol].name;\n', '    }\n', '\n', '    /// @notice Returns asset description.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset description.\n', '    function description(bytes32 _symbol) public view returns (string) {\n', '        return assets[_symbol].description;\n', '    }\n', '\n', '    /// @notice Returns asset reissuability.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset reissuability.\n', '    function isReissuable(bytes32 _symbol) public view returns (bool) {\n', '        return assets[_symbol].isReissuable;\n', '    }\n', '\n', '    /// @notice Returns asset owner address.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset owner address.\n', '    function owner(bytes32 _symbol) public view returns (address) {\n', '        return holders[assets[_symbol].owner].addr;\n', '    }\n', '\n', '    /// @notice Check if specified address has asset owner rights.\n', '    ///\n', '    /// @param _owner address to check.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return owner rights availability.\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool) {\n', '        return isCreated(_symbol) && (assets[_symbol].owner == getHolderId(_owner));\n', '    }\n', '\n', '    /// @notice Checks if a specified address has asset owner or co-owner rights.\n', '    ///\n', '    /// @param _owner address to check.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return owner rights availability.\n', '    function hasAssetRights(address _owner, bytes32 _symbol) public view returns (bool) {\n', '        uint holderId = getHolderId(_owner);\n', '        return isCreated(_symbol) && (assets[_symbol].owner == holderId || assets[_symbol].partowners[holderId]);\n', '    }\n', '\n', '    /// @notice Returns asset total supply.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset total supply.\n', '    function totalSupply(bytes32 _symbol) public view returns (uint) {\n', '        return assets[_symbol].totalSupply;\n', '    }\n', '\n', '    /// @notice Returns asset balance for a particular holder.\n', '    ///\n', '    /// @param _holder holder address.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder balance.\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint) {\n', '        return _balanceOf(getHolderId(_holder), _symbol);\n', '    }\n', '\n', '    /// @notice Returns asset balance for a particular holder id.\n', '    ///\n', '    /// @param _holderId holder id.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder balance.\n', '    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {\n', '        return assets[_symbol].wallets[_holderId].balance;\n', '    }\n', '\n', '    /// @notice Returns current address for a particular holder id.\n', '    ///\n', '    /// @param _holderId holder id.\n', '    ///\n', '    /// @return holder address.\n', '    function _address(uint _holderId) public view returns (address) {\n', '        return holders[_holderId].addr;\n', '    }\n', '\n', '    function checkIsAssetPartOwner(bytes32 _symbol, address _partowner) public view returns (bool) {\n', '        require(_partowner != 0x0);\n', '        uint holderId = getHolderId(_partowner);\n', '        return assets[_symbol].partowners[holderId];\n', '    }\n', '\n', '    /// @notice Sets Proxy contract address for a particular asset.\n', '    ///\n', '    /// Can be set only once for each asset, and only by contract owner.\n', '    ///\n', '    /// @param _proxyAddress Proxy contract address.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return success.\n', '    function setProxy(address _proxyAddress, bytes32 _symbol) public onlyOneOfContractOwners returns (uint) {\n', '        if (proxies[_symbol] != 0x0) {\n', '            return ATX_PLATFORM_PROXY_ALREADY_EXISTS;\n', '        }\n', '        proxies[_symbol] = _proxyAddress;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address.\n', '    ///\n', '    /// @param _holder holder address.\n', '    ///\n', '    /// @return holder id.\n', '    function getHolderId(address _holder) public view returns (uint) {\n', '        return holderIndex[_holder];\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _sender transfer initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) public returns (uint) {\n', '        return _transfer(getHolderId(_sender), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Issues new asset token on the platform.\n', '    ///\n', '    /// Tokens issued with this call go straight to contract owner.\n', '    /// Each symbol can be issued only once, and only by contract owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to issue immediately.\n', '    /// @param _name name of the asset.\n', '    /// @param _description description for the asset.\n', '    /// @param _baseUnit number of decimals.\n', '    /// @param _isReissuable dynamic or fixed supply.\n', '    ///\n', '    /// @return success.\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint) {\n', '        return issueAssetToAddress(_symbol, _value, _name, _description, _baseUnit, _isReissuable, msg.sender);\n', '    }\n', '\n', '    /// @notice Issues new asset token on the platform.\n', '    ///\n', '    /// Tokens issued with this call go straight to contract owner.\n', '    /// Each symbol can be issued only once, and only by contract owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to issue immediately.\n', '    /// @param _name name of the asset.\n', '    /// @param _description description for the asset.\n', '    /// @param _baseUnit number of decimals.\n', '    /// @param _isReissuable dynamic or fixed supply.\n', '    /// @param _account address where issued balance will be held\n', '    ///\n', '    /// @return success.\n', '    function issueAssetToAddress(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable, address _account) public onlyOneOfContractOwners returns (uint) {\n', '        // Should have positive value if supply is going to be fixed.\n', '        if (_value == 0 && !_isReissuable) {\n', '            return _error(ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE);\n', '        }\n', '        // Should not be issued yet.\n', '        if (isCreated(_symbol)) {\n', '            return _error(ATX_PLATFORM_ASSET_ALREADY_ISSUED);\n', '        }\n', '        uint holderId = _createHolderId(_account);\n', '        uint creatorId = _account == msg.sender ? holderId : _createHolderId(msg.sender);\n', '\n', '        symbols.push(_symbol);\n', '        assets[_symbol] = Asset(creatorId, _value, _name, _description, _isReissuable, _baseUnit);\n', '        assets[_symbol].wallets[holderId].balance = _value;\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Issues additional asset tokens if the asset have dynamic supply.\n', '    ///\n', '    /// Tokens issued with this call go straight to asset owner.\n', '    /// Can only be called by asset owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of additional tokens to issue.\n', '    ///\n', '    /// @return success.\n', '    function reissueAsset(bytes32 _symbol, uint _value) public onlyOneOfOwners(_symbol) returns (uint) {\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        Asset storage asset = assets[_symbol];\n', '        // Should have dynamic supply.\n', '        if (!asset.isReissuable) {\n', '            return _error(ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET);\n', '        }\n', '        // Resulting total supply should not overflow.\n', '        if (asset.totalSupply + _value < asset.totalSupply) {\n', '            return _error(ATX_PLATFORM_SUPPLY_OVERFLOW);\n', '        }\n', '        uint holderId = getHolderId(msg.sender);\n', '        asset.wallets[holderId].balance = asset.wallets[holderId].balance.add(_value);\n', '        asset.totalSupply = asset.totalSupply.add(_value);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n', '\n', '        _proxyTransferEvent(0, holderId, _value, _symbol);\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Destroys specified amount of senders asset tokens.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to destroy.\n', '    ///\n', '    /// @return success.\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint) {\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        Asset storage asset = assets[_symbol];\n', '        uint holderId = getHolderId(msg.sender);\n', '        // Should have enough tokens.\n', '        if (asset.wallets[holderId].balance < _value) {\n', '            return _error(ATX_PLATFORM_NOT_ENOUGH_TOKENS);\n', '        }\n', '        asset.wallets[holderId].balance = asset.wallets[holderId].balance.sub(_value);\n', '        asset.totalSupply = asset.totalSupply.sub(_value);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitRevoke(_symbol, _value, _address(holderId));\n', '        _proxyTransferEvent(holderId, 0, _value, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Passes asset ownership to specified address.\n', '    ///\n', '    /// Only ownership is changed, balances are not touched.\n', '    /// Can only be called by asset owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _newOwner address to become a new owner.\n', '    ///\n', '    /// @return success.\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public onlyOwner(_symbol) returns (uint) {\n', '        if (_newOwner == 0x0) {\n', '            return _error(ATX_PLATFORM_INVALID_NEW_OWNER);\n', '        }\n', '\n', '        Asset storage asset = assets[_symbol];\n', '        uint newOwnerId = _createHolderId(_newOwner);\n', '        // Should pass ownership to another holder.\n', '        if (asset.owner == newOwnerId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        address oldOwner = _address(asset.owner);\n', '        asset.owner = newOwnerId;\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitOwnershipChange(oldOwner, _newOwner, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check if specified holder trusts an address with recovery procedure.\n', '    ///\n', '    /// @param _from truster.\n', '    /// @param _to trustee.\n', '    ///\n', '    /// @return trust existance.\n', '    function isTrusted(address _from, address _to) public view returns (bool) {\n', '        return holders[getHolderId(_from)].trust[_to];\n', '    }\n', '\n', '    /// @notice Perform recovery procedure.\n', '    ///\n', '    /// Can be invoked by contract owner if he is trusted by sender only.\n', '    ///\n', '    /// This function logic is actually more of an addAccess(uint _holderId, address _to).\n', '    /// It grants another address access to recovery subject wallets.\n', '    /// Can only be called by trustee of recovery subject.\n', '    ///\n', '    /// @param _from holder address to recover from.\n', '    /// @param _to address to grant access to.\n', '    ///\n', '    /// @return success.\n', '    function recover(address _from, address _to) checkTrust(_from, msg.sender) public onlyContractOwner returns (uint errorCode) {\n', '        // We take current holder address because it might not equal _from.\n', '        // It is possible to recover from any old holder address, but event should have the current one.\n', '        address from = holders[getHolderId(_from)].addr;\n', '        holders[getHolderId(_from)].addr = _to;\n', '        holderIndex[_to] = getHolderId(_from);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitRecovery(from, _to, msg.sender);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sets asset spending allowance for a specified spender.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _spender holder address to set allowance to.\n', '    /// @param _value amount to allow.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _sender approve initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public onlyProxy(_symbol) returns (uint) {\n', '        return _approve(_createHolderId(_spender), _value, _symbol, _createHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Returns asset allowance from one holder to another.\n', '    ///\n', '    /// @param _from holder that allowed spending.\n', '    /// @param _spender holder that is allowed to spend.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder to spender allowance.\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint) {\n', '        return _allowance(getHolderId(_from), getHolderId(_spender), _symbol);\n', '    }\n', '\n', '    /// @notice Prforms allowance transfer of asset balance between holders wallets.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _from holder address to take from.\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _sender allowance transfer initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public onlyProxy(_symbol) returns (uint) {\n', '        return _transfer(getHolderId(_from), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    function _transferDirect(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n', '        assets[_symbol].wallets[_fromId].balance = assets[_symbol].wallets[_fromId].balance.sub(_value);\n', '        assets[_symbol].wallets[_toId].balance = assets[_symbol].wallets[_toId].balance.add(_value);\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @dev Performs sanity checks and takes care of allowances adjustment.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _senderId transfer initiator holder id.\n', '    ///\n', '    /// @return success.\n', '    function _transfer(uint _fromId, uint _toId, uint _value, bytes32 _symbol, string _reference, uint _senderId) internal returns (uint) {\n', '        // Should not allow to send to oneself.\n', '        if (_fromId == _toId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        // Should have enough balance.\n', '        if (_balanceOf(_fromId, _symbol) < _value) {\n', '            return _error(ATX_PLATFORM_INSUFFICIENT_BALANCE);\n', '        }\n', '        // Should have enough allowance.\n', '        if (_fromId != _senderId && _allowance(_fromId, _senderId, _symbol) < _value) {\n', '            return _error(ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE);\n', '        }\n', '\n', '        _transferDirect(_fromId, _toId, _value, _symbol);\n', '        // Adjust allowance.\n', '        if (_fromId != _senderId) {\n', '            assets[_symbol].wallets[_fromId].allowance[_senderId] = assets[_symbol].wallets[_fromId].allowance[_senderId].sub(_value);\n', '        }\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitTransfer(_address(_fromId), _address(_toId), _symbol, _value, _reference);\n', '        _proxyTransferEvent(_fromId, _toId, _value, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Ask asset Proxy contract to emit ERC20 compliant Transfer event.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n', '        if (proxies[_symbol] != 0x0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: n/a after HF 4;\n', '            // Recursive Call: safe, all changes already made.\n', '            ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value);\n', '        }\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address, creates it if needed.\n', '    ///\n', '    /// @param _holder holder address.\n', '    ///\n', '    /// @return holder id.\n', '    function _createHolderId(address _holder) internal returns (uint) {\n', '        uint holderId = holderIndex[_holder];\n', '        if (holderId == 0) {\n', '            holderId = ++holdersCount;\n', '            holders[holderId].addr = _holder;\n', '            holderIndex[_holder] = holderId;\n', '        }\n', '        return holderId;\n', '    }\n', '\n', '    /// @notice Sets asset spending allowance for a specified spender.\n', '    ///\n', '    /// Note: to revoke allowance, one needs to set allowance to 0.\n', '    ///\n', '    /// @param _spenderId holder id to set allowance for.\n', '    /// @param _value amount to allow.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _senderId approve initiator holder id.\n', '    ///\n', '    /// @return success.\n', '    function _approve(uint _spenderId, uint _value, bytes32 _symbol, uint _senderId) internal returns (uint) {\n', '        // Asset should exist.\n', '        if (!isCreated(_symbol)) {\n', '            return _error(ATX_PLATFORM_ASSET_IS_NOT_ISSUED);\n', '        }\n', '        // Should allow to another holder.\n', '        if (_senderId == _spenderId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '\n', '        // Double Spend Attack checkpoint\n', '        if (assets[_symbol].wallets[_senderId].allowance[_spenderId] != 0 && _value != 0) {\n', '            return _error(ATX_PLATFORM_INVALID_INVOCATION);\n', '        }\n', '\n', '        assets[_symbol].wallets[_senderId].allowance[_spenderId] = _value;\n', '\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitApprove(_address(_senderId), _address(_spenderId), _symbol, _value);\n', '        if (proxies[_symbol] != 0x0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: n/a after HF 4;\n', '            // Recursive Call: safe, all changes already made.\n', '            ProxyEventsEmitter(proxies[_symbol]).emitApprove(_address(_senderId), _address(_spenderId), _value);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns asset allowance from one holder to another.\n', '    ///\n', '    /// @param _fromId holder id that allowed spending.\n', '    /// @param _toId holder id that is allowed to spend.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder to spender allowance.\n', '    function _allowance(uint _fromId, uint _toId, bytes32 _symbol) internal view returns (uint) {\n', '        return assets[_symbol].wallets[_fromId].allowance[_toId];\n', '    }\n', '\n', '    /// @dev Emits Error event with specified error message.\n', '    /// Should only be used if no state changes happened.\n', '    /// @param _errorCode code of an error\n', '    function _error(uint _errorCode) internal returns (uint) {\n', '        Emitter(eventsHistory).emitError(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title General MultiEventsHistory user.\n', ' *\n', ' */\n', 'contract MultiEventsHistoryAdapter {\n', '\n', '    /**\n', '    *   @dev It is address of MultiEventsHistory caller assuming we are inside of delegate call.\n', '    */\n', '    function _self() constant internal returns (address) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', '/// @title Fund Tokens Platform Emitter.\n', '///\n', '/// Contains all the original event emitting function definitions and events.\n', '/// In case of new events needed later, additional emitters can be developed.\n', '/// All the functions is meant to be called using delegatecall.\n', 'contract Emitter is MultiEventsHistoryAdapter {\n', '\n', '    event Transfer(address indexed from, address indexed to, bytes32 indexed symbol, uint value, string reference);\n', '    event Issue(bytes32 indexed symbol, uint value, address indexed by);\n', '    event Revoke(bytes32 indexed symbol, uint value, address indexed by);\n', '    event OwnershipChange(address indexed from, address indexed to, bytes32 indexed symbol);\n', '    event Approve(address indexed from, address indexed spender, bytes32 indexed symbol, uint value);\n', '    event Recovery(address indexed from, address indexed to, address by);\n', '    event Error(uint errorCode);\n', '\n', '    function emitTransfer(address _from, address _to, bytes32 _symbol, uint _value, string _reference) public {\n', '        Transfer(_from, _to, _symbol, _value, _reference);\n', '    }\n', '\n', '    function emitIssue(bytes32 _symbol, uint _value, address _by) public {\n', '        Issue(_symbol, _value, _by);\n', '    }\n', '\n', '    function emitRevoke(bytes32 _symbol, uint _value, address _by) public {\n', '        Revoke(_symbol, _value, _by);\n', '    }\n', '\n', '    function emitOwnershipChange(address _from, address _to, bytes32 _symbol) public {\n', '        OwnershipChange(_from, _to, _symbol);\n', '    }\n', '\n', '    function emitApprove(address _from, address _spender, bytes32 _symbol, uint _value) public {\n', '        Approve(_from, _spender, _symbol, _value);\n', '    }\n', '\n', '    function emitRecovery(address _from, address _to, address _by) public {\n', '        Recovery(_from, _to, _by);\n', '    }\n', '\n', '    function emitError(uint _errorCode) public {\n', '        Error(_errorCode);\n', '    }\n', '}\n', '\n', '\n', 'contract ProxyEventsEmitter {\n', '    function emitTransfer(address _from, address _to, uint _value) public;\n', '    function emitApprove(address _from, address _spender, uint _value) public;\n', '}\n', '\n', '\n', '/// @title Fund Tokens Platform.\n', '///\n', '/// Platform uses MultiEventsHistory contract to keep events, so that in case it needs to be redeployed\n', '/// at some point, all the events keep appearing at the same place.\n', '///\n', '/// Every asset is meant to be used through a proxy contract. Only one proxy contract have access\n', '/// rights for a particular asset.\n', '///\n', '/// Features: transfers, allowances, supply adjustments, lost wallet access recovery.\n', '///\n', '/// Note: all the non constant functions return false instead of throwing in case if state change\n', "/// didn't happen yet.\n", '/// BMCPlatformInterface compatibility\n', 'contract ATxPlatform is Object, Emitter {\n', '\n', '    uint constant ATX_PLATFORM_SCOPE = 80000;\n', '    uint constant ATX_PLATFORM_PROXY_ALREADY_EXISTS = ATX_PLATFORM_SCOPE + 1;\n', '    uint constant ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF = ATX_PLATFORM_SCOPE + 2;\n', '    uint constant ATX_PLATFORM_INVALID_VALUE = ATX_PLATFORM_SCOPE + 3;\n', '    uint constant ATX_PLATFORM_INSUFFICIENT_BALANCE = ATX_PLATFORM_SCOPE + 4;\n', '    uint constant ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE = ATX_PLATFORM_SCOPE + 5;\n', '    uint constant ATX_PLATFORM_ASSET_ALREADY_ISSUED = ATX_PLATFORM_SCOPE + 6;\n', '    uint constant ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE = ATX_PLATFORM_SCOPE + 7;\n', '    uint constant ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET = ATX_PLATFORM_SCOPE + 8;\n', '    uint constant ATX_PLATFORM_SUPPLY_OVERFLOW = ATX_PLATFORM_SCOPE + 9;\n', '    uint constant ATX_PLATFORM_NOT_ENOUGH_TOKENS = ATX_PLATFORM_SCOPE + 10;\n', '    uint constant ATX_PLATFORM_INVALID_NEW_OWNER = ATX_PLATFORM_SCOPE + 11;\n', '    uint constant ATX_PLATFORM_ALREADY_TRUSTED = ATX_PLATFORM_SCOPE + 12;\n', '    uint constant ATX_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS = ATX_PLATFORM_SCOPE + 13;\n', '    uint constant ATX_PLATFORM_ASSET_IS_NOT_ISSUED = ATX_PLATFORM_SCOPE + 14;\n', '    uint constant ATX_PLATFORM_INVALID_INVOCATION = ATX_PLATFORM_SCOPE + 15;\n', '\n', '    using SafeMath for uint;\n', '\n', '    /// @title Structure of a particular asset.\n', '    struct Asset {\n', "        uint owner;                       // Asset's owner id.\n", "        uint totalSupply;                 // Asset's total supply.\n", "        string name;                      // Asset's name, for information purposes.\n", "        string description;               // Asset's description, for information purposes.\n", '        bool isReissuable;                // Indicates if asset have dynamic or fixed supply.\n', '        uint8 baseUnit;                   // Proposed number of decimals.\n', '        mapping(uint => Wallet) wallets;  // Holders wallets.\n', '        mapping(uint => bool) partowners; // Part-owners of an asset; have less access rights than owner\n', '    }\n', '\n', '    /// @title Structure of an asset holder wallet for particular asset.\n', '    struct Wallet {\n', '        uint balance;\n', '        mapping(uint => uint) allowance;\n', '    }\n', '\n', '    /// @title Structure of an asset holder.\n', '    struct Holder {\n', '        address addr;                    // Current address of the holder.\n', '        mapping(address => bool) trust;  // Addresses that are trusted with recovery proocedure.\n', '    }\n', '\n', '    /// @dev Iterable mapping pattern is used for holders.\n', '    /// @dev This is an access address mapping. Many addresses may have access to a single holder.\n', '    uint public holdersCount;\n', '    mapping(uint => Holder) public holders;\n', '    mapping(address => uint) holderIndex;\n', '\n', '    /// @dev List of symbols that exist in a platform\n', '    bytes32[] public symbols;\n', '\n', '    /// @dev Asset symbol to asset mapping.\n', '    mapping(bytes32 => Asset) public assets;\n', '\n', '    /// @dev Asset symbol to asset proxy mapping.\n', '    mapping(bytes32 => address) public proxies;\n', '\n', '    /// @dev Co-owners of a platform. Has less access rights than a root contract owner\n', '    mapping(address => bool) public partowners;\n', '\n', '    /// @dev Should use interface of the emitter, but address of events history.\n', '    address public eventsHistory;\n', '\n', '    /// @dev Emits Error if called not by asset owner.\n', '    modifier onlyOwner(bytes32 _symbol) {\n', '        if (isOwner(msg.sender, _symbol)) {\n', '            _;\n', '        }\n', '    }\n', '\n', "    /// @dev UNAUTHORIZED if called not by one of symbol's partowners or owner\n", '    modifier onlyOneOfOwners(bytes32 _symbol) {\n', '        if (hasAssetRights(msg.sender, _symbol)) {\n', '            _;\n', '        }\n', '    }\n', '\n', "    /// @dev UNAUTHORIZED if called not by one of partowners or contract's owner\n", '    modifier onlyOneOfContractOwners() {\n', '        if (contractOwner == msg.sender || partowners[msg.sender]) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /// @dev Emits Error if called not by asset proxy.\n', '    modifier onlyProxy(bytes32 _symbol) {\n', '        if (proxies[_symbol] == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', "    /// @dev Emits Error if _from doesn't trust _to.\n", '    modifier checkTrust(address _from, address _to) {\n', '        if (isTrusted(_from, _to)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /// @notice Trust an address to perform recovery procedure for the caller.\n', '    ///\n', '    /// @return success.\n', '    function trust() external returns (uint) {\n', '        uint fromId = _createHolderId(msg.sender);\n', '        // Should trust to another address.\n', '        if (msg.sender == contractOwner) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        // Should trust to yet untrusted.\n', '        if (isTrusted(msg.sender, contractOwner)) {\n', '            return _error(ATX_PLATFORM_ALREADY_TRUSTED);\n', '        }\n', '\n', '        holders[fromId].trust[contractOwner] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Revoke trust to perform recovery procedure from an address.\n', '    ///\n', '    /// @return success.\n', '    function distrust() external checkTrust(msg.sender, contractOwner) returns (uint) {\n', '        holders[getHolderId(msg.sender)].trust[contractOwner] = false;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds a co-owner of a contract. Might be more than one co-owner\n', '    ///\n', '    /// @dev Allowed to only contract onwer\n', '    ///\n', '    /// @param _partowner a co-owner of a contract\n', '    ///\n', '    /// @return result code of an operation\n', '    function addPartOwner(address _partowner) external onlyContractOwner returns (uint) {\n', '        partowners[_partowner] = true;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice emoves a co-owner of a contract\n', '    ///\n', '    /// @dev Should be performed only by root contract owner\n', '    ///\n', '    /// @param _partowner a co-owner of a contract\n', '    ///\n', '    /// @return result code of an operation\n', '    function removePartOwner(address _partowner) external onlyContractOwner returns (uint) {\n', '        delete partowners[_partowner];\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sets EventsHstory contract address.\n', '    ///\n', '    /// @dev Can be set only by owner.\n', '    ///\n', '    /// @param _eventsHistory MultiEventsHistory contract address.\n', '    ///\n', '    /// @return success.\n', '    function setupEventsHistory(address _eventsHistory) external onlyContractOwner returns (uint errorCode) {\n', '        eventsHistory = _eventsHistory;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Adds a co-owner for an asset with provided symbol.\n', '    /// @dev Should be performed by a contract owner or its co-owners\n', '    ///\n', "    /// @param _symbol asset's symbol\n", '    /// @param _partowner a co-owner of an asset\n', '    ///\n', '    /// @return errorCode result code of an operation\n', '    function addAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {\n', '        uint holderId = _createHolderId(_partowner);\n', '        assets[_symbol].partowners[holderId] = true;\n', '        Emitter(eventsHistory).emitOwnershipChange(0x0, _partowner, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Removes a co-owner for an asset with provided symbol.\n', '    /// @dev Should be performed by a contract owner or its co-owners\n', '    ///\n', "    /// @param _symbol asset's symbol\n", '    /// @param _partowner a co-owner of an asset\n', '    ///\n', '    /// @return errorCode result code of an operation\n', '    function removeAssetPartOwner(bytes32 _symbol, address _partowner) external onlyOneOfOwners(_symbol) returns (uint) {\n', '        uint holderId = getHolderId(_partowner);\n', '        delete assets[_symbol].partowners[holderId];\n', '        Emitter(eventsHistory).emitOwnershipChange(_partowner, 0x0, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    function massTransfer(address[] addresses, uint[] values, bytes32 _symbol) external onlyOneOfOwners(_symbol) returns (uint errorCode, uint count) {\n', '        require(addresses.length == values.length);\n', '        require(_symbol != 0x0);\n', '\n', '        uint senderId = _createHolderId(msg.sender);\n', '\n', '        uint success = 0;\n', '        for (uint idx = 0; idx < addresses.length && msg.gas > 110000; ++idx) {\n', '            uint value = values[idx];\n', '\n', '            if (value == 0) {\n', '                _error(ATX_PLATFORM_INVALID_VALUE);\n', '                continue;\n', '            }\n', '\n', '            if (_balanceOf(senderId, _symbol) < value) {\n', '                _error(ATX_PLATFORM_INSUFFICIENT_BALANCE);\n', '                continue;\n', '            }\n', '\n', '            if (msg.sender == addresses[idx]) {\n', '                _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '                continue;\n', '            }\n', '\n', '            uint holderId = _createHolderId(addresses[idx]);\n', '\n', '            _transferDirect(senderId, holderId, value, _symbol);\n', '            Emitter(eventsHistory).emitTransfer(msg.sender, addresses[idx], _symbol, value, "");\n', '\n', '            ++success;\n', '        }\n', '\n', '        return (OK, success);\n', '    }\n', '\n', '    /// @notice Provides a cheap way to get number of symbols registered in a platform\n', '    ///\n', '    /// @return number of symbols\n', '    function symbolsCount() public view returns (uint) {\n', '        return symbols.length;\n', '    }\n', '\n', '    /// @notice Check asset existance.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset existance.\n', '    function isCreated(bytes32 _symbol) public view returns (bool) {\n', '        return assets[_symbol].owner != 0;\n', '    }\n', '\n', '    /// @notice Returns asset decimals.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset decimals.\n', '    function baseUnit(bytes32 _symbol) public view returns (uint8) {\n', '        return assets[_symbol].baseUnit;\n', '    }\n', '\n', '    /// @notice Returns asset name.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset name.\n', '    function name(bytes32 _symbol) public view returns (string) {\n', '        return assets[_symbol].name;\n', '    }\n', '\n', '    /// @notice Returns asset description.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset description.\n', '    function description(bytes32 _symbol) public view returns (string) {\n', '        return assets[_symbol].description;\n', '    }\n', '\n', '    /// @notice Returns asset reissuability.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset reissuability.\n', '    function isReissuable(bytes32 _symbol) public view returns (bool) {\n', '        return assets[_symbol].isReissuable;\n', '    }\n', '\n', '    /// @notice Returns asset owner address.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset owner address.\n', '    function owner(bytes32 _symbol) public view returns (address) {\n', '        return holders[assets[_symbol].owner].addr;\n', '    }\n', '\n', '    /// @notice Check if specified address has asset owner rights.\n', '    ///\n', '    /// @param _owner address to check.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return owner rights availability.\n', '    function isOwner(address _owner, bytes32 _symbol) public view returns (bool) {\n', '        return isCreated(_symbol) && (assets[_symbol].owner == getHolderId(_owner));\n', '    }\n', '\n', '    /// @notice Checks if a specified address has asset owner or co-owner rights.\n', '    ///\n', '    /// @param _owner address to check.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return owner rights availability.\n', '    function hasAssetRights(address _owner, bytes32 _symbol) public view returns (bool) {\n', '        uint holderId = getHolderId(_owner);\n', '        return isCreated(_symbol) && (assets[_symbol].owner == holderId || assets[_symbol].partowners[holderId]);\n', '    }\n', '\n', '    /// @notice Returns asset total supply.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return asset total supply.\n', '    function totalSupply(bytes32 _symbol) public view returns (uint) {\n', '        return assets[_symbol].totalSupply;\n', '    }\n', '\n', '    /// @notice Returns asset balance for a particular holder.\n', '    ///\n', '    /// @param _holder holder address.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder balance.\n', '    function balanceOf(address _holder, bytes32 _symbol) public view returns (uint) {\n', '        return _balanceOf(getHolderId(_holder), _symbol);\n', '    }\n', '\n', '    /// @notice Returns asset balance for a particular holder id.\n', '    ///\n', '    /// @param _holderId holder id.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder balance.\n', '    function _balanceOf(uint _holderId, bytes32 _symbol) public view returns (uint) {\n', '        return assets[_symbol].wallets[_holderId].balance;\n', '    }\n', '\n', '    /// @notice Returns current address for a particular holder id.\n', '    ///\n', '    /// @param _holderId holder id.\n', '    ///\n', '    /// @return holder address.\n', '    function _address(uint _holderId) public view returns (address) {\n', '        return holders[_holderId].addr;\n', '    }\n', '\n', '    function checkIsAssetPartOwner(bytes32 _symbol, address _partowner) public view returns (bool) {\n', '        require(_partowner != 0x0);\n', '        uint holderId = getHolderId(_partowner);\n', '        return assets[_symbol].partowners[holderId];\n', '    }\n', '\n', '    /// @notice Sets Proxy contract address for a particular asset.\n', '    ///\n', '    /// Can be set only once for each asset, and only by contract owner.\n', '    ///\n', '    /// @param _proxyAddress Proxy contract address.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return success.\n', '    function setProxy(address _proxyAddress, bytes32 _symbol) public onlyOneOfContractOwners returns (uint) {\n', '        if (proxies[_symbol] != 0x0) {\n', '            return ATX_PLATFORM_PROXY_ALREADY_EXISTS;\n', '        }\n', '        proxies[_symbol] = _proxyAddress;\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address.\n', '    ///\n', '    /// @param _holder holder address.\n', '    ///\n', '    /// @return holder id.\n', '    function getHolderId(address _holder) public view returns (uint) {\n', '        return holderIndex[_holder];\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _sender transfer initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) public returns (uint) {\n', '        return _transfer(getHolderId(_sender), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Issues new asset token on the platform.\n', '    ///\n', '    /// Tokens issued with this call go straight to contract owner.\n', '    /// Each symbol can be issued only once, and only by contract owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to issue immediately.\n', '    /// @param _name name of the asset.\n', '    /// @param _description description for the asset.\n', '    /// @param _baseUnit number of decimals.\n', '    /// @param _isReissuable dynamic or fixed supply.\n', '    ///\n', '    /// @return success.\n', '    function issueAsset(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable) public returns (uint) {\n', '        return issueAssetToAddress(_symbol, _value, _name, _description, _baseUnit, _isReissuable, msg.sender);\n', '    }\n', '\n', '    /// @notice Issues new asset token on the platform.\n', '    ///\n', '    /// Tokens issued with this call go straight to contract owner.\n', '    /// Each symbol can be issued only once, and only by contract owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to issue immediately.\n', '    /// @param _name name of the asset.\n', '    /// @param _description description for the asset.\n', '    /// @param _baseUnit number of decimals.\n', '    /// @param _isReissuable dynamic or fixed supply.\n', '    /// @param _account address where issued balance will be held\n', '    ///\n', '    /// @return success.\n', '    function issueAssetToAddress(bytes32 _symbol, uint _value, string _name, string _description, uint8 _baseUnit, bool _isReissuable, address _account) public onlyOneOfContractOwners returns (uint) {\n', '        // Should have positive value if supply is going to be fixed.\n', '        if (_value == 0 && !_isReissuable) {\n', '            return _error(ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE);\n', '        }\n', '        // Should not be issued yet.\n', '        if (isCreated(_symbol)) {\n', '            return _error(ATX_PLATFORM_ASSET_ALREADY_ISSUED);\n', '        }\n', '        uint holderId = _createHolderId(_account);\n', '        uint creatorId = _account == msg.sender ? holderId : _createHolderId(msg.sender);\n', '\n', '        symbols.push(_symbol);\n', '        assets[_symbol] = Asset(creatorId, _value, _name, _description, _isReissuable, _baseUnit);\n', '        assets[_symbol].wallets[holderId].balance = _value;\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Issues additional asset tokens if the asset have dynamic supply.\n', '    ///\n', '    /// Tokens issued with this call go straight to asset owner.\n', '    /// Can only be called by asset owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of additional tokens to issue.\n', '    ///\n', '    /// @return success.\n', '    function reissueAsset(bytes32 _symbol, uint _value) public onlyOneOfOwners(_symbol) returns (uint) {\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        Asset storage asset = assets[_symbol];\n', '        // Should have dynamic supply.\n', '        if (!asset.isReissuable) {\n', '            return _error(ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET);\n', '        }\n', '        // Resulting total supply should not overflow.\n', '        if (asset.totalSupply + _value < asset.totalSupply) {\n', '            return _error(ATX_PLATFORM_SUPPLY_OVERFLOW);\n', '        }\n', '        uint holderId = getHolderId(msg.sender);\n', '        asset.wallets[holderId].balance = asset.wallets[holderId].balance.add(_value);\n', '        asset.totalSupply = asset.totalSupply.add(_value);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitIssue(_symbol, _value, _address(holderId));\n', '\n', '        _proxyTransferEvent(0, holderId, _value, _symbol);\n', '\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Destroys specified amount of senders asset tokens.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _value amount of tokens to destroy.\n', '    ///\n', '    /// @return success.\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns (uint) {\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        Asset storage asset = assets[_symbol];\n', '        uint holderId = getHolderId(msg.sender);\n', '        // Should have enough tokens.\n', '        if (asset.wallets[holderId].balance < _value) {\n', '            return _error(ATX_PLATFORM_NOT_ENOUGH_TOKENS);\n', '        }\n', '        asset.wallets[holderId].balance = asset.wallets[holderId].balance.sub(_value);\n', '        asset.totalSupply = asset.totalSupply.sub(_value);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitRevoke(_symbol, _value, _address(holderId));\n', '        _proxyTransferEvent(holderId, 0, _value, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Passes asset ownership to specified address.\n', '    ///\n', '    /// Only ownership is changed, balances are not touched.\n', '    /// Can only be called by asset owner.\n', '    ///\n', '    /// @param _symbol asset symbol.\n', '    /// @param _newOwner address to become a new owner.\n', '    ///\n', '    /// @return success.\n', '    function changeOwnership(bytes32 _symbol, address _newOwner) public onlyOwner(_symbol) returns (uint) {\n', '        if (_newOwner == 0x0) {\n', '            return _error(ATX_PLATFORM_INVALID_NEW_OWNER);\n', '        }\n', '\n', '        Asset storage asset = assets[_symbol];\n', '        uint newOwnerId = _createHolderId(_newOwner);\n', '        // Should pass ownership to another holder.\n', '        if (asset.owner == newOwnerId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        address oldOwner = _address(asset.owner);\n', '        asset.owner = newOwnerId;\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitOwnershipChange(oldOwner, _newOwner, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Check if specified holder trusts an address with recovery procedure.\n', '    ///\n', '    /// @param _from truster.\n', '    /// @param _to trustee.\n', '    ///\n', '    /// @return trust existance.\n', '    function isTrusted(address _from, address _to) public view returns (bool) {\n', '        return holders[getHolderId(_from)].trust[_to];\n', '    }\n', '\n', '    /// @notice Perform recovery procedure.\n', '    ///\n', '    /// Can be invoked by contract owner if he is trusted by sender only.\n', '    ///\n', '    /// This function logic is actually more of an addAccess(uint _holderId, address _to).\n', '    /// It grants another address access to recovery subject wallets.\n', '    /// Can only be called by trustee of recovery subject.\n', '    ///\n', '    /// @param _from holder address to recover from.\n', '    /// @param _to address to grant access to.\n', '    ///\n', '    /// @return success.\n', '    function recover(address _from, address _to) checkTrust(_from, msg.sender) public onlyContractOwner returns (uint errorCode) {\n', '        // We take current holder address because it might not equal _from.\n', '        // It is possible to recover from any old holder address, but event should have the current one.\n', '        address from = holders[getHolderId(_from)].addr;\n', '        holders[getHolderId(_from)].addr = _to;\n', '        holderIndex[_to] = getHolderId(_from);\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitRecovery(from, _to, msg.sender);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Sets asset spending allowance for a specified spender.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _spender holder address to set allowance to.\n', '    /// @param _value amount to allow.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _sender approve initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) public onlyProxy(_symbol) returns (uint) {\n', '        return _approve(_createHolderId(_spender), _value, _symbol, _createHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Returns asset allowance from one holder to another.\n', '    ///\n', '    /// @param _from holder that allowed spending.\n', '    /// @param _spender holder that is allowed to spend.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder to spender allowance.\n', '    function allowance(address _from, address _spender, bytes32 _symbol) public view returns (uint) {\n', '        return _allowance(getHolderId(_from), getHolderId(_spender), _symbol);\n', '    }\n', '\n', '    /// @notice Prforms allowance transfer of asset balance between holders wallets.\n', '    ///\n', '    /// @dev Can only be called by asset proxy.\n', '    ///\n', '    /// @param _from holder address to take from.\n', '    /// @param _to holder address to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _sender allowance transfer initiator address.\n', '    ///\n', '    /// @return success.\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public onlyProxy(_symbol) returns (uint) {\n', '        return _transfer(getHolderId(_from), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    function _transferDirect(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n', '        assets[_symbol].wallets[_fromId].balance = assets[_symbol].wallets[_fromId].balance.sub(_value);\n', '        assets[_symbol].wallets[_toId].balance = assets[_symbol].wallets[_toId].balance.add(_value);\n', '    }\n', '\n', '    /// @notice Transfers asset balance between holders wallets.\n', '    ///\n', '    /// @dev Performs sanity checks and takes care of allowances adjustment.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _reference transfer comment to be included in a Transfer event.\n', '    /// @param _senderId transfer initiator holder id.\n', '    ///\n', '    /// @return success.\n', '    function _transfer(uint _fromId, uint _toId, uint _value, bytes32 _symbol, string _reference, uint _senderId) internal returns (uint) {\n', '        // Should not allow to send to oneself.\n', '        if (_fromId == _toId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '        // Should have positive value.\n', '        if (_value == 0) {\n', '            return _error(ATX_PLATFORM_INVALID_VALUE);\n', '        }\n', '        // Should have enough balance.\n', '        if (_balanceOf(_fromId, _symbol) < _value) {\n', '            return _error(ATX_PLATFORM_INSUFFICIENT_BALANCE);\n', '        }\n', '        // Should have enough allowance.\n', '        if (_fromId != _senderId && _allowance(_fromId, _senderId, _symbol) < _value) {\n', '            return _error(ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE);\n', '        }\n', '\n', '        _transferDirect(_fromId, _toId, _value, _symbol);\n', '        // Adjust allowance.\n', '        if (_fromId != _senderId) {\n', '            assets[_symbol].wallets[_fromId].allowance[_senderId] = assets[_symbol].wallets[_fromId].allowance[_senderId].sub(_value);\n', '        }\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: n/a after HF 4;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitTransfer(_address(_fromId), _address(_toId), _symbol, _value, _reference);\n', '        _proxyTransferEvent(_fromId, _toId, _value, _symbol);\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Ask asset Proxy contract to emit ERC20 compliant Transfer event.\n', '    ///\n', '    /// @param _fromId holder id to take from.\n', '    /// @param _toId holder id to give to.\n', '    /// @param _value amount to transfer.\n', '    /// @param _symbol asset symbol.\n', '    function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n', '        if (proxies[_symbol] != 0x0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: n/a after HF 4;\n', '            // Recursive Call: safe, all changes already made.\n', '            ProxyEventsEmitter(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value);\n', '        }\n', '    }\n', '\n', '    /// @notice Returns holder id for the specified address, creates it if needed.\n', '    ///\n', '    /// @param _holder holder address.\n', '    ///\n', '    /// @return holder id.\n', '    function _createHolderId(address _holder) internal returns (uint) {\n', '        uint holderId = holderIndex[_holder];\n', '        if (holderId == 0) {\n', '            holderId = ++holdersCount;\n', '            holders[holderId].addr = _holder;\n', '            holderIndex[_holder] = holderId;\n', '        }\n', '        return holderId;\n', '    }\n', '\n', '    /// @notice Sets asset spending allowance for a specified spender.\n', '    ///\n', '    /// Note: to revoke allowance, one needs to set allowance to 0.\n', '    ///\n', '    /// @param _spenderId holder id to set allowance for.\n', '    /// @param _value amount to allow.\n', '    /// @param _symbol asset symbol.\n', '    /// @param _senderId approve initiator holder id.\n', '    ///\n', '    /// @return success.\n', '    function _approve(uint _spenderId, uint _value, bytes32 _symbol, uint _senderId) internal returns (uint) {\n', '        // Asset should exist.\n', '        if (!isCreated(_symbol)) {\n', '            return _error(ATX_PLATFORM_ASSET_IS_NOT_ISSUED);\n', '        }\n', '        // Should allow to another holder.\n', '        if (_senderId == _spenderId) {\n', '            return _error(ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF);\n', '        }\n', '\n', '        // Double Spend Attack checkpoint\n', '        if (assets[_symbol].wallets[_senderId].allowance[_spenderId] != 0 && _value != 0) {\n', '            return _error(ATX_PLATFORM_INVALID_INVOCATION);\n', '        }\n', '\n', '        assets[_symbol].wallets[_senderId].allowance[_spenderId] = _value;\n', '\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        Emitter(eventsHistory).emitApprove(_address(_senderId), _address(_spenderId), _symbol, _value);\n', '        if (proxies[_symbol] != 0x0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: n/a after HF 4;\n', '            // Recursive Call: safe, all changes already made.\n', '            ProxyEventsEmitter(proxies[_symbol]).emitApprove(_address(_senderId), _address(_spenderId), _value);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    /// @notice Returns asset allowance from one holder to another.\n', '    ///\n', '    /// @param _fromId holder id that allowed spending.\n', '    /// @param _toId holder id that is allowed to spend.\n', '    /// @param _symbol asset symbol.\n', '    ///\n', '    /// @return holder to spender allowance.\n', '    function _allowance(uint _fromId, uint _toId, bytes32 _symbol) internal view returns (uint) {\n', '        return assets[_symbol].wallets[_fromId].allowance[_toId];\n', '    }\n', '\n', '    /// @dev Emits Error event with specified error message.\n', '    /// Should only be used if no state changes happened.\n', '    /// @param _errorCode code of an error\n', '    function _error(uint _errorCode) internal returns (uint) {\n', '        Emitter(eventsHistory).emitError(_errorCode);\n', '        return _errorCode;\n', '    }\n', '}']
