['pragma solidity ^0.4.24;\n', '\n', 'contract BackMeApp {\n', '  address public owner;\n', '  uint256 public minEsteemAmount;\n', '  bool public isShutDown;\n', '\n', '  struct EtherBox {\n', '    bytes32 label;\n', '    address owner;\n', '    uint256 expiration;\n', '    string ownerUrl;\n', '  }\n', '\n', '  mapping (address => bytes32) public nicknames;\n', '  mapping (address => address[]) public ownerToEtherBoxes;\n', '  mapping (address => EtherBox) public etherBoxes;\n', '  mapping (address => uint256) etherBoxesNonce;\n', '\n', '  event NewEsteem(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, bytes32 etherBoxLabel, string message, uint amount, uint256 timestamp);\n', '  event EtherBoxPublished(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, bytes32 etherBoxLabel, uint256 timestamp);\n', '  event EtherBoxDeleted(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, uint256 timestamp);\n', '  modifier onlyOwner() { require(msg.sender == owner); _; }\n', '  modifier onlyWhenRunning() { require(isShutDown == false); _; }\n', '\n', '  constructor() public { owner = msg.sender; minEsteemAmount = 1 finney; }\n', '\n', '  function getEtherBoxes(address _owner) external view returns(address[]) { return ownerToEtherBoxes[_owner]; }\n', '  function isExpired(address _etherBoxAddress) external view returns(bool) { return etherBoxes[_etherBoxAddress].expiration <= now ? true : false; }\n', '\n', '  function esteem(bytes32 _nickname, string _message, address _to) external payable {\n', '    assert(bytes(_message).length <= 300);\n', '    EtherBox storage etherBox = etherBoxes[_to];\n', '    require(etherBox.expiration > now);\n', '    assert(etherBox.owner != address(0));\n', '    nicknames[msg.sender] = _nickname;\n', '    emit NewEsteem(msg.sender, _nickname, _to, etherBox.label, _message, msg.value, now);\n', '    etherBox.owner.transfer(msg.value);\n', '  }\n', '\n', '  function publishEtherBox (bytes32 _label, string _ownerUrl, uint _lifespan) external onlyWhenRunning() payable {\n', '      require(ownerToEtherBoxes[msg.sender].length < 10);\n', '      assert(bytes(_ownerUrl).length <= 200);\n', '      address etherBoxAddress = address(keccak256(abi.encodePacked(msg.sender, etherBoxesNonce[msg.sender]++, now)));\n', '      ownerToEtherBoxes[msg.sender].push(etherBoxAddress);\n', '      etherBoxes[etherBoxAddress] = EtherBox({ label: _label, owner: msg.sender, ownerUrl: _ownerUrl, expiration: now+_lifespan });\n', '      emit EtherBoxPublished(msg.sender, nicknames[msg.sender], etherBoxAddress, _label, now);\n', '      if(msg.value > 0){ owner.transfer(msg.value); }\n', '  }\n', '\n', '  function deleteEtherBox(address _etherBoxAddress) external {\n', '    require(etherBoxes[_etherBoxAddress].owner == msg.sender);\n', '    require(etherBoxes[_etherBoxAddress].expiration <= now);\n', '    address[] storage ownedEtherBoxes = ownerToEtherBoxes[msg.sender];\n', '    address[] memory tempEtherBoxes = ownedEtherBoxes;\n', '    uint newLength = 0;\n', '    for(uint i = 0; i < tempEtherBoxes.length; i++){\n', '      if(tempEtherBoxes[i] != _etherBoxAddress){\n', '        ownedEtherBoxes[newLength] = tempEtherBoxes[i];\n', '        newLength++;\n', '      }\n', '    }\n', '    ownedEtherBoxes.length = newLength;\n', '    delete etherBoxes[_etherBoxAddress];\n', '    emit EtherBoxDeleted(msg.sender, nicknames[msg.sender], _etherBoxAddress, now);\n', '  }\n', '\n', '  function setMinEsteemAmount(uint256 _amount) external onlyOwner() { minEsteemAmount = _amount; }\n', '  function toggleFactoryPower() external onlyOwner() { isShutDown = isShutDown == false ? true : false; }\n', '  function destroyFactory() external onlyOwner() { selfdestruct(owner); }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract BackMeApp {\n', '  address public owner;\n', '  uint256 public minEsteemAmount;\n', '  bool public isShutDown;\n', '\n', '  struct EtherBox {\n', '    bytes32 label;\n', '    address owner;\n', '    uint256 expiration;\n', '    string ownerUrl;\n', '  }\n', '\n', '  mapping (address => bytes32) public nicknames;\n', '  mapping (address => address[]) public ownerToEtherBoxes;\n', '  mapping (address => EtherBox) public etherBoxes;\n', '  mapping (address => uint256) etherBoxesNonce;\n', '\n', '  event NewEsteem(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, bytes32 etherBoxLabel, string message, uint amount, uint256 timestamp);\n', '  event EtherBoxPublished(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, bytes32 etherBoxLabel, uint256 timestamp);\n', '  event EtherBoxDeleted(address indexed senderAddress, bytes32 senderNickname, address indexed etherBoxAddress, uint256 timestamp);\n', '  modifier onlyOwner() { require(msg.sender == owner); _; }\n', '  modifier onlyWhenRunning() { require(isShutDown == false); _; }\n', '\n', '  constructor() public { owner = msg.sender; minEsteemAmount = 1 finney; }\n', '\n', '  function getEtherBoxes(address _owner) external view returns(address[]) { return ownerToEtherBoxes[_owner]; }\n', '  function isExpired(address _etherBoxAddress) external view returns(bool) { return etherBoxes[_etherBoxAddress].expiration <= now ? true : false; }\n', '\n', '  function esteem(bytes32 _nickname, string _message, address _to) external payable {\n', '    assert(bytes(_message).length <= 300);\n', '    EtherBox storage etherBox = etherBoxes[_to];\n', '    require(etherBox.expiration > now);\n', '    assert(etherBox.owner != address(0));\n', '    nicknames[msg.sender] = _nickname;\n', '    emit NewEsteem(msg.sender, _nickname, _to, etherBox.label, _message, msg.value, now);\n', '    etherBox.owner.transfer(msg.value);\n', '  }\n', '\n', '  function publishEtherBox (bytes32 _label, string _ownerUrl, uint _lifespan) external onlyWhenRunning() payable {\n', '      require(ownerToEtherBoxes[msg.sender].length < 10);\n', '      assert(bytes(_ownerUrl).length <= 200);\n', '      address etherBoxAddress = address(keccak256(abi.encodePacked(msg.sender, etherBoxesNonce[msg.sender]++, now)));\n', '      ownerToEtherBoxes[msg.sender].push(etherBoxAddress);\n', '      etherBoxes[etherBoxAddress] = EtherBox({ label: _label, owner: msg.sender, ownerUrl: _ownerUrl, expiration: now+_lifespan });\n', '      emit EtherBoxPublished(msg.sender, nicknames[msg.sender], etherBoxAddress, _label, now);\n', '      if(msg.value > 0){ owner.transfer(msg.value); }\n', '  }\n', '\n', '  function deleteEtherBox(address _etherBoxAddress) external {\n', '    require(etherBoxes[_etherBoxAddress].owner == msg.sender);\n', '    require(etherBoxes[_etherBoxAddress].expiration <= now);\n', '    address[] storage ownedEtherBoxes = ownerToEtherBoxes[msg.sender];\n', '    address[] memory tempEtherBoxes = ownedEtherBoxes;\n', '    uint newLength = 0;\n', '    for(uint i = 0; i < tempEtherBoxes.length; i++){\n', '      if(tempEtherBoxes[i] != _etherBoxAddress){\n', '        ownedEtherBoxes[newLength] = tempEtherBoxes[i];\n', '        newLength++;\n', '      }\n', '    }\n', '    ownedEtherBoxes.length = newLength;\n', '    delete etherBoxes[_etherBoxAddress];\n', '    emit EtherBoxDeleted(msg.sender, nicknames[msg.sender], _etherBoxAddress, now);\n', '  }\n', '\n', '  function setMinEsteemAmount(uint256 _amount) external onlyOwner() { minEsteemAmount = _amount; }\n', '  function toggleFactoryPower() external onlyOwner() { isShutDown = isShutDown == false ? true : false; }\n', '  function destroyFactory() external onlyOwner() { selfdestruct(owner); }\n', '}']
