['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Interface {\n', '    function balanceOf(address _owner) external returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '}\n', '\n', 'contract Donations {\n', '    struct Project\n', '    {\n', '        uint16 Id;\n', '        uint256 Target;\n', '        uint256 Current;\n', '    }\n', '    mapping(uint16 => Project) public projects;\n', '    address owner;\n', '    uint8 public projectsCount;\n', '    \n', '    address queen;\n', '    address joker;\n', '    address knight;\n', '    address paladin;\n', '\n', '    ERC20Interface horseToken;\n', '    address horseTokenAddress = 0x5B0751713b2527d7f002c0c4e2a37e1219610A6B;\n', '    \n', '    uint8 jokerDivs = 50;\n', '    uint8 knightDivs = 30;\n', '    uint8 paladinDivs = 10;\n', '    \n', '    uint256 private toDistribute;\n', '    uint256 private toDistributeHorse;\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => uint256) private _balancesHorse;\n', '   \n', '    constructor(address _queen, address _joker, address _knight, address _paladin) public {\n', '        owner = msg.sender;\n', '        queen = _queen;\n', '        joker = _joker;\n', '        knight = _knight;\n', '        paladin = _paladin;\n', '\n', '        horseToken = ERC20Interface(horseTokenAddress);\n', '    }\n', ' /*   \n', '    function changeAddressQueen(address newAddr) external {\n', '        require(msg.sender == queen,"wrong role");\n', '        _transferCeo(newAddr);\n', '        queen = newAddr;\n', '    }\n', '    function changeAddressJoker(address newAddr) external {\n', '        require(msg.sender == joker,"wrong role");\n', '        _transferCeo(newAddr);\n', '        joker = newAddr;\n', '    }\n', '    function changeAddressKnight(address newAddr) external {\n', '        require(msg.sender == knight,"wrong role");\n', '        _transferCeo(newAddr);\n', '        knight = newAddr;\n', '    }\n', '    function changeAddressPaladin(address newAddr) external {\n', '        require(msg.sender == paladin,"wrong role");\n', '        _transferCeo(newAddr);\n', '        paladin = newAddr;\n', '    }\n', '*/    \n', '    function addProject(uint256 target) external\n', '    onlyOwner()\n', '    returns (uint16) {\n', '        uint16 newid = uint16(projectsCount);\n', '        projectsCount = projectsCount + 1;\n', '        Project storage proj = projects[newid];\n', '        proj.Id = newid;\n', '        proj.Target = target;\n', '        return newid;\n', '    }\n', '    \n', '    function donateToProject(uint16 id) external payable {\n', '        require(id < projectsCount,"project doesnt exist");\n', '        require(msg.value > 0,"non null donations only");\n', '        projects[id].Current = projects[id].Current + msg.value;\n', '        toDistribute = toDistribute + msg.value;\n', '    }\n', '    \n', '    function () external payable {\n', '       //fallback function just accept the funds\n', '    }\n', '    \n', '    function withdraw() external {\n', '        //check for pure transfer ETH and HORSe donations\n', '        _distributeRest();\n', '        if(toDistribute > 0)\n', '            _distribute();\n', '        if(toDistributeHorse > 0)\n', '            _distributeHorse();\n', '        if(_balances[msg.sender] > 0) {\n', '            msg.sender.transfer(_balances[msg.sender]);\n', '            _balances[msg.sender] = 0;\n', '        }\n', '\n', '        if(_balancesHorse[msg.sender] > 0) {\n', '            horseToken.transfer(msg.sender,_balancesHorse[msg.sender]);\n', '            _balancesHorse[msg.sender] = 0;\n', '        }\n', '    }\n', '    \n', '    function checkBalance() external view\n', '    onlyCeo() returns (uint256,uint256) {\n', '        return (_balances[msg.sender],_balancesHorse[msg.sender]);\n', '    }\n', '\n', '    function _distributeRest() internal {\n', '        int rest = int(address(this).balance)\n', '        - int(_balances[joker]) \n', '        - int(_balances[knight]) \n', '        - int(_balances[paladin]) \n', '        - int(_balances[queen]) \n', '        - int(toDistribute);\n', '        if(rest > 0) {\n', '            toDistribute = toDistribute + uint256(rest);\n', '        }\n', '\n', '        uint256 ownedHorse = horseToken.balanceOf(address(this));\n', '        if(ownedHorse > 0) {\n', '            int restHorse = int(ownedHorse)\n', '            - int(_balancesHorse[joker]) \n', '            - int(_balancesHorse[knight]) \n', '            - int(_balancesHorse[paladin]) \n', '            - int(_balancesHorse[queen]) \n', '            - int(toDistributeHorse);\n', '\n', '            if(restHorse > 0) {\n', '                toDistributeHorse = toDistributeHorse + uint256(restHorse);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _distribute() private {\n', '        uint256 parts = toDistribute / 100;\n', '        uint256 jokerDue = parts * 50;\n', '        uint256 knightDue = parts * 30;\n', '        uint256 paladinDue = parts * 10;\n', '\n', '        _balances[joker] = _balances[joker] + jokerDue;\n', '        _balances[knight] = _balances[knight] + knightDue;\n', '        _balances[paladin] = _balances[paladin] + paladinDue;\n', '        _balances[queen] = _balances[queen] + (toDistribute - jokerDue - knightDue - paladinDue);\n', '        \n', '        toDistribute = 0;\n', '    }\n', '\n', '    function _distributeHorse() private {\n', '        uint256 parts = toDistributeHorse / 100;\n', '        uint256 jokerDue = parts * 50;\n', '        uint256 knightDue = parts * 30;\n', '        uint256 paladinDue = parts * 10;\n', '\n', '        _balancesHorse[joker] = _balancesHorse[joker] + jokerDue;\n', '        _balancesHorse[knight] = _balancesHorse[knight] + knightDue;\n', '        _balancesHorse[paladin] = _balancesHorse[paladin] + paladinDue;\n', '        _balancesHorse[queen] = _balancesHorse[queen] + (toDistributeHorse - jokerDue - knightDue - paladinDue);\n', '\n', '        toDistributeHorse = 0;\n', '    }\n', ' /*   \n', '    function _transferCeo(address newAddr) internal\n', '    unique(newAddr)\n', '    {\n', '        require(newAddr != address(0),"address is 0");\n', '\n', '        _balances[newAddr] = _balances[msg.sender];\n', '        _balances[msg.sender] = 0;\n', '\n', '        _balancesHorse[newAddr] = _balancesHorse[msg.sender];\n', '        _balancesHorse[msg.sender] = 0;\n', '    }\n', ' */   \n', '    function _isCeo(address addr) internal view returns (bool) {\n', '        return ((addr == queen) || (addr == joker) || (addr == knight) || (addr == paladin));\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only owner");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyCeo() {\n', '        require(_isCeo(msg.sender), "not ceo");\n', '        _;\n', '    }\n', '    \n', '    modifier unique(address newAddr) {\n', '        require(!_isCeo(newAddr),"not unique");\n', '        _;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Interface {\n', '    function balanceOf(address _owner) external returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '}\n', '\n', 'contract Donations {\n', '    struct Project\n', '    {\n', '        uint16 Id;\n', '        uint256 Target;\n', '        uint256 Current;\n', '    }\n', '    mapping(uint16 => Project) public projects;\n', '    address owner;\n', '    uint8 public projectsCount;\n', '    \n', '    address queen;\n', '    address joker;\n', '    address knight;\n', '    address paladin;\n', '\n', '    ERC20Interface horseToken;\n', '    address horseTokenAddress = 0x5B0751713b2527d7f002c0c4e2a37e1219610A6B;\n', '    \n', '    uint8 jokerDivs = 50;\n', '    uint8 knightDivs = 30;\n', '    uint8 paladinDivs = 10;\n', '    \n', '    uint256 private toDistribute;\n', '    uint256 private toDistributeHorse;\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => uint256) private _balancesHorse;\n', '   \n', '    constructor(address _queen, address _joker, address _knight, address _paladin) public {\n', '        owner = msg.sender;\n', '        queen = _queen;\n', '        joker = _joker;\n', '        knight = _knight;\n', '        paladin = _paladin;\n', '\n', '        horseToken = ERC20Interface(horseTokenAddress);\n', '    }\n', ' /*   \n', '    function changeAddressQueen(address newAddr) external {\n', '        require(msg.sender == queen,"wrong role");\n', '        _transferCeo(newAddr);\n', '        queen = newAddr;\n', '    }\n', '    function changeAddressJoker(address newAddr) external {\n', '        require(msg.sender == joker,"wrong role");\n', '        _transferCeo(newAddr);\n', '        joker = newAddr;\n', '    }\n', '    function changeAddressKnight(address newAddr) external {\n', '        require(msg.sender == knight,"wrong role");\n', '        _transferCeo(newAddr);\n', '        knight = newAddr;\n', '    }\n', '    function changeAddressPaladin(address newAddr) external {\n', '        require(msg.sender == paladin,"wrong role");\n', '        _transferCeo(newAddr);\n', '        paladin = newAddr;\n', '    }\n', '*/    \n', '    function addProject(uint256 target) external\n', '    onlyOwner()\n', '    returns (uint16) {\n', '        uint16 newid = uint16(projectsCount);\n', '        projectsCount = projectsCount + 1;\n', '        Project storage proj = projects[newid];\n', '        proj.Id = newid;\n', '        proj.Target = target;\n', '        return newid;\n', '    }\n', '    \n', '    function donateToProject(uint16 id) external payable {\n', '        require(id < projectsCount,"project doesnt exist");\n', '        require(msg.value > 0,"non null donations only");\n', '        projects[id].Current = projects[id].Current + msg.value;\n', '        toDistribute = toDistribute + msg.value;\n', '    }\n', '    \n', '    function () external payable {\n', '       //fallback function just accept the funds\n', '    }\n', '    \n', '    function withdraw() external {\n', '        //check for pure transfer ETH and HORSe donations\n', '        _distributeRest();\n', '        if(toDistribute > 0)\n', '            _distribute();\n', '        if(toDistributeHorse > 0)\n', '            _distributeHorse();\n', '        if(_balances[msg.sender] > 0) {\n', '            msg.sender.transfer(_balances[msg.sender]);\n', '            _balances[msg.sender] = 0;\n', '        }\n', '\n', '        if(_balancesHorse[msg.sender] > 0) {\n', '            horseToken.transfer(msg.sender,_balancesHorse[msg.sender]);\n', '            _balancesHorse[msg.sender] = 0;\n', '        }\n', '    }\n', '    \n', '    function checkBalance() external view\n', '    onlyCeo() returns (uint256,uint256) {\n', '        return (_balances[msg.sender],_balancesHorse[msg.sender]);\n', '    }\n', '\n', '    function _distributeRest() internal {\n', '        int rest = int(address(this).balance)\n', '        - int(_balances[joker]) \n', '        - int(_balances[knight]) \n', '        - int(_balances[paladin]) \n', '        - int(_balances[queen]) \n', '        - int(toDistribute);\n', '        if(rest > 0) {\n', '            toDistribute = toDistribute + uint256(rest);\n', '        }\n', '\n', '        uint256 ownedHorse = horseToken.balanceOf(address(this));\n', '        if(ownedHorse > 0) {\n', '            int restHorse = int(ownedHorse)\n', '            - int(_balancesHorse[joker]) \n', '            - int(_balancesHorse[knight]) \n', '            - int(_balancesHorse[paladin]) \n', '            - int(_balancesHorse[queen]) \n', '            - int(toDistributeHorse);\n', '\n', '            if(restHorse > 0) {\n', '                toDistributeHorse = toDistributeHorse + uint256(restHorse);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _distribute() private {\n', '        uint256 parts = toDistribute / 100;\n', '        uint256 jokerDue = parts * 50;\n', '        uint256 knightDue = parts * 30;\n', '        uint256 paladinDue = parts * 10;\n', '\n', '        _balances[joker] = _balances[joker] + jokerDue;\n', '        _balances[knight] = _balances[knight] + knightDue;\n', '        _balances[paladin] = _balances[paladin] + paladinDue;\n', '        _balances[queen] = _balances[queen] + (toDistribute - jokerDue - knightDue - paladinDue);\n', '        \n', '        toDistribute = 0;\n', '    }\n', '\n', '    function _distributeHorse() private {\n', '        uint256 parts = toDistributeHorse / 100;\n', '        uint256 jokerDue = parts * 50;\n', '        uint256 knightDue = parts * 30;\n', '        uint256 paladinDue = parts * 10;\n', '\n', '        _balancesHorse[joker] = _balancesHorse[joker] + jokerDue;\n', '        _balancesHorse[knight] = _balancesHorse[knight] + knightDue;\n', '        _balancesHorse[paladin] = _balancesHorse[paladin] + paladinDue;\n', '        _balancesHorse[queen] = _balancesHorse[queen] + (toDistributeHorse - jokerDue - knightDue - paladinDue);\n', '\n', '        toDistributeHorse = 0;\n', '    }\n', ' /*   \n', '    function _transferCeo(address newAddr) internal\n', '    unique(newAddr)\n', '    {\n', '        require(newAddr != address(0),"address is 0");\n', '\n', '        _balances[newAddr] = _balances[msg.sender];\n', '        _balances[msg.sender] = 0;\n', '\n', '        _balancesHorse[newAddr] = _balancesHorse[msg.sender];\n', '        _balancesHorse[msg.sender] = 0;\n', '    }\n', ' */   \n', '    function _isCeo(address addr) internal view returns (bool) {\n', '        return ((addr == queen) || (addr == joker) || (addr == knight) || (addr == paladin));\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only owner");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyCeo() {\n', '        require(_isCeo(msg.sender), "not ceo");\n', '        _;\n', '    }\n', '    \n', '    modifier unique(address newAddr) {\n', '        require(!_isCeo(newAddr),"not unique");\n', '        _;\n', '    }\n', '}']
