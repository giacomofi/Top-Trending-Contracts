['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ECRecovery.sol\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/BookingPoC.sol\n', '\n', '/**\n', ' * @title BookingPoC\n', ' * @dev A contract to offer hotel rooms for booking, the payment can be done\n', ' * with ETH or Lif\n', ' */\n', 'contract BookingPoC is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '  using ECRecovery for bytes32;\n', '\n', '  // The account that will sign the offers\n', '  address public offerSigner;\n', '\n', '  // The time where no more bookings can be done\n', '  uint256 public endBookings;\n', '\n', '  // A mapping of the rooms booked by night, it saves the guest address by\n', '  // room/night\n', '  // RoomType => Night => Room => Booking\n', '  struct Booking {\n', '    address guest;\n', '    bytes32 bookingHash;\n', '    uint256 payed;\n', '    bool isEther;\n', '  }\n', '  struct RoomType {\n', '    uint256 totalRooms;\n', '    mapping(uint256 => mapping(uint256 => Booking)) nights;\n', '  }\n', '  mapping(string => RoomType) rooms;\n', '\n', '  // An array of the refund polices, it has to be ordered by beforeTime\n', '  struct Refund {\n', '    uint256 beforeTime;\n', '    uint8 dividedBy;\n', '  }\n', '  Refund[] public refunds;\n', '\n', '  // The total amount of nights offered for booking\n', '  uint256 public totalNights;\n', '\n', '  // The ERC20 lifToken that will be used for payment\n', '  ERC20 public lifToken;\n', '\n', '  event BookingCanceled(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address newGuest, bytes32 bookingHash\n', '  );\n', '\n', '  event BookingChanged(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address newGuest, bytes32 bookingHash\n', '  );\n', '\n', '  event BookingDone(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address guest, bytes32 bookingHash\n', '  );\n', '\n', '  event RoomsAdded(string roomType, uint256 newRooms);\n', '\n', '  /**\n', '   * @dev Constructor\n', '   * @param _offerSigner Address of the account that will sign offers\n', '   * @param _lifToken Address of the Lif token contract\n', '   * @param _totalNights The max amount of nights to be booked\n', '   */\n', '  constructor(\n', '    address _offerSigner, address _lifToken,\n', '    uint256 _totalNights, uint256 _endBookings\n', '  ) public {\n', '    require(_offerSigner != address(0));\n', '    require(_lifToken != address(0));\n', '    require(_totalNights > 0);\n', '    require(_endBookings > now);\n', '    offerSigner = _offerSigner;\n', '    lifToken = ERC20(_lifToken);\n', '    totalNights = _totalNights;\n', '    endBookings = _endBookings;\n', '  }\n', '\n', '  /**\n', '   * @dev Change the signer or lif token addresses, only called by owner\n', '   * @param _offerSigner Address of the account that will sign offers\n', '   * @param _lifToken Address of the Lif token contract\n', '   */\n', '  function edit(address _offerSigner, address _lifToken) onlyOwner public {\n', '    require(_offerSigner != address(0));\n', '    require(_lifToken != address(0));\n', '    offerSigner = _offerSigner;\n', '    lifToken = ERC20(_lifToken);\n', '  }\n', '\n', '  /**\n', '   * @dev Add a refund policy\n', '   * @param _beforeTime The time before this refund can be executed\n', '   * @param _dividedBy The divisor of the payment value\n', '   */\n', '  function addRefund(uint256 _beforeTime, uint8 _dividedBy) onlyOwner public {\n', '    if (refunds.length > 0)\n', '      require(refunds[refunds.length-1].beforeTime > _beforeTime);\n', '    refunds.push(Refund(_beforeTime, _dividedBy));\n', '  }\n', '\n', '  /**\n', '   * @dev Change a refund policy\n', '   * @param _beforeTime The time before this refund can be executed\n', '   * @param _dividedBy The divisor of the payment value\n', '   */\n', '  function changeRefund(\n', '    uint8 _refundIndex, uint256 _beforeTime, uint8 _dividedBy\n', '  ) onlyOwner public {\n', '    if (_refundIndex > 0)\n', '      require(refunds[_refundIndex-1].beforeTime > _beforeTime);\n', '    refunds[_refundIndex].beforeTime = _beforeTime;\n', '    refunds[_refundIndex].dividedBy = _dividedBy;\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of rooms offered, only called by owner\n', '   * @param roomType The room type to be added\n', '   * @param amount The amount of rooms to be increased\n', '   */\n', '  function addRooms(string roomType, uint256 amount) onlyOwner public {\n', '    rooms[roomType].totalRooms = rooms[roomType].totalRooms.add(amount);\n', '    emit RoomsAdded(roomType, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room for a certain address, internal function\n', '   * @param roomType The room type to be booked\n', '   * @param _nights The nights that we want to book\n', '   * @param room The room that wants to be booked\n', '   * @param guest The address of the guest that will book the room\n', '   */\n', '  function bookRoom(\n', '    string roomType, uint256[] _nights, uint256 room,\n', '    address guest, bytes32 bookingHash, uint256 weiPerNight, bool isEther\n', '  ) internal {\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      rooms[roomType].nights[_nights[i]][room].guest = guest;\n', '      rooms[roomType].nights[_nights[i]][room].bookingHash = bookingHash;\n', '      rooms[roomType].nights[_nights[i]][room].payed = weiPerNight;\n', '      rooms[roomType].nights[_nights[i]][room].isEther = isEther;\n', '    }\n', '    emit BookingDone(roomType, _nights, room, guest, bookingHash);\n', '  }\n', '\n', '  event log(uint256 msg);\n', '\n', '  /**\n', '   * @dev Cancel a booking\n', '   * @param roomType The room type to be booked\n', '   * @param _nights The nights that we want to book\n', '   * @param room The room that wants to be booked\n', '   */\n', '  function cancelBooking(\n', '    string roomType, uint256[] _nights,\n', '    uint256 room, bytes32 bookingHash, bool isEther\n', '  ) public {\n', '\n', '    // Check the booking and delete it\n', '    uint256 totalPayed = 0;\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      require(rooms[roomType].nights[_nights[i]][room].guest == msg.sender);\n', '      require(rooms[roomType].nights[_nights[i]][room].isEther == isEther);\n', '      require(rooms[roomType].nights[_nights[i]][room].bookingHash == bookingHash);\n', '      totalPayed = totalPayed.add(\n', '        rooms[roomType].nights[_nights[i]][room].payed\n', '      );\n', '      delete rooms[roomType].nights[_nights[i]][room];\n', '    }\n', '\n', '    // Calculate refund amount\n', '    uint256 refundAmount = 0;\n', '    for (i = 0; i < refunds.length; i ++) {\n', '      if (now < endBookings.sub(refunds[i].beforeTime)){\n', '        refundAmount = totalPayed.div(refunds[i].dividedBy);\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Forward refund funds\n', '    if (isEther)\n', '      msg.sender.transfer(refundAmount);\n', '    else\n', '      lifToken.transfer(msg.sender, refundAmount);\n', '\n', '    emit BookingCanceled(roomType, _nights, room, msg.sender, bookingHash);\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw tokens and eth, only from owner contract\n', '   */\n', '  function withdraw() public onlyOwner {\n', '    require(now > endBookings);\n', '    lifToken.transfer(owner, lifToken.balanceOf(address(this)));\n', '    owner.transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room paying with ETH\n', '   * @param pricePerNight The price per night in wei\n', '   * @param offerTimestamp The timestamp of when the offer ends\n', '   * @param offerSignature The signature provided by the offer signer\n', '   * @param roomType The room type that the guest wants to book\n', '   * @param _nights The nights that the guest wants to book\n', '   */\n', '  function bookWithEth(\n', '    uint256 pricePerNight,\n', '    uint256 offerTimestamp,\n', '    bytes offerSignature,\n', '    string roomType,\n', '    uint256[] _nights,\n', '    bytes32 bookingHash\n', '  ) public payable {\n', '    // Check that the offer is still valid\n', '    require(offerTimestamp < now);\n', '    require(now < endBookings);\n', '\n', '    // Check the eth sent\n', '    require(pricePerNight.mul(_nights.length) <= msg.value);\n', '\n', '    // Check if there is at least one room available\n', '    uint256 available = firstRoomAvailable(roomType, _nights);\n', '    require(available > 0);\n', '\n', '    // Check the signer of the offer is the right address\n', '    bytes32 priceSigned = keccak256(abi.encodePacked(\n', '      roomType, pricePerNight, offerTimestamp, "eth", bookingHash\n', '    )).toEthSignedMessageHash();\n', '    require(offerSigner == priceSigned.recover(offerSignature));\n', '\n', '    // Assign the available room to the guest\n', '    bookRoom(\n', '      roomType, _nights, available, msg.sender,\n', '      bookingHash, pricePerNight, true\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room paying with Lif\n', '   * @param pricePerNight The price per night in wei\n', '   * @param offerTimestamp The timestamp of when the offer ends\n', '   * @param offerSignature The signature provided by the offer signer\n', '   * @param roomType The room type that the guest wants to book\n', '   * @param _nights The nights that the guest wants to book\n', '   */\n', '  function bookWithLif(\n', '    uint256 pricePerNight,\n', '    uint256 offerTimestamp,\n', '    bytes offerSignature,\n', '    string roomType,\n', '    uint256[] _nights,\n', '    bytes32 bookingHash\n', '  ) public {\n', '    // Check that the offer is still valid\n', '    require(offerTimestamp < now);\n', '\n', '    // Check the amount of lifTokens allowed to be spent by this contract\n', '    uint256 lifTokenAllowance = lifToken.allowance(msg.sender, address(this));\n', '    require(pricePerNight.mul(_nights.length) <= lifTokenAllowance);\n', '\n', '    // Check if there is at least one room available\n', '    uint256 available = firstRoomAvailable(roomType, _nights);\n', '    require(available > 0);\n', '\n', '    // Check the signer of the offer is the right address\n', '    bytes32 priceSigned = keccak256(abi.encodePacked(\n', '      roomType, pricePerNight, offerTimestamp, "lif", bookingHash\n', '    )).toEthSignedMessageHash();\n', '    require(offerSigner == priceSigned.recover(offerSignature));\n', '\n', '    // Assign the available room to the guest\n', '    bookRoom(\n', '      roomType, _nights, available, msg.sender,\n', '      bookingHash, pricePerNight, false\n', '    );\n', '\n', '    // Transfer the lifTokens to booking\n', '    lifToken.transferFrom(msg.sender, address(this), lifTokenAllowance);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the total rooms for a room type\n', '   * @param roomType The room type that wants to be booked\n', '   */\n', '  function totalRooms(string roomType) view public returns (uint256) {\n', '    return rooms[roomType].totalRooms;\n', '  }\n', '\n', '  /**\n', '   * @dev Get a booking information\n', '   * @param roomType The room type\n', '   * @param room The room booked\n', '   * @param night The night of the booking\n', '   */\n', '  function getBooking(\n', '    string roomType, uint256 room, uint256 night\n', '  ) view public returns (address, uint256, bytes32, bool) {\n', '    return (\n', '      rooms[roomType].nights[night][room].guest,\n', '      rooms[roomType].nights[night][room].payed,\n', '      rooms[roomType].nights[night][room].bookingHash,\n', '      rooms[roomType].nights[night][room].isEther\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Get the availability of a specific room\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @param room The room that wants to be booked\n', '   * @return bool If the room is available or not\n', '   */\n', '  function roomAvailable(\n', '    string roomType, uint256[] _nights, uint256 room\n', '  ) view public returns (bool) {\n', '    require(room <= rooms[roomType].totalRooms);\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      require(_nights[i] <= totalNights);\n', '      if (rooms[roomType].nights[_nights[i]][room].guest != address(0))\n', '        return false;\n', '      }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Get the available rooms for certain nights\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @return uint256 Array of the rooms available for that nights\n', '   */\n', '  function roomsAvailable(\n', '    string roomType, uint256[] _nights\n', '  ) view public returns (uint256[]) {\n', '    require(_nights[i] <= totalNights);\n', '    uint256[] memory available = new uint256[](rooms[roomType].totalRooms);\n', '    for (uint z = 1; z <= rooms[roomType].totalRooms; z ++) {\n', '      available[z-1] = z;\n', '      for (uint i = 0; i < _nights.length; i ++)\n', '        if (rooms[roomType].nights[_nights[i]][z].guest != address(0)) {\n', '          available[z-1] = 0;\n', '          break;\n', '        }\n', '    }\n', '    return available;\n', '  }\n', '\n', '  /**\n', '   * @dev Get the first available room for certain nights\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @return uint256 The first available room\n', '   */\n', '  function firstRoomAvailable(\n', '    string roomType, uint256[] _nights\n', '  ) internal returns (uint256) {\n', '    require(_nights[i] <= totalNights);\n', '    uint256 available = 0;\n', '    bool isAvailable;\n', '    for (uint z = rooms[roomType].totalRooms; z >= 1 ; z --) {\n', '      isAvailable = true;\n', '      for (uint i = 0; i < _nights.length; i ++) {\n', '        if (rooms[roomType].nights[_nights[i]][z].guest != address(0))\n', '          isAvailable = false;\n', '          break;\n', '        }\n', '      if (isAvailable)\n', '        available = z;\n', '    }\n', '    return available;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: zeppelin-solidity/contracts/ECRecovery.sol\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '    );\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/BookingPoC.sol\n', '\n', '/**\n', ' * @title BookingPoC\n', ' * @dev A contract to offer hotel rooms for booking, the payment can be done\n', ' * with ETH or Lif\n', ' */\n', 'contract BookingPoC is Ownable {\n', '\n', '  using SafeMath for uint256;\n', '  using ECRecovery for bytes32;\n', '\n', '  // The account that will sign the offers\n', '  address public offerSigner;\n', '\n', '  // The time where no more bookings can be done\n', '  uint256 public endBookings;\n', '\n', '  // A mapping of the rooms booked by night, it saves the guest address by\n', '  // room/night\n', '  // RoomType => Night => Room => Booking\n', '  struct Booking {\n', '    address guest;\n', '    bytes32 bookingHash;\n', '    uint256 payed;\n', '    bool isEther;\n', '  }\n', '  struct RoomType {\n', '    uint256 totalRooms;\n', '    mapping(uint256 => mapping(uint256 => Booking)) nights;\n', '  }\n', '  mapping(string => RoomType) rooms;\n', '\n', '  // An array of the refund polices, it has to be ordered by beforeTime\n', '  struct Refund {\n', '    uint256 beforeTime;\n', '    uint8 dividedBy;\n', '  }\n', '  Refund[] public refunds;\n', '\n', '  // The total amount of nights offered for booking\n', '  uint256 public totalNights;\n', '\n', '  // The ERC20 lifToken that will be used for payment\n', '  ERC20 public lifToken;\n', '\n', '  event BookingCanceled(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address newGuest, bytes32 bookingHash\n', '  );\n', '\n', '  event BookingChanged(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address newGuest, bytes32 bookingHash\n', '  );\n', '\n', '  event BookingDone(\n', '    string roomType, uint256[] nights, uint256 room,\n', '    address guest, bytes32 bookingHash\n', '  );\n', '\n', '  event RoomsAdded(string roomType, uint256 newRooms);\n', '\n', '  /**\n', '   * @dev Constructor\n', '   * @param _offerSigner Address of the account that will sign offers\n', '   * @param _lifToken Address of the Lif token contract\n', '   * @param _totalNights The max amount of nights to be booked\n', '   */\n', '  constructor(\n', '    address _offerSigner, address _lifToken,\n', '    uint256 _totalNights, uint256 _endBookings\n', '  ) public {\n', '    require(_offerSigner != address(0));\n', '    require(_lifToken != address(0));\n', '    require(_totalNights > 0);\n', '    require(_endBookings > now);\n', '    offerSigner = _offerSigner;\n', '    lifToken = ERC20(_lifToken);\n', '    totalNights = _totalNights;\n', '    endBookings = _endBookings;\n', '  }\n', '\n', '  /**\n', '   * @dev Change the signer or lif token addresses, only called by owner\n', '   * @param _offerSigner Address of the account that will sign offers\n', '   * @param _lifToken Address of the Lif token contract\n', '   */\n', '  function edit(address _offerSigner, address _lifToken) onlyOwner public {\n', '    require(_offerSigner != address(0));\n', '    require(_lifToken != address(0));\n', '    offerSigner = _offerSigner;\n', '    lifToken = ERC20(_lifToken);\n', '  }\n', '\n', '  /**\n', '   * @dev Add a refund policy\n', '   * @param _beforeTime The time before this refund can be executed\n', '   * @param _dividedBy The divisor of the payment value\n', '   */\n', '  function addRefund(uint256 _beforeTime, uint8 _dividedBy) onlyOwner public {\n', '    if (refunds.length > 0)\n', '      require(refunds[refunds.length-1].beforeTime > _beforeTime);\n', '    refunds.push(Refund(_beforeTime, _dividedBy));\n', '  }\n', '\n', '  /**\n', '   * @dev Change a refund policy\n', '   * @param _beforeTime The time before this refund can be executed\n', '   * @param _dividedBy The divisor of the payment value\n', '   */\n', '  function changeRefund(\n', '    uint8 _refundIndex, uint256 _beforeTime, uint8 _dividedBy\n', '  ) onlyOwner public {\n', '    if (_refundIndex > 0)\n', '      require(refunds[_refundIndex-1].beforeTime > _beforeTime);\n', '    refunds[_refundIndex].beforeTime = _beforeTime;\n', '    refunds[_refundIndex].dividedBy = _dividedBy;\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of rooms offered, only called by owner\n', '   * @param roomType The room type to be added\n', '   * @param amount The amount of rooms to be increased\n', '   */\n', '  function addRooms(string roomType, uint256 amount) onlyOwner public {\n', '    rooms[roomType].totalRooms = rooms[roomType].totalRooms.add(amount);\n', '    emit RoomsAdded(roomType, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room for a certain address, internal function\n', '   * @param roomType The room type to be booked\n', '   * @param _nights The nights that we want to book\n', '   * @param room The room that wants to be booked\n', '   * @param guest The address of the guest that will book the room\n', '   */\n', '  function bookRoom(\n', '    string roomType, uint256[] _nights, uint256 room,\n', '    address guest, bytes32 bookingHash, uint256 weiPerNight, bool isEther\n', '  ) internal {\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      rooms[roomType].nights[_nights[i]][room].guest = guest;\n', '      rooms[roomType].nights[_nights[i]][room].bookingHash = bookingHash;\n', '      rooms[roomType].nights[_nights[i]][room].payed = weiPerNight;\n', '      rooms[roomType].nights[_nights[i]][room].isEther = isEther;\n', '    }\n', '    emit BookingDone(roomType, _nights, room, guest, bookingHash);\n', '  }\n', '\n', '  event log(uint256 msg);\n', '\n', '  /**\n', '   * @dev Cancel a booking\n', '   * @param roomType The room type to be booked\n', '   * @param _nights The nights that we want to book\n', '   * @param room The room that wants to be booked\n', '   */\n', '  function cancelBooking(\n', '    string roomType, uint256[] _nights,\n', '    uint256 room, bytes32 bookingHash, bool isEther\n', '  ) public {\n', '\n', '    // Check the booking and delete it\n', '    uint256 totalPayed = 0;\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      require(rooms[roomType].nights[_nights[i]][room].guest == msg.sender);\n', '      require(rooms[roomType].nights[_nights[i]][room].isEther == isEther);\n', '      require(rooms[roomType].nights[_nights[i]][room].bookingHash == bookingHash);\n', '      totalPayed = totalPayed.add(\n', '        rooms[roomType].nights[_nights[i]][room].payed\n', '      );\n', '      delete rooms[roomType].nights[_nights[i]][room];\n', '    }\n', '\n', '    // Calculate refund amount\n', '    uint256 refundAmount = 0;\n', '    for (i = 0; i < refunds.length; i ++) {\n', '      if (now < endBookings.sub(refunds[i].beforeTime)){\n', '        refundAmount = totalPayed.div(refunds[i].dividedBy);\n', '        break;\n', '      }\n', '    }\n', '\n', '    // Forward refund funds\n', '    if (isEther)\n', '      msg.sender.transfer(refundAmount);\n', '    else\n', '      lifToken.transfer(msg.sender, refundAmount);\n', '\n', '    emit BookingCanceled(roomType, _nights, room, msg.sender, bookingHash);\n', '  }\n', '\n', '  /**\n', '   * @dev Withdraw tokens and eth, only from owner contract\n', '   */\n', '  function withdraw() public onlyOwner {\n', '    require(now > endBookings);\n', '    lifToken.transfer(owner, lifToken.balanceOf(address(this)));\n', '    owner.transfer(address(this).balance);\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room paying with ETH\n', '   * @param pricePerNight The price per night in wei\n', '   * @param offerTimestamp The timestamp of when the offer ends\n', '   * @param offerSignature The signature provided by the offer signer\n', '   * @param roomType The room type that the guest wants to book\n', '   * @param _nights The nights that the guest wants to book\n', '   */\n', '  function bookWithEth(\n', '    uint256 pricePerNight,\n', '    uint256 offerTimestamp,\n', '    bytes offerSignature,\n', '    string roomType,\n', '    uint256[] _nights,\n', '    bytes32 bookingHash\n', '  ) public payable {\n', '    // Check that the offer is still valid\n', '    require(offerTimestamp < now);\n', '    require(now < endBookings);\n', '\n', '    // Check the eth sent\n', '    require(pricePerNight.mul(_nights.length) <= msg.value);\n', '\n', '    // Check if there is at least one room available\n', '    uint256 available = firstRoomAvailable(roomType, _nights);\n', '    require(available > 0);\n', '\n', '    // Check the signer of the offer is the right address\n', '    bytes32 priceSigned = keccak256(abi.encodePacked(\n', '      roomType, pricePerNight, offerTimestamp, "eth", bookingHash\n', '    )).toEthSignedMessageHash();\n', '    require(offerSigner == priceSigned.recover(offerSignature));\n', '\n', '    // Assign the available room to the guest\n', '    bookRoom(\n', '      roomType, _nights, available, msg.sender,\n', '      bookingHash, pricePerNight, true\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Book a room paying with Lif\n', '   * @param pricePerNight The price per night in wei\n', '   * @param offerTimestamp The timestamp of when the offer ends\n', '   * @param offerSignature The signature provided by the offer signer\n', '   * @param roomType The room type that the guest wants to book\n', '   * @param _nights The nights that the guest wants to book\n', '   */\n', '  function bookWithLif(\n', '    uint256 pricePerNight,\n', '    uint256 offerTimestamp,\n', '    bytes offerSignature,\n', '    string roomType,\n', '    uint256[] _nights,\n', '    bytes32 bookingHash\n', '  ) public {\n', '    // Check that the offer is still valid\n', '    require(offerTimestamp < now);\n', '\n', '    // Check the amount of lifTokens allowed to be spent by this contract\n', '    uint256 lifTokenAllowance = lifToken.allowance(msg.sender, address(this));\n', '    require(pricePerNight.mul(_nights.length) <= lifTokenAllowance);\n', '\n', '    // Check if there is at least one room available\n', '    uint256 available = firstRoomAvailable(roomType, _nights);\n', '    require(available > 0);\n', '\n', '    // Check the signer of the offer is the right address\n', '    bytes32 priceSigned = keccak256(abi.encodePacked(\n', '      roomType, pricePerNight, offerTimestamp, "lif", bookingHash\n', '    )).toEthSignedMessageHash();\n', '    require(offerSigner == priceSigned.recover(offerSignature));\n', '\n', '    // Assign the available room to the guest\n', '    bookRoom(\n', '      roomType, _nights, available, msg.sender,\n', '      bookingHash, pricePerNight, false\n', '    );\n', '\n', '    // Transfer the lifTokens to booking\n', '    lifToken.transferFrom(msg.sender, address(this), lifTokenAllowance);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the total rooms for a room type\n', '   * @param roomType The room type that wants to be booked\n', '   */\n', '  function totalRooms(string roomType) view public returns (uint256) {\n', '    return rooms[roomType].totalRooms;\n', '  }\n', '\n', '  /**\n', '   * @dev Get a booking information\n', '   * @param roomType The room type\n', '   * @param room The room booked\n', '   * @param night The night of the booking\n', '   */\n', '  function getBooking(\n', '    string roomType, uint256 room, uint256 night\n', '  ) view public returns (address, uint256, bytes32, bool) {\n', '    return (\n', '      rooms[roomType].nights[night][room].guest,\n', '      rooms[roomType].nights[night][room].payed,\n', '      rooms[roomType].nights[night][room].bookingHash,\n', '      rooms[roomType].nights[night][room].isEther\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Get the availability of a specific room\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @param room The room that wants to be booked\n', '   * @return bool If the room is available or not\n', '   */\n', '  function roomAvailable(\n', '    string roomType, uint256[] _nights, uint256 room\n', '  ) view public returns (bool) {\n', '    require(room <= rooms[roomType].totalRooms);\n', '    for (uint i = 0; i < _nights.length; i ++) {\n', '      require(_nights[i] <= totalNights);\n', '      if (rooms[roomType].nights[_nights[i]][room].guest != address(0))\n', '        return false;\n', '      }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Get the available rooms for certain nights\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @return uint256 Array of the rooms available for that nights\n', '   */\n', '  function roomsAvailable(\n', '    string roomType, uint256[] _nights\n', '  ) view public returns (uint256[]) {\n', '    require(_nights[i] <= totalNights);\n', '    uint256[] memory available = new uint256[](rooms[roomType].totalRooms);\n', '    for (uint z = 1; z <= rooms[roomType].totalRooms; z ++) {\n', '      available[z-1] = z;\n', '      for (uint i = 0; i < _nights.length; i ++)\n', '        if (rooms[roomType].nights[_nights[i]][z].guest != address(0)) {\n', '          available[z-1] = 0;\n', '          break;\n', '        }\n', '    }\n', '    return available;\n', '  }\n', '\n', '  /**\n', '   * @dev Get the first available room for certain nights\n', '   * @param roomType The room type that wants to be booked\n', '   * @param _nights The nights to check availability\n', '   * @return uint256 The first available room\n', '   */\n', '  function firstRoomAvailable(\n', '    string roomType, uint256[] _nights\n', '  ) internal returns (uint256) {\n', '    require(_nights[i] <= totalNights);\n', '    uint256 available = 0;\n', '    bool isAvailable;\n', '    for (uint z = rooms[roomType].totalRooms; z >= 1 ; z --) {\n', '      isAvailable = true;\n', '      for (uint i = 0; i < _nights.length; i ++) {\n', '        if (rooms[roomType].nights[_nights[i]][z].guest != address(0))\n', '          isAvailable = false;\n', '          break;\n', '        }\n', '      if (isAvailable)\n', '        available = z;\n', '    }\n', '    return available;\n', '  }\n', '\n', '}']
