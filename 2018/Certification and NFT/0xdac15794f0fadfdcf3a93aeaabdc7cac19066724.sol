['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract GreenX is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "GREENX";\n', '    string public constant symbol = "GEX";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 375000000 * 10 ** 18; // 375 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public portalAddress;\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public teamAddress;\n', '\n', '    mapping(address => bool) public privateList;\n', '    mapping(address => bool) public whiteList;\n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 180 days; // 1st locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod2 = 1 years; // 2nd locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod3 = 2 years; // locked period for remaining sale tokens after ending ICO\n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_PRIVATE_SALE = 1; // In private sales\n', '    uint constant IN_PRESALE = 2; // In presales\n', '    uint constant END_PRESALE = 3; // End presales\n', '    uint constant IN_1ST_ICO = 4; // In ICO 1st round\n', '    uint constant IN_2ND_ICO = 5; // In ICO 2nd round\n', '    uint constant IN_3RD_ICO = 6; // In ICO 3rd round\n', '    uint constant END_SALE = 7; // End sales\n', '\n', '    uint256 public constant salesAllocation = 187500000 * 10 ** 18; // 187.5 mil tokens allocated for sales\n', '    uint256 public constant bonusAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for token sale bonuses\n', '    uint256 public constant reservedAllocation = 90000000 * 10 ** 18; // 90 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant founderAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for founders\n', '    uint256 public constant teamAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for team\n', '    uint256 public constant minInvestedCap = 2500 * 10 ** 18; // 2500 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public teamAllocatedTime = 1;\n', '    uint256 public privateSalePrice;\n', '    uint256 public preSalePrice;\n', '    uint256 public icoStandardPrice;\n', '    uint256 public ico1stPrice;\n', '    uint256 public ico2ndPrice;\n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalReservedAndBonusTokenAllocation; // Total tokens allocated for reserved and bonuses\n', '    uint256 public totalLoadedRefund; // Total ether will be loaded to contract for refund\n', '    uint256 public totalRefundedAmount; // Total ether refunded to investors\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', '    event ModifyWhiteList(address investorAddress, bool isWhiteListed);  // Add or remove investor&#39;s address to or from white list\n', '    event ModifyPrivateList(address investorAddress, bool isPrivateListed);  // Add or remove investor&#39;s address to or from private list\n', '    event StartPrivateSales(uint state); // Start private sales\n', '    event StartPresales(uint state); // Start presales\n', '    event EndPresales(uint state); // End presales\n', '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    event SetPrivateSalePrice(uint256 price); // Set private sale price\n', '    event SetPreSalePrice(uint256 price); // Set presale price\n', '    event SetICOPrice(uint256 price); // Set ICO standard price\n', '    \n', '    event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); // Issue tokens to investor\n', '    event RevokeTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint256 txFee); // Revoke tokens after ending ICO for incompleted KYC investors\n', '    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders&#39; address\n', '    event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); // Allocate tokens to team&#39;s address\n', '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event Refund(address investorAddress, uint256 etherRefundedAmount, uint256 tokensRevokedAmount); // Refund ether and revoke tokens for investors\n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress || msg.sender == portalAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function GreenX(address _walletAddr, address _adminAddr, address _portalAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '        require(_portalAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        portalAddress = _portalAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalReservedAndBonusTokenAllocation = reservedAllocation + bonusAllocation;\n', '    }\n', '\n', '    // Fallback function for token purchasing  \n', '    function () external payable isActive isInSale {\n', '        uint state = getCurrentState();\n', '        require(state >= IN_PRIVATE_SALE && state < END_SALE);\n', '        require(msg.value >= minInvestedAmount);\n', '\n', '        bool isPrivate = privateList[msg.sender];\n', '        if (isPrivate == true) {\n', '            return issueTokensForPrivateInvestor(state);\n', '        }\n', '        if (state == IN_PRESALE) {\n', '            return issueTokensForPresale(state);\n', '        }\n', '        if (IN_1ST_ICO <= state && state <= IN_3RD_ICO) {\n', '            return issueTokensForICO(state);\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Load ether amount to contract for refunding or revoking\n', '    function loadFund() external payable {\n', '        require(msg.value > 0);\n', '\t\t\n', '        totalLoadedRefund = totalLoadedRefund.add(msg.value);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Modify white list\n', '    function modifyWhiteList(address[] _investorAddrs, bool _isWhiteListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            whiteList[_investorAddrs[i]] = _isWhiteListed;\n', '            emit ModifyWhiteList(_investorAddrs[i], _isWhiteListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Modify private list\n', '    function modifyPrivateList(address[] _investorAddrs, bool _isPrivateListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            privateList[_investorAddrs[i]] = _isPrivateListed;\n', '            emit ModifyPrivateList(_investorAddrs[i], _isPrivateListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Start private sales\n', '    function startPrivateSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == NOT_SALE);\n', '        require(privateSalePrice > 0);\n', '\t\t\n', '        saleState = IN_PRIVATE_SALE;\n', '        isSelling = true;\n', '        emit StartPrivateSales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Start presales\n', '    function startPreSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState < IN_PRESALE);\n', '        require(preSalePrice > 0);\n', '\t\t\n', '        saleState = IN_PRESALE;\n', '        isSelling = true;\n', '        emit StartPresales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End presales\n', '    function endPreSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == IN_PRESALE);\n', '\t\t\n', '        saleState = END_PRESALE;\n', '        isSelling = false;\n', '        emit EndPresales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == END_PRESALE);\n', '        require(icoStandardPrice > 0);\n', '\t\t\n', '        saleState = IN_1ST_ICO;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(getCurrentState() == IN_3RD_ICO);\n', '        require(icoEndTime == 0);\n', '\t\t\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Set private sales price\n', '    function setPrivateSalePrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        privateSalePrice = _tokenPerEther;\n', '        emit SetPrivateSalePrice(privateSalePrice);\n', '        return true;\n', '    }\n', '\n', '    // Set presales price\n', '    function setPreSalePrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        preSalePrice = _tokenPerEther;\n', '        emit SetPreSalePrice(preSalePrice);\n', '        return true;\n', '    }\n', '\n', '    // Set ICO price including ICO standard price, ICO 1st round price, ICO 2nd round price\n', '    function setICOPrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        icoStandardPrice = _tokenPerEther;\n', '        ico1stPrice = _tokenPerEther + _tokenPerEther * 20 / 100;\n', '        ico2ndPrice = _tokenPerEther + _tokenPerEther * 10 / 100;\n', '        emit SetICOPrice(icoStandardPrice);\n', '        return true;\n', '    }\n', '\n', '    // Revoke tokens from incompleted KYC investors&#39; addresses\n', '    function revokeTokens(address _noneKycAddr, uint256 _transactionFee) external onlyOwnerOrAdmin {\n', '        require(_noneKycAddr != address(0));\n', '        uint256 investedAmount = totalInvestedAmountOf[_noneKycAddr];\n', '        uint256 totalRemainingRefund = totalLoadedRefund.sub(totalRefundedAmount);\n', '        require(whiteList[_noneKycAddr] == false && privateList[_noneKycAddr] == false);\n', '        require(investedAmount > 0);\n', '        require(totalRemainingRefund >= investedAmount);\n', '        require(saleState == END_SALE);\n', '\t\t\n', '        uint256 refundAmount = investedAmount.sub(_transactionFee);\n', '        uint tokenRevoked = balances[_noneKycAddr];\n', '        totalInvestedAmountOf[_noneKycAddr] = 0;\n', '        balances[_noneKycAddr] = 0;\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.add(tokenRevoked);\n', '        totalRefundedAmount = totalRefundedAmount.add(refundAmount);\n', '        _noneKycAddr.transfer(refundAmount);\n', '        emit RevokeTokens(_noneKycAddr, refundAmount, tokenRevoked, _transactionFee);\n', '    }    \n', '\n', '    // Investors can claim ether refund if total raised fund doesn&#39;t reach our softcap\n', '    function refund() external {\n', '        uint256 refundedAmount = totalInvestedAmountOf[msg.sender];\n', '        uint256 totalRemainingRefund = totalLoadedRefund.sub(totalRefundedAmount);\n', '        uint256 tokenRevoked = balances[msg.sender];\n', '        require(saleState == END_SALE);\n', '        require(!isSoftCapReached());\n', '        require(totalRemainingRefund >= refundedAmount && refundedAmount > 0);\n', '\t\t\n', '        totalInvestedAmountOf[msg.sender] = 0;\n', '        balances[msg.sender] = 0;\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.add(tokenRevoked);\n', '        totalRefundedAmount = totalRefundedAmount.add(refundedAmount);\n', '        msg.sender.transfer(refundedAmount);\n', '        emit Refund(msg.sender, refundedAmount, tokenRevoked);\n', '    }    \n', '\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '\n', '    // Modify portal\n', '    function changePortalAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(portalAddress != _newAddress);\n', '        portalAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(teamAddress != _newAddress);\n', '        teamAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 1 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = founderAllocation * 20/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = founderAllocation * 30/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 4;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate tokens for team vested gradually for 1 year\n', '    function allocateTokensForTeam() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(teamAddress != address(0));\n', '        uint256 amount;\n', '        if (teamAllocatedTime == 1) {\n', '            amount = teamAllocation * 20/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = teamAllocation * 30/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = teamAllocation * 50/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 4;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Remaining tokens for sales will be locked by contract in 2 years\n', '    function allocateRemainingTokens(address _addr) external isActive onlyOwnerOrAdmin {\n', '        require(_addr != address(0));\n', '        require(saleState == END_SALE);\n', '        require(totalRemainingTokensForSales > 0);\n', '        require(now >= icoEndTime + lockPeriod3);\n', '        balances[_addr] = balances[_addr].add(totalRemainingTokensForSales);\n', '        totalRemainingTokensForSales = 0;\n', '    }\n', '\n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedAndBonusTokenAllocation = totalReservedAndBonusTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get current sales state\n', '    function getCurrentState() public view returns(uint256) {\n', '        if (saleState == IN_1ST_ICO) {\n', '            if (now > icoStartTime + 30 days) {\n', '                return IN_3RD_ICO;\n', '            }\n', '            if (now > icoStartTime + 15 days) {\n', '                return IN_2ND_ICO;\n', '            }\n', '            return IN_1ST_ICO;\n', '        }\n', '        return saleState;\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '\n', '    // Issue tokens to private investors\n', '    function issueTokensForPrivateInvestor(uint _state) private {\n', '        uint256 price = privateSalePrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to normal investors in presales\n', '    function issueTokensForPresale(uint _state) private {\n', '        uint256 price = preSalePrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to normal investors through ICO rounds\n', '    function issueTokensForICO(uint _state) private {\n', '        uint256 price = icoStandardPrice;\n', '        if (_state == IN_1ST_ICO) {\n', '            price = ico1stPrice;\n', '        } else if (_state == IN_2ND_ICO) {\n', '            price = ico2ndPrice;\n', '        }\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to investors and transfer ether to wallet\n', '    function issueTokens(uint256 _price, uint _state) private {\n', '        require(walletAddress != address(0));\n', '\t\t\n', '        uint tokenAmount = msg.value.mul(_price).mul(10**18).div(1 ether);\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '        totalInvestedAmountOf[msg.sender] = totalInvestedAmountOf[msg.sender].add(msg.value);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(tokenAmount);\n', '        totalInvestedAmount = totalInvestedAmount.add(msg.value);\n', '        walletAddress.transfer(msg.value);\n', '        emit IssueTokens(msg.sender, msg.value, tokenAmount, _state);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'contract Owner {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Owner(address _owner) public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function changeOwner(address _newOwnerAddr) public onlyOwner {\n', '        require(_newOwnerAddr != address(0));\n', '        owner = _newOwnerAddr;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract GreenX is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "GREENX";\n', '    string public constant symbol = "GEX";\n', '    uint public constant decimals = 18;\n', '    uint256 constant public totalSupply = 375000000 * 10 ** 18; // 375 mil tokens will be supplied\n', '  \n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '\n', '    address public portalAddress;\n', '    address public adminAddress;\n', '    address public walletAddress;\n', '    address public founderAddress;\n', '    address public teamAddress;\n', '\n', '    mapping(address => bool) public privateList;\n', '    mapping(address => bool) public whiteList;\n', '    mapping(address => uint256) public totalInvestedAmountOf;\n', '\n', '    uint constant lockPeriod1 = 180 days; // 1st locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod2 = 1 years; // 2nd locked period for tokens allocation of founder and team\n', '    uint constant lockPeriod3 = 2 years; // locked period for remaining sale tokens after ending ICO\n', '    uint constant NOT_SALE = 0; // Not in sales\n', '    uint constant IN_PRIVATE_SALE = 1; // In private sales\n', '    uint constant IN_PRESALE = 2; // In presales\n', '    uint constant END_PRESALE = 3; // End presales\n', '    uint constant IN_1ST_ICO = 4; // In ICO 1st round\n', '    uint constant IN_2ND_ICO = 5; // In ICO 2nd round\n', '    uint constant IN_3RD_ICO = 6; // In ICO 3rd round\n', '    uint constant END_SALE = 7; // End sales\n', '\n', '    uint256 public constant salesAllocation = 187500000 * 10 ** 18; // 187.5 mil tokens allocated for sales\n', '    uint256 public constant bonusAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for token sale bonuses\n', '    uint256 public constant reservedAllocation = 90000000 * 10 ** 18; // 90 mil tokens allocated for reserved, bounty campaigns, ICO partners, and bonus fund\n', '    uint256 public constant founderAllocation = 37500000 * 10 ** 18; // 37.5 mil tokens allocated for founders\n', '    uint256 public constant teamAllocation = 22500000 * 10 ** 18; // 22.5 mil tokens allocated for team\n', '    uint256 public constant minInvestedCap = 2500 * 10 ** 18; // 2500 ether for softcap \n', '    uint256 public constant minInvestedAmount = 0.1 * 10 ** 18; // 0.1 ether for mininum ether contribution per transaction\n', '    \n', '    uint saleState;\n', '    uint256 totalInvestedAmount;\n', '    uint public icoStartTime;\n', '    uint public icoEndTime;\n', '    bool public inActive;\n', '    bool public isSelling;\n', '    bool public isTransferable;\n', '    uint public founderAllocatedTime = 1;\n', '    uint public teamAllocatedTime = 1;\n', '    uint256 public privateSalePrice;\n', '    uint256 public preSalePrice;\n', '    uint256 public icoStandardPrice;\n', '    uint256 public ico1stPrice;\n', '    uint256 public ico2ndPrice;\n', '    uint256 public totalRemainingTokensForSales; // Total tokens remaining for sales\n', '    uint256 public totalReservedAndBonusTokenAllocation; // Total tokens allocated for reserved and bonuses\n', '    uint256 public totalLoadedRefund; // Total ether will be loaded to contract for refund\n', '    uint256 public totalRefundedAmount; // Total ether refunded to investors\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value); // ERC20 standard event\n', '    event Transfer(address indexed from, address indexed to, uint256 value); // ERC20 standard event\n', '\n', "    event ModifyWhiteList(address investorAddress, bool isWhiteListed);  // Add or remove investor's address to or from white list\n", "    event ModifyPrivateList(address investorAddress, bool isPrivateListed);  // Add or remove investor's address to or from private list\n", '    event StartPrivateSales(uint state); // Start private sales\n', '    event StartPresales(uint state); // Start presales\n', '    event EndPresales(uint state); // End presales\n', '    event StartICO(uint state); // Start ICO sales\n', '    event EndICO(uint state); // End ICO sales\n', '    \n', '    event SetPrivateSalePrice(uint256 price); // Set private sale price\n', '    event SetPreSalePrice(uint256 price); // Set presale price\n', '    event SetICOPrice(uint256 price); // Set ICO standard price\n', '    \n', '    event IssueTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint state); // Issue tokens to investor\n', '    event RevokeTokens(address investorAddress, uint256 amount, uint256 tokenAmount, uint256 txFee); // Revoke tokens after ending ICO for incompleted KYC investors\n', "    event AllocateTokensForFounder(address founderAddress, uint256 founderAllocatedTime, uint256 tokenAmount); // Allocate tokens to founders' address\n", "    event AllocateTokensForTeam(address teamAddress, uint256 teamAllocatedTime, uint256 tokenAmount); // Allocate tokens to team's address\n", '    event AllocateReservedTokens(address reservedAddress, uint256 tokenAmount); // Allocate reserved tokens\n', '    event Refund(address investorAddress, uint256 etherRefundedAmount, uint256 tokensRevokedAmount); // Refund ether and revoke tokens for investors\n', '\n', '    modifier isActive() {\n', '        require(inActive == false);\n', '        _;\n', '    }\n', '\n', '    modifier isInSale() {\n', '        require(isSelling == true);\n', '        _;\n', '    }\n', '\n', '    modifier transferable() {\n', '        require(isTransferable == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdminOrPortal() {\n', '        require(msg.sender == owner || msg.sender == adminAddress || msg.sender == portalAddress);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    function GreenX(address _walletAddr, address _adminAddr, address _portalAddr) public Owner(msg.sender) {\n', '        require(_walletAddr != address(0));\n', '        require(_adminAddr != address(0));\n', '        require(_portalAddr != address(0));\n', '\t\t\n', '        walletAddress = _walletAddr;\n', '        adminAddress = _adminAddr;\n', '        portalAddress = _portalAddr;\n', '        inActive = true;\n', '        totalInvestedAmount = 0;\n', '        totalRemainingTokensForSales = salesAllocation;\n', '        totalReservedAndBonusTokenAllocation = reservedAllocation + bonusAllocation;\n', '    }\n', '\n', '    // Fallback function for token purchasing  \n', '    function () external payable isActive isInSale {\n', '        uint state = getCurrentState();\n', '        require(state >= IN_PRIVATE_SALE && state < END_SALE);\n', '        require(msg.value >= minInvestedAmount);\n', '\n', '        bool isPrivate = privateList[msg.sender];\n', '        if (isPrivate == true) {\n', '            return issueTokensForPrivateInvestor(state);\n', '        }\n', '        if (state == IN_PRESALE) {\n', '            return issueTokensForPresale(state);\n', '        }\n', '        if (IN_1ST_ICO <= state && state <= IN_3RD_ICO) {\n', '            return issueTokensForICO(state);\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Load ether amount to contract for refunding or revoking\n', '    function loadFund() external payable {\n', '        require(msg.value > 0);\n', '\t\t\n', '        totalLoadedRefund = totalLoadedRefund.add(msg.value);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transfer(address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function transferFrom(address _from, address _to, uint256 _value) external transferable returns (bool) {\n', '        require(_to != address(0));\n', '        require(_from != address(0));\n', '        require(_value > 0);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function approve(address _spender, uint256 _value) external transferable returns (bool) {\n', '        require(_spender != address(0));\n', '        require(_value > 0);\n', '\t\t\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // Modify white list\n', '    function modifyWhiteList(address[] _investorAddrs, bool _isWhiteListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            whiteList[_investorAddrs[i]] = _isWhiteListed;\n', '            emit ModifyWhiteList(_investorAddrs[i], _isWhiteListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Modify private list\n', '    function modifyPrivateList(address[] _investorAddrs, bool _isPrivateListed) external isActive onlyOwnerOrAdminOrPortal returns(bool) {\n', '        for (uint256 i = 0; i < _investorAddrs.length; i++) {\n', '            privateList[_investorAddrs[i]] = _isPrivateListed;\n', '            emit ModifyPrivateList(_investorAddrs[i], _isPrivateListed);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Start private sales\n', '    function startPrivateSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == NOT_SALE);\n', '        require(privateSalePrice > 0);\n', '\t\t\n', '        saleState = IN_PRIVATE_SALE;\n', '        isSelling = true;\n', '        emit StartPrivateSales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Start presales\n', '    function startPreSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState < IN_PRESALE);\n', '        require(preSalePrice > 0);\n', '\t\t\n', '        saleState = IN_PRESALE;\n', '        isSelling = true;\n', '        emit StartPresales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End presales\n', '    function endPreSales() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == IN_PRESALE);\n', '\t\t\n', '        saleState = END_PRESALE;\n', '        isSelling = false;\n', '        emit EndPresales(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Start ICO\n', '    function startICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(saleState == END_PRESALE);\n', '        require(icoStandardPrice > 0);\n', '\t\t\n', '        saleState = IN_1ST_ICO;\n', '        icoStartTime = now;\n', '        isSelling = true;\n', '        emit StartICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // End ICO\n', '    function endICO() external isActive onlyOwnerOrAdmin returns (bool) {\n', '        require(getCurrentState() == IN_3RD_ICO);\n', '        require(icoEndTime == 0);\n', '\t\t\n', '        saleState = END_SALE;\n', '        isSelling = false;\n', '        icoEndTime = now;\n', '        emit EndICO(saleState);\n', '        return true;\n', '    }\n', '\n', '    // Set private sales price\n', '    function setPrivateSalePrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        privateSalePrice = _tokenPerEther;\n', '        emit SetPrivateSalePrice(privateSalePrice);\n', '        return true;\n', '    }\n', '\n', '    // Set presales price\n', '    function setPreSalePrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        preSalePrice = _tokenPerEther;\n', '        emit SetPreSalePrice(preSalePrice);\n', '        return true;\n', '    }\n', '\n', '    // Set ICO price including ICO standard price, ICO 1st round price, ICO 2nd round price\n', '    function setICOPrice(uint256 _tokenPerEther) external onlyOwnerOrAdmin returns(bool) {\n', '        require(_tokenPerEther > 0);\n', '\t\t\n', '        icoStandardPrice = _tokenPerEther;\n', '        ico1stPrice = _tokenPerEther + _tokenPerEther * 20 / 100;\n', '        ico2ndPrice = _tokenPerEther + _tokenPerEther * 10 / 100;\n', '        emit SetICOPrice(icoStandardPrice);\n', '        return true;\n', '    }\n', '\n', "    // Revoke tokens from incompleted KYC investors' addresses\n", '    function revokeTokens(address _noneKycAddr, uint256 _transactionFee) external onlyOwnerOrAdmin {\n', '        require(_noneKycAddr != address(0));\n', '        uint256 investedAmount = totalInvestedAmountOf[_noneKycAddr];\n', '        uint256 totalRemainingRefund = totalLoadedRefund.sub(totalRefundedAmount);\n', '        require(whiteList[_noneKycAddr] == false && privateList[_noneKycAddr] == false);\n', '        require(investedAmount > 0);\n', '        require(totalRemainingRefund >= investedAmount);\n', '        require(saleState == END_SALE);\n', '\t\t\n', '        uint256 refundAmount = investedAmount.sub(_transactionFee);\n', '        uint tokenRevoked = balances[_noneKycAddr];\n', '        totalInvestedAmountOf[_noneKycAddr] = 0;\n', '        balances[_noneKycAddr] = 0;\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.add(tokenRevoked);\n', '        totalRefundedAmount = totalRefundedAmount.add(refundAmount);\n', '        _noneKycAddr.transfer(refundAmount);\n', '        emit RevokeTokens(_noneKycAddr, refundAmount, tokenRevoked, _transactionFee);\n', '    }    \n', '\n', "    // Investors can claim ether refund if total raised fund doesn't reach our softcap\n", '    function refund() external {\n', '        uint256 refundedAmount = totalInvestedAmountOf[msg.sender];\n', '        uint256 totalRemainingRefund = totalLoadedRefund.sub(totalRefundedAmount);\n', '        uint256 tokenRevoked = balances[msg.sender];\n', '        require(saleState == END_SALE);\n', '        require(!isSoftCapReached());\n', '        require(totalRemainingRefund >= refundedAmount && refundedAmount > 0);\n', '\t\t\n', '        totalInvestedAmountOf[msg.sender] = 0;\n', '        balances[msg.sender] = 0;\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.add(tokenRevoked);\n', '        totalRefundedAmount = totalRefundedAmount.add(refundedAmount);\n', '        msg.sender.transfer(refundedAmount);\n', '        emit Refund(msg.sender, refundedAmount, tokenRevoked);\n', '    }    \n', '\n', '    // Activate token sale function\n', '    function activate() external onlyOwner {\n', '        inActive = false;\n', '    }\n', '\n', '    // Deacivate token sale function\n', '    function deActivate() external onlyOwner {\n', '        inActive = true;\n', '    }\n', '\n', '    // Enable transfer feature of tokens\n', '    function enableTokenTransfer() external isActive onlyOwner {\n', '        isTransferable = true;\n', '    }\n', '\n', '    // Modify wallet\n', '    function changeWallet(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(walletAddress != _newAddress);\n', '        walletAddress = _newAddress;\n', '    }\n', '\n', '    // Modify admin\n', '    function changeAdminAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(adminAddress != _newAddress);\n', '        adminAddress = _newAddress;\n', '    }\n', '\n', '    // Modify portal\n', '    function changePortalAddress(address _newAddress) external onlyOwner {\n', '        require(_newAddress != address(0));\n', '        require(portalAddress != _newAddress);\n', '        portalAddress = _newAddress;\n', '    }\n', '  \n', '    // Modify founder address to receive founder tokens allocation\n', '    function changeFounderAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(founderAddress != _newAddress);\n', '        founderAddress = _newAddress;\n', '    }\n', '\n', '    // Modify team address to receive team tokens allocation\n', '    function changeTeamAddress(address _newAddress) external onlyOwnerOrAdmin {\n', '        require(_newAddress != address(0));\n', '        require(teamAddress != _newAddress);\n', '        teamAddress = _newAddress;\n', '    }\n', '\n', '    // Allocate tokens for founder vested gradually for 1 year\n', '    function allocateTokensForFounder() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(founderAddress != address(0));\n', '        uint256 amount;\n', '        if (founderAllocatedTime == 1) {\n', '            amount = founderAllocation * 20/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = founderAllocation * 30/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (founderAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = founderAllocation * 50/100;\n', '            balances[founderAddress] = balances[founderAddress].add(amount);\n', '            emit AllocateTokensForFounder(founderAddress, founderAllocatedTime, amount);\n', '            founderAllocatedTime = 4;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Allocate tokens for team vested gradually for 1 year\n', '    function allocateTokensForTeam() external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(teamAddress != address(0));\n', '        uint256 amount;\n', '        if (teamAllocatedTime == 1) {\n', '            amount = teamAllocation * 20/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 2;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 2) {\n', '            require(now >= icoEndTime + lockPeriod1);\n', '            amount = teamAllocation * 30/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 3;\n', '            return;\n', '        }\n', '        if (teamAllocatedTime == 3) {\n', '            require(now >= icoEndTime + lockPeriod2);\n', '            amount = teamAllocation * 50/100;\n', '            balances[teamAddress] = balances[teamAddress].add(amount);\n', '            emit AllocateTokensForTeam(teamAddress, teamAllocatedTime, amount);\n', '            teamAllocatedTime = 4;\n', '            return;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    // Remaining tokens for sales will be locked by contract in 2 years\n', '    function allocateRemainingTokens(address _addr) external isActive onlyOwnerOrAdmin {\n', '        require(_addr != address(0));\n', '        require(saleState == END_SALE);\n', '        require(totalRemainingTokensForSales > 0);\n', '        require(now >= icoEndTime + lockPeriod3);\n', '        balances[_addr] = balances[_addr].add(totalRemainingTokensForSales);\n', '        totalRemainingTokensForSales = 0;\n', '    }\n', '\n', '    // Allocate reserved tokens\n', '    function allocateReservedTokens(address _addr, uint _amount) external isActive onlyOwnerOrAdmin {\n', '        require(saleState == END_SALE);\n', '        require(_amount > 0);\n', '        require(_addr != address(0));\n', '\t\t\n', '        balances[_addr] = balances[_addr].add(_amount);\n', '        totalReservedAndBonusTokenAllocation = totalReservedAndBonusTokenAllocation.sub(_amount);\n', '        emit AllocateReservedTokens(_addr, _amount);\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function allowance(address _owner, address _spender) external constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // ERC20 standard function\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Get current sales state\n', '    function getCurrentState() public view returns(uint256) {\n', '        if (saleState == IN_1ST_ICO) {\n', '            if (now > icoStartTime + 30 days) {\n', '                return IN_3RD_ICO;\n', '            }\n', '            if (now > icoStartTime + 15 days) {\n', '                return IN_2ND_ICO;\n', '            }\n', '            return IN_1ST_ICO;\n', '        }\n', '        return saleState;\n', '    }\n', '\n', '    // Get softcap reaching status\n', '    function isSoftCapReached() public view returns (bool) {\n', '        return totalInvestedAmount >= minInvestedCap;\n', '    }\n', '\n', '    // Issue tokens to private investors\n', '    function issueTokensForPrivateInvestor(uint _state) private {\n', '        uint256 price = privateSalePrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to normal investors in presales\n', '    function issueTokensForPresale(uint _state) private {\n', '        uint256 price = preSalePrice;\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to normal investors through ICO rounds\n', '    function issueTokensForICO(uint _state) private {\n', '        uint256 price = icoStandardPrice;\n', '        if (_state == IN_1ST_ICO) {\n', '            price = ico1stPrice;\n', '        } else if (_state == IN_2ND_ICO) {\n', '            price = ico2ndPrice;\n', '        }\n', '        issueTokens(price, _state);\n', '    }\n', '\n', '    // Issue tokens to investors and transfer ether to wallet\n', '    function issueTokens(uint256 _price, uint _state) private {\n', '        require(walletAddress != address(0));\n', '\t\t\n', '        uint tokenAmount = msg.value.mul(_price).mul(10**18).div(1 ether);\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '        totalInvestedAmountOf[msg.sender] = totalInvestedAmountOf[msg.sender].add(msg.value);\n', '        totalRemainingTokensForSales = totalRemainingTokensForSales.sub(tokenAmount);\n', '        totalInvestedAmount = totalInvestedAmount.add(msg.value);\n', '        walletAddress.transfer(msg.value);\n', '        emit IssueTokens(msg.sender, msg.value, tokenAmount, _state);\n', '    }\n', '}']
