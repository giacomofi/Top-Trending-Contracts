['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract Trigonometry {\n', '\n', '    // Table index into the trigonometric table\n', '    uint constant INDEX_WIDTH = 4;\n', '    // Interpolation between successive entries in the tables\n', '    uint constant INTERP_WIDTH = 8;\n', '    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;\n', '    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;\n', '    uint16 constant ANGLES_IN_CYCLE = 16384;\n', '    uint16 constant QUADRANT_HIGH_MASK = 8192;\n', '    uint16 constant QUADRANT_LOW_MASK = 4096;\n', '    uint constant SINE_TABLE_SIZE = 16;\n', '\n', '    // constant sine lookup table generated by gen_tables.py\n', '    // We have no other choice but this since constant arrays don&#39;t yet exist\n', '    uint8 constant entry_bytes = 2;\n', '    bytes constant sin_table = "\\x00\\x00\\x0c\\x8c\\x18\\xf9\\x25\\x28\\x30\\xfb\\x3c\\x56\\x47\\x1c\\x51\\x33\\x5a\\x82\\x62\\xf1\\x6a\\x6d\\x70\\xe2\\x76\\x41\\x7a\\x7c\\x7d\\x89\\x7f\\x61\\x7f\\xff";\n', '\n', '    /**\n', '     * Convenience function to apply a mask on an integer to extract a certain\n', '     * number of bits. Using exponents since solidity still does not support\n', '     * shifting.\n', '     *\n', '     * @param _value The integer whose bits we want to get\n', '     * @param _width The width of the bits (in bits) we want to extract\n', '     * @param _offset The offset of the bits (in bits) we want to extract\n', '     * @return An integer containing _width bits of _value starting at the\n', '     *         _offset bit\n', '     */\n', '    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {\n', '        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);\n', '    }\n', '\n', '    function sin_table_lookup(uint index) pure internal returns (uint16) {\n', '        bytes memory table = sin_table;\n', '        uint offset = (index + 1) * entry_bytes;\n', '        uint16 trigint_value;\n', '        assembly {\n', '            trigint_value := mload(add(table, offset))\n', '        }\n', '\n', '        return trigint_value;\n', '    }\n', '\n', '    /**\n', '     * Return the sine of an integer approximated angle as a signed 16-bit\n', '     * integer.\n', '     *\n', '     * @param _angle A 14-bit angle. This divides the circle into 16384\n', '     *               angle units, instead of the standard 360 degrees.\n', '     * @return The sine result as a number in the range -32767 to 32767.\n', '     */\n', '    function sin(uint16 _angle) public pure returns (int) {\n', '        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);\n', '        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);\n', '\n', '        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;\n', '        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;\n', '\n', '        if (!is_odd_quadrant) {\n', '            index = SINE_TABLE_SIZE - 1 - index;\n', '        }\n', '\n', '        uint x1 = sin_table_lookup(index);\n', '        uint x2 = sin_table_lookup(index + 1);\n', '        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);\n', '\n', '        int sine;\n', '        if (is_odd_quadrant) {\n', '            sine = int(x1) + int(approximation);\n', '        } else {\n', '            sine = int(x2) - int(approximation);\n', '        }\n', '\n', '        if (is_negative_quadrant) {\n', '            sine *= -1;\n', '        }\n', '\n', '        return sine;\n', '    }\n', '\n', '    /**\n', '     * Return the cos of an integer approximated angle.\n', '     * It functions just like the sin() method but uses the trigonometric\n', '     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.\n', '     */\n', '    function cos(uint16 _angle) public pure returns (int) {\n', '        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {\n', '            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;\n', '        } else {\n', '            _angle += QUADRANT_LOW_MASK;\n', '        }\n', '        return sin(_angle);\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract VirusGame is Ownable, Trigonometry {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '    * Structs\n', '    */\n', '\n', '    struct Virus {\n', '        bytes32 name;\n', '        bytes32 parent;\n', '        uint256 potential;\n', '        uint256 infected;\n', '        uint256 infectedPayed;\n', '        uint256 infectedTriggle;\n', '        uint256 lastWithdraw;\n', '        uint256 lastInfected;\n', '        uint256 generation;\n', '        address owner;\n', '    }\n', '\n', '    /**\n', '    * State\n', '    */\n', '\n', '    uint256 nonce;\n', '\n', '    mapping (address => bytes32[]) public virusOwner;\n', '\n', '    mapping (bytes32 => Virus) public virus;\n', '\n', '    bytes32[] public virusHashes;\n', '\n', '    uint256 public totalPopulation;\n', '\n', '    uint256 public totalInfected;\n', '\n', '    bytes32 public genesisVirus;\n', '\n', '    uint256 public totalBalance;\n', '\n', '    uint256 public totalPayed;\n', '\n', '    /**\n', '    * Modifier\n', '    */\n', '\n', '    modifier useNonce() {\n', '        _;\n', '        nonce = nonce.add(1);\n', '    }\n', '\n', '    modifier healthyPeople() {\n', '        require(totalPopulation > totalInfected);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Functions\n', '    */\n', '\n', '    event LogMutation(\n', '        bytes32 parentHash,\n', '        bytes32 virusHash\n', '    );\n', '\n', '    function mutate(bytes32 _virus, bytes32 _name) payable healthyPeople useNonce public {\n', '        // ensure parent virus exists\n', '        require(virus[_virus].owner != address(0));\n', '\n', '        uint costs = virus[_virus].generation.mul(0.001 ether).add(0.01 ether);\n', '        require(msg.value >= costs);\n', '\n', '        bytes32 newHash = keccak256(_virus, _name, nonce, msg.sender, now);\n', '\n', '        // new potential from virus hash to uint -> sinus or cosinus\n', '        int mutationFactor = sin(uint16(newHash));\n', '        uint uintFactor;\n', '        uint newPotential;\n', '\n', '        if (mutationFactor >= 0) {\n', '            uintFactor = uint(mutationFactor);\n', '            newPotential = virus[_virus].potential.mul(\n', '                uintFactor.mul(20).div(32767).add(100)\n', '            ).div(100);\n', '        } else {\n', '            uintFactor = uint(-mutationFactor);\n', '            newPotential = virus[_virus].potential.mul(\n', '                uintFactor.mul(20).div(32767).add(80)\n', '            ).div(100);\n', '        }\n', '\n', '        virus[newHash].name = _name;\n', '        virus[newHash].parent = _virus;\n', '        virus[newHash].generation = virus[_virus].generation.add(1);\n', '        virus[newHash].potential = newPotential;\n', '        virus[newHash].lastInfected = now;\n', '        virus[newHash].lastWithdraw = now;\n', '        virus[newHash].owner = msg.sender;\n', '\n', '        virusHashes.push(newHash);\n', '        virusOwner[msg.sender].push(newHash);\n', '\n', '        totalBalance = totalBalance.add(\n', '            costs.mul(9).div(10)\n', '        );\n', '\n', '        LogMutation(\n', '            _virus,\n', '            newHash\n', '        );\n', '    }\n', '\n', '    event LogInfection(\n', '        uint infected,\n', '        bytes32 virusHash\n', '    );\n', '\n', '    event LogEndOfWorld();\n', '\n', '    function infect(bytes32 _virus) healthyPeople public {\n', '        require(virus[_virus].owner == msg.sender);\n', '\n', '        // infectedTriggle + potential * delay = infected\n', '        uint delay = now.sub(virus[_virus].lastInfected);\n', '\n', '        uint infected = virus[_virus].infectedTriggle.add(\n', '            virus[_virus].potential.mul(delay).div(1 days)\n', '        );\n', '        \n', '        // infectedTriggle from parent must be set to x% of infected\n', '        virus[virus[_virus].parent].infectedTriggle = virus[virus[_virus].parent].infectedTriggle.add(\n', '            infected.div(10)\n', '        );\n', '\n', '        totalInfected = totalInfected.add(infected);\n', '        virus[_virus].infected = virus[_virus].infected.add(infected);\n', '\n', '        virus[_virus].lastInfected = now;\n', '        virus[_virus].infectedTriggle = 0;\n', '\n', '        LogInfection(\n', '            infected,\n', '            _virus\n', '        );\n', '\n', '        if (totalPopulation < totalInfected) {\n', '            totalInfected = totalPopulation;\n', '            LogEndOfWorld();\n', '        }\n', '    }\n', '\n', '    function withdraw(bytes32 _virus) public {\n', '        require(virus[_virus].owner == msg.sender);\n', '\n', '        // only withdraw once a day\n', '        require(now > (virus[_virus].lastWithdraw + 1 days));\n', '\n', '        // calculate ether\n', '        uint toBePayed = virus[_virus].infected.sub(virus[_virus].infectedPayed);\n', '        uint amount = totalBalance.div(totalInfected.sub(totalPayed)).mul(toBePayed);\n', '\n', '        require(amount <= totalBalance);\n', '\n', '        // subtract from total balance\n', '        totalBalance = totalBalance.sub(amount);\n', '        totalPayed = totalPayed.add(toBePayed);\n', '\n', '        // send ether\n', '        msg.sender.transfer(amount);\n', '\n', '        virus[_virus].infectedPayed = virus[_virus].infected;\n', '        virus[_virus].lastWithdraw = now;\n', '    }\n', '\n', '    function withdrawExcess(address _withdraw) onlyOwner public {\n', '        _withdraw.transfer(this.balance.sub(totalBalance));\n', '    }\n', '\n', '    /**\n', '    * Getters\n', '    */\n', '\n', '    function getVirusLength() public view returns(uint) {\n', '        return virusHashes.length;\n', '    }\n', '\n', '    function getOwnerVirusLength(address _owner) public view returns(uint) {\n', '        return virusOwner[_owner].length;\n', '    }\n', '\n', '    /**\n', '    * Constructor\n', '    */\n', '\n', '    function VirusGame() public {\n', '        totalPopulation = 7000000000;\n', '\n', '        genesisVirus = keccak256("Genesis");\n', '\n', '        virus[genesisVirus].name = "Genesis";\n', '        virus[genesisVirus].potential = 100;\n', '        virus[genesisVirus].owner = msg.sender;\n', '        virus[genesisVirus].lastInfected = now;\n', '\n', '        virusOwner[msg.sender].push(genesisVirus);\n', '        virusHashes.push(genesisVirus);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', 'contract Trigonometry {\n', '\n', '    // Table index into the trigonometric table\n', '    uint constant INDEX_WIDTH = 4;\n', '    // Interpolation between successive entries in the tables\n', '    uint constant INTERP_WIDTH = 8;\n', '    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;\n', '    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;\n', '    uint16 constant ANGLES_IN_CYCLE = 16384;\n', '    uint16 constant QUADRANT_HIGH_MASK = 8192;\n', '    uint16 constant QUADRANT_LOW_MASK = 4096;\n', '    uint constant SINE_TABLE_SIZE = 16;\n', '\n', '    // constant sine lookup table generated by gen_tables.py\n', "    // We have no other choice but this since constant arrays don't yet exist\n", '    uint8 constant entry_bytes = 2;\n', '    bytes constant sin_table = "\\x00\\x00\\x0c\\x8c\\x18\\xf9\\x25\\x28\\x30\\xfb\\x3c\\x56\\x47\\x1c\\x51\\x33\\x5a\\x82\\x62\\xf1\\x6a\\x6d\\x70\\xe2\\x76\\x41\\x7a\\x7c\\x7d\\x89\\x7f\\x61\\x7f\\xff";\n', '\n', '    /**\n', '     * Convenience function to apply a mask on an integer to extract a certain\n', '     * number of bits. Using exponents since solidity still does not support\n', '     * shifting.\n', '     *\n', '     * @param _value The integer whose bits we want to get\n', '     * @param _width The width of the bits (in bits) we want to extract\n', '     * @param _offset The offset of the bits (in bits) we want to extract\n', '     * @return An integer containing _width bits of _value starting at the\n', '     *         _offset bit\n', '     */\n', '    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {\n', '        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);\n', '    }\n', '\n', '    function sin_table_lookup(uint index) pure internal returns (uint16) {\n', '        bytes memory table = sin_table;\n', '        uint offset = (index + 1) * entry_bytes;\n', '        uint16 trigint_value;\n', '        assembly {\n', '            trigint_value := mload(add(table, offset))\n', '        }\n', '\n', '        return trigint_value;\n', '    }\n', '\n', '    /**\n', '     * Return the sine of an integer approximated angle as a signed 16-bit\n', '     * integer.\n', '     *\n', '     * @param _angle A 14-bit angle. This divides the circle into 16384\n', '     *               angle units, instead of the standard 360 degrees.\n', '     * @return The sine result as a number in the range -32767 to 32767.\n', '     */\n', '    function sin(uint16 _angle) public pure returns (int) {\n', '        uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);\n', '        uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);\n', '\n', '        bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;\n', '        bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;\n', '\n', '        if (!is_odd_quadrant) {\n', '            index = SINE_TABLE_SIZE - 1 - index;\n', '        }\n', '\n', '        uint x1 = sin_table_lookup(index);\n', '        uint x2 = sin_table_lookup(index + 1);\n', '        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);\n', '\n', '        int sine;\n', '        if (is_odd_quadrant) {\n', '            sine = int(x1) + int(approximation);\n', '        } else {\n', '            sine = int(x2) - int(approximation);\n', '        }\n', '\n', '        if (is_negative_quadrant) {\n', '            sine *= -1;\n', '        }\n', '\n', '        return sine;\n', '    }\n', '\n', '    /**\n', '     * Return the cos of an integer approximated angle.\n', '     * It functions just like the sin() method but uses the trigonometric\n', '     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.\n', '     */\n', '    function cos(uint16 _angle) public pure returns (int) {\n', '        if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {\n', '            _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;\n', '        } else {\n', '            _angle += QUADRANT_LOW_MASK;\n', '        }\n', '        return sin(_angle);\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract VirusGame is Ownable, Trigonometry {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '    * Structs\n', '    */\n', '\n', '    struct Virus {\n', '        bytes32 name;\n', '        bytes32 parent;\n', '        uint256 potential;\n', '        uint256 infected;\n', '        uint256 infectedPayed;\n', '        uint256 infectedTriggle;\n', '        uint256 lastWithdraw;\n', '        uint256 lastInfected;\n', '        uint256 generation;\n', '        address owner;\n', '    }\n', '\n', '    /**\n', '    * State\n', '    */\n', '\n', '    uint256 nonce;\n', '\n', '    mapping (address => bytes32[]) public virusOwner;\n', '\n', '    mapping (bytes32 => Virus) public virus;\n', '\n', '    bytes32[] public virusHashes;\n', '\n', '    uint256 public totalPopulation;\n', '\n', '    uint256 public totalInfected;\n', '\n', '    bytes32 public genesisVirus;\n', '\n', '    uint256 public totalBalance;\n', '\n', '    uint256 public totalPayed;\n', '\n', '    /**\n', '    * Modifier\n', '    */\n', '\n', '    modifier useNonce() {\n', '        _;\n', '        nonce = nonce.add(1);\n', '    }\n', '\n', '    modifier healthyPeople() {\n', '        require(totalPopulation > totalInfected);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Functions\n', '    */\n', '\n', '    event LogMutation(\n', '        bytes32 parentHash,\n', '        bytes32 virusHash\n', '    );\n', '\n', '    function mutate(bytes32 _virus, bytes32 _name) payable healthyPeople useNonce public {\n', '        // ensure parent virus exists\n', '        require(virus[_virus].owner != address(0));\n', '\n', '        uint costs = virus[_virus].generation.mul(0.001 ether).add(0.01 ether);\n', '        require(msg.value >= costs);\n', '\n', '        bytes32 newHash = keccak256(_virus, _name, nonce, msg.sender, now);\n', '\n', '        // new potential from virus hash to uint -> sinus or cosinus\n', '        int mutationFactor = sin(uint16(newHash));\n', '        uint uintFactor;\n', '        uint newPotential;\n', '\n', '        if (mutationFactor >= 0) {\n', '            uintFactor = uint(mutationFactor);\n', '            newPotential = virus[_virus].potential.mul(\n', '                uintFactor.mul(20).div(32767).add(100)\n', '            ).div(100);\n', '        } else {\n', '            uintFactor = uint(-mutationFactor);\n', '            newPotential = virus[_virus].potential.mul(\n', '                uintFactor.mul(20).div(32767).add(80)\n', '            ).div(100);\n', '        }\n', '\n', '        virus[newHash].name = _name;\n', '        virus[newHash].parent = _virus;\n', '        virus[newHash].generation = virus[_virus].generation.add(1);\n', '        virus[newHash].potential = newPotential;\n', '        virus[newHash].lastInfected = now;\n', '        virus[newHash].lastWithdraw = now;\n', '        virus[newHash].owner = msg.sender;\n', '\n', '        virusHashes.push(newHash);\n', '        virusOwner[msg.sender].push(newHash);\n', '\n', '        totalBalance = totalBalance.add(\n', '            costs.mul(9).div(10)\n', '        );\n', '\n', '        LogMutation(\n', '            _virus,\n', '            newHash\n', '        );\n', '    }\n', '\n', '    event LogInfection(\n', '        uint infected,\n', '        bytes32 virusHash\n', '    );\n', '\n', '    event LogEndOfWorld();\n', '\n', '    function infect(bytes32 _virus) healthyPeople public {\n', '        require(virus[_virus].owner == msg.sender);\n', '\n', '        // infectedTriggle + potential * delay = infected\n', '        uint delay = now.sub(virus[_virus].lastInfected);\n', '\n', '        uint infected = virus[_virus].infectedTriggle.add(\n', '            virus[_virus].potential.mul(delay).div(1 days)\n', '        );\n', '        \n', '        // infectedTriggle from parent must be set to x% of infected\n', '        virus[virus[_virus].parent].infectedTriggle = virus[virus[_virus].parent].infectedTriggle.add(\n', '            infected.div(10)\n', '        );\n', '\n', '        totalInfected = totalInfected.add(infected);\n', '        virus[_virus].infected = virus[_virus].infected.add(infected);\n', '\n', '        virus[_virus].lastInfected = now;\n', '        virus[_virus].infectedTriggle = 0;\n', '\n', '        LogInfection(\n', '            infected,\n', '            _virus\n', '        );\n', '\n', '        if (totalPopulation < totalInfected) {\n', '            totalInfected = totalPopulation;\n', '            LogEndOfWorld();\n', '        }\n', '    }\n', '\n', '    function withdraw(bytes32 _virus) public {\n', '        require(virus[_virus].owner == msg.sender);\n', '\n', '        // only withdraw once a day\n', '        require(now > (virus[_virus].lastWithdraw + 1 days));\n', '\n', '        // calculate ether\n', '        uint toBePayed = virus[_virus].infected.sub(virus[_virus].infectedPayed);\n', '        uint amount = totalBalance.div(totalInfected.sub(totalPayed)).mul(toBePayed);\n', '\n', '        require(amount <= totalBalance);\n', '\n', '        // subtract from total balance\n', '        totalBalance = totalBalance.sub(amount);\n', '        totalPayed = totalPayed.add(toBePayed);\n', '\n', '        // send ether\n', '        msg.sender.transfer(amount);\n', '\n', '        virus[_virus].infectedPayed = virus[_virus].infected;\n', '        virus[_virus].lastWithdraw = now;\n', '    }\n', '\n', '    function withdrawExcess(address _withdraw) onlyOwner public {\n', '        _withdraw.transfer(this.balance.sub(totalBalance));\n', '    }\n', '\n', '    /**\n', '    * Getters\n', '    */\n', '\n', '    function getVirusLength() public view returns(uint) {\n', '        return virusHashes.length;\n', '    }\n', '\n', '    function getOwnerVirusLength(address _owner) public view returns(uint) {\n', '        return virusOwner[_owner].length;\n', '    }\n', '\n', '    /**\n', '    * Constructor\n', '    */\n', '\n', '    function VirusGame() public {\n', '        totalPopulation = 7000000000;\n', '\n', '        genesisVirus = keccak256("Genesis");\n', '\n', '        virus[genesisVirus].name = "Genesis";\n', '        virus[genesisVirus].potential = 100;\n', '        virus[genesisVirus].owner = msg.sender;\n', '        virus[genesisVirus].lastInfected = now;\n', '\n', '        virusOwner[msg.sender].push(genesisVirus);\n', '        virusHashes.push(genesisVirus);\n', '    }\n', '\n', '}']
