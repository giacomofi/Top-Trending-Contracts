['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title ICO for Aumonet token based on ERC20 and ERC223 standards\n', ' *\n', ' * R&D performed and issued by BLOCKCHAIN INNOVATIVE TECHNOLOGIES LTD\n', ' * Company number 11344164\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev https://github.com/ethereum/EIPs/issues/223\n', ' * @dev Based on code from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\n', ' *      and on code from Dexaran ERC223: https://github.com/Dexaran/ERC223-token-standard/blob/master/token/ERC223/ERC223_token.sol\n', ' */\n', '\n', '/**\n', ' * Contract that is working with ERC223 tokens\n', ' */\n', '\n', 'contract ContractReceiver {\n', '\tfunction tokenFallback(address _from, uint _value, bytes _data)public pure {\n', '\t\t/* Fix for Mist warning */\n', '\t\t_from;\n', '\t\t_value;\n', '\t\t_data;\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '\t/**\n', '\t * @dev Multiplies two numbers, throws on overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b)internal pure returns(uint256 c) {\n', '\t\t// Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '\t\t// benefit is lost if &#39;b&#39; is also tested.\n', '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tc = a * b;\n', '\t\tassert(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Integer division of two numbers, truncating the quotient.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b)internal pure returns(uint256) {\n', '\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t\t// uint256 c = a / b;\n', '\t\t// assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b)internal pure returns(uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Adds two numbers, throws on overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b)internal pure returns(uint256 c) {\n', '\t\tc = a + b;\n', '\t\tassert(c >= a);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\tevent OwnershipRenounced(address indexed previousOwner);\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed _newOwner);\n', '\n', '\t/**\n', '\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t * account.\n', '\t */\n', '\tconstructor()public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t * @param _newOwner The address to transfer ownership to.\n', '\t */\n', '\tfunction transferOwnership(address _newOwner)public onlyOwner {\n', '\t\trequire(_newOwner != address(0));\n', '\t\temit OwnershipTransferred(owner, _newOwner);\n', '\t\towner = _newOwner;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Allows the current owner to relinquish control of the contract.\n', '\t */\n', '\tfunction renounceOwnership()public onlyOwner {\n', '\t\temit OwnershipRenounced(owner);\n', '\t\towner = address(0);\n', '\t}\n', '}\n', '\n', 'contract ERC223Interface {\n', '\tuint public _totalSupply;\n', '\tfunction balanceOf(address who)public view returns(uint);\n', '\n', '\tfunction totalSupply()public view returns(uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '}\n', '\n', '/**\n', ' * @title Aumonet ERC223 token\n', ' *\n', ' * @dev Implementation of the ERC223 token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/223\n', ' * @dev Based on code from Dexaran ERC223: https://github.com/Dexaran/ERC223-token-standard/blob/master/token/ERC223/ERC223_token.sol\n', ' */\n', 'contract AumonetERC223 is ERC223Interface {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/* Contract Variables */\n', '\taddress public owner;\n', '\tmapping(address => uint256)public balances;\n', '\tmapping(address => mapping(address => uint256))public allowed;\n', '\n', '\tconstructor()public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/* ERC20 Events */\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent Approval(address indexed from, address indexed to, uint256 value);\n', '\n', '\t/* ERC223 Events */\n', '\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\n', '\n', '\t/* Returns the balance of a particular account */\n', '\tfunction balanceOf(address _address)public view returns(uint256 balance) {\n', '\t\treturn balances[_address];\n', '\t}\n', '\n', '\t/* Transfer the balance from the sender&#39;s address to the address _to */\n', '\tfunction transfer(address _to, uint _value)public returns(bool success) {\n', '\t\tbytes memory empty;\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContract(_to, _value, empty);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, empty);\n', '\t\t}\n', '\t}\n', '\n', '\t/* Withdraws to address _to form the address _from up to the amount _value */\n', '\tfunction transferFrom(address _from, address _to, uint256 _value)public returns(bool success) {\n', '\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to].add(_value) > balances[_to]) {\n', '\t\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\t\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\t\temit Transfer(_from, _to, _value);\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\treturn false;\n', '\t\t}\n', '\t}\n', '\n', '\t/* Allows _spender to withdraw the _allowance amount form sender */\n', '\tfunction approve(address _spender, uint256 _allowance)public returns(bool success) {\n', '\t\tallowed[msg.sender][_spender] = _allowance;\n', '\t\temit Approval(msg.sender, _spender, _allowance);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* Checks how much _spender can withdraw from _owner */\n', '\tfunction allowance(address _owner, address _spender)public view returns(uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Standard function transfer used in ERC223 with _data parameter and custom fallback\n', '\t *\n', '\t * @dev called when a user or another ERC223 contract wants to transfer tokens.\n', '\t * @dev transfer token to a specified address\n', '\t * @param _to The address to transfer to.\n', '\t * @param _value The amount to be transferred.\n', '\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\n', '\t * @param _custom_fallback If there are defined custom fallbacks in ERC223 contracts, you specify it here.\n', '\t */\n', '\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public returns(bool success) {\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Transfer the specified amount of tokens to the specified address.\n', '\t *\n', '\t * @dev Invokes the `tokenFallback` function if the recipient is a contract.\n', '\t * The token transfer fails if the recipient is a contract\n', '\t * but does not implement the `tokenFallback` function\n', '\t * or the fallback function to receive funds.\n', '\t *\n', '\t * @param _to    Receiver address.\n', '\t * @param _value Amount of tokens that will be transferred.\n', '\t * @param _data  Transaction metadata.\n', '\t */\n', '\tfunction transfer(address _to, uint _value, bytes _data)public returns(bool) {\n', '\t\tif (isContract(_to)) {\n', '\t\t\treturn transferToContract(_to, _value, _data);\n', '\t\t} else {\n', '\t\t\treturn transferToAddress(_to, _value, _data);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Standard check for ERC223 functions\n', '\t *\n', '\t * @param _addr The address to be checked if it is contract address or not\n', '\t */\n', '\tfunction isContract(address _addr)private view returns(bool is_contract) {\n', '\t\tuint length;\n', '\t\tassembly {\n', '\t\t\t//retrieve the size of the code on target address, this needs assembly\n', '\t\t\tlength := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (length > 0);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function that is called when transaction target is an address\n', '\t *\n', '\t * @dev called when a user or another ERC223 contract wants to transfer tokens to a wallet address.\n', '\t * @dev transfer token to a specified address\n', '\t * @param _to The address to transfer to.\n', '\t * @param _value The amount to be transferred.\n', '\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\n', '\t */\n', '\tfunction transferToAddress(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function that is called when transaction target is contract\n', '\t *\n', '\t * @dev called when a user or another ERC223 contract wants to transfer tokens to a contract address.\n', '\t * @dev transfer token to a specified address\n', '\t * @param _to The address to transfer to.\n', '\t * @param _value The amount to be transferred.\n', '\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\n', '\t */\n', '\tfunction transferToContract(address _to, uint _value, bytes _data)private returns(bool success) {\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tContractReceiver receiver = ContractReceiver(_to);\n', '\t\treceiver.tokenFallback(msg.sender, _value, _data);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function that is called when transaction target is contract with custom fallback\n', '\t *\n', '\t * @dev called when a user or another ERC223 contract wants to transfer tokens.\n', '\t * @dev transfer token to a specified address\n', '\t * @param _to The address to transfer to.\n', '\t * @param _value The amount to be transferred.\n', '\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\n', '\t * @param _custom_fallback If there are defined custom fallbacks in ERC223 contracts, you specify it here.\n', '\t */\n', '\tfunction transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback)private returns(bool success) {\n', '\t\trequire(balances[msg.sender] >= _value);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n', '\t\temit Transfer(msg.sender, _to, _value, _data);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/* Stops any attempt to send Ether to this contract */\n', '\tfunction ()public {\n', '\t\trevert();\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '\tusing SafeMath for uint256;\n', '\n', '\tevent Pause();\n', '\tevent Unpause();\n', '\n', '\tbool public paused = false;\n', '\n', '\tuint _pauseStartTime = 0;\n', '\tuint _pauseTime = 0;\n', '\n', '\t/**\n', '\t * @dev Modifier to make a function callable only when the contract is not paused.\n', '\t */\n', '\tmodifier whenNotPaused() {\n', '\t\trequire(!paused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Modifier to make a function callable only when the contract is paused.\n', '\t */\n', '\tmodifier whenPaused() {\n', '\t\trequire(paused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev called for get pause time\n', '\t */\n', '\tfunction pauseTime()public view returns(uint256) {\n', '\t\treturn _pauseTime;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev called by the owner to pause, triggers stopped state\n', '\t */\n', '\tfunction pause()onlyOwner whenNotPaused public {\n', '\t\t_pauseStartTime = block.timestamp;\n', '\t\tpaused = true;\n', '\t\temit Pause();\n', '\t}\n', '\n', '\t/**\n', '\t * @dev called by the owner to unpause, returns to normal state\n', '\t */\n', '\tfunction unpause()onlyOwner whenPaused public {\n', '\t\t_pauseTime = _pauseTime.add(block.timestamp.sub(_pauseStartTime));\n', '\n', '\t\tpaused = false;\n', '\t\temit Unpause();\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev StandardToken modified with pausable transfers.\n', ' **/\n', 'contract PausableToken is AumonetERC223, Pausable {\n', '\n', '\tfunction transfer(address _to, uint256 _value)public whenNotPaused returns(bool) {\n', '\t\treturn super.transfer(_to, _value);\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public whenNotPaused returns(bool) {\n', '\t\treturn super.transfer(_to, _value, _data, _custom_fallback);\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value, bytes _data)public whenNotPaused returns(bool) {\n', '\t\treturn super.transfer(_to, _value, _data);\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value)public whenNotPaused returns(bool) {\n', '\t\treturn super.transferFrom(_from, _to, _value);\n', '\t}\n', '\n', '\tfunction approve(address _spender, uint256 _value)public whenNotPaused returns(bool) {\n', '\t\treturn super.approve(_spender, _value);\n', '\t}\n', '\n', '\tfunction increaseApproval(address _spender, uint _addedValue)public whenNotPaused returns(bool success) {\n', '\t\tallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseApproval(address _spender, uint _subtractedValue)public whenNotPaused returns(bool success) {\n', '\t\tuint256 oldValue = allowed[msg.sender][_spender];\n', '\t\tif (_subtractedValue > oldValue) {\n', '\t\t\tallowed[msg.sender][_spender] = 0;\n', '\t\t} else {\n', '\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '\t\t}\n', '\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Ownable Token\n', ' * @dev Token that has modified transfer functions with onlyOwner approval.\n', ' */\n', 'contract OwnableToken is PausableToken {\n', '\n', '\tevent Burn(address indexed burner, uint256 value);\n', '\n', '\t/**\n', '\t * @notice Allows the owner to transfer out any accidentally sent ERC20 tokens.\n', '\t *\n', '\t * @param _tokenAddress The address of the ERC20 contract.\n', '\t * @param _amount The amount of tokens to be transferred.\n', '\t */\n', '\tfunction transferAnyERC20Token(address _tokenAddress, uint256 _amount)onlyOwner public returns(bool success) {\n', '\t\treturn AumonetERC223(_tokenAddress).transfer(owner, _amount);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Burns a specific amount of tokens.\n', '\t * @param _value The amount of token to be burned.\n', '\t */\n', '\tfunction burn(uint256 _value)public {\n', '\t\t_burn(msg.sender, _value);\n', '\t}\n', '\n', '\tfunction _burn(address _who, uint256 _value)internal {\n', '\t\trequire(_value <= balances[_who]);\n', '\t\t// no need to require value <= totalSupply, since that would imply the\n', '\t\t// sender&#39;s balance is greater than the totalSupply, which *should* be an assertion failure\n', '\n', '\t\tbalances[_who] = balances[_who].sub(_value);\n', '\t\t_totalSupply = _totalSupply.sub(_value);\n', '\t\temit Burn(_who, _value);\n', '\t\temit Transfer(_who, address(0), _value);\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Aumonet Token\n', ' * @dev Defining constants used in Aumonet smart contract.\n', ' */\n', 'contract AumonetToken is OwnableToken {\n', '\n', '\t/* Contract Constants */\n', '\tstring public _name = "Ezekiel";\n', '\tstring public _symbol = "EZ37";\n', '\tuint8 public _decimals = 5;\n', '\tuint256 public _creatorSupply;\n', '\tuint256 public _icoSupply;\n', '\tuint256 public _bonusSupply = 187000 * (10 ** uint256(_decimals)); // The Bonus scheme supply is 17% (187 000 tokens);\n', '\n', '\tconstructor()public {\n', '\t\t//pause();\n', '\n', '\t\t_totalSupply = 1100000 * (10 ** uint256(_decimals));\n', '\n', '\t\t_creatorSupply = _totalSupply * 25 / 100; // The creator has 25% of tokens\n', '\t\t_icoSupply = _totalSupply * 58 / 100; // Smart contract balance is 58% of tokens (638 000 tokens)\n', '\n', '\t\t//balances[this] = _icoSupply.add(_bonusSupply); // Token balance to smart contract.\n', '\t\t//balances[msg.sender] = _creatorSupply;\n', '\t\tbalances[msg.sender] = _icoSupply.add(_bonusSupply);\n', '\t\tbalances[tx.origin] = _creatorSupply; //instead of tx.origin should be address of where will be sended money\n', '\n', '\t}\n', '\n', '\tfunction name()public view returns(string) {\n', '\t\treturn _name;\n', '\t}\n', '\n', '\tfunction symbol()public view returns(string) {\n', '\t\treturn _symbol;\n', '\t}\n', '\n', '\tfunction decimals()public view returns(uint8) {\n', '\t\treturn _decimals;\n', '\t}\n', '\n', '\tfunction bonusSupply()public view returns(uint256) {\n', '\t\treturn _bonusSupply;\n', '\t}\n', '\n', '\tfunction icoSupply()public view returns(uint256) {\n', '\t\treturn _icoSupply;\n', '\t}\n', '\n', '}\n', '\n', '/**\n', ' * @title Crowdsale\n', ' * @dev Crowdsale is a base contract for managing a token crowdsale,\n', ' * allowing investors to purchase tokens with ether. This contract implements\n', ' * such functionality in its most fundamental form and can be extended to provide additional\n', ' * functionality and/or custom behavior.\n', ' * The external interface represents the basic interface for purchasing tokens, and conform\n', ' * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\n', ' * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\n', ' * the methods to add functionality. Consider using &#39;super&#39; where appropiate to concatenate\n', ' * behavior.\n', ' */\n', 'contract Crowdsale {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// The token being sold\n', '\tAumonetToken public token;\n', '\n', '\t// start and end timestamps of crowdsale\n', '\tuint public start; // the start date of the crowdsale\n', '\tuint public end; // the end date of the crowdsale\n', '\tuint256 increaseTime; // time paused\n', '\t// Address where funds are collected\n', '\taddress public wallet;\n', '\n', '\t// How many token units a buyer gets per eth.\n', '\t// The rate is the conversion between wei and the smallest and indivisible token unit.\n', '\tuint256 public ethRate;\n', '\n', '\t// Amount of wei raised\n', '\tuint256 public totalWeiRaised; // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We&#39;ll store the total ETH raised via our ICO here.\n', '\n', '\tuint256 public tokensSold; // the number of tokens already sold\n', '\n', '\tbool public crowdsaleClosed = false; // indicates if the crowdsale has been closed already\n', '\n', '\n', '\t/**\n', '\t * Event for token purchase logging\n', '\t * @param purchaser who paid for the tokens\n', '\t * @param beneficiary who got the tokens\n', '\t * @param value weis paid for purchase\n', '\t * @param amount amount of tokens purchased\n', '\t */\n', '\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '\t/**\n', '\t * @param _wallet Address where collected funds will be forwarded to\n', '\t * @param _startICO starting time of ICO\n', '\t * @param _endICO ending time of ICO\n', '\t */\n', '\tconstructor(address _wallet, uint _startICO, uint _endICO)public {\n', '\t\trequire(_wallet != address(0));\n', '\n', '\t\ttoken = new AumonetToken(); // creates the token to be sold.\n', '\t\tethRate = 124; // Set the rate of token to ether exchange for the ICO\n', '\t\ttotalWeiRaised = 0;\n', '\t\ttokensSold = 0;\n', '\t\tstart = _startICO; // Start of ICO is at 08.11.2018 00:00 (UTC)\n', '\t\tend = _endICO; // End of ICO is at 20.12.2018 23:59 (UTC)\n', '\t\tincreaseTime = 0;\n', '\t\twallet = _wallet;\n', '\t}\n', '\n', '\tmodifier afterDeadline() {\n', '\t\tincreaseTime = token.pauseTime();\n', '\t\trequire(block.timestamp > end.add(increaseTime));\n', '\t\t_;\n', '\t}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale external interface\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @dev fallback function ***DO NOT OVERRIDE***\n', '\t */\n', '\tfunction ()external payable {\n', '\t\tbuyTokens(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function calls other functions to calculate tokenamount to send to beneficiary. Checks if the process of buying is correct.\n', '\t *\n', '\t * @dev low level token purchase\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t */\n', '\tfunction buyTokens(address _beneficiary)public payable {}\n', '\n', '\t// -----------------------------------------\n', '\t// Crowdsale internal interface (extensible)\n', '\t// -----------------------------------------\n', '\n', '\t/**\n', '\t * @notice Validation of an incoming purchase.\n', '\t *\n', '\t * @dev Use require statements to revert state when conditions are not met. Use super to concatenate validations.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _weiAmount Value in wei involved in the purchase\n', '\t */\n', '\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount)internal {\n', '\t\trequire(_beneficiary != address(0));\n', '\t\trequire(_weiAmount != 0);\n', '\t\tincreaseTime = token.pauseTime();\n', '\t\trequire(!crowdsaleClosed && block.timestamp >= start.add(increaseTime) && block.timestamp <= end.add(increaseTime));\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function transfers tokens from contract to beneficiary address.\n', '\t *\n', '\t * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t * @param _tokenAmount Number of tokens to be emitted\n', '\t */\n', '\tfunction _deliverTokens(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\ttoken.transfer(_beneficiary, _tokenAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function to calculate tokenamount from wei.\n', '\t *\n', '\t * @dev Override to extend the way in which ether is converted to tokens.\n', '\t * @param _weiAmount Value in wei to be converted into tokens\n', '\t * @return Number of tokens that can be purchased with the specified _weiAmount\n', '\t */\n', '\tfunction _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {\n', '\t\t_weiAmount = _weiAmount.mul(ethRate).div(100);\n', '\t\treturn _weiAmount.div(10 ** uint(18 - token.decimals())); //as we have other decimals number than standard 18, we need to calculate\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Determines how ETH is stored/forwarded on purchases.\n', '\t */\n', '\tfunction _forwardFunds()internal {\n', '\t\twallet.transfer(msg.value);\n', '\t}\n', '\n', '\t// @return true if crowdsale event has ended\n', '\tfunction hasEnded()public returns(bool) {\n', '\t\tincreaseTime = token.pauseTime();\n', '\t\treturn now > end.add(increaseTime);\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title FinalizableCrowdsale\n', ' * @dev Extension of Crowdsale where an owner can do extra work\n', ' * after finishing.\n', ' */\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '\n', '\tbool public isFinalized = false;\n', '\n', '    event Finalized();\n', '\n', '\tconstructor()Ownable()public {}\n', '\n', '\t/**\n', '\t * @notice Failsafe transfer of tokens for the team to owner wallet.\n', '\t */\n', '\tfunction withdrawTokens()onlyOwner public returns(bool) {\n', '\t\trequire(token.transfer(owner, token.balanceOf(this)));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function to indicate the end of ICO.\n', '\t *\n', '\t * @dev Must be called after crowdsale ends, to do some extra finalization\n', '\t * work. Calls the contract&#39;s finalization function.\n', '\t */\n', '\tfunction finalize()onlyOwner afterDeadline public {\n', '\t\trequire(!crowdsaleClosed);\n', '\n', '\t\temit Finalized();\n', '\t\twithdrawTokens();\n', '\n', '\t\tcrowdsaleClosed = true;\n', '\t\tisFinalized = true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Can be overridden to add finalization logic. The overriding function\n', '\t * should call super.finalization() to ensure the chain of finalization is\n', '\t * executed entirely.\n', '\t */\n', '\tfunction finalization()internal {}\n', '}\n', '\n', 'contract AumonetICO is FinalizableCrowdsale {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 public BONUS_TOKENS = 18700000000;\n', '\t/**\n', '\t * Defining timestamps for bonuscheme from White Paper.\n', '\t * The start of bonuses is 8 November 2018 and the end is 20 December 2018.\n', '\t * There are 2 seconds in between changing the phases.  */\n', '\tuint256 startOfFirstBonus;\n', '\tuint256 endOfFirstBonus;\n', '\tuint256 startOfSecondBonus;\n', '\tuint256 endOfSecondBonus;\n', '\tuint256 startOfThirdBonus;\n', '\tuint256 endOfThirdBonus;\n', '\tuint256 startOfFourthBonus;\n', '\tuint256 endOfFourthBonus;\n', '\tuint256 startOfFifthBonus;\n', '\tuint256 endOfFifthBonus;\n', '\n', '\t/**\n', '\t * Defining bonuses according to White Paper.\n', '\t * First week there is bonus 30%.\n', '\t * Second week there is bonus 25%.\n', '\t * Third week there is bonus 20%.\n', '\t * Fourth week there is bonus 15%.\n', '\t * Fifth week there is bonus 10%.\n', '\t * The remaining week will have bonus 3%.\n', '\t */\n', '\tuint256 firstBonus = 30;\n', '\tuint256 secondBonus = 25;\n', '\tuint256 thirdBonus = 20;\n', '\tuint256 fourthBonus = 15;\n', '\tuint256 fifthBonus = 10;\n', '\tuint256 sixthBonus = 3;\n', '\n', '\tconstructor(address _wallet, uint _startICO, uint _endICO)FinalizableCrowdsale()Crowdsale(_wallet, _startICO, _endICO)public {\n', '\t\t/*\n', '\t\t * Set bonusscheme week values\n', '\t\t */\n', '\t\tstartOfFirstBonus = _startICO;\n', '\t\tendOfFirstBonus = (startOfFirstBonus - 1) + 8 days;\n', '\t\tstartOfSecondBonus = (startOfFirstBonus + 1) + 8 days;\n', '\t\tendOfSecondBonus = (startOfSecondBonus - 1) + 8 days;\n', '\t\tstartOfThirdBonus = (startOfSecondBonus + 1) + 8 days;\n', '\t\tendOfThirdBonus = (startOfThirdBonus - 1) + 8 days;\n', '\t\tstartOfFourthBonus = (startOfThirdBonus + 1) + 8 days;\n', '\t\tendOfFourthBonus = (startOfFourthBonus - 1) + 8 days;\n', '\t\tstartOfFifthBonus = (startOfFourthBonus + 1) + 8 days;\n', '\t\tendOfFifthBonus = (startOfFifthBonus - 1) + 8 days;\n', '\n', '\t}\n', '\n', '\tevent BonusCalculated(uint256 tokenAmount);\n', '\tevent BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens);\n', '\n', '\tmodifier beforeICO() {\n', '\t\tincreaseTime = token.pauseTime();\n', '\t\trequire(block.timestamp <= start.add(increaseTime));\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Sets how many tokens have we sold in PRE-ICO phase\n', '\t *\n', '\t * @param _soldTokens Number of tokens sold in PRE-ICO. The number needs to be multiplied by 10**number of decimals before entering it into function.\n', '\t * @param _raisedWei The amount of ETH in wei raised in PRE-ICO.\n', '\t */\n', '\tfunction setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei)onlyOwner beforeICO public {\n', '\t\ttokensSold = tokensSold.add(_soldTokens);\n', '\t\ttotalWeiRaised = totalWeiRaised.add(_raisedWei);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\n', '\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\n', '\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\n', '\t */\n', '\tfunction getBonusTokens(uint256 _tokenAmount)public returns(uint256) {\n', '\t\tincreaseTime = token.pauseTime();\n', '\t\tif (block.timestamp >= startOfFirstBonus.add(increaseTime) && block.timestamp <= endOfFirstBonus.add(increaseTime)) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfSecondBonus.add(increaseTime) && block.timestamp <= endOfSecondBonus.add(increaseTime)) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfThirdBonus.add(increaseTime) && block.timestamp <= endOfThirdBonus.add(increaseTime)) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFourthBonus.add(increaseTime) && block.timestamp <= endOfFourthBonus.add(increaseTime)) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\n', '\t\t} else if (block.timestamp >= startOfFifthBonus.add(increaseTime) && block.timestamp <= endOfFifthBonus.add(increaseTime)) {\n', '\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\n', '\t\t} else\n', '\t\t\t_tokenAmount = _tokenAmount.mul(sixthBonus).div(100);\n', '\t\temit BonusCalculated(_tokenAmount);\n', '\t\treturn _tokenAmount;\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function calls other functions to calculate tokenamount to send to beneficiary. Checks if the process of buying is correct.\n', '\t *\n', '\t * @dev low level token purchase\n', '\t * @param _beneficiary Address performing the token purchase\n', '\t */\n', '\tfunction buyTokens(address _beneficiary)public payable {\n', '\t\tuint256 weiAmount = msg.value;\n', '\t\t_preValidatePurchase(_beneficiary, weiAmount);\n', '\n', '\t\tuint256 tokens = _getTokenAmount(weiAmount); // calculate token amount to be sold\n', '\n', '\t\trequire(token.balanceOf(this) >= tokens); //check if the contract has enough tokens\n', '\n', '\t\ttotalWeiRaised = totalWeiRaised.add(weiAmount); //update state\n', '\t\ttokensSold = tokensSold.add(tokens); //update state\n', '\n', '\t\t_deliverTokens(_beneficiary, tokens);\n', '\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '\t\t_processBonus(msg.sender, tokens);\n', '\n', '\t\t_forwardFunds();\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Function to calculate bonus from bought tokens.\n', '\t *\n', '\t * @dev Executed when a purchase has been validated and bonus tokens need to be calculated. Not necessarily emits/sends bonus tokens.\n', '\t * @param _beneficiary Address receiving the tokens\n', '\t * @param _tokenAmount Number of tokens from which is calculated bonus amount\n', '\t */\n', '\tfunction _processBonus(address _beneficiary, uint256 _tokenAmount)internal {\n', '\t\tuint256 bonusTokens = getBonusTokens(_tokenAmount); // Calculate bonus token amount\n', '\t\tif (BONUS_TOKENS < bonusTokens) { // If the bonus scheme does not have enough tokens, send all remaining\n', '\t\t\tbonusTokens = BONUS_TOKENS;\n', '\t\t}\n', '\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\n', '\t\t\tBONUS_TOKENS = BONUS_TOKENS.sub(bonusTokens);\n', '\t\t\ttoken.transfer(_beneficiary, bonusTokens);\n', '\t\t\temit BonusSent(address(token), _beneficiary, _tokenAmount, bonusTokens);\n', '\t\t\ttokensSold = tokensSold.add(bonusTokens); // update state of sold tokens\n', '\t\t}\n', '\t}\n', '\n', '\tfunction transferTokenOwnership(address _newOwner)public {\n', '\t\ttoken.transferOwnership(_newOwner);\n', '\t}\n', '\n', '\tfunction finalization()internal {\n', '\t\ttoken.transferOwnership(wallet);\n', '\t}\n', '\n', '}']