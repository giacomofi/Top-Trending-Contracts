['pragma solidity ^0.4.18;\n', '\n', '\tlibrary SafeMath {\n', '\t    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        if (a == 0) {\n', '\t            return 0;\n', '\t        }\n', '\t        uint256 c = a * b;\n', '\t        assert(c / a == b);\n', '\t        return c;\n', '\t    }\n', '\n', '\t    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t        uint256 c = a / b;\n', '\t        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\t        return c;\n', '\t    }\n', '\n', '\t    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        assert(b <= a);\n', '\t        return a - b;\n', '\t    }\n', '\n', '\t    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        uint256 c = a + b;\n', '\t        assert(c >= a);\n', '\t        return c;\n', '\t    }\n', '\t}\n', '\n', '\tlibrary SafeBonus {\n', '\t    using SafeMath for uint256;\n', '\n', '\t    function addBonus(uint256 value, uint256 percentages) internal pure returns (uint256) {\n', '\t        return value.add(value.mul(percentages).div(100));\n', '\t    }\n', '\t}\n', '\n', '\tcontract Ownable {\n', '\t    address public owner;\n', '\n', '\n', '\t    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '\t    /**\n', '\t     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t     * account.\n', '\t     */\n', '\t    function Ownable() public {\n', '\t        owner = msg.sender;\n', '\t    }\n', '\n', '\n', '\t    /**\n', '\t     * @dev Throws if called by any account other than the owner.\n', '\t     */\n', '\t    modifier onlyOwner() {\n', '\t        require(msg.sender == owner);\n', '\t        _;\n', '\t    }\n', '\n', '\n', '\t    /**\n', '\t     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t     * @param newOwner The address to transfer ownership to.\n', '\t     */\n', '\t    function transferOwnership(address newOwner) public onlyOwner {\n', '\t        require(newOwner != address(0));\n', '\t        OwnershipTransferred(owner, newOwner);\n', '\t        owner = newOwner;\n', '\t    }\n', '\t}\n', '\n', '\tinterface token {\n', '\t    function transfer(address receiver, uint amount) public;\n', '\t}\n', '\n', '\tcontract VesaStage2PreICO is Ownable {\n', '\t    using SafeMath for uint256;\n', '\t    using SafeBonus for uint256;\n', '\n', '\t    address public beneficiary;\n', '\t    uint8 public durationInDays = 31;\n', '\t    uint public fundingGoal = 100 ether;\n', '\t    uint public fundingGoalHardCap = 10000 ether;\n', '\t    uint public amountRaised;\n', '\t    uint public start;\n', '\t    uint public deadline;\n', '\t    uint public bonusPrice = 164285714300000; // 0.0001642857143 ETH\n', '\t    uint public bonusPriceDeltaPerHour = 3571428573000; // 0.000003571428573 ETH\n', '\t    uint public bonusPeriodDurationInHours = 10;\n', '\t    uint public price = 200000000000000; // 0.0002 ETH\n', '\t    uint public minSum = 200000000000000000; // 0.2 ETH\n', '\t    token public tokenReward;\n', '\t    mapping(address => uint256) public balanceOf;\n', '\t    bool public fundingGoalReached = false;\n', '\t    bool public crowdsaleClosed = false;\n', '\t    bool public allowRefund = false;\n', '\n', '\t    event GoalReached(address recipient, uint totalAmountRaised);\n', '\t    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\t    event BeneficiaryChanged(address indexed previousBeneficiary, address indexed newBeneficiary);\n', '\n', '\t    /**\n', '\t     * Constructor function\n', '\t     *\n', '\t     * Setup the owner\n', '\t     */\n', '\t    function VesaStage2PreICO() public {\n', '\t        beneficiary = 0x2bF8AeE3845af10f2bbEBbCF53EBd887c5021d14;\n', '\t        start = 1522155600;\n', '\t        deadline = start + durationInDays * 1 days;\n', '\t        tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921);\n', '\t    }\n', '\n', '\t    modifier afterDeadline() {\n', '\t        if (now >= deadline) \n', '\t            _;\n', '\t    }\n', '\n', '\t    function getPrice() public view returns (uint) {\n', '\t        require(!crowdsaleClosed);\n', '\t        if ( now >= (start + bonusPeriodDurationInHours.mul(1 hours))) {\n', '\t            return price;\n', '\t        } else {\n', '\t            uint hoursLeft = now.sub(start).div(1 hours);\n', '\t            return bonusPrice.add(bonusPriceDeltaPerHour.mul(hoursLeft));\n', '\t        }\n', '\t    }\n', '\n', '\t    function getBonus(uint amount) public view returns (uint) {\n', '\t        require(!crowdsaleClosed);\n', '\n', '\t        if (amount < 2857142857000000000) {return 0;}                                        // < 2.857142857\n', '\t        if (amount >= 2857142857000000000 && amount < 7142857143000000000) {return 35;}      // 2.857142857-7,142857143 ETH\n', '\t        if (amount >= 7142857143000000000 && amount < 14285714290000000000) {return 42;}     // 7,142857143-14,28571429 ETH\n', '\t        if (amount >= 14285714290000000000 && amount < 25000000000000000000) {return 47;}    // 14,28571429-25 ETH\n', '\t        if (amount >= 25000000000000000000 && amount < 85000000000000000000) {return 55;}    // 25-85 ETH\n', '\t        if (amount >= 85000000000000000000 && amount < 285000000000000000000) {return 65;}   // 85-285 ETH\n', '\t        if (amount >= 285000000000000000000) {return 75;}                                    // >285 ETH\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Fallback function\n', '\t     *\n', '\t     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '\t     */\n', '\t    function () public payable {\n', '\t        require(!crowdsaleClosed);\n', '\t        require(now > start);\n', '\t        require(msg.value > minSum);\n', '\t        uint amount = msg.value;\n', '\t        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '\t        amountRaised = amountRaised.add(amount);\n', '\n', '\t        uint currentPrice = getPrice();\n', '\t        uint currentBonus = getBonus(amount);\n', '\n', '\t        uint tokensToTransfer = amount.mul(10 ** 18).div(currentPrice);\n', '\t        uint tokensToTransferWithBonuses = tokensToTransfer.addBonus(currentBonus);\n', '\n', '\t        tokenReward.transfer(msg.sender, tokensToTransferWithBonuses);\n', '\t        FundTransfer(msg.sender, amount, true);\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Check if goal was reached\n', '\t     *\n', '\t     * Checks if the goal or time limit has been reached and ends the campaign\n', '\t     */\n', '\t    function checkGoalReached() public afterDeadline {\n', '\t        if (amountRaised >= fundingGoal){\n', '\t            fundingGoalReached = true;\n', '\t            GoalReached(beneficiary, amountRaised);\n', '\t        }\n', '\t        crowdsaleClosed = true;\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Withdraw the funds\n', '\t     *\n', '\t     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '\t     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\n', '\t     * the amount they contributed.\n', '\t     */\n', '\t    function safeWithdrawal() public afterDeadline {\n', '\t        if (allowRefund) {\n', '\t            uint amount = balanceOf[msg.sender];\n', '\t            balanceOf[msg.sender] = 0;\n', '\t            if (amount > 0) {\n', '\t                if (msg.sender.send(amount)) {\n', '\t                    FundTransfer(msg.sender, amount, false);\n', '\t                } else {\n', '\t                    balanceOf[msg.sender] = amount;\n', '\t                }\n', '\t            }\n', '\t        }\n', '\n', '\t        if (beneficiary == msg.sender) {\n', '\t            if (beneficiary.send(amountRaised)) {\n', '\t                FundTransfer(beneficiary, amountRaised, false);\n', '\t                crowdsaleClosed = true;\n', '\t            } else {\n', '\t                //If we fail to send the funds to beneficiary, unlock funders balance\n', '\t                fundingGoalReached = false;\n', '\t            }\n', '\t        }\n', '\t    }\n', '\n', '\t    function tokensWithdrawal(address receiver, uint amount) public onlyOwner {\n', '\t        tokenReward.transfer(receiver, amount);\n', '\t    }\n', '\n', '\t    function initializeRefund() public afterDeadline onlyOwner {\n', '\t    \tallowRefund = true;\n', '\t    }\n', '\n', '\t    function changeBeneficiary(address newBeneficiary) public onlyOwner {\n', '\t        require(newBeneficiary != address(0));\n', '\t        BeneficiaryChanged(beneficiary, newBeneficiary);\n', '\t        beneficiary = newBeneficiary;\n', '\t    }\n', '\n', '\t}']
['pragma solidity ^0.4.18;\n', '\n', '\tlibrary SafeMath {\n', '\t    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        if (a == 0) {\n', '\t            return 0;\n', '\t        }\n', '\t        uint256 c = a * b;\n', '\t        assert(c / a == b);\n', '\t        return c;\n', '\t    }\n', '\n', '\t    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '\t        uint256 c = a / b;\n', "\t        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t        return c;\n', '\t    }\n', '\n', '\t    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        assert(b <= a);\n', '\t        return a - b;\n', '\t    }\n', '\n', '\t    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t        uint256 c = a + b;\n', '\t        assert(c >= a);\n', '\t        return c;\n', '\t    }\n', '\t}\n', '\n', '\tlibrary SafeBonus {\n', '\t    using SafeMath for uint256;\n', '\n', '\t    function addBonus(uint256 value, uint256 percentages) internal pure returns (uint256) {\n', '\t        return value.add(value.mul(percentages).div(100));\n', '\t    }\n', '\t}\n', '\n', '\tcontract Ownable {\n', '\t    address public owner;\n', '\n', '\n', '\t    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '\t    /**\n', '\t     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '\t     * account.\n', '\t     */\n', '\t    function Ownable() public {\n', '\t        owner = msg.sender;\n', '\t    }\n', '\n', '\n', '\t    /**\n', '\t     * @dev Throws if called by any account other than the owner.\n', '\t     */\n', '\t    modifier onlyOwner() {\n', '\t        require(msg.sender == owner);\n', '\t        _;\n', '\t    }\n', '\n', '\n', '\t    /**\n', '\t     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t     * @param newOwner The address to transfer ownership to.\n', '\t     */\n', '\t    function transferOwnership(address newOwner) public onlyOwner {\n', '\t        require(newOwner != address(0));\n', '\t        OwnershipTransferred(owner, newOwner);\n', '\t        owner = newOwner;\n', '\t    }\n', '\t}\n', '\n', '\tinterface token {\n', '\t    function transfer(address receiver, uint amount) public;\n', '\t}\n', '\n', '\tcontract VesaStage2PreICO is Ownable {\n', '\t    using SafeMath for uint256;\n', '\t    using SafeBonus for uint256;\n', '\n', '\t    address public beneficiary;\n', '\t    uint8 public durationInDays = 31;\n', '\t    uint public fundingGoal = 100 ether;\n', '\t    uint public fundingGoalHardCap = 10000 ether;\n', '\t    uint public amountRaised;\n', '\t    uint public start;\n', '\t    uint public deadline;\n', '\t    uint public bonusPrice = 164285714300000; // 0.0001642857143 ETH\n', '\t    uint public bonusPriceDeltaPerHour = 3571428573000; // 0.000003571428573 ETH\n', '\t    uint public bonusPeriodDurationInHours = 10;\n', '\t    uint public price = 200000000000000; // 0.0002 ETH\n', '\t    uint public minSum = 200000000000000000; // 0.2 ETH\n', '\t    token public tokenReward;\n', '\t    mapping(address => uint256) public balanceOf;\n', '\t    bool public fundingGoalReached = false;\n', '\t    bool public crowdsaleClosed = false;\n', '\t    bool public allowRefund = false;\n', '\n', '\t    event GoalReached(address recipient, uint totalAmountRaised);\n', '\t    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\t    event BeneficiaryChanged(address indexed previousBeneficiary, address indexed newBeneficiary);\n', '\n', '\t    /**\n', '\t     * Constructor function\n', '\t     *\n', '\t     * Setup the owner\n', '\t     */\n', '\t    function VesaStage2PreICO() public {\n', '\t        beneficiary = 0x2bF8AeE3845af10f2bbEBbCF53EBd887c5021d14;\n', '\t        start = 1522155600;\n', '\t        deadline = start + durationInDays * 1 days;\n', '\t        tokenReward = token(0xb1c74c1D82824428e484072069041deD079eD921);\n', '\t    }\n', '\n', '\t    modifier afterDeadline() {\n', '\t        if (now >= deadline) \n', '\t            _;\n', '\t    }\n', '\n', '\t    function getPrice() public view returns (uint) {\n', '\t        require(!crowdsaleClosed);\n', '\t        if ( now >= (start + bonusPeriodDurationInHours.mul(1 hours))) {\n', '\t            return price;\n', '\t        } else {\n', '\t            uint hoursLeft = now.sub(start).div(1 hours);\n', '\t            return bonusPrice.add(bonusPriceDeltaPerHour.mul(hoursLeft));\n', '\t        }\n', '\t    }\n', '\n', '\t    function getBonus(uint amount) public view returns (uint) {\n', '\t        require(!crowdsaleClosed);\n', '\n', '\t        if (amount < 2857142857000000000) {return 0;}                                        // < 2.857142857\n', '\t        if (amount >= 2857142857000000000 && amount < 7142857143000000000) {return 35;}      // 2.857142857-7,142857143 ETH\n', '\t        if (amount >= 7142857143000000000 && amount < 14285714290000000000) {return 42;}     // 7,142857143-14,28571429 ETH\n', '\t        if (amount >= 14285714290000000000 && amount < 25000000000000000000) {return 47;}    // 14,28571429-25 ETH\n', '\t        if (amount >= 25000000000000000000 && amount < 85000000000000000000) {return 55;}    // 25-85 ETH\n', '\t        if (amount >= 85000000000000000000 && amount < 285000000000000000000) {return 65;}   // 85-285 ETH\n', '\t        if (amount >= 285000000000000000000) {return 75;}                                    // >285 ETH\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Fallback function\n', '\t     *\n', '\t     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '\t     */\n', '\t    function () public payable {\n', '\t        require(!crowdsaleClosed);\n', '\t        require(now > start);\n', '\t        require(msg.value > minSum);\n', '\t        uint amount = msg.value;\n', '\t        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '\t        amountRaised = amountRaised.add(amount);\n', '\n', '\t        uint currentPrice = getPrice();\n', '\t        uint currentBonus = getBonus(amount);\n', '\n', '\t        uint tokensToTransfer = amount.mul(10 ** 18).div(currentPrice);\n', '\t        uint tokensToTransferWithBonuses = tokensToTransfer.addBonus(currentBonus);\n', '\n', '\t        tokenReward.transfer(msg.sender, tokensToTransferWithBonuses);\n', '\t        FundTransfer(msg.sender, amount, true);\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Check if goal was reached\n', '\t     *\n', '\t     * Checks if the goal or time limit has been reached and ends the campaign\n', '\t     */\n', '\t    function checkGoalReached() public afterDeadline {\n', '\t        if (amountRaised >= fundingGoal){\n', '\t            fundingGoalReached = true;\n', '\t            GoalReached(beneficiary, amountRaised);\n', '\t        }\n', '\t        crowdsaleClosed = true;\n', '\t    }\n', '\n', '\t    /**\n', '\t     * Withdraw the funds\n', '\t     *\n', '\t     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '\t     * sends the entire amount to the beneficiary. If goal was not reached, each contributor can withdraw\n', '\t     * the amount they contributed.\n', '\t     */\n', '\t    function safeWithdrawal() public afterDeadline {\n', '\t        if (allowRefund) {\n', '\t            uint amount = balanceOf[msg.sender];\n', '\t            balanceOf[msg.sender] = 0;\n', '\t            if (amount > 0) {\n', '\t                if (msg.sender.send(amount)) {\n', '\t                    FundTransfer(msg.sender, amount, false);\n', '\t                } else {\n', '\t                    balanceOf[msg.sender] = amount;\n', '\t                }\n', '\t            }\n', '\t        }\n', '\n', '\t        if (beneficiary == msg.sender) {\n', '\t            if (beneficiary.send(amountRaised)) {\n', '\t                FundTransfer(beneficiary, amountRaised, false);\n', '\t                crowdsaleClosed = true;\n', '\t            } else {\n', '\t                //If we fail to send the funds to beneficiary, unlock funders balance\n', '\t                fundingGoalReached = false;\n', '\t            }\n', '\t        }\n', '\t    }\n', '\n', '\t    function tokensWithdrawal(address receiver, uint amount) public onlyOwner {\n', '\t        tokenReward.transfer(receiver, amount);\n', '\t    }\n', '\n', '\t    function initializeRefund() public afterDeadline onlyOwner {\n', '\t    \tallowRefund = true;\n', '\t    }\n', '\n', '\t    function changeBeneficiary(address newBeneficiary) public onlyOwner {\n', '\t        require(newBeneficiary != address(0));\n', '\t        BeneficiaryChanged(beneficiary, newBeneficiary);\n', '\t        beneficiary = newBeneficiary;\n', '\t    }\n', '\n', '\t}']
