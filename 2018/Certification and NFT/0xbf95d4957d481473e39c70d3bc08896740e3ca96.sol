['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/upgradeability/ImplementationStorage.sol\n', '\n', '/**\n', ' * @title ImplementationStorage\n', ' * @dev This contract stores proxy implementation address.\n', ' */\n', 'contract ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "cvc.proxy.implementation", and is validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    */\n', '    constructor() public {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("cvc.proxy.implementation"));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/upgradeability/CvcProxy.sol\n', '\n', '/**\n', ' * @title CvcProxy\n', ' * @dev Transparent proxy with upgradeability functions and authorization control.\n', ' */\n', 'contract CvcProxy is ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address implementation);\n', '\n', '    /**\n', '     * @dev Emitted when the administration has been transferred.\n', '     * @param previousAdmin Address of the previous admin.\n', '     * @param newAdmin Address of the new admin.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "cvc.proxy.admin", and is validated in the constructor.\n', '     */\n', '    bytes32 private constant ADMIN_SLOT = 0x2bbac3e52eee27be250d682577104e2abe776c40160cd3167b24633933100433;\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the admin.\n', '     * It executes the function if called by admin. Otherwise, it will delegate the call to the implementation.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == currentAdmin()) {\n', '            _;\n', '        } else {\n', '            delegate(implementation());\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Contract constructor.\n', '     * It sets the `msg.sender` as the proxy admin.\n', '     */\n', '    constructor() public {\n', '        assert(ADMIN_SLOT == keccak256("cvc.proxy.admin"));\n', '        setAdmin(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function.\n', '     */\n', '    function() external payable {\n', '        require(msg.sender != currentAdmin(), "Message sender is not contract admin");\n', '        delegate(implementation());\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * Only the current admin can call this function.\n', '     * @param _newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeAdmin(address _newAdmin) external ifAdmin {\n', '        require(_newAdmin != address(0), "Cannot change contract admin to zero address");\n', '        emit AdminChanged(currentAdmin(), _newAdmin);\n', '        setAdmin(_newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     */\n', '    function upgradeTo(address _implementation) external ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade and call the new implementation\n', '     * to initialize whatever is needed through a low level call.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     * @param _data the msg.data to bet sent in the low level call. This parameter may include the function\n', '     * signature of the implementation to be called with the needed payload.\n', '     */\n', '    function upgradeToAndCall(address _implementation, bytes _data) external payable ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '        //solium-disable-next-line security/no-call-value\n', '        require(address(this).call.value(msg.value)(_data), "Upgrade error: initialization method call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the Address of the proxy admin.\n', '     * @return address\n', '     */\n', '    function admin() external view ifAdmin returns (address) {\n', '        return currentAdmin();\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the implementation address.\n', '     * @param _newImplementation the address of the new implementation to be set\n', '     */\n', '    function upgradeImplementation(address _newImplementation) private {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation, "Upgrade error: proxy contract already uses specified implementation");\n', '        setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', '     * This is a low level function that doesn&#39;t return to its internal call site.\n', '     * It will return to the external caller whatever the implementation returns.\n', '     * @param _implementation Address to delegate.\n', '     */\n', '    function delegate(address _implementation) private {\n', '        assembly {\n', '            // Copy msg.data.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '            // Call current implementation passing proxy calldata.\n', '            let result := delegatecall(gas, _implementation, 0, calldatasize, 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            // Propagate result (delegatecall returns 0 on error).\n', '            switch result\n', '            case 0 {revert(0, returndatasize)}\n', '            default {return (0, returndatasize)}\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return The admin slot.\n', '     */\n', '    function currentAdmin() private view returns (address proxyAdmin) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            proxyAdmin := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the proxy admin.\n', '     * @param _newAdmin Address of the new proxy admin.\n', '     */\n', '    function setAdmin(address _newAdmin) private {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            sstore(slot, _newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param _newImplementation Address of the new implementation.\n', '     */\n', '    function setImplementation(address _newImplementation) private {\n', '        require(\n', '            AddressUtils.isContract(_newImplementation),\n', '            "Cannot set new implementation: no contract code at contract address"\n', '        );\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(slot, _newImplementation)\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/upgradeability/CvcMigrator.sol\n', '\n', '/**\n', '* @title CvcMigrator\n', '* @dev This is a system contract which provides transactional upgrade functionality.\n', '* It allows the ability to add &#39;upgrade transactions&#39; for multiple proxy contracts and execute all of them in single transaction.\n', '*/\n', 'contract CvcMigrator is Ownable {\n', '\n', '    /**\n', '    * @dev The ProxyCreated event is emitted when new instance of CvcProxy contract is deployed.\n', '    * @param proxyAddress New proxy contract instance address.\n', '    */\n', '    event ProxyCreated(address indexed proxyAddress);\n', '\n', '    struct Migration {\n', '        address proxy;\n', '        address implementation;\n', '        bytes data;\n', '    }\n', '\n', '    /// List of registered upgrades.\n', '    Migration[] public migrations;\n', '\n', '    /**\n', '    * @dev Store migration record for the next migration\n', '    * @param _proxy Proxy address\n', '    * @param _implementation Implementation address\n', '    * @param _data Pass-through to proxy&#39;s updateToAndCall\n', '    */\n', '    function addUpgrade(address _proxy, address _implementation, bytes _data) external onlyOwner {\n', '        require(AddressUtils.isContract(_implementation), "Migrator error: no contract code at new implementation address");\n', '        require(CvcProxy(_proxy).implementation() != _implementation, "Migrator error: proxy contract already uses specified implementation");\n', '        migrations.push(Migration(_proxy, _implementation, _data));\n', '    }\n', '\n', '    /**\n', '    * @dev Applies stored upgrades to proxies. Flushes the list of migration records\n', '    */\n', '    function migrate() external onlyOwner {\n', '        for (uint256 i = 0; i < migrations.length; i++) {\n', '            Migration storage migration = migrations[i];\n', '            if (migration.data.length > 0) {\n', '                CvcProxy(migration.proxy).upgradeToAndCall(migration.implementation, migration.data);\n', '            } else {\n', '                CvcProxy(migration.proxy).upgradeTo(migration.implementation);\n', '            }\n', '        }\n', '        delete migrations;\n', '    }\n', '\n', '    /**\n', '    * @dev Flushes the migration list without applying them. Can be used in case wrong migration added to the list.\n', '    */\n', '    function reset() external onlyOwner {\n', '        delete migrations;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers ownership from the migrator to a new address\n', '    * @param _target Proxy address\n', '    * @param _newOwner New proxy owner address\n', '    */\n', '    function changeProxyAdmin(address _target, address _newOwner) external onlyOwner {\n', '        CvcProxy(_target).changeAdmin(_newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Proxy factory\n', '    * @return CvcProxy\n', '    */\n', '    function createProxy() external onlyOwner returns (CvcProxy) {\n', '        CvcProxy proxy = new CvcProxy();\n', '        // We emit event here to retrieve contract address later in the tx receipt\n', '        emit ProxyCreated(address(proxy));\n', '        return proxy;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns migration record by index. Will become obsolete as soon as migrations() will be usable via web3.js\n', '    * @param _index 0-based index\n', '    * @return address Proxy address\n', '    * @return address Implementation address\n', '    * @return bytes Pass-through to proxy&#39;s updateToAndCall\n', '    */\n', '    function getMigration(uint256 _index) external view returns (address, address, bytes) {\n', '        return (migrations[_index].proxy, migrations[_index].implementation, migrations[_index].data);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns current stored migration count\n', '    * @return uint256 Count\n', '    */\n', '    function getMigrationCount() external view returns (uint256) {\n', '        return migrations.length;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/upgradeability/ImplementationStorage.sol\n', '\n', '/**\n', ' * @title ImplementationStorage\n', ' * @dev This contract stores proxy implementation address.\n', ' */\n', 'contract ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "cvc.proxy.implementation", and is validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    */\n', '    constructor() public {\n', '        assert(IMPLEMENTATION_SLOT == keccak256("cvc.proxy.implementation"));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/upgradeability/CvcProxy.sol\n', '\n', '/**\n', ' * @title CvcProxy\n', ' * @dev Transparent proxy with upgradeability functions and authorization control.\n', ' */\n', 'contract CvcProxy is ImplementationStorage {\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address implementation);\n', '\n', '    /**\n', '     * @dev Emitted when the administration has been transferred.\n', '     * @param previousAdmin Address of the previous admin.\n', '     * @param newAdmin Address of the new admin.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "cvc.proxy.admin", and is validated in the constructor.\n', '     */\n', '    bytes32 private constant ADMIN_SLOT = 0x2bbac3e52eee27be250d682577104e2abe776c40160cd3167b24633933100433;\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the admin.\n', '     * It executes the function if called by admin. Otherwise, it will delegate the call to the implementation.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == currentAdmin()) {\n', '            _;\n', '        } else {\n', '            delegate(implementation());\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Contract constructor.\n', '     * It sets the `msg.sender` as the proxy admin.\n', '     */\n', '    constructor() public {\n', '        assert(ADMIN_SLOT == keccak256("cvc.proxy.admin"));\n', '        setAdmin(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function.\n', '     */\n', '    function() external payable {\n', '        require(msg.sender != currentAdmin(), "Message sender is not contract admin");\n', '        delegate(implementation());\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * Only the current admin can call this function.\n', '     * @param _newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeAdmin(address _newAdmin) external ifAdmin {\n', '        require(_newAdmin != address(0), "Cannot change contract admin to zero address");\n', '        emit AdminChanged(currentAdmin(), _newAdmin);\n', '        setAdmin(_newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     */\n', '    function upgradeTo(address _implementation) external ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to upgrade and call the new implementation\n', '     * to initialize whatever is needed through a low level call.\n', '     * @param _implementation the address of the new implementation to be set.\n', '     * @param _data the msg.data to bet sent in the low level call. This parameter may include the function\n', '     * signature of the implementation to be called with the needed payload.\n', '     */\n', '    function upgradeToAndCall(address _implementation, bytes _data) external payable ifAdmin {\n', '        upgradeImplementation(_implementation);\n', '        //solium-disable-next-line security/no-call-value\n', '        require(address(this).call.value(msg.value)(_data), "Upgrade error: initialization method call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the Address of the proxy admin.\n', '     * @return address\n', '     */\n', '    function admin() external view ifAdmin returns (address) {\n', '        return currentAdmin();\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the implementation address.\n', '     * @param _newImplementation the address of the new implementation to be set\n', '     */\n', '    function upgradeImplementation(address _newImplementation) private {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation, "Upgrade error: proxy contract already uses specified implementation");\n', '        setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', "     * This is a low level function that doesn't return to its internal call site.\n", '     * It will return to the external caller whatever the implementation returns.\n', '     * @param _implementation Address to delegate.\n', '     */\n', '    function delegate(address _implementation) private {\n', '        assembly {\n', '            // Copy msg.data.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '            // Call current implementation passing proxy calldata.\n', '            let result := delegatecall(gas, _implementation, 0, calldatasize, 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            // Propagate result (delegatecall returns 0 on error).\n', '            switch result\n', '            case 0 {revert(0, returndatasize)}\n', '            default {return (0, returndatasize)}\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return The admin slot.\n', '     */\n', '    function currentAdmin() private view returns (address proxyAdmin) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            proxyAdmin := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the proxy admin.\n', '     * @param _newAdmin Address of the new proxy admin.\n', '     */\n', '    function setAdmin(address _newAdmin) private {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            sstore(slot, _newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param _newImplementation Address of the new implementation.\n', '     */\n', '    function setImplementation(address _newImplementation) private {\n', '        require(\n', '            AddressUtils.isContract(_newImplementation),\n', '            "Cannot set new implementation: no contract code at contract address"\n', '        );\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(slot, _newImplementation)\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/upgradeability/CvcMigrator.sol\n', '\n', '/**\n', '* @title CvcMigrator\n', '* @dev This is a system contract which provides transactional upgrade functionality.\n', "* It allows the ability to add 'upgrade transactions' for multiple proxy contracts and execute all of them in single transaction.\n", '*/\n', 'contract CvcMigrator is Ownable {\n', '\n', '    /**\n', '    * @dev The ProxyCreated event is emitted when new instance of CvcProxy contract is deployed.\n', '    * @param proxyAddress New proxy contract instance address.\n', '    */\n', '    event ProxyCreated(address indexed proxyAddress);\n', '\n', '    struct Migration {\n', '        address proxy;\n', '        address implementation;\n', '        bytes data;\n', '    }\n', '\n', '    /// List of registered upgrades.\n', '    Migration[] public migrations;\n', '\n', '    /**\n', '    * @dev Store migration record for the next migration\n', '    * @param _proxy Proxy address\n', '    * @param _implementation Implementation address\n', "    * @param _data Pass-through to proxy's updateToAndCall\n", '    */\n', '    function addUpgrade(address _proxy, address _implementation, bytes _data) external onlyOwner {\n', '        require(AddressUtils.isContract(_implementation), "Migrator error: no contract code at new implementation address");\n', '        require(CvcProxy(_proxy).implementation() != _implementation, "Migrator error: proxy contract already uses specified implementation");\n', '        migrations.push(Migration(_proxy, _implementation, _data));\n', '    }\n', '\n', '    /**\n', '    * @dev Applies stored upgrades to proxies. Flushes the list of migration records\n', '    */\n', '    function migrate() external onlyOwner {\n', '        for (uint256 i = 0; i < migrations.length; i++) {\n', '            Migration storage migration = migrations[i];\n', '            if (migration.data.length > 0) {\n', '                CvcProxy(migration.proxy).upgradeToAndCall(migration.implementation, migration.data);\n', '            } else {\n', '                CvcProxy(migration.proxy).upgradeTo(migration.implementation);\n', '            }\n', '        }\n', '        delete migrations;\n', '    }\n', '\n', '    /**\n', '    * @dev Flushes the migration list without applying them. Can be used in case wrong migration added to the list.\n', '    */\n', '    function reset() external onlyOwner {\n', '        delete migrations;\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers ownership from the migrator to a new address\n', '    * @param _target Proxy address\n', '    * @param _newOwner New proxy owner address\n', '    */\n', '    function changeProxyAdmin(address _target, address _newOwner) external onlyOwner {\n', '        CvcProxy(_target).changeAdmin(_newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Proxy factory\n', '    * @return CvcProxy\n', '    */\n', '    function createProxy() external onlyOwner returns (CvcProxy) {\n', '        CvcProxy proxy = new CvcProxy();\n', '        // We emit event here to retrieve contract address later in the tx receipt\n', '        emit ProxyCreated(address(proxy));\n', '        return proxy;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns migration record by index. Will become obsolete as soon as migrations() will be usable via web3.js\n', '    * @param _index 0-based index\n', '    * @return address Proxy address\n', '    * @return address Implementation address\n', "    * @return bytes Pass-through to proxy's updateToAndCall\n", '    */\n', '    function getMigration(uint256 _index) external view returns (address, address, bytes) {\n', '        return (migrations[_index].proxy, migrations[_index].implementation, migrations[_index].data);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns current stored migration count\n', '    * @return uint256 Count\n', '    */\n', '    function getMigrationCount() external view returns (uint256) {\n', '        return migrations.length;\n', '    }\n', '\n', '}']
