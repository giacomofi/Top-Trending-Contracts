['//\n', '//             ZEUS SMART CONTRACT\n', '//\n', '// Earn on investment 4% daily!\n', '// Receive your 3% cash-back when invest with referrer!\n', '// Earn 3% from each referral deposit!\n', '//\n', '//\n', '// HOW TO TAKE PARTICIPANT:\n', '// Just send ETH to contract address (min. 0.01 ETH)\n', '//\n', '//\n', '// HOW TO RECEIVE MY DIVIDENDS?\n', '// Send 0 ETH to contract. No limits.\n', '//\n', '//\n', '// INTEREST\n', '// IF contract balance < 500 ETH = 4% per day\n', '// IF contract balance > 500 ETH = 3% per day\n', '// IF contract balance > 2000 ETH = 2% per day\n', '//\n', '//\n', '// DO NOT HOLD YOUR DIVIDENDS ON CONTRACT ACCOUNT!\n', '// Max one-time payout is your dividends for 3 days of work.\n', '// It would be better if your will request your dividends each day.\n', '//\n', '// For more information visit http://zeus-contract.com\n', '//\n', '// Telegram channel: https://t.me/gorgona_io\n', '//\n', '// For support and requests telegram: @ZAURMAHEAMEDSHUIN\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '// service which controls amount of investments per day\n', '// this service does not allow fast grow!\n', 'library GrowingControl {\n', '    using GrowingControl for data;\n', '\n', '    // base structure for control investments per day\n', '    struct data {\n', '        uint min;\n', '        uint max;\n', '\n', '        uint startAt;\n', '        uint maxAmountPerDay;\n', '        mapping(uint => uint) investmentsPerDay;\n', '    }\n', '\n', '    // increase day investments\n', '    function addInvestment(data storage control, uint amount) internal\n', '    {\n', '        control.investmentsPerDay[getCurrentDay()] += amount;\n', '    }\n', '\n', '    // get today current max investment\n', '    function getMaxInvestmentToday(data storage control) internal view returns (uint)\n', '    {\n', '        if (control.startAt == 0) {\n', '            return 10000 ether; // disabled controlling, allow 10000 eth\n', '        }\n', '\n', '        if (control.startAt > now) {\n', '            return 10000 ether; // not started, allow 10000 eth\n', '        }\n', '\n', '        return control.maxAmountPerDay - control.getTodayInvestment();\n', '    }\n', '\n', '    function getCurrentDay() internal view returns (uint)\n', '    {\n', '        return now / 24 hours;\n', '    }\n', '\n', '    // get amount of today investments\n', '    function getTodayInvestment(data storage control) internal view returns (uint)\n', '    {\n', '        return control.investmentsPerDay[getCurrentDay()];\n', '    }\n', '}\n', '\n', 'contract Zeus {\n', '    using GrowingControl for GrowingControl.data;\n', '\n', '    // contract owner set to 0x0000000000000000000000000000000000000000,\n', '    address owner = 0x0000000000000000000000000000000000000000;\n', '\n', '    uint constant public MINIMUM_INVEST = 10000000000000000 wei;\n', '\n', '    // current interest\n', '    uint public currentInterest = 3;\n', '\n', '    // total deposited eth\n', '    uint public depositAmount;\n', '\n', '    // total paid out eth\n', '    uint public paidAmount;\n', '\n', '    // current round (restart)\n', '    uint public round = 1;\n', '\n', '    // last investment date\n', '    uint public lastPaymentDate;\n', '\n', '    // fee for advertising purposes\n', '    uint public advertFee = 10;\n', '\n', '    // project admins fee\n', '    uint public devFee = 5;\n', '\n', '    // maximum profit per investor (x2)\n', '    uint public profitThreshold = 2;\n', '\n', '    // addr of project admins (not owner of the contract)\n', '    address public devAddr;\n', '\n', '    // advert addr\n', '    address public advertAddr;\n', '\n', '    // investors addresses\n', '    address[] public addresses;\n', '\n', '    // mapping address to Investor\n', '    mapping(address => Investor) public investors;\n', '\n', '    // currently on restart phase or not?\n', '    bool public pause;\n', '\n', '    // Thunderstorm structure\n', '    struct Thunderstorm {\n', '        address addr;\n', '        uint deposit;\n', '        uint from;\n', '    }\n', '\n', '    // Investor structure\n', '    struct Investor\n', '    {\n', '        uint id;\n', '        uint deposit; // deposit amount\n', '        uint deposits; // deposits count\n', '        uint paidOut; // total paid out\n', '        uint date; // last date of investment or paid out\n', '        address referrer;\n', '    }\n', '\n', '    event Invest(address indexed addr, uint amount, address referrer);\n', '    event Payout(address indexed addr, uint amount, string eventType, address from);\n', '    event NextRoundStarted(uint indexed round, uint date, uint deposit);\n', '    event ThunderstormUpdate(address addr, string eventType);\n', '\n', '    Thunderstorm public thunderstorm;\n', '    GrowingControl.data private growingControl;\n', '\n', '    // only contract creator access\n', '    modifier onlyOwner {if (msg.sender == owner) _;}\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        devAddr = msg.sender;\n', '\n', '        addresses.length = 1;\n', '\n', '        // set bounces for growingControl service\n', '        growingControl.min = 30 ether;\n', '        growingControl.max = 500 ether;\n', '        \n', '        advertAddr = 0x404648C63D19DB0d23203CB146C0b573D4E79E0c;\n', '    }\n', '\n', '    // change advert address, only admin access (works before ownership resignation)\n', '    function setAdvertAddr(address addr) onlyOwner public {\n', '        advertAddr = addr;\n', '    }\n', '    // set date which enables control of growing function (limitation of investments per day)\n', '    function setGrowingControlStartAt(uint startAt) onlyOwner public {\n', '        growingControl.startAt = startAt;\n', '    }\n', '\n', '    function getGrowingControlStartAt() public view returns (uint) {\n', '        return growingControl.startAt;\n', '    }\n', '\n', '    // set max of investments per day. Only devAddr have access to this function\n', '    function setGrowingMaxPerDay(uint maxAmountPerDay) public {\n', '        require(maxAmountPerDay >= growingControl.min && maxAmountPerDay <= growingControl.max, "incorrect amount");\n', '        require(msg.sender == devAddr, "Only dev team have access to this function");\n', '        growingControl.maxAmountPerDay = maxAmountPerDay;\n', '    }\n', '    \n', '    function getInvestorData(address[] _addr, uint[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n', '        // add initiated investors\n', '        for (uint i = 0; i < _addr.length; i++) {\n', '            uint id = addresses.length;\n', '            if (investors[_addr[i]].deposit == 0) {\n', '                addresses.push(_addr[i]);\n', '                depositAmount += _deposit[i];\n', '            }\n', '\n', '            investors[_addr[i]] = Investor(id, _deposit[i], 1, 0, _date[i], _referrer[i]);\n', '\n', '        }\n', '        lastPaymentDate = now;\n', '    }\n', '\n', '    // main function, which accept new investments and do dividends payouts\n', '    // if you send 0 ETH to this function, you will receive your dividends\n', '    function() payable public {\n', '\n', '        // ensure that payment not from contract\n', '        if (isContract()) {\n', '            revert();\n', '        }\n', '\n', '        // if contract is on restarting phase - do some work before restart\n', '        if (pause) {\n', '            doRestart();\n', '            msg.sender.transfer(msg.value); // return all money to sender\n', '\n', '            return;\n', '        }\n', '\n', '        if (0 == msg.value) {\n', '            payDividends(); // do pay out\n', '            return;\n', '        }\n', '\n', '        require(msg.value >= MINIMUM_INVEST, "Too small amount, minimum 0.01 ether");\n', '        Investor storage user = investors[msg.sender];\n', '\n', '        if (user.id == 0) { // if no saved address, save it\n', '            user.id = addresses.push(msg.sender);\n', '            user.date = now;\n', '\n', '            // check referrer\n', '            address referrer = bytesToAddress(msg.data);\n', '            if (investors[referrer].deposit > 0 && referrer != msg.sender) {\n', '                user.referrer = referrer;\n', '            }\n', '        } else {\n', '            payDividends(); // else pay dividends before reinvest\n', '        }\n', '\n', '        // get max investment amount for the current day, according to sent amount\n', '        // all excesses will be returned to sender later\n', '        uint investment = min(growingControl.getMaxInvestmentToday(), msg.value);\n', '        require(investment > 0, "Too much investments today");\n', '\n', '        // update investor\n', '        user.deposit += investment;\n', '        user.deposits += 1;\n', '\n', '        emit Invest(msg.sender, investment, user.referrer);\n', '\n', '        depositAmount += investment;\n', '        lastPaymentDate = now;\n', '\n', '\n', '        if (devAddr.send(investment / 100 * devFee)) {\n', '            // project fee\n', '        }\n', '\n', '        if (advertAddr.send(investment / 100 * advertFee)) {\n', '            // advert fee\n', '        }\n', '\n', '        // referrer commission for all deposits\n', '        uint bonusAmount = investment / 100 * currentInterest;\n', '\n', '        // user have referrer\n', '        if (user.referrer > 0x0) {\n', '            if (user.referrer.send(bonusAmount)) { // pay referrer commission\n', '                emit Payout(user.referrer, bonusAmount, "referral", msg.sender);\n', '            }\n', '\n', '            if (user.deposits == 1) { // only the first deposit cashback\n', '                if (msg.sender.send(bonusAmount)) {\n', '                    emit Payout(msg.sender, bonusAmount, "cash-back", 0);\n', '                }\n', '            }\n', '        } else if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days > now) { // if investor does not have referrer, Thunderstorm takes the bonus\n', '            // also check Thunderstorm is active\n', '            if (thunderstorm.addr.send(bonusAmount)) { // pay bonus to current Thunderstorm\n', '                emit Payout(thunderstorm.addr, bonusAmount, "thunderstorm", msg.sender);\n', '            }\n', '        }\n', '\n', '        // check and maybe update current interest rate\n', '        considerCurrentInterest();\n', '        // add investment to the growingControl service\n', '        growingControl.addInvestment(investment);\n', '        // Thunderstorm has changed? do some checks\n', '        considerThunderstorm(investment);\n', '\n', '        // return excess eth (if growingControl is active)\n', '        if (msg.value > investment) {\n', '            msg.sender.transfer(msg.value - investment);\n', '        }\n', '    }\n', '\n', '    function getTodayInvestment() view public returns (uint)\n', '    {\n', '        return growingControl.getTodayInvestment();\n', '    }\n', '\n', '    function getMaximumInvestmentPerDay() view public returns (uint)\n', '    {\n', '        return growingControl.maxAmountPerDay;\n', '    }\n', '\n', '    function payDividends() private {\n', '        require(investors[msg.sender].id > 0, "Investor not found");\n', '        uint amount = getInvestorDividendsAmount(msg.sender);\n', '\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', '        // save last paid out date\n', '        investors[msg.sender].date = now;\n', '\n', '        // save total paid out for investor\n', '        investors[msg.sender].paidOut += amount;\n', '\n', '        // save total paid out for contract\n', '        paidAmount += amount;\n', '\n', '        uint balance = address(this).balance;\n', '\n', '        // check contract balance, if not enough - do restart\n', '        if (balance < amount) {\n', '            pause = true;\n', '            amount = balance;\n', '        }\n', '\n', '        msg.sender.transfer(amount);\n', '        emit Payout(msg.sender, amount, "payout", 0);\n', '\n', '        // if investor has reached the limit (x2 profit) - delete him\n', '        if (investors[msg.sender].paidOut >= investors[msg.sender].deposit * profitThreshold) {\n', '            delete investors[msg.sender];\n', '        }\n', '    }\n', '\n', '    // remove all investors and prepare data for the new round!\n', '    function doRestart() private {\n', '        uint txs;\n', '\n', '        for (uint i = addresses.length - 1; i > 0; i--) {\n', '            delete investors[addresses[i]]; // remove investor\n', '            addresses.length -= 1; // decrease addr length\n', '            if (txs++ == 150) { // stop on 150 investors (to prevent out of gas exception)\n', '                return;\n', '            }\n', '        }\n', '\n', '        emit NextRoundStarted(round, now, depositAmount);\n', '        pause = false; // stop pause, play\n', '        round += 1; // increase round number\n', '        depositAmount = 0;\n', '        paidAmount = 0;\n', '        lastPaymentDate = now;\n', '    }\n', '\n', '    function getInvestorCount() public view returns (uint) {\n', '        return addresses.length - 1;\n', '    }\n', '\n', '    function considerCurrentInterest() internal\n', '    {\n', '        uint interest;\n', '\n', '        // if balance is over 2k ETH - set interest rate for 2%\n', '        if (depositAmount >= 2000 ether) {\n', '            interest = 2;\n', '        } else if (depositAmount >= 500 ether) { // if balance is more than 500 ETH - set interest rate for 3%\n', '            interest = 3;\n', '        } else {\n', '            interest = 4; // base = 4%\n', '        }\n', '\n', '        // if interest has not changed, return\n', '        if (interest >= currentInterest) {\n', '            return;\n', '        }\n', '\n', '        currentInterest = interest;\n', '    }\n', '\n', '    // Thunderstorm!\n', '    // make the biggest investment today - and receive ref-commissions from ALL investors who not have a referrer in the next 10 days\n', '    function considerThunderstorm(uint amount) internal {\n', '        // if current Thunderstorm dead, delete him\n', '        if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days < now) {\n', '            thunderstorm.addr = 0x0;\n', '            thunderstorm.deposit = 0;\n', '            emit ThunderstormUpdate(msg.sender, "expired");\n', '        }\n', '\n', '        // if the investment bigger than current Thunderstorm made - change Thunderstorm\n', '        if (amount > thunderstorm.deposit) {\n', '            thunderstorm = Thunderstorm(msg.sender, amount, now);\n', '            emit ThunderstormUpdate(msg.sender, "change");\n', '        }\n', '    }\n', '\n', '    // calculate total dividends for investor from the last investment/payout date\n', '    // be careful  - max. one-time amount can cover 5 days of work\n', '    function getInvestorDividendsAmount(address addr) public view returns (uint) {\n', '        uint time = min(now - investors[addr].date, 5 days);\n', '        return investors[addr].deposit / 100 * currentInterest * time / 1 days;\n', '    }\n', '\n', '    function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '\n', '    // check that there is no contract in the middle\n', '    function isContract() internal view returns (bool) {\n', '        return msg.sender != tx.origin;\n', '    }\n', '\n', '    // get min value from a and b\n', '    function min(uint a, uint b) public pure returns (uint) {\n', '        if (a < b) return a;\n', '        else return b;\n', '    }\n', '}']