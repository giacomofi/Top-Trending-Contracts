['pragma solidity ^0.4.18;\n', '\n', '/*\n', '*   DapCar Token (DAPX)\n', '*   Created by Starlag Labs (www.starlag.com)\n', '*   Copyright &#169; DapCar.io 2018. All rights reserved.\n', '*   https://www.dapcar.io\n', '*/\n', '\n', 'library Math {\n', '    function mul(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Utils {\n', '    function Utils() public {}\n', '\n', '    modifier greaterThanZero(uint256 _value) \n', '    {\n', '        require(_value > 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint(uint256 _value) \n', '    {\n', '        require(_value >= 0);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) \n', '    {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) \n', '    {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier validAddressAndNotThis(address _address) \n', '    {\n', '        require(_address != address(0) && _address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notEmpty(string _data)\n', '    {\n', '        require(bytes(_data).length > 0);\n', '        _;\n', '    }\n', '\n', '    modifier stringLength(string _data, uint256 _length)\n', '    {\n', '        require(bytes(_data).length == _length);\n', '        _;\n', '    }\n', '    \n', '    modifier validBytes32(bytes32 _bytes)\n', '    {\n', '        require(_bytes != 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint64(uint64 _value) \n', '    {\n', '        require(_value >= 0 && _value < 4294967296);\n', '        _;\n', '    }\n', '\n', '    modifier validUint8(uint8 _value) \n', '    {\n', '        require(_value >= 0 && _value < 256);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceThis(uint256 _value)\n', '    {\n', '        require(_value <= address(this).balance);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Authorizable is Utils {\n', '    using Math for uint256;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    mapping (address => Level) authorizeds;\n', '    uint256 public authorizedCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   OWNER 1\n', '    *   ADMIN 2\n', '    *   DAPP 3\n', '    */  \n', '    enum Level {ZERO,OWNER,ADMIN,DAPP}\n', '\n', '    event OwnerTransferred(address indexed _prevOwner, address indexed _newOwner);\n', '    event Authorized(address indexed _address, Level _level);\n', '    event UnAuthorized(address indexed _address);\n', '\n', '    function Authorizable() \n', '    public \n', '    {\n', '        owner = msg.sender;\n', '        authorizeds[msg.sender] = Level.OWNER;\n', '        authorizedCount = authorizedCount.add(1);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(authorizeds[msg.sender] == Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrThis {\n', '        require(authorizeds[msg.sender] == Level.OWNER || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notOwner(address _address) {\n', '        require(authorizeds[_address] != Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier authLevel(Level _level) {\n', '        require((authorizeds[msg.sender] > Level.ZERO) && (authorizeds[msg.sender] <= _level));\n', '        _;\n', '    }\n', '\n', '    modifier authLevelOnly(Level _level) {\n', '        require(authorizeds[msg.sender] == _level);\n', '        _;\n', '    }\n', '    \n', '    modifier notSender(address _address) {\n', '        require(msg.sender != _address);\n', '        _;\n', '    }\n', '\n', '    modifier isSender(address _address) {\n', '        require(msg.sender == _address);\n', '        _;\n', '    }\n', '\n', '    modifier checkLevel(Level _level) {\n', '        require((_level > Level.ZERO) && (Level.DAPP >= _level));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) \n', '    public \n', '    {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) \n', '    onlyOwner \n', '    validAddress(_newOwner)\n', '    notThis(_newOwner)\n', '    internal \n', '    {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() \n', '    validAddress(newOwner)\n', '    isSender(newOwner)\n', '    public \n', '    {\n', '        OwnerTransferred(owner, newOwner);\n', '        if (authorizeds[owner] == Level.OWNER) {\n', '            delete authorizeds[owner];\n', '        }\n', '        if (authorizeds[newOwner] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        authorizeds[owner] = Level.OWNER;\n', '    }\n', '\n', '    function cancelOwnership() \n', '    onlyOwner\n', '    public \n', '    {\n', '        newOwner = address(0);\n', '    }\n', '\n', '    function authorized(address _address, Level _level) \n', '    public  \n', '    {\n', '        _authorized(_address, _level);\n', '    }\n', '\n', '    function _authorized(address _address, Level _level) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    checkLevel(_level)\n', '    internal  \n', '    {\n', '        if (authorizeds[_address] == Level.ZERO) {\n', '            authorizedCount = authorizedCount.add(1);\n', '        }\n', '        authorizeds[_address] = _level;\n', '        Authorized(_address, _level);\n', '    }\n', '\n', '    function unAuthorized(address _address) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    public  \n', '    {\n', '        if (authorizeds[_address] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        delete authorizeds[_address];\n', '        UnAuthorized(_address);\n', '    }\n', '\n', '    function isAuthorized(address _address) \n', '    validAddress(_address)\n', '    notThis(_address)\n', '    public \n', '    constant \n', '    returns (Level) \n', '    {\n', '        return authorizeds[_address];\n', '    }\n', '}\n', '\n', 'contract ITokenRecipient { function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract IERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20Token is Authorizable, IERC20 {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    modifier validBalance(uint256 _value)\n', '    {\n', '        require(_value <= balances[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceFrom(address _from, uint256 _value)\n', '    {\n', '        require(_value <= balances[_from]);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceOverflows(address _to, uint256 _value)\n', '    {\n', '        require(balances[_to] <= balances[_to].add(_value));\n', '        _;\n', '    }\n', '\n', '    function ERC20Token() public {}\n', '\n', '    function totalSupply()\n', '    public \n', '    constant \n', '    returns (uint256) \n', '    {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        return _transfer(_to, _value);\n', '    }\n', '\n', '    function _transfer(address _to, uint256 _value)\n', '    validAddress(_to)\n', '    greaterThanZero(_value)\n', '    validBalance(_value)\n', '    validBalanceOverflows(_to, _value)\n', '    internal\n', '    returns (bool success) \n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        return _transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function _transferFrom(address _from, address _to, uint256 _value)\n', '    validAddress(_to)\n', '    validAddress(_from)\n', '    greaterThanZero(_value)\n', '    validBalanceFrom(_from, _value)\n', '    validBalanceOverflows(_to, _value)\n', '    internal \n', '    returns (bool success) \n', '    {\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '    validAddress(_owner)\n', '    public \n', '    constant \n', '    returns (uint256 balance) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) \n', '    public \n', '    returns (bool success) \n', '    {\n', '        return _approve(_spender, _value);\n', '    }\n', '\n', '    function _approve(address _spender, uint256 _value) \n', '    validAddress(_spender)\n', '    internal \n', '    returns (bool success) \n', '    {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)\n', '    validAddress(_owner)\n', '    validAddress(_spender)\n', '    public \n', '    constant \n', '    returns (uint256 remaining) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue)\n', '    validAddress(_spender)\n', '    greaterThanZero(_addedValue)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    validAddress(_spender)\n', '    greaterThanZero(_subtractedValue)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            delete allowed[msg.sender][_spender];\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract FrozenToken is ERC20Token, ITokenRecipient {\n', '    mapping (address => bool) frozeds;\n', '    uint256 public frozedCount;\n', '    bool public freezeEnabled = true;\n', '    bool public autoFreeze = true;\n', '    bool public mintFinished = false;\n', '\n', '    event Freeze(address indexed wallet);\n', '    event UnFreeze(address indexed wallet);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '    event Mint(address indexed sender, address indexed wallet, uint256 amount);\n', '    event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData);\n', '    event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); \n', '    event Burn(address indexed sender, uint256 amount);\n', '    event MintFinished(address indexed spender);\n', '\n', '    modifier notFreeze\n', '    {\n', '        require(frozeds[msg.sender] == false || freezeEnabled == false);\n', '        _;\n', '    }\n', '\n', '    modifier notFreezeFrom(address _from) \n', '    {\n', '        require((_from != address(0) && frozeds[_from] == false) || freezeEnabled == false);\n', '        _;\n', '    }\n', '\n', '    modifier canMint\n', '    {\n', '        require(!mintFinished);\n', '        _;\n', '    }\n', '\n', '    function FrozenToken() public {}\n', '\n', '    function freeze(address _address) \n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    notThis(_address)\n', '    notOwner(_address)\n', '    public \n', '    {\n', '        if (!frozeds[_address]) {\n', '            frozeds[_address] = true;\n', '            frozedCount = frozedCount.add(1);\n', '            Freeze(_address);\n', '        }\n', '    }\n', '\n', '    function unFreeze(address _address) \n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    public \n', '    {\n', '        if (frozeds[_address]) {\n', '            delete frozeds[_address];\n', '            frozedCount = frozedCount.sub(1);\n', '            UnFreeze(_address);\n', '        }\n', '    }\n', '\n', '    function updFreezeEnabled(bool _freezeEnabled) \n', '    authLevel(Level.ADMIN)\n', '    public \n', '    {\n', '        PropsChanged(msg.sender, "freezeEnabled", freezeEnabled, _freezeEnabled);\n', '        freezeEnabled = _freezeEnabled;\n', '    }\n', '\n', '    function updAutoFreeze(bool _autoFreeze) \n', '    authLevel(Level.ADMIN)\n', '    public \n', '    {\n', '        PropsChanged(msg.sender, "autoFreeze", autoFreeze, _autoFreeze);\n', '        autoFreeze = _autoFreeze;\n', '    }\n', '\n', '    function isFreeze(address _address) \n', '    validAddress(_address)\n', '    public \n', '    constant \n', '    returns(bool) \n', '    {\n', '        return bool(frozeds[_address]);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) \n', '    notFreeze\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) \n', '    notFreezeFrom(_from)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) \n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue)\n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) \n', '    validAddress(_spender)\n', '    greaterThanZero(_value)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        ITokenRecipient spender = ITokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            ApproveAndCall(_spender, _value, _extraData); \n', '            return true;\n', '        }\n', '    }\n', '\n', '    function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData)\n', '    validAddress(_spender)\n', '    validAddress(_token)\n', '    greaterThanZero(_value)\n', '    public \n', '    {\n', '        IERC20 token = IERC20(_token);\n', '        require(token.transferFrom(_spender, address(this), _value));\n', '        ReceiveTokens(_spender, _token, _value, _extraData);\n', '    }\n', '\n', '    function mintFinish() \n', '    onlyOwner\n', '    public \n', '    returns (bool success)\n', '    {\n', '        mintFinished = true;\n', '        MintFinished(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function mint(address _address, uint256 _value)\n', '    canMint\n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    greaterThanZero(_value)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        balances[_address] = balances[_address].add(_value);\n', '        totalSupply_ = totalSupply_.add(_value);\n', '        Transfer(0, _address, _value);\n', '\n', '        if (freezeEnabled && autoFreeze && _address != address(this) && isAuthorized(_address) == Level.ZERO) {\n', '            if (!isFreeze(_address)) {\n', '                frozeds[_address] = true;\n', '                frozedCount = frozedCount.add(1);\n', '                Freeze(_address);\n', '            }\n', '        }\n', '\n', '        Mint(0, _address, _value);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value)\n', '    greaterThanZero(_value)\n', '    validBalance(_value)\n', '    public\n', '    returns (bool) \n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '\n', '        if (isFreeze(msg.sender)) {\n', '            delete frozeds[msg.sender];\n', '            frozedCount = frozedCount.sub(1);\n', '            UnFreeze(msg.sender);\n', '        }\n', '\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract DapCarToken is FrozenToken {\n', '    string public name = "DapCar Token";\n', '    string public symbol = "DAPX";\n', '    uint8 public decimals = 0;\n', '\n', '    string public version = "0.1";\n', '    string public publisher = "https://www.dapcar.io";\n', '    string public description = "This is an official DapCar Token (DAPX)";\n', '\n', '    bool public acceptAdminWithdraw = false;\n', '    bool public acceptDonate = true;\n', '\n', '    event InfoChanged(address indexed sender, string version, string publisher, string description);\n', '    event Withdraw(address indexed sender, address indexed wallet, uint256 amount);\n', '    event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount);\n', '    event Donate(address indexed sender, uint256 value);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '\n', '    function DapCarToken() public {}\n', '\n', '    function setupInfo(string _version, string _publisher, string _description)\n', '    authLevel(Level.ADMIN)\n', '    notEmpty(_version)\n', '    notEmpty(_publisher)\n', '    notEmpty(_description)\n', '    public\n', '    {\n', '        version = _version;\n', '        publisher = _publisher;\n', '        description = _description;\n', '        InfoChanged(msg.sender, _version, _publisher, _description);\n', '    }\n', '\n', '    function withdraw() \n', '    public \n', '    returns (bool success)\n', '    {\n', '        return withdrawAmount(address(this).balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 _amount) \n', '    authLevel(Level.ADMIN) \n', '    greaterThanZero(address(this).balance)\n', '    greaterThanZero(_amount)\n', '    validBalanceThis(_amount)\n', '    public \n', '    returns (bool success)\n', '    {\n', '        address wallet = owner;\n', '        if (acceptAdminWithdraw) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        Withdraw(msg.sender, wallet, address(this).balance);\n', '        wallet.transfer(address(this).balance);\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(address _token, uint256 _amount)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    greaterThanZero(_amount)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        address wallet = owner;\n', '        if (acceptAdminWithdraw) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        bool result = IERC20(_token).transfer(wallet, _amount);\n', '        if (result) {\n', '            WithdrawTokens(msg.sender, wallet, _token, _amount);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function balanceToken(address _token)\n', '    validAddress(_token)\n', '    public \n', '    constant\n', '    returns (uint256 amount) \n', '    {\n', '        return IERC20(_token).balanceOf(address(this));\n', '    }\n', '\n', '    function updAcceptAdminWithdraw(bool _accept)\n', '    onlyOwner\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "acceptAdminWithdraw", acceptAdminWithdraw, _accept);\n', '        acceptAdminWithdraw = _accept;\n', '        return true;\n', '    }\n', '    \n', '    function () \n', '    external \n', '    payable \n', '    {\n', '        if (acceptDonate) {\n', '            donate();\n', '        }\n', '\t}\n', '\n', '    function donate() \n', '    greaterThanZero(msg.value)\n', '    internal \n', '    {\n', '        Donate(msg.sender, msg.value);\n', '    }\n', '\n', '    function updAcceptDonate(bool _accept)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "acceptDonate", acceptDonate, _accept);\n', '        acceptDonate = _accept;\n', '        return true;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', '*   DapCar Token (DAPX)\n', '*   Created by Starlag Labs (www.starlag.com)\n', '*   Copyright Â© DapCar.io 2018. All rights reserved.\n', '*   https://www.dapcar.io\n', '*/\n', '\n', 'library Math {\n', '    function mul(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Utils {\n', '    function Utils() public {}\n', '\n', '    modifier greaterThanZero(uint256 _value) \n', '    {\n', '        require(_value > 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint(uint256 _value) \n', '    {\n', '        require(_value >= 0);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) \n', '    {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) \n', '    {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier validAddressAndNotThis(address _address) \n', '    {\n', '        require(_address != address(0) && _address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notEmpty(string _data)\n', '    {\n', '        require(bytes(_data).length > 0);\n', '        _;\n', '    }\n', '\n', '    modifier stringLength(string _data, uint256 _length)\n', '    {\n', '        require(bytes(_data).length == _length);\n', '        _;\n', '    }\n', '    \n', '    modifier validBytes32(bytes32 _bytes)\n', '    {\n', '        require(_bytes != 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint64(uint64 _value) \n', '    {\n', '        require(_value >= 0 && _value < 4294967296);\n', '        _;\n', '    }\n', '\n', '    modifier validUint8(uint8 _value) \n', '    {\n', '        require(_value >= 0 && _value < 256);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceThis(uint256 _value)\n', '    {\n', '        require(_value <= address(this).balance);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Authorizable is Utils {\n', '    using Math for uint256;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    mapping (address => Level) authorizeds;\n', '    uint256 public authorizedCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   OWNER 1\n', '    *   ADMIN 2\n', '    *   DAPP 3\n', '    */  \n', '    enum Level {ZERO,OWNER,ADMIN,DAPP}\n', '\n', '    event OwnerTransferred(address indexed _prevOwner, address indexed _newOwner);\n', '    event Authorized(address indexed _address, Level _level);\n', '    event UnAuthorized(address indexed _address);\n', '\n', '    function Authorizable() \n', '    public \n', '    {\n', '        owner = msg.sender;\n', '        authorizeds[msg.sender] = Level.OWNER;\n', '        authorizedCount = authorizedCount.add(1);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(authorizeds[msg.sender] == Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrThis {\n', '        require(authorizeds[msg.sender] == Level.OWNER || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notOwner(address _address) {\n', '        require(authorizeds[_address] != Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier authLevel(Level _level) {\n', '        require((authorizeds[msg.sender] > Level.ZERO) && (authorizeds[msg.sender] <= _level));\n', '        _;\n', '    }\n', '\n', '    modifier authLevelOnly(Level _level) {\n', '        require(authorizeds[msg.sender] == _level);\n', '        _;\n', '    }\n', '    \n', '    modifier notSender(address _address) {\n', '        require(msg.sender != _address);\n', '        _;\n', '    }\n', '\n', '    modifier isSender(address _address) {\n', '        require(msg.sender == _address);\n', '        _;\n', '    }\n', '\n', '    modifier checkLevel(Level _level) {\n', '        require((_level > Level.ZERO) && (Level.DAPP >= _level));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) \n', '    public \n', '    {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) \n', '    onlyOwner \n', '    validAddress(_newOwner)\n', '    notThis(_newOwner)\n', '    internal \n', '    {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() \n', '    validAddress(newOwner)\n', '    isSender(newOwner)\n', '    public \n', '    {\n', '        OwnerTransferred(owner, newOwner);\n', '        if (authorizeds[owner] == Level.OWNER) {\n', '            delete authorizeds[owner];\n', '        }\n', '        if (authorizeds[newOwner] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        authorizeds[owner] = Level.OWNER;\n', '    }\n', '\n', '    function cancelOwnership() \n', '    onlyOwner\n', '    public \n', '    {\n', '        newOwner = address(0);\n', '    }\n', '\n', '    function authorized(address _address, Level _level) \n', '    public  \n', '    {\n', '        _authorized(_address, _level);\n', '    }\n', '\n', '    function _authorized(address _address, Level _level) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    checkLevel(_level)\n', '    internal  \n', '    {\n', '        if (authorizeds[_address] == Level.ZERO) {\n', '            authorizedCount = authorizedCount.add(1);\n', '        }\n', '        authorizeds[_address] = _level;\n', '        Authorized(_address, _level);\n', '    }\n', '\n', '    function unAuthorized(address _address) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    public  \n', '    {\n', '        if (authorizeds[_address] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        delete authorizeds[_address];\n', '        UnAuthorized(_address);\n', '    }\n', '\n', '    function isAuthorized(address _address) \n', '    validAddress(_address)\n', '    notThis(_address)\n', '    public \n', '    constant \n', '    returns (Level) \n', '    {\n', '        return authorizeds[_address];\n', '    }\n', '}\n', '\n', 'contract ITokenRecipient { function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract IERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20Token is Authorizable, IERC20 {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '    uint256 totalSupply_;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    modifier validBalance(uint256 _value)\n', '    {\n', '        require(_value <= balances[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceFrom(address _from, uint256 _value)\n', '    {\n', '        require(_value <= balances[_from]);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceOverflows(address _to, uint256 _value)\n', '    {\n', '        require(balances[_to] <= balances[_to].add(_value));\n', '        _;\n', '    }\n', '\n', '    function ERC20Token() public {}\n', '\n', '    function totalSupply()\n', '    public \n', '    constant \n', '    returns (uint256) \n', '    {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        return _transfer(_to, _value);\n', '    }\n', '\n', '    function _transfer(address _to, uint256 _value)\n', '    validAddress(_to)\n', '    greaterThanZero(_value)\n', '    validBalance(_value)\n', '    validBalanceOverflows(_to, _value)\n', '    internal\n', '    returns (bool success) \n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        return _transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function _transferFrom(address _from, address _to, uint256 _value)\n', '    validAddress(_to)\n', '    validAddress(_from)\n', '    greaterThanZero(_value)\n', '    validBalanceFrom(_from, _value)\n', '    validBalanceOverflows(_to, _value)\n', '    internal \n', '    returns (bool success) \n', '    {\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '    validAddress(_owner)\n', '    public \n', '    constant \n', '    returns (uint256 balance) \n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) \n', '    public \n', '    returns (bool success) \n', '    {\n', '        return _approve(_spender, _value);\n', '    }\n', '\n', '    function _approve(address _spender, uint256 _value) \n', '    validAddress(_spender)\n', '    internal \n', '    returns (bool success) \n', '    {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)\n', '    validAddress(_owner)\n', '    validAddress(_spender)\n', '    public \n', '    constant \n', '    returns (uint256 remaining) \n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue)\n', '    validAddress(_spender)\n', '    greaterThanZero(_addedValue)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    validAddress(_spender)\n', '    greaterThanZero(_subtractedValue)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            delete allowed[msg.sender][_spender];\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract FrozenToken is ERC20Token, ITokenRecipient {\n', '    mapping (address => bool) frozeds;\n', '    uint256 public frozedCount;\n', '    bool public freezeEnabled = true;\n', '    bool public autoFreeze = true;\n', '    bool public mintFinished = false;\n', '\n', '    event Freeze(address indexed wallet);\n', '    event UnFreeze(address indexed wallet);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '    event Mint(address indexed sender, address indexed wallet, uint256 amount);\n', '    event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData);\n', '    event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); \n', '    event Burn(address indexed sender, uint256 amount);\n', '    event MintFinished(address indexed spender);\n', '\n', '    modifier notFreeze\n', '    {\n', '        require(frozeds[msg.sender] == false || freezeEnabled == false);\n', '        _;\n', '    }\n', '\n', '    modifier notFreezeFrom(address _from) \n', '    {\n', '        require((_from != address(0) && frozeds[_from] == false) || freezeEnabled == false);\n', '        _;\n', '    }\n', '\n', '    modifier canMint\n', '    {\n', '        require(!mintFinished);\n', '        _;\n', '    }\n', '\n', '    function FrozenToken() public {}\n', '\n', '    function freeze(address _address) \n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    notThis(_address)\n', '    notOwner(_address)\n', '    public \n', '    {\n', '        if (!frozeds[_address]) {\n', '            frozeds[_address] = true;\n', '            frozedCount = frozedCount.add(1);\n', '            Freeze(_address);\n', '        }\n', '    }\n', '\n', '    function unFreeze(address _address) \n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    public \n', '    {\n', '        if (frozeds[_address]) {\n', '            delete frozeds[_address];\n', '            frozedCount = frozedCount.sub(1);\n', '            UnFreeze(_address);\n', '        }\n', '    }\n', '\n', '    function updFreezeEnabled(bool _freezeEnabled) \n', '    authLevel(Level.ADMIN)\n', '    public \n', '    {\n', '        PropsChanged(msg.sender, "freezeEnabled", freezeEnabled, _freezeEnabled);\n', '        freezeEnabled = _freezeEnabled;\n', '    }\n', '\n', '    function updAutoFreeze(bool _autoFreeze) \n', '    authLevel(Level.ADMIN)\n', '    public \n', '    {\n', '        PropsChanged(msg.sender, "autoFreeze", autoFreeze, _autoFreeze);\n', '        autoFreeze = _autoFreeze;\n', '    }\n', '\n', '    function isFreeze(address _address) \n', '    validAddress(_address)\n', '    public \n', '    constant \n', '    returns(bool) \n', '    {\n', '        return bool(frozeds[_address]);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) \n', '    notFreeze\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) \n', '    notFreezeFrom(_from)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) \n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint256 _addedValue)\n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.increaseApproval(_spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) \n', '    notFreezeFrom(_spender)\n', '    public \n', '    returns (bool) \n', '    {\n', '        return super.decreaseApproval(_spender, _subtractedValue);\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) \n', '    validAddress(_spender)\n', '    greaterThanZero(_value)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        ITokenRecipient spender = ITokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            ApproveAndCall(_spender, _value, _extraData); \n', '            return true;\n', '        }\n', '    }\n', '\n', '    function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData)\n', '    validAddress(_spender)\n', '    validAddress(_token)\n', '    greaterThanZero(_value)\n', '    public \n', '    {\n', '        IERC20 token = IERC20(_token);\n', '        require(token.transferFrom(_spender, address(this), _value));\n', '        ReceiveTokens(_spender, _token, _value, _extraData);\n', '    }\n', '\n', '    function mintFinish() \n', '    onlyOwner\n', '    public \n', '    returns (bool success)\n', '    {\n', '        mintFinished = true;\n', '        MintFinished(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function mint(address _address, uint256 _value)\n', '    canMint\n', '    authLevel(Level.DAPP)\n', '    validAddress(_address)\n', '    greaterThanZero(_value)\n', '    public\n', '    returns (bool success) \n', '    {\n', '        balances[_address] = balances[_address].add(_value);\n', '        totalSupply_ = totalSupply_.add(_value);\n', '        Transfer(0, _address, _value);\n', '\n', '        if (freezeEnabled && autoFreeze && _address != address(this) && isAuthorized(_address) == Level.ZERO) {\n', '            if (!isFreeze(_address)) {\n', '                frozeds[_address] = true;\n', '                frozedCount = frozedCount.add(1);\n', '                Freeze(_address);\n', '            }\n', '        }\n', '\n', '        Mint(0, _address, _value);\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value)\n', '    greaterThanZero(_value)\n', '    validBalance(_value)\n', '    public\n', '    returns (bool) \n', '    {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply_ = totalSupply_.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '\n', '        if (isFreeze(msg.sender)) {\n', '            delete frozeds[msg.sender];\n', '            frozedCount = frozedCount.sub(1);\n', '            UnFreeze(msg.sender);\n', '        }\n', '\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract DapCarToken is FrozenToken {\n', '    string public name = "DapCar Token";\n', '    string public symbol = "DAPX";\n', '    uint8 public decimals = 0;\n', '\n', '    string public version = "0.1";\n', '    string public publisher = "https://www.dapcar.io";\n', '    string public description = "This is an official DapCar Token (DAPX)";\n', '\n', '    bool public acceptAdminWithdraw = false;\n', '    bool public acceptDonate = true;\n', '\n', '    event InfoChanged(address indexed sender, string version, string publisher, string description);\n', '    event Withdraw(address indexed sender, address indexed wallet, uint256 amount);\n', '    event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount);\n', '    event Donate(address indexed sender, uint256 value);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '\n', '    function DapCarToken() public {}\n', '\n', '    function setupInfo(string _version, string _publisher, string _description)\n', '    authLevel(Level.ADMIN)\n', '    notEmpty(_version)\n', '    notEmpty(_publisher)\n', '    notEmpty(_description)\n', '    public\n', '    {\n', '        version = _version;\n', '        publisher = _publisher;\n', '        description = _description;\n', '        InfoChanged(msg.sender, _version, _publisher, _description);\n', '    }\n', '\n', '    function withdraw() \n', '    public \n', '    returns (bool success)\n', '    {\n', '        return withdrawAmount(address(this).balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 _amount) \n', '    authLevel(Level.ADMIN) \n', '    greaterThanZero(address(this).balance)\n', '    greaterThanZero(_amount)\n', '    validBalanceThis(_amount)\n', '    public \n', '    returns (bool success)\n', '    {\n', '        address wallet = owner;\n', '        if (acceptAdminWithdraw) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        Withdraw(msg.sender, wallet, address(this).balance);\n', '        wallet.transfer(address(this).balance);\n', '        return true;\n', '    }\n', '\n', '    function withdrawTokens(address _token, uint256 _amount)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    greaterThanZero(_amount)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        address wallet = owner;\n', '        if (acceptAdminWithdraw) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        bool result = IERC20(_token).transfer(wallet, _amount);\n', '        if (result) {\n', '            WithdrawTokens(msg.sender, wallet, _token, _amount);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function balanceToken(address _token)\n', '    validAddress(_token)\n', '    public \n', '    constant\n', '    returns (uint256 amount) \n', '    {\n', '        return IERC20(_token).balanceOf(address(this));\n', '    }\n', '\n', '    function updAcceptAdminWithdraw(bool _accept)\n', '    onlyOwner\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "acceptAdminWithdraw", acceptAdminWithdraw, _accept);\n', '        acceptAdminWithdraw = _accept;\n', '        return true;\n', '    }\n', '    \n', '    function () \n', '    external \n', '    payable \n', '    {\n', '        if (acceptDonate) {\n', '            donate();\n', '        }\n', '\t}\n', '\n', '    function donate() \n', '    greaterThanZero(msg.value)\n', '    internal \n', '    {\n', '        Donate(msg.sender, msg.value);\n', '    }\n', '\n', '    function updAcceptDonate(bool _accept)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "acceptDonate", acceptDonate, _accept);\n', '        acceptDonate = _accept;\n', '        return true;\n', '    }\n', '}']
