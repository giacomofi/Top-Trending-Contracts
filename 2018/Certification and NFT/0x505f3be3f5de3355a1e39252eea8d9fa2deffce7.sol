['pragma solidity ^0.4.17;\n', '\n', '\n', '/// general helpers.\n', '/// `internal` so they get compiled into contracts using them.\n', 'library Helpers {\n', '    /// returns whether `array` contains `value`.\n', '    function addressArrayContains(address[] array, address value) internal pure returns (bool) {\n', '        for (uint256 i = 0; i < array.length; i++) {\n', '            if (array[i] == value) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // returns the digits of `inputValue` as a string.\n', '    // example: `uintToString(12345678)` returns `"12345678"`\n', '    function uintToString(uint256 inputValue) internal pure returns (string) {\n', '        // figure out the length of the resulting string\n', '        uint256 length = 0;\n', '        uint256 currentValue = inputValue;\n', '        do {\n', '            length++;\n', '            currentValue /= 10;\n', '        } while (currentValue != 0);\n', '        // allocate enough memory\n', '        bytes memory result = new bytes(length);\n', '        // construct the string backwards\n', '        uint256 i = length - 1;\n', '        currentValue = inputValue;\n', '        do {\n', '            result[i--] = byte(48 + currentValue % 10);\n', '            currentValue /= 10;\n', '        } while (currentValue != 0);\n', '        return string(result);\n', '    }\n', '\n', '    /// returns whether signatures (whose components are in `vs`, `rs`, `ss`)\n', '    /// contain `requiredSignatures` distinct correct signatures\n', '    /// where signer is in `allowed_signers`\n', '    /// that signed `message`\n', '    function hasEnoughValidSignatures(bytes message, uint8[] vs, bytes32[] rs, bytes32[] ss, address[] allowed_signers, uint256 requiredSignatures) internal pure returns (bool) {\n', '        // not enough signatures\n', '        if (vs.length < requiredSignatures) {\n', '            return false;\n', '        }\n', '\n', '        var hash = MessageSigning.hashMessage(message);\n', '        var encountered_addresses = new address[](allowed_signers.length);\n', '\n', '        for (uint256 i = 0; i < requiredSignatures; i++) {\n', '            var recovered_address = ecrecover(hash, vs[i], rs[i], ss[i]);\n', '            // only signatures by addresses in `addresses` are allowed\n', '            if (!addressArrayContains(allowed_signers, recovered_address)) {\n', '                return false;\n', '            }\n', '            // duplicate signatures are not allowed\n', '            if (addressArrayContains(encountered_addresses, recovered_address)) {\n', '                return false;\n', '            }\n', '            encountered_addresses[i] = recovered_address;\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '/// Library used only to test Helpers library via rpc calls\n', 'library HelpersTest {\n', '    function addressArrayContains(address[] array, address value) public pure returns (bool) {\n', '        return Helpers.addressArrayContains(array, value);\n', '    }\n', '\n', '    function uintToString(uint256 inputValue) public pure returns (string str) {\n', '        return Helpers.uintToString(inputValue);\n', '    }\n', '\n', '    function hasEnoughValidSignatures(bytes message, uint8[] vs, bytes32[] rs, bytes32[] ss, address[] addresses, uint256 requiredSignatures) public pure returns (bool) {\n', '        return Helpers.hasEnoughValidSignatures(message, vs, rs, ss, addresses, requiredSignatures);\n', '    }\n', '}\n', '\n', '\n', '// helpers for message signing.\n', '// `internal` so they get compiled into contracts using them.\n', 'library MessageSigning {\n', '    function recoverAddressFromSignedMessage(bytes signature, bytes message) internal pure returns (address) {\n', '        require(signature.length == 65);\n', '        bytes32 r;\n', '        bytes32 s;\n', '        bytes1 v;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := mload(add(signature, 0x60))\n', '        }\n', '        return ecrecover(hashMessage(message), uint8(v), r, s);\n', '    }\n', '\n', '    function hashMessage(bytes message) internal pure returns (bytes32) {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n";\n', '        return keccak256(prefix, Helpers.uintToString(message.length), message);\n', '    }\n', '}\n', '\n', '\n', '/// Library used only to test MessageSigning library via rpc calls\n', 'library MessageSigningTest {\n', '    function recoverAddressFromSignedMessage(bytes signature, bytes message) public pure returns (address) {\n', '        return MessageSigning.recoverAddressFromSignedMessage(signature, message);\n', '    }\n', '}\n', '\n', '\n', 'library Message {\n', '    // layout of message :: bytes:\n', '    // offset  0: 32 bytes :: uint256 (big endian) - message length (not part of message. any `bytes` begins with the length in memory)\n', '    // offset 32: 20 bytes :: address - recipient address\n', '    // offset 52: 32 bytes :: uint256 (big endian) - value\n', '    // offset 84: 32 bytes :: bytes32 - transaction hash\n', '    // offset 116: 32 bytes :: uint256 (big endian) - main gas price\n', '\n', '    // mload always reads 32 bytes.\n', '    // if mload reads an address it only interprets the last 20 bytes as the address.\n', '    // so we can and have to start reading recipient at offset 20 instead of 32.\n', '    // if we were to read at 32 the address would contain part of value and be corrupted.\n', '    // when reading from offset 20 mload will ignore 12 bytes followed\n', '    // by the 20 recipient address bytes and correctly convert it into an address.\n', '    // this saves some storage/gas over the alternative solution\n', '    // which is padding address to 32 bytes and reading recipient at offset 32.\n', '    // for more details see discussion in:\n', '    // https://github.com/paritytech/parity-bridge/issues/61\n', '\n', '    function getRecipient(bytes message) internal pure returns (address) {\n', '        address recipient;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            recipient := mload(add(message, 20))\n', '        }\n', '        return recipient;\n', '    }\n', '\n', '    function getValue(bytes message) internal pure returns (uint256) {\n', '        uint256 value;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            value := mload(add(message, 52))\n', '        }\n', '        return value;\n', '    }\n', '\n', '    function getTransactionHash(bytes message) internal pure returns (bytes32) {\n', '        bytes32 hash;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            hash := mload(add(message, 84))\n', '        }\n', '        return hash;\n', '    }\n', '\n', '    function getMainGasPrice(bytes message) internal pure returns (uint256) {\n', '        uint256 gasPrice;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            gasPrice := mload(add(message, 116))\n', '        }\n', '        return gasPrice;\n', '    }\n', '}\n', '\n', '\n', '/// Library used only to test Message library via rpc calls\n', 'library MessageTest {\n', '    function getRecipient(bytes message) public pure returns (address) {\n', '        return Message.getRecipient(message);\n', '    }\n', '\n', '    function getValue(bytes message) public pure returns (uint256) {\n', '        return Message.getValue(message);\n', '    }\n', '\n', '    function getTransactionHash(bytes message) public pure returns (bytes32) {\n', '        return Message.getTransactionHash(message);\n', '    }\n', '\n', '    function getMainGasPrice(bytes message) public pure returns (uint256) {\n', '        return Message.getMainGasPrice(message);\n', '    }\n', '}\n', '\n', '\n', 'contract MainBridge {\n', '    /// Number of authorities signatures required to withdraw the money.\n', '    ///\n', '    /// Must be lesser than number of authorities.\n', '    uint256 public requiredSignatures;\n', '\n', '    /// The gas cost of calling `MainBridge.withdraw`.\n', '    ///\n', '    /// Is subtracted from `value` on withdraw.\n', '    /// recipient pays the relaying authority for withdraw.\n', '    /// this shuts down attacks that exhaust authorities funds on main chain.\n', '    uint256 public estimatedGasCostOfWithdraw;\n', '\n', '    /// reject deposits that would increase `this.balance` beyond this value.\n', '    /// security feature:\n', '    /// limits the total amount of mainnet ether that can be lost\n', '    /// if the bridge is faulty or compromised in any way!\n', '    /// set to 0 to disable.\n', '    uint256 public maxTotalMainContractBalance;\n', '\n', '    /// reject deposits whose `msg.value` is higher than this value.\n', '    /// security feature.\n', '    /// set to 0 to disable.\n', '    uint256 public maxSingleDepositValue;\n', '\n', '    /// Contract authorities.\n', '    address[] public authorities;\n', '\n', '    /// Used side transaction hashes.\n', '    mapping (bytes32 => bool) public withdraws;\n', '\n', '    /// Event created on money deposit.\n', '    event Deposit (address recipient, uint256 value);\n', '\n', '    /// Event created on money withdraw.\n', '    event Withdraw (address recipient, uint256 value, bytes32 transactionHash);\n', '\n', '    /// Constructor.\n', '    function MainBridge(\n', '        uint256 requiredSignaturesParam,\n', '        address[] authoritiesParam,\n', '        uint256 estimatedGasCostOfWithdrawParam,\n', '        uint256 maxTotalMainContractBalanceParam,\n', '        uint256 maxSingleDepositValueParam\n', '    ) public\n', '    {\n', '        require(requiredSignaturesParam != 0);\n', '        require(requiredSignaturesParam <= authoritiesParam.length);\n', '        requiredSignatures = requiredSignaturesParam;\n', '        authorities = authoritiesParam;\n', '        estimatedGasCostOfWithdraw = estimatedGasCostOfWithdrawParam;\n', '        maxTotalMainContractBalance = maxTotalMainContractBalanceParam;\n', '        maxSingleDepositValue = maxSingleDepositValueParam;\n', '    }\n', '\n', '    /// Should be used to deposit money.\n', '    function () public payable {\n', '        require(maxSingleDepositValue == 0 || msg.value <= maxSingleDepositValue);\n', '        // the value of `this.balance` in payable methods is increased\n', '        // by `msg.value` before the body of the payable method executes\n', '        require(maxTotalMainContractBalance == 0 || this.balance <= maxTotalMainContractBalance);\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /// Called by the bridge node processes on startup\n', '    /// to determine early whether the address pointing to the main\n', '    /// bridge contract is misconfigured.\n', '    /// so we can provide a helpful error message instead of the very\n', '    /// unhelpful errors encountered otherwise.\n', '    function isMainBridgeContract() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /// final step of a withdraw.\n', '    /// checks that `requiredSignatures` `authorities` have signed of on the `message`.\n', '    /// then transfers `value` to `recipient` (both extracted from `message`).\n', '    /// see message library above for a breakdown of the `message` contents.\n', '    /// `vs`, `rs`, `ss` are the components of the signatures.\n', '\n', '    /// anyone can call this, provided they have the message and required signatures!\n', '    /// only the `authorities` can create these signatures.\n', '    /// `requiredSignatures` authorities can sign arbitrary `message`s\n', '    /// transfering any ether `value` out of this contract to `recipient`.\n', '    /// bridge users must trust a majority of `requiredSignatures` of the `authorities`.\n', '    function withdraw(uint8[] vs, bytes32[] rs, bytes32[] ss, bytes message) public {\n', '        require(message.length == 116);\n', '\n', '        // check that at least `requiredSignatures` `authorities` have signed `message`\n', '        require(Helpers.hasEnoughValidSignatures(message, vs, rs, ss, authorities, requiredSignatures));\n', '\n', '        address recipient = Message.getRecipient(message);\n', '        uint256 value = Message.getValue(message);\n', '        bytes32 hash = Message.getTransactionHash(message);\n', '        uint256 mainGasPrice = Message.getMainGasPrice(message);\n', '\n', '        // if the recipient calls `withdraw` they can choose the gas price freely.\n', '        // if anyone else calls `withdraw` they have to use the gas price\n', '        // `mainGasPrice` specified by the user initiating the withdraw.\n', '        // this is a security mechanism designed to shut down\n', '        // malicious senders setting extremely high gas prices\n', '        // and effectively burning recipients withdrawn value.\n', '        // see https://github.com/paritytech/parity-bridge/issues/112\n', '        // for further explanation.\n', '        require((recipient == msg.sender) || (tx.gasprice == mainGasPrice));\n', '\n', '        // The following two statements guard against reentry into this function.\n', '        // Duplicated withdraw or reentry.\n', '        require(!withdraws[hash]);\n', '        // Order of operations below is critical to avoid TheDAO-like re-entry bug\n', '        withdraws[hash] = true;\n', '\n', '        uint256 estimatedWeiCostOfWithdraw = estimatedGasCostOfWithdraw * mainGasPrice;\n', '\n', '        // charge recipient for relay cost\n', '        uint256 valueRemainingAfterSubtractingCost = value - estimatedWeiCostOfWithdraw;\n', '\n', '        // pay out recipient\n', '        recipient.transfer(valueRemainingAfterSubtractingCost);\n', '\n', '        // refund relay cost to relaying authority\n', '        msg.sender.transfer(estimatedWeiCostOfWithdraw);\n', '\n', '        Withdraw(recipient, valueRemainingAfterSubtractingCost, hash);\n', '    }\n', '}\n', '\n', '\n', 'contract SideBridge {\n', '    // following is the part of SideBridge that implements an ERC20 token.\n', '    // ERC20 spec: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '\n', '    uint256 public totalSupply;\n', '\n', '    string public name = "SideBridge";\n', '    // BETH = bridged ether\n', '    string public symbol = "BETH";\n', '    // 1-1 mapping of ether to tokens\n', '    uint8 public decimals = 18;\n', '\n', '    /// maps addresses to their token balances\n', '    mapping (address => uint256) public balances;\n', '\n', '    // owner of account approves the transfer of an amount by another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /// Event created on money transfer\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '\n', '    // returns the ERC20 token balance of the given address\n', '    function balanceOf(address tokenOwner) public view returns (uint256) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    /// Transfer `value` to `recipient` on this `side` chain.\n', '    ///\n', '    /// does not affect `main` chain. does not do a relay.\n', "    /// as specificed in ERC20 this doesn't fail if tokens == 0.\n", '    function transfer(address recipient, uint256 tokens) public returns (bool) {\n', '        require(balances[msg.sender] >= tokens);\n', '        // fails if there is an overflow\n', '        require(balances[recipient] + tokens >= balances[recipient]);\n', '\n', '        balances[msg.sender] -= tokens;\n', '        balances[recipient] += tokens;\n', '        Transfer(msg.sender, recipient, tokens);\n', '        return true;\n', '    }\n', '\n', '    // following is the part of SideBridge that is concerned\n', '    // with the part of the ERC20 standard responsible for giving others spending rights\n', '    // and spending others tokens\n', '\n', '    // created when `approve` is executed to mark that\n', '    // `tokenOwner` has approved `spender` to spend `tokens` of his tokens\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '\n', '    // allow `spender` to withdraw from your account, multiple times, up to the `tokens` amount.\n', '    // calling this function repeatedly overwrites the current allowance.\n', '    function approve(address spender, uint256 tokens) public returns (bool) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // returns how much `spender` is allowed to spend of `owner`s tokens\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool) {\n', '        // `from` has enough tokens\n', '        require(balances[from] >= tokens);\n', '        // `sender` is allowed to move `tokens` from `from`\n', '        require(allowed[from][msg.sender] >= tokens);\n', '        // fails if there is an overflow\n', '        require(balances[to] + tokens >= balances[to]);\n', '\n', '        balances[to] += tokens;\n', '        balances[from] -= tokens;\n', '        allowed[from][msg.sender] -= tokens;\n', '\n', '        Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // following is the part of SideBridge that is\n', '    // no longer part of ERC20 and is concerned with\n', '    // with moving tokens from and to MainBridge\n', '\n', '    struct SignaturesCollection {\n', '        /// Signed message.\n', '        bytes message;\n', '        /// Authorities who signed the message.\n', '        address[] authorities;\n', '        /// Signatures\n', '        bytes[] signatures;\n', '    }\n', '\n', '    /// Number of authorities signatures required to withdraw the money.\n', '    ///\n', '    /// Must be less than number of authorities.\n', '    uint256 public requiredSignatures;\n', '\n', '    uint256 public estimatedGasCostOfWithdraw;\n', '\n', '    /// Contract authorities.\n', '    address[] public authorities;\n', '\n', '    /// Pending deposits and authorities who confirmed them\n', '    mapping (bytes32 => address[]) deposits;\n', '\n', '    /// Pending signatures and authorities who confirmed them\n', '    mapping (bytes32 => SignaturesCollection) signatures;\n', '\n', '    /// triggered when an authority confirms a deposit\n', '    event DepositConfirmation(address recipient, uint256 value, bytes32 transactionHash);\n', '\n', '    /// triggered when enough authorities have confirmed a deposit\n', '    event Deposit(address recipient, uint256 value, bytes32 transactionHash);\n', '\n', '    /// Event created on money withdraw.\n', '    event Withdraw(address recipient, uint256 value, uint256 mainGasPrice);\n', '\n', '    event WithdrawSignatureSubmitted(bytes32 messageHash);\n', '\n', '    /// Collected signatures which should be relayed to main chain.\n', '    event CollectedSignatures(address indexed authorityResponsibleForRelay, bytes32 messageHash);\n', '\n', '    function SideBridge(\n', '        uint256 _requiredSignatures,\n', '        address[] _authorities,\n', '        uint256 _estimatedGasCostOfWithdraw\n', '    ) public\n', '    {\n', '        require(_requiredSignatures != 0);\n', '        require(_requiredSignatures <= _authorities.length);\n', '        requiredSignatures = _requiredSignatures;\n', '        authorities = _authorities;\n', '        estimatedGasCostOfWithdraw = _estimatedGasCostOfWithdraw;\n', '    }\n', '\n', '    // Called by the bridge node processes on startup\n', '    // to determine early whether the address pointing to the side\n', '    // bridge contract is misconfigured.\n', '    // so we can provide a helpful error message instead of the\n', '    // very unhelpful errors encountered otherwise.\n', '    function isSideBridgeContract() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /// require that sender is an authority\n', '    modifier onlyAuthority() {\n', '        require(Helpers.addressArrayContains(authorities, msg.sender));\n', '        _;\n', '    }\n', '\n', '    /// Used to deposit money to the contract.\n', '    ///\n', '    /// deposit recipient (bytes20)\n', '    /// deposit value (uint256)\n', '    /// mainnet transaction hash (bytes32) // to avoid transaction duplication\n', '    function deposit(address recipient, uint256 value, bytes32 transactionHash) public onlyAuthority() {\n', '        // Protection from misbehaving authority\n', '        var hash = keccak256(recipient, value, transactionHash);\n', '\n', "        // don't allow authority to confirm deposit twice\n", '        require(!Helpers.addressArrayContains(deposits[hash], msg.sender));\n', '\n', '        deposits[hash].push(msg.sender);\n', '\n', '        // TODO: this may cause troubles if requiredSignatures len is changed\n', '        if (deposits[hash].length != requiredSignatures) {\n', '            DepositConfirmation(recipient, value, transactionHash);\n', '            return;\n', '        }\n', '\n', '        balances[recipient] += value;\n', '        // mints tokens\n', '        totalSupply += value;\n', '        // ERC20 specifies: a token contract which creates new tokens\n', '        // SHOULD trigger a Transfer event with the _from address\n', '        // set to 0x0 when tokens are created.\n', '        Transfer(0x0, recipient, value);\n', '        Deposit(recipient, value, transactionHash);\n', '    }\n', '\n', '    /// Transfer `value` from `msg.sender`s local balance (on `side` chain) to `recipient` on `main` chain.\n', '    ///\n', '    /// immediately decreases `msg.sender`s local balance.\n', '    /// emits a `Withdraw` event which will be picked up by the bridge authorities.\n', '    /// bridge authorities will then sign off (by calling `submitSignature`) on a message containing `value`,\n', '    /// `recipient` and the `hash` of the transaction on `side` containing the `Withdraw` event.\n', '    /// once `requiredSignatures` are collected a `CollectedSignatures` event will be emitted.\n', '    /// an authority will pick up `CollectedSignatures` an call `MainBridge.withdraw`\n', '    /// which transfers `value - relayCost` to `recipient` completing the transfer.\n', '    function transferToMainViaRelay(address recipient, uint256 value, uint256 mainGasPrice) public {\n', '        require(balances[msg.sender] >= value);\n', "        // don't allow 0 value transfers to main\n", '        require(value > 0);\n', '\n', '        uint256 estimatedWeiCostOfWithdraw = estimatedGasCostOfWithdraw * mainGasPrice;\n', '        require(value > estimatedWeiCostOfWithdraw);\n', '\n', '        balances[msg.sender] -= value;\n', '        // burns tokens\n', '        totalSupply -= value;\n', '        // in line with the transfer event from `0x0` on token creation\n', '        // recommended by ERC20 (see implementation of `deposit` above)\n', '        // we trigger a Transfer event to `0x0` on token destruction\n', '        Transfer(msg.sender, 0x0, value);\n', '        Withdraw(recipient, value, mainGasPrice);\n', '    }\n', '\n', '    /// Should be used as sync tool\n', '    ///\n', '    /// Message is a message that should be relayed to main chain once authorities sign it.\n', '    ///\n', '    /// for withdraw message contains:\n', '    /// withdrawal recipient (bytes20)\n', '    /// withdrawal value (uint256)\n', '    /// side transaction hash (bytes32) // to avoid transaction duplication\n', '    function submitSignature(bytes signature, bytes message) public onlyAuthority() {\n', '        // ensure that `signature` is really `message` signed by `msg.sender`\n', '        require(msg.sender == MessageSigning.recoverAddressFromSignedMessage(signature, message));\n', '\n', '        require(message.length == 116);\n', '        var hash = keccak256(message);\n', '\n', '        // each authority can only provide one signature per message\n', '        require(!Helpers.addressArrayContains(signatures[hash].authorities, msg.sender));\n', '        signatures[hash].message = message;\n', '        signatures[hash].authorities.push(msg.sender);\n', '        signatures[hash].signatures.push(signature);\n', '\n', '        // TODO: this may cause troubles if requiredSignatures len is changed\n', '        if (signatures[hash].authorities.length == requiredSignatures) {\n', '            CollectedSignatures(msg.sender, hash);\n', '        } else {\n', '            WithdrawSignatureSubmitted(hash);\n', '        }\n', '    }\n', '\n', '    function hasAuthoritySignedMainToSide(address authority, address recipient, uint256 value, bytes32 mainTxHash) public view returns (bool) {\n', '        var hash = keccak256(recipient, value, mainTxHash);\n', '\n', '        return Helpers.addressArrayContains(deposits[hash], authority);\n', '    }\n', '\n', '    function hasAuthoritySignedSideToMain(address authority, bytes message) public view returns (bool) {\n', '        require(message.length == 116);\n', '        var messageHash = keccak256(message);\n', '        return Helpers.addressArrayContains(signatures[messageHash].authorities, authority);\n', '    }\n', '\n', '    /// Get signature\n', '    function signature(bytes32 messageHash, uint256 index) public view returns (bytes) {\n', '        return signatures[messageHash].signatures[index];\n', '    }\n', '\n', '    /// Get message\n', '    function message(bytes32 message_hash) public view returns (bytes) {\n', '        return signatures[message_hash].message;\n', '    }\n', '}']