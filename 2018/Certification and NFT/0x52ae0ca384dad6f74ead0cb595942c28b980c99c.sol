['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath\n', '{\n', '    function mul(uint256 a, uint256 b) internal pure\n', '    returns (uint256)\n', '    {\n', '        uint256 c = a * b;\n', '\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure\n', '    returns (uint256)\n', '    {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure\n', '    returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure\n', '    returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface ERC20\n', '{\n', '    function totalSupply() view external returns (uint _totalSupply);\n', '    function balanceOf(address _owner) view external returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) view external returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract LynchpinToken is ERC20\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    string  public name        = "Lynchpin";\n', '    string  public symbol      = "LYN";\n', '    uint8   public decimals    = 18;\n', '    uint    public totalSupply = 5000000 * (10 ** uint(decimals));\n', '    address public owner       = 0xAc983022185b95eF2B2C7219143483BD0C65Ecda;\n', '\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '\n', '    constructor() public\n', '    {\n', '        balanceOf[owner] = totalSupply;\n', '    }\n', '\n', '    function totalSupply() view external returns (uint _totalSupply)\n', '    {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) view external returns (uint balance)\n', '    {\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) view external returns (uint remaining)\n', '    {\n', '        return allowance[_owner][_spender];\n', '    }\n', '    function _transfer(address _from, address _to, uint _value) internal\n', '    {\n', '        require(_to != 0x0);\n', '\n', '        uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success)\n', '    {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\n', '    {\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success)\n', '    {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // disallow incoming ether to this contract\n', '    function () public\n', '    {\n', '        revert();\n', '    }\n', '}\n', '\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor(address _owner) public\n', '    {\n', '        owner = _owner;\n', '    }\n', '\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner\n', '    {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract LynchpinPublicICO is Ownable(0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba)\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    LynchpinToken public lynT = LynchpinToken(0xB0B1685f55843D03739c7D9b0A230F1B7DcF03D5);\n', '    address public beneficiary = 0x1788A2Fe89a3Bfa58DB57aabbf1Ffa08ADED6cba;\n', '\n', '    uint256 public tokeninOneEther;\n', '    uint256 public maxTokensToSell = 2000000 * 10**18;\n', '    uint256 public tokenSold;\n', '    bool crowdsaleClosed = false;\n', '\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    event LogAddedToWhitelist(address indexed _contributor);\n', '    event LogTokenRateUpdated(uint256 _newRate);\n', '    event LogSaleClosed();\n', '\n', '    constructor(uint256 _tokeninOneEther) public\n', '    {\n', '        require (_tokeninOneEther > 0);\n', '        isWhitelisted[owner] = true;\n', '        tokeninOneEther = _tokeninOneEther;\n', '        emit LogTokenRateUpdated(_tokeninOneEther);\n', '    }\n', '\n', '    function () public payable\n', '    {\n', '        require(!crowdsaleClosed);\n', '        require(isWhitelisted[msg.sender]);\n', '\n', '        uint256 amountToSend = msg.value * tokeninOneEther;\n', '\n', '        require (tokenSold.add(amountToSend) <= maxTokensToSell);\n', '\n', '        lynT.transfer(msg.sender, amountToSend);\n', '        tokenSold += amountToSend;\n', '    }\n', '\n', '    function addContributor(address _contributor) external onlyOwner\n', '    {\n', '        require(_contributor != address(0));\n', '        require(!isWhitelisted[_contributor]);\n', '        isWhitelisted[_contributor] = true;\n', '        emit LogAddedToWhitelist(_contributor);\n', '    }\n', '\n', '    function updateTokenRate(uint256 _tokeninOneEther ) external onlyOwner\n', '    {\n', '        require (_tokeninOneEther > 0);\n', '        tokeninOneEther = _tokeninOneEther;\n', '        emit LogTokenRateUpdated(_tokeninOneEther);\n', '    }\n', '\n', '    function closeSale() external onlyOwner\n', '    {\n', '        lynT.transfer(msg.sender, lynT.balanceOf(address(this)));\n', '        beneficiary.transfer(address(this).balance);\n', '        crowdsaleClosed = true;\n', '        emit LogSaleClosed();\n', '    }\n', '}']