['pragma solidity ^0.4.13;\n', '\n', 'contract HexBoard3 {\n', '\n', '  // To ease iteration\n', '  uint8 constant public minTileId= 1;\n', '  uint8 constant public maxTileId = 19;\n', '  uint8 constant public numTiles = 19;\n', '\n', '  // Any 0s in the neighbor array represent non-neighbors. There might be a better way to do this, but w/e\n', '  mapping(uint8 => uint8[6]) public tileToNeighbors;\n', '  uint8 constant public nullNeighborValue = 0;\n', '\n', '  // TODO: Add neighbor calculation in if we want to use neighbors in jackpot calculation\n', '  constructor() public {\n', '  }\n', '}\n', '\n', 'contract JackpotRules {\n', '  using SafeMath for uint256;\n', '\n', '  constructor() public {}\n', '\n', '  // NOTE: The next methods *must* add up to 100%\n', '\n', '  // 50%\n', '  function _winnerJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(2);\n', '  }\n', '\n', '  // 40%\n', '  function _landholderJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return (jackpot.mul(2)).div(5);\n', '  }\n', '\n', '  // 5%\n', '  function _nextPotJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(20);\n', '  }\n', '\n', '  // 5%\n', '  function _teamJackpot(uint256 jackpot) public pure returns (uint256) {\n', '    return jackpot.div(20);\n', '  }\n', '}\n', '\n', 'library Math {\n', '  /**\n', '  * @dev Returns the largest of two numbers.\n', '  */\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * @dev Returns the smallest of two numbers.\n', '  */\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  /**\n', '  * @dev Calculates the average of two numbers. Since these are integers,\n', '  * averages of an even and odd number cannot be represented, and will be\n', '  * rounded down.\n', '  */\n', '  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // (a + b) / 2 can overflow, so we distribute\n', '    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract PullPayment {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public payments;\n', '    uint256 public totalPayments;\n', '\n', '    /**\n', '     * @dev Withdraw accumulated balance, called by payee.\n', '     */\n', '    function withdrawPayments() public {\n', '        address payee = msg.sender;\n', '        uint256 payment = payments[payee];\n', '\n', '        require(payment != 0);\n', '        require(address(this).balance >= payment);\n', '\n', '        totalPayments = totalPayments.sub(payment);\n', '        payments[payee] = 0;\n', '\n', '        payee.transfer(payment);\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the payer to store the sent amount as credit to be pulled.\n', '     * @param dest The destination address of the funds.\n', '     * @param amount The amount to transfer.\n', '     */\n', '    function asyncSend(address dest, uint256 amount) internal {\n', '        payments[dest] = payments[dest].add(amount);\n', '        totalPayments = totalPayments.add(amount);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract TaxRules {\n', '    using SafeMath for uint256;\n', '\n', '    constructor() public {}\n', '\n', '    // 10%\n', '    function _priceToTax(uint256 price) public pure returns (uint256) {\n', '        return price.div(10);\n', '    }\n', '\n', '    // NOTE: The next methods *must* add up to 100%\n', '\n', '    // 40%\n', '    function _jackpotTax(uint256 tax) public pure returns (uint256) {\n', '        return (tax.mul(2)).div(5);\n', '    }\n', '\n', '    // 38%\n', '    function _totalLandholderTax(uint256 tax) public pure returns (uint256) {\n', '        return (tax.mul(19)).div(50);\n', '    }\n', '\n', '    // 17%/12%\n', '    function _teamTax(uint256 tax, bool hasReferrer) public pure returns (uint256) {\n', '        if (hasReferrer) {\n', '            return (tax.mul(3)).div(25);\n', '        } else {\n', '            return (tax.mul(17)).div(100);\n', '        }\n', '    }\n', '\n', '    // 5% although only invoked if _teamTax is lower value\n', '    function _referrerTax(uint256 tax, bool hasReferrer)  public pure returns (uint256) {\n', '        if (hasReferrer) {\n', '            return tax.div(20);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // 5%\n', '    function _nextPotTax(uint256 tax) public pure returns (uint256) {\n', '        return tax.div(20);\n', '    }\n', '}\n', '\n', 'contract Microverse is\n', '    HexBoard3,\n', '    PullPayment,\n', '    Ownable,\n', '    TaxRules,\n', '    JackpotRules {\n', '    using SafeMath for uint256;\n', '    using Math for uint256;\n', '\n', '    // states this contract progresses through\n', '    enum Stage {\n', '        DutchAuction,\n', '        GameRounds\n', '    }\n', '    Stage public stage = Stage.DutchAuction;\n', '\n', '    modifier atStage(Stage _stage) {\n', '        require(\n', '            stage == _stage,\n', '            "Function cannot be called at this time."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // NOTE: stage arg for debugging purposes only! Should just be set to 0 by default\n', '    constructor(uint startingStage) public {\n', '        if (startingStage == uint(Stage.GameRounds)) {\n', '            stage = Stage.GameRounds;\n', '            _startGameRound();\n', '        } else {\n', '            _startAuction();\n', '        }\n', '    }\n', '\n', '    mapping(uint8 => address) public tileToOwner;\n', '    mapping(uint8 => uint256) public tileToPrice;\n', '    uint256 public totalTileValue;\n', '\n', '    function _changeTilePrice(uint8 tileId, uint256 newPrice) private {\n', '        uint256 oldPrice = tileToPrice[tileId];\n', '        tileToPrice[tileId] = newPrice;\n', '        totalTileValue = (totalTileValue.sub(oldPrice)).add(newPrice);\n', '    }\n', '\n', '    event TileOwnerChanged(\n', '        uint8 indexed tileId,\n', '        address indexed oldOwner,\n', '        address indexed newOwner,\n', '        uint256 oldPrice,\n', '        uint256 newPrice\n', '    );\n', '\n', '    /////////////\n', '    // Team stuff\n', '    /////////////\n', '\n', '    // The muscle behind microverse\n', '    address public teamAddress1 = 0xcB46219bA114245c3A18761E4f7891f9C4BeF8c0;\n', '    address public teamAddress2 = 0xF2AFb5c2D205B36F22BE528A1300393B1C399E79;\n', '    address public teamAddress3 = 0x22FC59B3878F0Aa2e43F7f3388c1e20D83Cf8ba2;\n', '\n', '    function _sendToTeam(uint256 amount) private {\n', '        uint256 perTeamMemberFee = amount.div(3);\n', '\n', '        asyncSend(teamAddress1, perTeamMemberFee);\n', '        asyncSend(teamAddress2, perTeamMemberFee);\n', '        asyncSend(teamAddress3, perTeamMemberFee);\n', '    }\n', '\n', '    function withdrawContractBalance() external onlyOwner {\n', '        uint256 contractBalance = address(this).balance;\n', '        uint256 withdrawableBalance = contractBalance.sub(totalPayments);\n', '\n', '        // No withdrawal necessary if <= 0 balance\n', '        require(withdrawableBalance > 0);\n', '\n', '        asyncSend(msg.sender, withdrawableBalance);\n', '    }\n', '\n', '    //////////\n', '    // Auction\n', '    //////////\n', '\n', '    event AuctionStarted(\n', '        uint256 startingAuctionPrice,\n', '        uint256 endingAuctionPrice,\n', '        uint256 auctionDuration,\n', '        uint256 startTime\n', '    );\n', '\n', '    event AuctionEnded(\n', '        uint256 endTime\n', '    );\n', '\n', '    uint256 constant public startingAuctionPrice = 1 ether;\n', '    uint256 constant public endingAuctionPrice = 0.05 ether;\n', '    uint256 constant public auctionDuration = 5 days; // period over which land price decreases linearly\n', '\n', '    uint256 public numBoughtTiles;\n', '    uint256 public auctionStartTime;\n', '\n', '    function buyTileAuction(uint8 tileId, uint256 newPrice, address referrer) public payable atStage(Stage.DutchAuction) {\n', '        require(\n', '            tileToOwner[tileId] == address(0) && tileToPrice[tileId] == 0,\n', '            "Can\'t buy a tile that\'s already been auctioned off"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '        uint256 price = getTilePriceAuction();\n', '\n', '        require(\n', '            msg.value >= tax.add(price),\n', '            "Must pay the full price and tax for a tile on auction"\n', '        );\n', '\n', '        // NOTE: *entire* payment distributed as Game taxes\n', '        _distributeAuctionTax(msg.value, referrer);\n', '\n', '        tileToOwner[tileId] = msg.sender;\n', '        _changeTilePrice(tileId, newPrice);\n', '\n', '        numBoughtTiles = numBoughtTiles.add(1);\n', '\n', '        emit TileOwnerChanged(tileId, address(0), msg.sender, price, newPrice);\n', '\n', '        if (numBoughtTiles >= numTiles) {\n', '            endAuction();\n', '        }\n', '    }\n', '\n', '    // NOTE: Some common logic with _distributeTax\n', '    function _distributeAuctionTax(uint256 tax, address referrer) private {\n', '        _distributeLandholderTax(_totalLandholderTax(tax));\n', '\n', "        // NOTE: Because no notion of 'current jackpot', everything added to next pot\n", '        uint256 totalJackpotTax = _jackpotTax(tax).add(_nextPotTax(tax));\n', '        nextJackpot = nextJackpot.add(totalJackpotTax);\n', '\n', '        // NOTE: referrer tax comes out of dev team tax\n', '        bool hasReferrer = referrer != address(0);\n', '        _sendToTeam(_teamTax(tax, hasReferrer));\n', '        asyncSend(referrer, _referrerTax(tax, hasReferrer));\n', '    }\n', '\n', '    function getTilePriceAuction() public view atStage(Stage.DutchAuction) returns (uint256) {\n', '        uint256 secondsPassed = 0;\n', '\n', '        // This should always be the case...\n', '        if (now > auctionStartTime) {\n', '            secondsPassed = now.sub(auctionStartTime);\n', '        }\n', '\n', '        if (secondsPassed >= auctionDuration) {\n', '            return endingAuctionPrice;\n', '        } else {\n', '            uint256 maxPriceDelta = startingAuctionPrice.sub(endingAuctionPrice);\n', '            uint256 actualPriceDelta = (maxPriceDelta.mul(secondsPassed)).div(auctionDuration);\n', '\n', '            return startingAuctionPrice.sub(actualPriceDelta);\n', '        }\n', '    }\n', '\n', '    function endAuction() private {\n', '        require(\n', '            numBoughtTiles >= numTiles,\n', '            "Can\'t end auction if are unbought tiles"\n', '        );\n', '\n', '        stage = Stage.GameRounds;\n', '        _startGameRound();\n', '\n', '        emit AuctionEnded(now);\n', '    }\n', '\n', '    function _startAuction() private {\n', '        auctionStartTime = now;\n', '        numBoughtTiles = 0;\n', '\n', '        emit AuctionStarted(startingAuctionPrice,\n', '                            endingAuctionPrice,\n', '                            auctionDuration,\n', '                            auctionStartTime);\n', '    }\n', '\n', '    ///////\n', '    // Game\n', '    ///////\n', '\n', '    uint256 constant public startingRoundExtension = 12 hours;\n', '    uint256 constant public halvingVolume = 10 ether; // tx volume before next duration halving\n', '    uint256 constant public minRoundExtension = 10 seconds; // could set to 1 second\n', '\n', '    uint256 public roundNumber = 0;\n', '\n', '    uint256 public curExtensionVolume;\n', '    uint256 public curRoundExtension;\n', '\n', '    uint256 public roundEndTime;\n', '\n', '    uint256 public jackpot;\n', '    uint256 public nextJackpot;\n', '\n', "    // Only emitted if owner doesn't *also* change\n", '    event TilePriceChanged(\n', '        uint8 indexed tileId,\n', '        address indexed owner,\n', '        uint256 oldPrice,\n', '        uint256 newPrice\n', '    );\n', '\n', '    event GameRoundStarted(\n', '        uint256 initJackpot,\n', '        uint256 endTime,\n', '        uint256 roundNumber\n', '    );\n', '\n', '    event GameRoundExtended(\n', '        uint256 endTime\n', '    );\n', '\n', '    event GameRoundEnded(\n', '        uint256 jackpot\n', '    );\n', '\n', '    ////////////////////////////////////\n', '    // [Game] Round extension management\n', '    ////////////////////////////////////\n', '\n', '    function roundTimeRemaining() public view atStage(Stage.GameRounds) returns (uint256)  {\n', '        if (_roundOver()) {\n', '            return 0;\n', '        } else {\n', '            return roundEndTime.sub(now);\n', '        }\n', '    }\n', '\n', '    function _extendRound() private {\n', '        roundEndTime = roundEndTime.max(now.add(curRoundExtension));\n', '\n', '        emit GameRoundExtended(roundEndTime);\n', '    }\n', '\n', '    function _startGameRound() private {\n', '        curExtensionVolume = 0 ether;\n', '        curRoundExtension = startingRoundExtension;\n', '\n', '        jackpot = nextJackpot;\n', '        nextJackpot = 0;\n', '\n', '        roundNumber = roundNumber.add(1);\n', '\n', '        _extendRound();\n', '\n', '        emit GameRoundStarted(jackpot, roundEndTime, roundNumber);\n', '    }\n', '\n', '    function _roundOver() private view returns (bool) {\n', '        return now >= roundEndTime;\n', '    }\n', '\n', '    modifier duringRound() {\n', '        require(\n', '            !_roundOver(),\n', '            "Round can\'t be over!"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // NOTE: Must be called for all volume we want to count towards round extension halving\n', '    function _logRoundExtensionVolume(uint256 amount) private {\n', '        curExtensionVolume = curExtensionVolume.add(amount);\n', '\n', '        if (curExtensionVolume >= halvingVolume) {\n', '            curRoundExtension = curRoundExtension.div(2).max(minRoundExtension);\n', '            curExtensionVolume = 0 ether;\n', '        }\n', '    }\n', '\n', '    ////////////////////////\n', '    // [Game] Player actions\n', '    ////////////////////////\n', '\n', '    function endGameRound() public atStage(Stage.GameRounds) {\n', '        require(\n', '            _roundOver(),\n', '            "Round must be over!"\n', '        );\n', '\n', '        _distributeJackpot();\n', '\n', '        emit GameRoundEnded(jackpot);\n', '\n', '        _startGameRound();\n', '    }\n', '\n', '    function setTilePrice(uint8 tileId, uint256 newPrice, address referrer)\n', '        public\n', '        payable\n', '        atStage(Stage.GameRounds)\n', '        duringRound {\n', '        require(\n', '            tileToOwner[tileId] == msg.sender,\n', '            "Can\'t set tile price for a tile you don\'t own!"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '\n', '        require(\n', '            msg.value >= tax,\n', '            "Must pay tax on new tile price!"\n', '        );\n', '\n', '        uint256 oldPrice = tileToPrice[tileId];\n', '        _distributeTax(msg.value, referrer);\n', '        _changeTilePrice(tileId, newPrice);\n', '\n', "        // NOTE: Currently we extend round for 'every' tile price change. Alternatively could do only on\n", '        // increases or decreases or changes exceeding some magnitude\n', '        _extendRound();\n', '        _logRoundExtensionVolume(msg.value);\n', '\n', '        emit TilePriceChanged(tileId, tileToOwner[tileId], oldPrice, newPrice);\n', '    }\n', '\n', '    function buyTile(uint8 tileId, uint256 newPrice, address referrer)\n', '        public\n', '        payable\n', '        atStage(Stage.GameRounds)\n', '        duringRound {\n', '        address oldOwner = tileToOwner[tileId];\n', '        require(\n', '            oldOwner != msg.sender,\n', '            "Can\'t buy a tile you already own"\n', '        );\n', '\n', '        uint256 tax = _priceToTax(newPrice);\n', '\n', '        uint256 oldPrice = tileToPrice[tileId];\n', '        require(\n', '            msg.value >= tax.add(oldPrice),\n', '            "Must pay full price and tax for tile"\n', '        );\n', '\n', '        // pay seller\n', '        asyncSend(oldOwner, tileToPrice[tileId]);\n', '        tileToOwner[tileId] = msg.sender;\n', '\n', '        uint256 actualTax = msg.value.sub(oldPrice);\n', '        _distributeTax(actualTax, referrer);\n', '\n', '        _changeTilePrice(tileId, newPrice);\n', '        _extendRound();\n', '        _logRoundExtensionVolume(msg.value);\n', '\n', '        emit TileOwnerChanged(tileId, oldOwner, msg.sender, oldPrice, newPrice);\n', '    }\n', '\n', '    ///////////////////////////////////////\n', '    // [Game] Dividend/jackpot distribution\n', '    ///////////////////////////////////////\n', '\n', '    function _distributeJackpot() private {\n', '        uint256 winnerJackpot = _winnerJackpot(jackpot);\n', '        uint256 landholderJackpot = _landholderJackpot(jackpot);\n', '        _distributeWinnerAndLandholderJackpot(winnerJackpot, landholderJackpot);\n', '\n', '        _sendToTeam(_teamJackpot(jackpot));\n', '        nextJackpot = nextJackpot.add(_nextPotJackpot(jackpot));\n', '    }\n', '\n', '    function _calculatePriceComplement(uint8 tileId) private view returns (uint256) {\n', '        return totalTileValue.sub(tileToPrice[tileId]);\n', '    }\n', '\n', '    // NOTE: These are bundled together so that we only have to compute complements once\n', '    function _distributeWinnerAndLandholderJackpot(uint256 winnerJackpot, uint256 landholderJackpot) private {\n', '        uint256[] memory complements = new uint256[](numTiles + 1); // inc necessary b/c tiles are 1-indexed\n', '        uint256 totalPriceComplement = 0;\n', '\n', '        uint256 bestComplement = 0;\n', '        uint8 lastWinningTileId = 0;\n', '        for (uint8 i = minTileId; i <= maxTileId; i++) {\n', '            uint256 priceComplement = _calculatePriceComplement(i);\n', '\n', '            // update winner\n', '            if (bestComplement == 0 || priceComplement > bestComplement) {\n', '                bestComplement = priceComplement;\n', '                lastWinningTileId = i;\n', '            }\n', '\n', '            complements[i] = priceComplement;\n', '            totalPriceComplement = totalPriceComplement.add(priceComplement);\n', '        }\n', '        uint256 numWinners = 0;\n', '        for (i = minTileId; i <= maxTileId; i++) {\n', '            if (_calculatePriceComplement(i) == bestComplement) {\n', '                numWinners++;\n', '            }\n', '        }\n', '\n', '        // distribute jackpot among all winners. save time on the majority (1-winner) case\n', '        if (numWinners == 1) {\n', '            asyncSend(tileToOwner[lastWinningTileId], winnerJackpot);\n', '        } else {\n', '            for (i = minTileId; i <= maxTileId; i++) {\n', '                if (_calculatePriceComplement(i) == bestComplement) {\n', '                    asyncSend(tileToOwner[i], winnerJackpot.div(numWinners));\n', '                }\n', '            }\n', '        }\n', '\n', '        // distribute landholder things\n', '        for (i = minTileId; i <= maxTileId; i++) {\n', "            // NOTE: We don't exclude the jackpot winner(s) here, so the winner(s) is paid 'twice'\n", '            uint256 landholderAllocation = complements[i].mul(landholderJackpot).div(totalPriceComplement);\n', '\n', '            asyncSend(tileToOwner[i], landholderAllocation);\n', '        }\n', '    }\n', '\n', '    function _distributeTax(uint256 tax, address referrer) private {\n', '        jackpot = jackpot.add(_jackpotTax(tax));\n', '\n', '        _distributeLandholderTax(_totalLandholderTax(tax));\n', '        nextJackpot = nextJackpot.add(_nextPotTax(tax));\n', '\n', '        // NOTE: referrer tax comes out of dev team tax\n', '        bool hasReferrer = referrer != address(0);\n', '        _sendToTeam(_teamTax(tax, hasReferrer));\n', '        asyncSend(referrer, _referrerTax(tax, hasReferrer));\n', '    }\n', '\n', '    function _distributeLandholderTax(uint256 tax) private {\n', '        for (uint8 tile = minTileId; tile <= maxTileId; tile++) {\n', '            if (tileToOwner[tile] != address(0) && tileToPrice[tile] != 0) {\n', '                uint256 tilePrice = tileToPrice[tile];\n', '                uint256 allocation = tax.mul(tilePrice).div(totalTileValue);\n', '\n', '                asyncSend(tileToOwner[tile], allocation);\n', '            }\n', '        }\n', '    }\n', '}']