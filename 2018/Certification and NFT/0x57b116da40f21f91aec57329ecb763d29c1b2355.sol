['pragma solidity ^0.4.0;\n', '\n', 'interface ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// GOO - Crypto Idle Game\n', '// https://ethergoo.io\n', '\n', 'contract Goo is ERC20 {\n', '    \n', '    string public constant name  = "IdleEth";\n', '    string public constant symbol = "Goo";\n', '    uint8 public constant decimals = 0;\n', '    uint256 private roughSupply;\n', '    uint256 public totalGooProduction;\n', '    address public owner; // Minor management of game\n', '    bool public gameStarted;\n', '    \n', '    uint256 public researchDivPercent = 8;\n', '    uint256 public gooDepositDivPercent = 2;\n', '    \n', '    uint256 public totalEtherGooResearchPool; // Eth dividends to be split between players&#39; goo production\n', '    uint256[] private totalGooProductionSnapshots; // The total goo production for each prior day past\n', '    uint256[] private totalGooDepositSnapshots;  // The total goo deposited for each prior day past\n', '    uint256[] private allocatedGooResearchSnapshots; // Div pot #1 (research eth allocated to each prior day past)\n', '    uint256[] private allocatedGooDepositSnapshots;  // Div pot #2 (deposit eth allocated to each prior day past)\n', '    uint256 public nextSnapshotTime;\n', '    \n', '    // Balances for each player\n', '    mapping(address => uint256) private ethBalance;\n', '    mapping(address => uint256) private gooBalance;\n', '    mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; // Store player&#39;s goo production for given day (snapshot)\n', '    mapping(address => mapping(uint256 => uint256)) private gooDepositSnapshots;    // Store player&#39;s goo deposited for given day (snapshot)\n', '    mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; // This isn&#39;t great but we need know difference between 0 production and an unused/inactive day.\n', '    \n', '    mapping(address => uint256) private lastGooSaveTime; // Seconds (last time player claimed their produced goo)\n', '    mapping(address => uint256) public lastGooProductionUpdate; // Days (last snapshot player updated their production)\n', '    mapping(address => uint256) private lastGooResearchFundClaim; // Days (snapshot number)\n', '    mapping(address => uint256) private lastGooDepositFundClaim; // Days (snapshot number)\n', '    mapping(address => uint256) private battleCooldown; // If user attacks they cannot attack again for short time\n', '    \n', '    // Stuff owned by each player\n', '    mapping(address => mapping(uint256 => uint256)) private unitsOwned;\n', '    mapping(address => mapping(uint256 => bool)) private upgradesOwned;\n', '    mapping(uint256 => address) private rareItemOwner;\n', '    mapping(uint256 => uint256) private rareItemPrice;\n', '    \n', '    // Rares & Upgrades (Increase unit&#39;s production / attack etc.)\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; // Adds to the goo per second\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; // Multiplies the goo per second\n', '    mapping(address => mapping(uint256 => uint256)) private unitAttackIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitAttackMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitDefenseIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitDefenseMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooStealingIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooStealingMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\n', '    \n', '    // Mapping of approved ERC20 transfers (by player)\n', '    mapping(address => mapping(address => uint256)) private allowed;\n', '    mapping(address => bool) private protectedAddresses; // For npc exchanges (requires 0 goo production)\n', '    \n', '    // Raffle structures\n', '    struct TicketPurchases {\n', '        TicketPurchase[] ticketsBought;\n', '        uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)\n', '        uint256 raffleId;\n', '    }\n', '    \n', '    // Allows us to query winner without looping (avoiding potential for gas limit)\n', '    struct TicketPurchase {\n', '        uint256 startId;\n', '        uint256 endId;\n', '    }\n', '    \n', '    // Raffle tickets\n', '    mapping(address => TicketPurchases) private rareItemTicketsBoughtByPlayer;\n', '    mapping(uint256 => address[]) private itemRafflePlayers;\n', '    \n', '    // Duplicating for the two raffles is not ideal\n', '    mapping(address => TicketPurchases) private rareUnitTicketsBoughtByPlayer;\n', '    mapping(uint256 => address[]) private unitRafflePlayers;\n', '\n', '    // Item raffle info\n', '    uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000;\n', '    uint256 private itemRaffleEndTime;\n', '    uint256 private itemRaffleRareId;\n', '    uint256 private itemRaffleTicketsBought;\n', '    address private itemRaffleWinner; // Address of winner\n', '    bool private itemRaffleWinningTicketSelected;\n', '    uint256 private itemRaffleTicketThatWon;\n', '    \n', '     // Unit raffle info\n', '    uint256 private unitRaffleEndTime;\n', '    uint256 private unitRaffleId;     // Raffle Id\n', '    uint256 private unitRaffleRareId; // Unit Id\n', '    uint256 private unitRaffleTicketsBought;\n', '    address private unitRaffleWinner; // Address of winner\n', '    bool private unitRaffleWinningTicketSelected;\n', '    uint256 private unitRaffleTicketThatWon;\n', '    \n', '    // Minor game events\n', '    event UnitBought(address player, uint256 unitId, uint256 amount);\n', '    event UnitSold(address player, uint256 unitId, uint256 amount);\n', '    event PlayerAttacked(address attacker, address target, bool success, uint256 gooStolen);\n', '    \n', '    event ReferalGain(address player, address referal, uint256 amount);\n', '    event UpgradeMigration(address player, uint256 upgradeId, uint256 txProof);\n', '    \n', '    GooGameConfig schema = GooGameConfig(0xf925a82b8c26520170c8d51b65a7def6364877b3);\n', '    \n', '    // Constructor\n', '    function Goo() public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function() payable {\n', '        // Fallback will donate to pot\n', '        totalEtherGooResearchPool += msg.value;\n', '    }\n', '    \n', '    function beginGame(uint256 firstDivsTime) external payable {\n', '        require(msg.sender == owner);\n', '        require(!gameStarted);\n', '        \n', '        gameStarted = true; // GO-OOOO!\n', '        nextSnapshotTime = firstDivsTime;\n', '        totalGooDepositSnapshots.push(0); // Add initial-zero snapshot\n', '        totalEtherGooResearchPool = msg.value; // Seed pot\n', '    }\n', '    \n', '    // Incase community prefers goo deposit payments over production %, can be tweaked for balance\n', '    function tweakDailyDividends(uint256 newResearchPercent, uint256 newGooDepositPercent) external {\n', '        require(msg.sender == owner);\n', '        require(newResearchPercent > 0 && newResearchPercent <= 10);\n', '        require(newGooDepositPercent > 0 && newGooDepositPercent <= 10);\n', '        \n', '        researchDivPercent = newResearchPercent;\n', '        gooDepositDivPercent = newGooDepositPercent;\n', '    }\n', '    \n', '    function totalSupply() public constant returns(uint256) {\n', '        return roughSupply; // Stored goo (rough supply as it ignores earned/unclaimed goo)\n', '    }\n', '    \n', '    function balanceOf(address player) public constant returns(uint256) {\n', '        return gooBalance[player] + balanceOfUnclaimedGoo(player);\n', '    }\n', '    \n', '    function balanceOfUnclaimedGoo(address player) internal constant returns (uint256) {\n', '        uint256 lastSave = lastGooSaveTime[player];\n', '        if (lastSave > 0 && lastSave < block.timestamp) {\n', '            return (getGooProduction(player) * (block.timestamp - lastSave)) / 100;\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function etherBalanceOf(address player) public constant returns(uint256) {\n', '        return ethBalance[player];\n', '    }\n', '    \n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersGoo(msg.sender);\n', '        require(amount <= gooBalance[msg.sender]);\n', '        \n', '        gooBalance[msg.sender] -= amount;\n', '        gooBalance[recipient] += amount;\n', '        \n', '        emit Transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersGoo(player);\n', '        require(amount <= allowed[player][msg.sender] && amount <= gooBalance[player]);\n', '        \n', '        gooBalance[player] -= amount;\n', '        gooBalance[recipient] += amount;\n', '        allowed[player][msg.sender] -= amount;\n', '        \n', '        emit Transfer(player, recipient, amount);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address approvee, uint256 amount) public returns (bool){\n', '        allowed[msg.sender][approvee] = amount;\n', '        emit Approval(msg.sender, approvee, amount);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address player, address approvee) public constant returns(uint256){\n', '        return allowed[player][approvee];\n', '    }\n', '    \n', '    function getGooProduction(address player) public constant returns (uint256){\n', '        return gooProductionSnapshots[player][lastGooProductionUpdate[player]];\n', '    }\n', '    \n', '    function updatePlayersGoo(address player) internal {\n', '        uint256 gooGain = balanceOfUnclaimedGoo(player);\n', '        lastGooSaveTime[player] = block.timestamp;\n', '        roughSupply += gooGain;\n', '        gooBalance[player] += gooGain;\n', '    }\n', '    \n', '    function updatePlayersGooFromPurchase(address player, uint256 purchaseCost) internal {\n', '        uint256 unclaimedGoo = balanceOfUnclaimedGoo(player);\n', '        \n', '        if (purchaseCost > unclaimedGoo) {\n', '            uint256 gooDecrease = purchaseCost - unclaimedGoo;\n', '            require(gooBalance[player] >= gooDecrease);\n', '            roughSupply -= gooDecrease;\n', '            gooBalance[player] -= gooDecrease;\n', '        } else {\n', '            uint256 gooGain = unclaimedGoo - purchaseCost;\n', '            roughSupply += gooGain;\n', '            gooBalance[player] += gooGain;\n', '        }\n', '        \n', '        lastGooSaveTime[player] = block.timestamp;\n', '    }\n', '    \n', '    function increasePlayersGooProduction(address player, uint256 increase) internal {\n', '        gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = getGooProduction(player) + increase;\n', '        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\n', '        totalGooProduction += increase;\n', '    }\n', '    \n', '    function reducePlayersGooProduction(address player, uint256 decrease) internal {\n', '        uint256 previousProduction = getGooProduction(player);\n', '        uint256 newProduction = SafeMath.sub(previousProduction, decrease);\n', '        \n', '        if (newProduction == 0) { // Special case which tangles with "inactive day" snapshots (claiming divs)\n', '            gooProductionZeroedSnapshots[player][allocatedGooResearchSnapshots.length] = true;\n', '            delete gooProductionSnapshots[player][allocatedGooResearchSnapshots.length]; // 0\n', '        } else {\n', '            gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = newProduction;\n', '        }\n', '        \n', '        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\n', '        totalGooProduction -= decrease;\n', '    }\n', '    \n', '    \n', '    function buyBasicUnit(uint256 unitId, uint256 amount) external {\n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        \n', '        require(gameStarted);\n', '        require(schemaUnitId > 0); // Valid unit\n', '        require(ethCost == 0); // Free unit\n', '        \n', '        uint256 newTotal = SafeMath.add(existing, amount);\n', '        if (newTotal > 99) { // Default unit limit\n', '            require(newTotal <= unitMaxCap[msg.sender][unitId]); // Housing upgrades (allow more units)\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '        \n', '        if (gooProduction > 0) {\n', '            increasePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        unitsOwned[msg.sender][unitId] = newTotal;\n', '        emit UnitBought(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function buyEthUnit(uint256 unitId, uint256 amount) external payable {\n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        \n', '        require(gameStarted);\n', '        require(schemaUnitId > 0);\n', '        require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '\n', '        if (ethCost > msg.value) {\n', '            ethBalance[msg.sender] -= (ethCost - msg.value);\n', '        }\n', '        \n', '        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', '        uint256 dividends = (ethCost - devFund) / 4; // 25% goes to pool (75% retained for sale value)\n', '        totalEtherGooResearchPool += dividends;\n', '        ethBalance[owner] += devFund;\n', '        \n', '        \n', '        uint256 newTotal = SafeMath.add(existing, amount);\n', '        if (newTotal > 99) { // Default unit limit\n', '            require(newTotal <= unitMaxCap[msg.sender][unitId]); // Housing upgrades (allow more units)\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '        \n', '        if (gooProduction > 0) {\n', '            increasePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        unitsOwned[msg.sender][unitId] += amount;\n', '        emit UnitBought(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function sellUnit(uint256 unitId, uint256 amount) external {\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        require(existing >= amount && amount > 0);\n', '        existing -= amount;\n', '        unitsOwned[msg.sender][unitId] = existing;\n', '        \n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        require(schema.unitSellable(unitId));\n', '        \n', '        uint256 gooChange = balanceOfUnclaimedGoo(msg.sender) + ((gooCost * 3) / 4); // Claim unsaved goo whilst here\n', '        lastGooSaveTime[msg.sender] = block.timestamp;\n', '        roughSupply += gooChange;\n', '        gooBalance[msg.sender] += gooChange;\n', '        \n', '        if (gooProduction > 0) {\n', '            reducePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        if (ethCost > 0) { // Premium units sell for 75% of buy cost\n', '            ethBalance[msg.sender] += (ethCost * 3) / 4;\n', '        }\n', '        \n', '        emit UnitSold(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function buyUpgrade(uint256 upgradeId) external payable {\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        uint256 prerequisiteUpgrade;\n', '        (gooCost, ethCost, upgradeClass, unitId, upgradeValue, prerequisiteUpgrade) = schema.getUpgradeInfo(upgradeId);\n', '        \n', '        require(gameStarted);\n', '        require(unitId > 0); // Valid upgrade\n', '        require(!upgradesOwned[msg.sender][upgradeId]); // Haven&#39;t already purchased\n', '        \n', '        if (prerequisiteUpgrade > 0) {\n', '            require(upgradesOwned[msg.sender][prerequisiteUpgrade]);\n', '        }\n', '        \n', '        if (ethCost > 0) {\n', '            require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '             if (ethCost > msg.value) { // They can use their balance instead\n', '                ethBalance[msg.sender] -= (ethCost - msg.value);\n', '            }\n', '        \n', '            uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', '            totalEtherGooResearchPool += (ethCost - devFund); // Rest goes to div pool (Can&#39;t sell upgrades)\n', '            ethBalance[owner] += devFund;\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '\n', '        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\n', '        upgradesOwned[msg.sender][upgradeId] = true;\n', '    }\n', '    \n', '    function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\n', '        uint256 productionGain;\n', '        if (upgradeClass == 0) {\n', '            unitGooProductionIncreases[player][unitId] += upgradeValue;\n', '            productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId]);\n', '            increasePlayersGooProduction(player, productionGain);\n', '        } else if (upgradeClass == 1) {\n', '            unitGooProductionMultiplier[player][unitId] += upgradeValue;\n', '            productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]);\n', '            increasePlayersGooProduction(player, productionGain);\n', '        } else if (upgradeClass == 2) {\n', '            unitAttackIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 3) {\n', '            unitAttackMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 4) {\n', '            unitDefenseIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 5) {\n', '            unitDefenseMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 6) {\n', '            unitGooStealingIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 7) {\n', '            unitGooStealingMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 8) {\n', '            unitMaxCap[player][unitId] = upgradeValue; // Housing upgrade (new capacity)\n', '        }\n', '    }\n', '    \n', '    function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\n', '        uint256 productionLoss;\n', '        if (upgradeClass == 0) {\n', '            unitGooProductionIncreases[player][unitId] -= upgradeValue;\n', '            productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId]);\n', '            reducePlayersGooProduction(player, productionLoss);\n', '        } else if (upgradeClass == 1) {\n', '            unitGooProductionMultiplier[player][unitId] -= upgradeValue;\n', '            productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]);\n', '            reducePlayersGooProduction(player, productionLoss);\n', '        } else if (upgradeClass == 2) {\n', '            unitAttackIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 3) {\n', '            unitAttackMultiplier[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 4) {\n', '            unitDefenseIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 5) {\n', '            unitDefenseMultiplier[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 6) {\n', '            unitGooStealingIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 7) {\n', '            unitGooStealingMultiplier[player][unitId] -= upgradeValue;\n', '        }\n', '    }\n', '    \n', '    function buyRareItem(uint256 rareId) external payable {\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(rareId);\n', '\n', '        address previousOwner = rareItemOwner[rareId];\n', '        require(previousOwner != 0);\n', '        require(unitId > 0);\n', '        \n', '        // We have to claim buyer&#39;s goo before updating their production values\n', '        updatePlayersGoo(msg.sender);\n', '        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\n', '        \n', '        // We have to claim seller&#39;s goo before reducing their production values\n', '        updatePlayersGoo(previousOwner);\n', '        removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue);\n', '        \n', '        uint256 ethCost = rareItemPrice[rareId];\n', '        require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '        \n', '        // Splitbid/Overbid\n', '        if (ethCost > msg.value) {\n', '            // Earlier require() said they can still afford it (so use their ingame balance)\n', '            ethBalance[msg.sender] -= (ethCost - msg.value);\n', '        } else if (msg.value > ethCost) {\n', '            // Store overbid in their balance\n', '            ethBalance[msg.sender] += msg.value - ethCost;\n', '        }\n', '        \n', '        // Distribute ethCost\n', '        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', '        uint256 dividends = ethCost / 20; // 5% goes to pool (~93% goes to player)\n', '        totalEtherGooResearchPool += dividends;\n', '        ethBalance[owner] += devFund;\n', '        \n', '        // Transfer / update rare item\n', '        rareItemOwner[rareId] = msg.sender;\n', '        rareItemPrice[rareId] = (ethCost * 5) / 4; // 25% price flip increase\n', '        ethBalance[previousOwner] += ethCost - (dividends + devFund);\n', '    }\n', '    \n', '    function withdrawEther(uint256 amount) external {\n', '        require(amount <= ethBalance[msg.sender]);\n', '        ethBalance[msg.sender] -= amount;\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function fundGooResearch(uint256 amount) external {\n', '        updatePlayersGooFromPurchase(msg.sender, amount);\n', '        gooDepositSnapshots[msg.sender][totalGooDepositSnapshots.length - 1] += amount;\n', '        totalGooDepositSnapshots[totalGooDepositSnapshots.length - 1] += amount;\n', '    }\n', '    \n', '    function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n', '        require(startSnapshot <= endSnapShot);\n', '        require(startSnapshot >= lastGooResearchFundClaim[msg.sender]);\n', '        require(endSnapShot < allocatedGooResearchSnapshots.length);\n', '        \n', '        uint256 researchShare;\n', '        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won&#39;t be a problem as gooProductionSnapshots[][0xffffffffff] = 0;\n', '        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n', '            \n', '            // Slightly complex things by accounting for days/snapshots when user made no tx&#39;s\n', '            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\n', '            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\n', '            if (productionDuringSnapshot == 0 && !soldAllProduction) {\n', '                productionDuringSnapshot = previousProduction;\n', '            } else {\n', '               previousProduction = productionDuringSnapshot;\n', '            }\n', '            \n', '            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\n', '        }\n', '        \n', '        \n', '        if (gooProductionSnapshots[msg.sender][endSnapShot] == 0 && !gooProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {\n', '            gooProductionSnapshots[msg.sender][endSnapShot] = previousProduction; // Checkpoint for next claim\n', '        }\n', '        \n', '        lastGooResearchFundClaim[msg.sender] = endSnapShot + 1;\n', '        \n', '        uint256 referalDivs;\n', '        if (referer != address(0) && referer != msg.sender) {\n', '            referalDivs = researchShare / 100; // 1%\n', '            ethBalance[referer] += referalDivs;\n', '            emit ReferalGain(referer, msg.sender, referalDivs);\n', '        }\n', '        \n', '        ethBalance[msg.sender] += researchShare - referalDivs;\n', '    }\n', '    \n', '    \n', '    function claimGooDepositDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n', '        require(startSnapshot <= endSnapShot);\n', '        require(startSnapshot >= lastGooDepositFundClaim[msg.sender]);\n', '        require(endSnapShot < allocatedGooDepositSnapshots.length);\n', '        \n', '        uint256 depositShare;\n', '        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n', '            depositShare += (allocatedGooDepositSnapshots[i] * gooDepositSnapshots[msg.sender][i]) / totalGooDepositSnapshots[i];\n', '        }\n', '        \n', '        lastGooDepositFundClaim[msg.sender] = endSnapShot + 1;\n', '        \n', '        uint256 referalDivs;\n', '        if (referer != address(0) && referer != msg.sender) {\n', '            referalDivs = depositShare / 100; // 1%\n', '            ethBalance[referer] += referalDivs;\n', '            emit ReferalGain(referer, msg.sender, referalDivs);\n', '        }\n', '        \n', '        ethBalance[msg.sender] += depositShare - referalDivs;\n', '    }\n', '    \n', '    \n', '    // Allocate pot #1 divs for the day (00:00 cron job)\n', '    function snapshotDailyGooResearchFunding() external {\n', '        require(msg.sender == owner);\n', '        \n', '        uint256 todaysGooResearchFund = (totalEtherGooResearchPool * researchDivPercent) / 100; // 8% of pool daily\n', '        totalEtherGooResearchPool -= todaysGooResearchFund;\n', '        \n', '        totalGooProductionSnapshots.push(totalGooProduction);\n', '        allocatedGooResearchSnapshots.push(todaysGooResearchFund);\n', '        nextSnapshotTime = block.timestamp + 24 hours;\n', '    }\n', '    \n', '    // Allocate pot #2 divs for the day (12:00 cron job)\n', '    function snapshotDailyGooDepositFunding() external {\n', '        require(msg.sender == owner);\n', '        \n', '        uint256 todaysGooDepositFund = (totalEtherGooResearchPool * gooDepositDivPercent) / 100; // 2% of pool daily\n', '        totalEtherGooResearchPool -= todaysGooDepositFund;\n', '        totalGooDepositSnapshots.push(0); // Reset for to store next day&#39;s deposits\n', '        allocatedGooDepositSnapshots.push(todaysGooDepositFund); // Store to payout divs for previous day deposits\n', '    }\n', '    \n', '    \n', '    // Raffle for rare items\n', '    function buyItemRaffleTicket(uint256 amount) external {\n', '        require(itemRaffleEndTime >= block.timestamp);\n', '        require(amount > 0);\n', '        \n', '        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\n', '        require(balanceOf(msg.sender) >= ticketsCost);\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, ticketsCost);\n', '        \n', '        // Handle new tickets\n', '        TicketPurchases storage purchases = rareItemTicketsBoughtByPlayer[msg.sender];\n', '        \n', '        // If we need to reset tickets from a previous raffle\n', '        if (purchases.raffleId != itemRaffleRareId) {\n', '            purchases.numPurchases = 0;\n', '            purchases.raffleId = itemRaffleRareId;\n', '            itemRafflePlayers[itemRaffleRareId].push(msg.sender); // Add user to raffle\n', '        }\n', '        \n', '        // Store new ticket purchase\n', '        if (purchases.numPurchases == purchases.ticketsBought.length) {\n', '            purchases.ticketsBought.length += 1;\n', '        }\n', '        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(itemRaffleTicketsBought, itemRaffleTicketsBought + (amount - 1)); // (eg: buy 10, get id&#39;s 0-9)\n', '        \n', '        // Finally update ticket total\n', '        itemRaffleTicketsBought += amount;\n', '    }\n', '    \n', '    // Raffle for rare units\n', '    function buyUnitRaffleTicket(uint256 amount) external {\n', '        require(unitRaffleEndTime >= block.timestamp);\n', '        require(amount > 0);\n', '        \n', '        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\n', '        require(balanceOf(msg.sender) >= ticketsCost);\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, ticketsCost);\n', '        \n', '        // Handle new tickets\n', '        TicketPurchases storage purchases = rareUnitTicketsBoughtByPlayer[msg.sender];\n', '        \n', '        // If we need to reset tickets from a previous raffle\n', '        if (purchases.raffleId != unitRaffleId) {\n', '            purchases.numPurchases = 0;\n', '            purchases.raffleId = unitRaffleId;\n', '            unitRafflePlayers[unitRaffleId].push(msg.sender); // Add user to raffle\n', '        }\n', '        \n', '        // Store new ticket purchase\n', '        if (purchases.numPurchases == purchases.ticketsBought.length) {\n', '            purchases.ticketsBought.length += 1;\n', '        }\n', '        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(unitRaffleTicketsBought, unitRaffleTicketsBought + (amount - 1)); // (eg: buy 10, get id&#39;s 0-9)\n', '        \n', '        // Finally update ticket total\n', '        unitRaffleTicketsBought += amount;\n', '    }\n', '    \n', '    function startItemRaffle(uint256 endTime, uint256 rareId) external {\n', '        require(msg.sender == owner);\n', '        require(schema.validRareId(rareId));\n', '        require(rareItemOwner[rareId] == 0);\n', '        require(block.timestamp < endTime);\n', '        \n', '        if (itemRaffleRareId != 0) { // Sanity to assure raffle has ended before next one starts\n', '            require(itemRaffleWinner != 0);\n', '        }\n', '        \n', '        // Reset previous raffle info\n', '        itemRaffleWinningTicketSelected = false;\n', '        itemRaffleTicketThatWon = 0;\n', '        itemRaffleWinner = 0;\n', '        itemRaffleTicketsBought = 0;\n', '        \n', '        // Set current raffle info\n', '        itemRaffleEndTime = endTime;\n', '        itemRaffleRareId = rareId;\n', '    }\n', '    \n', '    function startUnitRaffle(uint256 endTime, uint256 unitId) external {\n', '        require(msg.sender == owner);\n', '        require(block.timestamp < endTime);\n', '        \n', '        if (unitRaffleRareId != 0) { // Sanity to assure raffle has ended before next one starts\n', '            require(unitRaffleWinner != 0);\n', '        }\n', '        \n', '        // Reset previous raffle info\n', '        unitRaffleWinningTicketSelected = false;\n', '        unitRaffleTicketThatWon = 0;\n', '        unitRaffleWinner = 0;\n', '        unitRaffleTicketsBought = 0;\n', '        \n', '        // Set current raffle info\n', '        unitRaffleEndTime = endTime;\n', '        unitRaffleRareId = unitId;\n', '        unitRaffleId++; // Can&#39;t use unitRaffleRareId (as rare units are not unique)\n', '    }\n', '    \n', '    function awardItemRafflePrize(address checkWinner, uint256 checkIndex) external {\n', '        require(itemRaffleEndTime < block.timestamp);\n', '        require(itemRaffleWinner == 0);\n', '        require(rareItemOwner[itemRaffleRareId] == 0);\n', '        \n', '        if (!itemRaffleWinningTicketSelected) {\n', '            drawRandomItemWinner(); // Ideally do it in one call (gas limit cautious)\n', '        }\n', '        \n', '        // Reduce gas by (optionally) offering an address to _check_ for winner\n', '        if (checkWinner != 0) {\n', '            TicketPurchases storage tickets = rareItemTicketsBoughtByPlayer[checkWinner];\n', '            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == itemRaffleRareId) {\n', '                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n', '                if (itemRaffleTicketThatWon >= checkTicket.startId && itemRaffleTicketThatWon <= checkTicket.endId) {\n', '                    assignItemRafflePrize(checkWinner); // WINNER!\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '        \n', '        // Otherwise just naively try to find the winner (will work until mass amounts of players)\n', '        for (uint256 i = 0; i < itemRafflePlayers[itemRaffleRareId].length; i++) {\n', '            address player = itemRafflePlayers[itemRaffleRareId][i];\n', '            TicketPurchases storage playersTickets = rareItemTicketsBoughtByPlayer[player];\n', '            \n', '            uint256 endIndex = playersTickets.numPurchases - 1;\n', '            // Minor optimization to avoid checking every single player\n', '            if (itemRaffleTicketThatWon >= playersTickets.ticketsBought[0].startId && itemRaffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n', '                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n', '                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n', '                    if (itemRaffleTicketThatWon >= playerTicket.startId && itemRaffleTicketThatWon <= playerTicket.endId) {\n', '                        assignItemRafflePrize(player); // WINNER!\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function awardUnitRafflePrize(address checkWinner, uint256 checkIndex) external {\n', '        require(unitRaffleEndTime < block.timestamp);\n', '        require(unitRaffleWinner == 0);\n', '        \n', '        if (!unitRaffleWinningTicketSelected) {\n', '            drawRandomUnitWinner(); // Ideally do it in one call (gas limit cautious)\n', '        }\n', '        \n', '        // Reduce gas by (optionally) offering an address to _check_ for winner\n', '        if (checkWinner != 0) {\n', '            TicketPurchases storage tickets = rareUnitTicketsBoughtByPlayer[checkWinner];\n', '            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == unitRaffleId) {\n', '                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n', '                if (unitRaffleTicketThatWon >= checkTicket.startId && unitRaffleTicketThatWon <= checkTicket.endId) {\n', '                    assignUnitRafflePrize(checkWinner); // WINNER!\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '        \n', '        // Otherwise just naively try to find the winner (will work until mass amounts of players)\n', '        for (uint256 i = 0; i < unitRafflePlayers[unitRaffleId].length; i++) {\n', '            address player = unitRafflePlayers[unitRaffleId][i];\n', '            TicketPurchases storage playersTickets = rareUnitTicketsBoughtByPlayer[player];\n', '            \n', '            uint256 endIndex = playersTickets.numPurchases - 1;\n', '            // Minor optimization to avoid checking every single player\n', '            if (unitRaffleTicketThatWon >= playersTickets.ticketsBought[0].startId && unitRaffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n', '                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n', '                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n', '                    if (unitRaffleTicketThatWon >= playerTicket.startId && unitRaffleTicketThatWon <= playerTicket.endId) {\n', '                        assignUnitRafflePrize(player); // WINNER!\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function assignItemRafflePrize(address winner) internal {\n', '        itemRaffleWinner = winner;\n', '        rareItemOwner[itemRaffleRareId] = winner;\n', '        rareItemPrice[itemRaffleRareId] = (schema.rareStartPrice(itemRaffleRareId) * 21) / 20; // Buy price slightly higher (Div pool cut)\n', '        \n', '        updatePlayersGoo(winner);\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(itemRaffleRareId);\n', '        upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\n', '    }\n', '    \n', '    function assignUnitRafflePrize(address winner) internal {\n', '        unitRaffleWinner = winner;\n', '        updatePlayersGoo(winner);\n', '        increasePlayersGooProduction(winner, getUnitsProduction(winner, unitRaffleRareId, 1));\n', '        unitsOwned[winner][unitRaffleRareId] += 1;\n', '    }\n', '    \n', '    // Random enough for small contests (Owner only to prevent trial & error execution)\n', '    function drawRandomItemWinner() public {\n', '        require(msg.sender == owner);\n', '        require(itemRaffleEndTime < block.timestamp);\n', '        require(!itemRaffleWinningTicketSelected);\n', '        \n', '        uint256 seed = itemRaffleTicketsBought + block.timestamp;\n', '        itemRaffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, itemRaffleTicketsBought);\n', '        itemRaffleWinningTicketSelected = true;\n', '    }\n', '    \n', '    function drawRandomUnitWinner() public {\n', '        require(msg.sender == owner);\n', '        require(unitRaffleEndTime < block.timestamp);\n', '        require(!unitRaffleWinningTicketSelected);\n', '        \n', '        uint256 seed = unitRaffleTicketsBought + block.timestamp;\n', '        unitRaffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, unitRaffleTicketsBought);\n', '        unitRaffleWinningTicketSelected = true;\n', '    }\n', '    \n', '    // Gives players the upgrades they &#39;previously paid for&#39; (i.e. will be one of same unit/type/value of their v1 purchase)\n', '    // Tx of their (prior) purchase is provided so can be validated by anyone for 0 abuse\n', '    function migrateV1Upgrades(address[] playerToCredit, uint256[] upgradeIds, uint256[] txProof) external {\n', '        require(msg.sender == owner);\n', '        require(!gameStarted); // Pre-game migration\n', '        \n', '        for (uint256 i = 0; i < txProof.length; i++) {\n', '            address player = playerToCredit[i];\n', '            uint256 upgradeId = upgradeIds[i];\n', '            \n', '            uint256 unitId = schema.upgradeUnitId(upgradeId);\n', '            if (unitId > 0 && !upgradesOwned[player][upgradeId]) { // Upgrade valid (and haven&#39;t already migrated)\n', '                uint256 upgradeClass = schema.upgradeClass(upgradeId);\n', '                uint256 upgradeValue = schema.upgradeValue(upgradeId);\n', '        \n', '                upgradeUnitMultipliers(player, upgradeClass, unitId, upgradeValue);\n', '                upgradesOwned[player][upgradeId] = true;\n', '                emit UpgradeMigration(player, upgradeId, txProof[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function protectAddress(address exchange, bool shouldProtect) external {\n', '        require(msg.sender == owner);\n', '        if (shouldProtect) {\n', '            require(getGooProduction(exchange) == 0); // Can&#39;t protect actual players\n', '        }\n', '        protectedAddresses[exchange] = shouldProtect;\n', '    }\n', '    \n', '    function attackPlayer(address target) external {\n', '        require(battleCooldown[msg.sender] < block.timestamp);\n', '        require(target != msg.sender);\n', '        require(!protectedAddresses[target]); // Target not whitelisted (i.e. exchange wallets)\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '        (attackingPower, defendingPower, stealingPower) = getPlayersBattlePower(msg.sender, target);\n', '        \n', '        if (battleCooldown[target] > block.timestamp) { // When on battle cooldown you&#39;re vulnerable (starting value is 50% normal power)\n', '            defendingPower = schema.getWeakenedDefensePower(defendingPower);\n', '        }\n', '        \n', '        if (attackingPower > defendingPower) {\n', '            battleCooldown[msg.sender] = block.timestamp + 30 minutes;\n', '            if (balanceOf(target) > stealingPower) {\n', '                // Save all their unclaimed goo, then steal attacker&#39;s max capacity (at same time)\n', '                uint256 unclaimedGoo = balanceOfUnclaimedGoo(target);\n', '                if (stealingPower > unclaimedGoo) {\n', '                    uint256 gooDecrease = stealingPower - unclaimedGoo;\n', '                    gooBalance[target] -= gooDecrease;\n', '                    roughSupply -= gooDecrease;\n', '                } else {\n', '                    uint256 gooGain = unclaimedGoo - stealingPower;\n', '                    gooBalance[target] += gooGain;\n', '                    roughSupply += gooGain;\n', '                }\n', '                gooBalance[msg.sender] += stealingPower;\n', '                emit PlayerAttacked(msg.sender, target, true, stealingPower);\n', '            } else {\n', '                emit PlayerAttacked(msg.sender, target, true, balanceOf(target));\n', '                gooBalance[msg.sender] += balanceOf(target);\n', '                gooBalance[target] = 0;\n', '            }\n', '            \n', '            lastGooSaveTime[target] = block.timestamp;\n', '            // We don&#39;t need to claim/save msg.sender&#39;s goo (as production delta is unchanged)\n', '        } else {\n', '            battleCooldown[msg.sender] = block.timestamp + 10 minutes;\n', '            emit PlayerAttacked(msg.sender, target, false, 0);\n', '        }\n', '    }\n', '    \n', '    function getPlayersBattlePower(address attacker, address defender) internal constant returns (uint256, uint256, uint256) {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '\n', '        // Not ideal but will only be a small number of units (and saves gas when buying units)\n', '        while (startId <= endId) {\n', '            attackingPower += getUnitsAttack(attacker, startId, unitsOwned[attacker][startId]);\n', '            stealingPower += getUnitsStealingCapacity(attacker, startId, unitsOwned[attacker][startId]);\n', '            \n', '            defendingPower += getUnitsDefense(defender, startId, unitsOwned[defender][startId]);\n', '            startId++;\n', '        }\n', '        \n', '        return (attackingPower, defendingPower, stealingPower);\n', '    }\n', '    \n', '    function getPlayersBattleStats(address player) external constant returns (uint256, uint256, uint256, uint256) {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '\n', '        // Not ideal but will only be a small number of units (and saves gas when buying units)\n', '        while (startId <= endId) {\n', '            attackingPower += getUnitsAttack(player, startId, unitsOwned[player][startId]);\n', '            stealingPower += getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]);\n', '            defendingPower += getUnitsDefense(player, startId, unitsOwned[player][startId]);\n', '            startId++;\n', '        }\n', '        \n', '        if (battleCooldown[player] > block.timestamp) { // When on battle cooldown you&#39;re vulnerable (starting value is 50% normal power)\n', '            defendingPower = schema.getWeakenedDefensePower(defendingPower);\n', '        }\n', '        \n', '        return (attackingPower, defendingPower, stealingPower, battleCooldown[player]);\n', '    }\n', '    \n', '    function getUnitsProduction(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]) * (10 + unitGooProductionMultiplier[player][unitId]));\n', '    }\n', '    \n', '    function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitStealingCapacity(unitId) + unitGooStealingIncreases[player][unitId]) * (10 + unitGooStealingMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    \n', '    // To display on website\n', '    function getGameInfo() external constant returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256[], bool[]){\n', '        uint256[] memory units = new uint256[](schema.currentNumberOfUnits());\n', '        bool[] memory upgrades = new bool[](schema.currentNumberOfUpgrades());\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.productionUnitIdRange();\n', '        \n', '        uint256 i;\n', '        while (startId <= endId) {\n', '            units[i] = unitsOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        while (startId <= endId) {\n', '            units[i] = unitsOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        // Reset for upgrades\n', '        i = 0;\n', '        (startId, endId) = schema.upgradeIdRange();\n', '        while (startId <= endId) {\n', '            upgrades[i] = upgradesOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        return (block.timestamp, totalEtherGooResearchPool, totalGooProduction, totalGooDepositSnapshots[totalGooDepositSnapshots.length - 1],  gooDepositSnapshots[msg.sender][totalGooDepositSnapshots.length - 1],\n', '        nextSnapshotTime, balanceOf(msg.sender), ethBalance[msg.sender], getGooProduction(msg.sender), units, upgrades);\n', '    }\n', '    \n', '    // To display on website\n', '    function getRareItemInfo() external constant returns (address[], uint256[]) {\n', '        address[] memory itemOwners = new address[](schema.currentNumberOfRares());\n', '        uint256[] memory itemPrices = new uint256[](schema.currentNumberOfRares());\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.rareIdRange();\n', '        \n', '        uint256 i;\n', '        while (startId <= endId) {\n', '            itemOwners[i] = rareItemOwner[startId];\n', '            itemPrices[i] = rareItemPrice[startId];\n', '            \n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        return (itemOwners, itemPrices);\n', '    }\n', '    \n', '    // To display on website\n', '    function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {\n', '        uint256 startSnapshot = lastGooResearchFundClaim[msg.sender];\n', '        uint256 latestSnapshot = allocatedGooResearchSnapshots.length - 1; // No snapshots to begin with\n', '        \n', '        uint256 researchShare;\n', '        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won&#39;t be a problem as gooProductionSnapshots[][0xfffffffffffff] = 0;\n', '        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n', '            \n', '            // Slightly complex things by accounting for days/snapshots when user made no tx&#39;s\n', '            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\n', '            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\n', '            if (productionDuringSnapshot == 0 && !soldAllProduction) {\n', '                productionDuringSnapshot = previousProduction;\n', '            } else {\n', '               previousProduction = productionDuringSnapshot;\n', '            }\n', '            \n', '            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\n', '        }\n', '        return (researchShare, startSnapshot, latestSnapshot);\n', '    }\n', '    \n', '    // To display on website\n', '    function viewUnclaimedDepositDividends() external constant returns (uint256, uint256, uint256) {\n', '        uint256 startSnapshot = lastGooDepositFundClaim[msg.sender];\n', '        uint256 latestSnapshot = allocatedGooDepositSnapshots.length - 1; // No snapshots to begin with\n', '        \n', '        uint256 depositShare;\n', '        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n', '            depositShare += (allocatedGooDepositSnapshots[i] * gooDepositSnapshots[msg.sender][i]) / totalGooDepositSnapshots[i];\n', '        }\n', '        return (depositShare, startSnapshot, latestSnapshot);\n', '    }\n', '    \n', '    \n', '    // To allow clients to verify contestants\n', '    function getItemRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n', '        return (itemRafflePlayers[raffleId]);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getUnitRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n', '        return (unitRafflePlayers[raffleId]);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getPlayersItemTickets(address player) external constant returns (uint256[], uint256[]) {\n', '        TicketPurchases storage playersTickets = rareItemTicketsBoughtByPlayer[player];\n', '        \n', '        if (playersTickets.raffleId == itemRaffleRareId) {\n', '            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n', '            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n', '            \n', '            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n', '                startIds[i] = playersTickets.ticketsBought[i].startId;\n', '                endIds[i] = playersTickets.ticketsBought[i].endId;\n', '            }\n', '        }\n', '        \n', '        return (startIds, endIds);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getPlayersUnitTickets(address player) external constant returns (uint256[], uint256[]) {\n', '        TicketPurchases storage playersTickets = rareUnitTicketsBoughtByPlayer[player];\n', '        \n', '        if (playersTickets.raffleId == unitRaffleId) {\n', '            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n', '            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n', '            \n', '            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n', '                startIds[i] = playersTickets.ticketsBought[i].startId;\n', '                endIds[i] = playersTickets.ticketsBought[i].endId;\n', '            }\n', '        }\n', '        \n', '        return (startIds, endIds);\n', '    }\n', '    \n', '    // To display on website\n', '    function getLatestItemRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n', '        return (itemRaffleEndTime, itemRaffleRareId, itemRaffleTicketsBought, itemRaffleWinner, itemRaffleTicketThatWon);\n', '    }\n', '    \n', '    // To display on website\n', '    function getLatestUnitRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n', '        return (unitRaffleEndTime, unitRaffleRareId, unitRaffleTicketsBought, unitRaffleWinner, unitRaffleTicketThatWon);\n', '    }\n', '    \n', '    \n', '    // New units may be added in future, but check it matches existing schema so no-one can abuse selling.\n', '    function updateGooConfig(address newSchemaAddress) external {\n', '        require(msg.sender == owner);\n', '        \n', '        GooGameConfig newSchema = GooGameConfig(newSchemaAddress);\n', '        \n', '        requireExistingUnitsSame(newSchema);\n', '        requireExistingUpgradesSame(newSchema);\n', '        \n', '        // Finally update config\n', '        schema = GooGameConfig(newSchema);\n', '    }\n', '    \n', '    function requireExistingUnitsSame(GooGameConfig newSchema) internal constant {\n', '        // Requires units eth costs match up or fail execution\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.productionUnitIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\n', '            require(schema.unitGooProduction(startId) == newSchema.unitGooProduction(startId));\n', '            startId++;\n', '        }\n', '        \n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\n', '            require(schema.unitAttack(startId) == newSchema.unitAttack(startId));\n', '            require(schema.unitDefense(startId) == newSchema.unitDefense(startId));\n', '            require(schema.unitStealingCapacity(startId) == newSchema.unitStealingCapacity(startId));\n', '            startId++;\n', '        }\n', '    }\n', '    \n', '    function requireExistingUpgradesSame(GooGameConfig newSchema) internal constant {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        \n', '        // Requires ALL upgrade stats match up or fail execution\n', '        (startId, endId) = schema.upgradeIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.upgradeGooCost(startId) == newSchema.upgradeGooCost(startId));\n', '            require(schema.upgradeEthCost(startId) == newSchema.upgradeEthCost(startId));\n', '            require(schema.upgradeClass(startId) == newSchema.upgradeClass(startId));\n', '            require(schema.upgradeUnitId(startId) == newSchema.upgradeUnitId(startId));\n', '            require(schema.upgradeValue(startId) == newSchema.upgradeValue(startId));\n', '            startId++;\n', '        }\n', '        \n', '        // Requires ALL rare stats match up or fail execution\n', '        (startId, endId) = schema.rareIdRange();\n', '        while (startId <= endId) {\n', '            uint256 oldClass;\n', '            uint256 oldUnitId;\n', '            uint256 oldValue;\n', '            \n', '            uint256 newClass;\n', '            uint256 newUnitId;\n', '            uint256 newValue;\n', '            (oldClass, oldUnitId, oldValue) = schema.getRareInfo(startId);\n', '            (newClass, newUnitId, newValue) = newSchema.getRareInfo(startId);\n', '            \n', '            require(oldClass == newClass);\n', '            require(oldUnitId == newUnitId);\n', '            require(oldValue == newValue);\n', '            startId++;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract GooGameConfig {\n', '    \n', '    mapping(uint256 => Unit) private unitInfo;\n', '    mapping(uint256 => Upgrade) private upgradeInfo;\n', '    mapping(uint256 => Rare) private rareInfo;\n', '    \n', '    uint256 public constant currentNumberOfUnits = 15;\n', '    uint256 public constant currentNumberOfUpgrades = 210;\n', '    uint256 public constant currentNumberOfRares = 2;\n', '    \n', '    address public owner;\n', '    \n', '    struct Unit {\n', '        uint256 unitId;\n', '        uint256 baseGooCost;\n', '        uint256 gooCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)\n', '        uint256 ethCost;\n', '        uint256 baseGooProduction;\n', '        \n', '        uint256 attackValue;\n', '        uint256 defenseValue;\n', '        uint256 gooStealingCapacity;\n', '        bool unitSellable; // Rare units (from raffle) not sellable\n', '    }\n', '    \n', '    struct Upgrade {\n', '        uint256 upgradeId;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        uint256 prerequisiteUpgrade;\n', '    }\n', '    \n', '    struct Rare {\n', '        uint256 rareId;\n', '        uint256 ethCost;\n', '        uint256 rareClass;\n', '        uint256 unitId;\n', '        uint256 rareValue;\n', '    }\n', '    \n', '    function GooGameConfig() public {\n', '        owner = msg.sender;\n', '        \n', '        rareInfo[1] = Rare(1, 0.5 ether, 1, 1, 40); // 40 = +400%\n', '        rareInfo[2] = Rare(2, 0.5 ether, 0, 2, 35); // +35\n', '        \n', '        unitInfo[1] = Unit(1, 0, 10, 0, 2, 0, 0, 0, true);\n', '        unitInfo[2] = Unit(2, 100, 50, 0, 5, 0, 0, 0, true);\n', '        unitInfo[3] = Unit(3, 0, 0, 0.01 ether, 100, 0, 0, 0, true);\n', '        unitInfo[4] = Unit(4, 200, 100, 0, 10, 0, 0, 0, true);\n', '        unitInfo[5] = Unit(5, 500, 250, 0, 20, 0, 0, 0, true);\n', '        unitInfo[6] = Unit(6, 1000, 500, 0, 40, 0, 0, 0, true);\n', '        unitInfo[7] = Unit(7, 0, 1000, 0.05 ether, 500, 0, 0, 0, true);\n', '        unitInfo[8] = Unit(8, 1500, 750, 0, 60, 0, 0, 0, true);\n', '        unitInfo[9] = Unit(9, 0, 0, 10 ether, 6000, 0, 0, 0, false); // First secret rare unit from raffle (unsellable)\n', '        \n', '        unitInfo[40] = Unit(40, 50, 25, 0, 0, 10, 10, 10000, true);\n', '        unitInfo[41] = Unit(41, 100, 50, 0, 0, 1, 25, 500, true);\n', '        unitInfo[42] = Unit(42, 0, 0, 0.01 ether, 0, 200, 10, 50000, true);\n', '        unitInfo[43] = Unit(43, 250, 125, 0, 0, 25, 1, 15000, true);\n', '        unitInfo[44] = Unit(44, 500, 250, 0, 0, 20, 40, 5000, true);\n', '        unitInfo[45] = Unit(45, 0, 2500, 0.02 ether, 0, 0, 0, 100000, true);\n', '    }\n', '    \n', '    address allowedConfig;\n', '    function setConfigSetupContract(address schema) external {\n', '        require(msg.sender == owner);\n', '        allowedConfig = schema;\n', '    }\n', '    \n', '    function addUpgrade(uint256 id, uint256 goo, uint256 eth, uint256 class, uint256 unit, uint256 value, uint256 prereq) external {\n', '        require(msg.sender == allowedConfig);\n', '        upgradeInfo[id] = Upgrade(id, goo, eth, class, unit, value, prereq);\n', '    }\n', '    \n', '    function getGooCostForUnit(uint256 unitId, uint256 existing, uint256 amount) public constant returns (uint256) {\n', '        Unit storage unit = unitInfo[unitId];\n', '        if (amount == 1) { // 1\n', '            if (existing == 0) {\n', '                return unit.baseGooCost;\n', '            } else {\n', '                return unit.baseGooCost + (existing * unit.gooCostIncreaseHalf * 2);\n', '            }\n', '        } else if (amount > 1) {\n', '            uint256 existingCost;\n', '            if (existing > 0) { // Gated by unit limit\n', '                existingCost = (unit.baseGooCost * existing) + (existing * (existing - 1) * unit.gooCostIncreaseHalf);\n', '            }\n', '            \n', '            existing = SafeMath.add(existing, amount);\n', '            return SafeMath.add(SafeMath.mul(unit.baseGooCost, existing), SafeMath.mul(SafeMath.mul(existing, (existing - 1)), unit.gooCostIncreaseHalf)) - existingCost;\n', '        }\n', '    }\n', '    \n', '    function getWeakenedDefensePower(uint256 defendingPower) external constant returns (uint256) {\n', '        return defendingPower / 2;\n', '    }\n', '    \n', '    function validRareId(uint256 rareId) external constant returns (bool) {\n', '        return (rareId > 0 && rareId < 3);\n', '    }\n', '    \n', '    function unitSellable(uint256 unitId) external constant returns (bool) {\n', '        return unitInfo[unitId].unitSellable;\n', '    }\n', '    \n', '    function unitEthCost(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].ethCost;\n', '    }\n', '    \n', '    function unitGooProduction(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].baseGooProduction;\n', '    }\n', '    \n', '    function unitAttack(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].attackValue;\n', '    }\n', '    \n', '    function unitDefense(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].defenseValue;\n', '    }\n', '    \n', '    function unitStealingCapacity(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].gooStealingCapacity;\n', '    }\n', '    \n', '    function rareStartPrice(uint256 rareId) external constant returns (uint256) {\n', '        return rareInfo[rareId].ethCost;\n', '    }\n', '    \n', '    function upgradeGooCost(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].gooCost;\n', '    }\n', '    \n', '    function upgradeEthCost(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].ethCost;\n', '    }\n', '    \n', '    function upgradeClass(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].upgradeClass;\n', '    }\n', '    \n', '    function upgradeUnitId(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].unitId;\n', '    }\n', '    \n', '    function upgradeValue(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].upgradeValue;\n', '    }\n', '    \n', '    function productionUnitIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 9);\n', '    }\n', '    \n', '    function battleUnitIdRange() external constant returns (uint256, uint256) {\n', '        return (40, 45);\n', '    }\n', '    \n', '    function upgradeIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 210);\n', '    }\n', '    \n', '    function rareIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 2);\n', '    }\n', '    \n', '    function getUpgradeInfo(uint256 upgradeId) external constant returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (upgradeInfo[upgradeId].gooCost, upgradeInfo[upgradeId].ethCost, upgradeInfo[upgradeId].upgradeClass,\n', '        upgradeInfo[upgradeId].unitId, upgradeInfo[upgradeId].upgradeValue, upgradeInfo[upgradeId].prerequisiteUpgrade);\n', '    }\n', '    \n', '    function getRareInfo(uint256 rareId) external constant returns (uint256, uint256, uint256) {\n', '        return (rareInfo[rareId].rareClass, rareInfo[rareId].unitId, rareInfo[rareId].rareValue);\n', '    }\n', '    \n', '    function getUnitInfo(uint256 unitId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256) {\n', '        return (unitInfo[unitId].unitId, unitInfo[unitId].baseGooProduction, getGooCostForUnit(unitId, existing, amount), SafeMath.mul(unitInfo[unitId].ethCost, amount));\n', '    }\n', '    \n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.0;\n', '\n', 'interface ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// GOO - Crypto Idle Game\n', '// https://ethergoo.io\n', '\n', 'contract Goo is ERC20 {\n', '    \n', '    string public constant name  = "IdleEth";\n', '    string public constant symbol = "Goo";\n', '    uint8 public constant decimals = 0;\n', '    uint256 private roughSupply;\n', '    uint256 public totalGooProduction;\n', '    address public owner; // Minor management of game\n', '    bool public gameStarted;\n', '    \n', '    uint256 public researchDivPercent = 8;\n', '    uint256 public gooDepositDivPercent = 2;\n', '    \n', "    uint256 public totalEtherGooResearchPool; // Eth dividends to be split between players' goo production\n", '    uint256[] private totalGooProductionSnapshots; // The total goo production for each prior day past\n', '    uint256[] private totalGooDepositSnapshots;  // The total goo deposited for each prior day past\n', '    uint256[] private allocatedGooResearchSnapshots; // Div pot #1 (research eth allocated to each prior day past)\n', '    uint256[] private allocatedGooDepositSnapshots;  // Div pot #2 (deposit eth allocated to each prior day past)\n', '    uint256 public nextSnapshotTime;\n', '    \n', '    // Balances for each player\n', '    mapping(address => uint256) private ethBalance;\n', '    mapping(address => uint256) private gooBalance;\n', "    mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; // Store player's goo production for given day (snapshot)\n", "    mapping(address => mapping(uint256 => uint256)) private gooDepositSnapshots;    // Store player's goo deposited for given day (snapshot)\n", "    mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.\n", '    \n', '    mapping(address => uint256) private lastGooSaveTime; // Seconds (last time player claimed their produced goo)\n', '    mapping(address => uint256) public lastGooProductionUpdate; // Days (last snapshot player updated their production)\n', '    mapping(address => uint256) private lastGooResearchFundClaim; // Days (snapshot number)\n', '    mapping(address => uint256) private lastGooDepositFundClaim; // Days (snapshot number)\n', '    mapping(address => uint256) private battleCooldown; // If user attacks they cannot attack again for short time\n', '    \n', '    // Stuff owned by each player\n', '    mapping(address => mapping(uint256 => uint256)) private unitsOwned;\n', '    mapping(address => mapping(uint256 => bool)) private upgradesOwned;\n', '    mapping(uint256 => address) private rareItemOwner;\n', '    mapping(uint256 => uint256) private rareItemPrice;\n', '    \n', "    // Rares & Upgrades (Increase unit's production / attack etc.)\n", '    mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; // Adds to the goo per second\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; // Multiplies the goo per second\n', '    mapping(address => mapping(uint256 => uint256)) private unitAttackIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitAttackMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitDefenseIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitDefenseMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooStealingIncreases;\n', '    mapping(address => mapping(uint256 => uint256)) private unitGooStealingMultiplier;\n', '    mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\n', '    \n', '    // Mapping of approved ERC20 transfers (by player)\n', '    mapping(address => mapping(address => uint256)) private allowed;\n', '    mapping(address => bool) private protectedAddresses; // For npc exchanges (requires 0 goo production)\n', '    \n', '    // Raffle structures\n', '    struct TicketPurchases {\n', '        TicketPurchase[] ticketsBought;\n', '        uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit)\n', '        uint256 raffleId;\n', '    }\n', '    \n', '    // Allows us to query winner without looping (avoiding potential for gas limit)\n', '    struct TicketPurchase {\n', '        uint256 startId;\n', '        uint256 endId;\n', '    }\n', '    \n', '    // Raffle tickets\n', '    mapping(address => TicketPurchases) private rareItemTicketsBoughtByPlayer;\n', '    mapping(uint256 => address[]) private itemRafflePlayers;\n', '    \n', '    // Duplicating for the two raffles is not ideal\n', '    mapping(address => TicketPurchases) private rareUnitTicketsBoughtByPlayer;\n', '    mapping(uint256 => address[]) private unitRafflePlayers;\n', '\n', '    // Item raffle info\n', '    uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000;\n', '    uint256 private itemRaffleEndTime;\n', '    uint256 private itemRaffleRareId;\n', '    uint256 private itemRaffleTicketsBought;\n', '    address private itemRaffleWinner; // Address of winner\n', '    bool private itemRaffleWinningTicketSelected;\n', '    uint256 private itemRaffleTicketThatWon;\n', '    \n', '     // Unit raffle info\n', '    uint256 private unitRaffleEndTime;\n', '    uint256 private unitRaffleId;     // Raffle Id\n', '    uint256 private unitRaffleRareId; // Unit Id\n', '    uint256 private unitRaffleTicketsBought;\n', '    address private unitRaffleWinner; // Address of winner\n', '    bool private unitRaffleWinningTicketSelected;\n', '    uint256 private unitRaffleTicketThatWon;\n', '    \n', '    // Minor game events\n', '    event UnitBought(address player, uint256 unitId, uint256 amount);\n', '    event UnitSold(address player, uint256 unitId, uint256 amount);\n', '    event PlayerAttacked(address attacker, address target, bool success, uint256 gooStolen);\n', '    \n', '    event ReferalGain(address player, address referal, uint256 amount);\n', '    event UpgradeMigration(address player, uint256 upgradeId, uint256 txProof);\n', '    \n', '    GooGameConfig schema = GooGameConfig(0xf925a82b8c26520170c8d51b65a7def6364877b3);\n', '    \n', '    // Constructor\n', '    function Goo() public payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function() payable {\n', '        // Fallback will donate to pot\n', '        totalEtherGooResearchPool += msg.value;\n', '    }\n', '    \n', '    function beginGame(uint256 firstDivsTime) external payable {\n', '        require(msg.sender == owner);\n', '        require(!gameStarted);\n', '        \n', '        gameStarted = true; // GO-OOOO!\n', '        nextSnapshotTime = firstDivsTime;\n', '        totalGooDepositSnapshots.push(0); // Add initial-zero snapshot\n', '        totalEtherGooResearchPool = msg.value; // Seed pot\n', '    }\n', '    \n', '    // Incase community prefers goo deposit payments over production %, can be tweaked for balance\n', '    function tweakDailyDividends(uint256 newResearchPercent, uint256 newGooDepositPercent) external {\n', '        require(msg.sender == owner);\n', '        require(newResearchPercent > 0 && newResearchPercent <= 10);\n', '        require(newGooDepositPercent > 0 && newGooDepositPercent <= 10);\n', '        \n', '        researchDivPercent = newResearchPercent;\n', '        gooDepositDivPercent = newGooDepositPercent;\n', '    }\n', '    \n', '    function totalSupply() public constant returns(uint256) {\n', '        return roughSupply; // Stored goo (rough supply as it ignores earned/unclaimed goo)\n', '    }\n', '    \n', '    function balanceOf(address player) public constant returns(uint256) {\n', '        return gooBalance[player] + balanceOfUnclaimedGoo(player);\n', '    }\n', '    \n', '    function balanceOfUnclaimedGoo(address player) internal constant returns (uint256) {\n', '        uint256 lastSave = lastGooSaveTime[player];\n', '        if (lastSave > 0 && lastSave < block.timestamp) {\n', '            return (getGooProduction(player) * (block.timestamp - lastSave)) / 100;\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function etherBalanceOf(address player) public constant returns(uint256) {\n', '        return ethBalance[player];\n', '    }\n', '    \n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersGoo(msg.sender);\n', '        require(amount <= gooBalance[msg.sender]);\n', '        \n', '        gooBalance[msg.sender] -= amount;\n', '        gooBalance[recipient] += amount;\n', '        \n', '        emit Transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n', '        updatePlayersGoo(player);\n', '        require(amount <= allowed[player][msg.sender] && amount <= gooBalance[player]);\n', '        \n', '        gooBalance[player] -= amount;\n', '        gooBalance[recipient] += amount;\n', '        allowed[player][msg.sender] -= amount;\n', '        \n', '        emit Transfer(player, recipient, amount);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address approvee, uint256 amount) public returns (bool){\n', '        allowed[msg.sender][approvee] = amount;\n', '        emit Approval(msg.sender, approvee, amount);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address player, address approvee) public constant returns(uint256){\n', '        return allowed[player][approvee];\n', '    }\n', '    \n', '    function getGooProduction(address player) public constant returns (uint256){\n', '        return gooProductionSnapshots[player][lastGooProductionUpdate[player]];\n', '    }\n', '    \n', '    function updatePlayersGoo(address player) internal {\n', '        uint256 gooGain = balanceOfUnclaimedGoo(player);\n', '        lastGooSaveTime[player] = block.timestamp;\n', '        roughSupply += gooGain;\n', '        gooBalance[player] += gooGain;\n', '    }\n', '    \n', '    function updatePlayersGooFromPurchase(address player, uint256 purchaseCost) internal {\n', '        uint256 unclaimedGoo = balanceOfUnclaimedGoo(player);\n', '        \n', '        if (purchaseCost > unclaimedGoo) {\n', '            uint256 gooDecrease = purchaseCost - unclaimedGoo;\n', '            require(gooBalance[player] >= gooDecrease);\n', '            roughSupply -= gooDecrease;\n', '            gooBalance[player] -= gooDecrease;\n', '        } else {\n', '            uint256 gooGain = unclaimedGoo - purchaseCost;\n', '            roughSupply += gooGain;\n', '            gooBalance[player] += gooGain;\n', '        }\n', '        \n', '        lastGooSaveTime[player] = block.timestamp;\n', '    }\n', '    \n', '    function increasePlayersGooProduction(address player, uint256 increase) internal {\n', '        gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = getGooProduction(player) + increase;\n', '        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\n', '        totalGooProduction += increase;\n', '    }\n', '    \n', '    function reducePlayersGooProduction(address player, uint256 decrease) internal {\n', '        uint256 previousProduction = getGooProduction(player);\n', '        uint256 newProduction = SafeMath.sub(previousProduction, decrease);\n', '        \n', '        if (newProduction == 0) { // Special case which tangles with "inactive day" snapshots (claiming divs)\n', '            gooProductionZeroedSnapshots[player][allocatedGooResearchSnapshots.length] = true;\n', '            delete gooProductionSnapshots[player][allocatedGooResearchSnapshots.length]; // 0\n', '        } else {\n', '            gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = newProduction;\n', '        }\n', '        \n', '        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\n', '        totalGooProduction -= decrease;\n', '    }\n', '    \n', '    \n', '    function buyBasicUnit(uint256 unitId, uint256 amount) external {\n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        \n', '        require(gameStarted);\n', '        require(schemaUnitId > 0); // Valid unit\n', '        require(ethCost == 0); // Free unit\n', '        \n', '        uint256 newTotal = SafeMath.add(existing, amount);\n', '        if (newTotal > 99) { // Default unit limit\n', '            require(newTotal <= unitMaxCap[msg.sender][unitId]); // Housing upgrades (allow more units)\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '        \n', '        if (gooProduction > 0) {\n', '            increasePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        unitsOwned[msg.sender][unitId] = newTotal;\n', '        emit UnitBought(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function buyEthUnit(uint256 unitId, uint256 amount) external payable {\n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        \n', '        require(gameStarted);\n', '        require(schemaUnitId > 0);\n', '        require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '\n', '        if (ethCost > msg.value) {\n', '            ethBalance[msg.sender] -= (ethCost - msg.value);\n', '        }\n', '        \n', '        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', '        uint256 dividends = (ethCost - devFund) / 4; // 25% goes to pool (75% retained for sale value)\n', '        totalEtherGooResearchPool += dividends;\n', '        ethBalance[owner] += devFund;\n', '        \n', '        \n', '        uint256 newTotal = SafeMath.add(existing, amount);\n', '        if (newTotal > 99) { // Default unit limit\n', '            require(newTotal <= unitMaxCap[msg.sender][unitId]); // Housing upgrades (allow more units)\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '        \n', '        if (gooProduction > 0) {\n', '            increasePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        unitsOwned[msg.sender][unitId] += amount;\n', '        emit UnitBought(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function sellUnit(uint256 unitId, uint256 amount) external {\n', '        uint256 existing = unitsOwned[msg.sender][unitId];\n', '        require(existing >= amount && amount > 0);\n', '        existing -= amount;\n', '        unitsOwned[msg.sender][unitId] = existing;\n', '        \n', '        uint256 schemaUnitId;\n', '        uint256 gooProduction;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        (schemaUnitId, gooProduction, gooCost, ethCost) = schema.getUnitInfo(unitId, existing, amount);\n', '        require(schema.unitSellable(unitId));\n', '        \n', '        uint256 gooChange = balanceOfUnclaimedGoo(msg.sender) + ((gooCost * 3) / 4); // Claim unsaved goo whilst here\n', '        lastGooSaveTime[msg.sender] = block.timestamp;\n', '        roughSupply += gooChange;\n', '        gooBalance[msg.sender] += gooChange;\n', '        \n', '        if (gooProduction > 0) {\n', '            reducePlayersGooProduction(msg.sender, getUnitsProduction(msg.sender, unitId, amount));\n', '        }\n', '        \n', '        if (ethCost > 0) { // Premium units sell for 75% of buy cost\n', '            ethBalance[msg.sender] += (ethCost * 3) / 4;\n', '        }\n', '        \n', '        emit UnitSold(msg.sender, unitId, amount);\n', '    }\n', '    \n', '    \n', '    function buyUpgrade(uint256 upgradeId) external payable {\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        uint256 prerequisiteUpgrade;\n', '        (gooCost, ethCost, upgradeClass, unitId, upgradeValue, prerequisiteUpgrade) = schema.getUpgradeInfo(upgradeId);\n', '        \n', '        require(gameStarted);\n', '        require(unitId > 0); // Valid upgrade\n', "        require(!upgradesOwned[msg.sender][upgradeId]); // Haven't already purchased\n", '        \n', '        if (prerequisiteUpgrade > 0) {\n', '            require(upgradesOwned[msg.sender][prerequisiteUpgrade]);\n', '        }\n', '        \n', '        if (ethCost > 0) {\n', '            require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '             if (ethCost > msg.value) { // They can use their balance instead\n', '                ethBalance[msg.sender] -= (ethCost - msg.value);\n', '            }\n', '        \n', '            uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', "            totalEtherGooResearchPool += (ethCost - devFund); // Rest goes to div pool (Can't sell upgrades)\n", '            ethBalance[owner] += devFund;\n', '        }\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, gooCost);\n', '\n', '        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\n', '        upgradesOwned[msg.sender][upgradeId] = true;\n', '    }\n', '    \n', '    function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\n', '        uint256 productionGain;\n', '        if (upgradeClass == 0) {\n', '            unitGooProductionIncreases[player][unitId] += upgradeValue;\n', '            productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId]);\n', '            increasePlayersGooProduction(player, productionGain);\n', '        } else if (upgradeClass == 1) {\n', '            unitGooProductionMultiplier[player][unitId] += upgradeValue;\n', '            productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]);\n', '            increasePlayersGooProduction(player, productionGain);\n', '        } else if (upgradeClass == 2) {\n', '            unitAttackIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 3) {\n', '            unitAttackMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 4) {\n', '            unitDefenseIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 5) {\n', '            unitDefenseMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 6) {\n', '            unitGooStealingIncreases[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 7) {\n', '            unitGooStealingMultiplier[player][unitId] += upgradeValue;\n', '        } else if (upgradeClass == 8) {\n', '            unitMaxCap[player][unitId] = upgradeValue; // Housing upgrade (new capacity)\n', '        }\n', '    }\n', '    \n', '    function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\n', '        uint256 productionLoss;\n', '        if (upgradeClass == 0) {\n', '            unitGooProductionIncreases[player][unitId] -= upgradeValue;\n', '            productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId]);\n', '            reducePlayersGooProduction(player, productionLoss);\n', '        } else if (upgradeClass == 1) {\n', '            unitGooProductionMultiplier[player][unitId] -= upgradeValue;\n', '            productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]);\n', '            reducePlayersGooProduction(player, productionLoss);\n', '        } else if (upgradeClass == 2) {\n', '            unitAttackIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 3) {\n', '            unitAttackMultiplier[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 4) {\n', '            unitDefenseIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 5) {\n', '            unitDefenseMultiplier[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 6) {\n', '            unitGooStealingIncreases[player][unitId] -= upgradeValue;\n', '        } else if (upgradeClass == 7) {\n', '            unitGooStealingMultiplier[player][unitId] -= upgradeValue;\n', '        }\n', '    }\n', '    \n', '    function buyRareItem(uint256 rareId) external payable {\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(rareId);\n', '\n', '        address previousOwner = rareItemOwner[rareId];\n', '        require(previousOwner != 0);\n', '        require(unitId > 0);\n', '        \n', "        // We have to claim buyer's goo before updating their production values\n", '        updatePlayersGoo(msg.sender);\n', '        upgradeUnitMultipliers(msg.sender, upgradeClass, unitId, upgradeValue);\n', '        \n', "        // We have to claim seller's goo before reducing their production values\n", '        updatePlayersGoo(previousOwner);\n', '        removeUnitMultipliers(previousOwner, upgradeClass, unitId, upgradeValue);\n', '        \n', '        uint256 ethCost = rareItemPrice[rareId];\n', '        require(ethBalance[msg.sender] + msg.value >= ethCost);\n', '        \n', '        // Splitbid/Overbid\n', '        if (ethCost > msg.value) {\n', '            // Earlier require() said they can still afford it (so use their ingame balance)\n', '            ethBalance[msg.sender] -= (ethCost - msg.value);\n', '        } else if (msg.value > ethCost) {\n', '            // Store overbid in their balance\n', '            ethBalance[msg.sender] += msg.value - ethCost;\n', '        }\n', '        \n', '        // Distribute ethCost\n', '        uint256 devFund = ethCost / 50; // 2% fee on purchases (marketing, gameplay & maintenance)\n', '        uint256 dividends = ethCost / 20; // 5% goes to pool (~93% goes to player)\n', '        totalEtherGooResearchPool += dividends;\n', '        ethBalance[owner] += devFund;\n', '        \n', '        // Transfer / update rare item\n', '        rareItemOwner[rareId] = msg.sender;\n', '        rareItemPrice[rareId] = (ethCost * 5) / 4; // 25% price flip increase\n', '        ethBalance[previousOwner] += ethCost - (dividends + devFund);\n', '    }\n', '    \n', '    function withdrawEther(uint256 amount) external {\n', '        require(amount <= ethBalance[msg.sender]);\n', '        ethBalance[msg.sender] -= amount;\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function fundGooResearch(uint256 amount) external {\n', '        updatePlayersGooFromPurchase(msg.sender, amount);\n', '        gooDepositSnapshots[msg.sender][totalGooDepositSnapshots.length - 1] += amount;\n', '        totalGooDepositSnapshots[totalGooDepositSnapshots.length - 1] += amount;\n', '    }\n', '    \n', '    function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n', '        require(startSnapshot <= endSnapShot);\n', '        require(startSnapshot >= lastGooResearchFundClaim[msg.sender]);\n', '        require(endSnapShot < allocatedGooResearchSnapshots.length);\n', '        \n', '        uint256 researchShare;\n', "        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xffffffffff] = 0;\n", '        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n', '            \n', "            // Slightly complex things by accounting for days/snapshots when user made no tx's\n", '            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\n', '            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\n', '            if (productionDuringSnapshot == 0 && !soldAllProduction) {\n', '                productionDuringSnapshot = previousProduction;\n', '            } else {\n', '               previousProduction = productionDuringSnapshot;\n', '            }\n', '            \n', '            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\n', '        }\n', '        \n', '        \n', '        if (gooProductionSnapshots[msg.sender][endSnapShot] == 0 && !gooProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {\n', '            gooProductionSnapshots[msg.sender][endSnapShot] = previousProduction; // Checkpoint for next claim\n', '        }\n', '        \n', '        lastGooResearchFundClaim[msg.sender] = endSnapShot + 1;\n', '        \n', '        uint256 referalDivs;\n', '        if (referer != address(0) && referer != msg.sender) {\n', '            referalDivs = researchShare / 100; // 1%\n', '            ethBalance[referer] += referalDivs;\n', '            emit ReferalGain(referer, msg.sender, referalDivs);\n', '        }\n', '        \n', '        ethBalance[msg.sender] += researchShare - referalDivs;\n', '    }\n', '    \n', '    \n', '    function claimGooDepositDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n', '        require(startSnapshot <= endSnapShot);\n', '        require(startSnapshot >= lastGooDepositFundClaim[msg.sender]);\n', '        require(endSnapShot < allocatedGooDepositSnapshots.length);\n', '        \n', '        uint256 depositShare;\n', '        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n', '            depositShare += (allocatedGooDepositSnapshots[i] * gooDepositSnapshots[msg.sender][i]) / totalGooDepositSnapshots[i];\n', '        }\n', '        \n', '        lastGooDepositFundClaim[msg.sender] = endSnapShot + 1;\n', '        \n', '        uint256 referalDivs;\n', '        if (referer != address(0) && referer != msg.sender) {\n', '            referalDivs = depositShare / 100; // 1%\n', '            ethBalance[referer] += referalDivs;\n', '            emit ReferalGain(referer, msg.sender, referalDivs);\n', '        }\n', '        \n', '        ethBalance[msg.sender] += depositShare - referalDivs;\n', '    }\n', '    \n', '    \n', '    // Allocate pot #1 divs for the day (00:00 cron job)\n', '    function snapshotDailyGooResearchFunding() external {\n', '        require(msg.sender == owner);\n', '        \n', '        uint256 todaysGooResearchFund = (totalEtherGooResearchPool * researchDivPercent) / 100; // 8% of pool daily\n', '        totalEtherGooResearchPool -= todaysGooResearchFund;\n', '        \n', '        totalGooProductionSnapshots.push(totalGooProduction);\n', '        allocatedGooResearchSnapshots.push(todaysGooResearchFund);\n', '        nextSnapshotTime = block.timestamp + 24 hours;\n', '    }\n', '    \n', '    // Allocate pot #2 divs for the day (12:00 cron job)\n', '    function snapshotDailyGooDepositFunding() external {\n', '        require(msg.sender == owner);\n', '        \n', '        uint256 todaysGooDepositFund = (totalEtherGooResearchPool * gooDepositDivPercent) / 100; // 2% of pool daily\n', '        totalEtherGooResearchPool -= todaysGooDepositFund;\n', "        totalGooDepositSnapshots.push(0); // Reset for to store next day's deposits\n", '        allocatedGooDepositSnapshots.push(todaysGooDepositFund); // Store to payout divs for previous day deposits\n', '    }\n', '    \n', '    \n', '    // Raffle for rare items\n', '    function buyItemRaffleTicket(uint256 amount) external {\n', '        require(itemRaffleEndTime >= block.timestamp);\n', '        require(amount > 0);\n', '        \n', '        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\n', '        require(balanceOf(msg.sender) >= ticketsCost);\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, ticketsCost);\n', '        \n', '        // Handle new tickets\n', '        TicketPurchases storage purchases = rareItemTicketsBoughtByPlayer[msg.sender];\n', '        \n', '        // If we need to reset tickets from a previous raffle\n', '        if (purchases.raffleId != itemRaffleRareId) {\n', '            purchases.numPurchases = 0;\n', '            purchases.raffleId = itemRaffleRareId;\n', '            itemRafflePlayers[itemRaffleRareId].push(msg.sender); // Add user to raffle\n', '        }\n', '        \n', '        // Store new ticket purchase\n', '        if (purchases.numPurchases == purchases.ticketsBought.length) {\n', '            purchases.ticketsBought.length += 1;\n', '        }\n', "        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(itemRaffleTicketsBought, itemRaffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)\n", '        \n', '        // Finally update ticket total\n', '        itemRaffleTicketsBought += amount;\n', '    }\n', '    \n', '    // Raffle for rare units\n', '    function buyUnitRaffleTicket(uint256 amount) external {\n', '        require(unitRaffleEndTime >= block.timestamp);\n', '        require(amount > 0);\n', '        \n', '        uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\n', '        require(balanceOf(msg.sender) >= ticketsCost);\n', '        \n', '        // Update players goo\n', '        updatePlayersGooFromPurchase(msg.sender, ticketsCost);\n', '        \n', '        // Handle new tickets\n', '        TicketPurchases storage purchases = rareUnitTicketsBoughtByPlayer[msg.sender];\n', '        \n', '        // If we need to reset tickets from a previous raffle\n', '        if (purchases.raffleId != unitRaffleId) {\n', '            purchases.numPurchases = 0;\n', '            purchases.raffleId = unitRaffleId;\n', '            unitRafflePlayers[unitRaffleId].push(msg.sender); // Add user to raffle\n', '        }\n', '        \n', '        // Store new ticket purchase\n', '        if (purchases.numPurchases == purchases.ticketsBought.length) {\n', '            purchases.ticketsBought.length += 1;\n', '        }\n', "        purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(unitRaffleTicketsBought, unitRaffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9)\n", '        \n', '        // Finally update ticket total\n', '        unitRaffleTicketsBought += amount;\n', '    }\n', '    \n', '    function startItemRaffle(uint256 endTime, uint256 rareId) external {\n', '        require(msg.sender == owner);\n', '        require(schema.validRareId(rareId));\n', '        require(rareItemOwner[rareId] == 0);\n', '        require(block.timestamp < endTime);\n', '        \n', '        if (itemRaffleRareId != 0) { // Sanity to assure raffle has ended before next one starts\n', '            require(itemRaffleWinner != 0);\n', '        }\n', '        \n', '        // Reset previous raffle info\n', '        itemRaffleWinningTicketSelected = false;\n', '        itemRaffleTicketThatWon = 0;\n', '        itemRaffleWinner = 0;\n', '        itemRaffleTicketsBought = 0;\n', '        \n', '        // Set current raffle info\n', '        itemRaffleEndTime = endTime;\n', '        itemRaffleRareId = rareId;\n', '    }\n', '    \n', '    function startUnitRaffle(uint256 endTime, uint256 unitId) external {\n', '        require(msg.sender == owner);\n', '        require(block.timestamp < endTime);\n', '        \n', '        if (unitRaffleRareId != 0) { // Sanity to assure raffle has ended before next one starts\n', '            require(unitRaffleWinner != 0);\n', '        }\n', '        \n', '        // Reset previous raffle info\n', '        unitRaffleWinningTicketSelected = false;\n', '        unitRaffleTicketThatWon = 0;\n', '        unitRaffleWinner = 0;\n', '        unitRaffleTicketsBought = 0;\n', '        \n', '        // Set current raffle info\n', '        unitRaffleEndTime = endTime;\n', '        unitRaffleRareId = unitId;\n', "        unitRaffleId++; // Can't use unitRaffleRareId (as rare units are not unique)\n", '    }\n', '    \n', '    function awardItemRafflePrize(address checkWinner, uint256 checkIndex) external {\n', '        require(itemRaffleEndTime < block.timestamp);\n', '        require(itemRaffleWinner == 0);\n', '        require(rareItemOwner[itemRaffleRareId] == 0);\n', '        \n', '        if (!itemRaffleWinningTicketSelected) {\n', '            drawRandomItemWinner(); // Ideally do it in one call (gas limit cautious)\n', '        }\n', '        \n', '        // Reduce gas by (optionally) offering an address to _check_ for winner\n', '        if (checkWinner != 0) {\n', '            TicketPurchases storage tickets = rareItemTicketsBoughtByPlayer[checkWinner];\n', '            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == itemRaffleRareId) {\n', '                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n', '                if (itemRaffleTicketThatWon >= checkTicket.startId && itemRaffleTicketThatWon <= checkTicket.endId) {\n', '                    assignItemRafflePrize(checkWinner); // WINNER!\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '        \n', '        // Otherwise just naively try to find the winner (will work until mass amounts of players)\n', '        for (uint256 i = 0; i < itemRafflePlayers[itemRaffleRareId].length; i++) {\n', '            address player = itemRafflePlayers[itemRaffleRareId][i];\n', '            TicketPurchases storage playersTickets = rareItemTicketsBoughtByPlayer[player];\n', '            \n', '            uint256 endIndex = playersTickets.numPurchases - 1;\n', '            // Minor optimization to avoid checking every single player\n', '            if (itemRaffleTicketThatWon >= playersTickets.ticketsBought[0].startId && itemRaffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n', '                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n', '                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n', '                    if (itemRaffleTicketThatWon >= playerTicket.startId && itemRaffleTicketThatWon <= playerTicket.endId) {\n', '                        assignItemRafflePrize(player); // WINNER!\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function awardUnitRafflePrize(address checkWinner, uint256 checkIndex) external {\n', '        require(unitRaffleEndTime < block.timestamp);\n', '        require(unitRaffleWinner == 0);\n', '        \n', '        if (!unitRaffleWinningTicketSelected) {\n', '            drawRandomUnitWinner(); // Ideally do it in one call (gas limit cautious)\n', '        }\n', '        \n', '        // Reduce gas by (optionally) offering an address to _check_ for winner\n', '        if (checkWinner != 0) {\n', '            TicketPurchases storage tickets = rareUnitTicketsBoughtByPlayer[checkWinner];\n', '            if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == unitRaffleId) {\n', '                TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n', '                if (unitRaffleTicketThatWon >= checkTicket.startId && unitRaffleTicketThatWon <= checkTicket.endId) {\n', '                    assignUnitRafflePrize(checkWinner); // WINNER!\n', '                    return;\n', '                }\n', '            }\n', '        }\n', '        \n', '        // Otherwise just naively try to find the winner (will work until mass amounts of players)\n', '        for (uint256 i = 0; i < unitRafflePlayers[unitRaffleId].length; i++) {\n', '            address player = unitRafflePlayers[unitRaffleId][i];\n', '            TicketPurchases storage playersTickets = rareUnitTicketsBoughtByPlayer[player];\n', '            \n', '            uint256 endIndex = playersTickets.numPurchases - 1;\n', '            // Minor optimization to avoid checking every single player\n', '            if (unitRaffleTicketThatWon >= playersTickets.ticketsBought[0].startId && unitRaffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n', '                for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n', '                    TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n', '                    if (unitRaffleTicketThatWon >= playerTicket.startId && unitRaffleTicketThatWon <= playerTicket.endId) {\n', '                        assignUnitRafflePrize(player); // WINNER!\n', '                        return;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function assignItemRafflePrize(address winner) internal {\n', '        itemRaffleWinner = winner;\n', '        rareItemOwner[itemRaffleRareId] = winner;\n', '        rareItemPrice[itemRaffleRareId] = (schema.rareStartPrice(itemRaffleRareId) * 21) / 20; // Buy price slightly higher (Div pool cut)\n', '        \n', '        updatePlayersGoo(winner);\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        (upgradeClass, unitId, upgradeValue) = schema.getRareInfo(itemRaffleRareId);\n', '        upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\n', '    }\n', '    \n', '    function assignUnitRafflePrize(address winner) internal {\n', '        unitRaffleWinner = winner;\n', '        updatePlayersGoo(winner);\n', '        increasePlayersGooProduction(winner, getUnitsProduction(winner, unitRaffleRareId, 1));\n', '        unitsOwned[winner][unitRaffleRareId] += 1;\n', '    }\n', '    \n', '    // Random enough for small contests (Owner only to prevent trial & error execution)\n', '    function drawRandomItemWinner() public {\n', '        require(msg.sender == owner);\n', '        require(itemRaffleEndTime < block.timestamp);\n', '        require(!itemRaffleWinningTicketSelected);\n', '        \n', '        uint256 seed = itemRaffleTicketsBought + block.timestamp;\n', '        itemRaffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, itemRaffleTicketsBought);\n', '        itemRaffleWinningTicketSelected = true;\n', '    }\n', '    \n', '    function drawRandomUnitWinner() public {\n', '        require(msg.sender == owner);\n', '        require(unitRaffleEndTime < block.timestamp);\n', '        require(!unitRaffleWinningTicketSelected);\n', '        \n', '        uint256 seed = unitRaffleTicketsBought + block.timestamp;\n', '        unitRaffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, unitRaffleTicketsBought);\n', '        unitRaffleWinningTicketSelected = true;\n', '    }\n', '    \n', "    // Gives players the upgrades they 'previously paid for' (i.e. will be one of same unit/type/value of their v1 purchase)\n", '    // Tx of their (prior) purchase is provided so can be validated by anyone for 0 abuse\n', '    function migrateV1Upgrades(address[] playerToCredit, uint256[] upgradeIds, uint256[] txProof) external {\n', '        require(msg.sender == owner);\n', '        require(!gameStarted); // Pre-game migration\n', '        \n', '        for (uint256 i = 0; i < txProof.length; i++) {\n', '            address player = playerToCredit[i];\n', '            uint256 upgradeId = upgradeIds[i];\n', '            \n', '            uint256 unitId = schema.upgradeUnitId(upgradeId);\n', "            if (unitId > 0 && !upgradesOwned[player][upgradeId]) { // Upgrade valid (and haven't already migrated)\n", '                uint256 upgradeClass = schema.upgradeClass(upgradeId);\n', '                uint256 upgradeValue = schema.upgradeValue(upgradeId);\n', '        \n', '                upgradeUnitMultipliers(player, upgradeClass, unitId, upgradeValue);\n', '                upgradesOwned[player][upgradeId] = true;\n', '                emit UpgradeMigration(player, upgradeId, txProof[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function protectAddress(address exchange, bool shouldProtect) external {\n', '        require(msg.sender == owner);\n', '        if (shouldProtect) {\n', "            require(getGooProduction(exchange) == 0); // Can't protect actual players\n", '        }\n', '        protectedAddresses[exchange] = shouldProtect;\n', '    }\n', '    \n', '    function attackPlayer(address target) external {\n', '        require(battleCooldown[msg.sender] < block.timestamp);\n', '        require(target != msg.sender);\n', '        require(!protectedAddresses[target]); // Target not whitelisted (i.e. exchange wallets)\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '        (attackingPower, defendingPower, stealingPower) = getPlayersBattlePower(msg.sender, target);\n', '        \n', "        if (battleCooldown[target] > block.timestamp) { // When on battle cooldown you're vulnerable (starting value is 50% normal power)\n", '            defendingPower = schema.getWeakenedDefensePower(defendingPower);\n', '        }\n', '        \n', '        if (attackingPower > defendingPower) {\n', '            battleCooldown[msg.sender] = block.timestamp + 30 minutes;\n', '            if (balanceOf(target) > stealingPower) {\n', "                // Save all their unclaimed goo, then steal attacker's max capacity (at same time)\n", '                uint256 unclaimedGoo = balanceOfUnclaimedGoo(target);\n', '                if (stealingPower > unclaimedGoo) {\n', '                    uint256 gooDecrease = stealingPower - unclaimedGoo;\n', '                    gooBalance[target] -= gooDecrease;\n', '                    roughSupply -= gooDecrease;\n', '                } else {\n', '                    uint256 gooGain = unclaimedGoo - stealingPower;\n', '                    gooBalance[target] += gooGain;\n', '                    roughSupply += gooGain;\n', '                }\n', '                gooBalance[msg.sender] += stealingPower;\n', '                emit PlayerAttacked(msg.sender, target, true, stealingPower);\n', '            } else {\n', '                emit PlayerAttacked(msg.sender, target, true, balanceOf(target));\n', '                gooBalance[msg.sender] += balanceOf(target);\n', '                gooBalance[target] = 0;\n', '            }\n', '            \n', '            lastGooSaveTime[target] = block.timestamp;\n', "            // We don't need to claim/save msg.sender's goo (as production delta is unchanged)\n", '        } else {\n', '            battleCooldown[msg.sender] = block.timestamp + 10 minutes;\n', '            emit PlayerAttacked(msg.sender, target, false, 0);\n', '        }\n', '    }\n', '    \n', '    function getPlayersBattlePower(address attacker, address defender) internal constant returns (uint256, uint256, uint256) {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '\n', '        // Not ideal but will only be a small number of units (and saves gas when buying units)\n', '        while (startId <= endId) {\n', '            attackingPower += getUnitsAttack(attacker, startId, unitsOwned[attacker][startId]);\n', '            stealingPower += getUnitsStealingCapacity(attacker, startId, unitsOwned[attacker][startId]);\n', '            \n', '            defendingPower += getUnitsDefense(defender, startId, unitsOwned[defender][startId]);\n', '            startId++;\n', '        }\n', '        \n', '        return (attackingPower, defendingPower, stealingPower);\n', '    }\n', '    \n', '    function getPlayersBattleStats(address player) external constant returns (uint256, uint256, uint256, uint256) {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        \n', '        uint256 attackingPower;\n', '        uint256 defendingPower;\n', '        uint256 stealingPower;\n', '\n', '        // Not ideal but will only be a small number of units (and saves gas when buying units)\n', '        while (startId <= endId) {\n', '            attackingPower += getUnitsAttack(player, startId, unitsOwned[player][startId]);\n', '            stealingPower += getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]);\n', '            defendingPower += getUnitsDefense(player, startId, unitsOwned[player][startId]);\n', '            startId++;\n', '        }\n', '        \n', "        if (battleCooldown[player] > block.timestamp) { // When on battle cooldown you're vulnerable (starting value is 50% normal power)\n", '            defendingPower = schema.getWeakenedDefensePower(defendingPower);\n', '        }\n', '        \n', '        return (attackingPower, defendingPower, stealingPower, battleCooldown[player]);\n', '    }\n', '    \n', '    function getUnitsProduction(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitGooProduction(unitId) + unitGooProductionIncreases[player][unitId]) * (10 + unitGooProductionMultiplier[player][unitId]));\n', '    }\n', '    \n', '    function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n', '        return (amount * (schema.unitStealingCapacity(unitId) + unitGooStealingIncreases[player][unitId]) * (10 + unitGooStealingMultiplier[player][unitId])) / 10;\n', '    }\n', '    \n', '    \n', '    // To display on website\n', '    function getGameInfo() external constant returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256[], bool[]){\n', '        uint256[] memory units = new uint256[](schema.currentNumberOfUnits());\n', '        bool[] memory upgrades = new bool[](schema.currentNumberOfUpgrades());\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.productionUnitIdRange();\n', '        \n', '        uint256 i;\n', '        while (startId <= endId) {\n', '            units[i] = unitsOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        while (startId <= endId) {\n', '            units[i] = unitsOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        // Reset for upgrades\n', '        i = 0;\n', '        (startId, endId) = schema.upgradeIdRange();\n', '        while (startId <= endId) {\n', '            upgrades[i] = upgradesOwned[msg.sender][startId];\n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        return (block.timestamp, totalEtherGooResearchPool, totalGooProduction, totalGooDepositSnapshots[totalGooDepositSnapshots.length - 1],  gooDepositSnapshots[msg.sender][totalGooDepositSnapshots.length - 1],\n', '        nextSnapshotTime, balanceOf(msg.sender), ethBalance[msg.sender], getGooProduction(msg.sender), units, upgrades);\n', '    }\n', '    \n', '    // To display on website\n', '    function getRareItemInfo() external constant returns (address[], uint256[]) {\n', '        address[] memory itemOwners = new address[](schema.currentNumberOfRares());\n', '        uint256[] memory itemPrices = new uint256[](schema.currentNumberOfRares());\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.rareIdRange();\n', '        \n', '        uint256 i;\n', '        while (startId <= endId) {\n', '            itemOwners[i] = rareItemOwner[startId];\n', '            itemPrices[i] = rareItemPrice[startId];\n', '            \n', '            i++;\n', '            startId++;\n', '        }\n', '        \n', '        return (itemOwners, itemPrices);\n', '    }\n', '    \n', '    // To display on website\n', '    function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {\n', '        uint256 startSnapshot = lastGooResearchFundClaim[msg.sender];\n', '        uint256 latestSnapshot = allocatedGooResearchSnapshots.length - 1; // No snapshots to begin with\n', '        \n', '        uint256 researchShare;\n', "        uint256 previousProduction = gooProductionSnapshots[msg.sender][lastGooResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xfffffffffffff] = 0;\n", '        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n', '            \n', "            // Slightly complex things by accounting for days/snapshots when user made no tx's\n", '            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\n', '            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\n', '            if (productionDuringSnapshot == 0 && !soldAllProduction) {\n', '                productionDuringSnapshot = previousProduction;\n', '            } else {\n', '               previousProduction = productionDuringSnapshot;\n', '            }\n', '            \n', '            researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalGooProductionSnapshots[i];\n', '        }\n', '        return (researchShare, startSnapshot, latestSnapshot);\n', '    }\n', '    \n', '    // To display on website\n', '    function viewUnclaimedDepositDividends() external constant returns (uint256, uint256, uint256) {\n', '        uint256 startSnapshot = lastGooDepositFundClaim[msg.sender];\n', '        uint256 latestSnapshot = allocatedGooDepositSnapshots.length - 1; // No snapshots to begin with\n', '        \n', '        uint256 depositShare;\n', '        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n', '            depositShare += (allocatedGooDepositSnapshots[i] * gooDepositSnapshots[msg.sender][i]) / totalGooDepositSnapshots[i];\n', '        }\n', '        return (depositShare, startSnapshot, latestSnapshot);\n', '    }\n', '    \n', '    \n', '    // To allow clients to verify contestants\n', '    function getItemRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n', '        return (itemRafflePlayers[raffleId]);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getUnitRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n', '        return (unitRafflePlayers[raffleId]);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getPlayersItemTickets(address player) external constant returns (uint256[], uint256[]) {\n', '        TicketPurchases storage playersTickets = rareItemTicketsBoughtByPlayer[player];\n', '        \n', '        if (playersTickets.raffleId == itemRaffleRareId) {\n', '            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n', '            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n', '            \n', '            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n', '                startIds[i] = playersTickets.ticketsBought[i].startId;\n', '                endIds[i] = playersTickets.ticketsBought[i].endId;\n', '            }\n', '        }\n', '        \n', '        return (startIds, endIds);\n', '    }\n', '    \n', '    // To allow clients to verify contestants\n', '    function getPlayersUnitTickets(address player) external constant returns (uint256[], uint256[]) {\n', '        TicketPurchases storage playersTickets = rareUnitTicketsBoughtByPlayer[player];\n', '        \n', '        if (playersTickets.raffleId == unitRaffleId) {\n', '            uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n', '            uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n', '            \n', '            for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n', '                startIds[i] = playersTickets.ticketsBought[i].startId;\n', '                endIds[i] = playersTickets.ticketsBought[i].endId;\n', '            }\n', '        }\n', '        \n', '        return (startIds, endIds);\n', '    }\n', '    \n', '    // To display on website\n', '    function getLatestItemRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n', '        return (itemRaffleEndTime, itemRaffleRareId, itemRaffleTicketsBought, itemRaffleWinner, itemRaffleTicketThatWon);\n', '    }\n', '    \n', '    // To display on website\n', '    function getLatestUnitRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n', '        return (unitRaffleEndTime, unitRaffleRareId, unitRaffleTicketsBought, unitRaffleWinner, unitRaffleTicketThatWon);\n', '    }\n', '    \n', '    \n', '    // New units may be added in future, but check it matches existing schema so no-one can abuse selling.\n', '    function updateGooConfig(address newSchemaAddress) external {\n', '        require(msg.sender == owner);\n', '        \n', '        GooGameConfig newSchema = GooGameConfig(newSchemaAddress);\n', '        \n', '        requireExistingUnitsSame(newSchema);\n', '        requireExistingUpgradesSame(newSchema);\n', '        \n', '        // Finally update config\n', '        schema = GooGameConfig(newSchema);\n', '    }\n', '    \n', '    function requireExistingUnitsSame(GooGameConfig newSchema) internal constant {\n', '        // Requires units eth costs match up or fail execution\n', '        \n', '        uint256 startId;\n', '        uint256 endId;\n', '        (startId, endId) = schema.productionUnitIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\n', '            require(schema.unitGooProduction(startId) == newSchema.unitGooProduction(startId));\n', '            startId++;\n', '        }\n', '        \n', '        (startId, endId) = schema.battleUnitIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.unitEthCost(startId) == newSchema.unitEthCost(startId));\n', '            require(schema.unitAttack(startId) == newSchema.unitAttack(startId));\n', '            require(schema.unitDefense(startId) == newSchema.unitDefense(startId));\n', '            require(schema.unitStealingCapacity(startId) == newSchema.unitStealingCapacity(startId));\n', '            startId++;\n', '        }\n', '    }\n', '    \n', '    function requireExistingUpgradesSame(GooGameConfig newSchema) internal constant {\n', '        uint256 startId;\n', '        uint256 endId;\n', '        \n', '        // Requires ALL upgrade stats match up or fail execution\n', '        (startId, endId) = schema.upgradeIdRange();\n', '        while (startId <= endId) {\n', '            require(schema.upgradeGooCost(startId) == newSchema.upgradeGooCost(startId));\n', '            require(schema.upgradeEthCost(startId) == newSchema.upgradeEthCost(startId));\n', '            require(schema.upgradeClass(startId) == newSchema.upgradeClass(startId));\n', '            require(schema.upgradeUnitId(startId) == newSchema.upgradeUnitId(startId));\n', '            require(schema.upgradeValue(startId) == newSchema.upgradeValue(startId));\n', '            startId++;\n', '        }\n', '        \n', '        // Requires ALL rare stats match up or fail execution\n', '        (startId, endId) = schema.rareIdRange();\n', '        while (startId <= endId) {\n', '            uint256 oldClass;\n', '            uint256 oldUnitId;\n', '            uint256 oldValue;\n', '            \n', '            uint256 newClass;\n', '            uint256 newUnitId;\n', '            uint256 newValue;\n', '            (oldClass, oldUnitId, oldValue) = schema.getRareInfo(startId);\n', '            (newClass, newUnitId, newValue) = newSchema.getRareInfo(startId);\n', '            \n', '            require(oldClass == newClass);\n', '            require(oldUnitId == newUnitId);\n', '            require(oldValue == newValue);\n', '            startId++;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract GooGameConfig {\n', '    \n', '    mapping(uint256 => Unit) private unitInfo;\n', '    mapping(uint256 => Upgrade) private upgradeInfo;\n', '    mapping(uint256 => Rare) private rareInfo;\n', '    \n', '    uint256 public constant currentNumberOfUnits = 15;\n', '    uint256 public constant currentNumberOfUpgrades = 210;\n', '    uint256 public constant currentNumberOfRares = 2;\n', '    \n', '    address public owner;\n', '    \n', '    struct Unit {\n', '        uint256 unitId;\n', '        uint256 baseGooCost;\n', '        uint256 gooCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)\n', '        uint256 ethCost;\n', '        uint256 baseGooProduction;\n', '        \n', '        uint256 attackValue;\n', '        uint256 defenseValue;\n', '        uint256 gooStealingCapacity;\n', '        bool unitSellable; // Rare units (from raffle) not sellable\n', '    }\n', '    \n', '    struct Upgrade {\n', '        uint256 upgradeId;\n', '        uint256 gooCost;\n', '        uint256 ethCost;\n', '        uint256 upgradeClass;\n', '        uint256 unitId;\n', '        uint256 upgradeValue;\n', '        uint256 prerequisiteUpgrade;\n', '    }\n', '    \n', '    struct Rare {\n', '        uint256 rareId;\n', '        uint256 ethCost;\n', '        uint256 rareClass;\n', '        uint256 unitId;\n', '        uint256 rareValue;\n', '    }\n', '    \n', '    function GooGameConfig() public {\n', '        owner = msg.sender;\n', '        \n', '        rareInfo[1] = Rare(1, 0.5 ether, 1, 1, 40); // 40 = +400%\n', '        rareInfo[2] = Rare(2, 0.5 ether, 0, 2, 35); // +35\n', '        \n', '        unitInfo[1] = Unit(1, 0, 10, 0, 2, 0, 0, 0, true);\n', '        unitInfo[2] = Unit(2, 100, 50, 0, 5, 0, 0, 0, true);\n', '        unitInfo[3] = Unit(3, 0, 0, 0.01 ether, 100, 0, 0, 0, true);\n', '        unitInfo[4] = Unit(4, 200, 100, 0, 10, 0, 0, 0, true);\n', '        unitInfo[5] = Unit(5, 500, 250, 0, 20, 0, 0, 0, true);\n', '        unitInfo[6] = Unit(6, 1000, 500, 0, 40, 0, 0, 0, true);\n', '        unitInfo[7] = Unit(7, 0, 1000, 0.05 ether, 500, 0, 0, 0, true);\n', '        unitInfo[8] = Unit(8, 1500, 750, 0, 60, 0, 0, 0, true);\n', '        unitInfo[9] = Unit(9, 0, 0, 10 ether, 6000, 0, 0, 0, false); // First secret rare unit from raffle (unsellable)\n', '        \n', '        unitInfo[40] = Unit(40, 50, 25, 0, 0, 10, 10, 10000, true);\n', '        unitInfo[41] = Unit(41, 100, 50, 0, 0, 1, 25, 500, true);\n', '        unitInfo[42] = Unit(42, 0, 0, 0.01 ether, 0, 200, 10, 50000, true);\n', '        unitInfo[43] = Unit(43, 250, 125, 0, 0, 25, 1, 15000, true);\n', '        unitInfo[44] = Unit(44, 500, 250, 0, 0, 20, 40, 5000, true);\n', '        unitInfo[45] = Unit(45, 0, 2500, 0.02 ether, 0, 0, 0, 100000, true);\n', '    }\n', '    \n', '    address allowedConfig;\n', '    function setConfigSetupContract(address schema) external {\n', '        require(msg.sender == owner);\n', '        allowedConfig = schema;\n', '    }\n', '    \n', '    function addUpgrade(uint256 id, uint256 goo, uint256 eth, uint256 class, uint256 unit, uint256 value, uint256 prereq) external {\n', '        require(msg.sender == allowedConfig);\n', '        upgradeInfo[id] = Upgrade(id, goo, eth, class, unit, value, prereq);\n', '    }\n', '    \n', '    function getGooCostForUnit(uint256 unitId, uint256 existing, uint256 amount) public constant returns (uint256) {\n', '        Unit storage unit = unitInfo[unitId];\n', '        if (amount == 1) { // 1\n', '            if (existing == 0) {\n', '                return unit.baseGooCost;\n', '            } else {\n', '                return unit.baseGooCost + (existing * unit.gooCostIncreaseHalf * 2);\n', '            }\n', '        } else if (amount > 1) {\n', '            uint256 existingCost;\n', '            if (existing > 0) { // Gated by unit limit\n', '                existingCost = (unit.baseGooCost * existing) + (existing * (existing - 1) * unit.gooCostIncreaseHalf);\n', '            }\n', '            \n', '            existing = SafeMath.add(existing, amount);\n', '            return SafeMath.add(SafeMath.mul(unit.baseGooCost, existing), SafeMath.mul(SafeMath.mul(existing, (existing - 1)), unit.gooCostIncreaseHalf)) - existingCost;\n', '        }\n', '    }\n', '    \n', '    function getWeakenedDefensePower(uint256 defendingPower) external constant returns (uint256) {\n', '        return defendingPower / 2;\n', '    }\n', '    \n', '    function validRareId(uint256 rareId) external constant returns (bool) {\n', '        return (rareId > 0 && rareId < 3);\n', '    }\n', '    \n', '    function unitSellable(uint256 unitId) external constant returns (bool) {\n', '        return unitInfo[unitId].unitSellable;\n', '    }\n', '    \n', '    function unitEthCost(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].ethCost;\n', '    }\n', '    \n', '    function unitGooProduction(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].baseGooProduction;\n', '    }\n', '    \n', '    function unitAttack(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].attackValue;\n', '    }\n', '    \n', '    function unitDefense(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].defenseValue;\n', '    }\n', '    \n', '    function unitStealingCapacity(uint256 unitId) external constant returns (uint256) {\n', '        return unitInfo[unitId].gooStealingCapacity;\n', '    }\n', '    \n', '    function rareStartPrice(uint256 rareId) external constant returns (uint256) {\n', '        return rareInfo[rareId].ethCost;\n', '    }\n', '    \n', '    function upgradeGooCost(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].gooCost;\n', '    }\n', '    \n', '    function upgradeEthCost(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].ethCost;\n', '    }\n', '    \n', '    function upgradeClass(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].upgradeClass;\n', '    }\n', '    \n', '    function upgradeUnitId(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].unitId;\n', '    }\n', '    \n', '    function upgradeValue(uint256 upgradeId) external constant returns (uint256) {\n', '        return upgradeInfo[upgradeId].upgradeValue;\n', '    }\n', '    \n', '    function productionUnitIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 9);\n', '    }\n', '    \n', '    function battleUnitIdRange() external constant returns (uint256, uint256) {\n', '        return (40, 45);\n', '    }\n', '    \n', '    function upgradeIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 210);\n', '    }\n', '    \n', '    function rareIdRange() external constant returns (uint256, uint256) {\n', '        return (1, 2);\n', '    }\n', '    \n', '    function getUpgradeInfo(uint256 upgradeId) external constant returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (upgradeInfo[upgradeId].gooCost, upgradeInfo[upgradeId].ethCost, upgradeInfo[upgradeId].upgradeClass,\n', '        upgradeInfo[upgradeId].unitId, upgradeInfo[upgradeId].upgradeValue, upgradeInfo[upgradeId].prerequisiteUpgrade);\n', '    }\n', '    \n', '    function getRareInfo(uint256 rareId) external constant returns (uint256, uint256, uint256) {\n', '        return (rareInfo[rareId].rareClass, rareInfo[rareId].unitId, rareInfo[rareId].rareValue);\n', '    }\n', '    \n', '    function getUnitInfo(uint256 unitId, uint256 existing, uint256 amount) external constant returns (uint256, uint256, uint256, uint256) {\n', '        return (unitInfo[unitId].unitId, unitInfo[unitId].baseGooProduction, getGooCostForUnit(unitId, existing, amount), SafeMath.mul(unitInfo[unitId].ethCost, amount));\n', '    }\n', '    \n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
