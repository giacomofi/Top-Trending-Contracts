['pragma solidity ^0.4.20;\n', '\n', '/*\n', '\n', 'author : RNDM (Discord RNDM#3033)\n', 'Write me if you need coding service\n', 'My Ethereum address : 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96\n', '\n', 'Description tl;dr :\n', 'Simple trustless lottery with entries\n', 'After the contract reaches a certain amount of ethereum or when the owner calls "payWinnerManually()"\n', 'a winner gets calculated/drawed and paid out (10% fee for token giveaways).\n', '\n', '*/\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = 0xc42559F88481e1Df90f64e5E9f7d7C6A34da5691;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', 'contract Lottery is Ownable {\n', '\n', '    // The tokens can never be stolen\n', '    modifier secCheck(address aContract) {\n', '        require(aContract != address(contractCall));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Events\n', '    */\n', '\n', '    event BoughtTicket(uint256 amount, address customer, uint yourEntry);\n', '    event WinnerPaid(uint256 amount, address winner);\n', '\n', '\n', '    /**\n', '    * Data\n', '    */\n', '\n', '    _Contract contractCall;  // a reference to the contract\n', '    address[] public entries; // array with entries\n', '    uint256 entryCounter; // counter for the entries\n', '    uint256 public automaticThreshold; // automatic Threshold to close the lottery and pay the winner\n', '    uint256 public ticketPrice = 10 finney; // the price per lottery ticket (0.01 eth)\n', '    \n', '\n', '\n', '\n', '\n', '    constructor() public {\n', '        contractCall = _Contract(0x05215FCE25902366480696F38C3093e31DBCE69A);\n', '        automaticThreshold = 56; // 56 tickets \n', '        ticketPrice = 10 finney; // 10finney = 0.01 eth\n', '        entryCounter = 0;\n', '    }\n', '\n', '    // If you send money directly to the contract it gets treated like a donation\n', '    function() payable public {\n', '    }\n', '\n', '\n', '    function buyTickets() payable public {\n', '        //You have to send at least ticketPrice to get one entry\n', '        require(msg.value >= ticketPrice);\n', '\n', '        address customerAddress = msg.sender;\n', '        //Use deposit to purchase _Contract tokens\n', '        contractCall.buy.value(msg.value)(customerAddress);\n', '        // add customer to the entry list\n', '        if (entryCounter == (entries.length)) {\n', '            entries.push(customerAddress);\n', '            }\n', '        else {\n', '            entries[entryCounter] = customerAddress;\n', '        }\n', '        // increment the entry counter\n', '        entryCounter++;\n', '        //fire event\n', '        emit BoughtTicket(msg.value, msg.sender, entryCounter);\n', '\n', '         //Automatic Treshhold, checks if the always incremented entryCounter reached the threshold\n', '        if(entryCounter >= automaticThreshold) {\n', '            // withdraw + sell all tokens.\n', '            contractCall.exit();\n', '            // 10% token giveaway fee\n', '            giveawayFee();\n', '            //payout winner & start from beginning\n', '            payWinner();\n', '        }\n', '    }\n', '\n', '    // Other functions\n', ' \n', '    /*\n', '    PRNG(Pseudorandom number generator) :\n', '    PRN can be 0 up to entrycounter-1. (equivalent to 1 up to entrycounter)\n', '    n := entrycounter\n', '\n', '    Let n be an arbitrary number \n', '    and\n', '    y := uint256(keccak256(P)) where P is an arbitrary value.\n', '    The returned PRN % (n) is going to be between\n', '    0 and n-1 due to modular arithmetic.\n', '    */\n', '    function PRNG() internal view returns (uint256) {\n', '        uint256 initialize1 = block.timestamp;\n', '        uint256 initialize2 = uint256(block.coinbase);\n', '        uint256 initialize3 = uint256(blockhash(entryCounter));\n', '        uint256 initialize4 = block.number;\n', '        uint256 initialize5 = block.gaslimit;\n', '        uint256 initialize6 = block.difficulty;\n', '\n', '        uint256 calc1 = uint256(keccak256(abi.encodePacked((initialize1 * 5),initialize5,initialize6)));\n', '        uint256 calc2 = 1-calc1;\n', '        int256 ov = int8(calc2);\n', '        uint256 calc3 = uint256(sha256(abi.encodePacked(initialize1,ov,initialize3,initialize4)));\n', '        uint256 PRN = uint256(keccak256(abi.encodePacked(initialize1,calc1,initialize2,initialize3,calc3)))%(entryCounter);\n', '        return PRN;\n', '    }\n', '    \n', '\n', '    // Choose a winner and pay him\n', '    function payWinner() internal returns (address) {\n', '        uint256 balance = address(this).balance;\n', '        uint256 number = PRNG(); // generates a pseudorandom number\n', '        address winner = entries[number]; // choose the winner with the pseudorandom number\n', '        winner.transfer(balance); // payout winner\n', '        entryCounter = 0; // Zero entries again => Lottery resetted\n', '\n', '        emit WinnerPaid(balance, winner);\n', '        return winner;\n', '    }\n', '\n', '    //\n', '    function giveawayFee() internal {   \n', '        uint256 balance = (address(this).balance / 10);\n', '        owner.transfer(balance);\n', '    }\n', '\n', '    /*\n', '        If you plan to use this contract for your projects\n', '        be a man of honor and do not change or delete this function\n', '    */\n', '    function donateToDev() payable public {\n', '        address developer = 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96;\n', '        developer.transfer(msg.value);\n', '    }\n', '\n', '    //Number of tokens currently in the Lottery pool\n', '    function myTokens() public view returns(uint256) {\n', '        return contractCall.myTokens();\n', '    }\n', '\n', '    //Amount of dividends currently in the Lottery pool\n', '    function myDividends() public view returns(uint256) {\n', '        return contractCall.myDividends(true);\n', '    }\n', '\n', '\n', '    /**\n', '    * Administrator functions\n', '    */\n', '\n', '    // change the Threshold\n', '    function changeThreshold(uint newThreshold) onlyOwner() public {\n', '        // Owner is only able to change the threshold when no one bought (otherwise it would be unfair)\n', '        require(entryCounter == 0);\n', '        automaticThreshold = newThreshold;\n', '    }\n', '\n', '    function changeTicketPrice(uint newticketPrice) onlyOwner() public {\n', '        // Owner is only able to change the ticket price when no one bought (otherwise it would be unfair)\n', '        require(entryCounter == 0);\n', '        ticketPrice = newticketPrice;\n', '    }\n', '\n', '    // Admin can call the payWinner (ends lottery round & starts a new one) if it takes too long to reach the threshold\n', '    function payWinnerManually() public onlyOwner() returns (address) {\n', '        address winner = payWinner();\n', '        return winner;\n', '    }\n', '\n', '    // check special functions\n', '    function imAlive() public onlyOwner() {\n', '        inactivity = 1;\n', '    }\n', '    /**\n', '    * Special functions\n', '    */\n', '\n', '    /* \n', '    *   In case the threshold is way too high and the owner/admin disappeared (inactive for 30days)\n', '    *   Everyone can call this function then the timestamp gets saved\n', '    *   after 30 days of owner-inactivity someone can call the function again and calls payWinner with it\n', '    */\n', '    uint inactivity = 1;\n', '    function adminIsDead() public {\n', '        if (inactivity == 1) {\n', '            inactivity == block.timestamp;\n', '        }\n', '        else {\n', '            uint256 inactivityThreshold = (block.timestamp - (30 days));\n', '            assert(inactivityThreshold < block.timestamp);\n', '            if (inactivity < inactivityThreshold) {\n', '                inactivity = 1;\n', '                payWinnerManually2();\n', '            }\n', '        }\n', '    }\n', '\n', '    function payWinnerManually2() internal {\n', '        payWinner();\n', '    }\n', '\n', '\n', '     /* A trap door for when someone sends tokens other than the intended ones so the overseers\n', '      can decide where to send them. (credit: Doublr Contract) */\n', '    function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner() secCheck(tokenAddress) returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '//Need to ensure this contract can send tokens to people\n', 'contract ERC20Interface\n', '{\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', '// Interface to actually call contract functions of e.g. REV1\n', 'contract _Contract\n', '{\n', '    function buy(address) public payable returns(uint256);\n', '    function exit() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '/*\n', '\n', 'author : RNDM (Discord RNDM#3033)\n', 'Write me if you need coding service\n', 'My Ethereum address : 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96\n', '\n', 'Description tl;dr :\n', 'Simple trustless lottery with entries\n', 'After the contract reaches a certain amount of ethereum or when the owner calls "payWinnerManually()"\n', 'a winner gets calculated/drawed and paid out (10% fee for token giveaways).\n', '\n', '*/\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipRenounced(address indexed previousOwner);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() public {\n', '        owner = 0xc42559F88481e1Df90f64e5E9f7d7C6A34da5691;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipRenounced(owner);\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', 'contract Lottery is Ownable {\n', '\n', '    // The tokens can never be stolen\n', '    modifier secCheck(address aContract) {\n', '        require(aContract != address(contractCall));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Events\n', '    */\n', '\n', '    event BoughtTicket(uint256 amount, address customer, uint yourEntry);\n', '    event WinnerPaid(uint256 amount, address winner);\n', '\n', '\n', '    /**\n', '    * Data\n', '    */\n', '\n', '    _Contract contractCall;  // a reference to the contract\n', '    address[] public entries; // array with entries\n', '    uint256 entryCounter; // counter for the entries\n', '    uint256 public automaticThreshold; // automatic Threshold to close the lottery and pay the winner\n', '    uint256 public ticketPrice = 10 finney; // the price per lottery ticket (0.01 eth)\n', '    \n', '\n', '\n', '\n', '\n', '    constructor() public {\n', '        contractCall = _Contract(0x05215FCE25902366480696F38C3093e31DBCE69A);\n', '        automaticThreshold = 56; // 56 tickets \n', '        ticketPrice = 10 finney; // 10finney = 0.01 eth\n', '        entryCounter = 0;\n', '    }\n', '\n', '    // If you send money directly to the contract it gets treated like a donation\n', '    function() payable public {\n', '    }\n', '\n', '\n', '    function buyTickets() payable public {\n', '        //You have to send at least ticketPrice to get one entry\n', '        require(msg.value >= ticketPrice);\n', '\n', '        address customerAddress = msg.sender;\n', '        //Use deposit to purchase _Contract tokens\n', '        contractCall.buy.value(msg.value)(customerAddress);\n', '        // add customer to the entry list\n', '        if (entryCounter == (entries.length)) {\n', '            entries.push(customerAddress);\n', '            }\n', '        else {\n', '            entries[entryCounter] = customerAddress;\n', '        }\n', '        // increment the entry counter\n', '        entryCounter++;\n', '        //fire event\n', '        emit BoughtTicket(msg.value, msg.sender, entryCounter);\n', '\n', '         //Automatic Treshhold, checks if the always incremented entryCounter reached the threshold\n', '        if(entryCounter >= automaticThreshold) {\n', '            // withdraw + sell all tokens.\n', '            contractCall.exit();\n', '            // 10% token giveaway fee\n', '            giveawayFee();\n', '            //payout winner & start from beginning\n', '            payWinner();\n', '        }\n', '    }\n', '\n', '    // Other functions\n', ' \n', '    /*\n', '    PRNG(Pseudorandom number generator) :\n', '    PRN can be 0 up to entrycounter-1. (equivalent to 1 up to entrycounter)\n', '    n := entrycounter\n', '\n', '    Let n be an arbitrary number \n', '    and\n', '    y := uint256(keccak256(P)) where P is an arbitrary value.\n', '    The returned PRN % (n) is going to be between\n', '    0 and n-1 due to modular arithmetic.\n', '    */\n', '    function PRNG() internal view returns (uint256) {\n', '        uint256 initialize1 = block.timestamp;\n', '        uint256 initialize2 = uint256(block.coinbase);\n', '        uint256 initialize3 = uint256(blockhash(entryCounter));\n', '        uint256 initialize4 = block.number;\n', '        uint256 initialize5 = block.gaslimit;\n', '        uint256 initialize6 = block.difficulty;\n', '\n', '        uint256 calc1 = uint256(keccak256(abi.encodePacked((initialize1 * 5),initialize5,initialize6)));\n', '        uint256 calc2 = 1-calc1;\n', '        int256 ov = int8(calc2);\n', '        uint256 calc3 = uint256(sha256(abi.encodePacked(initialize1,ov,initialize3,initialize4)));\n', '        uint256 PRN = uint256(keccak256(abi.encodePacked(initialize1,calc1,initialize2,initialize3,calc3)))%(entryCounter);\n', '        return PRN;\n', '    }\n', '    \n', '\n', '    // Choose a winner and pay him\n', '    function payWinner() internal returns (address) {\n', '        uint256 balance = address(this).balance;\n', '        uint256 number = PRNG(); // generates a pseudorandom number\n', '        address winner = entries[number]; // choose the winner with the pseudorandom number\n', '        winner.transfer(balance); // payout winner\n', '        entryCounter = 0; // Zero entries again => Lottery resetted\n', '\n', '        emit WinnerPaid(balance, winner);\n', '        return winner;\n', '    }\n', '\n', '    //\n', '    function giveawayFee() internal {   \n', '        uint256 balance = (address(this).balance / 10);\n', '        owner.transfer(balance);\n', '    }\n', '\n', '    /*\n', '        If you plan to use this contract for your projects\n', '        be a man of honor and do not change or delete this function\n', '    */\n', '    function donateToDev() payable public {\n', '        address developer = 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96;\n', '        developer.transfer(msg.value);\n', '    }\n', '\n', '    //Number of tokens currently in the Lottery pool\n', '    function myTokens() public view returns(uint256) {\n', '        return contractCall.myTokens();\n', '    }\n', '\n', '    //Amount of dividends currently in the Lottery pool\n', '    function myDividends() public view returns(uint256) {\n', '        return contractCall.myDividends(true);\n', '    }\n', '\n', '\n', '    /**\n', '    * Administrator functions\n', '    */\n', '\n', '    // change the Threshold\n', '    function changeThreshold(uint newThreshold) onlyOwner() public {\n', '        // Owner is only able to change the threshold when no one bought (otherwise it would be unfair)\n', '        require(entryCounter == 0);\n', '        automaticThreshold = newThreshold;\n', '    }\n', '\n', '    function changeTicketPrice(uint newticketPrice) onlyOwner() public {\n', '        // Owner is only able to change the ticket price when no one bought (otherwise it would be unfair)\n', '        require(entryCounter == 0);\n', '        ticketPrice = newticketPrice;\n', '    }\n', '\n', '    // Admin can call the payWinner (ends lottery round & starts a new one) if it takes too long to reach the threshold\n', '    function payWinnerManually() public onlyOwner() returns (address) {\n', '        address winner = payWinner();\n', '        return winner;\n', '    }\n', '\n', '    // check special functions\n', '    function imAlive() public onlyOwner() {\n', '        inactivity = 1;\n', '    }\n', '    /**\n', '    * Special functions\n', '    */\n', '\n', '    /* \n', '    *   In case the threshold is way too high and the owner/admin disappeared (inactive for 30days)\n', '    *   Everyone can call this function then the timestamp gets saved\n', '    *   after 30 days of owner-inactivity someone can call the function again and calls payWinner with it\n', '    */\n', '    uint inactivity = 1;\n', '    function adminIsDead() public {\n', '        if (inactivity == 1) {\n', '            inactivity == block.timestamp;\n', '        }\n', '        else {\n', '            uint256 inactivityThreshold = (block.timestamp - (30 days));\n', '            assert(inactivityThreshold < block.timestamp);\n', '            if (inactivity < inactivityThreshold) {\n', '                inactivity = 1;\n', '                payWinnerManually2();\n', '            }\n', '        }\n', '    }\n', '\n', '    function payWinnerManually2() internal {\n', '        payWinner();\n', '    }\n', '\n', '\n', '     /* A trap door for when someone sends tokens other than the intended ones so the overseers\n', '      can decide where to send them. (credit: Doublr Contract) */\n', '    function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner() secCheck(tokenAddress) returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n', '    }\n', '\n', '\n', '}\n', '\n', '\n', '//Need to ensure this contract can send tokens to people\n', 'contract ERC20Interface\n', '{\n', '    function transfer(address to, uint256 tokens) public returns (bool success);\n', '}\n', '\n', '// Interface to actually call contract functions of e.g. REV1\n', 'contract _Contract\n', '{\n', '    function buy(address) public payable returns(uint256);\n', '    function exit() public;\n', '    function myTokens() public view returns(uint256);\n', '    function myDividends(bool) public view returns(uint256);\n', '}']
