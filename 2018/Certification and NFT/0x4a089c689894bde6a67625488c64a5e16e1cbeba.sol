['pragma solidity ^0.4.13;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n', '    totalSupply_ = totalSupply_.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(address(0), _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting() onlyOwner canMint public returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract NectarToken is MintableToken {\n', '    string public name = "Nectar";\n', '    string public symbol = "NCT";\n', '    uint8 public decimals = 18;\n', '\n', '    bool public transfersEnabled = false;\n', '    event TransfersEnabled();\n', '\n', '    // Disable transfers until after the sale\n', '    modifier whenTransfersEnabled() {\n', '        require(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    modifier whenTransfersNotEnabled() {\n', '        require(!transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    function enableTransfers() onlyOwner whenTransfersNotEnabled public {\n', '        transfersEnabled = true;\n', '        TransfersEnabled();\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public whenTransfersEnabled returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public whenTransfersEnabled returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    // Approves and then calls the receiving contract\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        // call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        // receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        // it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        require(_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData));\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract NectarCrowdsale is Ownable, Pausable {\n', '    using SafeMath for uint256;\n', '\n', '    /** Maximum amount to raise in USD based on initial exchange rate */\n', '    uint256 constant maxCapUsd = 50000000;\n', '    /** Minumum amount per purchase in USD based on initial exchange rate*/\n', '    uint256 constant minimumPurchaseUsd = 100;\n', '\n', '    /** Tranche parameters */\n', '    uint256 constant tranche1ThresholdUsd = 5000000;\n', '    uint256 constant tranche1Rate = 37604;\n', '    uint256 constant tranche2ThresholdUsd = 10000000;\n', '    uint256 constant tranche2Rate = 36038;\n', '    uint256 constant tranche3ThresholdUsd = 15000000;\n', '    uint256 constant tranche3Rate = 34471;\n', '    uint256 constant tranche4ThresholdUsd = 20000000;\n', '    uint256 constant tranche4Rate = 32904;\n', '    uint256 constant standardTrancheRate= 31337;\n', '\n', '    /** The token being sold */\n', '    NectarToken public token;\n', '\n', '    /** Start timestamp when token purchases are allowed, inclusive */\n', '    uint256 public startTime;\n', '\n', '    /** End timestamp when token purchases are allowed, inclusive */\n', '    uint256 public endTime;\n', '\n', '    /** Set value of wei/usd used in cap and minimum purchase calculation */\n', '    uint256 public weiUsdExchangeRate;\n', '\n', '    /** Address where funds are collected */\n', '    address public wallet;\n', '\n', '    /** Address used to sign purchase authorizations */\n', '    address public purchaseAuthorizer;\n', '\n', '    /** Total amount of raised money in wei */\n', '    uint256 public weiRaised;\n', '\n', '    /** Cap in USD */\n', '    uint256 public capUsd;\n', '\n', '    /** Maximum amount of raised money in wei */\n', '    uint256 public cap;\n', '\n', '    /** Minumum amount of wei per purchase */\n', '    uint256 public minimumPurchase;\n', '\n', '    /** Have we canceled the sale? */\n', '    bool public isCanceled;\n', '\n', '    /** have we finalized the sale? */\n', '    bool public isFinalized;\n', '\n', '    /** Record of nonces -> purchases */\n', '    mapping (uint256 => bool) public purchases;\n', '\n', '    /**\n', '     * Event triggered on presale minting\n', '     * @param purchaser who paid for the tokens\n', '     * @param amount amount of tokens minted\n', '     */\n', '    event PreSaleMinting(address indexed purchaser, uint256 amount);\n', '\n', '    /**\n', '     * Event triggered on token purchase\n', '     * @param purchaser who paid for the tokens\n', '     * @param value wei paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '\n', '    /** Event triggered on sale cancelation */\n', '    event Canceled();\n', '\n', '    /** Event triggered on sale finalization */\n', '    event Finalized();\n', '\n', '    /**\n', '     * NectarCrowdsale constructor\n', '     * @param _startTime start timestamp when purchases are allowed, inclusive\n', '     * @param _endTime end timestamp when purchases are allowed, inclusive\n', '     * @param _initialWeiUsdExchangeRate initial rate of wei/usd used in cap and minimum purchase calculation\n', '     * @param _wallet wallet in which to collect the funds\n', '     * @param _purchaseAuthorizer address to verify purchase authorizations from\n', '     */\n', '    function NectarCrowdsale(\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        uint256 _initialWeiUsdExchangeRate,\n', '        address _wallet,\n', '        address _purchaseAuthorizer\n', '    )\n', '        public\n', '    {\n', '        require(_startTime >= now);\n', '        require(_endTime >= _startTime);\n', '        require(_initialWeiUsdExchangeRate > 0);\n', '        require(_wallet != address(0));\n', '        require(_purchaseAuthorizer != address(0));\n', '\n', '        token = createTokenContract();\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        weiUsdExchangeRate = _initialWeiUsdExchangeRate;\n', '        wallet = _wallet;\n', '        purchaseAuthorizer = _purchaseAuthorizer;\n', '\n', '        capUsd = maxCapUsd;\n', '\n', '        // Updates cap and minimumPurchase based on capUsd and weiUsdExchangeRate\n', '        updateCapAndExchangeRate();\n', '\n', '        isCanceled = false;\n', '        isFinalized = false;\n', '    }\n', '\n', '    /** Disable usage of the fallback function, only accept eth from buyTokens */\n', '    function () external payable {\n', '        revert();\n', '    }\n', '\n', '    /** Only allow before the sale period */\n', '    modifier onlyPreSale() {\n', '        require(now < startTime);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Directly mint tokens and assign to presale buyers\n', '     * @param purchaser Address to assign to\n', '     * @param tokenAmount amount of tokens to mint\n', '     */\n', '    function mintPreSale(address purchaser, uint256 tokenAmount) public onlyOwner onlyPreSale {\n', '        require(purchaser != address(0));\n', '        require(tokenAmount > 0);\n', '\n', '        token.mint(purchaser, tokenAmount);\n', '        PreSaleMinting(purchaser, tokenAmount);\n', '    }\n', '\n', '    /**\n', '     * Buy tokens once authorized by the frontend\n', '     * @param nonce nonce parameter generated by the frontend\n', '     * @param authorizedAmount maximum purchase amount authorized for this transaction\n', '     * @param sig the signature generated by the frontned\n', '     */\n', '    function buyTokens(uint256 authorizedAmount, uint256 nonce, bytes sig) public payable whenNotPaused {\n', '        require(msg.sender != address(0));\n', '        require(validPurchase(authorizedAmount, nonce, sig));\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 rate = currentTranche();\n', '        uint256 tokens = weiAmount.mul(rate);\n', '\n', '        // update state\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        purchases[nonce] = true;\n', '\n', '        token.mint(msg.sender, tokens);\n', '        TokenPurchase(msg.sender, weiAmount, tokens);\n', '\n', '        forwardFunds();\n', '    }\n', '\n', '    /** Cancel the sale */\n', '    function cancel() public onlyOwner {\n', '        require(!isCanceled);\n', '        require(!hasEnded());\n', '\n', '        Canceled();\n', '        isCanceled = true;\n', '    }\n', '\n', '    /** Finalize the sale */\n', '    function finalize() public onlyOwner {\n', '        require(!isFinalized);\n', '        require(hasEnded());\n', '\n', '        finalization();\n', '        Finalized();\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /**\n', '     * Set exchange rate before sale\n', '     * @param _weiUsdExchangeRate rate of wei/usd used in cap and minimum purchase calculation\n', '     */\n', '    function setExchangeRate(uint256 _weiUsdExchangeRate) public onlyOwner onlyPreSale {\n', '        require(_weiUsdExchangeRate > 0);\n', '\n', '        weiUsdExchangeRate = _weiUsdExchangeRate;\n', '        updateCapAndExchangeRate();\n', '    }\n', '\n', '    /**\n', '     * Set exchange rate before sale\n', '     * @param _capUsd new cap in USD\n', '     */\n', '    function setCapUsd(uint256 _capUsd) public onlyOwner onlyPreSale {\n', '        require(_capUsd <= maxCapUsd);\n', '\n', '        capUsd = _capUsd;\n', '        updateCapAndExchangeRate();\n', '    }\n', '\n', '    /** Enable token sales once sale is completed */\n', '    function enableTransfers() public onlyOwner {\n', '        require(isFinalized);\n', '        require(hasEnded());\n', '\n', '        token.enableTransfers();\n', '    }\n', '\n', '    /**\n', '     * Get the rate of tokens/wei in the current tranche\n', '     * @return the current tokens/wei rate\n', '     */\n', '    function currentTranche() public view returns (uint256) {\n', '        uint256 currentFundingUsd = weiRaised.div(weiUsdExchangeRate);\n', '        if (currentFundingUsd <= tranche1ThresholdUsd) {\n', '            return tranche1Rate;\n', '        } else if (currentFundingUsd <= tranche2ThresholdUsd) {\n', '            return tranche2Rate;\n', '        } else if (currentFundingUsd <= tranche3ThresholdUsd) {\n', '            return tranche3Rate;\n', '        } else if (currentFundingUsd <= tranche4ThresholdUsd) {\n', '            return tranche4Rate;\n', '        } else {\n', '            return standardTrancheRate;\n', '        }\n', '    }\n', '\n', '    /** @return true if crowdsale event has ended */\n', '    function hasEnded() public view returns (bool) {\n', '        bool afterEnd = now > endTime;\n', '        bool capMet = weiRaised >= cap;\n', '        return afterEnd || capMet || isCanceled;\n', '    }\n', '\n', '    /** Get the amount collected in USD, needed for WINGS calculation. */\n', '    function totalCollected() public view returns (uint256) {\n', '        uint256 presale = maxCapUsd.sub(capUsd);\n', '        uint256 crowdsale = weiRaised.div(weiUsdExchangeRate);\n', '        return presale.add(crowdsale);\n', '    }\n', '\n', '    /** Creates the token to be sold. */\n', '    function createTokenContract() internal returns (NectarToken) {\n', '        return new NectarToken();\n', '    }\n', '\n', '    /** Create the 30% extra token supply at the end of the sale */\n', '    function finalization() internal {\n', '        // Create 30% NCT for company use\n', '        uint256 tokens = token.totalSupply().mul(3).div(10);\n', '        token.mint(wallet, tokens);\n', '    }\n', '\n', '    /** Forward ether to the fund collection wallet */\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    /** Update parameters dependant on capUsd and eiUsdEchangeRate */\n', '    function updateCapAndExchangeRate() internal {\n', '        cap = capUsd.mul(weiUsdExchangeRate);\n', '        minimumPurchase = minimumPurchaseUsd.mul(weiUsdExchangeRate);\n', '    }\n', '\n', '    /**\n', '     * Is a purchase transaction valid?\n', '     * @return true if the transaction can buy tokens\n', '     */\n', '    function validPurchase(uint256 authorizedAmount, uint256 nonce, bytes sig) internal view returns (bool) {\n', '        // 84 = 20 byte address + 32 byte authorized amount + 32 byte nonce\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n84";\n', '        bytes32 hash = keccak256(prefix, msg.sender, authorizedAmount, nonce);\n', '        bool validAuthorization = ECRecovery.recover(hash, sig) == purchaseAuthorizer;\n', '\n', '        bool validNonce = !purchases[nonce];\n', '        bool withinPeriod = now >= startTime && now <= endTime;\n', '        bool aboveMinimum = msg.value >= minimumPurchase;\n', '        bool belowAuthorized = msg.value <= authorizedAmount;\n', '        bool belowCap = weiRaised.add(msg.value) <= cap;\n', '        return validAuthorization && validNonce && withinPeriod && aboveMinimum && belowAuthorized && belowCap;\n', '    }\n', '}\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using his signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig) public pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}']