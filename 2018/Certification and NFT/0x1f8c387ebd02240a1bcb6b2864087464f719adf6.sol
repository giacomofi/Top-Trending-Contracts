['pragma solidity 0.4.24;\n', '\n', '// (c) 2018 SecureVote (Exo One Pty Ltd)\n', '\n', 'contract BBFarmEvents {\n', '    event BallotCreatedWithID(uint ballotId);\n', '    event BBFarmInit(bytes4 namespace);\n', '    event Sponsorship(uint ballotId, uint value);\n', '    event Vote(uint indexed ballotId, bytes32 vote, address voter, bytes extra);\n', '    event BallotOnForeignNetwork(bytes32 networkId, uint ballotId);  // added 2018-06-25 for BBFarmForeign support\n', '}\n', '\n', 'library BBLibV7 {\n', '    using BytesLib for bytes;\n', '\n', '    // ballot meta\n', '    uint256 constant BB_VERSION = 7;\n', '    /* 4 deprecated due to insecure vote by proxy\n', '       5 deprecated to\n', '        - add `returns (address)` to submitProxyVote\n', '       7 - adds submitVoteAlways (does not check open/close time)\n', '           useful for remote bbfarms\n', '    */\n', '\n', '    // voting settings\n', '    uint16 constant USE_ETH = 1;          // 2^0\n', '    uint16 constant USE_SIGNED = 2;       // 2^1\n', '    uint16 constant USE_NO_ENC = 4;       // 2^2\n', '    uint16 constant USE_ENC = 8;          // 2^3\n', '\n', '    // ballot settings\n', '    uint16 constant IS_BINDING = 8192;    // 2^13\n', '    uint16 constant IS_OFFICIAL = 16384;  // 2^14\n', '    uint16 constant USE_TESTING = 32768;  // 2^15\n', '\n', '    // other consts\n', '    uint32 constant MAX_UINT32 = 0xFFFFFFFF;\n', '\n', '    //// ** Storage Variables\n', '\n', '    // struct for ballot\n', '    struct Vote {\n', '        bytes32 voteData;\n', '        bytes32 castTsAndSender;\n', '        bytes extra;\n', '    }\n', '\n', '    struct Sponsor {\n', '        address sender;\n', '        uint amount;\n', '    }\n', '\n', '    //// ** Events\n', '    event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\n', '    event SuccessfulVote(address indexed voter, uint voteId);\n', '    event SeckeyRevealed(bytes32 secretKey);\n', '    event TestingEnabled();\n', '    event DeprecatedContract();\n', '\n', '\n', '    // The big database struct\n', '\n', '\n', '    struct DB {\n', '        // Maps to store ballots, along with corresponding log of voters.\n', '        // Should only be modified through internal functions\n', '        mapping (uint256 => Vote) votes;\n', '        uint256 nVotesCast;\n', '\n', '        // we need replay protection for proxy ballots - this will let us check against a sequence number\n', '        // note: votes directly from a user ALWAYS take priority b/c they do not have sequence numbers\n', '        // (sequencing is done by Ethereum itself via the tx nonce).\n', '        mapping (address => uint32) sequenceNumber;\n', '\n', '        // NOTE - We don&#39;t actually want to include the encryption PublicKey because _it&#39;s included in the ballotSpec_.\n', '        // It&#39;s better to ensure ppl actually have the ballot spec by not including it in the contract.\n', '        // Plus we&#39;re already storing the hash of the ballotSpec anyway...\n', '\n', '        // Private key to be set after ballot conclusion - curve25519\n', '        bytes32 ballotEncryptionSeckey;\n', '\n', '        // packed contains:\n', '        // 1. Timestamps for start and end of ballot (UTC)\n', '        // 2. bits used to decide which options are enabled or disabled for submission of ballots\n', '        uint256 packed;\n', '\n', '        // specHash by which to validate the ballots integrity\n', '        bytes32 specHash;\n', '        // extradata if we need it - allows us to upgrade spechash format, etc\n', '        bytes16 extraData;\n', '\n', '        // allow tracking of sponsorship for this ballot & connection to index\n', '        Sponsor[] sponsors;\n', '        IxIface index;\n', '\n', '        // deprecation flag - doesn&#39;t actually do anything besides signal that this contract is deprecated;\n', '        bool deprecated;\n', '\n', '        address ballotOwner;\n', '        uint256 creationTs;\n', '    }\n', '\n', '\n', '    // ** Modifiers -- note, these are functions here to allow use as a lib\n', '    function requireBallotClosed(DB storage db) internal view {\n', '        require(now > BPackedUtils.packedToEndTime(db.packed), "!b-closed");\n', '    }\n', '\n', '    function requireBallotOpen(DB storage db) internal view {\n', '        uint64 _n = uint64(now);\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\n', '        require(_n >= startTs && _n < endTs, "!b-open");\n', '        require(db.deprecated == false, "b-deprecated");\n', '    }\n', '\n', '    function requireBallotOwner(DB storage db) internal view {\n', '        require(msg.sender == db.ballotOwner, "!b-owner");\n', '    }\n', '\n', '    function requireTesting(DB storage db) internal view {\n', '        require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), "!testing");\n', '    }\n', '\n', '    /* Library meta */\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        // even though this is constant we want to make sure that it&#39;s actually\n', '        // callable on Ethereum so we don&#39;t accidentally package the constant code\n', '        // in with an SC using BBLib. This function _must_ be external.\n', '        return BB_VERSION;\n', '    }\n', '\n', '    /* Functions */\n', '\n', '    // "Constructor" function - init core params on deploy\n', '    // timestampts are uint64s to give us plenty of room for millennia\n', '    function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\n', '        require(db.specHash == bytes32(0), "b-exists");\n', '\n', '        db.index = ix;\n', '        db.ballotOwner = ballotOwner;\n', '\n', '        uint64 startTs;\n', '        uint64 endTs;\n', '        uint16 sb;\n', '        (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\n', '\n', '        bool _testing = isTesting(sb);\n', '        if (_testing) {\n', '            emit TestingEnabled();\n', '        } else {\n', '            require(endTs > now, "bad-end-time");\n', '\n', '            // 0x1ff2 is 0001111111110010 in binary\n', '            // by ANDing with subBits we make sure that only bits in positions 0,2,3,13,14,15\n', '            // can be used. these correspond to the option flags at the top, and ETH ballots\n', '            // that are enc&#39;d or plaintext.\n', '            require(sb & 0x1ff2 == 0, "bad-sb");\n', '\n', '            // if we give bad submission bits (e.g. all 0s) then refuse to deploy ballot\n', '            bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\n', '            require(okaySubmissionBits, "!valid-sb");\n', '\n', '            // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\n', '            // (which someone might be able to do if they could set the timestamp in the past)\n', '            startTs = startTs > now ? startTs : uint64(now);\n', '        }\n', '        require(_specHash != bytes32(0), "null-specHash");\n', '        db.specHash = _specHash;\n', '\n', '        db.packed = BPackedUtils.pack(sb, startTs, endTs);\n', '        db.creationTs = now;\n', '\n', '        if (extraData != bytes16(0)) {\n', '            db.extraData = extraData;\n', '        }\n', '\n', '        emit CreatedBallot(db.specHash, startTs, endTs, sb);\n', '    }\n', '\n', '    /* sponsorship */\n', '\n', '    function logSponsorship(DB storage db, uint value) internal {\n', '        db.sponsors.push(Sponsor(msg.sender, value));\n', '    }\n', '\n', '    /* getters */\n', '\n', '    function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n', '        return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\n', '    }\n', '\n', '    function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\n', '        return db.sequenceNumber[voter];\n', '    }\n', '\n', '    function getTotalSponsorship(DB storage db) internal view returns (uint total) {\n', '        for (uint i = 0; i < db.sponsors.length; i++) {\n', '            total += db.sponsors[i].amount;\n', '        }\n', '    }\n', '\n', '    function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\n', '        sender = db.sponsors[i].sender;\n', '        amount = db.sponsors[i].amount;\n', '    }\n', '\n', '    /* ETH BALLOTS */\n', '\n', '    function setSeqNumberMax(DB storage db) internal {\n', '        // set the sequence number to max uint32 to disable proxy submitted ballots\n', '        // after a voter submits a transaction personally - effectivley disables proxy\n', '        // ballots. You can _always_ submit a new vote _personally_ with this scheme.\n', '        if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\n', '            // using an IF statement here let&#39;s us save 4800 gas on repeat votes at the cost of 20k extra gas initially\n', '            db.sequenceNumber[msg.sender] = MAX_UINT32;\n', '        }\n', '    }\n', '\n', '    // Ballot submission\n', '    // note: if USE_ENC then curve25519 keys should be generated by client for\n', '    // each ballot (then thrown away).\n', '    // the curve25519 PKs go in the extra param\n', '    function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\n', '        _addVote(db, voteData, msg.sender, extra);\n', '        setSeqNumberMax(db);\n', '    }\n', '\n', '    // this skips the checks performed by _addVote\n', '    function submitVoteAlways(DB storage db, bytes32 voteData, bytes extra) external {\n', '        _addVoteAlways(db, voteData, msg.sender, extra);\n', '        setSeqNumberMax(db);\n', '    }\n', '\n', '    function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\n', '        return _submitProxyVote(db, proxyReq, extra, false);\n', '    }\n', '\n', '    function submitProxyVoteAlways(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\n', '        return _submitProxyVote(db, proxyReq, extra, true);\n', '    }\n', '\n', '    // Boundaries for constructing the msg we&#39;ll validate the signature of\n', '    function _submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra, bool submitAlways) internal returns (address voter) {\n', '        // a proxy vote (where the vote is submitted (i.e. tx fee paid by someone else)\n', '        // docs for datastructs: https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md\n', '\n', '        bytes32 r = proxyReq[0];\n', '        bytes32 s = proxyReq[1];\n', '        uint8 v = uint8(proxyReq[2][0]);\n', '        // converting to uint248 will truncate the first byte, and we can then convert it to a bytes31.\n', '        // we truncate the first byte because it&#39;s the `v` parm used above\n', '        bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\n', '        // proxyReq[3] is ballotId - required for verifying sig but not used for anything else\n', '        bytes32 ballotId = proxyReq[3];\n', '        bytes32 voteData = proxyReq[4];\n', '\n', '        // using abi.encodePacked is much cheaper than making bytes in other ways...\n', '        bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\n', '        bytes32 msgHash = keccak256(signed);\n', '        // need to be sure we are signing the entire ballot and any extra data that comes with it\n', '        voter = ecrecover(msgHash, v, r, s);\n', '\n', '        // we need to make sure that this is the most recent vote the voter made, and that it has\n', '        // not been seen before. NOTE: we&#39;ve already validated the BBFarm namespace before this, so\n', '        // we know it&#39;s meant for _this_ ballot.\n', '        uint32 sequence = uint32(proxyReq2);  // last 4 bytes of proxyReq2 - the sequence number\n', '        _proxyReplayProtection(db, voter, sequence);\n', '\n', '        if (submitAlways) {\n', '            _addVoteAlways(db, voteData, voter, extra);\n', '        } else {\n', '            _addVote(db, voteData, voter, extra);\n', '        }\n', '    }\n', '\n', '    function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n', '        requireBallotOpen(db);\n', '        return _addVoteAlways(db, voteData, sender, extra);\n', '    }\n', '\n', '    function _addVoteAlways(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n', '        id = db.nVotesCast;\n', '        db.votes[id].voteData = voteData;\n', '        // pack the casting ts right next to the sender\n', '        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\n', '        if (extra.length > 0) {\n', '            db.votes[id].extra = extra;\n', '        }\n', '        db.nVotesCast += 1;\n', '        emit SuccessfulVote(sender, id);\n', '    }\n', '\n', '    function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\n', '        // we want the replay protection sequence number to be STRICTLY MORE than what\n', '        // is stored in the mapping. This means we can set sequence to MAX_UINT32 to disable\n', '        // any future votes.\n', '        require(db.sequenceNumber[voter] < sequence, "bad-sequence-n");\n', '        db.sequenceNumber[voter] = sequence;\n', '    }\n', '\n', '    /* Admin */\n', '\n', '    function setEndTime(DB storage db, uint64 newEndTime) external {\n', '        uint16 sb;\n', '        uint64 sTs;\n', '        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\n', '        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\n', '    }\n', '\n', '    function revealSeckey(DB storage db, bytes32 sk) internal {\n', '        db.ballotEncryptionSeckey = sk;\n', '        emit SeckeyRevealed(sk);\n', '    }\n', '\n', '    /* Submission Bits (Ballot Classifications) */\n', '\n', '    // do (bits & SETTINGS_MASK) to get just operational bits (as opposed to testing or official flag)\n', '    uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\n', '\n', '    function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\n', '    }\n', '\n', '    function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\n', '        return checkFlags(submissionBits, USE_ETH | USE_ENC);\n', '    }\n', '\n', '    function isOfficial(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\n', '    }\n', '\n', '    function isBinding(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & IS_BINDING) == IS_BINDING;\n', '    }\n', '\n', '    function isTesting(uint16 submissionBits) pure internal returns (bool) {\n', '        return (submissionBits & USE_TESTING) == USE_TESTING;\n', '    }\n', '\n', '    function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\n', '        // if submissionBits AND any of the bits that make this _not_ a community\n', '        // ballot is equal to zero that means none of those bits were active, so\n', '        // it could be a community ballot\n', '        return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\n', '    }\n', '\n', '    function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\n', '        // this should ignore ONLY the testing/flag bits - all other bits are significant\n', '        uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\n', '        // then we want ONLY expected\n', '        return sBitsNoSettings == expected;\n', '    }\n', '}\n', '\n', 'library BPackedUtils {\n', '\n', '    // the uint16 ending at 128 bits should be 0s\n', '    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n', '    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n', '    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n', '\n', '    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n', '        return uint16(packed >> 128);\n', '    }\n', '\n', '    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed >> 64);\n', '    }\n', '\n', '    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n', '        return uint64(packed);\n', '    }\n', '\n', '    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n', '        submissionBits = uint16(packed >> 128);\n', '        startTime = uint64(packed >> 64);\n', '        endTime = uint64(packed);\n', '    }\n', '\n', '    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n', '        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n', '    }\n', '\n', '    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n', '        return (packed & sbMask) | uint256(newSB) << 128;\n', '    }\n', '\n', '    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\n', '    //     return (packed & startTimeMask) | uint256(startTime) << 64;\n', '    // }\n', '\n', '    function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n', '        return (packed & endTimeMask) | uint256(endTime);\n', '    }\n', '}\n', '\n', 'interface CommAuctionIface {\n', '    function getNextPrice(bytes32 democHash) external view returns (uint);\n', '    function noteBallotDeployed(bytes32 democHash) external;\n', '\n', '    // add more when we need it\n', '\n', '    function upgradeMe(address newSC) external;\n', '}\n', '\n', 'library IxLib {\n', '    /**\n', '     * Usage: `using IxLib for IxIface`\n', '     * The idea is to (instead of adding methods that already use\n', '     * available public info to the index) we can create `internal`\n', '     * methods in the lib to do this instead (which means the code\n', '     * is inserted into other contracts inline, without a `delegatecall`.\n', '     *\n', '     * For this reason it&#39;s crucial to have no methods in IxLib with the\n', '     * same name as methods in IxIface\n', '     */\n', '\n', '    /* Global price and payments data */\n', '\n', '    function getPayTo(IxIface ix) internal view returns (address) {\n', '        return ix.getPayments().getPayTo();\n', '    }\n', '\n', '    /* Global Ix data */\n', '\n', '    function getBBFarmFromBallotID(IxIface ix, uint256 ballotId) internal view returns (BBFarmIface) {\n', '        bytes4 bbNamespace = bytes4(ballotId >> 48);\n', '        uint8 bbFarmId = ix.getBBFarmID(bbNamespace);\n', '        return ix.getBBFarm(bbFarmId);\n', '    }\n', '\n', '    /* Global backend data */\n', '\n', '    function getGDemocsN(IxIface ix) internal view returns (uint256) {\n', '        return ix.getBackend().getGDemocsN();\n', '    }\n', '\n', '    function getGDemoc(IxIface ix, uint256 n) internal view returns (bytes32) {\n', '        return ix.getBackend().getGDemoc(n);\n', '    }\n', '\n', '    function getGErc20ToDemocs(IxIface ix, address erc20) internal view returns (bytes32[] democHashes) {\n', '        return ix.getBackend().getGErc20ToDemocs(erc20);\n', '    }\n', '\n', '    /* Democ specific payment/account data */\n', '\n', '    function accountInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\n', '        return ix.getPayments().accountInGoodStanding(democHash);\n', '    }\n', '\n', '    function accountPremiumAndInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\n', '        IxPaymentsIface payments = ix.getPayments();\n', '        return payments.accountInGoodStanding(democHash) && payments.getPremiumStatus(democHash);\n', '    }\n', '\n', '    function payForDemocracy(IxIface ix, bytes32 democHash) internal {\n', '        ix.getPayments().payForDemocracy.value(msg.value)(democHash);\n', '    }\n', '\n', '    /* Democ getters */\n', '\n', '    function getDOwner(IxIface ix, bytes32 democHash) internal view returns (address) {\n', '        return ix.getBackend().getDOwner(democHash);\n', '    }\n', '\n', '    function isDEditor(IxIface ix, bytes32 democHash, address editor) internal view returns (bool) {\n', '        return ix.getBackend().isDEditor(democHash, editor);\n', '    }\n', '\n', '    function getDBallotsN(IxIface ix, bytes32 democHash) internal view returns (uint256) {\n', '        return ix.getBackend().getDBallotsN(democHash);\n', '    }\n', '\n', '    function getDBallotID(IxIface ix, bytes32 democHash, uint256 n) internal view returns (uint256) {\n', '        return ix.getBackend().getDBallotID(democHash, n);\n', '    }\n', '\n', '    function getDInfo(IxIface ix, bytes32 democHash) internal view returns (address erc20, address admin, uint256 _nBallots) {\n', '        return ix.getBackend().getDInfo(democHash);\n', '    }\n', '\n', '    function getDErc20(IxIface ix, bytes32 democHash) internal view returns (address erc20) {\n', '        return ix.getBackend().getDErc20(democHash);\n', '    }\n', '\n', '    function getDHash(IxIface ix, bytes13 prefix) internal view returns (bytes32) {\n', '        return ix.getBackend().getDHash(prefix);\n', '    }\n', '\n', '    function getDCategoriesN(IxIface ix, bytes32 democHash) internal view returns (uint) {\n', '        return ix.getBackend().getDCategoriesN(democHash);\n', '    }\n', '\n', '    function getDCategory(IxIface ix, bytes32 democHash, uint categoryId) internal view returns (bool, bytes32, bool, uint) {\n', '        return ix.getBackend().getDCategory(democHash, categoryId);\n', '    }\n', '\n', '    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return ix.getBackend().getDArbitraryData(democHash, key);\n', '    }\n', '}\n', '\n', 'contract SVBallotConsts {\n', '    // voting settings\n', '    uint16 constant USE_ETH = 1;          // 2^0\n', '    uint16 constant USE_SIGNED = 2;       // 2^1\n', '    uint16 constant USE_NO_ENC = 4;       // 2^2\n', '    uint16 constant USE_ENC = 8;          // 2^3\n', '\n', '    // ballot settings\n', '    uint16 constant IS_BINDING = 8192;    // 2^13\n', '    uint16 constant IS_OFFICIAL = 16384;  // 2^14\n', '    uint16 constant USE_TESTING = 32768;  // 2^15\n', '}\n', '\n', 'contract safeSend {\n', '    bool private txMutex3847834;\n', '\n', '    // we want to be able to call outside contracts (e.g. the admin proxy contract)\n', '    // but reentrency is bad, so here&#39;s a mutex.\n', '    function doSafeSend(address toAddr, uint amount) internal {\n', '        doSafeSendWData(toAddr, "", amount);\n', '    }\n', '\n', '    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n', '        require(txMutex3847834 == false, "ss-guard");\n', '        txMutex3847834 = true;\n', '        // we need to use address.call.value(v)() because we want\n', '        // to be able to send to other contracts, even with no data,\n', '        // which might use more than 2300 gas in their fallback function.\n', '        require(toAddr.call.value(amount)(data), "ss-failed");\n', '        txMutex3847834 = false;\n', '    }\n', '}\n', '\n', 'contract payoutAllC is safeSend {\n', '    address private _payTo;\n', '\n', '    event PayoutAll(address payTo, uint value);\n', '\n', '    constructor(address initPayTo) public {\n', '        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\n', '        assert(initPayTo != address(0));\n', '        _payTo = initPayTo;\n', '    }\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return _payTo;\n', '    }\n', '\n', '    function _setPayTo(address newPayTo) internal {\n', '        _payTo = newPayTo;\n', '    }\n', '\n', '    function payoutAll() external {\n', '        address a = _getPayTo();\n', '        uint bal = address(this).balance;\n', '        doSafeSend(a, bal);\n', '        emit PayoutAll(a, bal);\n', '    }\n', '}\n', '\n', 'contract payoutAllCSettable is payoutAllC {\n', '    constructor (address initPayTo) payoutAllC(initPayTo) public {\n', '    }\n', '\n', '    function setPayTo(address) external;\n', '    function getPayTo() external view returns (address) {\n', '        return _getPayTo();\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address newOwner);\n', '\n', '    modifier only_owner() {\n', '        require(msg.sender == owner, "only_owner: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier owner_or(address addr) {\n', '        require(msg.sender == addr || msg.sender == owner, "!owner-or");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function setOwner(address newOwner) only_owner() external {\n', '        owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '}\n', '\n', 'contract CanReclaimToken is owned {\n', '\n', '    /**\n', '    * @dev Reclaim all ERC20Basic compatible tokens\n', '    * @param token ERC20Basic The address of the token contract\n', '    */\n', '    function reclaimToken(ERC20Interface token) external only_owner {\n', '        uint256 balance = token.balanceOf(this);\n', '        require(token.approve(owner, balance));\n', '    }\n', '\n', '}\n', '\n', 'contract CommunityAuctionSimple is owned, CommAuctionIface {\n', '    // about $1USD at $600usd/eth\n', '    uint public commBallotPriceWei = 1666666666000000;\n', '\n', '    struct Record {\n', '        bytes32 democHash;\n', '        uint ts;\n', '    }\n', '\n', '    mapping (address => Record[]) public ballotLog;\n', '    mapping (address => address) public upgrades;\n', '\n', '    function getNextPrice(bytes32) external view returns (uint) {\n', '        return commBallotPriceWei;\n', '    }\n', '\n', '    function noteBallotDeployed(bytes32 d) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        ballotLog[msg.sender].push(Record(d, now));\n', '    }\n', '\n', '    function upgradeMe(address newSC) external {\n', '        require(upgrades[msg.sender] == address(0));\n', '        upgrades[msg.sender] = newSC;\n', '    }\n', '\n', '    function getBallotLogN(address a) external view returns (uint) {\n', '        return ballotLog[a].length;\n', '    }\n', '\n', '    function setPriceWei(uint newPrice) only_owner() external {\n', '        commBallotPriceWei = newPrice;\n', '    }\n', '}\n', '\n', 'contract controlledIface {\n', '    function controller() external view returns (address);\n', '}\n', '\n', 'contract hasAdmins is owned {\n', '    mapping (uint => mapping (address => bool)) admins;\n', '    uint public currAdminEpoch = 0;\n', '    bool public adminsDisabledForever = false;\n', '    address[] adminLog;\n', '\n', '    event AdminAdded(address indexed newAdmin);\n', '    event AdminRemoved(address indexed oldAdmin);\n', '    event AdminEpochInc();\n', '    event AdminDisabledForever();\n', '\n', '    modifier only_admin() {\n', '        require(adminsDisabledForever == false, "admins must not be disabled");\n', '        require(isAdmin(msg.sender), "only_admin: forbidden");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        _setAdmin(msg.sender, true);\n', '    }\n', '\n', '    function isAdmin(address a) view public returns (bool) {\n', '        return admins[currAdminEpoch][a];\n', '    }\n', '\n', '    function getAdminLogN() view external returns (uint) {\n', '        return adminLog.length;\n', '    }\n', '\n', '    function getAdminLog(uint n) view external returns (address) {\n', '        return adminLog[n];\n', '    }\n', '\n', '    function upgradeMeAdmin(address newAdmin) only_admin() external {\n', '        // note: already checked msg.sender has admin with `only_admin` modifier\n', '        require(msg.sender != owner, "owner cannot upgrade self");\n', '        _setAdmin(msg.sender, false);\n', '        _setAdmin(newAdmin, true);\n', '    }\n', '\n', '    function setAdmin(address a, bool _givePerms) only_admin() external {\n', '        require(a != msg.sender && a != owner, "cannot change your own (or owner&#39;s) permissions");\n', '        _setAdmin(a, _givePerms);\n', '    }\n', '\n', '    function _setAdmin(address a, bool _givePerms) internal {\n', '        admins[currAdminEpoch][a] = _givePerms;\n', '        if (_givePerms) {\n', '            emit AdminAdded(a);\n', '            adminLog.push(a);\n', '        } else {\n', '            emit AdminRemoved(a);\n', '        }\n', '    }\n', '\n', '    // safety feature if admins go bad or something\n', '    function incAdminEpoch() only_owner() external {\n', '        currAdminEpoch++;\n', '        admins[currAdminEpoch][msg.sender] = true;\n', '        emit AdminEpochInc();\n', '    }\n', '\n', '    // this is internal so contracts can all it, but not exposed anywhere in this\n', '    // contract.\n', '    function disableAdminForever() internal {\n', '        currAdminEpoch++;\n', '        adminsDisabledForever = true;\n', '        emit AdminDisabledForever();\n', '    }\n', '}\n', '\n', 'contract EnsOwnerProxy is hasAdmins {\n', '    bytes32 public ensNode;\n', '    ENSIface public ens;\n', '    PublicResolver public resolver;\n', '\n', '    /**\n', '     * @param _ensNode The node to administer\n', '     * @param _ens The ENS Registrar\n', '     * @param _resolver The ENS Resolver\n', '     */\n', '    constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\n', '        ensNode = _ensNode;\n', '        ens = _ens;\n', '        resolver = _resolver;\n', '    }\n', '\n', '    function setAddr(address addr) only_admin() external {\n', '        _setAddr(addr);\n', '    }\n', '\n', '    function _setAddr(address addr) internal {\n', '        resolver.setAddr(ensNode, addr);\n', '    }\n', '\n', '    function returnToOwner() only_owner() external {\n', '        ens.setOwner(ensNode, owner);\n', '    }\n', '\n', '    function fwdToENS(bytes data) only_owner() external {\n', '        require(address(ens).call(data), "fwding to ens failed");\n', '    }\n', '\n', '    function fwdToResolver(bytes data) only_owner() external {\n', '        require(address(resolver).call(data), "fwding to resolver failed");\n', '    }\n', '}\n', '\n', 'contract permissioned is owned, hasAdmins {\n', '    mapping (address => bool) editAllowed;\n', '    bool public adminLockdown = false;\n', '\n', '    event PermissionError(address editAddr);\n', '    event PermissionGranted(address editAddr);\n', '    event PermissionRevoked(address editAddr);\n', '    event PermissionsUpgraded(address oldSC, address newSC);\n', '    event SelfUpgrade(address oldSC, address newSC);\n', '    event AdminLockdown();\n', '\n', '    modifier only_editors() {\n', '        require(editAllowed[msg.sender], "only_editors: forbidden");\n', '        _;\n', '    }\n', '\n', '    modifier no_lockdown() {\n', '        require(adminLockdown == false, "no_lockdown: check failed");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor() owned() hasAdmins() public {\n', '    }\n', '\n', '\n', '    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n', '        editAllowed[e] = _editPerms;\n', '        if (_editPerms)\n', '            emit PermissionGranted(e);\n', '        else\n', '            emit PermissionRevoked(e);\n', '    }\n', '\n', '    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n', '        editAllowed[oldSC] = false;\n', '        editAllowed[newSC] = true;\n', '        emit PermissionsUpgraded(oldSC, newSC);\n', '    }\n', '\n', '    // always allow SCs to upgrade themselves, even after lockdown\n', '    function upgradeMe(address newSC) only_editors() external {\n', '        editAllowed[msg.sender] = false;\n', '        editAllowed[newSC] = true;\n', '        emit SelfUpgrade(msg.sender, newSC);\n', '    }\n', '\n', '    function hasPermissions(address a) public view returns (bool) {\n', '        return editAllowed[a];\n', '    }\n', '\n', '    function doLockdown() external only_owner() no_lockdown() {\n', '        disableAdminForever();\n', '        adminLockdown = true;\n', '        emit AdminLockdown();\n', '    }\n', '}\n', '\n', 'contract upgradePtr {\n', '    address ptr = address(0);\n', '\n', '    modifier not_upgraded() {\n', '        require(ptr == address(0), "upgrade pointer is non-zero");\n', '        _;\n', '    }\n', '\n', '    function getUpgradePointer() view external returns (address) {\n', '        return ptr;\n', '    }\n', '\n', '    function doUpgradeInternal(address nextSC) internal {\n', '        ptr = nextSC;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface {\n', '    // Get the total token supply\n', '    function totalSupply() constant external returns (uint256 _totalSupply);\n', '\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ixEvents {\n', '    event PaymentMade(uint[2] valAndRemainder);\n', '    event AddedBBFarm(uint8 bbFarmId);\n', '    event SetBackend(bytes32 setWhat, address newSC);\n', '    event DeprecatedBBFarm(uint8 bbFarmId);\n', '    event CommunityBallot(bytes32 democHash, uint256 ballotId);\n', '    event ManuallyAddedBallot(bytes32 democHash, uint256 ballotId, uint256 packed);\n', '    // copied from BBFarm - unable to inherit from BBFarmEvents...\n', '    event BallotCreatedWithID(uint ballotId);\n', '    event BBFarmInit(bytes4 namespace);\n', '}\n', '\n', 'contract ixBackendEvents {\n', '    event NewDemoc(bytes32 democHash);\n', '    event ManuallyAddedDemoc(bytes32 democHash, address erc20);\n', '    event NewBallot(bytes32 indexed democHash, uint ballotN);\n', '    event DemocOwnerSet(bytes32 indexed democHash, address owner);\n', '    event DemocEditorSet(bytes32 indexed democHash, address editor, bool canEdit);\n', '    event DemocEditorsWiped(bytes32 indexed democHash);\n', '    event DemocErc20Set(bytes32 indexed democHash, address erc20);\n', '    event DemocDataSet(bytes32 indexed democHash, bytes32 keyHash);\n', '    event DemocCatAdded(bytes32 indexed democHash, uint catId);\n', '    event DemocCatDeprecated(bytes32 indexed democHash, uint catId);\n', '    event DemocCommunityBallotsEnabled(bytes32 indexed democHash, bool enabled);\n', '    event DemocErc20OwnerClaimDisabled(bytes32 indexed democHash);\n', '    event DemocClaimed(bytes32 indexed democHash);\n', '    event EmergencyDemocOwner(bytes32 indexed democHash, address newOwner);\n', '}\n', '\n', 'library SafeMath {\n', '    function subToZero(uint a, uint b) internal pure returns (uint) {\n', '        if (a < b) {  // then (a - b) would overflow\n', '            return 0;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract ixPaymentEvents {\n', '    event UpgradedToPremium(bytes32 indexed democHash);\n', '    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\n', '    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\n', '    event SetCommunityBallotFee(uint amount);\n', '    event SetBasicCentsPricePer30Days(uint amount);\n', '    event SetPremiumMultiplier(uint8 multiplier);\n', '    event DowngradeToBasic(bytes32 indexed democHash);\n', '    event UpgradeToPremium(bytes32 indexed democHash);\n', '    event SetExchangeRate(uint weiPerCent);\n', '    event FreeExtension(bytes32 democHash);\n', '    event SetBallotsPer30Days(uint amount);\n', '    event SetFreeExtension(bytes32 democHash, bool hasFreeExt);\n', '    event SetDenyPremium(bytes32 democHash, bool isPremiumDenied);\n', '    event SetPayTo(address payTo);\n', '    event SetMinorEditsAddr(address minorEditsAddr);\n', '    event SetMinWeiForDInit(uint amount);\n', '}\n', '\n', 'interface hasVersion {\n', '    function getVersion() external pure returns (uint);\n', '}\n', '\n', 'contract BBFarmIface is BBFarmEvents, permissioned, hasVersion, payoutAllC {\n', '    /* global bbfarm getters */\n', '\n', '    function getNamespace() external view returns (bytes4);\n', '    function getBBLibVersion() external view returns (uint256);\n', '    function getNBallots() external view returns (uint256);\n', '\n', '    /* foreign network integration */\n', '\n', '    // requires version >= 3;\n', '    function getVotingNetworkDetails() external view returns (bytes32);\n', '\n', '    /* init a ballot */\n', '\n', '    // note that the ballotId returned INCLUDES the namespace.\n', '    function initBallot( bytes32 specHash\n', '                       , uint256 packed\n', '                       , IxIface ix\n', '                       , address bbAdmin\n', '                       , bytes24 extraData\n', '                       ) external returns (uint ballotId);\n', '    // requires v3+; also isn&#39;t supported on all networks\n', '    function initBallotProxy(uint8 v, bytes32 r, bytes32 s, bytes32[4] params) external returns (uint256 ballotId);\n', '\n', '    /* Sponsorship of ballots */\n', '\n', '    function sponsor(uint ballotId) external payable;\n', '\n', '    /* Voting functions */\n', '\n', '    function submitVote(uint ballotId, bytes32 vote, bytes extra) external;\n', '    function submitProxyVote(bytes32[5] proxyReq, bytes extra) external;\n', '\n', '    /* Ballot Getters */\n', '\n', '    function getDetails(uint ballotId, address voter) external view returns\n', '            ( bool hasVoted\n', '            , uint nVotesCast\n', '            , bytes32 secKey\n', '            , uint16 submissionBits\n', '            , uint64 startTime\n', '            , uint64 endTime\n', '            , bytes32 specHash\n', '            , bool deprecated\n', '            , address ballotOwner\n', '            , bytes16 extraData);\n', '\n', '    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra);\n', '    // getVoteAndTime requires v3+\n', '    function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs);\n', '    function getTotalSponsorship(uint ballotId) external view returns (uint);\n', '    function getSponsorsN(uint ballotId) external view returns (uint);\n', '    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount);\n', '    function getCreationTs(uint ballotId) external view returns (uint);\n', '\n', '    /* Admin on ballots */\n', '    function revealSeckey(uint ballotId, bytes32 sk) external;\n', '    function setEndTime(uint ballotId, uint64 newEndTime) external;  // note: testing only\n', '    function setDeprecated(uint ballotId) external;\n', '    function setBallotOwner(uint ballotId, address newOwner) external;\n', '}\n', '\n', 'contract BBFarm is BBFarmIface {\n', '    using BBLibV7 for BBLibV7.DB;\n', '    using IxLib for IxIface;\n', '\n', '    // namespaces should be unique for each bbFarm\n', '    bytes4 constant NAMESPACE = 0x00000001;\n', '    // last 48 bits\n', '    uint256 constant BALLOT_ID_MASK = 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    uint constant VERSION = 3;\n', '\n', '    mapping (uint224 => BBLibV7.DB) dbs;\n', '    // note - start at 100 to avoid any test for if 0 is a valid ballotId\n', '    // also gives us some space to play with low numbers if we want.\n', '    uint nBallots = 0;\n', '\n', '    /* modifiers */\n', '\n', '    modifier req_namespace(uint ballotId) {\n', '        // bytes4() will take the _first_ 4 bytes\n', '        require(bytes4(ballotId >> 224) == NAMESPACE, "bad-namespace");\n', '        _;\n', '    }\n', '\n', '    /* Constructor */\n', '\n', '    constructor() payoutAllC(msg.sender) public {\n', '        // this bbFarm requires v5 of BBLib (note: v4 deprecated immediately due to insecure submitProxyVote)\n', '        // note: even though we can&#39;t test for this in coverage, this has stopped me deploying to kovan with the wrong version tho, so I consider it tested :)\n', '        assert(BBLibV7.getVersion() == 7);\n', '        emit BBFarmInit(NAMESPACE);\n', '    }\n', '\n', '    /* base SCs */\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    /* global funcs */\n', '\n', '    function getNamespace() external view returns (bytes4) {\n', '        return NAMESPACE;\n', '    }\n', '\n', '    function getBBLibVersion() external view returns (uint256) {\n', '        return BBLibV7.getVersion();\n', '    }\n', '\n', '    function getNBallots() external view returns (uint256) {\n', '        return nBallots;\n', '    }\n', '\n', '    function getVotingNetworkDetails() external view returns (bytes32) {\n', '        // 0 in either chainId or networkId spot indicate the local chain\n', '        return bytes32(uint(0) << 192 | uint(0) << 160 | uint160(address(this)));\n', '    }\n', '\n', '    /* db lookup helper */\n', '\n', '    function getDb(uint ballotId) internal view returns (BBLibV7.DB storage) {\n', '        // cut off anything above 224 bits (where the namespace goes)\n', '        return dbs[uint224(ballotId)];\n', '    }\n', '\n', '    /* Init ballot */\n', '\n', '    function initBallot( bytes32 specHash\n', '                       , uint256 packed\n', '                       , IxIface ix\n', '                       , address bbAdmin\n', '                       , bytes24 extraData\n', '                ) only_editors() external returns (uint ballotId) {\n', '        // calculate the ballotId based on the last 224 bits of the specHash.\n', '        ballotId = uint224(specHash) ^ (uint256(NAMESPACE) << 224);\n', '        // we need to call the init functions on our libraries\n', '        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));\n', '        nBallots += 1;\n', '\n', '        emit BallotCreatedWithID(ballotId);\n', '    }\n', '\n', '    function initBallotProxy(uint8, bytes32, bytes32, bytes32[4]) external returns (uint256) {\n', '        // this isn&#39;t supported on the deployed BBFarm\n', '        revert("initBallotProxy not implemented");\n', '    }\n', '\n', '    /* Sponsorship */\n', '\n', '    function sponsor(uint ballotId) external payable {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        db.logSponsorship(msg.value);\n', '        doSafeSend(db.index.getPayTo(), msg.value);\n', '        emit Sponsorship(ballotId, msg.value);\n', '    }\n', '\n', '    /* Voting */\n', '\n', '    function submitVote(uint ballotId, bytes32 vote, bytes extra) req_namespace(ballotId) external {\n', '        getDb(ballotId).submitVote(vote, extra);\n', '        emit Vote(ballotId, vote, msg.sender, extra);\n', '    }\n', '\n', '    function submitProxyVote(bytes32[5] proxyReq, bytes extra) req_namespace(uint256(proxyReq[3])) external {\n', '        // see https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md for breakdown of params\n', '        // pr[3] is the ballotId, and pr[4] is the vote\n', '        uint ballotId = uint256(proxyReq[3]);\n', '        address voter = getDb(ballotId).submitProxyVote(proxyReq, extra);\n', '        bytes32 vote = proxyReq[4];\n', '        emit Vote(ballotId, vote, voter, extra);\n', '    }\n', '\n', '    /* Getters */\n', '\n', '    // note - this is the maxmimum number of vars we can return with one\n', '    // function call (taking 2 args)\n', '    function getDetails(uint ballotId, address voter) external view returns\n', '            ( bool hasVoted\n', '            , uint nVotesCast\n', '            , bytes32 secKey\n', '            , uint16 submissionBits\n', '            , uint64 startTime\n', '            , uint64 endTime\n', '            , bytes32 specHash\n', '            , bool deprecated\n', '            , address ballotOwner\n', '            , bytes16 extraData) {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        uint packed = db.packed;\n', '        return (\n', '            db.getSequenceNumber(voter) > 0,\n', '            db.nVotesCast,\n', '            db.ballotEncryptionSeckey,\n', '            BPackedUtils.packedToSubmissionBits(packed),\n', '            BPackedUtils.packedToStartTime(packed),\n', '            BPackedUtils.packedToEndTime(packed),\n', '            db.specHash,\n', '            db.deprecated,\n', '            db.ballotOwner,\n', '            db.extraData\n', '        );\n', '    }\n', '\n', '    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra) {\n', '        (voteData, sender, extra, ) = getDb(ballotId).getVote(voteId);\n', '    }\n', '\n', '    function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n', '        return getDb(ballotId).getVote(voteId);\n', '    }\n', '\n', '    function getSequenceNumber(uint ballotId, address voter) external view returns (uint32 sequence) {\n', '        return getDb(ballotId).getSequenceNumber(voter);\n', '    }\n', '\n', '    function getTotalSponsorship(uint ballotId) external view returns (uint) {\n', '        return getDb(ballotId).getTotalSponsorship();\n', '    }\n', '\n', '    function getSponsorsN(uint ballotId) external view returns (uint) {\n', '        return getDb(ballotId).sponsors.length;\n', '    }\n', '\n', '    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount) {\n', '        return getDb(ballotId).getSponsor(sponsorN);\n', '    }\n', '\n', '    function getCreationTs(uint ballotId) external view returns (uint) {\n', '        return getDb(ballotId).creationTs;\n', '    }\n', '\n', '    /* ADMIN */\n', '\n', '    // Allow the owner to reveal the secret key after ballot conclusion\n', '    function revealSeckey(uint ballotId, bytes32 sk) external {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        db.requireBallotOwner();\n', '        db.requireBallotClosed();\n', '        db.revealSeckey(sk);\n', '    }\n', '\n', '    // note: testing only.\n', '    function setEndTime(uint ballotId, uint64 newEndTime) external {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        db.requireBallotOwner();\n', '        db.requireTesting();\n', '        db.setEndTime(newEndTime);\n', '    }\n', '\n', '    function setDeprecated(uint ballotId) external {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        db.requireBallotOwner();\n', '        db.deprecated = true;\n', '    }\n', '\n', '    function setBallotOwner(uint ballotId, address newOwner) external {\n', '        BBLibV7.DB storage db = getDb(ballotId);\n', '        db.requireBallotOwner();\n', '        db.ballotOwner = newOwner;\n', '    }\n', '}\n', '\n', 'contract IxIface is hasVersion,\n', '                    ixPaymentEvents,\n', '                    ixBackendEvents,\n', '                    ixEvents,\n', '                    SVBallotConsts,\n', '                    owned,\n', '                    CanReclaimToken,\n', '                    upgradePtr,\n', '                    payoutAllC {\n', '\n', '    /* owner functions */\n', '    function addBBFarm(BBFarmIface bbFarm) external returns (uint8 bbFarmId);\n', '    function setABackend(bytes32 toSet, address newSC) external;\n', '    function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) external;\n', '\n', '    /* global getters */\n', '    function getPayments() external view returns (IxPaymentsIface);\n', '    function getBackend() external view returns (IxBackendIface);\n', '    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface);\n', '    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId);\n', '    function getCommAuction() external view returns (CommAuctionIface);\n', '\n', '    /* init a democ */\n', '    function dInit(address defualtErc20, bool disableErc20OwnerClaim) external payable returns (bytes32);\n', '\n', '    /* democ owner / editor functions */\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n', '    function setDNoEditors(bytes32 democHash) external;\n', '    function setDOwner(bytes32 democHash, address newOwner) external;\n', '    function dOwnerErc20Claim(bytes32 democHash) external;\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n', '    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\n', '    function dUpgradeToPremium(bytes32 democHash) external;\n', '    function dDowngradeToBasic(bytes32 democHash) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) external;\n', '\n', '    /* democ getters (that used to be here) should be called on either backend or payments directly */\n', '    /* use IxLib for convenience functions from other SCs */\n', '\n', '    /* ballot deployment */\n', '    // only ix owner - used for adding past or special ballots\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed) external;\n', '    function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable;\n', '    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed) external payable;\n', '}\n', '\n', 'contract SVIndex is IxIface {\n', '    uint256 constant VERSION = 2;\n', '\n', '    // generated from: `address public owner;`\n', '    bytes4 constant OWNER_SIG = 0x8da5cb5b;\n', '    // generated from: `address public controller;`\n', '    bytes4 constant CONTROLLER_SIG = 0xf77c4791;\n', '\n', '    /* backend & other SC storage */\n', '\n', '    IxBackendIface backend;\n', '    IxPaymentsIface payments;\n', '    EnsOwnerProxy public ensOwnerPx;\n', '    BBFarmIface[] bbFarms;\n', '    CommAuctionIface commAuction;\n', '    // mapping from bbFarm namespace to bbFarmId\n', '    mapping (bytes4 => uint8) bbFarmIdLookup;\n', '    mapping (uint8 => bool) deprecatedBBFarms;\n', '\n', '    //* MODIFIERS /\n', '\n', '    modifier onlyDemocOwner(bytes32 democHash) {\n', '        require(msg.sender == backend.getDOwner(democHash), "!d-owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyDemocEditor(bytes32 democHash) {\n', '        require(backend.isDEditor(democHash, msg.sender), "!d-editor");\n', '        _;\n', '    }\n', '\n', '    /* FUNCTIONS */\n', '\n', '    // constructor\n', '    constructor( IxBackendIface _b\n', '               , IxPaymentsIface _pay\n', '               , EnsOwnerProxy _ensOwnerPx\n', '               , BBFarmIface _bbFarm0\n', '               , CommAuctionIface _commAuction\n', '               ) payoutAllC(msg.sender) public {\n', '        backend = _b;\n', '        payments = _pay;\n', '        ensOwnerPx = _ensOwnerPx;\n', '        _addBBFarm(0x0, _bbFarm0);\n', '        commAuction = _commAuction;\n', '    }\n', '\n', '    /* payoutAllC */\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return payments.getPayTo();\n', '    }\n', '\n', '    /* UPGRADE STUFF */\n', '\n', '    function doUpgrade(address nextSC) only_owner() not_upgraded() external {\n', '        doUpgradeInternal(nextSC);\n', '        backend.upgradeMe(nextSC);\n', '        payments.upgradeMe(nextSC);\n', '        ensOwnerPx.setAddr(nextSC);\n', '        ensOwnerPx.upgradeMeAdmin(nextSC);\n', '        commAuction.upgradeMe(nextSC);\n', '\n', '        for (uint i = 0; i < bbFarms.length; i++) {\n', '            bbFarms[i].upgradeMe(nextSC);\n', '        }\n', '    }\n', '\n', '    function _addBBFarm(bytes4 bbNamespace, BBFarmIface _bbFarm) internal returns (uint8 bbFarmId) {\n', '        uint256 bbFarmIdLong = bbFarms.length;\n', '        require(bbFarmIdLong < 2**8, "too-many-farms");\n', '        bbFarmId = uint8(bbFarmIdLong);\n', '\n', '        bbFarms.push(_bbFarm);\n', '        bbFarmIdLookup[bbNamespace] = bbFarmId;\n', '        emit AddedBBFarm(bbFarmId);\n', '    }\n', '\n', '    // adding a new BBFarm\n', '    function addBBFarm(BBFarmIface bbFarm) only_owner() external returns (uint8 bbFarmId) {\n', '        bytes4 bbNamespace = bbFarm.getNamespace();\n', '\n', '        require(bbNamespace != bytes4(0), "bb-farm-namespace");\n', '        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), "bb-namespace-used");\n', '\n', '        bbFarmId = _addBBFarm(bbNamespace, bbFarm);\n', '    }\n', '\n', '    function setABackend(bytes32 toSet, address newSC) only_owner() external {\n', '        emit SetBackend(toSet, newSC);\n', '        if (toSet == bytes32("payments")) {\n', '            payments = IxPaymentsIface(newSC);\n', '        } else if (toSet == bytes32("backend")) {\n', '            backend = IxBackendIface(newSC);\n', '        } else if (toSet == bytes32("commAuction")) {\n', '            commAuction = CommAuctionIface(newSC);\n', '        } else {\n', '            revert("404");\n', '        }\n', '    }\n', '\n', '    function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) only_owner() external {\n', '        require(address(_bbFarm) != address(0));\n', '        require(bbFarms[bbFarmId] == _bbFarm);\n', '        deprecatedBBFarms[bbFarmId] = true;\n', '        emit DeprecatedBBFarm(bbFarmId);\n', '    }\n', '\n', '    /* Getters for backends */\n', '\n', '    function getPayments() external view returns (IxPaymentsIface) {\n', '        return payments;\n', '    }\n', '\n', '    function getBackend() external view returns (IxBackendIface) {\n', '        return backend;\n', '    }\n', '\n', '    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface) {\n', '        return bbFarms[bbFarmId];\n', '    }\n', '\n', '    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId) {\n', '        return bbFarmIdLookup[bbNamespace];\n', '    }\n', '\n', '    function getCommAuction() external view returns (CommAuctionIface) {\n', '        return commAuction;\n', '    }\n', '\n', '    //* GLOBAL INFO */\n', '\n', '    function getVersion() external pure returns (uint256) {\n', '        return VERSION;\n', '    }\n', '\n', '    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\n', '\n', '    function dInit(address defaultErc20, bool disableErc20OwnerClaim) not_upgraded() external payable returns (bytes32) {\n', '        require(msg.value >= payments.getMinWeiForDInit());\n', '        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);\n', '        payments.payForDemocracy.value(msg.value)(democHash);\n', '        return democHash;\n', '    }\n', '\n', '    // admin methods\n', '\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) onlyDemocOwner(democHash) external {\n', '        backend.setDEditor(democHash, editor, canEdit);\n', '    }\n', '\n', '    function setDNoEditors(bytes32 democHash) onlyDemocOwner(democHash) external {\n', '        backend.setDNoEditors(democHash);\n', '    }\n', '\n', '    function setDOwner(bytes32 democHash, address newOwner) onlyDemocOwner(democHash) external {\n', '        backend.setDOwner(democHash, newOwner);\n', '    }\n', '\n', '    function dOwnerErc20Claim(bytes32 democHash) external {\n', '        address erc20 = backend.getDErc20(democHash);\n', '        // test if we can call the erc20.owner() method, etc\n', '        // also limit gas use to 3000 because we don&#39;t know what they&#39;ll do with it\n', '        // during testing both owned and controlled could be called from other contracts for 2525 gas.\n', '        if (erc20.call.gas(3000)(OWNER_SIG)) {\n', '            require(msg.sender == owned(erc20).owner.gas(3000)(), "!erc20-owner");\n', '        } else if (erc20.call.gas(3000)(CONTROLLER_SIG)) {\n', '            require(msg.sender == controlledIface(erc20).controller.gas(3000)(), "!erc20-controller");\n', '        } else {\n', '            revert();\n', '        }\n', '        // now we are certain the sender deployed or controls the erc20\n', '        backend.setDOwnerFromClaim(democHash, msg.sender);\n', '    }\n', '\n', '    function setDErc20(bytes32 democHash, address newErc20) onlyDemocOwner(democHash) external {\n', '        backend.setDErc20(democHash, newErc20);\n', '    }\n', '\n', '    function dAddCategory(bytes32 democHash, bytes32 catName, bool hasParent, uint parent) onlyDemocEditor(democHash) external {\n', '        backend.dAddCategory(democHash, catName, hasParent, parent);\n', '    }\n', '\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) onlyDemocEditor(democHash) external {\n', '        backend.dDeprecateCategory(democHash, catId);\n', '    }\n', '\n', '    function dUpgradeToPremium(bytes32 democHash) onlyDemocOwner(democHash) external {\n', '        payments.upgradeToPremium(democHash);\n', '    }\n', '\n', '    function dDowngradeToBasic(bytes32 democHash) onlyDemocOwner(democHash) external {\n', '        payments.downgradeToBasic(democHash);\n', '    }\n', '\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external {\n', '        if (msg.sender == backend.getDOwner(democHash)) {\n', '            backend.dSetArbitraryData(democHash, key, value);\n', '        } else if (backend.isDEditor(democHash, msg.sender)) {\n', '            backend.dSetEditorArbitraryData(democHash, key, value);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) onlyDemocOwner(democHash) external {\n', '        backend.dSetCommunityBallotsEnabled(democHash, enabled);\n', '    }\n', '\n', '    // this is one way only!\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) onlyDemocOwner(democHash) external {\n', '        backend.dDisableErc20OwnerClaim(democHash);\n', '    }\n', '\n', '    /* Democ Getters - deprecated */\n', '    // NOTE: the getters that used to live here just proxied to the backend.\n', '    // this has been removed to reduce gas costs + size of Ix contract\n', '    // For SCs you should use IxLib for convenience.\n', '    // For Offchain use you should query the backend directly (via ix.getBackend())\n', '\n', '    /* Add and Deploy Ballots */\n', '\n', '    // manually add a ballot - only the owner can call this\n', '    // WARNING - it&#39;s required that we make ABSOLUTELY SURE that\n', '    // ballotId is valid and can resolve via the appropriate BBFarm.\n', '    // this function _DOES NOT_ validate that everything else is done.\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed)\n', '                      only_owner()\n', '                      external {\n', '\n', '        _addBallot(democHash, ballotId, packed, false);\n', '        emit ManuallyAddedBallot(democHash, ballotId, packed);\n', '    }\n', '\n', '\n', '    function _deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint packed, bool checkLimit, bool alreadySentTx) internal returns (uint ballotId) {\n', '        require(BBLibV7.isTesting(BPackedUtils.packedToSubmissionBits(packed)) == false, "b-testing");\n', '\n', '        // the most significant byte of extraData signals the bbFarm to use.\n', '        uint8 bbFarmId = uint8(extraData[0]);\n', '        require(deprecatedBBFarms[bbFarmId] == false, "bb-dep");\n', '        BBFarmIface _bbFarm = bbFarms[bbFarmId];\n', '\n', '        // anything that isn&#39;t a community ballot counts towards the basic limit.\n', '        // we want to check in cases where\n', '        // the ballot doesn&#39;t qualify as a community ballot\n', '        // OR (the ballot qualifies as a community ballot\n', '        //     AND the admins have _disabled_ community ballots).\n', '        bool countTowardsLimit = checkLimit;\n', '        bool performedSend;\n', '        if (checkLimit) {\n', '            uint64 endTime = BPackedUtils.packedToEndTime(packed);\n', '            (countTowardsLimit, performedSend) = _basicBallotLimitOperations(democHash, _bbFarm);\n', '            _accountOkayChecks(democHash, endTime);\n', '        }\n', '\n', '        if (!performedSend && msg.value > 0 && alreadySentTx == false) {\n', '            // refund if we haven&#39;t send value anywhere (which might happen if someone accidentally pays us)\n', '            doSafeSend(msg.sender, msg.value);\n', '        }\n', '\n', '        ballotId = _bbFarm.initBallot(\n', '            specHash,\n', '            packed,\n', '            this,\n', '            msg.sender,\n', '            // we are certain that the first 8 bytes are for index use only.\n', '            // truncating extraData like this means we can occasionally\n', '            // save on gas. we need to use uint192 first because that will take\n', '            // the _last_ 24 bytes of extraData.\n', '            bytes24(uint192(extraData)));\n', '\n', '        _addBallot(democHash, ballotId, packed, countTowardsLimit);\n', '    }\n', '\n', '    function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable {\n', '        uint price = commAuction.getNextPrice(democHash);\n', '        require(msg.value >= price, "!cb-fee");\n', '\n', '        doSafeSend(payments.getPayTo(), price);\n', '        doSafeSend(msg.sender, msg.value - price);\n', '\n', '        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);\n', '        require(canProceed, "!cb-enabled");\n', '\n', '        uint256 packed = BPackedUtils.setSB(uint256(packedTimes), (USE_ETH | USE_NO_ENC));\n', '\n', '        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);\n', '        commAuction.noteBallotDeployed(democHash);\n', '\n', '        emit CommunityBallot(democHash, ballotId);\n', '    }\n', '\n', '    // only way a democ admin can deploy a ballot\n', '    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed)\n', '                          onlyDemocEditor(democHash)\n', '                          external payable {\n', '\n', '        _deployBallot(democHash, specHash, extraData, packed, true, false);\n', '    }\n', '\n', '    // internal logic around adding a ballot\n', '    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {\n', '        // backend handles events\n', '        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);\n', '    }\n', '\n', '    // check an account has paid up enough for this ballot\n', '    function _accountOkayChecks(bytes32 democHash, uint64 endTime) internal view {\n', '        // if the ballot is marked as official require the democracy is paid up to\n', '        // some relative amount - exclude NFP accounts from this check\n', '        uint secsLeft = payments.getSecondsRemaining(democHash);\n', '        // must be positive due to ending in future check\n', '        uint256 secsToEndTime = endTime - now;\n', '        // require ballots end no more than twice the time left on the democracy\n', '        require(secsLeft * 2 > secsToEndTime, "unpaid");\n', '    }\n', '\n', '    function _basicBallotLimitOperations(bytes32 democHash, BBFarmIface _bbFarm) internal returns (bool shouldCount, bool performedSend) {\n', '        // if we&#39;re an official ballot and the democ is basic, ensure the democ\n', '        // isn&#39;t over the ballots/mo limit\n', '        if (payments.getPremiumStatus(democHash) == false) {\n', '            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();\n', '            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);\n', '\n', '            // if the democ has less than nBallotsAllowed then it&#39;s guarenteed to be okay\n', '            if (nBallotsAllowed > nBallotsBasicCounted) {\n', '                // and we should count this ballot\n', '                return (true, false);\n', '            }\n', '\n', '            // we want to check the creation timestamp of the nth most recent ballot\n', '            // where n is the # of ballots allowed per month. Note: there isn&#39;t an off\n', '            // by 1 error here because if 1 ballots were allowed per month then we&#39;d want\n', '            // to look at the most recent ballot, so nBallotsBasicCounted-1 in this case.\n', '            // similarly, if X ballots were allowed per month we want to look at\n', '            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_\n', '            // recent than the one we&#39;re looking for.\n', '            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);\n', '            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);\n', '\n', '            // if the earlyBallot was created more than 30 days in the past we should\n', '            // count the new ballot\n', '            if (earlyBallotTs < now - 30 days) {\n', '                return (true, false);\n', '            }\n', '\n', '            // at this point it may be the case that we shouldn&#39;t allow the ballot\n', '            // to be created. (It&#39;s an official ballot for a basic tier democracy\n', '            // where the Nth most recent ballot was created within the last 30 days.)\n', '            // We should now check for payment\n', '            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();\n', '            require(msg.value >= extraBallotFee, "!extra-b-fee");\n', '\n', '            // now that we know they&#39;ve paid the fee, we should send Eth to `payTo`\n', '            // and return the remainder.\n', '            uint remainder = msg.value - extraBallotFee;\n', '            doSafeSend(address(payments), extraBallotFee);\n', '            doSafeSend(msg.sender, remainder);\n', '            emit PaymentMade([extraBallotFee, remainder]);\n', '            // only in this case (for basic) do we want to return false - don&#39;t count towards the\n', '            // limit because it&#39;s been paid for here.\n', '            return (false, true);\n', '\n', '        } else {  // if we&#39;re premium we don&#39;t count ballots\n', '            return (false, false);\n', '        }\n', '    }\n', '}\n', '\n', 'contract IxBackendIface is hasVersion, ixBackendEvents, permissioned, payoutAllC {\n', '    /* global getters */\n', '    function getGDemocsN() external view returns (uint);\n', '    function getGDemoc(uint id) external view returns (bytes32);\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\n', '\n', '    /* owner functions */\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) external;\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) external;\n', '\n', '    /* democ admin */\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) external returns (bytes32 democHash);\n', '    function setDOwner(bytes32 democHash, address newOwner) external;\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) external;\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n', '    function setDNoEditors(bytes32 democHash) external;\n', '    function setDErc20(bytes32 democHash, address newErc20) external;\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n', '    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) external;\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) external;\n', '\n', '    /* actually add a ballot */\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) external;\n', '\n', '    /* global democ getters */\n', '    function getDOwner(bytes32 democHash) external view returns (address);\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool);\n', '    function getDHash(bytes13 prefix) external view returns (bytes32);\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots);\n', '    function getDErc20(bytes32 democHash) external view returns (address);\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint);\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool);\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool);\n', '}\n', '\n', 'contract SVIndexBackend is IxBackendIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Democ {\n', '        address erc20;\n', '        address owner;\n', '        bool communityBallotsDisabled;\n', '        bool erc20OwnerClaimDisabled;\n', '        uint editorEpoch;\n', '        mapping (uint => mapping (address => bool)) editors;\n', '        uint256[] allBallots;\n', '        uint256[] includedBasicBallots;  // the IDs of official ballots\n', '\n', '    }\n', '\n', '    struct BallotRef {\n', '        bytes32 democHash;\n', '        uint ballotId;\n', '    }\n', '\n', '    struct Category {\n', '        bool deprecated;\n', '        bytes32 name;\n', '        bool hasParent;\n', '        uint parent;\n', '    }\n', '\n', '    struct CategoriesIx {\n', '        uint nCategories;\n', '        mapping(uint => Category) categories;\n', '    }\n', '\n', '    mapping (bytes32 => Democ) democs;\n', '    mapping (bytes32 => CategoriesIx) democCategories;\n', '    mapping (bytes13 => bytes32) democPrefixToHash;\n', '    mapping (address => bytes32[]) erc20ToDemocs;\n', '    bytes32[] democList;\n', '\n', '    // allows democ admins to store arbitrary data\n', '    // this lets us (for example) set particular keys to signal cerain\n', '    // things to client apps s.t. the admin can turn them on and off.\n', '    // arbitraryData[democHash][key]\n', '    mapping (bytes32 => mapping (bytes32 => bytes)) arbitraryData;\n', '\n', '    /* constructor */\n', '\n', '    constructor() payoutAllC(msg.sender) public {\n', '        // do nothing\n', '    }\n', '\n', '    /* base contract overloads */\n', '\n', '    function _getPayTo() internal view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    /* GLOBAL INFO */\n', '\n', '    function getGDemocsN() external view returns (uint) {\n', '        return democList.length;\n', '    }\n', '\n', '    function getGDemoc(uint id) external view returns (bytes32) {\n', '        return democList[id];\n', '    }\n', '\n', '    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes) {\n', '        return erc20ToDemocs[erc20];\n', '    }\n', '\n', '    /* DEMOCRACY ADMIN FUNCTIONS */\n', '\n', '    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {\n', '        democList.push(democHash);\n', '        Democ storage d = democs[democHash];\n', '        d.erc20 = erc20;\n', '        if (disableErc20OwnerClaim) {\n', '            d.erc20OwnerClaimDisabled = true;\n', '        }\n', '        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31\n', '        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));\n', '        democPrefixToHash[bytes13(democHash)] = democHash;\n', '        erc20ToDemocs[erc20].push(democHash);\n', '        _setDOwner(democHash, initOwner);\n', '        emit NewDemoc(democHash);\n', '    }\n', '\n', '    /* owner democ admin functions */\n', '\n', '    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external {\n', '        _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim);\n', '        emit ManuallyAddedDemoc(democHash, erc20);\n', '    }\n', '\n', '    /* Preferably for emergencies only */\n', '\n', '    function emergencySetDOwner(bytes32 democHash, address newOwner) only_owner() external {\n', '        _setDOwner(democHash, newOwner);\n', '        emit EmergencyDemocOwner(democHash, newOwner);\n', '    }\n', '\n', '    /* user democ admin functions */\n', '\n', '    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\n', '        // generating the democHash in this way guarentees it&#39;ll be unique/hard-to-brute-force\n', '        // (particularly because prevBlockHash and now are part of the hash)\n', '        democHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\n', '        _addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\n', '    }\n', '\n', '    function _setDOwner(bytes32 democHash, address newOwner) internal {\n', '        Democ storage d = democs[democHash];\n', '        uint epoch = d.editorEpoch;\n', '        d.owner = newOwner;\n', '        // unset prev owner as editor - does little if one was not set\n', '        d.editors[epoch][d.owner] = false;\n', '        // make new owner an editor too\n', '        d.editors[epoch][newOwner] = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwner(bytes32 democHash, address newOwner) only_editors() external {\n', '        _setDOwner(democHash, newOwner);\n', '    }\n', '\n', '    function setDOwnerFromClaim(bytes32 democHash, address newOwner) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        // make sure that the owner claim is enabled (i.e. the disabled flag is false)\n', '        require(d.erc20OwnerClaimDisabled == false, "!erc20-claim");\n', '        // set owner and editor\n', '        d.owner = newOwner;\n', '        d.editors[d.editorEpoch][newOwner] = true;\n', '        // disable the ability to claim now that it&#39;s done\n', '        d.erc20OwnerClaimDisabled = true;\n', '        emit DemocOwnerSet(democHash, newOwner);\n', '        emit DemocClaimed(democHash);\n', '    }\n', '\n', '    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {\n', '        Democ storage d = democs[democHash];\n', '        d.editors[d.editorEpoch][editor] = canEdit;\n', '        emit DemocEditorSet(democHash, editor, canEdit);\n', '    }\n', '\n', '    function setDNoEditors(bytes32 democHash) only_editors() external {\n', '        democs[democHash].editorEpoch += 1;\n', '        emit DemocEditorsWiped(democHash);\n', '    }\n', '\n', '    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {\n', '        democs[democHash].erc20 = newErc20;\n', '        erc20ToDemocs[newErc20].push(democHash);\n', '        emit DemocErc20Set(democHash, newErc20);\n', '    }\n', '\n', '    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(key);\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n', '        bytes32 k = keccak256(_calcEditorKey(key));\n', '        arbitraryData[democHash][k] = value;\n', '        emit DemocDataSet(democHash, k);\n', '    }\n', '\n', '    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {\n', '        uint catId = democCategories[democHash].nCategories;\n', '        democCategories[democHash].categories[catId].name = name;\n', '        if (hasParent) {\n', '            democCategories[democHash].categories[catId].hasParent = true;\n', '            democCategories[democHash].categories[catId].parent = parent;\n', '        }\n', '        democCategories[democHash].nCategories += 1;\n', '        emit DemocCatAdded(democHash, catId);\n', '    }\n', '\n', '    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {\n', '        democCategories[democHash].categories[catId].deprecated = true;\n', '        emit DemocCatDeprecated(democHash, catId);\n', '    }\n', '\n', '    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {\n', '        democs[democHash].communityBallotsDisabled = !enabled;\n', '        emit DemocCommunityBallotsEnabled(democHash, enabled);\n', '    }\n', '\n', '    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {\n', '        democs[democHash].erc20OwnerClaimDisabled = true;\n', '        emit DemocErc20OwnerClaimDisabled(democHash);\n', '    }\n', '\n', '    //* ADD BALLOT TO RECORD */\n', '\n', '    function _commitBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) internal {\n', '        uint16 subBits;\n', '        subBits = BPackedUtils.packedToSubmissionBits(packed);\n', '\n', '        uint localBallotId = democs[democHash].allBallots.length;\n', '        democs[democHash].allBallots.push(ballotId);\n', '\n', '        // do this for anything that doesn&#39;t qualify as a community ballot\n', '        if (countTowardsLimit) {\n', '            democs[democHash].includedBasicBallots.push(ballotId);\n', '        }\n', '\n', '        emit NewBallot(democHash, localBallotId);\n', '    }\n', '\n', '    // what SVIndex uses to add a ballot\n', '    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) only_editors() external {\n', '        _commitBallot(democHash, ballotId, packed, countTowardsLimit);\n', '    }\n', '\n', '    /* democ getters */\n', '\n', '    function getDOwner(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].owner;\n', '    }\n', '\n', '    function isDEditor(bytes32 democHash, address editor) external view returns (bool) {\n', '        Democ storage d = democs[democHash];\n', '        // allow either an editor or always the owner\n', '        return d.editors[d.editorEpoch][editor] || editor == d.owner;\n', '    }\n', '\n', '    function getDHash(bytes13 prefix) external view returns (bytes32) {\n', '        return democPrefixToHash[prefix];\n', '    }\n', '\n', '    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots) {\n', '        return (democs[democHash].erc20, democs[democHash].owner, democs[democHash].allBallots.length);\n', '    }\n', '\n', '    function getDErc20(bytes32 democHash) external view returns (address) {\n', '        return democs[democHash].erc20;\n', '    }\n', '\n', '    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(key)];\n', '    }\n', '\n', '    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n', '        return arbitraryData[democHash][keccak256(_calcEditorKey(key))];\n', '    }\n', '\n', '    function getDBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].allBallots.length;\n', '    }\n', '\n', '    function getDBallotID(bytes32 democHash, uint256 n) external view returns (uint ballotId) {\n', '        return democs[democHash].allBallots[n];\n', '    }\n', '\n', '    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots.length;\n', '    }\n', '\n', '    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256) {\n', '        return democs[democHash].includedBasicBallots[n];\n', '    }\n', '\n', '    function getDCategoriesN(bytes32 democHash) external view returns (uint) {\n', '        return democCategories[democHash].nCategories;\n', '    }\n', '\n', '    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint256 parent) {\n', '        deprecated = democCategories[democHash].categories[catId].deprecated;\n', '        name = democCategories[democHash].categories[catId].name;\n', '        hasParent = democCategories[democHash].categories[catId].hasParent;\n', '        parent = democCategories[democHash].categories[catId].parent;\n', '    }\n', '\n', '    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].communityBallotsDisabled;\n', '    }\n', '\n', '    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool) {\n', '        return !democs[democHash].erc20OwnerClaimDisabled;\n', '    }\n', '\n', '    /* util for calculating editor key */\n', '\n', '    function _calcEditorKey(bytes key) internal pure returns (bytes) {\n', '        return abi.encodePacked("editor.", key);\n', '    }\n', '}\n', '\n', 'contract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable {\n', '    /* in emergency break glass */\n', '    function emergencySetOwner(address newOwner) external;\n', '\n', '    /* financial calcluations */\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint secs);\n', '    function weiToCents(uint w) public view returns (uint);\n', '    function centsToWei(uint c) public view returns (uint);\n', '\n', '    /* account management */\n', '    function payForDemocracy(bytes32 democHash) external payable;\n', '    function doFreeExtension(bytes32 democHash) external;\n', '    function downgradeToBasic(bytes32 democHash) external;\n', '    function upgradeToPremium(bytes32 democHash) external;\n', '\n', '    /* account status - getters */\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool);\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool);\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool);\n', '\n', '    /* admin utils for accounts */\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\n', '\n', '    /* admin setters global */\n', '    function setPayTo(address) external;\n', '    function setMinorEditsAddr(address) external;\n', '    function setBasicCentsPricePer30Days(uint amount) external;\n', '    function setBasicBallotsPer30Days(uint amount) external;\n', '    function setPremiumMultiplier(uint8 amount) external;\n', '    function setWeiPerCent(uint) external;\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\n', '    function setMinWeiForDInit(uint amount) external;\n', '\n', '    /* global getters */\n', '    function getBasicCentsPricePer30Days() external view returns(uint);\n', '    function getBasicExtraBallotFeeWei() external view returns (uint);\n', '    function getBasicBallotsPer30Days() external view returns (uint);\n', '    function getPremiumMultiplier() external view returns (uint8);\n', '    function getPremiumCentsPricePer30Days() external view returns (uint);\n', '    function getWeiPerCent() external view returns (uint weiPerCent);\n', '    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\n', '    function getMinWeiForDInit() external view returns (uint);\n', '\n', '    /* payments stuff */\n', '    function getPaymentLogN() external view returns (uint);\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\n', '}\n', '\n', 'contract SVPayments is IxPaymentsIface {\n', '    uint constant VERSION = 2;\n', '\n', '    struct Account {\n', '        bool isPremium;\n', '        uint lastPaymentTs;\n', '        uint paidUpTill;\n', '        uint lastUpgradeTs;  // timestamp of the last time it was upgraded to premium\n', '    }\n', '\n', '    struct PaymentLog {\n', '        bool _external;\n', '        bytes32 _democHash;\n', '        uint _seconds;\n', '        uint _ethValue;\n', '    }\n', '\n', '    // this is an address that&#39;s only allowed to make minor edits\n', '    // e.g. setExchangeRate, setDenyPremium, giveTimeToDemoc\n', '    address public minorEditsAddr;\n', '\n', '    // payment details\n', '    uint basicCentsPricePer30Days = 125000; // $1250/mo\n', '    uint basicBallotsPer30Days = 10;\n', '    uint8 premiumMultiplier = 5;\n', '    uint weiPerCent = 0.000016583747 ether;  // $603, 4th June 2018\n', '\n', '    uint minWeiForDInit = 1;  // minimum 1 wei - match existing behaviour in SVIndex\n', '\n', '    mapping (bytes32 => Account) accounts;\n', '    PaymentLog[] payments;\n', '\n', '    // can set this on freeExtension democs to deny them premium upgrades\n', '    mapping (bytes32 => bool) denyPremium;\n', '    // this is used for non-profits or organisations that have perpetual licenses, etc\n', '    mapping (bytes32 => bool) freeExtension;\n', '\n', '\n', '    /* BREAK GLASS IN CASE OF EMERGENCY */\n', '    // this is included here because something going wrong with payments is possibly\n', '    // the absolute worst case. Note: does this have negligable benefit if the other\n', '    // contracts are compromised? (e.g. by a leaked privkey)\n', '    address public emergencyAdmin;\n', '    function emergencySetOwner(address newOwner) external {\n', '        require(msg.sender == emergencyAdmin, "!emergency-owner");\n', '        owner = newOwner;\n', '    }\n', '    /* END BREAK GLASS */\n', '\n', '\n', '    constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public {\n', '        emergencyAdmin = _emergencyAdmin;\n', '        assert(_emergencyAdmin != address(0));\n', '    }\n', '\n', '    /* base SCs */\n', '\n', '    function getVersion() external pure returns (uint) {\n', '        return VERSION;\n', '    }\n', '\n', '    function() payable public {\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal {\n', '        uint prevPaidTill = accounts[democHash].paidUpTill;\n', '        if (prevPaidTill < now) {\n', '            prevPaidTill = now;\n', '        }\n', '\n', '        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;\n', '        accounts[democHash].lastPaymentTs = now;\n', '    }\n', '\n', '    /* Financial Calculations */\n', '\n', '    function weiBuysHowManySeconds(uint amount) public view returns (uint) {\n', '        uint centsPaid = weiToCents(amount);\n', '        // multiply by 10**18 to ensure we make rounding errors insignificant\n', '        uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days;\n', '        uint secondsOffsetPaid = monthsOffsetPaid * (30 days);\n', '        uint additionalSeconds = secondsOffsetPaid / (10 ** 18);\n', '        return additionalSeconds;\n', '    }\n', '\n', '    function weiToCents(uint w) public view returns (uint) {\n', '        return w / weiPerCent;\n', '    }\n', '\n', '    function centsToWei(uint c) public view returns (uint) {\n', '        return c * weiPerCent;\n', '    }\n', '\n', '    /* account management */\n', '\n', '    function payForDemocracy(bytes32 democHash) external payable {\n', '        require(msg.value > 0, "need to send some ether to make payment");\n', '\n', '        uint additionalSeconds = weiBuysHowManySeconds(msg.value);\n', '\n', '        if (accounts[democHash].isPremium) {\n', '            additionalSeconds /= premiumMultiplier;\n', '        }\n', '\n', '        if (additionalSeconds >= 1) {\n', '            _modAccountBalance(democHash, additionalSeconds);\n', '        }\n', '        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));\n', '        emit AccountPayment(democHash, additionalSeconds);\n', '\n', '        _getPayTo().transfer(msg.value);\n', '    }\n', '\n', '    function doFreeExtension(bytes32 democHash) external {\n', '        require(freeExtension[democHash], "!free");\n', '        uint newPaidUpTill = now + 60 days;\n', '        accounts[democHash].paidUpTill = newPaidUpTill;\n', '        emit FreeExtension(democHash);\n', '    }\n', '\n', '    function downgradeToBasic(bytes32 democHash) only_editors() external {\n', '        require(accounts[democHash].isPremium, "!premium");\n', '        accounts[democHash].isPremium = false;\n', '        // convert premium minutes to basic\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', '        // if we have time remaining: convert it\n', '        if (timeRemaining > 0) {\n', '            // prevent accounts from downgrading if they have time remaining\n', '            // and upgraded less than 24hrs ago\n', '            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), "downgrade-too-soon");\n', '            timeRemaining *= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        emit DowngradeToBasic(democHash);\n', '    }\n', '\n', '    function upgradeToPremium(bytes32 democHash) only_editors() external {\n', '        require(denyPremium[democHash] == false, "upgrade-denied");\n', '        require(!accounts[democHash].isPremium, "!basic");\n', '        accounts[democHash].isPremium = true;\n', '        // convert basic minutes to premium minutes\n', '        uint paidTill = accounts[democHash].paidUpTill;\n', '        uint timeRemaining = SafeMath.subToZero(paidTill, now);\n', '        // if we have time remaning then convert it - otherwise don&#39;t need to do anything\n', '        if (timeRemaining > 0) {\n', '            timeRemaining /= premiumMultiplier;\n', '            accounts[democHash].paidUpTill = now + timeRemaining;\n', '        }\n', '        accounts[democHash].lastUpgradeTs = now;\n', '        emit UpgradedToPremium(democHash);\n', '    }\n', '\n', '    /* account status - getters */\n', '\n', '    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].paidUpTill >= now;\n', '    }\n', '\n', '    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {\n', '        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);\n', '    }\n', '\n', '    function getPremiumStatus(bytes32 democHash) external view returns (bool) {\n', '        return accounts[democHash].isPremium;\n', '    }\n', '\n', '    function getFreeExtension(bytes32 democHash) external view returns (bool) {\n', '        return freeExtension[democHash];\n', '    }\n', '\n', '    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {\n', '        isPremium = accounts[democHash].isPremium;\n', '        lastPaymentTs = accounts[democHash].lastPaymentTs;\n', '        paidUpTill = accounts[democHash].paidUpTill;\n', '        hasFreeExtension = freeExtension[democHash];\n', '    }\n', '\n', '    function getDenyPremium(bytes32 democHash) external view returns (bool) {\n', '        return denyPremium[democHash];\n', '    }\n', '\n', '    /* admin utils for accounts */\n', '\n', '    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {\n', '        _modAccountBalance(democHash, additionalSeconds);\n', '        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));\n', '        emit GrantedAccountTime(democHash, additionalSeconds, ref);\n', '    }\n', '\n', '    /* admin setters global */\n', '\n', '    function setPayTo(address newPayTo) only_owner() external {\n', '        _setPayTo(newPayTo);\n', '        emit SetPayTo(newPayTo);\n', '    }\n', '\n', '    function setMinorEditsAddr(address a) only_owner() external {\n', '        minorEditsAddr = a;\n', '        emit SetMinorEditsAddr(a);\n', '    }\n', '\n', '    function setBasicCentsPricePer30Days(uint amount) only_owner() external {\n', '        basicCentsPricePer30Days = amount;\n', '        emit SetBasicCentsPricePer30Days(amount);\n', '    }\n', '\n', '    function setBasicBallotsPer30Days(uint amount) only_owner() external {\n', '        basicBallotsPer30Days = amount;\n', '        emit SetBallotsPer30Days(amount);\n', '    }\n', '\n', '    function setPremiumMultiplier(uint8 m) only_owner() external {\n', '        premiumMultiplier = m;\n', '        emit SetPremiumMultiplier(m);\n', '    }\n', '\n', '    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {\n', '        weiPerCent = wpc;\n', '        emit SetExchangeRate(wpc);\n', '    }\n', '\n', '    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {\n', '        freeExtension[democHash] = hasFreeExt;\n', '        emit SetFreeExtension(democHash, hasFreeExt);\n', '    }\n', '\n', '    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {\n', '        denyPremium[democHash] = isPremiumDenied;\n', '        emit SetDenyPremium(democHash, isPremiumDenied);\n', '    }\n', '\n', '    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {\n', '        minWeiForDInit = amount;\n', '        emit SetMinWeiForDInit(amount);\n', '    }\n', '\n', '    /* global getters */\n', '\n', '    function getBasicCentsPricePer30Days() external view returns (uint) {\n', '        return basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getBasicExtraBallotFeeWei() external view returns (uint) {\n', '        return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days);\n', '    }\n', '\n', '    function getBasicBallotsPer30Days() external view returns (uint) {\n', '        return basicBallotsPer30Days;\n', '    }\n', '\n', '    function getPremiumMultiplier() external view returns (uint8) {\n', '        return premiumMultiplier;\n', '    }\n', '\n', '    function getPremiumCentsPricePer30Days() external view returns (uint) {\n', '        return _premiumPricePer30Days();\n', '    }\n', '\n', '    function _premiumPricePer30Days() internal view returns (uint) {\n', '        return uint(premiumMultiplier) * basicCentsPricePer30Days;\n', '    }\n', '\n', '    function getWeiPerCent() external view returns (uint) {\n', '        return weiPerCent;\n', '    }\n', '\n', '    function getUsdEthExchangeRate() external view returns (uint) {\n', '        // this returns cents per ether\n', '        return 1 ether / weiPerCent;\n', '    }\n', '\n', '    function getMinWeiForDInit() external view returns (uint) {\n', '        return minWeiForDInit;\n', '    }\n', '\n', '    /* payments stuff */\n', '\n', '    function getPaymentLogN() external view returns (uint) {\n', '        return payments.length;\n', '    }\n', '\n', '    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) {\n', '        _external = payments[n]._external;\n', '        _democHash = payments[n]._democHash;\n', '        _seconds = payments[n]._seconds;\n', '        _ethValue = payments[n]._ethValue;\n', '    }\n', '}\n', '\n', 'interface SvEnsIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'interface ENSIface {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', 'contract PublicResolver {\n', '\n', '    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n', '    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n', '    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n', '    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n', '    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n', '    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n', '    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n', '\n', '    event AddrChanged(bytes32 indexed node, address a);\n', '    event ContentChanged(bytes32 indexed node, bytes32 hash);\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n', '    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n', '    event TextChanged(bytes32 indexed node, string indexedKey, string key);\n', '\n', '    struct PublicKey {\n', '        bytes32 x;\n', '        bytes32 y;\n', '    }\n', '\n', '    struct Record {\n', '        address addr;\n', '        bytes32 content;\n', '        string name;\n', '        PublicKey pubkey;\n', '        mapping(string=>string) text;\n', '        mapping(uint256=>bytes) abis;\n', '    }\n', '\n', '    ENSIface ens;\n', '\n', '    mapping (bytes32 => Record) records;\n', '\n', '    modifier only_owner(bytes32 node) {\n', '        require(ens.owner(node) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor.\n', '     * @param ensAddr The ENS registrar contract.\n', '     */\n', '    constructor(ENSIface ensAddr) public {\n', '        ens = ensAddr;\n', '    }\n', '\n', '    /**\n', '     * Sets the address associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param addr The address to set.\n', '     */\n', '    function setAddr(bytes32 node, address addr) public only_owner(node) {\n', '        records[node].addr = addr;\n', '        emit AddrChanged(node, addr);\n', '    }\n', '\n', '    /**\n', '     * Sets the content hash associated with an ENS node.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The node to update.\n', '     * @param hash The content hash to set\n', '     */\n', '    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n', '        records[node].content = hash;\n', '        emit ContentChanged(node, hash);\n', '    }\n', '\n', '    /**\n', '     * Sets the name associated with an ENS node, for reverse records.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param name The name to set.\n', '     */\n', '    function setName(bytes32 node, string name) public only_owner(node) {\n', '        records[node].name = name;\n', '        emit NameChanged(node, name);\n', '    }\n', '\n', '    /**\n', '     * Sets the ABI associated with an ENS node.\n', '     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n', '     * the empty string.\n', '     * @param node The node to update.\n', '     * @param contentType The content type of the ABI\n', '     * @param data The ABI data.\n', '     */\n', '    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n', '        // Content types must be powers of 2\n', '        require(((contentType - 1) & contentType) == 0);\n', '\n', '        records[node].abis[contentType] = data;\n', '        emit ABIChanged(node, contentType);\n', '    }\n', '\n', '    /**\n', '     * Sets the SECP256k1 public key associated with an ENS node.\n', '     * @param node The ENS node to query\n', '     * @param x the X coordinate of the curve point for the public key.\n', '     * @param y the Y coordinate of the curve point for the public key.\n', '     */\n', '    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n', '        records[node].pubkey = PublicKey(x, y);\n', '        emit PubkeyChanged(node, x, y);\n', '    }\n', '\n', '    /**\n', '     * Sets the text data associated with an ENS node and key.\n', '     * May only be called by the owner of that node in the ENS registry.\n', '     * @param node The node to update.\n', '     * @param key The key to set.\n', '     * @param value The text data value to set.\n', '     */\n', '    function setText(bytes32 node, string key, string value) public only_owner(node) {\n', '        records[node].text[key] = value;\n', '        emit TextChanged(node, key, key);\n', '    }\n', '\n', '    /**\n', '     * Returns the text data associated with an ENS node and key.\n', '     * @param node The ENS node to query.\n', '     * @param key The text data key to query.\n', '     * @return The associated text data.\n', '     */\n', '    function text(bytes32 node, string key) public view returns (string) {\n', '        return records[node].text[key];\n', '    }\n', '\n', '    /**\n', '     * Returns the SECP256k1 public key associated with an ENS node.\n', '     * Defined in EIP 619.\n', '     * @param node The ENS node to query\n', '     * @return x, y the X and Y coordinates of the curve point for the public key.\n', '     */\n', '    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n', '        return (records[node].pubkey.x, records[node].pubkey.y);\n', '    }\n', '\n', '    /**\n', '     * Returns the ABI associated with an ENS node.\n', '     * Defined in EIP205.\n', '     * @param node The ENS node to query\n', '     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n', '     * @return contentType The content type of the return value\n', '     * @return data The ABI data\n', '     */\n', '    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n', '        Record storage record = records[node];\n', '        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n', '            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n', '                data = record.abis[contentType];\n', '                return;\n', '            }\n', '        }\n', '        contentType = 0;\n', '    }\n', '\n', '    /**\n', '     * Returns the name associated with an ENS node, for reverse records.\n', '     * Defined in EIP181.\n', '     * @param node The ENS node to query.\n', '     * @return The associated name.\n', '     */\n', '    function name(bytes32 node) public view returns (string) {\n', '        return records[node].name;\n', '    }\n', '\n', '    /**\n', '     * Returns the content hash associated with an ENS node.\n', '     * Note that this resource type is not standardized, and will likely change\n', '     * in future to a resource type based on multihash.\n', '     * @param node The ENS node to query.\n', '     * @return The associated content hash.\n', '     */\n', '    function content(bytes32 node) public view returns (bytes32) {\n', '        return records[node].content;\n', '    }\n', '\n', '    /**\n', '     * Returns the address associated with an ENS node.\n', '     * @param node The ENS node to query.\n', '     * @return The associated address.\n', '     */\n', '    function addr(bytes32 node) public view returns (address) {\n', '        return records[node].addr;\n', '    }\n', '\n', '    /**\n', '     * Returns true if the resolver implements the interface specified by the provided hash.\n', '     * @param interfaceID The ID of the interface to check for.\n', '     * @return True if the contract implements the requested interface.\n', '     */\n', '    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n', '        return interfaceID == ADDR_INTERFACE_ID ||\n', '        interfaceID == CONTENT_INTERFACE_ID ||\n', '        interfaceID == NAME_INTERFACE_ID ||\n', '        interfaceID == ABI_INTERFACE_ID ||\n', '        interfaceID == PUBKEY_INTERFACE_ID ||\n', '        interfaceID == TEXT_INTERFACE_ID ||\n', '        interfaceID == INTERFACE_META_ID;\n', '    }\n', '}\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', '            // of the array. (We don&#39;t need to use the offset into the slot\n', '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', '            // if length < 32 bytes so let&#39;s prepare for that\n', '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', '                // data we don&#39;t care about, but the last `lengthmod` bytes will\n', '                // land at the beginning of the contents of the new array. When\n', '                // we&#39;re done copying, we overwrite the full first word with\n', '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', '                // the following copy loop was copying the origin&#39;s length\n', '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', '            //if we want a zero-length slice let&#39;s just return a zero-length array\n', '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', '                // cb is a circuit breaker in the for loop since there&#39;s\n', '                //  no said feature for inline assembly loops\n', '                // cb = 1 - don&#39;t breaker\n', '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', '            // if lengths don&#39;t match the arrays are not equal\n', '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', '                // if length < 32 bytes so let&#39;s prepare for that\n', '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', '                        // cb is a circuit breaker in the for loop since there&#39;s\n', '                        //  no said feature for inline assembly loops\n', '                        // cb = 1 - don&#39;t breaker\n', '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}']