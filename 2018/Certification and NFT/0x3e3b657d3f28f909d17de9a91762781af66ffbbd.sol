['pragma solidity ^0.4.19;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract PostFactory {\n', '    using SafeMath for uint256;\n', '\n', '    string public name = "Karma Factory";\n', '    string public constant SYMBOL = "KC";\n', '\n', '    uint256 private postId = 1;\n', '    // post IDs start at 1, just like arrays do :)\n', '\n', '    mapping (address => mapping (uint256 => bool)) upvotedPost;\n', '\n', '    mapping (address => mapping (uint256 => bool)) downvotedPost;\n', '\n', '    // checks if a post exists\n', '    mapping (uint256 => bool) postExists;\n', '\n', '    struct Post {\n', '        string link;\n', '        address poster;\n', '        uint256 voteCount;\n', '        uint64 datePosted;\n', '    }\n', '\n', '    mapping (uint256 => Post) posts; // ties postId to a post\n', '\n', '    mapping(string => uint256) linkToPostId; // Ties a post&#39;s link to it&#39;s ID\n', '\n', '    function createPost(string _link) public returns(uint256) {\n', '\n', '        Post memory post = Post({\n', '            link: _link,\n', '            poster: msg.sender,\n', '            voteCount: 0,\n', '            datePosted: uint64(now)\n', '        });\n', '\n', '        posts[postId] = post;\n', '        linkToPostId[_link] = postId;\n', '        postExists[postId] = true;\n', '\n', '        uint256 currentPostId = postId;\n', '        incrementpostId();\n', '\n', '        return currentPostId;\n', '    }\n', '\n', '    function updoot(uint256 _postId) public {\n', '        require(postExists[_postId]);\n', '        upvotedPost[msg.sender][_postId] = true;\n', '        downvotedPost[msg.sender][_postId] = false;\n', '        posts[_postId].voteCount = posts[_postId].voteCount.add(1);\n', '    }\n', '\n', '    function downdoot(uint256 _postId) public {\n', '        require(postExists[_postId]);\n', '        require(posts[_postId].voteCount >= 1);\n', '        upvotedPost[msg.sender][_postId] = false;\n', '        downvotedPost[msg.sender][_postId] = true;\n', '        posts[_postId].voteCount = posts[_postId].voteCount.sub(1);\n', '    }\n', '\n', '    function getPostLink(uint256 _postId) public view returns(string) {\n', '        return posts[_postId].link;\n', '    }\n', '\n', '    function getPostPoster(uint256 _postId) public view returns(address) {\n', '        return posts[_postId].poster;\n', '    }\n', '\n', '    function getPostVoteCount(uint256 _postId) public view returns(uint256) {\n', '        return posts[_postId].voteCount;\n', '    }\n', '\n', '    function getLinkToPostId(string _link) public view returns(uint256) {\n', '        return linkToPostId[_link];\n', '    }\n', '\n', '    function getDatePosted(uint256 _postId) public view returns(uint64) {\n', '        return posts[_postId].datePosted;\n', '    }\n', '\n', '    function incrementpostId() internal {\n', '        postId = postId.add(1);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract KarmaCenter is PostFactory {\n', '    using SafeMath for uint256;\n', '\n', '    // The KarmaCoin token being minted\n', '    ERC20Basic public token;\n', '    \n', '    // My wallet\n', '    address private controller;\n', '\n', '    event GameWon(address indexed winner, uint256 valueUnlocked);\n', '\n', '    //Constructor\n', '    function KarmaCenter(ERC20Basic _token) public {\n', '        token = _token;\n', '        controller = msg.sender;\n', '    }\n', '\n', '    function () public payable {\n', '        controller.transfer(msg.value);\n', '    }\n', '\n', '    function updoot(uint256 _postId) public {\n', '        require(postExists[_postId]);\n', '        require(token.balanceOf(msg.sender) > 0);\n', '        upvotedPost[msg.sender][_postId] = true;\n', '        downvotedPost[msg.sender][_postId] = false;\n', '        posts[_postId].voteCount = posts[_postId].voteCount.add(1);\n', '        address poster = posts[_postId].poster;\n', '        token.transfer(poster, 1);\n', '    }\n', '\n', '    function downdoot(uint256 _postId) public {\n', '        require(postExists[_postId]);\n', '        require(posts[_postId].voteCount >= 1);\n', '        upvotedPost[msg.sender][_postId] = false;\n', '        downvotedPost[msg.sender][_postId] = true;\n', '        posts[_postId].voteCount = posts[_postId].voteCount.sub(1);\n', '    }\n', '\n', '}']