['pragma solidity ^0.4.23;\n', '\n', 'interface RegistryInterface {\n', '  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n', '      external view returns (bytes32 latest_name);\n', '  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n', '      external view returns (address index, bytes4[] selectors, address[] implementations);\n', '}\n', '\n', 'contract AbstractStorage {\n', '\n', '  // Special storage locations - applications can read from 0x0 to get the execution id, and 0x20\n', '  // to get the sender from which the call originated\n', '  bytes32 private exec_id;\n', '  address private sender;\n', '\n', '  // Keeps track of the number of applicaions initialized, so that each application has a unique execution id\n', '  uint private nonce;\n', '\n', '  /// EVENTS ///\n', '\n', '  event ApplicationInitialized(bytes32 indexed execution_id, address indexed index, address script_exec);\n', '  event ApplicationExecution(bytes32 indexed execution_id, address indexed script_target);\n', '  event DeliveredPayment(bytes32 indexed execution_id, address indexed destination, uint amount);\n', '\n', '  /// CONSTANTS ///\n', '\n', '  // STORAGE LOCATIONS //\n', '\n', '  bytes32 internal constant EXEC_PERMISSIONS = keccak256(&#39;script_exec_permissions&#39;);\n', '  bytes32 internal constant APP_IDX_ADDR = keccak256(&#39;index&#39;);\n', '\n', '  // ACTION REQUESTORS //\n', '\n', '  bytes4 internal constant EMITS = bytes4(keccak256(&#39;Emit((bytes32[],bytes)[])&#39;));\n', '  bytes4 internal constant STORES = bytes4(keccak256(&#39;Store(bytes32[])&#39;));\n', '  bytes4 internal constant PAYS = bytes4(keccak256(&#39;Pay(bytes32[])&#39;));\n', '  bytes4 internal constant THROWS = bytes4(keccak256(&#39;Error(string)&#39;));\n', '\n', '  // SELECTORS //\n', '\n', '  bytes4 internal constant REG_APP\n', '      = bytes4(keccak256(&#39;registerApp(bytes32,address,bytes4[],address[])&#39;));\n', '  bytes4 internal constant REG_APP_VER\n', '      = bytes4(keccak256(&#39;registerAppVersion(bytes32,bytes32,address,bytes4[],address[])&#39;));\n', '  bytes4 internal constant UPDATE_EXEC_SEL\n', '      = bytes4(keccak256(&#39;updateExec(address)&#39;));\n', '  bytes4 internal constant UPDATE_INST_SEL\n', '      = bytes4(keccak256(&#39;updateInstance(bytes32,bytes32,bytes32)&#39;));\n', '\n', '  // Creates an instance of a registry application and returns the execution id\n', '  function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n', '    bytes32 new_exec_id = keccak256(++nonce);\n', '    put(new_exec_id, keccak256(msg.sender, EXEC_PERMISSIONS), bytes32(1));\n', '    put(new_exec_id, APP_IDX_ADDR, bytes32(_registry_idx));\n', '    put(new_exec_id, keccak256(REG_APP, &#39;implementation&#39;), bytes32(_implementation));\n', '    put(new_exec_id, keccak256(REG_APP_VER, &#39;implementation&#39;), bytes32(_implementation));\n', '    put(new_exec_id, keccak256(UPDATE_INST_SEL, &#39;implementation&#39;), bytes32(_implementation));\n', '    put(new_exec_id, keccak256(UPDATE_EXEC_SEL, &#39;implementation&#39;), bytes32(_implementation));\n', '    emit ApplicationInitialized(new_exec_id, _registry_idx, msg.sender);\n', '    return new_exec_id;\n', '  }\n', '\n', '  /// APPLICATION INSTANCE INITIALIZATION ///\n', '\n', '  /*\n', '  Executes an initialization function of an application, generating a new exec id that will be associated with that address\n', '\n', '  @param _sender: The sender of the transaction, as reported by the script exec contract\n', '  @param _app_name: The name of the application which will be instantiated\n', '  @param _provider: The provider under which the application is registered\n', '  @param _registry_id: The execution id of the registry app\n', '  @param _calldata: The calldata to forward to the application\n', '  @return new_exec_id: A new, unique execution id paired with the created instance of the application\n', '  @return version: The name of the version of the instance\n', '  */\n', '  function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n', '    // Ensure valid input -\n', '    require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, &#39;invalid input&#39;);\n', '\n', '    // Create new exec id by incrementing the nonce -\n', '    new_exec_id = keccak256(++nonce);\n', '\n', '    // Sanity check - verify that this exec id is not linked to an existing application -\n', '    assert(getIndex(new_exec_id) == address(0));\n', '\n', '    // Set the allowed addresses and selectors for the new instance, from the script registry -\n', '    address index;\n', '    (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n', '\n', '    // Set the exec id and sender addresses for the target application -\n', '    setContext(new_exec_id, _sender);\n', '\n', '    // Execute application, create a new exec id, and commit the returned data to storage -\n', '    require(address(index).delegatecall(_calldata) == false, &#39;Unsafe execution&#39;);\n', '    // Get data returned from call revert and perform requested actions -\n', '    executeAppReturn(new_exec_id);\n', '\n', '    // Emit event\n', '    emit ApplicationInitialized(new_exec_id, index, msg.sender);\n', '\n', '    // If execution reaches this point, newly generated exec id should be valid -\n', '    assert(new_exec_id != bytes32(0));\n', '\n', '    // Ensure that any additional balance is transferred back to the sender -\n', '    if (address(this).balance > 0)\n', '      address(msg.sender).transfer(address(this).balance);\n', '  }\n', '\n', '  /*\n', '  Executes an initialized application associated with the given exec id, under the sender&#39;s address and with\n', '  the given calldata\n', '\n', '  @param _sender: The address reported as the call sender by the script exec contract\n', '  @param _exec_id: The execution id corresponding to an instance of the application\n', '  @param _calldata: The calldata to forward to the application\n', '  @return n_emitted: The number of events emitted on behalf of the application\n', '  @return n_paid: The number of destinations ETH was forwarded to on behalf of the application\n', '  @return n_stored: The number of storage slots written to on behalf of the application\n', '  */\n', '  function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n', '    // Ensure valid input and input size - minimum 4 bytes\n', '    require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n', '\n', '    // Get the target address associated with the given exec id\n', '    address target = getTarget(_exec_id, getSelector(_calldata));\n', '    require(target != address(0), &#39;Uninitialized application&#39;);\n', '\n', '    // Set the exec id and sender addresses for the target application -\n', '    setContext(_exec_id, _sender);\n', '\n', '    // Execute application and commit returned data to storage -\n', '    require(address(target).delegatecall(_calldata) == false, &#39;Unsafe execution&#39;);\n', '    (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n', '\n', '    // If no events were emitted, no wei was forwarded, and no storage was changed, revert -\n', '    if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n', '      revert(&#39;No state change occured&#39;);\n', '\n', '    // Emit event -\n', '    emit ApplicationExecution(_exec_id, target);\n', '\n', '    // Ensure that any additional balance is transferred back to the sender -\n', '    if (address(this).balance > 0)\n', '      address(msg.sender).transfer(address(this).balance);\n', '  }\n', '\n', '  /// APPLICATION RETURNDATA HANDLING ///\n', '\n', '  /*\n', '  This function parses data returned by an application and executes requested actions. Because applications\n', '  are assumed to be stateless, they cannot emit events, store data, or forward payment. Therefore, these\n', '  steps to execution are handled in the storage contract by this function.\n', '\n', '  Returned data can execute several actions requested by the application through the use of an &#39;action requestor&#39;:\n', '  Some actions mirror nested dynamic return types, which are manually encoded and decoded as they are not supported\n', '  1. THROWS  - App requests storage revert with a given message\n', '      --Format: bytes\n', '        --Payload is simply an array of bytes that will be reverted back to the caller\n', '  2. EMITS   - App requests that events be emitted. Can provide topics to index, as well as arbitrary length data\n', '      --Format: Event[]\n', '        --Event format: [uint n_topics][bytes32 topic_0]...[bytes32 topic_n][uint data.length][bytes data]\n', '  3. STORES  - App requests that data be stored to its storage. App storage locations are hashed with the app&#39;s exec id\n', '      --Format: bytes32[]\n', '        --bytes32[] consists of a data location followed by a value to place at that location\n', '        --as such, its length must be even\n', '        --Ex: [value_0][location_0]...[value_n][location_n]\n', '  4. PAYS    - App requests that ETH sent to the contract be forwarded to other addresses.\n', '      --Format: bytes32[]\n', '        --bytes32[] consists of an address to send ETH to, followed by an amount to send to that address\n', '        --As such, its length must be even\n', '        --Ex: [amt_0][bytes32(destination_0)]...[amt_n][bytes32(destination_n)]\n', '\n', '  Returndata is structured as an array of bytes, beginning with an action requestor (&#39;THROWS&#39;, &#39;PAYS&#39;, etc)\n', '  followed by that action&#39;s appropriately-formatted data (see above). Up to 3 actions with formatted data can be placed\n', '  into returndata, and each must be unique (i.e. no two &#39;EMITS&#39; actions).\n', '\n', '  If the THROWS action is requested, it must be the first event requested. The event will be parsed\n', '  and logged, and no other actions will be executed. If the THROWS requestor is not the first action\n', '  requested, this function will throw\n', '\n', '  @param _exec_id: The execution id which references this application&#39;s storage\n', '  @return n_emitted: The number of events emitted on behalf of the application\n', '  @return n_paid: The number of destinations ETH was forwarded to on behalf of the application\n', '  @return n_stored: The number of storage slots written to on behalf of the application\n', '  */\n', '  function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n', '    uint _ptr;      // Will be a pointer to the data returned by the application call\n', '    uint ptr_bound; // Will be the maximum value of the pointer possible (end of the memory stored in the pointer)\n', '    (ptr_bound, _ptr) = getReturnedData();\n', '    // If the application reverted with an error, we can check directly for its selector -\n', '    if (getAction(_ptr) == THROWS) {\n', '      // Execute THROWS request\n', '      doThrow(_ptr);\n', '      // doThrow should revert, so we should never reach this point\n', '      assert(false);\n', '    }\n', '\n', '    // Ensure there are at least 64 bytes stored at the pointer\n', '    require(ptr_bound >= _ptr + 64, &#39;Malformed returndata - invalid size&#39;);\n', '    _ptr += 64;\n', '\n', '    // Iterate over returned data and execute actions\n', '    bytes4 action;\n', '    while (_ptr <= ptr_bound && (action = getAction(_ptr)) != 0x0) {\n', '      if (action == EMITS) {\n', '        // If the action is EMITS, and this action has already been executed, throw\n', '        require(n_emitted == 0, &#39;Duplicate action: EMITS&#39;);\n', '        // Otherwise, emit events and get amount of events emitted\n', '        // doEmit returns the pointer incremented to the end of the data portion of the action executed\n', '        (_ptr, n_emitted) = doEmit(_ptr, ptr_bound);\n', '        // If 0 events were emitted, returndata is malformed: throw\n', '        require(n_emitted != 0, &#39;Unfulfilled action: EMITS&#39;);\n', '      } else if (action == STORES) {\n', '        // If the action is STORES, and this action has already been executed, throw\n', '        require(n_stored == 0, &#39;Duplicate action: STORES&#39;);\n', '        // Otherwise, store data and get amount of slots written to\n', '        // doStore increments the pointer to the end of the data portion of the action executed\n', '        (_ptr, n_stored) = doStore(_ptr, ptr_bound, _exec_id);\n', '        // If no storage was performed, returndata is malformed: throw\n', '        require(n_stored != 0, &#39;Unfulfilled action: STORES&#39;);\n', '      } else if (action == PAYS) {\n', '        // If the action is PAYS, and this action has already been executed, throw\n', '        require(n_paid == 0, &#39;Duplicate action: PAYS&#39;);\n', '        // Otherwise, forward ETH and get amount of addresses forwarded to\n', '        // doPay increments the pointer to the end of the data portion of the action executed\n', '        (_ptr, n_paid) = doPay(_exec_id, _ptr, ptr_bound);\n', '        // If no destinations recieved ETH, returndata is malformed: throw\n', '        require(n_paid != 0, &#39;Unfulfilled action: PAYS&#39;);\n', '      } else {\n', '        // Unrecognized action requested. returndata is malformed: throw\n', '        revert(&#39;Malformed returndata - unknown action&#39;);\n', '      }\n', '    }\n', '    assert(n_emitted != 0 || n_paid != 0 || n_stored != 0);\n', '  }\n', '\n', '  /// HELPERS ///\n', '\n', '  /*\n', '  Reads application information from the script registry, and sets up permissions for the new instance&#39;s various functions\n', '\n', '  @param _new_exec_id: The execution id being created, for which permissions will be registered\n', '  @param _app_name: The name of the new application instance - corresponds to an application registered by the provider under that name\n', '  @param _provider: The address of the account that registered an application under the given name\n', '  @param _registry_id: The exec id of the registry from which the information will be read\n', '  */\n', '  function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n', '    // Get the index address for the registry app associated with the passed-in exec id\n', '    index = getIndex(_registry_id);\n', '    require(index != address(0) && index != address(this), &#39;Registry application not found&#39;);\n', '    // Get the name of the latest version from the registry app at the given address\n', '    version = RegistryInterface(index).getLatestVersion(\n', '      address(this), _registry_id, _provider, _app_name\n', '    );\n', '    // Ensure the version name is valid -\n', '    require(version != bytes32(0), &#39;Invalid version name&#39;);\n', '\n', '    // Get the allowed selectors and addresses for the new instance from the registry app\n', '    bytes4[] memory selectors;\n', '    address[] memory implementations;\n', '    (index, selectors, implementations) = RegistryInterface(index).getVersionImplementation(\n', '      address(this), _registry_id, _provider, _app_name, version\n', '    );\n', '    // Ensure a valid index address for the new instance -\n', '    require(index != address(0), &#39;Invalid index address&#39;);\n', '    // Ensure a nonzero number of allowed selectors and implementing addresses -\n', '    require(selectors.length == implementations.length && selectors.length != 0, &#39;Invalid implementation length&#39;);\n', '\n', '    // Set the index address for the new instance -\n', '    bytes32 seed = APP_IDX_ADDR;\n', '    put(_new_exec_id, seed, bytes32(index));\n', '    // Loop over implementing addresses, and map each function selector to its corresponding address for the new instance\n', '    for (uint i = 0; i < selectors.length; i++) {\n', '      require(selectors[i] != 0 && implementations[i] != 0, &#39;invalid input - expected nonzero implementation&#39;);\n', '      seed = keccak256(selectors[i], &#39;implementation&#39;);\n', '      put(_new_exec_id, seed, bytes32(implementations[i]));\n', '    }\n', '\n', '    return (index, version);\n', '  }\n', '\n', '  // Returns the index address of an application using a given exec id, or 0x0\n', '  // if the instance does not exist\n', '  function getIndex(bytes32 _exec_id) public view returns (address) {\n', '    bytes32 seed = APP_IDX_ADDR;\n', '    function (bytes32, bytes32) view returns (address) getter;\n', '    assembly { getter := readMap }\n', '    return getter(_exec_id, seed);\n', '  }\n', '\n', '  // Returns the address to which calldata with the given selector will be routed\n', '  function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n', '    bytes32 seed = keccak256(_selector, &#39;implementation&#39;);\n', '    function (bytes32, bytes32) view returns (address) getter;\n', '    assembly { getter := readMap }\n', '    return getter(_exec_id, seed);\n', '  }\n', '\n', '  struct Map { mapping(bytes32 => bytes32) inner; }\n', '\n', '  // Receives a storage pointer and returns the value mapped to the seed at that pointer\n', '  function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n', '    return _map.inner[_seed];\n', '  }\n', '\n', '  // Maps the seed to the value within the execution id&#39;s storage\n', '  function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n', '    function (bytes32, bytes32, bytes32) puts;\n', '    assembly { puts := putMap }\n', '    puts(_exec_id, _seed, _val);\n', '  }\n', '\n', '  // Receives a storage pointer and maps the seed to the value at that pointer\n', '  function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n', '    _map.inner[_seed] = _val;\n', '  }\n', '\n', '  /// APPLICATION EXECUTION ///\n', '\n', '  function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n', '    assembly {\n', '      sel := and(\n', '        mload(add(0x20, _calldata)),\n', '        0xffffffff00000000000000000000000000000000000000000000000000000000\n', '      )\n', '    }\n', '  }\n', '\n', '  /*\n', '  After validating that returned data is larger than 32 bytes, returns a pointer to the returned data\n', '  in memory, as well as a pointer to the end of returndata in memory\n', '\n', '  @return ptr_bounds: The pointer cannot be this value and be reading from returndata\n', '  @return _returndata_ptr: A pointer to the returned data in memory\n', '  */\n', '  function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n', '    assembly {\n', '      // returndatasize must be minimum 96 bytes (offset, length, and requestor)\n', '      if lt(returndatasize, 0x60) {\n', '        mstore(0, 0x20)\n', '        mstore(0x20, 24)\n', '        mstore(0x40, &#39;Insufficient return size&#39;)\n', '        revert(0, 0x60)\n', '      }\n', '      // Get memory location to which returndata will be copied\n', '      _returndata_ptr := msize\n', '      // Copy returned data to pointer location\n', '      returndatacopy(_returndata_ptr, 0, returndatasize)\n', '      // Get maximum memory location value for returndata\n', '      ptr_bounds := add(_returndata_ptr, returndatasize)\n', '      // Set new free-memory pointer to point after the returndata in memory\n', '      // Returndata is automatically 32-bytes padded\n', '      mstore(0x40, add(0x20, ptr_bounds))\n', '    }\n', '  }\n', '\n', '  /*\n', '  Returns the value stored in memory at the pointer. Used to determine the size of fields in returned data\n', '\n', '  @param _ptr: A pointer to some location in memory containing returndata\n', '  @return length: The value stored at that pointer\n', '  */\n', '  function getLength(uint _ptr) internal pure returns (uint length) {\n', '    assembly { length := mload(_ptr) }\n', '  }\n', '\n', '  // Executes the THROWS action, reverting any returned data back to the caller\n', '  function doThrow(uint _ptr) internal pure {\n', '    assert(getAction(_ptr) == THROWS);\n', '    assembly { revert(_ptr, returndatasize) }\n', '  }\n', '\n', '  /*\n', '  Parses and executes a PAYS action copied from returndata and located at the pointer\n', '  A PAYS action provides a set of addresses and corresponding amounts of ETH to send to those\n', '  addresses. The sender must ensure the call has sufficient funds, or the call will fail\n', '  PAYS actions follow a format of: [amt_0][address_0]...[amt_n][address_n]\n', '\n', '  @param _ptr: A pointer in memory to an application&#39;s returned payment request\n', '  @param _ptr_bound: The upper bound on the value for _ptr before it is reading invalid data\n', '  @return ptr: An updated pointer, pointing to the end of the PAYS action request in memory\n', '  @return n_paid: The number of destinations paid out to from the returned PAYS request\n', '  */\n', '  function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n', '    // Ensure ETH was sent with the call\n', '    require(msg.value > 0);\n', '    assert(getAction(_ptr) == PAYS);\n', '    _ptr += 4;\n', '    // Get number of destinations\n', '    uint num_destinations = getLength(_ptr);\n', '    _ptr += 32;\n', '    address pay_to;\n', '    uint amt;\n', '    // Loop over PAYS actions and process each one\n', '    while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n', '      // Get the payment destination and amount from the pointer\n', '      assembly {\n', '        amt := mload(_ptr)\n', '        pay_to := mload(add(0x20, _ptr))\n', '      }\n', '      // Invalid address was passed as a payment destination - throw\n', '      if (pay_to == address(0) || pay_to == address(this))\n', '        revert(&#39;PAYS: invalid destination&#39;);\n', '\n', '      // Forward ETH and increment n_paid\n', '      address(pay_to).transfer(amt);\n', '      n_paid++;\n', '      // Increment pointer\n', '      _ptr += 64;\n', '      // Emit event\n', '      emit DeliveredPayment(_exec_id, pay_to, amt);\n', '    }\n', '    ptr = _ptr;\n', '    assert(n_paid == num_destinations);\n', '  }\n', '\n', '  /*\n', '  Parses and executes a STORES action copied from returndata and located at the pointer\n', '  A STORES action provides a set of storage locations and corresponding values to store at those locations\n', '  true storage locations within this contract are first hashed with the application&#39;s execution id to prevent\n', '  storage overlaps between applications sharing the contract\n', '  STORES actions follow a format of: [location_0][val_0]...[location_n][val_n]\n', '\n', '  @param _ptr: A pointer in memory to an application&#39;s returned storage request\n', '  @param _ptr_bound: The upper bound on the value for _ptr before it is reading invalid data\n', '  @param _exec_id: The execution id under which storage is located\n', '  @return ptr: An updated pointer, pointing to the end of the STORES action request in memory\n', '  @return n_stored: The number of storage locations written to from the returned STORES request\n', '  */\n', '  function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n', '    assert(getAction(_ptr) == STORES && _exec_id != bytes32(0));\n', '    _ptr += 4;\n', '    // Get number of locations to which data will be stored\n', '    uint num_locations = getLength(_ptr);\n', '    _ptr += 32;\n', '    bytes32 location;\n', '    bytes32 value;\n', '    // Loop over STORES actions and process each one\n', '    while (_ptr <= _ptr_bound && n_stored < num_locations) {\n', '      // Get storage location and value to store from the pointer\n', '      assembly {\n', '        location := mload(_ptr)\n', '        value := mload(add(0x20, _ptr))\n', '      }\n', '      // Store the data to the location hashed with the exec id\n', '      store(_exec_id, location, value);\n', '      // Increment n_stored and pointer\n', '      n_stored++;\n', '      _ptr += 64;\n', '    }\n', '    ptr = _ptr;\n', '    require(n_stored == num_locations);\n', '  }\n', '\n', '  /*\n', '  Parses and executes an EMITS action copied from returndata and located at the pointer\n', '  An EMITS action is a list of bytes that are able to be processed and passed into logging functions (log0, log1, etc)\n', '  EMITS actions follow a format of: [Event_0][Event_1]...[Event_n]\n', '    where each Event_i follows the format: [topic_0]...[topic_4][data.length]<data>\n', '    -The topics array is a bytes32 array of maximum length 4 and minimum 0\n', '    -The final data parameter is a simple bytes array, and is emitted as a non-indexed parameter\n', '\n', '  @param _ptr: A pointer in memory to an application&#39;s returned emit request\n', '  @param _ptr_bound: The upper bound on the value for _ptr before it is reading invalid data\n', '  @return ptr: An updated pointer, pointing to the end of the EMITS action request in memory\n', '  @return n_emitted: The number of events logged from the returned EMITS request\n', '  */\n', '  function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n', '    assert(getAction(_ptr) == EMITS);\n', '    _ptr += 4;\n', '    // Converts number of events that will be emitted\n', '    uint num_events = getLength(_ptr);\n', '    _ptr += 32;\n', '    bytes32[] memory topics;\n', '    bytes memory data;\n', '    // Loop over EMITS actions and process each one\n', '    while (_ptr <= _ptr_bound && n_emitted < num_events) {\n', '      // Get array of topics and additional data from the pointer\n', '      assembly {\n', '        topics := _ptr\n', '        data := add(add(_ptr, 0x20), mul(0x20, mload(topics)))\n', '      }\n', '      // Get size of the Event&#39;s data in memory\n', '      uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n', '      assembly {\n', '        switch mload(topics)                // topics.length\n', '          case 0 {\n', '            // Log Event.data array with no topics\n', '            log0(\n', '              add(0x20, data),              // data(ptr)\n', '              mload(data)                   // data.length\n', '            )\n', '          }\n', '          case 1 {\n', '            // Log Event.data array with 1 topic\n', '            log1(\n', '              add(0x20, data),              // data(ptr)\n', '              mload(data),                  // data.length\n', '              mload(add(0x20, topics))      // topics[0]\n', '            )\n', '          }\n', '          case 2 {\n', '            // Log Event.data array with 2 topics\n', '            log2(\n', '              add(0x20, data),              // data(ptr)\n', '              mload(data),                  // data.length\n', '              mload(add(0x20, topics)),     // topics[0]\n', '              mload(add(0x40, topics))      // topics[1]\n', '            )\n', '          }\n', '          case 3 {\n', '            // Log Event.data array with 3 topics\n', '            log3(\n', '              add(0x20, data),              // data(ptr)\n', '              mload(data),                  // data.length\n', '              mload(add(0x20, topics)),     // topics[0]\n', '              mload(add(0x40, topics)),     // topics[1]\n', '              mload(add(0x60, topics))      // topics[2]\n', '            )\n', '          }\n', '          case 4 {\n', '            // Log Event.data array with 4 topics\n', '            log4(\n', '              add(0x20, data),              // data(ptr)\n', '              mload(data),                  // data.length\n', '              mload(add(0x20, topics)),     // topics[0]\n', '              mload(add(0x40, topics)),     // topics[1]\n', '              mload(add(0x60, topics)),     // topics[2]\n', '              mload(add(0x80, topics))      // topics[3]\n', '            )\n', '          }\n', '          default {\n', '            // Events must have 4 or fewer topics\n', '            mstore(0, &#39;EMITS: invalid topic count&#39;)\n', '            revert(0, 0x20)\n', '          }\n', '      }\n', '      // Event emitted - increment n_emitted and pointer\n', '      n_emitted++;\n', '      _ptr += log_size;\n', '    }\n', '    ptr = _ptr;\n', '    require(n_emitted == num_events);\n', '  }\n', '\n', '  // Return the bytes4 action requestor stored at the pointer, and cleans the remaining bytes\n', '  function getAction(uint _ptr) internal pure returns (bytes4 action) {\n', '    assembly {\n', '      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\n', '      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n', '    }\n', '  }\n', '\n', '  // Sets the execution id and sender address in special storage locations, so that\n', '  // they are able to be read by the target application\n', '  function setContext(bytes32 _exec_id, address _sender) internal {\n', '    // Ensure the exec id and sender are nonzero\n', '    assert(_exec_id != bytes32(0) && _sender != address(0));\n', '    exec_id = _exec_id;\n', '    sender = _sender;\n', '  }\n', '\n', '  // Stores data to a given location, with a key (exec id)\n', '  function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n', '    // Get true location to store data to - hash of location hashed with exec id\n', '    _location = keccak256(_location, _exec_id);\n', '    // Store data at location\n', '    assembly { sstore(_location, _data) }\n', '  }\n', '\n', '  // STORAGE READS //\n', '\n', '  /*\n', '  Returns data stored at a given location\n', '  @param _location: The address to get data from\n', '  @return data: The data stored at the location after hashing\n', '  */\n', '  function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n', '    _location = keccak256(_location, _exec_id);\n', '    assembly { data_read := sload(_location) }\n', '  }\n', '\n', '  /*\n', '  Returns data stored in several nonconsecutive locations\n', '  @param _locations: A dynamic array of storage locations to read from\n', '  @return data_read: The corresponding data stored in the requested locations\n', '  */\n', '  function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n', '    data_read = new bytes32[](_locations.length);\n', '    for (uint i = 0; i < _locations.length; i++) {\n', '      data_read[i] = read(_exec_id, _locations[i]);\n', '    }\n', '  }\n', '}']