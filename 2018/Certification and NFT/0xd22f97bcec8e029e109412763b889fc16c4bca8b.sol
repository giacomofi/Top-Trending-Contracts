['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ee8a8f80878b82ae8281819e9c878089c0819c89">[email&#160;protected]</a>>\n', 'library MathUint {\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg = add(avg, arr[i]);\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs = add(cvs, mul(s, s));\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(newOwner != 0x0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        onlyPendingOwner\n', '        public\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2347424d4a464f634f4c4c53514a4d440d4c5144">[email&#160;protected]</a>>\n', 'contract ERC20 {\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="167277787f737a567a797966647f787138796471">[email&#160;protected]</a>>.\n', 'contract TokenTransferDelegate {\n', '    event AddressAuthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    event AddressDeauthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', '    // This map is used to keep trace of order&#39;s cancellation history.\n', '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses);\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        external;\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        external;\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        external;\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        public;\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        public;\n', '    function setCutoffs(uint t)\n', '        external;\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        external;\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view;\n', '    function suspend() external;\n', '    function resume() external;\n', '    function kill() external;\n', '}\n', '/// @title An Implementation of TokenTransferDelegate.\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6400050a0d010824080b0b14160d0a034a0b1603">[email&#160;protected]</a>>.\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8fe4e0e1e8e3e6eee1e8cfe3e0e0fffde6e1e8a1e0fde8">[email&#160;protected]</a>>.\n', 'contract TokenTransferDelegateImpl is TokenTransferDelegate, Claimable {\n', '    using MathUint for uint;\n', '    bool public suspended = false;\n', '    struct AddressInfo {\n', '        address previous;\n', '        uint32  index;\n', '        bool    authorized;\n', '    }\n', '    mapping(address => AddressInfo) public addressInfos;\n', '    address public latestAddress;\n', '    modifier onlyAuthorized()\n', '    {\n', '        require(addressInfos[msg.sender].authorized);\n', '        _;\n', '    }\n', '    modifier notSuspended()\n', '    {\n', '        require(!suspended);\n', '        _;\n', '    }\n', '    modifier isSuspended()\n', '    {\n', '        require(suspended);\n', '        _;\n', '    }\n', '    /// @dev Disable default function.\n', '    function ()\n', '        payable\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        onlyOwner\n', '        external\n', '    {\n', '        AddressInfo storage addrInfo = addressInfos[addr];\n', '        if (addrInfo.index != 0) { // existing\n', '            if (addrInfo.authorized == false) { // re-authorize\n', '                addrInfo.authorized = true;\n', '                emit AddressAuthorized(addr, addrInfo.index);\n', '            }\n', '        } else {\n', '            address prev = latestAddress;\n', '            if (prev == 0x0) {\n', '                addrInfo.index = 1;\n', '                addrInfo.authorized = true;\n', '            } else {\n', '                addrInfo.previous = prev;\n', '                addrInfo.index = addressInfos[prev].index + 1;\n', '            }\n', '            addrInfo.authorized = true;\n', '            latestAddress = addr;\n', '            emit AddressAuthorized(addr, addrInfo.index);\n', '        }\n', '    }\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint32 index = addressInfos[addr].index;\n', '        if (index != 0) {\n', '            addressInfos[addr].authorized = false;\n', '            emit AddressDeauthorized(addr, index);\n', '        }\n', '    }\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses)\n', '    {\n', '        addresses = new address[](max);\n', '        address addr = latestAddress;\n', '        AddressInfo memory addrInfo;\n', '        uint count = 0;\n', '        while (addr != 0x0 && count < max) {\n', '            addrInfo = addressInfos[addr];\n', '            if (addrInfo.index == 0) {\n', '                break;\n', '            }\n', '            addresses[count++] = addr;\n', '            addr = addrInfo.previous;\n', '        }\n', '    }\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        if (value > 0 && from != to && to != 0x0) {\n', '            require(\n', '                ERC20(token).transferFrom(from, to, value)\n', '            );\n', '        }\n', '    }\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        uint len = batch.length;\n', '        require(len % 7 == 0);\n', '        require(walletSplitPercentage > 0 && walletSplitPercentage < 100);\n', '        ERC20 lrc = ERC20(lrcTokenAddress);\n', '        address prevOwner = address(batch[len - 7]);\n', '        for (uint i = 0; i < len; i += 7) {\n', '            address owner = address(batch[i]);\n', '            // Pay token to previous order, or to miner as previous order&#39;s\n', '            // margin split or/and this order&#39;s margin split.\n', '            ERC20 token = ERC20(address(batch[i + 1]));\n', '            // Here batch[i + 2] has been checked not to be 0.\n', '            if (batch[i + 2] != 0x0 && owner != prevOwner) {\n', '                require(\n', '                    token.transferFrom(\n', '                        owner,\n', '                        prevOwner,\n', '                        uint(batch[i + 2])\n', '                    )\n', '                );\n', '            }\n', '            // Miner pays LRx fee to order owner\n', '            uint lrcReward = uint(batch[i + 4]);\n', '            if (lrcReward != 0 && minerFeeRecipient != owner) {\n', '                require(\n', '                    lrc.transferFrom(\n', '                        minerFeeRecipient,\n', '                        owner,\n', '                        lrcReward\n', '                    )\n', '                );\n', '            }\n', '            // Split margin-split income between miner and wallet\n', '            splitPayFee(\n', '                token,\n', '                uint(batch[i + 3]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            // Split LRx fee income between miner and wallet\n', '            splitPayFee(\n', '                lrc,\n', '                uint(batch[i + 5]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            prevOwner = owner;\n', '        }\n', '    }\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressInfos[addr].authorized;\n', '    }\n', '    function splitPayFee(\n', '        ERC20   token,\n', '        uint    fee,\n', '        address owner,\n', '        address minerFeeRecipient,\n', '        address walletFeeRecipient,\n', '        uint    walletSplitPercentage\n', '        )\n', '        internal\n', '    {\n', '        if (fee == 0) {\n', '            return;\n', '        }\n', '        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;\n', '        uint minerFee = fee.sub(walletFee);\n', '        if (walletFee > 0 && walletFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    walletFeeRecipient,\n', '                    walletFee\n', '                )\n', '            );\n', '        }\n', '        if (minerFee > 0 && minerFeeRecipient != 0x0 && minerFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    minerFeeRecipient,\n', '                    minerFee\n', '                )\n', '            );\n', '        }\n', '    }\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\n', '    }\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        onlyAuthorized\n', '        notSuspended\n', '        public\n', '    {\n', '        cancelledOrFilled[orderHash] = cancelledOrFilled[orderHash].add(cancelOrFillAmount);\n', '    }\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        onlyAuthorized\n', '        notSuspended\n', '        public\n', '    {\n', '        require(batch.length % 2 == 0);\n', '        for (uint i = 0; i < batch.length / 2; i++) {\n', '            cancelledOrFilled[batch[i * 2]] = cancelledOrFilled[batch[i * 2]]\n', '                .add(uint(batch[i * 2 + 1]));\n', '        }\n', '    }\n', '    function setCutoffs(uint t)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        cutoffs[tx.origin] = t;\n', '    }\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        tradingPairCutoffs[tx.origin][tokenPair] = t;\n', '    }\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view\n', '    {\n', '        uint len = owners.length;\n', '        require(len == tradingPairs.length);\n', '        require(len == validSince.length);\n', '        for(uint i = 0; i < len; i++) {\n', '            require(validSince[i] > tradingPairCutoffs[owners[i]][tradingPairs[i]]);  // order trading pair is cut off\n', '            require(validSince[i] > cutoffs[owners[i]]);                              // order is cut off\n', '        }\n', '    }\n', '    function suspend()\n', '        onlyOwner\n', '        notSuspended\n', '        external\n', '    {\n', '        suspended = true;\n', '    }\n', '    function resume()\n', '        onlyOwner\n', '        isSuspended\n', '        external\n', '    {\n', '        suspended = false;\n', '    }\n', '    /// owner must suspend delegate first before invoke kill method.\n', '    function kill()\n', '        onlyOwner\n', '        isSuspended\n', '        external\n', '    {\n', '        emit OwnershipTransferred(owner, 0x0);\n', '        owner = 0x0;\n', '    }\n', '}']
['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.21;\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint {\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg = add(avg, arr[i]);\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs = add(cvs, mul(s, s));\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(newOwner != 0x0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        onlyOwner\n', '        public\n', '    {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        onlyPendingOwner\n', '        public\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        view\n', '        public\n', '        returns (uint256);\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '        )\n', '        public\n', '        returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenTransferDelegate {\n', '    event AddressAuthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    event AddressDeauthorized(\n', '        address indexed addr,\n', '        uint32          number\n', '    );\n', '    // The following map is used to keep trace of order fill and cancellation\n', '    // history.\n', '    mapping (bytes32 => uint) public cancelledOrFilled;\n', "    // This map is used to keep trace of order's cancellation history.\n", '    mapping (bytes32 => uint) public cancelled;\n', '    // A map from address to its cutoff timestamp.\n', '    mapping (address => uint) public cutoffs;\n', '    // A map from address to its trading-pair cutoff timestamp.\n', '    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        external;\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses);\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        external;\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        external;\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool);\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        external;\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        public;\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        public;\n', '    function setCutoffs(uint t)\n', '        external;\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        external;\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view;\n', '    function suspend() external;\n', '    function resume() external;\n', '    function kill() external;\n', '}\n', '/// @title An Implementation of TokenTransferDelegate.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>.\n', 'contract TokenTransferDelegateImpl is TokenTransferDelegate, Claimable {\n', '    using MathUint for uint;\n', '    bool public suspended = false;\n', '    struct AddressInfo {\n', '        address previous;\n', '        uint32  index;\n', '        bool    authorized;\n', '    }\n', '    mapping(address => AddressInfo) public addressInfos;\n', '    address public latestAddress;\n', '    modifier onlyAuthorized()\n', '    {\n', '        require(addressInfos[msg.sender].authorized);\n', '        _;\n', '    }\n', '    modifier notSuspended()\n', '    {\n', '        require(!suspended);\n', '        _;\n', '    }\n', '    modifier isSuspended()\n', '    {\n', '        require(suspended);\n', '        _;\n', '    }\n', '    /// @dev Disable default function.\n', '    function ()\n', '        payable\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '    function authorizeAddress(\n', '        address addr\n', '        )\n', '        onlyOwner\n', '        external\n', '    {\n', '        AddressInfo storage addrInfo = addressInfos[addr];\n', '        if (addrInfo.index != 0) { // existing\n', '            if (addrInfo.authorized == false) { // re-authorize\n', '                addrInfo.authorized = true;\n', '                emit AddressAuthorized(addr, addrInfo.index);\n', '            }\n', '        } else {\n', '            address prev = latestAddress;\n', '            if (prev == 0x0) {\n', '                addrInfo.index = 1;\n', '                addrInfo.authorized = true;\n', '            } else {\n', '                addrInfo.previous = prev;\n', '                addrInfo.index = addressInfos[prev].index + 1;\n', '            }\n', '            addrInfo.authorized = true;\n', '            latestAddress = addr;\n', '            emit AddressAuthorized(addr, addrInfo.index);\n', '        }\n', '    }\n', '    function deauthorizeAddress(\n', '        address addr\n', '        )\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint32 index = addressInfos[addr].index;\n', '        if (index != 0) {\n', '            addressInfos[addr].authorized = false;\n', '            emit AddressDeauthorized(addr, index);\n', '        }\n', '    }\n', '    function getLatestAuthorizedAddresses(\n', '        uint max\n', '        )\n', '        external\n', '        view\n', '        returns (address[] addresses)\n', '    {\n', '        addresses = new address[](max);\n', '        address addr = latestAddress;\n', '        AddressInfo memory addrInfo;\n', '        uint count = 0;\n', '        while (addr != 0x0 && count < max) {\n', '            addrInfo = addressInfos[addr];\n', '            if (addrInfo.index == 0) {\n', '                break;\n', '            }\n', '            addresses[count++] = addr;\n', '            addr = addrInfo.previous;\n', '        }\n', '    }\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        if (value > 0 && from != to && to != 0x0) {\n', '            require(\n', '                ERC20(token).transferFrom(from, to, value)\n', '            );\n', '        }\n', '    }\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address minerFeeRecipient,\n', '        uint8 walletSplitPercentage,\n', '        bytes32[] batch\n', '        )\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        uint len = batch.length;\n', '        require(len % 7 == 0);\n', '        require(walletSplitPercentage > 0 && walletSplitPercentage < 100);\n', '        ERC20 lrc = ERC20(lrcTokenAddress);\n', '        address prevOwner = address(batch[len - 7]);\n', '        for (uint i = 0; i < len; i += 7) {\n', '            address owner = address(batch[i]);\n', "            // Pay token to previous order, or to miner as previous order's\n", "            // margin split or/and this order's margin split.\n", '            ERC20 token = ERC20(address(batch[i + 1]));\n', '            // Here batch[i + 2] has been checked not to be 0.\n', '            if (batch[i + 2] != 0x0 && owner != prevOwner) {\n', '                require(\n', '                    token.transferFrom(\n', '                        owner,\n', '                        prevOwner,\n', '                        uint(batch[i + 2])\n', '                    )\n', '                );\n', '            }\n', '            // Miner pays LRx fee to order owner\n', '            uint lrcReward = uint(batch[i + 4]);\n', '            if (lrcReward != 0 && minerFeeRecipient != owner) {\n', '                require(\n', '                    lrc.transferFrom(\n', '                        minerFeeRecipient,\n', '                        owner,\n', '                        lrcReward\n', '                    )\n', '                );\n', '            }\n', '            // Split margin-split income between miner and wallet\n', '            splitPayFee(\n', '                token,\n', '                uint(batch[i + 3]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            // Split LRx fee income between miner and wallet\n', '            splitPayFee(\n', '                lrc,\n', '                uint(batch[i + 5]),\n', '                owner,\n', '                minerFeeRecipient,\n', '                address(batch[i + 6]),\n', '                walletSplitPercentage\n', '            );\n', '            prevOwner = owner;\n', '        }\n', '    }\n', '    function isAddressAuthorized(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressInfos[addr].authorized;\n', '    }\n', '    function splitPayFee(\n', '        ERC20   token,\n', '        uint    fee,\n', '        address owner,\n', '        address minerFeeRecipient,\n', '        address walletFeeRecipient,\n', '        uint    walletSplitPercentage\n', '        )\n', '        internal\n', '    {\n', '        if (fee == 0) {\n', '            return;\n', '        }\n', '        uint walletFee = (walletFeeRecipient == 0x0) ? 0 : fee.mul(walletSplitPercentage) / 100;\n', '        uint minerFee = fee.sub(walletFee);\n', '        if (walletFee > 0 && walletFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    walletFeeRecipient,\n', '                    walletFee\n', '                )\n', '            );\n', '        }\n', '        if (minerFee > 0 && minerFeeRecipient != 0x0 && minerFeeRecipient != owner) {\n', '            require(\n', '                token.transferFrom(\n', '                    owner,\n', '                    minerFeeRecipient,\n', '                    minerFee\n', '                )\n', '            );\n', '        }\n', '    }\n', '    function addCancelled(bytes32 orderHash, uint cancelAmount)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        cancelled[orderHash] = cancelled[orderHash].add(cancelAmount);\n', '    }\n', '    function addCancelledOrFilled(bytes32 orderHash, uint cancelOrFillAmount)\n', '        onlyAuthorized\n', '        notSuspended\n', '        public\n', '    {\n', '        cancelledOrFilled[orderHash] = cancelledOrFilled[orderHash].add(cancelOrFillAmount);\n', '    }\n', '    function batchAddCancelledOrFilled(bytes32[] batch)\n', '        onlyAuthorized\n', '        notSuspended\n', '        public\n', '    {\n', '        require(batch.length % 2 == 0);\n', '        for (uint i = 0; i < batch.length / 2; i++) {\n', '            cancelledOrFilled[batch[i * 2]] = cancelledOrFilled[batch[i * 2]]\n', '                .add(uint(batch[i * 2 + 1]));\n', '        }\n', '    }\n', '    function setCutoffs(uint t)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        cutoffs[tx.origin] = t;\n', '    }\n', '    function setTradingPairCutoffs(bytes20 tokenPair, uint t)\n', '        onlyAuthorized\n', '        notSuspended\n', '        external\n', '    {\n', '        tradingPairCutoffs[tx.origin][tokenPair] = t;\n', '    }\n', '    function checkCutoffsBatch(address[] owners, bytes20[] tradingPairs, uint[] validSince)\n', '        external\n', '        view\n', '    {\n', '        uint len = owners.length;\n', '        require(len == tradingPairs.length);\n', '        require(len == validSince.length);\n', '        for(uint i = 0; i < len; i++) {\n', '            require(validSince[i] > tradingPairCutoffs[owners[i]][tradingPairs[i]]);  // order trading pair is cut off\n', '            require(validSince[i] > cutoffs[owners[i]]);                              // order is cut off\n', '        }\n', '    }\n', '    function suspend()\n', '        onlyOwner\n', '        notSuspended\n', '        external\n', '    {\n', '        suspended = true;\n', '    }\n', '    function resume()\n', '        onlyOwner\n', '        isSuspended\n', '        external\n', '    {\n', '        suspended = false;\n', '    }\n', '    /// owner must suspend delegate first before invoke kill method.\n', '    function kill()\n', '        onlyOwner\n', '        isSuspended\n', '        external\n', '    {\n', '        emit OwnershipTransferred(owner, 0x0);\n', '        owner = 0x0;\n', '    }\n', '}']
