['pragma solidity ^0.4.21;\n', '\n', 'contract DonationGuestbook {\n', '    struct Entry{\n', '        // structure for an guestbook entry\n', '        address owner;\n', '        string alias;\n', '        uint timestamp;\n', '        uint blocknumber;\n', '        uint donation;\n', '        string message;\n', '    }\n', '\n', '    address public owner; // Guestbook creator\n', '    address public donationWallet; // wallet to store donations\n', '    \n', '    uint public running_id = 0; // number of guestbook entries\n', '    mapping(uint=>Entry) public entries; // guestbook entries\n', '    uint public minimum_donation = 0; // to prevent spam in the guestbook\n', '\n', '    function DonationGuestbook() public { \n', '    // called at creation of contract\n', '        owner = msg.sender;\n', '        donationWallet = msg.sender;\n', '    }\n', '    \n', '    function() payable public {\n', '    // fallback function. In case somebody sends ether directly to the contract.\n', '        donationWallet.transfer(msg.value);\n', '    } \n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeDonationWallet(address _new_storage) public onlyOwner {\n', '    // in case the donation wallet address ever changes\n', '        donationWallet = _new_storage; \n', '    }\n', '\n', '    function changeOwner(address _new_owner) public onlyOwner {\n', '    // in case the owner ever changes\n', '        owner = _new_owner;\n', '    }\n', '\n', '    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n', '    // in case people spam into the guestbook\n', '        minimum_donation = _minDonation;\n', '    }\n', '\n', '    function destroy() onlyOwner public {\n', '    // kills the contract and sends all funds (which should be impossible to have) to the owner\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function createEntry(string _alias, string _message) payable public {\n', '    // called by a donator to make a donation + guestbook entry\n', '        require(msg.value > minimum_donation); // entries only for those that donate something\n', '        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n', '        running_id++;\n', '        donationWallet.transfer(msg.value);\n', '    }\n', '\n', '    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n', '    // for reading the entries of the guestbook\n', '        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n', '                entries[entry_id].donation, entries[entry_id].message);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract DonationGuestbook {\n', '    struct Entry{\n', '        // structure for an guestbook entry\n', '        address owner;\n', '        string alias;\n', '        uint timestamp;\n', '        uint blocknumber;\n', '        uint donation;\n', '        string message;\n', '    }\n', '\n', '    address public owner; // Guestbook creator\n', '    address public donationWallet; // wallet to store donations\n', '    \n', '    uint public running_id = 0; // number of guestbook entries\n', '    mapping(uint=>Entry) public entries; // guestbook entries\n', '    uint public minimum_donation = 0; // to prevent spam in the guestbook\n', '\n', '    function DonationGuestbook() public { \n', '    // called at creation of contract\n', '        owner = msg.sender;\n', '        donationWallet = msg.sender;\n', '    }\n', '    \n', '    function() payable public {\n', '    // fallback function. In case somebody sends ether directly to the contract.\n', '        donationWallet.transfer(msg.value);\n', '    } \n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeDonationWallet(address _new_storage) public onlyOwner {\n', '    // in case the donation wallet address ever changes\n', '        donationWallet = _new_storage; \n', '    }\n', '\n', '    function changeOwner(address _new_owner) public onlyOwner {\n', '    // in case the owner ever changes\n', '        owner = _new_owner;\n', '    }\n', '\n', '    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n', '    // in case people spam into the guestbook\n', '        minimum_donation = _minDonation;\n', '    }\n', '\n', '    function destroy() onlyOwner public {\n', '    // kills the contract and sends all funds (which should be impossible to have) to the owner\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function createEntry(string _alias, string _message) payable public {\n', '    // called by a donator to make a donation + guestbook entry\n', '        require(msg.value > minimum_donation); // entries only for those that donate something\n', '        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n', '        running_id++;\n', '        donationWallet.transfer(msg.value);\n', '    }\n', '\n', '    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n', '    // for reading the entries of the guestbook\n', '        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n', '                entries[entry_id].donation, entries[entry_id].message);\n', '    }\n', '}']
