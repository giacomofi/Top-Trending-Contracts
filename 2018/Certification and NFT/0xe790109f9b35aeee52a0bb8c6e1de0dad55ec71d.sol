['pragma solidity ^0.4.20;\n', '\n', '/*\n', '    ____\n', '   /\\&#39; .\\    _____\n', '  /: \\___\\  / .  /\\\n', '  \\&#39; / . / /____/..\\\n', '   \\/___/  \\&#39;  &#39;\\  /\n', '            \\&#39;__&#39;\\/\n', '\n', ' Developer:  TechnicalRise\n', ' \n', '*/\n', '\n', 'contract PHXReceivingContract {\n', '    /**\n', '     * @dev Standard ERC223 function that will handle incoming token transfers.\n', '     *\n', '     * @param _from  Token sender address.\n', '     * @param _value Amount of tokens.\n', '     * @param _data  Transaction metadata.\n', '     */\n', '    function tokenFallback(address _from, uint _value, bytes _data) public;\n', '}\n', '\n', 'contract PHXInterface {\n', '    function balanceOf(address who) public view returns (uint);\n', '    function transfer(address _to, uint _value) public returns (bool);\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool);\n', '}\n', '\n', 'contract PHXFlip is PHXReceivingContract {\n', '\n', '    address public constant PHXTKNADDR = 0x14b759A158879B133710f4059d32565b4a66140C;\n', '    PHXInterface public PHXTKN;\n', '\n', '\tfunction PHXFlip() public {\n', '\t    PHXTKN = PHXInterface(PHXTKNADDR); // Initialize the PHX Contract\n', '\t}\n', '\t\n', '\tfunction tokenFallback(address _from, uint _value, bytes _data) public {\n', '\t  // Note that msg.sender is the Token Contract Address\n', '\t  // and "_from" is the sender of the tokens\n', '\t  require(_humanSender(_from)); // Check that this is a non-contract sender\n', '\t  require(_phxToken(msg.sender));\n', '\t  \n', '\t  uint _possibleWinnings = 2 * _value;\n', '\t  // This doesn&#39;t require the PHX Balance to be greater than double the bet\n', '\t  // So check the contract&#39;s PHX Balance before wagering!\n', '\t  if(_prand(2) == 1) { // i.e. if it&#39;s "heads"\n', '\t      if(PHXTKN.balanceOf(this) >= _possibleWinnings) {\n', '\t          PHXTKN.transfer(_from, _possibleWinnings);\n', '\t      } else {\n', '\t          PHXTKN.transfer(_from,PHXTKN.balanceOf(this));\n', '\t      }\n', '\t  } else {\n', '\t      // And if you don&#39;t win, you just don&#39;t win, and it keeps your money\n', '\t  }\n', '    }\n', '    \n', '    // This is a supercheap psuedo-random number generator\n', '    // that relies on the fact that "who" will mine and "when" they will\n', '    // mine is random.  This is obviously vulnerable to "inside the block"\n', '    // attacks where someone writes a contract mined in the same block\n', '    // and calls this contract from it -- but we don&#39;t accept transactions\n', '    // from foreign contracts, lessening that risk\n', '    function _prand(uint _modulo) private view returns (uint) {\n', '        require((1 < _modulo) && (_modulo <= 10000)); // Keep it greater than 0, less than 10K.\n', '        uint seed1 = uint(block.coinbase); // Get Miner&#39;s Address\n', '        uint seed2 = now; // Get the timestamp\n', '        return uint(keccak256(seed1, seed2)) % _modulo;\n', '    }\n', '    \n', '    function _phxToken(address _tokenContract) private pure returns (bool) {\n', '        return _tokenContract == PHXTKNADDR; // Returns "true" of this is the PHX Token Contract\n', '    }\n', '    \n', '    // Determine if the "_from" address is a contract\n', '    function _humanSender(address _from) private view returns (bool) {\n', '      uint codeLength;\n', '      assembly {\n', '          codeLength := extcodesize(_from)\n', '      }\n', '      return (codeLength == 0); // If this is "true" sender is most likely  a Wallet\n', '    }\n', '}']