['pragma solidity ^0.4.18;\n', '\n', 'contract Token {\n', '\n', '    // ERC20 standard\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n', '    function totalSupply() constant public returns (uint256 supply);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a && c >= b);\n', '    return c;\n', '  }\n', '\n', '  modifier onlyPayloadSize(uint numWords) {\n', '     assert(msg.data.length >= numWords * 32 + 4);\n', '     _;\n', '  }\n', '\n', '}\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '    \n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value && _value > 0);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) public returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _oldValue);\n', '        allowed[msg.sender][_spender] = _newValue;\n', '        Approval(msg.sender, _spender, _newValue);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '    \n', '    \n', '    function totalSupply() constant public returns (uint256 supply) {\n', '        supply = totalSupply;\n', '    }\n', '    \n', '}\n', '\n', '\n', '\n', 'contract TabarniaCoin is StandardToken {\n', '\n', '    string public name = "Tabarnia Coin";\n', '    string public motto = "Acta est fabula";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "TAB";\n', "    string public version = '1.0';\n", '    string public author = "Lord Cid";\n', '    string public mission = "Somos Anonimos. Somos Legion. No perdonamos. No olvidamos.";\n', '    uint256 public tabsOneEthCanBuyICO = 1000;\n', '    bool public halted = false;\n', '    bool public tradeable = true;\n', '    address public fundsWallet;\n', '\n', '    struct Proposal {\n', '        uint voteCount;\n', '    }\n', '    \n', '    struct Voter {\n', '        uint8 vote;\n', '        bool voted;\n', '    }\n', '    \n', '    mapping(address => Voter) voters;\n', '    \n', '    Proposal[] proposals;\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    modifier onlyFundsWallet {\n', '        require(msg.sender == fundsWallet);\n', '        _;\n', '    }\n', '\n', '    modifier isTradeable {\n', '        require(tradeable || msg.sender == fundsWallet);\n', '        _;\n', '    }\n', '\n', '    function TabarniaCoin() public {\n', '        totalSupply = 1000000 * 1000000000000000000;\n', '        balances[msg.sender] = totalSupply;\n', '        fundsWallet = msg.sender;\n', '    }\n', '\n', '    function() payable public {\n', '        require(!halted);\n', '        uint256 amount = safeMul(msg.value,tabsOneEthCanBuyICO);\n', '\n', '        if (balances[fundsWallet] < amount) {\n', '            return;\n', '        }\n', '\n', '        balances[fundsWallet] = safeSub(balances[fundsWallet], amount);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], amount);\n', '\n', '        Transfer(fundsWallet, msg.sender, amount);\n', '\n', '        fundsWallet.transfer(msg.value);                               \n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        if (!_spender.call(bytes4(bytes32(keccak256("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }\n', '        return true;\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf(msg.sender) >= _value);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        totalSupply = safeSub(totalSupply, _value); \n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function halt() external onlyFundsWallet {\n', '        halted = true;\n', '    }\n', '\n', '    function unhalt() external onlyFundsWallet {\n', '        halted = false;\n', '    }\n', '\n', '\n', '    function enableTrading() external onlyFundsWallet {\n', '        tradeable = true;\n', '    }\n', '\n', '    function disableTrading() external onlyFundsWallet {\n', '        tradeable = false;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) isTradeable public returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) isTradeable public returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    function claimVotingRight() public {\n', '        require(tradeable);\n', '        voters[msg.sender].voted = false;\n', '        voters[msg.sender].vote = 0;\n', '    }\n', '\n', '    function newVoting(uint8 _numProposals) public onlyFundsWallet {\n', '        require(!tradeable);\n', '        proposals.length = _numProposals;\n', '        for (uint8 prop = 0; prop < proposals.length; prop++) {\n', '            proposals[prop].voteCount = 0;\n', '        }\n', '\n', '    }\n', '\n', '    function vote(uint8 toProposal) public {\n', '        require(!tradeable);\n', '        require(toProposal < proposals.length);\n', '        require(balances[msg.sender] > 0);\n', '        require(!voters[msg.sender].voted);\n', '        voters[msg.sender].voted = true;\n', '        voters[msg.sender].vote = toProposal;\n', '        proposals[toProposal].voteCount = safeAdd(proposals[toProposal].voteCount,balances[msg.sender]);\n', '    }\n', '\n', '    function winningProposal() public constant returns (uint8 _winningProposal) {\n', '        uint256 winningVoteCount = 0;\n', '        for (uint8 prop = 0; prop < proposals.length; prop++)\n', '            if (proposals[prop].voteCount > winningVoteCount) {\n', '                winningVoteCount = proposals[prop].voteCount;\n', '                _winningProposal = prop;\n', '            }\n', '    }\n', '\n', '    function changeFundsWallet(address newFundsWallet) external onlyFundsWallet {\n', '        require(newFundsWallet != address(0));\n', '        fundsWallet = newFundsWallet;\n', '    }\n', '    \n', '\n', '}']