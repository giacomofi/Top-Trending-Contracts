['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * New Art\n', ' *\n', ' * An ERC721 compatible public registry with support for operators.\n', ' * Vist https://www.newart.org for more information.\n', ' *\n', ' * Copyright NEW ART Co., Ltd.\n', ' */\n', '\n', '\n', '/**\n', ' * Interface for required functionality in the ERC721 standard\n', ' * for non-fungible tokens.\n', ' *\n', ' * Author: Nadav Hollander (nadav at dharma.io)\n', ' */\n', 'contract ERC721 {\n', '    // Function\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) public;\n', '    function getApproved(uint _tokenId) public view returns (address _approved);\n', '    function transferFrom(address _from, address _to, uint _tokenId) public;\n', '    function transfer(address _to, uint _tokenId) public;\n', '    function implementsERC721() public view returns (bool _implementsERC721);\n', '\n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '    // Optional Operator Extension\n', '    event AuthorizedOperator(address indexed _owner, address indexed _operator);\n', '    event RevokedOperator(address indexed _owner, address indexed _operator);\n', '    function authorizeOperator(address _operator) public;\n', '    function revokeOperator(address _operator) public;\n', '    function isOperatorFor(address _operator, address _owner) public constant returns (bool);\n', '}\n', '\n', '/**\n', ' * Interface for optional functionality in the ERC721 standard\n', ' * for non-fungible tokens.\n', ' *\n', ' * Author: Nadav Hollander (nadav at dharma.io)\n', ' */\n', 'contract DetailedERC721 is ERC721 {\n', '    function name() public view returns (string _name);\n', '    function symbol() public view returns (string _symbol);\n', '    function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) public view returns (uint _tokenId);\n', '}\n', '\n', '/**\n', ' * @title NonFungibleToken\n', ' *\n', ' * Generic implementation for both required and optional functionality in\n', ' * the ERC721 standard for non-fungible tokens.\n', ' *\n', ' * Heavily inspired by Decentraland&#39;s generic implementation:\n', ' * https://github.com/decentraland/land/blob/master/contracts/BasicNFT.sol\n', ' *\n', ' * Standard Author: dete\n', ' * Implementation Author: Nadav Hollander <nadav at dharma.io>\n', ' */\n', 'contract NonFungibleToken is DetailedERC721 {\n', '    string public name;\n', '    string public symbol;\n', '\n', '    uint public numTokensTotal;\n', '\n', '    mapping(uint => address) internal tokenIdToOwner;\n', '    mapping(uint => address) internal tokenIdToApprovedAddress;\n', '    mapping(uint => string) internal tokenIdToMetadata;\n', '    mapping(address => uint[]) internal ownerToTokensOwned;\n', '    mapping(uint => uint) internal tokenIdToOwnerArrayIndex;\n', '    mapping(address => mapping(address => bool)) internal ownerToOperators;\n', '\n', '    modifier onlyExtantToken(uint _tokenId) {\n', '        require(ownerOf(_tokenId) != address(0));\n', '        _;\n', '    }\n', '\n', '    function name()\n', '        public\n', '        view\n', '        returns (string _name)\n', '    {\n', '        return name;\n', '    }\n', '\n', '    function symbol()\n', '        public\n', '        view\n', '        returns (string _symbol)\n', '    {\n', '        return symbol;\n', '    }\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256 _totalSupply)\n', '    {\n', '        return numTokensTotal;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return ownerToTokensOwned[_owner].length;\n', '    }\n', '\n', '    function ownerOf(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _owner)\n', '    {\n', '        return _ownerOf(_tokenId);\n', '    }\n', '\n', '    function tokenMetadata(uint _tokenId)\n', '        public\n', '        view\n', '        returns (string _infoUrl)\n', '    {\n', '        return tokenIdToMetadata[_tokenId];\n', '    }\n', '\n', '    function approve(address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(msg.sender == ownerOf(_tokenId) || isOperatorFor(msg.sender, ownerOf(_tokenId)));\n', '        require(msg.sender != _to);\n', '\n', '        if (_getApproved(_tokenId) != address(0) ||\n', '                _to != address(0)) {\n', '            _approve(_to, _tokenId);\n', '            Approval(msg.sender, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    function authorizeOperator(address _operator) public {\n', '      ownerToOperators[msg.sender][_operator] = true;\n', '      AuthorizedOperator(msg.sender, _operator);\n', '    }\n', '\n', '    function revokeOperator(address _operator) public {\n', '      ownerToOperators[msg.sender][_operator] = false;\n', '      RevokedOperator(msg.sender, _operator);\n', '    }\n', '\n', '    function isOperatorFor(address _operator, address _owner) public constant returns (bool) {\n', '      return ownerToOperators[_owner][_operator];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(getApproved(_tokenId) == msg.sender);\n', '        require(ownerOf(_tokenId) == _from);\n', '        require(_to != address(0));\n', '\n', '        _clearApprovalAndTransfer(_from, _to, _tokenId);\n', '\n', '        Approval(_from, 0, _tokenId);\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(ownerOf(_tokenId) == msg.sender || isOperatorFor(msg.sender, ownerOf(_tokenId)));\n', '        require(_to != address(0));\n', '\n', '        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '\n', '        Approval(msg.sender, 0, _tokenId);\n', '        Transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint _index)\n', '        public\n', '        view\n', '        returns (uint _tokenId)\n', '    {\n', '        return _getOwnerTokenByIndex(_owner, _index);\n', '    }\n', '\n', '    function getOwnerTokens(address _owner)\n', '        public\n', '        view\n', '        returns (uint[] _tokenIds)\n', '    {\n', '        return _getOwnerTokens(_owner);\n', '    }\n', '\n', '    function implementsERC721()\n', '        public\n', '        view\n', '        returns (bool _implementsERC721)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function getApproved(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return _getApproved(_tokenId);\n', '    }\n', '\n', '    function approvedFor(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return _getApproved(_tokenId);\n', '    }\n', '\n', '    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)\n', '        internal\n', '    {\n', '        _clearTokenApproval(_tokenId);\n', '        _removeTokenFromOwnersList(_from, _tokenId);\n', '        _setTokenOwner(_tokenId, _to);\n', '        _addTokenToOwnersList(_to, _tokenId);\n', '    }\n', '\n', '    function _ownerOf(uint _tokenId)\n', '        internal\n', '        view\n', '        returns (address _owner)\n', '    {\n', '        return tokenIdToOwner[_tokenId];\n', '    }\n', '\n', '    function _approve(address _to, uint _tokenId)\n', '        internal\n', '    {\n', '        tokenIdToApprovedAddress[_tokenId] = _to;\n', '    }\n', '\n', '    function _getApproved(uint _tokenId)\n', '        internal\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return tokenIdToApprovedAddress[_tokenId];\n', '    }\n', '\n', '    function _getOwnerTokens(address _owner)\n', '        internal\n', '        view\n', '        returns (uint[] _tokens)\n', '    {\n', '        return ownerToTokensOwned[_owner];\n', '    }\n', '\n', '    function _getOwnerTokenByIndex(address _owner, uint _index)\n', '        internal\n', '        view\n', '        returns (uint _tokens)\n', '    {\n', '        return ownerToTokensOwned[_owner][_index];\n', '    }\n', '\n', '    function _clearTokenApproval(uint _tokenId)\n', '        internal\n', '    {\n', '        tokenIdToApprovedAddress[_tokenId] = address(0);\n', '    }\n', '\n', '    function _setTokenOwner(uint _tokenId, address _owner)\n', '        internal\n', '    {\n', '        tokenIdToOwner[_tokenId] = _owner;\n', '    }\n', '\n', '    function _addTokenToOwnersList(address _owner, uint _tokenId)\n', '        internal\n', '    {\n', '        ownerToTokensOwned[_owner].push(_tokenId);\n', '        tokenIdToOwnerArrayIndex[_tokenId] = ownerToTokensOwned[_owner].length - 1;\n', '    }\n', '\n', '    function _removeTokenFromOwnersList(address _owner, uint _tokenId)\n', '        internal\n', '    {\n', '        uint length = ownerToTokensOwned[_owner].length;\n', '        uint index = tokenIdToOwnerArrayIndex[_tokenId];\n', '        uint swapToken = ownerToTokensOwned[_owner][length - 1];\n', '\n', '        ownerToTokensOwned[_owner][index] = swapToken;\n', '        tokenIdToOwnerArrayIndex[swapToken] = index;\n', '\n', '        delete ownerToTokensOwned[_owner][length - 1];\n', '        ownerToTokensOwned[_owner].length--;\n', '    }\n', '\n', '    function _insertTokenMetadata(uint _tokenId, string _metadata)\n', '        internal\n', '    {\n', '        tokenIdToMetadata[_tokenId] = _metadata;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MintableNonFungibleToken\n', ' *\n', ' * Superset of the ERC721 standard that allows for the minting\n', ' * of non-fungible tokens.\n', ' */\n', 'contract MintableNonFungibleToken is NonFungibleToken {\n', '    using SafeMath for uint;\n', '\n', '    event Mint(address indexed _to, uint256 indexed _tokenId);\n', '\n', '    modifier onlyNonexistentToken(uint _tokenId) {\n', '        require(tokenIdToOwner[_tokenId] == address(0));\n', '        _;\n', '    }\n', '\n', '    function mint(address _owner, uint256 _tokenId, address _approvedAddress, string _metadata)\n', '        public\n', '        onlyNonexistentToken(_tokenId)\n', '    {\n', '        _setTokenOwner(_tokenId, _owner);\n', '        _addTokenToOwnersList(_owner, _tokenId);\n', '        _approve(_approvedAddress, _tokenId);\n', '        _insertTokenMetadata(_tokenId, _metadata);\n', '\n', '        numTokensTotal = numTokensTotal.add(1);\n', '\n', '        Mint(_owner, _tokenId);\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '/**\n', ' * New Art\n', ' *\n', ' * An ERC721 compatible public registry with support for operators.\n', ' * Vist https://www.newart.org for more information.\n', ' *\n', ' * Copyright NEW ART Co., Ltd.\n', ' */\n', '\n', '\n', '/**\n', ' * Interface for required functionality in the ERC721 standard\n', ' * for non-fungible tokens.\n', ' *\n', ' * Author: Nadav Hollander (nadav at dharma.io)\n', ' */\n', 'contract ERC721 {\n', '    // Function\n', '    function totalSupply() public view returns (uint256 _totalSupply);\n', '    function balanceOf(address _owner) public view returns (uint256 _balance);\n', '    function ownerOf(uint _tokenId) public view returns (address _owner);\n', '    function approve(address _to, uint _tokenId) public;\n', '    function getApproved(uint _tokenId) public view returns (address _approved);\n', '    function transferFrom(address _from, address _to, uint _tokenId) public;\n', '    function transfer(address _to, uint _tokenId) public;\n', '    function implementsERC721() public view returns (bool _implementsERC721);\n', '\n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '    // Optional Operator Extension\n', '    event AuthorizedOperator(address indexed _owner, address indexed _operator);\n', '    event RevokedOperator(address indexed _owner, address indexed _operator);\n', '    function authorizeOperator(address _operator) public;\n', '    function revokeOperator(address _operator) public;\n', '    function isOperatorFor(address _operator, address _owner) public constant returns (bool);\n', '}\n', '\n', '/**\n', ' * Interface for optional functionality in the ERC721 standard\n', ' * for non-fungible tokens.\n', ' *\n', ' * Author: Nadav Hollander (nadav at dharma.io)\n', ' */\n', 'contract DetailedERC721 is ERC721 {\n', '    function name() public view returns (string _name);\n', '    function symbol() public view returns (string _symbol);\n', '    function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);\n', '    function tokenOfOwnerByIndex(address _owner, uint _index) public view returns (uint _tokenId);\n', '}\n', '\n', '/**\n', ' * @title NonFungibleToken\n', ' *\n', ' * Generic implementation for both required and optional functionality in\n', ' * the ERC721 standard for non-fungible tokens.\n', ' *\n', " * Heavily inspired by Decentraland's generic implementation:\n", ' * https://github.com/decentraland/land/blob/master/contracts/BasicNFT.sol\n', ' *\n', ' * Standard Author: dete\n', ' * Implementation Author: Nadav Hollander <nadav at dharma.io>\n', ' */\n', 'contract NonFungibleToken is DetailedERC721 {\n', '    string public name;\n', '    string public symbol;\n', '\n', '    uint public numTokensTotal;\n', '\n', '    mapping(uint => address) internal tokenIdToOwner;\n', '    mapping(uint => address) internal tokenIdToApprovedAddress;\n', '    mapping(uint => string) internal tokenIdToMetadata;\n', '    mapping(address => uint[]) internal ownerToTokensOwned;\n', '    mapping(uint => uint) internal tokenIdToOwnerArrayIndex;\n', '    mapping(address => mapping(address => bool)) internal ownerToOperators;\n', '\n', '    modifier onlyExtantToken(uint _tokenId) {\n', '        require(ownerOf(_tokenId) != address(0));\n', '        _;\n', '    }\n', '\n', '    function name()\n', '        public\n', '        view\n', '        returns (string _name)\n', '    {\n', '        return name;\n', '    }\n', '\n', '    function symbol()\n', '        public\n', '        view\n', '        returns (string _symbol)\n', '    {\n', '        return symbol;\n', '    }\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256 _totalSupply)\n', '    {\n', '        return numTokensTotal;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '        public\n', '        view\n', '        returns (uint _balance)\n', '    {\n', '        return ownerToTokensOwned[_owner].length;\n', '    }\n', '\n', '    function ownerOf(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _owner)\n', '    {\n', '        return _ownerOf(_tokenId);\n', '    }\n', '\n', '    function tokenMetadata(uint _tokenId)\n', '        public\n', '        view\n', '        returns (string _infoUrl)\n', '    {\n', '        return tokenIdToMetadata[_tokenId];\n', '    }\n', '\n', '    function approve(address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(msg.sender == ownerOf(_tokenId) || isOperatorFor(msg.sender, ownerOf(_tokenId)));\n', '        require(msg.sender != _to);\n', '\n', '        if (_getApproved(_tokenId) != address(0) ||\n', '                _to != address(0)) {\n', '            _approve(_to, _tokenId);\n', '            Approval(msg.sender, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    function authorizeOperator(address _operator) public {\n', '      ownerToOperators[msg.sender][_operator] = true;\n', '      AuthorizedOperator(msg.sender, _operator);\n', '    }\n', '\n', '    function revokeOperator(address _operator) public {\n', '      ownerToOperators[msg.sender][_operator] = false;\n', '      RevokedOperator(msg.sender, _operator);\n', '    }\n', '\n', '    function isOperatorFor(address _operator, address _owner) public constant returns (bool) {\n', '      return ownerToOperators[_owner][_operator];\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(getApproved(_tokenId) == msg.sender);\n', '        require(ownerOf(_tokenId) == _from);\n', '        require(_to != address(0));\n', '\n', '        _clearApprovalAndTransfer(_from, _to, _tokenId);\n', '\n', '        Approval(_from, 0, _tokenId);\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint _tokenId)\n', '        public\n', '        onlyExtantToken(_tokenId)\n', '    {\n', '        require(ownerOf(_tokenId) == msg.sender || isOperatorFor(msg.sender, ownerOf(_tokenId)));\n', '        require(_to != address(0));\n', '\n', '        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);\n', '\n', '        Approval(msg.sender, 0, _tokenId);\n', '        Transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint _index)\n', '        public\n', '        view\n', '        returns (uint _tokenId)\n', '    {\n', '        return _getOwnerTokenByIndex(_owner, _index);\n', '    }\n', '\n', '    function getOwnerTokens(address _owner)\n', '        public\n', '        view\n', '        returns (uint[] _tokenIds)\n', '    {\n', '        return _getOwnerTokens(_owner);\n', '    }\n', '\n', '    function implementsERC721()\n', '        public\n', '        view\n', '        returns (bool _implementsERC721)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function getApproved(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return _getApproved(_tokenId);\n', '    }\n', '\n', '    function approvedFor(uint _tokenId)\n', '        public\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return _getApproved(_tokenId);\n', '    }\n', '\n', '    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)\n', '        internal\n', '    {\n', '        _clearTokenApproval(_tokenId);\n', '        _removeTokenFromOwnersList(_from, _tokenId);\n', '        _setTokenOwner(_tokenId, _to);\n', '        _addTokenToOwnersList(_to, _tokenId);\n', '    }\n', '\n', '    function _ownerOf(uint _tokenId)\n', '        internal\n', '        view\n', '        returns (address _owner)\n', '    {\n', '        return tokenIdToOwner[_tokenId];\n', '    }\n', '\n', '    function _approve(address _to, uint _tokenId)\n', '        internal\n', '    {\n', '        tokenIdToApprovedAddress[_tokenId] = _to;\n', '    }\n', '\n', '    function _getApproved(uint _tokenId)\n', '        internal\n', '        view\n', '        returns (address _approved)\n', '    {\n', '        return tokenIdToApprovedAddress[_tokenId];\n', '    }\n', '\n', '    function _getOwnerTokens(address _owner)\n', '        internal\n', '        view\n', '        returns (uint[] _tokens)\n', '    {\n', '        return ownerToTokensOwned[_owner];\n', '    }\n', '\n', '    function _getOwnerTokenByIndex(address _owner, uint _index)\n', '        internal\n', '        view\n', '        returns (uint _tokens)\n', '    {\n', '        return ownerToTokensOwned[_owner][_index];\n', '    }\n', '\n', '    function _clearTokenApproval(uint _tokenId)\n', '        internal\n', '    {\n', '        tokenIdToApprovedAddress[_tokenId] = address(0);\n', '    }\n', '\n', '    function _setTokenOwner(uint _tokenId, address _owner)\n', '        internal\n', '    {\n', '        tokenIdToOwner[_tokenId] = _owner;\n', '    }\n', '\n', '    function _addTokenToOwnersList(address _owner, uint _tokenId)\n', '        internal\n', '    {\n', '        ownerToTokensOwned[_owner].push(_tokenId);\n', '        tokenIdToOwnerArrayIndex[_tokenId] = ownerToTokensOwned[_owner].length - 1;\n', '    }\n', '\n', '    function _removeTokenFromOwnersList(address _owner, uint _tokenId)\n', '        internal\n', '    {\n', '        uint length = ownerToTokensOwned[_owner].length;\n', '        uint index = tokenIdToOwnerArrayIndex[_tokenId];\n', '        uint swapToken = ownerToTokensOwned[_owner][length - 1];\n', '\n', '        ownerToTokensOwned[_owner][index] = swapToken;\n', '        tokenIdToOwnerArrayIndex[swapToken] = index;\n', '\n', '        delete ownerToTokensOwned[_owner][length - 1];\n', '        ownerToTokensOwned[_owner].length--;\n', '    }\n', '\n', '    function _insertTokenMetadata(uint _tokenId, string _metadata)\n', '        internal\n', '    {\n', '        tokenIdToMetadata[_tokenId] = _metadata;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MintableNonFungibleToken\n', ' *\n', ' * Superset of the ERC721 standard that allows for the minting\n', ' * of non-fungible tokens.\n', ' */\n', 'contract MintableNonFungibleToken is NonFungibleToken {\n', '    using SafeMath for uint;\n', '\n', '    event Mint(address indexed _to, uint256 indexed _tokenId);\n', '\n', '    modifier onlyNonexistentToken(uint _tokenId) {\n', '        require(tokenIdToOwner[_tokenId] == address(0));\n', '        _;\n', '    }\n', '\n', '    function mint(address _owner, uint256 _tokenId, address _approvedAddress, string _metadata)\n', '        public\n', '        onlyNonexistentToken(_tokenId)\n', '    {\n', '        _setTokenOwner(_tokenId, _owner);\n', '        _addTokenToOwnersList(_owner, _tokenId);\n', '        _approve(_approvedAddress, _tokenId);\n', '        _insertTokenMetadata(_tokenId, _metadata);\n', '\n', '        numTokensTotal = numTokensTotal.add(1);\n', '\n', '        Mint(_owner, _tokenId);\n', '    }\n', '}']
