['pragma solidity ^0.4.16;\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Currency contract\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address from, address to, uint tokens);\n', '    event Approval(address tokenOwner, address spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// CNT Currency contract extended API\n', '// ----------------------------------------------------------------------------\n', 'contract PRE_SALE_Token is ERC20Interface {\n', '    function ico_distribution(address to, uint tokens) public;\n', '    function ico_promo_reward(address to, uint tokens) public;\n', '    function init(address _sale) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Contract User Contract API\n', '// ----------------------------------------------------------------------------\n', 'contract NRB_Contract {\n', '    function registerUserOnToken(address _token, address _user, uint _value, uint _flc, string _json) public returns (uint);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// contract WhiteListAccess\n', '// ----------------------------------------------------------------------------\n', 'contract WhiteListAccess { \n', '    \n', '    function WhiteListAccess() public {\n', '        owner = msg.sender;\n', '        whitelist[owner] = true;\n', '        whitelist[address(this)] = true;\n', '    }\n', '    \n', '    address public owner;\n', '    mapping (address => bool) whitelist;\n', '\n', '    modifier onlyOwner {require(msg.sender == owner); _;}\n', '    modifier onlyWhitelisted {require(whitelist[msg.sender]); _;}\n', '\n', '    function addToWhiteList(address trusted) public onlyOwner() {\n', '        whitelist[trusted] = true;\n', '    }\n', '\n', '    function removeFromWhiteList(address untrusted) public onlyOwner() {\n', '        whitelist[untrusted] = false;\n', '    }\n', '\n', '}\n', '// ----------------------------------------------------------------------------\n', '// CNT_Common contract\n', '// ----------------------------------------------------------------------------\n', 'contract CNT_Common is WhiteListAccess {\n', '    string  public name;\n', '    function CNT_Common() public { ETH_address = 0x1; }\n', '\n', '    // Deployment\n', '    bool public initialized;\n', '    address public ETH_address;    // representation of Ether as Token (0x1)\n', '    address public EOS_address;    // EOS Tokens\n', '    address public NRB_address;    // New Rich on The Block Contract\n', '    \n', '    address public CNT_address;    // Chip\n', '    address public BGB_address;    // BG Coin\n', '    address public VPE_address;    // Vapaee Token\n', '    address public GVPE_address;   // Golden Vapaee Token\n', '    \n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// CNT_Crowdsale\n', '// ----------------------------------------------------------------------------\n', 'contract CNT_Crowdsale is CNT_Common {\n', '\n', '    uint public raised;\n', '    uint public remaining;\n', '    uint public cnt_per_Keos;\n', '    uint public bgb_per_Keos;\n', '    uint public vpe_per_Keos;\n', '    uint public gvpe_per_Keos;\n', '    mapping(address => uint) public paid;\n', '    \n', '    // a global list of users (uniques ids across)\n', '    mapping(uint => Reward) public rewards;\n', '\n', '    // length of prev list\n', '    uint public rewardslength;\n', '\n', '    struct Reward {\n', '        uint cnt;\n', '        uint bgb;\n', '        uint timestamp;\n', '        address target;\n', '        string concept;\n', '    }\n', '\n', '    event Sale(address from, uint eos_tokens, address to, uint cnt_tokens, uint mana_tokens, uint vpe_tokens, uint gvpe_tokens);\n', '    // --------------------------------------------------------------------------------\n', '\n', '    function CNT_Crowdsale() public {\n', '        rewardslength = 0;\n', '        cnt_per_Keos  = 300000;\n', '        bgb_per_Keos  = 300000;\n', '        vpe_per_Keos  =    500;\n', '        gvpe_per_Keos =    100;\n', '        name = "CNT_Crowdsale";\n', '        remaining = 1000000 * 10**18; // 1 million\n', '    }\n', '\n', '    function init(address _eos, address _cnt, address _bgb, address _vpe, address _gvpe, address _nrb) public {\n', '        require(!initialized);\n', '        EOS_address = _eos;\n', '        CNT_address = _cnt;\n', '        BGB_address = _bgb;\n', '        VPE_address = _vpe;\n', '        GVPE_address = _gvpe;\n', '        NRB_address = _nrb;\n', '        PRE_SALE_Token(CNT_address).init(address(this));\n', '        PRE_SALE_Token(BGB_address).init(address(this));\n', '        PRE_SALE_Token(VPE_address).init(address(this));\n', '        PRE_SALE_Token(GVPE_address).init(address(this));\n', '        initialized = true;\n', '    }\n', '\n', '    function isInit() constant public returns (bool) {\n', '        return initialized;\n', '    }\n', '\n', '    function calculateTokens(uint _Keos_amount) constant public returns (uint, uint, uint, uint) {\n', '        uint cnt  = _Keos_amount * cnt_per_Keos;\n', '        uint bgb  = _Keos_amount * bgb_per_Keos;\n', '        uint vpe  = _Keos_amount * vpe_per_Keos;\n', '        uint gvpe = _Keos_amount * gvpe_per_Keos;        \n', '        if (vpe % 1000000000000000000 > 0) {\n', '            vpe = vpe - vpe % 1000000000000000000;\n', '        }\n', '        if (gvpe % 1000000000000000000 > 0) {\n', '            gvpe = gvpe - gvpe % 1000000000000000000;\n', '        }\n', '        return (\n', '            cnt,\n', '            bgb,\n', '            vpe,\n', '            gvpe\n', '        );\n', '    }\n', '\n', '    function buy(uint _Keos_amount) public {\n', '        // calculate how much of each token must be sent\n', '        uint _eos_amount = _Keos_amount * 1000;\n', '        require(remaining >= _eos_amount);\n', '\n', '        uint cnt_amount  = 0;\n', '        uint bgb_amount = 0;\n', '        uint vpe_amount  = 0;\n', '        uint gvpe_amount = 0;\n', '\n', '        (cnt_amount, bgb_amount, vpe_amount, gvpe_amount) = calculateTokens(_Keos_amount);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_distribution(msg.sender, cnt_amount);\n', '        PRE_SALE_Token(BGB_address) .ico_distribution(msg.sender, bgb_amount);\n', '        PRE_SALE_Token(VPE_address) .ico_distribution(msg.sender, vpe_amount);\n', '        PRE_SALE_Token(GVPE_address).ico_distribution(msg.sender, gvpe_amount);\n', '\n', '        // registro la compra\n', '        Sale(address(this), _eos_amount, msg.sender, cnt_amount, bgb_amount, vpe_amount, gvpe_amount);\n', '        paid[msg.sender] = paid[msg.sender] + _eos_amount;\n', '\n', '        // env&#237;o los eos al owner\n', '        ERC20Interface(EOS_address).transferFrom(msg.sender, owner, _eos_amount);\n', '\n', '        raised = raised + _eos_amount;\n', '        remaining = remaining - _eos_amount;\n', '    }\n', '\n', '    function registerUserOnToken(string _json) public {\n', '        NRB_Contract(CNT_address).registerUserOnToken(EOS_address, msg.sender, paid[msg.sender], 0, _json);\n', '    }\n', '\n', '    function finishPresale() public onlyOwner() {\n', '        uint cnt_amount  = 0;\n', '        uint bgb_amount = 0;\n', '        uint vpe_amount  = 0;\n', '        uint gvpe_amount = 0;\n', '\n', '        (cnt_amount, bgb_amount, vpe_amount, gvpe_amount) = calculateTokens(remaining);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_distribution(owner, cnt_amount);\n', '        PRE_SALE_Token(BGB_address) .ico_distribution(owner, bgb_amount);\n', '        PRE_SALE_Token(VPE_address) .ico_distribution(owner, vpe_amount);\n', '        PRE_SALE_Token(GVPE_address).ico_distribution(owner, gvpe_amount);\n', '\n', '        // registro la compra\n', '        Sale(address(this), remaining, owner, cnt_amount, bgb_amount, vpe_amount, gvpe_amount);\n', '        paid[owner] = paid[owner] + remaining;\n', '\n', '        raised = raised + remaining;\n', '        remaining = 0;        \n', '    }\n', '\n', '    function reward(address _target, uint _cnt, uint _bgb,  string _concept) public onlyOwner() {\n', '        // register the reward\n', '        rewardslength++;\n', '        rewards[rewardslength] = Reward(_cnt, _bgb, block.timestamp, _target, _concept);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_promo_reward(_target, _cnt);\n', '        PRE_SALE_Token(BGB_address) .ico_promo_reward(_target, _bgb);        \n', '    }\n', '    // ------------------------------------------------------------------------\n', '    // Don&#39;t accept ETH\n', '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Currency contract\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address from, address to, uint tokens);\n', '    event Approval(address tokenOwner, address spender, uint tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// CNT Currency contract extended API\n', '// ----------------------------------------------------------------------------\n', 'contract PRE_SALE_Token is ERC20Interface {\n', '    function ico_distribution(address to, uint tokens) public;\n', '    function ico_promo_reward(address to, uint tokens) public;\n', '    function init(address _sale) public;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// NRB_Contract User Contract API\n', '// ----------------------------------------------------------------------------\n', 'contract NRB_Contract {\n', '    function registerUserOnToken(address _token, address _user, uint _value, uint _flc, string _json) public returns (uint);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// contract WhiteListAccess\n', '// ----------------------------------------------------------------------------\n', 'contract WhiteListAccess { \n', '    \n', '    function WhiteListAccess() public {\n', '        owner = msg.sender;\n', '        whitelist[owner] = true;\n', '        whitelist[address(this)] = true;\n', '    }\n', '    \n', '    address public owner;\n', '    mapping (address => bool) whitelist;\n', '\n', '    modifier onlyOwner {require(msg.sender == owner); _;}\n', '    modifier onlyWhitelisted {require(whitelist[msg.sender]); _;}\n', '\n', '    function addToWhiteList(address trusted) public onlyOwner() {\n', '        whitelist[trusted] = true;\n', '    }\n', '\n', '    function removeFromWhiteList(address untrusted) public onlyOwner() {\n', '        whitelist[untrusted] = false;\n', '    }\n', '\n', '}\n', '// ----------------------------------------------------------------------------\n', '// CNT_Common contract\n', '// ----------------------------------------------------------------------------\n', 'contract CNT_Common is WhiteListAccess {\n', '    string  public name;\n', '    function CNT_Common() public { ETH_address = 0x1; }\n', '\n', '    // Deployment\n', '    bool public initialized;\n', '    address public ETH_address;    // representation of Ether as Token (0x1)\n', '    address public EOS_address;    // EOS Tokens\n', '    address public NRB_address;    // New Rich on The Block Contract\n', '    \n', '    address public CNT_address;    // Chip\n', '    address public BGB_address;    // BG Coin\n', '    address public VPE_address;    // Vapaee Token\n', '    address public GVPE_address;   // Golden Vapaee Token\n', '    \n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// CNT_Crowdsale\n', '// ----------------------------------------------------------------------------\n', 'contract CNT_Crowdsale is CNT_Common {\n', '\n', '    uint public raised;\n', '    uint public remaining;\n', '    uint public cnt_per_Keos;\n', '    uint public bgb_per_Keos;\n', '    uint public vpe_per_Keos;\n', '    uint public gvpe_per_Keos;\n', '    mapping(address => uint) public paid;\n', '    \n', '    // a global list of users (uniques ids across)\n', '    mapping(uint => Reward) public rewards;\n', '\n', '    // length of prev list\n', '    uint public rewardslength;\n', '\n', '    struct Reward {\n', '        uint cnt;\n', '        uint bgb;\n', '        uint timestamp;\n', '        address target;\n', '        string concept;\n', '    }\n', '\n', '    event Sale(address from, uint eos_tokens, address to, uint cnt_tokens, uint mana_tokens, uint vpe_tokens, uint gvpe_tokens);\n', '    // --------------------------------------------------------------------------------\n', '\n', '    function CNT_Crowdsale() public {\n', '        rewardslength = 0;\n', '        cnt_per_Keos  = 300000;\n', '        bgb_per_Keos  = 300000;\n', '        vpe_per_Keos  =    500;\n', '        gvpe_per_Keos =    100;\n', '        name = "CNT_Crowdsale";\n', '        remaining = 1000000 * 10**18; // 1 million\n', '    }\n', '\n', '    function init(address _eos, address _cnt, address _bgb, address _vpe, address _gvpe, address _nrb) public {\n', '        require(!initialized);\n', '        EOS_address = _eos;\n', '        CNT_address = _cnt;\n', '        BGB_address = _bgb;\n', '        VPE_address = _vpe;\n', '        GVPE_address = _gvpe;\n', '        NRB_address = _nrb;\n', '        PRE_SALE_Token(CNT_address).init(address(this));\n', '        PRE_SALE_Token(BGB_address).init(address(this));\n', '        PRE_SALE_Token(VPE_address).init(address(this));\n', '        PRE_SALE_Token(GVPE_address).init(address(this));\n', '        initialized = true;\n', '    }\n', '\n', '    function isInit() constant public returns (bool) {\n', '        return initialized;\n', '    }\n', '\n', '    function calculateTokens(uint _Keos_amount) constant public returns (uint, uint, uint, uint) {\n', '        uint cnt  = _Keos_amount * cnt_per_Keos;\n', '        uint bgb  = _Keos_amount * bgb_per_Keos;\n', '        uint vpe  = _Keos_amount * vpe_per_Keos;\n', '        uint gvpe = _Keos_amount * gvpe_per_Keos;        \n', '        if (vpe % 1000000000000000000 > 0) {\n', '            vpe = vpe - vpe % 1000000000000000000;\n', '        }\n', '        if (gvpe % 1000000000000000000 > 0) {\n', '            gvpe = gvpe - gvpe % 1000000000000000000;\n', '        }\n', '        return (\n', '            cnt,\n', '            bgb,\n', '            vpe,\n', '            gvpe\n', '        );\n', '    }\n', '\n', '    function buy(uint _Keos_amount) public {\n', '        // calculate how much of each token must be sent\n', '        uint _eos_amount = _Keos_amount * 1000;\n', '        require(remaining >= _eos_amount);\n', '\n', '        uint cnt_amount  = 0;\n', '        uint bgb_amount = 0;\n', '        uint vpe_amount  = 0;\n', '        uint gvpe_amount = 0;\n', '\n', '        (cnt_amount, bgb_amount, vpe_amount, gvpe_amount) = calculateTokens(_Keos_amount);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_distribution(msg.sender, cnt_amount);\n', '        PRE_SALE_Token(BGB_address) .ico_distribution(msg.sender, bgb_amount);\n', '        PRE_SALE_Token(VPE_address) .ico_distribution(msg.sender, vpe_amount);\n', '        PRE_SALE_Token(GVPE_address).ico_distribution(msg.sender, gvpe_amount);\n', '\n', '        // registro la compra\n', '        Sale(address(this), _eos_amount, msg.sender, cnt_amount, bgb_amount, vpe_amount, gvpe_amount);\n', '        paid[msg.sender] = paid[msg.sender] + _eos_amount;\n', '\n', '        // envío los eos al owner\n', '        ERC20Interface(EOS_address).transferFrom(msg.sender, owner, _eos_amount);\n', '\n', '        raised = raised + _eos_amount;\n', '        remaining = remaining - _eos_amount;\n', '    }\n', '\n', '    function registerUserOnToken(string _json) public {\n', '        NRB_Contract(CNT_address).registerUserOnToken(EOS_address, msg.sender, paid[msg.sender], 0, _json);\n', '    }\n', '\n', '    function finishPresale() public onlyOwner() {\n', '        uint cnt_amount  = 0;\n', '        uint bgb_amount = 0;\n', '        uint vpe_amount  = 0;\n', '        uint gvpe_amount = 0;\n', '\n', '        (cnt_amount, bgb_amount, vpe_amount, gvpe_amount) = calculateTokens(remaining);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_distribution(owner, cnt_amount);\n', '        PRE_SALE_Token(BGB_address) .ico_distribution(owner, bgb_amount);\n', '        PRE_SALE_Token(VPE_address) .ico_distribution(owner, vpe_amount);\n', '        PRE_SALE_Token(GVPE_address).ico_distribution(owner, gvpe_amount);\n', '\n', '        // registro la compra\n', '        Sale(address(this), remaining, owner, cnt_amount, bgb_amount, vpe_amount, gvpe_amount);\n', '        paid[owner] = paid[owner] + remaining;\n', '\n', '        raised = raised + remaining;\n', '        remaining = 0;        \n', '    }\n', '\n', '    function reward(address _target, uint _cnt, uint _bgb,  string _concept) public onlyOwner() {\n', '        // register the reward\n', '        rewardslength++;\n', '        rewards[rewardslength] = Reward(_cnt, _bgb, block.timestamp, _target, _concept);\n', '\n', '        // send the tokens\n', '        PRE_SALE_Token(CNT_address) .ico_promo_reward(_target, _cnt);\n', '        PRE_SALE_Token(BGB_address) .ico_promo_reward(_target, _bgb);        \n', '    }\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '\n', '}']
