['/**\n', ' * UserRegistry.sol\n', ' * Mt Pelerin user registry.\n', '\n', ' * The unflattened code is available through this github tag:\n', ' * https://github.com/MtPelerin/MtPelerin-protocol/tree/etherscan-verify-batch-1\n', '\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', '\n', ' * @notice All matters regarding the intellectual property of this code \n', ' * @notice or software are subject to Swiss Law without reference to its \n', ' * @notice conflicts of law rules.\n', '\n', ' * @notice License for each contract is available in the respective file\n', ' * @notice or in the LICENSE.md file.\n', ' * @notice https://github.com/MtPelerin/\n', '\n', ' * @notice Code by OpenZeppelin is copyrighted and licensed on their repository:\n', ' * @notice https://github.com/OpenZeppelin/openzeppelin-solidity\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// File: contracts/zeppelin/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Authority.sol\n', '\n', '/**\n', ' * @title Authority\n', ' * @dev The Authority contract has an authority address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * Authority means to represent a legal entity that is entitled to specific rights\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * AU01: Message sender must be an authority\n', ' */\n', 'contract Authority is Ownable {\n', '\n', '  address authority;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the authority.\n', '   */\n', '  modifier onlyAuthority {\n', '    require(msg.sender == authority, "AU01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev return the address associated to the authority\n', '   */\n', '  function authorityAddress() public view returns (address) {\n', '    return authority;\n', '  }\n', '\n', '  /**\n', '   * @dev rdefines an authority\n', '   * @param _name the authority name\n', '   * @param _address the authority address.\n', '   */\n', '  function defineAuthority(string _name, address _address) public onlyOwner {\n', '    emit AuthorityDefined(_name, _address);\n', '    authority = _address;\n', '  }\n', '\n', '  event AuthorityDefined(\n', '    string name,\n', '    address _address\n', '  );\n', '}\n', '\n', '// File: contracts/interface/IRule.sol\n', '\n', '/**\n', ' * @title IRule\n', ' * @dev IRule interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'interface IRule {\n', '  function isAddressValid(address _address) external view returns (bool);\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: contracts/interface/IUserRegistry.sol\n', '\n', '/**\n', ' * @title IUserRegistry\n', ' * @dev IUserRegistry interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' **/\n', 'contract IUserRegistry {\n', '\n', '  function registerManyUsers(address[] _addresses, uint256 _validUntilTime)\n', '    public;\n', '\n', '  function attachManyAddresses(uint256[] _userIds, address[] _addresses)\n', '    public;\n', '\n', '  function detachManyAddresses(address[] _addresses)\n', '    public;\n', '\n', '  function userCount() public view returns (uint256);\n', '  function userId(address _address) public view returns (uint256);\n', '  function addressConfirmed(address _address) public view returns (bool);\n', '  function validUntilTime(uint256 _userId) public view returns (uint256);\n', '  function suspended(uint256 _userId) public view returns (bool);\n', '  function extended(uint256 _userId, uint256 _key)\n', '    public view returns (uint256);\n', '\n', '  function isAddressValid(address _address) public view returns (bool);\n', '  function isValid(uint256 _userId) public view returns (bool);\n', '\n', '  function registerUser(address _address, uint256 _validUntilTime) public;\n', '  function attachAddress(uint256 _userId, address _address) public;\n', '  function confirmSelf() public;\n', '  function detachAddress(address _address) public;\n', '  function detachSelf() public;\n', '  function detachSelfAddress(address _address) public;\n', '  function suspendUser(uint256 _userId) public;\n', '  function unsuspendUser(uint256 _userId) public;\n', '  function suspendManyUsers(uint256[] _userIds) public;\n', '  function unsuspendManyUsers(uint256[] _userIds) public;\n', '  function updateUser(uint256 _userId, uint256 _validUntil, bool _suspended)\n', '    public;\n', '\n', '  function updateManyUsers(\n', '    uint256[] _userIds,\n', '    uint256 _validUntil,\n', '    bool _suspended) public;\n', '\n', '  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\n', '    public;\n', '\n', '  function updateManyUsersExtended(\n', '    uint256[] _userIds,\n', '    uint256 _key,\n', '    uint256 _value) public;\n', '}\n', '\n', '// File: contracts/UserRegistry.sol\n', '\n', '/**\n', ' * @title UserRegistry\n', ' * @dev UserRegistry contract\n', ' * Configure and manage users\n', ' * Extended may be used externaly to store data within a user context\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@mtpelerin.com>\n', ' *\n', ' * @notice Copyright © 2016 - 2018 Mt Pelerin Group SA - All Rights Reserved\n', ' * @notice Please refer to the top of this file for the license.\n', ' *\n', ' * Error messages\n', ' * UR01: Users length does not match addresses length\n', ' * UR02: UserId is invalid\n', ' * UR03: WalletOwner is invalid\n', ' * UR04: WalletOwner is already confirmed\n', ' * UR05: User is already suspended\n', ' * UR06: User is not suspended\n', '*/\n', 'contract UserRegistry is IUserRegistry, Authority {\n', '\n', '  struct User {\n', '    uint256 validUntilTime;\n', '    bool suspended;\n', '    mapping(uint256 => uint256) extended;\n', '  }\n', '  struct WalletOwner {\n', '    uint256 userId;\n', '    bool confirmed;\n', '  }\n', '\n', '  mapping(uint256 => User) internal users;\n', '  mapping(address => WalletOwner) internal walletOwners;\n', '  uint256 public userCount;\n', '\n', '  /**\n', '   * @dev contructor\n', '   **/\n', '  constructor(address[] _addresses, uint256 _validUntilTime) public {\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      registerUserInternal(_addresses[i], _validUntilTime);\n', '      walletOwners[_addresses[i]].confirmed = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev register many users\n', '   */\n', '  function registerManyUsers(address[] _addresses, uint256 _validUntilTime)\n', '    public onlyAuthority\n', '  {\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      registerUserInternal(_addresses[i], _validUntilTime);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev attach many addresses to many users\n', '   */\n', '  function attachManyAddresses(uint256[] _userIds, address[] _addresses)\n', '    public onlyAuthority\n', '  {\n', '    require(_addresses.length == _userIds.length, "UR01");\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      attachAddress(_userIds[i], _addresses[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev detach many addresses association between addresses and their respective users\n', '   */\n', '  function detachManyAddresses(address[] _addresses) public onlyAuthority {\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      detachAddress(_addresses[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev number of user registred\n', '   */\n', '  function userCount() public view returns (uint256) {\n', '    return userCount;\n', '  }\n', '\n', '  /**\n', '   * @dev the userId associated to the provided address\n', '   */\n', '  function userId(address _address) public view returns (uint256) {\n', '    return walletOwners[_address].userId;\n', '  }\n', '\n', '  /**\n', '   * @dev the userId associated to the provided address if the user is valid\n', '   */\n', '  function validUserId(address _address) public view returns (uint256) {\n', '    if (isAddressValid(_address)) {\n', '      return walletOwners[_address].userId;\n', '    }\n', '    return 0;\n', '  }\n', '\n', '  /**\n', '   * @dev the userId associated to the provided address\n', '   */\n', '  function addressConfirmed(address _address) public view returns (bool) {\n', '    return walletOwners[_address].confirmed;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the time at which user validity ends\n', '   */\n', '  function validUntilTime(uint256 _userId) public view returns (uint256) {\n', '    return users[_userId].validUntilTime;\n', '  }\n', '\n', '  /**\n', '   * @dev is the user suspended\n', '   */\n', '  function suspended(uint256 _userId) public view returns (bool) {\n', '    return users[_userId].suspended;\n', '  }\n', '\n', '  /**\n', '   * @dev access to extended user data\n', '   */\n', '  function extended(uint256 _userId, uint256 _key)\n', '    public view returns (uint256)\n', '  {\n', '    return users[_userId].extended[_key];\n', '  }\n', '\n', '  /**\n', '   * @dev validity of the current user\n', '   */\n', '  function isAddressValid(address _address) public view returns (bool) {\n', '    return walletOwners[_address].confirmed &&\n', '      isValid(walletOwners[_address].userId);\n', '  }\n', '\n', '  /**\n', '   * @dev validity of the current user\n', '   */\n', '  function isValid(uint256 _userId) public view returns (bool) {\n', '    return isValidInternal(users[_userId]);\n', '  }\n', '\n', '  /**\n', '   * @dev register a user\n', '   */\n', '  function registerUser(address _address, uint256 _validUntilTime)\n', '    public onlyAuthority\n', '  {\n', '    registerUserInternal(_address, _validUntilTime);\n', '  }\n', '\n', '  /**\n', '   * @dev register a user\n', '   */\n', '  function registerUserInternal(address _address, uint256 _validUntilTime)\n', '    public\n', '  {\n', '    require(walletOwners[_address].userId == 0, "UR03");\n', '    users[++userCount] = User(_validUntilTime, false);\n', '    walletOwners[_address] = WalletOwner(userCount, false);\n', '  }\n', '\n', '  /**\n', '   * @dev attach an address with a user\n', '   */\n', '  function attachAddress(uint256 _userId, address _address)\n', '    public onlyAuthority\n', '  {\n', '    require(_userId > 0 && _userId <= userCount, "UR02");\n', '    require(walletOwners[_address].userId == 0, "UR03");\n', '    walletOwners[_address] = WalletOwner(_userId, false);\n', '  }\n', '\n', '  /**\n', '   * @dev confirm the address by the user to activate it\n', '   */\n', '  function confirmSelf() public {\n', '    require(walletOwners[msg.sender].userId != 0, "UR03");\n', '    require(!walletOwners[msg.sender].confirmed, "UR04");\n', '    walletOwners[msg.sender].confirmed = true;\n', '  }\n', '\n', '  /**\n', '   * @dev detach the association between an address and its user\n', '   */\n', '  function detachAddress(address _address) public onlyAuthority {\n', '    require(walletOwners[_address].userId != 0, "UR03");\n', '    delete walletOwners[_address];\n', '  }\n', '\n', '  /**\n', '   * @dev detach the association between an address and its user\n', '   */\n', '  function detachSelf() public {\n', '    detachSelfAddress(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev detach the association between an address and its user\n', '   */\n', '  function detachSelfAddress(address _address) public {\n', '    uint256 senderUserId = walletOwners[msg.sender].userId;\n', '    require(senderUserId != 0, "UR03");\n', '    require(walletOwners[_address].userId == senderUserId, "UR06");\n', '    delete walletOwners[_address];\n', '  }\n', '\n', '  /**\n', '   * @dev suspend a user\n', '   */\n', '  function suspendUser(uint256 _userId) public onlyAuthority {\n', '    require(_userId > 0 && _userId <= userCount, "UR02");\n', '    require(!users[_userId].suspended, "UR06");\n', '    users[_userId].suspended = true;\n', '  }\n', '\n', '  /**\n', '   * @dev unsuspend a user\n', '   */\n', '  function unsuspendUser(uint256 _userId) public onlyAuthority {\n', '    require(_userId > 0 && _userId <= userCount, "UR02");\n', '    require(users[_userId].suspended, "UR06");\n', '    users[_userId].suspended = false;\n', '  }\n', '\n', '  /**\n', '   * @dev suspend many users\n', '   */\n', '  function suspendManyUsers(uint256[] _userIds) public onlyAuthority {\n', '    for (uint256 i = 0; i < _userIds.length; i++) {\n', '      suspendUser(_userIds[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev unsuspend many users\n', '   */\n', '  function unsuspendManyUsers(uint256[] _userIds) public onlyAuthority {\n', '    for (uint256 i = 0; i < _userIds.length; i++) {\n', '      unsuspendUser(_userIds[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev update a user\n', '   */\n', '  function updateUser(\n', '    uint256 _userId,\n', '    uint256 _validUntilTime,\n', '    bool _suspended) public onlyAuthority\n', '  {\n', '    require(_userId > 0 && _userId <= userCount, "UR02");\n', '    users[_userId].validUntilTime = _validUntilTime;\n', '    users[_userId].suspended = _suspended;\n', '  }\n', '\n', '  /**\n', '   * @dev update many users\n', '   */\n', '  function updateManyUsers(\n', '    uint256[] _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended) public onlyAuthority\n', '  {\n', '    for (uint256 i = 0; i < _userIds.length; i++) {\n', '      updateUser(_userIds[i], _validUntilTime, _suspended);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev update user extended information\n', '   */\n', '  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\n', '    public onlyAuthority\n', '  {\n', '    require(_userId > 0 && _userId <= userCount, "UR02");\n', '    users[_userId].extended[_key] = _value;\n', '  }\n', '\n', '  /**\n', "   * @dev update many users' extended information\n", '   */\n', '  function updateManyUsersExtended(\n', '    uint256[] _userIds,\n', '    uint256 _key,\n', '    uint256 _value) public onlyAuthority\n', '  {\n', '    for (uint256 i = 0; i < _userIds.length; i++) {\n', '      updateUserExtended(_userIds[i], _key, _value);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev validity of the current user\n', '   */\n', '  function isValidInternal(User user) internal view returns (bool) {\n', '    // solium-disable-next-line security/no-block-members\n', '    return !user.suspended && user.validUntilTime > now;\n', '  }\n', '}']