['/*\n', '\n', '  Copyright 2017 Cofound.it.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.4.13;\n', '\n', 'contract ReentrnacyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() public{\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract IToken {\n', '  function totalSupply() public constant returns (uint256 totalSupply);\n', '  function mintTokens(address _to, uint256 _amount) public {}\n', '}\n', '\n', 'contract IERC20Token {\n', '  function totalSupply() public constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {}\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract Crowdsale is ReentrnacyHandlingContract, Owned{\n', '\n', '  struct ContributorData{\n', '    uint priorityPassAllowance;\n', '    bool isActive;\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint public nextContributorIndex;\n', '  mapping(uint => address) public contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\n', '\n', '  uint public presaleStartTime;\n', '  uint public presaleUnlimitedStartTime;\n', '  uint public crowdsaleStartTime;\n', '  uint public crowdsaleEndedTime;\n', '\n', '  event PresaleStarted(uint blockTime);\n', '  event PresaleUnlimitedStarted(uint blockTime);\n', '  event CrowdsaleStarted(uint blockTime);\n', '  event CrowdsaleEnded(uint blockTime);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockTime);\n', '  event MaxCapReached(uint blockTime);\n', '  event ContributionMade(address indexed contributor, uint amount);\n', '\n', '\n', '  IToken token = IToken(0x0);\n', '  uint ethToTokenConversion;\n', '\n', '  uint public minCap;\n', '  uint public maxP1Cap;\n', '  uint public maxCap;\n', '  uint public ethRaised;\n', '\n', '  address public multisigAddress;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint public maxTokenSupply;\n', '  bool public ownerHasClaimedTokens;\n', '  uint public presaleBonusTokens;\n', '  address public presaleBonusAddress;\n', '  address public presaleBonusAddressColdStorage;\n', '  bool public presaleBonusTokensClaimed;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  // @payable\n', '  //\n', '  function() public noReentrancy payable{\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.priorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.openedPriorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.crowdsale){\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    }\n', '    else{\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool){\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      MaxCapReached(block.timestamp);                                                              // Close the crowdsale\n', '      CrowdsaleEnded(block.timestamp);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.timestamp > presaleStartTime && block.timestamp <= presaleUnlimitedStartTime){  // Check if we are in presale phase\n', '      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.priorityPass;                                              // Set new state\n', '        PresaleStarted(block.timestamp);                                                     // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.timestamp > presaleUnlimitedStartTime && block.timestamp <= crowdsaleStartTime){ // Check if we are in presale unlimited phase\n', '      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.openedPriorityPass;                                              // Set new state\n', '        PresaleUnlimitedStarted(block.timestamp);                                                  // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.timestamp > crowdsaleStartTime && block.timestamp <= crowdsaleEndedTime){        // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.timestamp);                                                         // Raise event\n', '        return true;\n', '      }\n', '    }else{\n', '      if (crowdsaleState != state.crowdsaleEnded && block.timestamp > crowdsaleEndedTime){        // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.timestamp);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal{\n', '    if (_stateChanged){\n', '      msg.sender.transfer(msg.value);\n', '    }else{\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  // Calculate how much user can contribute\n', '  //\n', '  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\n', '    uint maxContrib;\n', '    if (crowdsaleState == state.priorityPass){    // Check if we are in priority pass\n', '      maxContrib = contributorList[_contributor].priorityPassAllowance - contributorList[_contributor].contributionAmount;\n', '      if (maxContrib > (maxP1Cap - ethRaised)){   // Check if max contribution is more that max cap\n', '        maxContrib = maxP1Cap - ethRaised;        // Alter max cap\n', '      }\n', '    }\n', '    else{\n', '      maxContrib = maxCap - ethRaised;            // Alter max cap\n', '    }\n', '    return maxContrib;\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal{\n', '    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxContribution;                                     // Set that user contributes his maximum allowed contribution\n', '      returnAmount = _amount - maxContribution;                                 // Calculate how much he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) MinCapReached(block.timestamp);\n', '\n', '    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\n', '      contributorList[_contributor].isActive = true;                            // Set his activity to true\n', '      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\n', '      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '      nextContributorIndex++;\n', '    }\n', '    else{\n', '      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n', '    }\n', '    ethRaised += contributionAmount;                                            // Add to eth raised\n', '\n', '    ContributionMade(msg.sender, contributionAmount);\n', '\n', '    uint tokenAmount = contributionAmount * ethToTokenConversion;               // Calculate how much tokens must contributor get\n', '    if (tokenAmount > 0){\n', '      token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\n', '      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\n', '    }\n', '    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\n', '  }\n', '\n', '  //\n', '  // Push contributor data to the contract before the crowdsale so that they are eligible for priority pass\n', '  //\n', '  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances) public onlyOwner{\n', '    require(_contributorAddresses.length == _contributorPPAllowances.length); // Check if input data is correct\n', '\n', '    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\n', '      if (contributorList[_contributorAddresses[cnt]].isActive){\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '      }\n', '      else{\n', '        contributorList[_contributorAddresses[cnt]].isActive = true;\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '        contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];\n', '        nextContributorIndex++;\n', '      }\n', '    }\n', '  }\n', '\n', '  //\n', '  // Method is needed for recovering tokens accidentally sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) public onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  // @owner sets contributions to withdraw\n', '  //\n', '  function withdrawEth() onlyOwner public {\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    pendingEthWithdrawal = this.balance;\n', '  }\n', '\n', '\n', '  uint public pendingEthWithdrawal;\n', '  //\n', '  // pulls the funds that were set to send with calling of\n', '  // withdrawEth when minimum cap is reached\n', '  // @multisig pulls the contributions to self\n', '  //\n', '  function pullBalance() public {\n', '    require(msg.sender == multisigAddress);\n', '    require(pendingEthWithdrawal > 0);\n', '\n', '    multisigAddress.transfer(pendingEthWithdrawal);\n', '    pendingEthWithdrawal = 0;\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed() public {\n', '    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedTime\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)){                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) public onlyOwner{\n', '    require(block.timestamp > crowdsaleEndedTime && ethRaised < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withdraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() public onlyOwner{\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.timestamp > crowdsaleEndedTime);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) public onlyOwner{\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) public onlyOwner{\n', '    token = IToken(_newAddress);\n', '  }\n', '\n', '  //\n', '  // Owner can claim teams tokens when crowdsale has successfully ended\n', '  //\n', '  function claimCoreTeamsTokens(address _to) public onlyOwner{\n', '    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\n', '    require(!ownerHasClaimedTokens);                              // Check if owner has already claimed tokens\n', '\n', '    uint devReward = maxTokenSupply - token.totalSupply();\n', '    if (!presaleBonusTokensClaimed) devReward -= presaleBonusTokens; // If presaleBonusToken has been claimed its ok if not set aside presaleBonusTokens\n', '    token.mintTokens(_to, devReward);                             // Issue Teams tokens\n', '    ownerHasClaimedTokens = true;                                 // Block further mints from this method\n', '  }\n', '\n', '  //\n', '  // Presale bonus tokens\n', '  //\n', '  function claimPresaleTokens() public {\n', '    require(msg.sender == presaleBonusAddress);         // Check if sender is address to claim tokens\n', '    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\n', '    require(!presaleBonusTokensClaimed);                // Check if tokens were already claimed\n', '\n', '    token.mintTokens(presaleBonusAddressColdStorage, presaleBonusTokens);             // Issue presale  tokens\n', '    presaleBonusTokensClaimed = true;                   // Block further mints from this method\n', '  }\n', '\n', '  function getTokenAddress() public constant returns(address){\n', '    return address(token);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract FutouristCrowdsale is Crowdsale {\n', '  function FutouristCrowdsale() public {\n', '    /* ADAPT */\n', '    presaleStartTime = 1519142400; //20/2/2017/1700\n', '    presaleUnlimitedStartTime = 1519315200; //22/2/2017/1700\n', '    crowdsaleStartTime = 1519747200; //27/2/2017/1700\n', '    crowdsaleEndedTime = 1521561600; //20/3/2017/1700\n', '\n', '    minCap = 1 ether;\n', '    maxCap = 4979 ether;\n', '    maxP1Cap = 4979 ether;\n', '\n', '    ethToTokenConversion = 47000;\n', '\n', '    maxTokenSupply = 1000000000 * 10**18;\n', '    presaleBonusTokens = 115996000  * 10**18;\n', '    presaleBonusAddress = 0xd7C4af0e30EC62a01036e45b6ed37BC6D0a3bd53;\n', '    presaleBonusAddressColdStorage = 0x47D634Ce50170a156ec4300d35BE3b48E17CAaf6;\n', '    /* /ADAPT */\n', '  }\n', '}']