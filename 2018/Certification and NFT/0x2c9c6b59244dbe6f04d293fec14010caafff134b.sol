['pragma solidity ^0.4.8;\n', '\n', 'contract ibaVoter {\n', '    \n', '    struct Proposal{\n', '        bytes32 name;\n', '    }\n', '    \n', '    struct Ballot{\n', '        bytes32 name;\n', '        address chainperson;\n', '        bool blind;\n', '        bool finished;\n', '    }\n', '    \n', '    struct votedData{\n', '        uint256 proposal;\n', '        bool isVal;\n', '    }\n', '    \n', '    event Vote(\n', '        address votedPerson,\n', '        uint256 proposalIndex\n', '        );\n', '        \n', '    event Finish(\n', '        bool finished\n', '        );\n', '\n', '    mapping (address => mapping(uint256 => mapping(address => votedData))) votedDatas;\n', '    mapping (address => mapping(uint256 => address[])) voted;\n', '    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) voteCount;\n', '    mapping (address => Ballot[]) public ballots;   \n', '    mapping (address => mapping(uint256 => Proposal[])) public proposals;\n', '    \n', '    function getBallotsNum(address chainperson) public constant returns (uint count) {\n', '        return ballots[chainperson].length; \n', '    }\n', '    function getProposalsNum(address chainperson, uint ballot) public constant returns (uint count) {\n', '        return proposals[chainperson][ballot].length;\n', '    }\n', '    \n', '    function getBallotIndex(address chainperson, bytes32 ballotName) public constant returns (uint index){\n', '        for (uint i=0;i<ballots[chainperson].length;i++){\n', '            if (ballots[chainperson][i].name == ballotName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    function isVoted(address chainperson, uint ballot) public constant returns (bool result){\n', '        for (uint8 i=0;i<voted[chainperson][ballot].length;i++){\n', '            if (voted[chainperson][ballot][i] == msg.sender){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){\n', '        for (uint8 y=0;y<ballots[msg.sender].length;y++){\n', '            if (ballots[msg.sender][i].name == ballotName){\n', '                revert();\n', '            }\n', '        }\n', '        ballots[msg.sender].push(Ballot({\n', '            name: ballotName, \n', '            chainperson: msg.sender, \n', '            blind: blindParam,\n', '            finished: false\n', '        }));\n', '        \n', '        uint ballotsNum = ballots[msg.sender].length;\n', '        for (uint8 i=0;i<proposalNames.length;i++){\n', '            proposals[msg.sender][ballotsNum-1].push(Proposal({name:proposalNames[i]}));\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function getVoted(address chainperson, uint256 ballot) public constant returns (address[]){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        return voted[chainperson][ballot];\n', '    }\n', '    \n', '    function getVotesCount(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint256 count){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return voteCount[chainperson][ballot][i];\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getVotedData(address chainperson, uint256 ballot, address voter) public constant returns (uint256 proposalNum){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        if (votedDatas[chainperson][ballot][voter].isVal == true){\n', '            return votedDatas[chainperson][ballot][voter].proposal;\n', '        }\n', '    }\n', '    \n', '    function vote(address chainperson, uint256 ballot, uint256 proposalNum) external returns (bool success){\n', '        \n', '        if (ballots[chainperson][ballot].finished == true){\n', '            revert();\n', '        }\n', '        for (uint8 i = 0;i<voted[chainperson][ballot].length;i++){\n', '            if (votedDatas[chainperson][ballot][msg.sender].isVal == true){\n', '                revert();\n', '            }\n', '        }\n', '        voted[chainperson][ballot].push(msg.sender);\n', '        voteCount[chainperson][ballot][proposalNum]++;\n', '        votedDatas[chainperson][ballot][msg.sender] = votedData({proposal: proposalNum, isVal: true});\n', '        Vote(msg.sender, proposalNum);\n', '        return true;\n', '    }\n', '    \n', '    function getProposalIndex(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint index){\n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function finishBallot(bytes32 ballot) external returns (bool success){\n', '        for (uint8 i=0;i<ballots[msg.sender].length;i++){\n', '            if (ballots[msg.sender][i].name == ballot) {\n', '                if (ballots[msg.sender][i].chainperson == msg.sender){\n', '                    ballots[msg.sender][i].finished = true;\n', '                    Finish(true);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getWinner(address chainperson, uint ballotIndex) public constant returns (bytes32 winnerName){\n', '            if (ballots[chainperson][ballotIndex].finished == false){\n', '                revert();\n', '            }\n', '            uint256 maxVotes;\n', '            bytes32 winner;\n', '            for (uint8 i=0;i<proposals[chainperson][ballotIndex].length;i++){\n', '                if (voteCount[chainperson][ballotIndex][i]>maxVotes){\n', '                    maxVotes = voteCount[chainperson][ballotIndex][i];\n', '                    winner = proposals[chainperson][ballotIndex][i].name;\n', '                }\n', '            }\n', '            return winner;\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', 'contract ibaVoter {\n', '    \n', '    struct Proposal{\n', '        bytes32 name;\n', '    }\n', '    \n', '    struct Ballot{\n', '        bytes32 name;\n', '        address chainperson;\n', '        bool blind;\n', '        bool finished;\n', '    }\n', '    \n', '    struct votedData{\n', '        uint256 proposal;\n', '        bool isVal;\n', '    }\n', '    \n', '    event Vote(\n', '        address votedPerson,\n', '        uint256 proposalIndex\n', '        );\n', '        \n', '    event Finish(\n', '        bool finished\n', '        );\n', '\n', '    mapping (address => mapping(uint256 => mapping(address => votedData))) votedDatas;\n', '    mapping (address => mapping(uint256 => address[])) voted;\n', '    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) voteCount;\n', '    mapping (address => Ballot[]) public ballots;   \n', '    mapping (address => mapping(uint256 => Proposal[])) public proposals;\n', '    \n', '    function getBallotsNum(address chainperson) public constant returns (uint count) {\n', '        return ballots[chainperson].length; \n', '    }\n', '    function getProposalsNum(address chainperson, uint ballot) public constant returns (uint count) {\n', '        return proposals[chainperson][ballot].length;\n', '    }\n', '    \n', '    function getBallotIndex(address chainperson, bytes32 ballotName) public constant returns (uint index){\n', '        for (uint i=0;i<ballots[chainperson].length;i++){\n', '            if (ballots[chainperson][i].name == ballotName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    function isVoted(address chainperson, uint ballot) public constant returns (bool result){\n', '        for (uint8 i=0;i<voted[chainperson][ballot].length;i++){\n', '            if (voted[chainperson][ballot][i] == msg.sender){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){\n', '        for (uint8 y=0;y<ballots[msg.sender].length;y++){\n', '            if (ballots[msg.sender][i].name == ballotName){\n', '                revert();\n', '            }\n', '        }\n', '        ballots[msg.sender].push(Ballot({\n', '            name: ballotName, \n', '            chainperson: msg.sender, \n', '            blind: blindParam,\n', '            finished: false\n', '        }));\n', '        \n', '        uint ballotsNum = ballots[msg.sender].length;\n', '        for (uint8 i=0;i<proposalNames.length;i++){\n', '            proposals[msg.sender][ballotsNum-1].push(Proposal({name:proposalNames[i]}));\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function getVoted(address chainperson, uint256 ballot) public constant returns (address[]){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        return voted[chainperson][ballot];\n', '    }\n', '    \n', '    function getVotesCount(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint256 count){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return voteCount[chainperson][ballot][i];\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getVotedData(address chainperson, uint256 ballot, address voter) public constant returns (uint256 proposalNum){\n', '        if (ballots[chainperson][ballot].blind == true){\n', '            revert();\n', '        }\n', '        \n', '        if (votedDatas[chainperson][ballot][voter].isVal == true){\n', '            return votedDatas[chainperson][ballot][voter].proposal;\n', '        }\n', '    }\n', '    \n', '    function vote(address chainperson, uint256 ballot, uint256 proposalNum) external returns (bool success){\n', '        \n', '        if (ballots[chainperson][ballot].finished == true){\n', '            revert();\n', '        }\n', '        for (uint8 i = 0;i<voted[chainperson][ballot].length;i++){\n', '            if (votedDatas[chainperson][ballot][msg.sender].isVal == true){\n', '                revert();\n', '            }\n', '        }\n', '        voted[chainperson][ballot].push(msg.sender);\n', '        voteCount[chainperson][ballot][proposalNum]++;\n', '        votedDatas[chainperson][ballot][msg.sender] = votedData({proposal: proposalNum, isVal: true});\n', '        Vote(msg.sender, proposalNum);\n', '        return true;\n', '    }\n', '    \n', '    function getProposalIndex(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint index){\n', '        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\n', '            if (proposals[chainperson][ballot][i].name == proposalName){\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    function finishBallot(bytes32 ballot) external returns (bool success){\n', '        for (uint8 i=0;i<ballots[msg.sender].length;i++){\n', '            if (ballots[msg.sender][i].name == ballot) {\n', '                if (ballots[msg.sender][i].chainperson == msg.sender){\n', '                    ballots[msg.sender][i].finished = true;\n', '                    Finish(true);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getWinner(address chainperson, uint ballotIndex) public constant returns (bytes32 winnerName){\n', '            if (ballots[chainperson][ballotIndex].finished == false){\n', '                revert();\n', '            }\n', '            uint256 maxVotes;\n', '            bytes32 winner;\n', '            for (uint8 i=0;i<proposals[chainperson][ballotIndex].length;i++){\n', '                if (voteCount[chainperson][ballotIndex][i]>maxVotes){\n', '                    maxVotes = voteCount[chainperson][ballotIndex][i];\n', '                    winner = proposals[chainperson][ballotIndex][i].name;\n', '                }\n', '            }\n', '            return winner;\n', '    }\n', '}']
