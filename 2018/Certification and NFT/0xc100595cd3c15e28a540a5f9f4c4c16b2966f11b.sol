['pragma solidity ^0.4.24;\n', '\n', 'contract IERC20 {\n', '    function totalSupply() pure public returns (uint _totalSupply);\n', '    function balanceOf(address _owner) pure public returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) pure public returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'library SafeMathLib {\n', '\n', '  function times(uint a, uint b) pure public returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) pure public returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) pure public returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @notice The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract TDX {\n', '\n', '    address public owner;\n', '    /**\n', '    * @notice The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @notice Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Sale\n', ' * @notice The Token Sale contract\n', ' */\n', 'contract Sale is TDX {\n', '\n', '  using SafeMathLib for uint256;\n', '  using SafeMathLib for uint8;\n', '\n', '  IERC20 token;\n', '  address tokenAddressWallet;\n', '  address etherAddressWallet;\n', '  \n', '  uint256 public constant CAP = 15000000 * 10**8;\n', '  uint256 public constant tokensPerPhase = 5000000 * 10**8;\n', '  uint256 public PHASE1_START = 1533254400;\n', '  uint256 public PHASE1_END = 1536451200;\n', '  \n', '  uint256 public PHASE2_START = 1536451200;\n', '  uint256 public PHASE2_END = 1539648000;\n', '  \n', '  uint256 public PHASE3_START = 1539648000;\n', '  uint256 public PHASE3_END = 1543017600;\n', '\n', '  // For First phase, price is 1/2,\n', '  // For Second phase, price is 3/4,\n', '  // For Third phase, price is 1\n', '  uint256 usdPerEther = 1000;\n', '  \n', '  //Total Tokens Sold\n', '  uint256 public tokensSold;\n', '  uint256[] public tokensSoldPerPhase;\n', '\n', '  bool public initialized = false;\n', '\n', '  modifier IsLive() {\n', '    // Check if sale is active\n', '    assert(isSaleLive());\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '      address _tokenAddr,\n', '      address _etherAddr,\n', '      address _tokenWalletAddr\n', '      ) public {\n', '      require(_tokenAddr != 0);\n', '      token = IERC20(_tokenAddr);\n', '      etherAddressWallet = _etherAddr;\n', '      tokenAddressWallet = _tokenWalletAddr;\n', '  }\n', '\n', '  /**\n', '   * @notice Initializes the Sale\n', '   * Required as we need to Ensure the pre-requirements are met.\n', '   */\n', '  function initialize() public onlyOwner {\n', '      require(initialized == false); // Can only be initialized once\n', '      require(tokensAvailable() == CAP); // Must have enough tokens allocated\n', '      initialized = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Checks if the sale is Live.\n', '   */\n', '  function isSaleLive() public constant returns (bool) {\n', '    return ( \n', '        initialized == true &&\n', '        getPhase() != 0 &&\n', '        goalReached() == false // Goal must not already be reached\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether the Goal is Reached.\n', '   */\n', '  function goalReached() public constant returns (bool) {\n', '    if (tokensSold >= CAP) {\n', '      token.transfer(tokenAddressWallet, token.balanceOf(this));\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '  \n', '  function () public payable {\n', '    sellTokens();\n', '  }\n', '\n', '  function sellTokens() payable IsLive {\n', '    require(msg.value > 0);\n', '    uint256 tokens;\n', '    uint8 phase = getPhase();\n', '    \n', '    if (phase == 1) {\n', '        tokens = (((msg.value) / usdPerEther) / 2) / 10 **10;\n', '    } else if (phase == 2) {\n', '        tokens = (((msg.value).times(3) / usdPerEther) / 4) / 10 **10;\n', '    } else if (phase == 3) {\n', '        tokens = ((msg.value) / usdPerEther) / 10 ** 10;\n', '    }\n', '    \n', '    uint256 afterPayment = tokensSoldPerPhase[phase].plus(tokens);\n', '    require(afterPayment <= tokensPerPhase);\n', '    tokensSold = tokensSold.plus(tokens);\n', '    tokensSoldPerPhase[phase] = afterPayment;\n', '    transferTokens(tokens);\n', '    etherAddressWallet.transfer(msg.value);\n', '  }\n', '  \n', '  function getPhase() public constant returns (uint8) {\n', '      if (now >= PHASE1_START && now <= PHASE1_END) {\n', '        return 1;\n', '      } else if (now >= PHASE2_START && now <= PHASE2_END) {\n', '        return 2;\n', '      } else if (now >= PHASE3_START && now <= PHASE3_END) {\n', '        return 3;\n', '      } else if(now >= PHASE3_END) {\n', '          terminateSale();\n', '      } else {\n', '        return 0;\n', '      }\n', '  }\n', '  \n', '   function transferTokens(uint256 tokens) private {\n', '      token.transfer(msg.sender, tokens);\n', '      tokensSold = tokensSold.plus(tokens);\n', '  }\n', '\n', '  function tokensAvailable() public constant returns (uint256) {\n', '    return token.balanceOf(this);\n', '  }\n', '\n', '  function terminateSale() internal {\n', '    token.transfer(tokenAddressWallet, token.balanceOf(this));\n', '  }\n', '\n', '  function terminateTokenSale() public onlyOwner {\n', '      terminateSale();\n', '  }\n', '\n', '  function terminateContract() public onlyOwner {\n', '      terminateSale();\n', '      selfdestruct(etherAddressWallet);\n', '  }\n', '\n', '}']