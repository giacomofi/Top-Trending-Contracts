['pragma solidity ^0.4.24;\n', '\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  function safeAdd (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x <= MAX_UINT256 - y);\n', '    return x + y;\n', '  }\n', '\n', '  function safeSub (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x >= y);\n', '    return x - y;\n', '  }\n', '\n', '  function safeMul (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    assert (x <= MAX_UINT256 / y);\n', '    return x * y;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '\n', '  function totalSupply () public view returns (uint256 supply);\n', '\n', '  function balanceOf (address _owner) public view returns (uint256 balance);\n', '\n', '  function transfer (address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  function approve (address _spender, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  function allowance (address _owner, address _spender)\n', '  public view returns (uint256 remaining);\n', '\n', '  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  event Approval (\n', '    address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract AddressSet {\n', '  function contains (address _address) public view returns (bool);\n', '}\n', '\n', 'contract AbstractToken is Token, SafeMath {\n', '  function AbstractToken () public {\n', '    // Do nothing\n', '  }\n', '\n', '  function balanceOf (address _owner) public view returns (uint256 balance) {\n', '    return accounts [_owner];\n', '  }\n', '\n', '  function transfer (address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    uint256 fromBalance = accounts [msg.sender];\n', '    if (fromBalance < _value) return false;\n', '    if (_value > 0 && msg.sender != _to) {\n', '      accounts [msg.sender] = safeSub (fromBalance, _value);\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    Transfer (msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    uint256 spenderAllowance = allowances [_from][msg.sender];\n', '    if (spenderAllowance < _value) return false;\n', '    uint256 fromBalance = accounts [_from];\n', '    if (fromBalance < _value) return false;\n', '\n', '    allowances [_from][msg.sender] =\n', '      safeSub (spenderAllowance, _value);\n', '\n', '    if (_value > 0 && _from != _to) {\n', '      accounts [_from] = safeSub (fromBalance, _value);\n', '      accounts [_to] = safeAdd (accounts [_to], _value);\n', '    }\n', '    Transfer (_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve (address _spender, uint256 _value)\n', '  public returns (bool success) {\n', '    allowances [msg.sender][_spender] = _value;\n', '    Approval (msg.sender, _spender, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function allowance (address _owner, address _spender)\n', '  public view returns (uint256 remaining) {\n', '    return allowances [_owner][_spender];\n', '  }\n', '\n', '  mapping (address => uint256) internal accounts;\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowances;\n', '}\n', '\n', 'contract AbstractVirtualToken is AbstractToken {\n', '\n', '  uint256 constant MAXIMUM_TOKENS_COUNT =\n', '    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  uint256 constant BALANCE_MASK =\n', '    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  uint256 constant MATERIALIZED_FLAG_MASK =\n', '    0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '  function AbstractVirtualToken () public AbstractToken () {\n', '    // Do nothing\n', '  }\n', '\n', '  function totalSupply () public view returns (uint256 supply) {\n', '    return tokensCount;\n', '  }\n', '\n', '  function balanceOf (address _owner) public view returns (uint256 balance) {\n', '    return safeAdd (\n', '      accounts [_owner] & BALANCE_MASK, getVirtualBalance (_owner));\n', '  }\n', '\n', '  function transfer (address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    if (_value > balanceOf (msg.sender)) return false;\n', '    else {\n', '      materializeBalanceIfNeeded (msg.sender, _value);\n', '      return AbstractToken.transfer (_to, _value);\n', '    }\n', '  }\n', '\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success) {\n', '    if (_value > allowance (_from, msg.sender)) return false;\n', '    if (_value > balanceOf (_from)) return false;\n', '    else {\n', '      materializeBalanceIfNeeded (_from, _value);\n', '      return AbstractToken.transferFrom (_from, _to, _value);\n', '    }\n', '  }\n', '\n', '  function virtualBalanceOf (address _owner)\n', '  internal view returns (uint256 _virtualBalance);\n', '\n', '  function getVirtualBalance (address _owner)\n', '  private view returns (uint256 _virtualBalance) {\n', '    if (accounts [_owner] & MATERIALIZED_FLAG_MASK != 0) return 0;\n', '    else {\n', '      _virtualBalance = virtualBalanceOf (_owner);\n', '      uint256 maxVirtualBalance = safeSub (MAXIMUM_TOKENS_COUNT, tokensCount);\n', '      if (_virtualBalance > maxVirtualBalance)\n', '        _virtualBalance = maxVirtualBalance;\n', '    }\n', '  }\n', '\n', '  function materializeBalanceIfNeeded (address _owner, uint256 _value) private {\n', '    uint256 storedBalance = accounts [_owner];\n', '    if (storedBalance & MATERIALIZED_FLAG_MASK == 0) {\n', '      // Virtual balance is not materialized yet\n', '      if (_value > storedBalance) {\n', '        // Real balance is not enough\n', '        uint256 virtualBalance = getVirtualBalance (_owner);\n', '        require (safeSub (_value, storedBalance) <= virtualBalance);\n', '        accounts [_owner] = MATERIALIZED_FLAG_MASK |\n', '          safeAdd (storedBalance, virtualBalance);\n', '        tokensCount = safeAdd (tokensCount, virtualBalance);\n', '      }\n', '    }\n', '  }\n', '\n', '  uint256 internal tokensCount;\n', '}\n', '\n', 'contract FoshaAirdrop is AbstractVirtualToken {\n', '\n', '  uint256 private constant VIRTUAL_THRESHOLD = 0.1 ether;\n', '\n', '  uint256 private constant VIRTUAL_COUNT = 10e8;\n', '\n', '  function FoshaAirdrop () AbstractVirtualToken () {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function name () constant returns (string result) {\n', '    return "Fosha Airdrop";\n', '  }\n', '\n', '  function symbol () constant returns (string result) {\n', '    return "FOSHAIR";\n', '  }\n', '\n', '  function decimals () constant returns (uint8 result) {\n', '    return 8;\n', '  }\n', '\n', '  function massNotify (address [] _owners) {\n', '    require (msg.sender == owner);\n', '    uint256 count = _owners.length;\n', '    for (uint256 i = 0; i < count; i++)\n', '      Transfer (address (0), _owners [i], VIRTUAL_COUNT);\n', '  }\n', '\n', '  function kill () {\n', '    require (msg.sender == owner);\n', '    selfdestruct (owner);\n', '  }\n', '\n', '  function virtualBalanceOf (address _owner)\n', '  internal constant returns (uint256 _virtualBalance) {\n', '    return _owner.balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0;\n', '  }\n', '\n', '  address private owner;\n', '}']