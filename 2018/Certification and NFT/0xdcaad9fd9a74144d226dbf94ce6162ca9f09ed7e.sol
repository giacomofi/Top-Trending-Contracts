['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/// @title An optional contract that allows us to associate metadata to our cards.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersMetadata {\n', '\n', '  /// @dev The base url for the API where we fetch the metadata.\n', '  ///   ex: https://us-central1-cryptostrikers-api.cloudfunctions.net/cards/\n', '  string public apiUrl;\n', '\n', '  constructor(string _apiUrl) public {\n', '    apiUrl = _apiUrl;\n', '  }\n', '\n', '  /// @dev Returns the API URL for a given token Id.\n', '  ///   ex: https://us-central1-cryptostrikers-api.cloudfunctions.net/cards/22\n', '  ///   Right now, this endpoint returns a JSON blob conforming to OpenSea&#39;s spec.\n', '  ///   see: https://docs.opensea.io/docs/2-adding-metadata\n', '  function tokenURI(uint256 _tokenId) external view returns (string) {\n', '    string memory _id = uint2str(_tokenId);\n', '    return strConcat(apiUrl, _id);\n', '  }\n', '\n', '  // String helpers below were taken from Oraclize.\n', '  // https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', '\n', '  function strConcat(string _a, string _b) internal pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    string memory ab = new string(_ba.length + _bb.length);\n', '    bytes memory bab = bytes(ab);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '    return string(bab);\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string) {\n', '    if (i == 0) return "0";\n', '    uint j = i;\n', '    uint len;\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '    bytes memory bstr = new bytes(len);\n', '    uint k = len - 1;\n', '    while (i != 0) {\n', '      bstr[k--] = byte(48 + i % 10);\n', '      i /= 10;\n', '    }\n', '    return string(bstr);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '   * @dev Guarantees msg.sender is owner of the given token\n', '   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '   */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '   * @param _tokenId uint256 ID of the token to validate\n', '   */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param _owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the owner of the specified token ID\n', '   * @param _tokenId uint256 ID of the token to query the owner of\n', '   * @return owner address currently marked as the owner of the given token ID\n', '   */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the specified token exists\n', '   * @param _tokenId uint256 ID of the token to query the existance of\n', '   * @return whether the token exists\n', '   */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Approves another address to transfer the given token ID\n', '   * @dev The zero address indicates there is no approved address.\n', '   * @dev There can only be one approved address per token at a given time.\n', '   * @dev Can only be called by the token owner or an approved operator.\n', '   * @param _to address to be approved for the given token ID\n', '   * @param _tokenId uint256 ID of the token to be approved\n', '   */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets or unsets the approval of a given operator\n', '   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '   * @param _to operator address to set the approval\n', '   * @param _approved representing the status of the approval to be set\n', '   */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    emit ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given token ID to another address\n', '   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    // solium-disable-next-line arg-overflow\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes data to send along with a safe transfer check\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    transferFrom(_from, _to, _tokenId);\n', '    // solium-disable-next-line arg-overflow\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to The address that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to clear current approval of a given token ID\n', '   * @dev Reverts if the given address is not indeed the owner of the token\n', '   * @param _owner owner of the token\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      emit Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to invoke `onERC721Received` on a target address\n', '   * @dev The call is not executed if the target address is not a contract\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _to target address that will receive the tokens\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes optional data to send along with the call\n', '   * @return whether the call correctly returned the expected magic value\n', '   */\n', '  function checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    returns (bool)\n', '  {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Token is ERC721, ERC721BasicToken {\n', '  // Token name\n', '  string internal name_;\n', '\n', '  // Token symbol\n', '  string internal symbol_;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) internal ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) internal ownedTokensIndex;\n', '\n', '  // Array with all token ids, used for enumeration\n', '  uint256[] internal allTokens;\n', '\n', '  // Mapping from token id to position in the allTokens array\n', '  mapping(uint256 => uint256) internal allTokensIndex;\n', '\n', '  // Optional mapping for token URIs\n', '  mapping(uint256 => string) internal tokenURIs;\n', '\n', '  /**\n', '   * @dev Constructor function\n', '   */\n', '  function ERC721Token(string _name, string _symbol) public {\n', '    name_ = _name;\n', '    symbol_ = _symbol;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token name\n', '   * @return string representing the token name\n', '   */\n', '  function name() public view returns (string) {\n', '    return name_;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token symbol\n', '   * @return string representing the token symbol\n', '   */\n', '  function symbol() public view returns (string) {\n', '    return symbol_;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an URI for a given token ID\n', '   * @dev Throws if the token ID does not exist. May return an empty string.\n', '   * @param _tokenId uint256 ID of the token to query\n', '   */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    require(exists(_tokenId));\n', '    return tokenURIs[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '   * @param _owner address owning the tokens list to be accessed\n', '   * @param _index uint256 representing the index to be accessed of the requested tokens list\n', '   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '   */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the total amount of tokens stored by the contract\n', '   * @return uint256 representing the total amount of tokens\n', '   */\n', '  function totalSupply() public view returns (uint256) {\n', '    return allTokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token ID at a given index of all the tokens in this contract\n', '   * @dev Reverts if the index is greater or equal to the total number of tokens\n', '   * @param _index uint256 representing the index to be accessed of the tokens list\n', '   * @return uint256 token ID at the given index of the tokens list\n', '   */\n', '  function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return allTokens[_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to set the token URI for a given token\n', '   * @dev Reverts if the token ID does not exist\n', '   * @param _tokenId uint256 ID of the token to set its URI\n', '   * @param _uri string URI to assign\n', '   */\n', '  function _setTokenURI(uint256 _tokenId, string _uri) internal {\n', '    require(exists(_tokenId));\n', '    tokenURIs[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    super.addTokenTo(_to, _tokenId);\n', '    uint256 length = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    super.removeTokenFrom(_from, _tokenId);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to address the beneficiary that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    super._mint(_to, _tokenId);\n', '\n', '    allTokensIndex[_tokenId] = allTokens.length;\n', '    allTokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _owner owner of the token to burn\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    // Clear metadata (if any)\n', '    if (bytes(tokenURIs[_tokenId]).length != 0) {\n', '      delete tokenURIs[_tokenId];\n', '    }\n', '\n', '    // Reorg all tokens array\n', '    uint256 tokenIndex = allTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = allTokens.length.sub(1);\n', '    uint256 lastToken = allTokens[lastTokenIndex];\n', '\n', '    allTokens[tokenIndex] = lastToken;\n', '    allTokens[lastTokenIndex] = 0;\n', '\n', '    allTokens.length--;\n', '    allTokensIndex[_tokenId] = 0;\n', '    allTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title The contract that manages all the players that appear in our game.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersPlayerList is Ownable {\n', '  // We only use playerIds in StrikersChecklist.sol (to\n', '  // indicate which player features on instances of a\n', '  // given ChecklistItem), and nowhere else in the app.\n', '  // While it&#39;s not explictly necessary for any of our\n', '  // contracts to know that playerId 0 corresponds to\n', '  // Lionel Messi, we think that it&#39;s nice to have\n', '  // a canonical source of truth for who the playerIds\n', '  // actually refer to. Storing strings (player names)\n', '  // is expensive, so we just use Events to prove that,\n', '  // at some point, we said a playerId represents a given person.\n', '\n', '  /// @dev The event we fire when we add a player.\n', '  event PlayerAdded(uint8 indexed id, string name);\n', '\n', '  /// @dev How many players we&#39;ve added so far\n', '  ///   (max 255, though we don&#39;t plan on getting close)\n', '  uint8 public playerCount;\n', '\n', '  /// @dev Here we add the players we are launching with on Day 1.\n', '  ///   Players are loosely ranked by things like FIFA ratings,\n', '  ///   number of Instagram followers, and opinions of CryptoStrikers\n', '  ///   team members. Feel free to yell at us on Twitter.\n', '  constructor() public {\n', '    addPlayer("Lionel Messi"); // 0\n', '    addPlayer("Cristiano Ronaldo"); // 1\n', '    addPlayer("Neymar"); // 2\n', '    addPlayer("Mohamed Salah"); // 3\n', '    addPlayer("Robert Lewandowski"); // 4\n', '    addPlayer("Kevin De Bruyne"); // 5\n', '    addPlayer("Luka Modrić"); // 6\n', '    addPlayer("Eden Hazard"); // 7\n', '    addPlayer("Sergio Ramos"); // 8\n', '    addPlayer("Toni Kroos"); // 9\n', '    addPlayer("Luis Su&#225;rez"); // 10\n', '    addPlayer("Harry Kane"); // 11\n', '    addPlayer("Sergio Ag&#252;ero"); // 12\n', '    addPlayer("Kylian Mbapp&#233;"); // 13\n', '    addPlayer("Gonzalo Higua&#237;n"); // 14\n', '    addPlayer("David de Gea"); // 15\n', '    addPlayer("Antoine Griezmann"); // 16\n', '    addPlayer("N&#39;Golo Kant&#233;"); // 17\n', '    addPlayer("Edinson Cavani"); // 18\n', '    addPlayer("Paul Pogba"); // 19\n', '    addPlayer("Isco"); // 20\n', '    addPlayer("Marcelo"); // 21\n', '    addPlayer("Manuel Neuer"); // 22\n', '    addPlayer("Dries Mertens"); // 23\n', '    addPlayer("James Rodr&#237;guez"); // 24\n', '    addPlayer("Paulo Dybala"); // 25\n', '    addPlayer("Christian Eriksen"); // 26\n', '    addPlayer("David Silva"); // 27\n', '    addPlayer("Gabriel Jesus"); // 28\n', '    addPlayer("Thiago"); // 29\n', '    addPlayer("Thibaut Courtois"); // 30\n', '    addPlayer("Philippe Coutinho"); // 31\n', '    addPlayer("Andr&#233;s Iniesta"); // 32\n', '    addPlayer("Casemiro"); // 33\n', '    addPlayer("Romelu Lukaku"); // 34\n', '    addPlayer("Gerard Piqu&#233;"); // 35\n', '    addPlayer("Mats Hummels"); // 36\n', '    addPlayer("Diego God&#237;n"); // 37\n', '    addPlayer("Mesut &#214;zil"); // 38\n', '    addPlayer("Son Heung-min"); // 39\n', '    addPlayer("Raheem Sterling"); // 40\n', '    addPlayer("Hugo Lloris"); // 41\n', '    addPlayer("Radamel Falcao"); // 42\n', '    addPlayer("Ivan Rakitić"); // 43\n', '    addPlayer("Leroy San&#233;"); // 44\n', '    addPlayer("Roberto Firmino"); // 45\n', '    addPlayer("Sadio Man&#233;"); // 46\n', '    addPlayer("Thomas M&#252;ller"); // 47\n', '    addPlayer("Dele Alli"); // 48\n', '    addPlayer("Keylor Navas"); // 49\n', '    addPlayer("Thiago Silva"); // 50\n', '    addPlayer("Rapha&#235;l Varane"); // 51\n', '    addPlayer("&#193;ngel Di Mar&#237;a"); // 52\n', '    addPlayer("Jordi Alba"); // 53\n', '    addPlayer("Medhi Benatia"); // 54\n', '    addPlayer("Timo Werner"); // 55\n', '    addPlayer("Gylfi Sigur&#240;sson"); // 56\n', '    addPlayer("Nemanja Matić"); // 57\n', '    addPlayer("Kalidou Koulibaly"); // 58\n', '    addPlayer("Bernardo Silva"); // 59\n', '    addPlayer("Vincent Kompany"); // 60\n', '    addPlayer("Jo&#227;o Moutinho"); // 61\n', '    addPlayer("Toby Alderweireld"); // 62\n', '    addPlayer("Emil Forsberg"); // 63\n', '    addPlayer("Mario Mandžukić"); // 64\n', '    addPlayer("Sergej Milinković-Savić"); // 65\n', '    addPlayer("Shinji Kagawa"); // 66\n', '    addPlayer("Granit Xhaka"); // 67\n', '    addPlayer("Andreas Christensen"); // 68\n', '    addPlayer("Piotr Zieliński"); // 69\n', '    addPlayer("Fyodor Smolov"); // 70\n', '    addPlayer("Xherdan Shaqiri"); // 71\n', '    addPlayer("Marcus Rashford"); // 72\n', '    addPlayer("Javier Hern&#225;ndez"); // 73\n', '    addPlayer("Hirving Lozano"); // 74\n', '    addPlayer("Hakim Ziyech"); // 75\n', '    addPlayer("Victor Moses"); // 76\n', '    addPlayer("Jefferson Farf&#225;n"); // 77\n', '    addPlayer("Mohamed Elneny"); // 78\n', '    addPlayer("Marcus Berg"); // 79\n', '    addPlayer("Guillermo Ochoa"); // 80\n', '    addPlayer("Igor Akinfeev"); // 81\n', '    addPlayer("Sardar Azmoun"); // 82\n', '    addPlayer("Christian Cueva"); // 83\n', '    addPlayer("Wahbi Khazri"); // 84\n', '    addPlayer("Keisuke Honda"); // 85\n', '    addPlayer("Tim Cahill"); // 86\n', '    addPlayer("John Obi Mikel"); // 87\n', '    addPlayer("Ki Sung-yueng"); // 88\n', '    addPlayer("Bryan Ruiz"); // 89\n', '    addPlayer("Maya Yoshida"); // 90\n', '    addPlayer("Nawaf Al Abed"); // 91\n', '    addPlayer("Lee Chung-yong"); // 92\n', '    addPlayer("Gabriel G&#243;mez"); // 93\n', '    addPlayer("Na&#239;m Sliti"); // 94\n', '    addPlayer("Reza Ghoochannejhad"); // 95\n', '    addPlayer("Mile Jedinak"); // 96\n', '    addPlayer("Mohammad Al-Sahlawi"); // 97\n', '    addPlayer("Aron Gunnarsson"); // 98\n', '    addPlayer("Blas P&#233;rez"); // 99\n', '    addPlayer("Dani Alves"); // 100\n', '    addPlayer("Zlatan Ibrahimović"); // 101\n', '  }\n', '\n', '  /// @dev Fires an event, proving that we said a player corresponds to a given ID.\n', '  /// @param _name The name of the player we are adding.\n', '  function addPlayer(string _name) public onlyOwner {\n', '    require(playerCount < 255, "You&#39;ve already added the maximum amount of players.");\n', '    emit PlayerAdded(playerCount, _name);\n', '    playerCount++;\n', '  }\n', '}\n', '\n', '\n', '/// @title The contract that manages checklist items, sets, and rarity tiers.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersChecklist is StrikersPlayerList {\n', '  // High level overview of everything going on in this contract:\n', '  //\n', '  // ChecklistItem is the parent class to Card and has 3 properties:\n', '  //  - uint8 checklistId (000 to 255)\n', '  //  - uint8 playerId (see StrikersPlayerList.sol)\n', '  //  - RarityTier tier (more info below)\n', '  //\n', '  // Two things to note: the checklistId is not explicitly stored\n', '  // on the checklistItem struct, and it&#39;s composed of two parts.\n', '  // (For the following, assume it is left padded with zeros to reach\n', '  // three digits, such that checklistId 0 becomes 000)\n', '  //  - the first digit represents the setId\n', '  //      * 0 = Originals Set\n', '  //      * 1 = Iconics Set\n', '  //      * 2 = Unreleased Set\n', '  //  - the last two digits represent its index in the appropriate set arary\n', '  //\n', '  //  For example, checklist ID 100 would represent fhe first checklist item\n', '  //  in the iconicChecklistItems array (first digit = 1 = Iconics Set, last two\n', '  //  digits = 00 = first index of array)\n', '  //\n', '  // Because checklistId is represented as a uint8 throughout the app, the highest\n', '  // value it can take is 255, which means we can&#39;t add more than 56 items to our\n', '  // Unreleased Set&#39;s unreleasedChecklistItems array (setId 2). Also, once we&#39;ve initialized\n', '  // this contract, it&#39;s impossible for us to add more checklist items to the Originals\n', '  // and Iconics set -- what you see here is what you get.\n', '  //\n', '  // Simple enough right?\n', '\n', '  /// @dev We initialize this contract with so much data that we have\n', '  ///   to stage it in 4 different steps, ~33 checklist items at a time.\n', '  enum DeployStep {\n', '    WaitingForStepOne,\n', '    WaitingForStepTwo,\n', '    WaitingForStepThree,\n', '    WaitingForStepFour,\n', '    DoneInitialDeploy\n', '  }\n', '\n', '  /// @dev Enum containing all our rarity tiers, just because\n', '  ///   it&#39;s cleaner dealing with these values than with uint8s.\n', '  enum RarityTier {\n', '    IconicReferral,\n', '    IconicInsert,\n', '    Diamond,\n', '    Gold,\n', '    Silver,\n', '    Bronze\n', '  }\n', '\n', '  /// @dev A lookup table indicating how limited the cards\n', '  ///   in each tier are. If this value is 0, it means\n', '  ///   that cards of this rarity tier are unlimited,\n', '  ///   which is only the case for the 8 Iconics cards\n', '  ///   we give away as part of our referral program.\n', '  uint16[] public tierLimits = [\n', '    0,    // Iconic - Referral Bonus (uncapped)\n', '    100,  // Iconic Inserts ("Card of the Day")\n', '    1000, // Diamond\n', '    1664, // Gold\n', '    3328, // Silver\n', '    4352  // Bronze\n', '  ];\n', '\n', '  /// @dev ChecklistItem is essentially the parent class to Card.\n', '  ///   It represents a given superclass of cards (eg Originals Messi),\n', '  ///   and then each Card is an instance of this ChecklistItem, with\n', '  ///   its own serial number, mint date, etc.\n', '  struct ChecklistItem {\n', '    uint8 playerId;\n', '    RarityTier tier;\n', '  }\n', '\n', '  /// @dev The deploy step we&#39;re at. Defaults to WaitingForStepOne.\n', '  DeployStep public deployStep;\n', '\n', '  /// @dev Array containing all the Originals checklist items (000 - 099)\n', '  ChecklistItem[] public originalChecklistItems;\n', '\n', '  /// @dev Array containing all the Iconics checklist items (100 - 131)\n', '  ChecklistItem[] public iconicChecklistItems;\n', '\n', '  /// @dev Array containing all the unreleased checklist items (200 - 255 max)\n', '  ChecklistItem[] public unreleasedChecklistItems;\n', '\n', '  /// @dev Internal function to add a checklist item to the Originals set.\n', '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', '  /// @param _tier This checklist item&#39;s rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n', '  function _addOriginalChecklistItem(uint8 _playerId, RarityTier _tier) internal {\n', '    originalChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', '  /// @dev Internal function to add a checklist item to the Iconics set.\n', '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', '  /// @param _tier This checklist item&#39;s rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n', '  function _addIconicChecklistItem(uint8 _playerId, RarityTier _tier) internal {\n', '    iconicChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', '  /// @dev External function to add a checklist item to our mystery set.\n', '  ///   Must have completed initial deploy, and can&#39;t add more than 56 items (because checklistId is a uint8).\n', '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', '  /// @param _tier This checklist item&#39;s rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n', '  function addUnreleasedChecklistItem(uint8 _playerId, RarityTier _tier) external onlyOwner {\n', '    require(deployStep == DeployStep.DoneInitialDeploy, "Finish deploying the Originals and Iconics sets first.");\n', '    require(unreleasedCount() < 56, "You can&#39;t add any more checklist items.");\n', '    require(_playerId < playerCount, "This player doesn&#39;t exist in our player list.");\n', '    unreleasedChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', '  /// @dev Returns how many Original checklist items we&#39;ve added.\n', '  function originalsCount() external view returns (uint256) {\n', '    return originalChecklistItems.length;\n', '  }\n', '\n', '  /// @dev Returns how many Iconic checklist items we&#39;ve added.\n', '  function iconicsCount() public view returns (uint256) {\n', '    return iconicChecklistItems.length;\n', '  }\n', '\n', '  /// @dev Returns how many Unreleased checklist items we&#39;ve added.\n', '  function unreleasedCount() public view returns (uint256) {\n', '    return unreleasedChecklistItems.length;\n', '  }\n', '\n', '  // In the next four functions, we initialize this contract with our\n', '  // 132 initial checklist items (100 Originals, 32 Iconics). Because\n', '  // of how much data we need to store, it has to be broken up into\n', '  // four different function calls, which need to be called in sequence.\n', '  // The ordering of the checklist items we add determines their\n', '  // checklist ID, which is left-padded in our frontend to be a\n', '  // 3-digit identifier where the first digit is the setId and the last\n', '  // 2 digits represents the checklist items index in the appropriate ___ChecklistItems array.\n', '  // For example, Originals Messi is the first item for set ID 0, and this\n', '  // is displayed as #000 throughout the app. Our Card struct declare its\n', '  // checklistId property as uint8, so we have\n', '  // to be mindful that we can only have 256 total checklist items.\n', '\n', '  /// @dev Deploys Originals #000 through #032.\n', '  function deployStepOne() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepOne, "You&#39;re not following the steps in order...");\n', '\n', '    /* ORIGINALS - DIAMOND */\n', '    _addOriginalChecklistItem(0, RarityTier.Diamond); // 000 Messi\n', '    _addOriginalChecklistItem(1, RarityTier.Diamond); // 001 Ronaldo\n', '    _addOriginalChecklistItem(2, RarityTier.Diamond); // 002 Neymar\n', '    _addOriginalChecklistItem(3, RarityTier.Diamond); // 003 Salah\n', '\n', '    /* ORIGINALS - GOLD */\n', '    _addOriginalChecklistItem(4, RarityTier.Gold); // 004 Lewandowski\n', '    _addOriginalChecklistItem(5, RarityTier.Gold); // 005 De Bruyne\n', '    _addOriginalChecklistItem(6, RarityTier.Gold); // 006 Modrić\n', '    _addOriginalChecklistItem(7, RarityTier.Gold); // 007 Hazard\n', '    _addOriginalChecklistItem(8, RarityTier.Gold); // 008 Ramos\n', '    _addOriginalChecklistItem(9, RarityTier.Gold); // 009 Kroos\n', '    _addOriginalChecklistItem(10, RarityTier.Gold); // 010 Su&#225;rez\n', '    _addOriginalChecklistItem(11, RarityTier.Gold); // 011 Kane\n', '    _addOriginalChecklistItem(12, RarityTier.Gold); // 012 Ag&#252;ero\n', '    _addOriginalChecklistItem(13, RarityTier.Gold); // 013 Mbapp&#233;\n', '    _addOriginalChecklistItem(14, RarityTier.Gold); // 014 Higua&#237;n\n', '    _addOriginalChecklistItem(15, RarityTier.Gold); // 015 de Gea\n', '    _addOriginalChecklistItem(16, RarityTier.Gold); // 016 Griezmann\n', '    _addOriginalChecklistItem(17, RarityTier.Gold); // 017 Kant&#233;\n', '    _addOriginalChecklistItem(18, RarityTier.Gold); // 018 Cavani\n', '    _addOriginalChecklistItem(19, RarityTier.Gold); // 019 Pogba\n', '\n', '    /* ORIGINALS - SILVER (020 to 032) */\n', '    _addOriginalChecklistItem(20, RarityTier.Silver); // 020 Isco\n', '    _addOriginalChecklistItem(21, RarityTier.Silver); // 021 Marcelo\n', '    _addOriginalChecklistItem(22, RarityTier.Silver); // 022 Neuer\n', '    _addOriginalChecklistItem(23, RarityTier.Silver); // 023 Mertens\n', '    _addOriginalChecklistItem(24, RarityTier.Silver); // 024 James\n', '    _addOriginalChecklistItem(25, RarityTier.Silver); // 025 Dybala\n', '    _addOriginalChecklistItem(26, RarityTier.Silver); // 026 Eriksen\n', '    _addOriginalChecklistItem(27, RarityTier.Silver); // 027 David Silva\n', '    _addOriginalChecklistItem(28, RarityTier.Silver); // 028 Gabriel Jesus\n', '    _addOriginalChecklistItem(29, RarityTier.Silver); // 029 Thiago\n', '    _addOriginalChecklistItem(30, RarityTier.Silver); // 030 Courtois\n', '    _addOriginalChecklistItem(31, RarityTier.Silver); // 031 Coutinho\n', '    _addOriginalChecklistItem(32, RarityTier.Silver); // 032 Iniesta\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepTwo;\n', '  }\n', '\n', '  /// @dev Deploys Originals #033 through #065.\n', '  function deployStepTwo() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepTwo, "You&#39;re not following the steps in order...");\n', '\n', '    /* ORIGINALS - SILVER (033 to 049) */\n', '    _addOriginalChecklistItem(33, RarityTier.Silver); // 033 Casemiro\n', '    _addOriginalChecklistItem(34, RarityTier.Silver); // 034 Lukaku\n', '    _addOriginalChecklistItem(35, RarityTier.Silver); // 035 Piqu&#233;\n', '    _addOriginalChecklistItem(36, RarityTier.Silver); // 036 Hummels\n', '    _addOriginalChecklistItem(37, RarityTier.Silver); // 037 God&#237;n\n', '    _addOriginalChecklistItem(38, RarityTier.Silver); // 038 &#214;zil\n', '    _addOriginalChecklistItem(39, RarityTier.Silver); // 039 Son\n', '    _addOriginalChecklistItem(40, RarityTier.Silver); // 040 Sterling\n', '    _addOriginalChecklistItem(41, RarityTier.Silver); // 041 Lloris\n', '    _addOriginalChecklistItem(42, RarityTier.Silver); // 042 Falcao\n', '    _addOriginalChecklistItem(43, RarityTier.Silver); // 043 Rakitić\n', '    _addOriginalChecklistItem(44, RarityTier.Silver); // 044 San&#233;\n', '    _addOriginalChecklistItem(45, RarityTier.Silver); // 045 Firmino\n', '    _addOriginalChecklistItem(46, RarityTier.Silver); // 046 Man&#233;\n', '    _addOriginalChecklistItem(47, RarityTier.Silver); // 047 M&#252;ller\n', '    _addOriginalChecklistItem(48, RarityTier.Silver); // 048 Alli\n', '    _addOriginalChecklistItem(49, RarityTier.Silver); // 049 Navas\n', '\n', '    /* ORIGINALS - BRONZE (050 to 065) */\n', '    _addOriginalChecklistItem(50, RarityTier.Bronze); // 050 Thiago Silva\n', '    _addOriginalChecklistItem(51, RarityTier.Bronze); // 051 Varane\n', '    _addOriginalChecklistItem(52, RarityTier.Bronze); // 052 Di Mar&#237;a\n', '    _addOriginalChecklistItem(53, RarityTier.Bronze); // 053 Alba\n', '    _addOriginalChecklistItem(54, RarityTier.Bronze); // 054 Benatia\n', '    _addOriginalChecklistItem(55, RarityTier.Bronze); // 055 Werner\n', '    _addOriginalChecklistItem(56, RarityTier.Bronze); // 056 Sigur&#240;sson\n', '    _addOriginalChecklistItem(57, RarityTier.Bronze); // 057 Matić\n', '    _addOriginalChecklistItem(58, RarityTier.Bronze); // 058 Koulibaly\n', '    _addOriginalChecklistItem(59, RarityTier.Bronze); // 059 Bernardo Silva\n', '    _addOriginalChecklistItem(60, RarityTier.Bronze); // 060 Kompany\n', '    _addOriginalChecklistItem(61, RarityTier.Bronze); // 061 Moutinho\n', '    _addOriginalChecklistItem(62, RarityTier.Bronze); // 062 Alderweireld\n', '    _addOriginalChecklistItem(63, RarityTier.Bronze); // 063 Forsberg\n', '    _addOriginalChecklistItem(64, RarityTier.Bronze); // 064 Mandžukić\n', '    _addOriginalChecklistItem(65, RarityTier.Bronze); // 065 Milinković-Savić\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepThree;\n', '  }\n', '\n', '  /// @dev Deploys Originals #066 through #099.\n', '  function deployStepThree() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepThree, "You&#39;re not following the steps in order...");\n', '\n', '    /* ORIGINALS - BRONZE (066 to 099) */\n', '    _addOriginalChecklistItem(66, RarityTier.Bronze); // 066 Kagawa\n', '    _addOriginalChecklistItem(67, RarityTier.Bronze); // 067 Xhaka\n', '    _addOriginalChecklistItem(68, RarityTier.Bronze); // 068 Christensen\n', '    _addOriginalChecklistItem(69, RarityTier.Bronze); // 069 Zieliński\n', '    _addOriginalChecklistItem(70, RarityTier.Bronze); // 070 Smolov\n', '    _addOriginalChecklistItem(71, RarityTier.Bronze); // 071 Shaqiri\n', '    _addOriginalChecklistItem(72, RarityTier.Bronze); // 072 Rashford\n', '    _addOriginalChecklistItem(73, RarityTier.Bronze); // 073 Hern&#225;ndez\n', '    _addOriginalChecklistItem(74, RarityTier.Bronze); // 074 Lozano\n', '    _addOriginalChecklistItem(75, RarityTier.Bronze); // 075 Ziyech\n', '    _addOriginalChecklistItem(76, RarityTier.Bronze); // 076 Moses\n', '    _addOriginalChecklistItem(77, RarityTier.Bronze); // 077 Farf&#225;n\n', '    _addOriginalChecklistItem(78, RarityTier.Bronze); // 078 Elneny\n', '    _addOriginalChecklistItem(79, RarityTier.Bronze); // 079 Berg\n', '    _addOriginalChecklistItem(80, RarityTier.Bronze); // 080 Ochoa\n', '    _addOriginalChecklistItem(81, RarityTier.Bronze); // 081 Akinfeev\n', '    _addOriginalChecklistItem(82, RarityTier.Bronze); // 082 Azmoun\n', '    _addOriginalChecklistItem(83, RarityTier.Bronze); // 083 Cueva\n', '    _addOriginalChecklistItem(84, RarityTier.Bronze); // 084 Khazri\n', '    _addOriginalChecklistItem(85, RarityTier.Bronze); // 085 Honda\n', '    _addOriginalChecklistItem(86, RarityTier.Bronze); // 086 Cahill\n', '    _addOriginalChecklistItem(87, RarityTier.Bronze); // 087 Mikel\n', '    _addOriginalChecklistItem(88, RarityTier.Bronze); // 088 Sung-yueng\n', '    _addOriginalChecklistItem(89, RarityTier.Bronze); // 089 Ruiz\n', '    _addOriginalChecklistItem(90, RarityTier.Bronze); // 090 Yoshida\n', '    _addOriginalChecklistItem(91, RarityTier.Bronze); // 091 Al Abed\n', '    _addOriginalChecklistItem(92, RarityTier.Bronze); // 092 Chung-yong\n', '    _addOriginalChecklistItem(93, RarityTier.Bronze); // 093 G&#243;mez\n', '    _addOriginalChecklistItem(94, RarityTier.Bronze); // 094 Sliti\n', '    _addOriginalChecklistItem(95, RarityTier.Bronze); // 095 Ghoochannejhad\n', '    _addOriginalChecklistItem(96, RarityTier.Bronze); // 096 Jedinak\n', '    _addOriginalChecklistItem(97, RarityTier.Bronze); // 097 Al-Sahlawi\n', '    _addOriginalChecklistItem(98, RarityTier.Bronze); // 098 Gunnarsson\n', '    _addOriginalChecklistItem(99, RarityTier.Bronze); // 099 P&#233;rez\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepFour;\n', '  }\n', '\n', '  /// @dev Deploys all Iconics and marks the deploy as complete!\n', '  function deployStepFour() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepFour, "You&#39;re not following the steps in order...");\n', '\n', '    /* ICONICS */\n', '    _addIconicChecklistItem(0, RarityTier.IconicInsert); // 100 Messi\n', '    _addIconicChecklistItem(1, RarityTier.IconicInsert); // 101 Ronaldo\n', '    _addIconicChecklistItem(2, RarityTier.IconicInsert); // 102 Neymar\n', '    _addIconicChecklistItem(3, RarityTier.IconicInsert); // 103 Salah\n', '    _addIconicChecklistItem(4, RarityTier.IconicInsert); // 104 Lewandowski\n', '    _addIconicChecklistItem(5, RarityTier.IconicInsert); // 105 De Bruyne\n', '    _addIconicChecklistItem(6, RarityTier.IconicInsert); // 106 Modrić\n', '    _addIconicChecklistItem(7, RarityTier.IconicInsert); // 107 Hazard\n', '    _addIconicChecklistItem(8, RarityTier.IconicInsert); // 108 Ramos\n', '    _addIconicChecklistItem(9, RarityTier.IconicInsert); // 109 Kroos\n', '    _addIconicChecklistItem(10, RarityTier.IconicInsert); // 110 Su&#225;rez\n', '    _addIconicChecklistItem(11, RarityTier.IconicInsert); // 111 Kane\n', '    _addIconicChecklistItem(12, RarityTier.IconicInsert); // 112 Ag&#252;ero\n', '    _addIconicChecklistItem(15, RarityTier.IconicInsert); // 113 de Gea\n', '    _addIconicChecklistItem(16, RarityTier.IconicInsert); // 114 Griezmann\n', '    _addIconicChecklistItem(17, RarityTier.IconicReferral); // 115 Kant&#233;\n', '    _addIconicChecklistItem(18, RarityTier.IconicReferral); // 116 Cavani\n', '    _addIconicChecklistItem(19, RarityTier.IconicInsert); // 117 Pogba\n', '    _addIconicChecklistItem(21, RarityTier.IconicInsert); // 118 Marcelo\n', '    _addIconicChecklistItem(24, RarityTier.IconicInsert); // 119 James\n', '    _addIconicChecklistItem(26, RarityTier.IconicInsert); // 120 Eriksen\n', '    _addIconicChecklistItem(29, RarityTier.IconicReferral); // 121 Thiago\n', '    _addIconicChecklistItem(36, RarityTier.IconicReferral); // 122 Hummels\n', '    _addIconicChecklistItem(38, RarityTier.IconicReferral); // 123 &#214;zil\n', '    _addIconicChecklistItem(39, RarityTier.IconicInsert); // 124 Son\n', '    _addIconicChecklistItem(46, RarityTier.IconicInsert); // 125 Man&#233;\n', '    _addIconicChecklistItem(48, RarityTier.IconicInsert); // 126 Alli\n', '    _addIconicChecklistItem(49, RarityTier.IconicReferral); // 127 Navas\n', '    _addIconicChecklistItem(73, RarityTier.IconicInsert); // 128 Hern&#225;ndez\n', '    _addIconicChecklistItem(85, RarityTier.IconicInsert); // 129 Honda\n', '    _addIconicChecklistItem(100, RarityTier.IconicReferral); // 130 Alves\n', '    _addIconicChecklistItem(101, RarityTier.IconicReferral); // 131 Zlatan\n', '\n', '    // Mark the initial deploy as complete.\n', '    deployStep = DeployStep.DoneInitialDeploy;\n', '  }\n', '\n', '  /// @dev Returns the mint limit for a given checklist item, based on its tier.\n', '  /// @param _checklistId Which checklist item we need to get the limit for.\n', '  /// @return How much of this checklist item we are allowed to mint.\n', '  function limitForChecklistId(uint8 _checklistId) external view returns (uint16) {\n', '    RarityTier rarityTier;\n', '    uint8 index;\n', '    if (_checklistId < 100) { // Originals = #000 to #099\n', '      rarityTier = originalChecklistItems[_checklistId].tier;\n', '    } else if (_checklistId < 200) { // Iconics = #100 to #131\n', '      index = _checklistId - 100;\n', '      require(index < iconicsCount(), "This Iconics checklist item doesn&#39;t exist.");\n', '      rarityTier = iconicChecklistItems[index].tier;\n', '    } else { // Unreleased = #200 to max #255\n', '      index = _checklistId - 200;\n', '      require(index < unreleasedCount(), "This Unreleased checklist item doesn&#39;t exist.");\n', '      rarityTier = unreleasedChecklistItems[index].tier;\n', '    }\n', '    return tierLimits[uint8(rarityTier)];\n', '  }\n', '}\n', '\n', '\n', '/// @title Base contract for CryptoStrikers. Defines what a card is and how to mint one.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersBase is ERC721Token("CryptoStrikers", "STRK") {\n', '\n', '  /// @dev Emit this event whenever we mint a new card (see _mintCard below)\n', '  event CardMinted(uint256 cardId);\n', '\n', '  /// @dev The struct representing the game&#39;s main object, a sports trading card.\n', '  struct Card {\n', '    // The timestamp at which this card was minted.\n', '    // With uint32 we are good until 2106, by which point we will have not minted\n', '    // a card in like, 88 years.\n', '    uint32 mintTime;\n', '\n', '    // The checklist item represented by this card. See StrikersChecklist.sol for more info.\n', '    uint8 checklistId;\n', '\n', '    // Cards for a given player have a serial number, which gets\n', '    // incremented in sequence. For example, if we mint 1000 of a card,\n', '    // the third one to be minted has serialNumber = 3 (out of 1000).\n', '    uint16 serialNumber;\n', '  }\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev All the cards that have been minted, indexed by cardId.\n', '  Card[] public cards;\n', '\n', '  /// @dev Keeps track of how many cards we have minted for a given checklist item\n', '  ///   to make sure we don&#39;t go over the limit for it.\n', '  ///   NB: uint16 has a capacity of 65,535, but we are not minting more than\n', '  ///   4,352 of any given checklist item.\n', '  mapping (uint8 => uint16) public mintedCountForChecklistId;\n', '\n', '  /// @dev A reference to our checklist contract, which contains all the minting limits.\n', '  StrikersChecklist public strikersChecklist;\n', '\n', '  /*** FUNCTIONS ***/\n', '\n', '  /// @dev For a given owner, returns two arrays. The first contains the IDs of every card owned\n', '  ///   by this address. The second returns the corresponding checklist ID for each of these cards.\n', '  ///   There are a few places we need this info in the web app and short of being able to return an\n', '  ///   actual array of Cards, this is the best solution we could come up with...\n', '  function cardAndChecklistIdsForOwner(address _owner) external view returns (uint256[], uint8[]) {\n', '    uint256[] memory cardIds = ownedTokens[_owner];\n', '    uint256 cardCount = cardIds.length;\n', '    uint8[] memory checklistIds = new uint8[](cardCount);\n', '\n', '    for (uint256 i = 0; i < cardCount; i++) {\n', '      uint256 cardId = cardIds[i];\n', '      checklistIds[i] = cards[cardId].checklistId;\n', '    }\n', '\n', '    return (cardIds, checklistIds);\n', '  }\n', '\n', '  /// @dev An internal method that creates a new card and stores it.\n', '  ///  Emits both a CardMinted and a Transfer event.\n', '  /// @param _checklistId The ID of the checklistItem represented by the card (see Checklist.sol)\n', '  /// @param _owner The card&#39;s first owner!\n', '  function _mintCard(\n', '    uint8 _checklistId,\n', '    address _owner\n', '  )\n', '    internal\n', '    returns (uint256)\n', '  {\n', '    uint16 mintLimit = strikersChecklist.limitForChecklistId(_checklistId);\n', '    require(mintLimit == 0 || mintedCountForChecklistId[_checklistId] < mintLimit, "Can&#39;t mint any more of this card!");\n', '    uint16 serialNumber = ++mintedCountForChecklistId[_checklistId];\n', '    Card memory newCard = Card({\n', '      mintTime: uint32(now),\n', '      checklistId: _checklistId,\n', '      serialNumber: serialNumber\n', '    });\n', '    uint256 newCardId = cards.push(newCard) - 1;\n', '    emit CardMinted(newCardId);\n', '    _mint(_owner, newCardId);\n', '    return newCardId;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '/// @title The contract that exposes minting functions to the outside world and limits who can call them.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersMinting is StrikersBase, Pausable {\n', '\n', '  /// @dev Emit this when we decide to no longer mint a given checklist ID.\n', '  event PulledFromCirculation(uint8 checklistId);\n', '\n', '  /// @dev If the value for a checklistId is true, we can no longer mint it.\n', '  mapping (uint8 => bool) public outOfCirculation;\n', '\n', '  /// @dev The address of the contract that manages the pack sale.\n', '  address public packSaleAddress;\n', '\n', '  /// @dev Only the owner can update the address of the pack sale contract.\n', '  /// @param _address The address of the new StrikersPackSale contract.\n', '  function setPackSaleAddress(address _address) external onlyOwner {\n', '    packSaleAddress = _address;\n', '  }\n', '\n', '  /// @dev Allows the contract at packSaleAddress to mint cards.\n', '  /// @param _checklistId The checklist item represented by this new card.\n', '  /// @param _owner The card&#39;s first owner!\n', '  /// @return The new card&#39;s ID.\n', '  function mintPackSaleCard(uint8 _checklistId, address _owner) external returns (uint256) {\n', '    require(msg.sender == packSaleAddress, "Only the pack sale contract can mint here.");\n', '    require(!outOfCirculation[_checklistId], "Can&#39;t mint any more of this checklist item...");\n', '    return _mintCard(_checklistId, _owner);\n', '  }\n', '\n', '  /// @dev Allows the owner to mint cards from our Unreleased Set.\n', '  /// @param _checklistId The checklist item represented by this new card. Must be >= 200.\n', '  /// @param _owner The card&#39;s first owner!\n', '  function mintUnreleasedCard(uint8 _checklistId, address _owner) external onlyOwner {\n', '    require(_checklistId >= 200, "You can only use this to mint unreleased cards.");\n', '    require(!outOfCirculation[_checklistId], "Can&#39;t mint any more of this checklist item...");\n', '    _mintCard(_checklistId, _owner);\n', '  }\n', '\n', '  /// @dev Allows the owner or the pack sale contract to prevent an Iconic or Unreleased card from ever being minted again.\n', '  /// @param _checklistId The Iconic or Unreleased card we want to remove from circulation.\n', '  function pullFromCirculation(uint8 _checklistId) external {\n', '    bool ownerOrPackSale = (msg.sender == owner) || (msg.sender == packSaleAddress);\n', '    require(ownerOrPackSale, "Only the owner or pack sale can take checklist items out of circulation.");\n', '    require(_checklistId >= 100, "This function is reserved for Iconics and Unreleased sets.");\n', '    outOfCirculation[_checklistId] = true;\n', '    emit PulledFromCirculation(_checklistId);\n', '  }\n', '}\n', '\n', '\n', '/// @title StrikersTrading - Allows users to trustlessly trade cards.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersTrading is StrikersMinting {\n', '\n', '  /// @dev Emitting this allows us to look up if a trade has been\n', '  ///   successfully filled, by who, and which cards were involved.\n', '  event TradeFilled(\n', '    bytes32 indexed tradeHash,\n', '    address indexed maker,\n', '    uint256 makerCardId,\n', '    address indexed taker,\n', '    uint256 takerCardId\n', '  );\n', '\n', '  /// @dev Emitting this allows us to look up if a trade has been cancelled.\n', '  event TradeCancelled(bytes32 indexed tradeHash, address indexed maker);\n', '\n', '  /// @dev All the possible states for a trade.\n', '  enum TradeState {\n', '    Valid,\n', '    Filled,\n', '    Cancelled\n', '  }\n', '\n', '  /// @dev Mapping of tradeHash => TradeState. Defaults to Valid.\n', '  mapping (bytes32 => TradeState) public tradeStates;\n', '\n', '  /// @dev A taker (someone who has received a signed trade hash)\n', '  ///   submits a cardId to this function and, if it satisfies\n', '  ///   the given criteria, the trade is executed.\n', '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', '  /// @param _taker The counterparty the maker wishes to trade with (if it&#39;s address(0), anybody can fill the trade!)\n', '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Originals John Smith").\n', '  ///                                If not, then it&#39;s a card ID (e.g. "Originals John Smith #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  /// @param _submittedCardId The card the taker is using to fill the trade. Must satisfy either the card or checklist ID\n', '  ///                         specified in _takerCardOrChecklistId.\n', '  /// @param _v ECDSA signature parameter v from the tradeHash signed by the maker.\n', '  /// @param _r ECDSA signature parameters r from the tradeHash signed by the maker.\n', '  /// @param _s ECDSA signature parameters s from the tradeHash signed by the maker.\n', '  function fillTrade(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt,\n', '    uint256 _submittedCardId,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s)\n', '    external\n', '    whenNotPaused\n', '  {\n', '    require(_maker != msg.sender, "You can&#39;t fill your own trade.");\n', '    require(_taker == address(0) || _taker == msg.sender, "You are not authorized to fill this trade.");\n', '\n', '    if (_taker == address(0)) {\n', '      // This trade is open to the public so we are requesting a checklistItem, rather than a specific card.\n', '      require(cards[_submittedCardId].checklistId == _takerCardOrChecklistId, "The card you submitted is not valid for this trade.");\n', '    } else {\n', '      // We are trading directly with another user and are requesting a specific card.\n', '      require(_submittedCardId == _takerCardOrChecklistId, "The card you submitted is not valid for this trade.");\n', '    }\n', '\n', '    bytes32 tradeHash = getTradeHash(\n', '      _maker,\n', '      _makerCardId,\n', '      _taker,\n', '      _takerCardOrChecklistId,\n', '      _salt\n', '    );\n', '\n', '    require(tradeStates[tradeHash] == TradeState.Valid, "This trade is no longer valid.");\n', '    require(isValidSignature(_maker, tradeHash, _v, _r, _s), "Invalid signature.");\n', '\n', '    tradeStates[tradeHash] = TradeState.Filled;\n', '\n', '    // For better UX, we assume that by signing the trade, the maker has given\n', '    // implicit approval for this token to be transferred. This saves us from an\n', '    // extra approval transaction...\n', '    tokenApprovals[_makerCardId] = msg.sender;\n', '\n', '    safeTransferFrom(_maker, msg.sender, _makerCardId);\n', '    safeTransferFrom(msg.sender, _maker, _submittedCardId);\n', '\n', '    emit TradeFilled(tradeHash, _maker, _makerCardId, msg.sender, _submittedCardId);\n', '  }\n', '\n', '  /// @dev Allows the maker to cancel a trade that hasn&#39;t been filled yet.\n', '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', '  /// @param _taker The counterparty the maker wishes to trade with (if it&#39;s address(0), anybody can fill the trade!)\n', '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Lionel Messi").\n', '  ///                                If not, then it&#39;s a card ID (e.g. "Lionel Messi #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  function cancelTrade(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt)\n', '    external\n', '  {\n', '    require(_maker == msg.sender, "Only the trade creator can cancel this trade.");\n', '\n', '    bytes32 tradeHash = getTradeHash(\n', '      _maker,\n', '      _makerCardId,\n', '      _taker,\n', '      _takerCardOrChecklistId,\n', '      _salt\n', '    );\n', '\n', '    require(tradeStates[tradeHash] == TradeState.Valid, "This trade has already been cancelled or filled.");\n', '    tradeStates[tradeHash] = TradeState.Cancelled;\n', '    emit TradeCancelled(tradeHash, _maker);\n', '  }\n', '\n', '  /// @dev Calculates Keccak-256 hash of a trade with specified parameters.\n', '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', '  /// @param _taker The counterparty the maker wishes to trade with (if it&#39;s address(0), anybody can fill the trade!)\n', '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Lionel Messi").\n', '  ///                                If not, then it&#39;s a card ID (e.g. "Lionel Messi #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  /// @return Keccak-256 hash of trade.\n', '  function getTradeHash(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt)\n', '    public\n', '    view\n', '    returns (bytes32)\n', '  {\n', '    // Hashing the contract address prevents a trade from being replayed on any new trade contract we deploy.\n', '    bytes memory packed = abi.encodePacked(this, _maker, _makerCardId, _taker, _takerCardOrChecklistId, _salt);\n', '    return keccak256(packed);\n', '  }\n', '\n', '  /// @dev Verifies that a signed trade is valid.\n', '  /// @param _signer Address of signer.\n', '  /// @param _tradeHash Signed Keccak-256 hash.\n', '  /// @param _v ECDSA signature parameter v.\n', '  /// @param _r ECDSA signature parameters r.\n', '  /// @param _s ECDSA signature parameters s.\n', '  /// @return Validity of signature.\n', '  function isValidSignature(\n', '    address _signer,\n', '    bytes32 _tradeHash,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s)\n', '    public\n', '    pure\n', '    returns (bool)\n', '  {\n', '    bytes memory packed = abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _tradeHash);\n', '    return _signer == ecrecover(keccak256(packed), _v, _r, _s);\n', '  }\n', '}\n', '\n', '\n', '/// @title The main, ERC721-compliant CryptoStrikers contract.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersCore is StrikersTrading {\n', '\n', '  /// @dev An external metadata contract that the owner can upgrade.\n', '  StrikersMetadata public strikersMetadata;\n', '\n', '  /// @dev We initialize the CryptoStrikers game with an immutable checklist that oversees card rarity.\n', '  constructor(address _checklistAddress) public {\n', '    strikersChecklist = StrikersChecklist(_checklistAddress);\n', '  }\n', '\n', '  /// @dev Allows the contract owner to update the metadata contract.\n', '  function setMetadataAddress(address _contractAddress) external onlyOwner {\n', '    strikersMetadata = StrikersMetadata(_contractAddress);\n', '  }\n', '\n', '  /// @dev If we&#39;ve set an external metadata contract, use that.\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    if (strikersMetadata == address(0)) {\n', '      return super.tokenURI(_tokenId);\n', '    }\n', '\n', '    require(exists(_tokenId), "Card does not exist.");\n', '    return strikersMetadata.tokenURI(_tokenId);\n', '  }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Basic {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) public view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function exists(uint256 _tokenId) public view returns (bool _exists);\n', '\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId) public view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/// @title An optional contract that allows us to associate metadata to our cards.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersMetadata {\n', '\n', '  /// @dev The base url for the API where we fetch the metadata.\n', '  ///   ex: https://us-central1-cryptostrikers-api.cloudfunctions.net/cards/\n', '  string public apiUrl;\n', '\n', '  constructor(string _apiUrl) public {\n', '    apiUrl = _apiUrl;\n', '  }\n', '\n', '  /// @dev Returns the API URL for a given token Id.\n', '  ///   ex: https://us-central1-cryptostrikers-api.cloudfunctions.net/cards/22\n', "  ///   Right now, this endpoint returns a JSON blob conforming to OpenSea's spec.\n", '  ///   see: https://docs.opensea.io/docs/2-adding-metadata\n', '  function tokenURI(uint256 _tokenId) external view returns (string) {\n', '    string memory _id = uint2str(_tokenId);\n', '    return strConcat(apiUrl, _id);\n', '  }\n', '\n', '  // String helpers below were taken from Oraclize.\n', '  // https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', '\n', '  function strConcat(string _a, string _b) internal pure returns (string) {\n', '    bytes memory _ba = bytes(_a);\n', '    bytes memory _bb = bytes(_b);\n', '    string memory ab = new string(_ba.length + _bb.length);\n', '    bytes memory bab = bytes(ab);\n', '    uint k = 0;\n', '    for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '    for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '    return string(bab);\n', '  }\n', '\n', '  function uint2str(uint i) internal pure returns (string) {\n', '    if (i == 0) return "0";\n', '    uint j = i;\n', '    uint len;\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '    bytes memory bstr = new bytes(len);\n', '    uint k = len - 1;\n', '    while (i != 0) {\n', '      bstr[k--] = byte(48 + i % 10);\n', '      i /= 10;\n', '    }\n', '    return string(bstr);\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC721Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic {\n', '  function name() public view returns (string _name);\n', '  function symbol() public view returns (string _symbol);\n', '  function tokenURI(uint256 _tokenId) public view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver {\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   *  as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721BasicToken is ERC721Basic {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  // Mapping from token ID to owner\n', '  mapping (uint256 => address) internal tokenOwner;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) internal tokenApprovals;\n', '\n', '  // Mapping from owner to number of owned token\n', '  mapping (address => uint256) internal ownedTokensCount;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) internal operatorApprovals;\n', '\n', '  /**\n', '   * @dev Guarantees msg.sender is owner of the given token\n', '   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n', '   */\n', '  modifier onlyOwnerOf(uint256 _tokenId) {\n', '    require(ownerOf(_tokenId) == msg.sender);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n', '   * @param _tokenId uint256 ID of the token to validate\n', '   */\n', '  modifier canTransfer(uint256 _tokenId) {\n', '    require(isApprovedOrOwner(msg.sender, _tokenId));\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the balance of the specified address\n', '   * @param _owner address to query the balance of\n', '   * @return uint256 representing the amount owned by the passed address\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    require(_owner != address(0));\n', '    return ownedTokensCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the owner of the specified token ID\n', '   * @param _tokenId uint256 ID of the token to query the owner of\n', '   * @return owner address currently marked as the owner of the given token ID\n', '   */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    address owner = tokenOwner[_tokenId];\n', '    require(owner != address(0));\n', '    return owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the specified token exists\n', '   * @param _tokenId uint256 ID of the token to query the existance of\n', '   * @return whether the token exists\n', '   */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    address owner = tokenOwner[_tokenId];\n', '    return owner != address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Approves another address to transfer the given token ID\n', '   * @dev The zero address indicates there is no approved address.\n', '   * @dev There can only be one approved address per token at a given time.\n', '   * @dev Can only be called by the token owner or an approved operator.\n', '   * @param _to address to be approved for the given token ID\n', '   * @param _tokenId uint256 ID of the token to be approved\n', '   */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    address owner = ownerOf(_tokenId);\n', '    require(_to != owner);\n', '    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n', '      tokenApprovals[_tokenId] = _to;\n', '      emit Approval(owner, _to, _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for a the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    return tokenApprovals[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Sets or unsets the approval of a given operator\n', '   * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '   * @param _to operator address to set the approval\n', '   * @param _approved representing the status of the approval to be set\n', '   */\n', '  function setApprovalForAll(address _to, bool _approved) public {\n', '    require(_to != msg.sender);\n', '    operatorApprovals[msg.sender][_to] = _approved;\n', '    emit ApprovalForAll(msg.sender, _to, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Tells whether an operator is approved by a given owner\n', '   * @param _owner owner address which you want to query the approval of\n', '   * @param _operator operator address which you want to query the approval of\n', '   * @return bool whether the given operator is approved by the given owner\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n', '    return operatorApprovals[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of a given token ID to another address\n', '   * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n', '    require(_from != address(0));\n', '    require(_to != address(0));\n', '\n', '    clearApproval(_from, _tokenId);\n', '    removeTokenFrom(_from, _tokenId);\n', '    addTokenTo(_to, _tokenId);\n', '\n', '    emit Transfer(_from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '  */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    // solium-disable-next-line arg-overflow\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Safely transfers the ownership of a given token ID to another address\n', '   * @dev If the target address is a contract, it must implement `onERC721Received`,\n', '   *  which is called upon a safe transfer, and return the magic value\n', '   *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise,\n', '   *  the transfer is reverted.\n', '   * @dev Requires the msg sender to be the owner, approved, or operator\n', '   * @param _from current owner of the token\n', '   * @param _to address to receive the ownership of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes data to send along with a safe transfer check\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    public\n', '    canTransfer(_tokenId)\n', '  {\n', '    transferFrom(_from, _to, _tokenId);\n', '    // solium-disable-next-line arg-overflow\n', '    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the given spender can transfer a given token ID\n', '   * @param _spender address of the spender to query\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @return bool whether the msg.sender is approved for the given token ID,\n', '   *  is an operator of the owner, or is the owner of the token\n', '   */\n', '  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n', '    address owner = ownerOf(_tokenId);\n', '    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to The address that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    require(_to != address(0));\n', '    addTokenTo(_to, _tokenId);\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    clearApproval(_owner, _tokenId);\n', '    removeTokenFrom(_owner, _tokenId);\n', '    emit Transfer(_owner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to clear current approval of a given token ID\n', '   * @dev Reverts if the given address is not indeed the owner of the token\n', '   * @param _owner owner of the token\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   */\n', '  function clearApproval(address _owner, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _owner);\n', '    if (tokenApprovals[_tokenId] != address(0)) {\n', '      tokenApprovals[_tokenId] = address(0);\n', '      emit Approval(_owner, address(0), _tokenId);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    require(tokenOwner[_tokenId] == address(0));\n', '    tokenOwner[_tokenId] = _to;\n', '    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    require(ownerOf(_tokenId) == _from);\n', '    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n', '    tokenOwner[_tokenId] = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to invoke `onERC721Received` on a target address\n', '   * @dev The call is not executed if the target address is not a contract\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _to target address that will receive the tokens\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes optional data to send along with the call\n', '   * @return whether the call correctly returned the expected magic value\n', '   */\n', '  function checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes _data\n', '  )\n', '    internal\n', '    returns (bool)\n', '  {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Token is ERC721, ERC721BasicToken {\n', '  // Token name\n', '  string internal name_;\n', '\n', '  // Token symbol\n', '  string internal symbol_;\n', '\n', '  // Mapping from owner to list of owned token IDs\n', '  mapping (address => uint256[]) internal ownedTokens;\n', '\n', '  // Mapping from token ID to index of the owner tokens list\n', '  mapping(uint256 => uint256) internal ownedTokensIndex;\n', '\n', '  // Array with all token ids, used for enumeration\n', '  uint256[] internal allTokens;\n', '\n', '  // Mapping from token id to position in the allTokens array\n', '  mapping(uint256 => uint256) internal allTokensIndex;\n', '\n', '  // Optional mapping for token URIs\n', '  mapping(uint256 => string) internal tokenURIs;\n', '\n', '  /**\n', '   * @dev Constructor function\n', '   */\n', '  function ERC721Token(string _name, string _symbol) public {\n', '    name_ = _name;\n', '    symbol_ = _symbol;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token name\n', '   * @return string representing the token name\n', '   */\n', '  function name() public view returns (string) {\n', '    return name_;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token symbol\n', '   * @return string representing the token symbol\n', '   */\n', '  function symbol() public view returns (string) {\n', '    return symbol_;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an URI for a given token ID\n', '   * @dev Throws if the token ID does not exist. May return an empty string.\n', '   * @param _tokenId uint256 ID of the token to query\n', '   */\n', '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    require(exists(_tokenId));\n', '    return tokenURIs[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '   * @param _owner address owning the tokens list to be accessed\n', '   * @param _index uint256 representing the index to be accessed of the requested tokens list\n', '   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '   */\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n', '    require(_index < balanceOf(_owner));\n', '    return ownedTokens[_owner][_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the total amount of tokens stored by the contract\n', '   * @return uint256 representing the total amount of tokens\n', '   */\n', '  function totalSupply() public view returns (uint256) {\n', '    return allTokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the token ID at a given index of all the tokens in this contract\n', '   * @dev Reverts if the index is greater or equal to the total number of tokens\n', '   * @param _index uint256 representing the index to be accessed of the tokens list\n', '   * @return uint256 token ID at the given index of the tokens list\n', '   */\n', '  function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return allTokens[_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to set the token URI for a given token\n', '   * @dev Reverts if the token ID does not exist\n', '   * @param _tokenId uint256 ID of the token to set its URI\n', '   * @param _uri string URI to assign\n', '   */\n', '  function _setTokenURI(uint256 _tokenId, string _uri) internal {\n', '    require(exists(_tokenId));\n', '    tokenURIs[_tokenId] = _uri;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to add a token ID to the list of a given address\n', '   * @param _to address representing the new owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '   */\n', '  function addTokenTo(address _to, uint256 _tokenId) internal {\n', '    super.addTokenTo(_to, _tokenId);\n', '    uint256 length = ownedTokens[_to].length;\n', '    ownedTokens[_to].push(_tokenId);\n', '    ownedTokensIndex[_tokenId] = length;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to remove a token ID from the list of a given address\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '   */\n', '  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n', '    super.removeTokenFrom(_from, _tokenId);\n', '\n', '    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n', '    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n', '\n', '    ownedTokens[_from][tokenIndex] = lastToken;\n', '    ownedTokens[_from][lastTokenIndex] = 0;\n', '    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n', '    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n', '    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n', '\n', '    ownedTokens[_from].length--;\n', '    ownedTokensIndex[_tokenId] = 0;\n', '    ownedTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to mint a new token\n', '   * @dev Reverts if the given token ID already exists\n', '   * @param _to address the beneficiary that will own the minted token\n', '   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n', '   */\n', '  function _mint(address _to, uint256 _tokenId) internal {\n', '    super._mint(_to, _tokenId);\n', '\n', '    allTokensIndex[_tokenId] = allTokens.length;\n', '    allTokens.push(_tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to burn a specific token\n', '   * @dev Reverts if the token does not exist\n', '   * @param _owner owner of the token to burn\n', '   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n', '   */\n', '  function _burn(address _owner, uint256 _tokenId) internal {\n', '    super._burn(_owner, _tokenId);\n', '\n', '    // Clear metadata (if any)\n', '    if (bytes(tokenURIs[_tokenId]).length != 0) {\n', '      delete tokenURIs[_tokenId];\n', '    }\n', '\n', '    // Reorg all tokens array\n', '    uint256 tokenIndex = allTokensIndex[_tokenId];\n', '    uint256 lastTokenIndex = allTokens.length.sub(1);\n', '    uint256 lastToken = allTokens[lastTokenIndex];\n', '\n', '    allTokens[tokenIndex] = lastToken;\n', '    allTokens[lastTokenIndex] = 0;\n', '\n', '    allTokens.length--;\n', '    allTokensIndex[_tokenId] = 0;\n', '    allTokensIndex[lastToken] = tokenIndex;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title The contract that manages all the players that appear in our game.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersPlayerList is Ownable {\n', '  // We only use playerIds in StrikersChecklist.sol (to\n', '  // indicate which player features on instances of a\n', '  // given ChecklistItem), and nowhere else in the app.\n', "  // While it's not explictly necessary for any of our\n", '  // contracts to know that playerId 0 corresponds to\n', "  // Lionel Messi, we think that it's nice to have\n", '  // a canonical source of truth for who the playerIds\n', '  // actually refer to. Storing strings (player names)\n', '  // is expensive, so we just use Events to prove that,\n', '  // at some point, we said a playerId represents a given person.\n', '\n', '  /// @dev The event we fire when we add a player.\n', '  event PlayerAdded(uint8 indexed id, string name);\n', '\n', "  /// @dev How many players we've added so far\n", "  ///   (max 255, though we don't plan on getting close)\n", '  uint8 public playerCount;\n', '\n', '  /// @dev Here we add the players we are launching with on Day 1.\n', '  ///   Players are loosely ranked by things like FIFA ratings,\n', '  ///   number of Instagram followers, and opinions of CryptoStrikers\n', '  ///   team members. Feel free to yell at us on Twitter.\n', '  constructor() public {\n', '    addPlayer("Lionel Messi"); // 0\n', '    addPlayer("Cristiano Ronaldo"); // 1\n', '    addPlayer("Neymar"); // 2\n', '    addPlayer("Mohamed Salah"); // 3\n', '    addPlayer("Robert Lewandowski"); // 4\n', '    addPlayer("Kevin De Bruyne"); // 5\n', '    addPlayer("Luka Modrić"); // 6\n', '    addPlayer("Eden Hazard"); // 7\n', '    addPlayer("Sergio Ramos"); // 8\n', '    addPlayer("Toni Kroos"); // 9\n', '    addPlayer("Luis Suárez"); // 10\n', '    addPlayer("Harry Kane"); // 11\n', '    addPlayer("Sergio Agüero"); // 12\n', '    addPlayer("Kylian Mbappé"); // 13\n', '    addPlayer("Gonzalo Higuaín"); // 14\n', '    addPlayer("David de Gea"); // 15\n', '    addPlayer("Antoine Griezmann"); // 16\n', '    addPlayer("N\'Golo Kanté"); // 17\n', '    addPlayer("Edinson Cavani"); // 18\n', '    addPlayer("Paul Pogba"); // 19\n', '    addPlayer("Isco"); // 20\n', '    addPlayer("Marcelo"); // 21\n', '    addPlayer("Manuel Neuer"); // 22\n', '    addPlayer("Dries Mertens"); // 23\n', '    addPlayer("James Rodríguez"); // 24\n', '    addPlayer("Paulo Dybala"); // 25\n', '    addPlayer("Christian Eriksen"); // 26\n', '    addPlayer("David Silva"); // 27\n', '    addPlayer("Gabriel Jesus"); // 28\n', '    addPlayer("Thiago"); // 29\n', '    addPlayer("Thibaut Courtois"); // 30\n', '    addPlayer("Philippe Coutinho"); // 31\n', '    addPlayer("Andrés Iniesta"); // 32\n', '    addPlayer("Casemiro"); // 33\n', '    addPlayer("Romelu Lukaku"); // 34\n', '    addPlayer("Gerard Piqué"); // 35\n', '    addPlayer("Mats Hummels"); // 36\n', '    addPlayer("Diego Godín"); // 37\n', '    addPlayer("Mesut Özil"); // 38\n', '    addPlayer("Son Heung-min"); // 39\n', '    addPlayer("Raheem Sterling"); // 40\n', '    addPlayer("Hugo Lloris"); // 41\n', '    addPlayer("Radamel Falcao"); // 42\n', '    addPlayer("Ivan Rakitić"); // 43\n', '    addPlayer("Leroy Sané"); // 44\n', '    addPlayer("Roberto Firmino"); // 45\n', '    addPlayer("Sadio Mané"); // 46\n', '    addPlayer("Thomas Müller"); // 47\n', '    addPlayer("Dele Alli"); // 48\n', '    addPlayer("Keylor Navas"); // 49\n', '    addPlayer("Thiago Silva"); // 50\n', '    addPlayer("Raphaël Varane"); // 51\n', '    addPlayer("Ángel Di María"); // 52\n', '    addPlayer("Jordi Alba"); // 53\n', '    addPlayer("Medhi Benatia"); // 54\n', '    addPlayer("Timo Werner"); // 55\n', '    addPlayer("Gylfi Sigurðsson"); // 56\n', '    addPlayer("Nemanja Matić"); // 57\n', '    addPlayer("Kalidou Koulibaly"); // 58\n', '    addPlayer("Bernardo Silva"); // 59\n', '    addPlayer("Vincent Kompany"); // 60\n', '    addPlayer("João Moutinho"); // 61\n', '    addPlayer("Toby Alderweireld"); // 62\n', '    addPlayer("Emil Forsberg"); // 63\n', '    addPlayer("Mario Mandžukić"); // 64\n', '    addPlayer("Sergej Milinković-Savić"); // 65\n', '    addPlayer("Shinji Kagawa"); // 66\n', '    addPlayer("Granit Xhaka"); // 67\n', '    addPlayer("Andreas Christensen"); // 68\n', '    addPlayer("Piotr Zieliński"); // 69\n', '    addPlayer("Fyodor Smolov"); // 70\n', '    addPlayer("Xherdan Shaqiri"); // 71\n', '    addPlayer("Marcus Rashford"); // 72\n', '    addPlayer("Javier Hernández"); // 73\n', '    addPlayer("Hirving Lozano"); // 74\n', '    addPlayer("Hakim Ziyech"); // 75\n', '    addPlayer("Victor Moses"); // 76\n', '    addPlayer("Jefferson Farfán"); // 77\n', '    addPlayer("Mohamed Elneny"); // 78\n', '    addPlayer("Marcus Berg"); // 79\n', '    addPlayer("Guillermo Ochoa"); // 80\n', '    addPlayer("Igor Akinfeev"); // 81\n', '    addPlayer("Sardar Azmoun"); // 82\n', '    addPlayer("Christian Cueva"); // 83\n', '    addPlayer("Wahbi Khazri"); // 84\n', '    addPlayer("Keisuke Honda"); // 85\n', '    addPlayer("Tim Cahill"); // 86\n', '    addPlayer("John Obi Mikel"); // 87\n', '    addPlayer("Ki Sung-yueng"); // 88\n', '    addPlayer("Bryan Ruiz"); // 89\n', '    addPlayer("Maya Yoshida"); // 90\n', '    addPlayer("Nawaf Al Abed"); // 91\n', '    addPlayer("Lee Chung-yong"); // 92\n', '    addPlayer("Gabriel Gómez"); // 93\n', '    addPlayer("Naïm Sliti"); // 94\n', '    addPlayer("Reza Ghoochannejhad"); // 95\n', '    addPlayer("Mile Jedinak"); // 96\n', '    addPlayer("Mohammad Al-Sahlawi"); // 97\n', '    addPlayer("Aron Gunnarsson"); // 98\n', '    addPlayer("Blas Pérez"); // 99\n', '    addPlayer("Dani Alves"); // 100\n', '    addPlayer("Zlatan Ibrahimović"); // 101\n', '  }\n', '\n', '  /// @dev Fires an event, proving that we said a player corresponds to a given ID.\n', '  /// @param _name The name of the player we are adding.\n', '  function addPlayer(string _name) public onlyOwner {\n', '    require(playerCount < 255, "You\'ve already added the maximum amount of players.");\n', '    emit PlayerAdded(playerCount, _name);\n', '    playerCount++;\n', '  }\n', '}\n', '\n', '\n', '/// @title The contract that manages checklist items, sets, and rarity tiers.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersChecklist is StrikersPlayerList {\n', '  // High level overview of everything going on in this contract:\n', '  //\n', '  // ChecklistItem is the parent class to Card and has 3 properties:\n', '  //  - uint8 checklistId (000 to 255)\n', '  //  - uint8 playerId (see StrikersPlayerList.sol)\n', '  //  - RarityTier tier (more info below)\n', '  //\n', '  // Two things to note: the checklistId is not explicitly stored\n', "  // on the checklistItem struct, and it's composed of two parts.\n", '  // (For the following, assume it is left padded with zeros to reach\n', '  // three digits, such that checklistId 0 becomes 000)\n', '  //  - the first digit represents the setId\n', '  //      * 0 = Originals Set\n', '  //      * 1 = Iconics Set\n', '  //      * 2 = Unreleased Set\n', '  //  - the last two digits represent its index in the appropriate set arary\n', '  //\n', '  //  For example, checklist ID 100 would represent fhe first checklist item\n', '  //  in the iconicChecklistItems array (first digit = 1 = Iconics Set, last two\n', '  //  digits = 00 = first index of array)\n', '  //\n', '  // Because checklistId is represented as a uint8 throughout the app, the highest\n', "  // value it can take is 255, which means we can't add more than 56 items to our\n", "  // Unreleased Set's unreleasedChecklistItems array (setId 2). Also, once we've initialized\n", "  // this contract, it's impossible for us to add more checklist items to the Originals\n", '  // and Iconics set -- what you see here is what you get.\n', '  //\n', '  // Simple enough right?\n', '\n', '  /// @dev We initialize this contract with so much data that we have\n', '  ///   to stage it in 4 different steps, ~33 checklist items at a time.\n', '  enum DeployStep {\n', '    WaitingForStepOne,\n', '    WaitingForStepTwo,\n', '    WaitingForStepThree,\n', '    WaitingForStepFour,\n', '    DoneInitialDeploy\n', '  }\n', '\n', '  /// @dev Enum containing all our rarity tiers, just because\n', "  ///   it's cleaner dealing with these values than with uint8s.\n", '  enum RarityTier {\n', '    IconicReferral,\n', '    IconicInsert,\n', '    Diamond,\n', '    Gold,\n', '    Silver,\n', '    Bronze\n', '  }\n', '\n', '  /// @dev A lookup table indicating how limited the cards\n', '  ///   in each tier are. If this value is 0, it means\n', '  ///   that cards of this rarity tier are unlimited,\n', '  ///   which is only the case for the 8 Iconics cards\n', '  ///   we give away as part of our referral program.\n', '  uint16[] public tierLimits = [\n', '    0,    // Iconic - Referral Bonus (uncapped)\n', '    100,  // Iconic Inserts ("Card of the Day")\n', '    1000, // Diamond\n', '    1664, // Gold\n', '    3328, // Silver\n', '    4352  // Bronze\n', '  ];\n', '\n', '  /// @dev ChecklistItem is essentially the parent class to Card.\n', '  ///   It represents a given superclass of cards (eg Originals Messi),\n', '  ///   and then each Card is an instance of this ChecklistItem, with\n', '  ///   its own serial number, mint date, etc.\n', '  struct ChecklistItem {\n', '    uint8 playerId;\n', '    RarityTier tier;\n', '  }\n', '\n', "  /// @dev The deploy step we're at. Defaults to WaitingForStepOne.\n", '  DeployStep public deployStep;\n', '\n', '  /// @dev Array containing all the Originals checklist items (000 - 099)\n', '  ChecklistItem[] public originalChecklistItems;\n', '\n', '  /// @dev Array containing all the Iconics checklist items (100 - 131)\n', '  ChecklistItem[] public iconicChecklistItems;\n', '\n', '  /// @dev Array containing all the unreleased checklist items (200 - 255 max)\n', '  ChecklistItem[] public unreleasedChecklistItems;\n', '\n', '  /// @dev Internal function to add a checklist item to the Originals set.\n', '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', "  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n", '  function _addOriginalChecklistItem(uint8 _playerId, RarityTier _tier) internal {\n', '    originalChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', '  /// @dev Internal function to add a checklist item to the Iconics set.\n', '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', "  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n", '  function _addIconicChecklistItem(uint8 _playerId, RarityTier _tier) internal {\n', '    iconicChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', '  /// @dev External function to add a checklist item to our mystery set.\n', "  ///   Must have completed initial deploy, and can't add more than 56 items (because checklistId is a uint8).\n", '  /// @param _playerId The player represented by this checklist item. (see StrikersPlayerList.sol)\n', "  /// @param _tier This checklist item's rarity tier. (see Rarity Tier enum and corresponding tierLimits)\n", '  function addUnreleasedChecklistItem(uint8 _playerId, RarityTier _tier) external onlyOwner {\n', '    require(deployStep == DeployStep.DoneInitialDeploy, "Finish deploying the Originals and Iconics sets first.");\n', '    require(unreleasedCount() < 56, "You can\'t add any more checklist items.");\n', '    require(_playerId < playerCount, "This player doesn\'t exist in our player list.");\n', '    unreleasedChecklistItems.push(ChecklistItem({\n', '      playerId: _playerId,\n', '      tier: _tier\n', '    }));\n', '  }\n', '\n', "  /// @dev Returns how many Original checklist items we've added.\n", '  function originalsCount() external view returns (uint256) {\n', '    return originalChecklistItems.length;\n', '  }\n', '\n', "  /// @dev Returns how many Iconic checklist items we've added.\n", '  function iconicsCount() public view returns (uint256) {\n', '    return iconicChecklistItems.length;\n', '  }\n', '\n', "  /// @dev Returns how many Unreleased checklist items we've added.\n", '  function unreleasedCount() public view returns (uint256) {\n', '    return unreleasedChecklistItems.length;\n', '  }\n', '\n', '  // In the next four functions, we initialize this contract with our\n', '  // 132 initial checklist items (100 Originals, 32 Iconics). Because\n', '  // of how much data we need to store, it has to be broken up into\n', '  // four different function calls, which need to be called in sequence.\n', '  // The ordering of the checklist items we add determines their\n', '  // checklist ID, which is left-padded in our frontend to be a\n', '  // 3-digit identifier where the first digit is the setId and the last\n', '  // 2 digits represents the checklist items index in the appropriate ___ChecklistItems array.\n', '  // For example, Originals Messi is the first item for set ID 0, and this\n', '  // is displayed as #000 throughout the app. Our Card struct declare its\n', '  // checklistId property as uint8, so we have\n', '  // to be mindful that we can only have 256 total checklist items.\n', '\n', '  /// @dev Deploys Originals #000 through #032.\n', '  function deployStepOne() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepOne, "You\'re not following the steps in order...");\n', '\n', '    /* ORIGINALS - DIAMOND */\n', '    _addOriginalChecklistItem(0, RarityTier.Diamond); // 000 Messi\n', '    _addOriginalChecklistItem(1, RarityTier.Diamond); // 001 Ronaldo\n', '    _addOriginalChecklistItem(2, RarityTier.Diamond); // 002 Neymar\n', '    _addOriginalChecklistItem(3, RarityTier.Diamond); // 003 Salah\n', '\n', '    /* ORIGINALS - GOLD */\n', '    _addOriginalChecklistItem(4, RarityTier.Gold); // 004 Lewandowski\n', '    _addOriginalChecklistItem(5, RarityTier.Gold); // 005 De Bruyne\n', '    _addOriginalChecklistItem(6, RarityTier.Gold); // 006 Modrić\n', '    _addOriginalChecklistItem(7, RarityTier.Gold); // 007 Hazard\n', '    _addOriginalChecklistItem(8, RarityTier.Gold); // 008 Ramos\n', '    _addOriginalChecklistItem(9, RarityTier.Gold); // 009 Kroos\n', '    _addOriginalChecklistItem(10, RarityTier.Gold); // 010 Suárez\n', '    _addOriginalChecklistItem(11, RarityTier.Gold); // 011 Kane\n', '    _addOriginalChecklistItem(12, RarityTier.Gold); // 012 Agüero\n', '    _addOriginalChecklistItem(13, RarityTier.Gold); // 013 Mbappé\n', '    _addOriginalChecklistItem(14, RarityTier.Gold); // 014 Higuaín\n', '    _addOriginalChecklistItem(15, RarityTier.Gold); // 015 de Gea\n', '    _addOriginalChecklistItem(16, RarityTier.Gold); // 016 Griezmann\n', '    _addOriginalChecklistItem(17, RarityTier.Gold); // 017 Kanté\n', '    _addOriginalChecklistItem(18, RarityTier.Gold); // 018 Cavani\n', '    _addOriginalChecklistItem(19, RarityTier.Gold); // 019 Pogba\n', '\n', '    /* ORIGINALS - SILVER (020 to 032) */\n', '    _addOriginalChecklistItem(20, RarityTier.Silver); // 020 Isco\n', '    _addOriginalChecklistItem(21, RarityTier.Silver); // 021 Marcelo\n', '    _addOriginalChecklistItem(22, RarityTier.Silver); // 022 Neuer\n', '    _addOriginalChecklistItem(23, RarityTier.Silver); // 023 Mertens\n', '    _addOriginalChecklistItem(24, RarityTier.Silver); // 024 James\n', '    _addOriginalChecklistItem(25, RarityTier.Silver); // 025 Dybala\n', '    _addOriginalChecklistItem(26, RarityTier.Silver); // 026 Eriksen\n', '    _addOriginalChecklistItem(27, RarityTier.Silver); // 027 David Silva\n', '    _addOriginalChecklistItem(28, RarityTier.Silver); // 028 Gabriel Jesus\n', '    _addOriginalChecklistItem(29, RarityTier.Silver); // 029 Thiago\n', '    _addOriginalChecklistItem(30, RarityTier.Silver); // 030 Courtois\n', '    _addOriginalChecklistItem(31, RarityTier.Silver); // 031 Coutinho\n', '    _addOriginalChecklistItem(32, RarityTier.Silver); // 032 Iniesta\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepTwo;\n', '  }\n', '\n', '  /// @dev Deploys Originals #033 through #065.\n', '  function deployStepTwo() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepTwo, "You\'re not following the steps in order...");\n', '\n', '    /* ORIGINALS - SILVER (033 to 049) */\n', '    _addOriginalChecklistItem(33, RarityTier.Silver); // 033 Casemiro\n', '    _addOriginalChecklistItem(34, RarityTier.Silver); // 034 Lukaku\n', '    _addOriginalChecklistItem(35, RarityTier.Silver); // 035 Piqué\n', '    _addOriginalChecklistItem(36, RarityTier.Silver); // 036 Hummels\n', '    _addOriginalChecklistItem(37, RarityTier.Silver); // 037 Godín\n', '    _addOriginalChecklistItem(38, RarityTier.Silver); // 038 Özil\n', '    _addOriginalChecklistItem(39, RarityTier.Silver); // 039 Son\n', '    _addOriginalChecklistItem(40, RarityTier.Silver); // 040 Sterling\n', '    _addOriginalChecklistItem(41, RarityTier.Silver); // 041 Lloris\n', '    _addOriginalChecklistItem(42, RarityTier.Silver); // 042 Falcao\n', '    _addOriginalChecklistItem(43, RarityTier.Silver); // 043 Rakitić\n', '    _addOriginalChecklistItem(44, RarityTier.Silver); // 044 Sané\n', '    _addOriginalChecklistItem(45, RarityTier.Silver); // 045 Firmino\n', '    _addOriginalChecklistItem(46, RarityTier.Silver); // 046 Mané\n', '    _addOriginalChecklistItem(47, RarityTier.Silver); // 047 Müller\n', '    _addOriginalChecklistItem(48, RarityTier.Silver); // 048 Alli\n', '    _addOriginalChecklistItem(49, RarityTier.Silver); // 049 Navas\n', '\n', '    /* ORIGINALS - BRONZE (050 to 065) */\n', '    _addOriginalChecklistItem(50, RarityTier.Bronze); // 050 Thiago Silva\n', '    _addOriginalChecklistItem(51, RarityTier.Bronze); // 051 Varane\n', '    _addOriginalChecklistItem(52, RarityTier.Bronze); // 052 Di María\n', '    _addOriginalChecklistItem(53, RarityTier.Bronze); // 053 Alba\n', '    _addOriginalChecklistItem(54, RarityTier.Bronze); // 054 Benatia\n', '    _addOriginalChecklistItem(55, RarityTier.Bronze); // 055 Werner\n', '    _addOriginalChecklistItem(56, RarityTier.Bronze); // 056 Sigurðsson\n', '    _addOriginalChecklistItem(57, RarityTier.Bronze); // 057 Matić\n', '    _addOriginalChecklistItem(58, RarityTier.Bronze); // 058 Koulibaly\n', '    _addOriginalChecklistItem(59, RarityTier.Bronze); // 059 Bernardo Silva\n', '    _addOriginalChecklistItem(60, RarityTier.Bronze); // 060 Kompany\n', '    _addOriginalChecklistItem(61, RarityTier.Bronze); // 061 Moutinho\n', '    _addOriginalChecklistItem(62, RarityTier.Bronze); // 062 Alderweireld\n', '    _addOriginalChecklistItem(63, RarityTier.Bronze); // 063 Forsberg\n', '    _addOriginalChecklistItem(64, RarityTier.Bronze); // 064 Mandžukić\n', '    _addOriginalChecklistItem(65, RarityTier.Bronze); // 065 Milinković-Savić\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepThree;\n', '  }\n', '\n', '  /// @dev Deploys Originals #066 through #099.\n', '  function deployStepThree() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepThree, "You\'re not following the steps in order...");\n', '\n', '    /* ORIGINALS - BRONZE (066 to 099) */\n', '    _addOriginalChecklistItem(66, RarityTier.Bronze); // 066 Kagawa\n', '    _addOriginalChecklistItem(67, RarityTier.Bronze); // 067 Xhaka\n', '    _addOriginalChecklistItem(68, RarityTier.Bronze); // 068 Christensen\n', '    _addOriginalChecklistItem(69, RarityTier.Bronze); // 069 Zieliński\n', '    _addOriginalChecklistItem(70, RarityTier.Bronze); // 070 Smolov\n', '    _addOriginalChecklistItem(71, RarityTier.Bronze); // 071 Shaqiri\n', '    _addOriginalChecklistItem(72, RarityTier.Bronze); // 072 Rashford\n', '    _addOriginalChecklistItem(73, RarityTier.Bronze); // 073 Hernández\n', '    _addOriginalChecklistItem(74, RarityTier.Bronze); // 074 Lozano\n', '    _addOriginalChecklistItem(75, RarityTier.Bronze); // 075 Ziyech\n', '    _addOriginalChecklistItem(76, RarityTier.Bronze); // 076 Moses\n', '    _addOriginalChecklistItem(77, RarityTier.Bronze); // 077 Farfán\n', '    _addOriginalChecklistItem(78, RarityTier.Bronze); // 078 Elneny\n', '    _addOriginalChecklistItem(79, RarityTier.Bronze); // 079 Berg\n', '    _addOriginalChecklistItem(80, RarityTier.Bronze); // 080 Ochoa\n', '    _addOriginalChecklistItem(81, RarityTier.Bronze); // 081 Akinfeev\n', '    _addOriginalChecklistItem(82, RarityTier.Bronze); // 082 Azmoun\n', '    _addOriginalChecklistItem(83, RarityTier.Bronze); // 083 Cueva\n', '    _addOriginalChecklistItem(84, RarityTier.Bronze); // 084 Khazri\n', '    _addOriginalChecklistItem(85, RarityTier.Bronze); // 085 Honda\n', '    _addOriginalChecklistItem(86, RarityTier.Bronze); // 086 Cahill\n', '    _addOriginalChecklistItem(87, RarityTier.Bronze); // 087 Mikel\n', '    _addOriginalChecklistItem(88, RarityTier.Bronze); // 088 Sung-yueng\n', '    _addOriginalChecklistItem(89, RarityTier.Bronze); // 089 Ruiz\n', '    _addOriginalChecklistItem(90, RarityTier.Bronze); // 090 Yoshida\n', '    _addOriginalChecklistItem(91, RarityTier.Bronze); // 091 Al Abed\n', '    _addOriginalChecklistItem(92, RarityTier.Bronze); // 092 Chung-yong\n', '    _addOriginalChecklistItem(93, RarityTier.Bronze); // 093 Gómez\n', '    _addOriginalChecklistItem(94, RarityTier.Bronze); // 094 Sliti\n', '    _addOriginalChecklistItem(95, RarityTier.Bronze); // 095 Ghoochannejhad\n', '    _addOriginalChecklistItem(96, RarityTier.Bronze); // 096 Jedinak\n', '    _addOriginalChecklistItem(97, RarityTier.Bronze); // 097 Al-Sahlawi\n', '    _addOriginalChecklistItem(98, RarityTier.Bronze); // 098 Gunnarsson\n', '    _addOriginalChecklistItem(99, RarityTier.Bronze); // 099 Pérez\n', '\n', '    // Move to the next deploy step.\n', '    deployStep = DeployStep.WaitingForStepFour;\n', '  }\n', '\n', '  /// @dev Deploys all Iconics and marks the deploy as complete!\n', '  function deployStepFour() external onlyOwner {\n', '    require(deployStep == DeployStep.WaitingForStepFour, "You\'re not following the steps in order...");\n', '\n', '    /* ICONICS */\n', '    _addIconicChecklistItem(0, RarityTier.IconicInsert); // 100 Messi\n', '    _addIconicChecklistItem(1, RarityTier.IconicInsert); // 101 Ronaldo\n', '    _addIconicChecklistItem(2, RarityTier.IconicInsert); // 102 Neymar\n', '    _addIconicChecklistItem(3, RarityTier.IconicInsert); // 103 Salah\n', '    _addIconicChecklistItem(4, RarityTier.IconicInsert); // 104 Lewandowski\n', '    _addIconicChecklistItem(5, RarityTier.IconicInsert); // 105 De Bruyne\n', '    _addIconicChecklistItem(6, RarityTier.IconicInsert); // 106 Modrić\n', '    _addIconicChecklistItem(7, RarityTier.IconicInsert); // 107 Hazard\n', '    _addIconicChecklistItem(8, RarityTier.IconicInsert); // 108 Ramos\n', '    _addIconicChecklistItem(9, RarityTier.IconicInsert); // 109 Kroos\n', '    _addIconicChecklistItem(10, RarityTier.IconicInsert); // 110 Suárez\n', '    _addIconicChecklistItem(11, RarityTier.IconicInsert); // 111 Kane\n', '    _addIconicChecklistItem(12, RarityTier.IconicInsert); // 112 Agüero\n', '    _addIconicChecklistItem(15, RarityTier.IconicInsert); // 113 de Gea\n', '    _addIconicChecklistItem(16, RarityTier.IconicInsert); // 114 Griezmann\n', '    _addIconicChecklistItem(17, RarityTier.IconicReferral); // 115 Kanté\n', '    _addIconicChecklistItem(18, RarityTier.IconicReferral); // 116 Cavani\n', '    _addIconicChecklistItem(19, RarityTier.IconicInsert); // 117 Pogba\n', '    _addIconicChecklistItem(21, RarityTier.IconicInsert); // 118 Marcelo\n', '    _addIconicChecklistItem(24, RarityTier.IconicInsert); // 119 James\n', '    _addIconicChecklistItem(26, RarityTier.IconicInsert); // 120 Eriksen\n', '    _addIconicChecklistItem(29, RarityTier.IconicReferral); // 121 Thiago\n', '    _addIconicChecklistItem(36, RarityTier.IconicReferral); // 122 Hummels\n', '    _addIconicChecklistItem(38, RarityTier.IconicReferral); // 123 Özil\n', '    _addIconicChecklistItem(39, RarityTier.IconicInsert); // 124 Son\n', '    _addIconicChecklistItem(46, RarityTier.IconicInsert); // 125 Mané\n', '    _addIconicChecklistItem(48, RarityTier.IconicInsert); // 126 Alli\n', '    _addIconicChecklistItem(49, RarityTier.IconicReferral); // 127 Navas\n', '    _addIconicChecklistItem(73, RarityTier.IconicInsert); // 128 Hernández\n', '    _addIconicChecklistItem(85, RarityTier.IconicInsert); // 129 Honda\n', '    _addIconicChecklistItem(100, RarityTier.IconicReferral); // 130 Alves\n', '    _addIconicChecklistItem(101, RarityTier.IconicReferral); // 131 Zlatan\n', '\n', '    // Mark the initial deploy as complete.\n', '    deployStep = DeployStep.DoneInitialDeploy;\n', '  }\n', '\n', '  /// @dev Returns the mint limit for a given checklist item, based on its tier.\n', '  /// @param _checklistId Which checklist item we need to get the limit for.\n', '  /// @return How much of this checklist item we are allowed to mint.\n', '  function limitForChecklistId(uint8 _checklistId) external view returns (uint16) {\n', '    RarityTier rarityTier;\n', '    uint8 index;\n', '    if (_checklistId < 100) { // Originals = #000 to #099\n', '      rarityTier = originalChecklistItems[_checklistId].tier;\n', '    } else if (_checklistId < 200) { // Iconics = #100 to #131\n', '      index = _checklistId - 100;\n', '      require(index < iconicsCount(), "This Iconics checklist item doesn\'t exist.");\n', '      rarityTier = iconicChecklistItems[index].tier;\n', '    } else { // Unreleased = #200 to max #255\n', '      index = _checklistId - 200;\n', '      require(index < unreleasedCount(), "This Unreleased checklist item doesn\'t exist.");\n', '      rarityTier = unreleasedChecklistItems[index].tier;\n', '    }\n', '    return tierLimits[uint8(rarityTier)];\n', '  }\n', '}\n', '\n', '\n', '/// @title Base contract for CryptoStrikers. Defines what a card is and how to mint one.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersBase is ERC721Token("CryptoStrikers", "STRK") {\n', '\n', '  /// @dev Emit this event whenever we mint a new card (see _mintCard below)\n', '  event CardMinted(uint256 cardId);\n', '\n', "  /// @dev The struct representing the game's main object, a sports trading card.\n", '  struct Card {\n', '    // The timestamp at which this card was minted.\n', '    // With uint32 we are good until 2106, by which point we will have not minted\n', '    // a card in like, 88 years.\n', '    uint32 mintTime;\n', '\n', '    // The checklist item represented by this card. See StrikersChecklist.sol for more info.\n', '    uint8 checklistId;\n', '\n', '    // Cards for a given player have a serial number, which gets\n', '    // incremented in sequence. For example, if we mint 1000 of a card,\n', '    // the third one to be minted has serialNumber = 3 (out of 1000).\n', '    uint16 serialNumber;\n', '  }\n', '\n', '  /*** STORAGE ***/\n', '\n', '  /// @dev All the cards that have been minted, indexed by cardId.\n', '  Card[] public cards;\n', '\n', '  /// @dev Keeps track of how many cards we have minted for a given checklist item\n', "  ///   to make sure we don't go over the limit for it.\n", '  ///   NB: uint16 has a capacity of 65,535, but we are not minting more than\n', '  ///   4,352 of any given checklist item.\n', '  mapping (uint8 => uint16) public mintedCountForChecklistId;\n', '\n', '  /// @dev A reference to our checklist contract, which contains all the minting limits.\n', '  StrikersChecklist public strikersChecklist;\n', '\n', '  /*** FUNCTIONS ***/\n', '\n', '  /// @dev For a given owner, returns two arrays. The first contains the IDs of every card owned\n', '  ///   by this address. The second returns the corresponding checklist ID for each of these cards.\n', '  ///   There are a few places we need this info in the web app and short of being able to return an\n', '  ///   actual array of Cards, this is the best solution we could come up with...\n', '  function cardAndChecklistIdsForOwner(address _owner) external view returns (uint256[], uint8[]) {\n', '    uint256[] memory cardIds = ownedTokens[_owner];\n', '    uint256 cardCount = cardIds.length;\n', '    uint8[] memory checklistIds = new uint8[](cardCount);\n', '\n', '    for (uint256 i = 0; i < cardCount; i++) {\n', '      uint256 cardId = cardIds[i];\n', '      checklistIds[i] = cards[cardId].checklistId;\n', '    }\n', '\n', '    return (cardIds, checklistIds);\n', '  }\n', '\n', '  /// @dev An internal method that creates a new card and stores it.\n', '  ///  Emits both a CardMinted and a Transfer event.\n', '  /// @param _checklistId The ID of the checklistItem represented by the card (see Checklist.sol)\n', "  /// @param _owner The card's first owner!\n", '  function _mintCard(\n', '    uint8 _checklistId,\n', '    address _owner\n', '  )\n', '    internal\n', '    returns (uint256)\n', '  {\n', '    uint16 mintLimit = strikersChecklist.limitForChecklistId(_checklistId);\n', '    require(mintLimit == 0 || mintedCountForChecklistId[_checklistId] < mintLimit, "Can\'t mint any more of this card!");\n', '    uint16 serialNumber = ++mintedCountForChecklistId[_checklistId];\n', '    Card memory newCard = Card({\n', '      mintTime: uint32(now),\n', '      checklistId: _checklistId,\n', '      serialNumber: serialNumber\n', '    });\n', '    uint256 newCardId = cards.push(newCard) - 1;\n', '    emit CardMinted(newCardId);\n', '    _mint(_owner, newCardId);\n', '    return newCardId;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '\n', '/// @title The contract that exposes minting functions to the outside world and limits who can call them.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersMinting is StrikersBase, Pausable {\n', '\n', '  /// @dev Emit this when we decide to no longer mint a given checklist ID.\n', '  event PulledFromCirculation(uint8 checklistId);\n', '\n', '  /// @dev If the value for a checklistId is true, we can no longer mint it.\n', '  mapping (uint8 => bool) public outOfCirculation;\n', '\n', '  /// @dev The address of the contract that manages the pack sale.\n', '  address public packSaleAddress;\n', '\n', '  /// @dev Only the owner can update the address of the pack sale contract.\n', '  /// @param _address The address of the new StrikersPackSale contract.\n', '  function setPackSaleAddress(address _address) external onlyOwner {\n', '    packSaleAddress = _address;\n', '  }\n', '\n', '  /// @dev Allows the contract at packSaleAddress to mint cards.\n', '  /// @param _checklistId The checklist item represented by this new card.\n', "  /// @param _owner The card's first owner!\n", "  /// @return The new card's ID.\n", '  function mintPackSaleCard(uint8 _checklistId, address _owner) external returns (uint256) {\n', '    require(msg.sender == packSaleAddress, "Only the pack sale contract can mint here.");\n', '    require(!outOfCirculation[_checklistId], "Can\'t mint any more of this checklist item...");\n', '    return _mintCard(_checklistId, _owner);\n', '  }\n', '\n', '  /// @dev Allows the owner to mint cards from our Unreleased Set.\n', '  /// @param _checklistId The checklist item represented by this new card. Must be >= 200.\n', "  /// @param _owner The card's first owner!\n", '  function mintUnreleasedCard(uint8 _checklistId, address _owner) external onlyOwner {\n', '    require(_checklistId >= 200, "You can only use this to mint unreleased cards.");\n', '    require(!outOfCirculation[_checklistId], "Can\'t mint any more of this checklist item...");\n', '    _mintCard(_checklistId, _owner);\n', '  }\n', '\n', '  /// @dev Allows the owner or the pack sale contract to prevent an Iconic or Unreleased card from ever being minted again.\n', '  /// @param _checklistId The Iconic or Unreleased card we want to remove from circulation.\n', '  function pullFromCirculation(uint8 _checklistId) external {\n', '    bool ownerOrPackSale = (msg.sender == owner) || (msg.sender == packSaleAddress);\n', '    require(ownerOrPackSale, "Only the owner or pack sale can take checklist items out of circulation.");\n', '    require(_checklistId >= 100, "This function is reserved for Iconics and Unreleased sets.");\n', '    outOfCirculation[_checklistId] = true;\n', '    emit PulledFromCirculation(_checklistId);\n', '  }\n', '}\n', '\n', '\n', '/// @title StrikersTrading - Allows users to trustlessly trade cards.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersTrading is StrikersMinting {\n', '\n', '  /// @dev Emitting this allows us to look up if a trade has been\n', '  ///   successfully filled, by who, and which cards were involved.\n', '  event TradeFilled(\n', '    bytes32 indexed tradeHash,\n', '    address indexed maker,\n', '    uint256 makerCardId,\n', '    address indexed taker,\n', '    uint256 takerCardId\n', '  );\n', '\n', '  /// @dev Emitting this allows us to look up if a trade has been cancelled.\n', '  event TradeCancelled(bytes32 indexed tradeHash, address indexed maker);\n', '\n', '  /// @dev All the possible states for a trade.\n', '  enum TradeState {\n', '    Valid,\n', '    Filled,\n', '    Cancelled\n', '  }\n', '\n', '  /// @dev Mapping of tradeHash => TradeState. Defaults to Valid.\n', '  mapping (bytes32 => TradeState) public tradeStates;\n', '\n', '  /// @dev A taker (someone who has received a signed trade hash)\n', '  ///   submits a cardId to this function and, if it satisfies\n', '  ///   the given criteria, the trade is executed.\n', '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', "  /// @param _taker The counterparty the maker wishes to trade with (if it's address(0), anybody can fill the trade!)\n", '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Originals John Smith").\n', '  ///                                If not, then it\'s a card ID (e.g. "Originals John Smith #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  /// @param _submittedCardId The card the taker is using to fill the trade. Must satisfy either the card or checklist ID\n', '  ///                         specified in _takerCardOrChecklistId.\n', '  /// @param _v ECDSA signature parameter v from the tradeHash signed by the maker.\n', '  /// @param _r ECDSA signature parameters r from the tradeHash signed by the maker.\n', '  /// @param _s ECDSA signature parameters s from the tradeHash signed by the maker.\n', '  function fillTrade(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt,\n', '    uint256 _submittedCardId,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s)\n', '    external\n', '    whenNotPaused\n', '  {\n', '    require(_maker != msg.sender, "You can\'t fill your own trade.");\n', '    require(_taker == address(0) || _taker == msg.sender, "You are not authorized to fill this trade.");\n', '\n', '    if (_taker == address(0)) {\n', '      // This trade is open to the public so we are requesting a checklistItem, rather than a specific card.\n', '      require(cards[_submittedCardId].checklistId == _takerCardOrChecklistId, "The card you submitted is not valid for this trade.");\n', '    } else {\n', '      // We are trading directly with another user and are requesting a specific card.\n', '      require(_submittedCardId == _takerCardOrChecklistId, "The card you submitted is not valid for this trade.");\n', '    }\n', '\n', '    bytes32 tradeHash = getTradeHash(\n', '      _maker,\n', '      _makerCardId,\n', '      _taker,\n', '      _takerCardOrChecklistId,\n', '      _salt\n', '    );\n', '\n', '    require(tradeStates[tradeHash] == TradeState.Valid, "This trade is no longer valid.");\n', '    require(isValidSignature(_maker, tradeHash, _v, _r, _s), "Invalid signature.");\n', '\n', '    tradeStates[tradeHash] = TradeState.Filled;\n', '\n', '    // For better UX, we assume that by signing the trade, the maker has given\n', '    // implicit approval for this token to be transferred. This saves us from an\n', '    // extra approval transaction...\n', '    tokenApprovals[_makerCardId] = msg.sender;\n', '\n', '    safeTransferFrom(_maker, msg.sender, _makerCardId);\n', '    safeTransferFrom(msg.sender, _maker, _submittedCardId);\n', '\n', '    emit TradeFilled(tradeHash, _maker, _makerCardId, msg.sender, _submittedCardId);\n', '  }\n', '\n', "  /// @dev Allows the maker to cancel a trade that hasn't been filled yet.\n", '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', "  /// @param _taker The counterparty the maker wishes to trade with (if it's address(0), anybody can fill the trade!)\n", '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Lionel Messi").\n', '  ///                                If not, then it\'s a card ID (e.g. "Lionel Messi #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  function cancelTrade(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt)\n', '    external\n', '  {\n', '    require(_maker == msg.sender, "Only the trade creator can cancel this trade.");\n', '\n', '    bytes32 tradeHash = getTradeHash(\n', '      _maker,\n', '      _makerCardId,\n', '      _taker,\n', '      _takerCardOrChecklistId,\n', '      _salt\n', '    );\n', '\n', '    require(tradeStates[tradeHash] == TradeState.Valid, "This trade has already been cancelled or filled.");\n', '    tradeStates[tradeHash] = TradeState.Cancelled;\n', '    emit TradeCancelled(tradeHash, _maker);\n', '  }\n', '\n', '  /// @dev Calculates Keccak-256 hash of a trade with specified parameters.\n', '  /// @param _maker Address of the maker (i.e. trade creator).\n', '  /// @param _makerCardId ID of the card the maker has agreed to give up.\n', "  /// @param _taker The counterparty the maker wishes to trade with (if it's address(0), anybody can fill the trade!)\n", '  /// @param _takerCardOrChecklistId If taker is the 0-address, then this is a checklist ID (e.g. "any Lionel Messi").\n', '  ///                                If not, then it\'s a card ID (e.g. "Lionel Messi #8/100").\n', '  /// @param _salt A uint256 timestamp to differentiate trades that have otherwise identical params (prevents replay attacks).\n', '  /// @return Keccak-256 hash of trade.\n', '  function getTradeHash(\n', '    address _maker,\n', '    uint256 _makerCardId,\n', '    address _taker,\n', '    uint256 _takerCardOrChecklistId,\n', '    uint256 _salt)\n', '    public\n', '    view\n', '    returns (bytes32)\n', '  {\n', '    // Hashing the contract address prevents a trade from being replayed on any new trade contract we deploy.\n', '    bytes memory packed = abi.encodePacked(this, _maker, _makerCardId, _taker, _takerCardOrChecklistId, _salt);\n', '    return keccak256(packed);\n', '  }\n', '\n', '  /// @dev Verifies that a signed trade is valid.\n', '  /// @param _signer Address of signer.\n', '  /// @param _tradeHash Signed Keccak-256 hash.\n', '  /// @param _v ECDSA signature parameter v.\n', '  /// @param _r ECDSA signature parameters r.\n', '  /// @param _s ECDSA signature parameters s.\n', '  /// @return Validity of signature.\n', '  function isValidSignature(\n', '    address _signer,\n', '    bytes32 _tradeHash,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s)\n', '    public\n', '    pure\n', '    returns (bool)\n', '  {\n', '    bytes memory packed = abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _tradeHash);\n', '    return _signer == ecrecover(keccak256(packed), _v, _r, _s);\n', '  }\n', '}\n', '\n', '\n', '/// @title The main, ERC721-compliant CryptoStrikers contract.\n', '/// @author The CryptoStrikers Team\n', 'contract StrikersCore is StrikersTrading {\n', '\n', '  /// @dev An external metadata contract that the owner can upgrade.\n', '  StrikersMetadata public strikersMetadata;\n', '\n', '  /// @dev We initialize the CryptoStrikers game with an immutable checklist that oversees card rarity.\n', '  constructor(address _checklistAddress) public {\n', '    strikersChecklist = StrikersChecklist(_checklistAddress);\n', '  }\n', '\n', '  /// @dev Allows the contract owner to update the metadata contract.\n', '  function setMetadataAddress(address _contractAddress) external onlyOwner {\n', '    strikersMetadata = StrikersMetadata(_contractAddress);\n', '  }\n', '\n', "  /// @dev If we've set an external metadata contract, use that.\n", '  function tokenURI(uint256 _tokenId) public view returns (string) {\n', '    if (strikersMetadata == address(0)) {\n', '      return super.tokenURI(_tokenId);\n', '    }\n', '\n', '    require(exists(_tokenId), "Card does not exist.");\n', '    return strikersMetadata.tokenURI(_tokenId);\n', '  }\n', '}']
