['/**\n', ' * Licensed to the Apache Software Foundation (ASF) under one\n', ' * or more contributor license agreements.  See the NOTICE file\n', ' * distributed with this work for additional information\n', ' * regarding copyright ownership.  The ASF licenses this file\n', ' * to you under the Apache License, Version 2.0 (the\n', ' * "License"); you may not use this file except in compliance\n', ' * with the License.  You may obtain a copy of the License at\n', ' * \n', ' *   http://www.apache.org/licenses/LICENSE-2.0\n', ' * \n', ' * Unless required by applicable law or agreed to in writing,\n', ' * software distributed under the License is distributed on an\n', ' * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n', ' * KIND, either express or implied.  See the License for the\n', ' * specific language governing permissions and limitations\n', ' * under the License.\n', ' */\n', '\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' *  @title Ownable\n', ' *  @dev Provides a modifier that requires the caller to be the owner of the contract.\n', ' */\n', 'contract Ownable {\n', '    address payable public owner;\n', '\n', '    event OwnerTransferred(\n', '        address indexed oldOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Owner account is required");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwner(address payable newOwner)\n', '    public\n', '    onlyOwner {\n', '        require(newOwner != owner, "New Owner cannot be the current owner");\n', '        require(newOwner != address(0), "New Owner cannot be zero address");\n', '        address payable prevOwner = owner;\n', '        owner = newOwner;\n', '        emit OwnerTransferred(prevOwner, newOwner);\n', '    }\n', '}\n', '\n', '/**\n', ' *  @title Lockable\n', ' *  @dev The Lockable contract adds the ability for the contract owner to set the lock status\n', ' *  of the account. A modifier is provided that checks the throws when the contract is\n', ' *  in the locked state.\n', ' */\n', 'contract Lockable is Ownable {\n', '    bool public isLocked;\n', '\n', '    constructor() public {\n', '        isLocked = false;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '        require(!isLocked, "Contract is currently locked for modification");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Set the contract to a read-only state.\n', '     *  @param locked The locked state to set the contract to.\n', '     */\n', '    function setLocked(bool locked)\n', '    onlyOwner\n', '    external {\n', '        require(isLocked != locked, "Contract already in requested lock state");\n', '\n', '        isLocked = locked;\n', '    }\n', '}\n', '\n', '/**\n', ' *  @title Destroyable\n', ' *  @dev The Destroyable contract alows the owner address to `selfdestruct` the contract.\n', ' */\n', 'contract Destroyable is Ownable {\n', '    /**\n', '     *  Allow the owner to destroy this contract.\n', '     */\n', '    function kill()\n', '    onlyOwner\n', '    external {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' *  Contract to facilitate locking and self destructing.\n', ' */\n', 'contract LockableDestroyable is Lockable, Destroyable { }\n', '\n', 'library AdditiveMath {\n', '    /**\n', '     *  Adds two numbers and returns the result\n', '     *  THROWS when the result overflows\n', '     *  @return The sum of the arguments\n', '     */\n', '    function add(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256) {\n', '        uint256 sum = x + y;\n', '        require(sum >= x, "Results in overflow");\n', '        return sum;\n', '    }\n', '\n', '    /**\n', '     *  Subtracts two numbers and returns the result\n', '     *  THROWS when the result underflows\n', '     *  @return The difference of the arguments\n', '     */\n', '    function subtract(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256) {\n', '        require(y <= x, "Results in underflow");\n', '        return x - y;\n', '    }\n', '}\n', '\n', '/**\n', ' *\n', ' *  @title AddressMap\n', ' *  @dev Map of unique indexed addresseses.\n', ' *\n', ' *  **NOTE**\n', ' *    The internal collections are one-based.\n', ' *    This is simply because null values are expressed as zero,\n', ' *    which makes it hard to check for the existence of items within the array,\n', ' *    or grabbing the first item of an array for non-existent items.\n', ' *\n', ' *    This is only exposed internally, so callers still use zero-based indices.\n', ' *\n', ' */\n', 'library AddressMap {\n', '    struct Data {\n', '        int256 count;\n', '        mapping(address => int256) indices;\n', '        mapping(int256 => address) items;\n', '    }\n', '\n', '    address constant ZERO_ADDRESS = address(0);\n', '\n', '    /**\n', '     *  Appends the address to the end of the map, if the address is not\n', '     *  zero and the address doesn&#39;t currently exist.\n', '     *  @param addr The address to append.\n', '     *  @return true if the address was added.\n', '     */\n', '    function append(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return false;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index >= 0 && index < self.count) {\n', '            return false;\n', '        }\n', '\n', '        self.count++;\n', '        self.indices[addr] = self.count;\n', '        self.items[self.count] = addr;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Removes the given address from the map.\n', '     *  @param addr The address to remove from the map.\n', '     *  @return true if the address was removed.\n', '     */\n', '    function remove(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        int256 oneBasedIndex = self.indices[addr];\n', '        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\n', '            return false;  // address doesn&#39;t exist, or zero.\n', '        }\n', '\n', '        // When the item being removed is not the last item in the collection,\n', '        // replace that item with the last one, otherwise zero it out.\n', '        //\n', '        //  If {2} is the item to be removed\n', '        //     [0, 1, 2, 3, 4]\n', '        //  The result would be:\n', '        //     [0, 1, 4, 3]\n', '        //\n', '        if (oneBasedIndex < self.count) {\n', '            // Replace with last item\n', '            address last = self.items[self.count];  // Get the last item\n', '            self.indices[last] = oneBasedIndex;     // Update last items index to current index\n', '            self.items[oneBasedIndex] = last;       // Update current index to last item\n', '            delete self.items[self.count];          // Delete the last item, since it&#39;s moved\n', '        } else {\n', '            // Delete the address\n', '            delete self.items[oneBasedIndex];\n', '        }\n', '\n', '        delete self.indices[addr];\n', '        self.count--;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Clears all items within the map.\n', '     */\n', '    function clear(Data storage self)\n', '    internal {\n', '        self.count = 0;\n', '    }\n', '\n', '    /**\n', '     *  Retrieves the address at the given index.\n', '     *  THROWS when the index is invalid.\n', '     *  @param index The index of the item to retrieve.\n', '     *  @return The address of the item at the given index.\n', '     */\n', '    function at(Data storage self, int256 index)\n', '    internal\n', '    view\n', '    returns (address) {\n', '        require(index >= 0 && index < self.count, "Index outside of bounds.");\n', '        return self.items[index + 1];\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the given address.\n', '     *  @param addr The address of the item to get the index for.\n', '     *  @return The index of the given address.\n', '     */\n', '    function indexOf(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (int256) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return -1;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index < 0 || index >= self.count) {\n', '            return -1;\n', '        }\n', '        return index;\n', '    }\n', '\n', '    /**\n', '     *  Returns whether or not the given address exists within the map.\n', '     *  @param addr The address to check for existence.\n', '     *  @return If the given address exists or not.\n', '     */\n', '    function exists(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (bool) {\n', '        int256 index = self.indices[addr] - 1;\n', '        return index >= 0 && index < self.count;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' *\n', ' *  @title AccountMap\n', ' *  @dev Map of unique indexed accounts.\n', ' *\n', ' *  **NOTE**\n', ' *    The internal collections are one-based.\n', ' *    This is simply because null values are expressed as zero,\n', ' *    which makes it hard to check for the existence of items within the array,\n', ' *    or grabbing the first item of an array for non-existent items.\n', ' *\n', ' *    This is only exposed internally, so callers still use zero-based indices.\n', ' *\n', ' */\n', 'library AccountMap {\n', '    struct Account {\n', '        address addr;\n', '        uint8 kind;\n', '        bool frozen;\n', '        address parent;\n', '    }\n', '\n', '    struct Data {\n', '        int256 count;\n', '        mapping(address => int256) indices;\n', '        mapping(int256 => Account) items;\n', '    }\n', '\n', '    address constant ZERO_ADDRESS = address(0);\n', '\n', '    /**\n', '     *  Appends the address to the end of the map, if the addres is not\n', '     *  zero and the address doesn&#39;t currently exist.\n', '     *  @param addr The address to append.\n', '     *  @return true if the address was added.\n', '     */\n', '    function append(Data storage self, address addr, uint8 kind, bool isFrozen, address parent)\n', '    internal\n', '    returns (bool) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return false;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index >= 0 && index < self.count) {\n', '            return false;\n', '        }\n', '\n', '        self.count++;\n', '        self.indices[addr] = self.count;\n', '        self.items[self.count] = Account(addr, kind, isFrozen, parent);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Removes the given address from the map.\n', '     *  @param addr The address to remove from the map.\n', '     *  @return true if the address was removed.\n', '     */\n', '    function remove(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        int256 oneBasedIndex = self.indices[addr];\n', '        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\n', '            return false;  // address doesn&#39;t exist, or zero.\n', '        }\n', '\n', '        // When the item being removed is not the last item in the collection,\n', '        // replace that item with the last one, otherwise zero it out.\n', '        //\n', '        //  If {2} is the item to be removed\n', '        //     [0, 1, 2, 3, 4]\n', '        //  The result would be:\n', '        //     [0, 1, 4, 3]\n', '        //\n', '        if (oneBasedIndex < self.count) {\n', '            // Replace with last item\n', '            Account storage last = self.items[self.count];  // Get the last item\n', '            self.indices[last.addr] = oneBasedIndex;        // Update last items index to current index\n', '            self.items[oneBasedIndex] = last;               // Update current index to last item\n', '            delete self.items[self.count];                  // Delete the last item, since it&#39;s moved\n', '        } else {\n', '            // Delete the account\n', '            delete self.items[oneBasedIndex];\n', '        }\n', '\n', '        delete self.indices[addr];\n', '        self.count--;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Clears all items within the map.\n', '     */\n', '    function clear(Data storage self)\n', '    internal {\n', '        self.count = 0;\n', '    }\n', '\n', '    /**\n', '     *  Retrieves the address at the given index.\n', '     *  THROWS when the index is invalid.\n', '     *  @param index The index of the item to retrieve.\n', '     *  @return The address of the item at the given index.\n', '     */\n', '    function at(Data storage self, int256 index)\n', '    internal\n', '    view\n', '    returns (Account memory) {\n', '        require(index >= 0 && index < self.count, "Index outside of bounds.");\n', '        return self.items[index + 1];\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the given address.\n', '     *  @param addr The address of the item to get the index for.\n', '     *  @return The index of the given address.\n', '     */\n', '    function indexOf(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (int256) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return -1;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index < 0 || index >= self.count) {\n', '            return -1;\n', '        }\n', '        return index;\n', '    }\n', '\n', '    /**\n', '     *  Gets the Account for the given address.\n', '     *  THROWS when an account doesn&#39;t exist for the given address.\n', '     *  @param addr The address of the item to get.\n', '     *  @return The account of the given address.\n', '     */\n', '    function get(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (Account memory) {\n', '        return at(self, indexOf(self, addr));\n', '    }\n', '\n', '    /**\n', '     *  Returns whether or not the given address exists within the map.\n', '     *  @param addr The address to check for existence.\n', '     *  @return If the given address exists or not.\n', '     */\n', '    function exists(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (bool) {\n', '        int256 index = self.indices[addr] - 1;\n', '        return index >= 0 && index < self.count;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' *  @title Registry Storage\n', ' */\n', 'contract Storage is Ownable, LockableDestroyable {\n', '  \n', '    using AccountMap for AccountMap.Data;\n', '    using AddressMap for AddressMap.Data;\n', '\n', '    // ------------------------------- Variables -------------------------------\n', '    // Number of data slots available for accounts\n', '    uint8 constant MAX_DATA = 30;\n', '\n', '    // Accounts\n', '    AccountMap.Data public accounts;\n', '\n', '    // Account Data\n', '    //   - mapping of:\n', '    //     (address        => (index =>    data))\n', '    mapping(address => mapping(uint8 => bytes32)) public data;\n', '\n', '    // Address write permissions\n', '    //     (kind  => address)\n', '    mapping(uint8 => AddressMap.Data) public permissions;\n', '\n', '\n', '    // ------------------------------- Modifiers -------------------------------\n', '    /**\n', '     *  Ensures the `msg.sender` has permission for the given kind/type of account.\n', '     *\n', '     *    - The `owner` account is always allowed\n', '     *    - Addresses/Contracts must have a corresponding entry, for the given kind\n', '     */\n', '    modifier isAllowed(uint8 kind) {\n', '        require(kind > 0, "Invalid, or missing permission");\n', '        if (msg.sender != owner) {\n', '            require(permissions[kind].exists(msg.sender), "Missing permission");\n', '        }\n', '        _;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     *  Adds an account to storage\n', '     *  THROWS when `msg.sender` doesn&#39;t have permission\n', '     *  THROWS when the account already exists\n', '     *  @param addr The address of the account\n', '     *  @param kind The kind of account\n', '     *  @param isFrozen The frozen status of the account\n', '     *  @param parent The account parent/owner\n', '     */\n', '    function addAccount(address addr, uint8 kind, bool isFrozen, address parent)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        require(accounts.append(addr, kind, isFrozen, parent), "Account already exists");\n', '    }\n', '\n', '    /**\n', '     *  Sets an account&#39;s frozen status\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the account\n', '     *  @param frozen The frozen status of the account\n', '     */\n', '    function setAccountFrozen(address addr, bool frozen)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        // NOTE: Not bounds checking `index` here, as `isAllowed` ensures the address exists.\n', '        //       Indices are one-based internally, so we need to add one to compensate.\n', '        int256 index = accounts.indexOf(addr) + 1;\n', '        accounts.items[index].frozen = frozen;\n', '    }\n', '\n', '    /**\n', '     *  Removes an account from storage\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the account\n', '     */\n', '    function removeAccount(address addr)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        bytes32 ZERO_BYTES = bytes32(0);\n', '        mapping(uint8 => bytes32) storage accountData = data[addr];\n', '\n', '        // Remove data\n', '        for (uint8 i = 0; i < MAX_DATA; i++) {\n', '            if (accountData[i] != ZERO_BYTES) {\n', '                delete accountData[i];\n', '            }\n', '        }\n', '\n', '        // Remove account\n', '        accounts.remove(addr);\n', '    }\n', '\n', '    /**\n', '     *  Sets data for an address/caller\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address\n', '     *  @param index The index of the data\n', '     *  @param customData The data store set\n', '     */\n', '    function setAccountData(address addr, uint8 index, bytes32 customData)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        require(index < MAX_DATA, "index outside of bounds");\n', '        data[addr][index] = customData;\n', '    }\n', '\n', '    /**\n', '     *  Grants the address permission for the given kind\n', '     *  @param kind The kind of address\n', '     *  @param addr The address\n', '     */\n', '    function grantPermission(uint8 kind, address addr)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        permissions[kind].append(addr);\n', '    }\n', '\n', '    /**\n', '     *  Revokes the address permission for the given kind\n', '     *  @param kind The kind of address\n', '     *  @param addr The address\n', '     */\n', '    function revokePermission(uint8 kind, address addr)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        permissions[kind].remove(addr);\n', '    }\n', '\n', '    // ---------------------------- Address Getters ----------------------------\n', '    /**\n', '     *  Gets the account at the given index\n', '     *  THROWS when the index is out-of-bounds\n', '     *  @param index The index of the item to retrieve\n', '     *  @return The address, kind, frozen status, and parent of the account at the given index\n', '     */\n', '    function accountAt(int256 index)\n', '    external\n', '    view\n', '    returns(address, uint8, bool, address) {\n', '        AccountMap.Account memory acct = accounts.at(index);\n', '        return (acct.addr, acct.kind, acct.frozen, acct.parent);\n', '    }\n', '\n', '    /**\n', '     *  Gets the account for the given address\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the item to retrieve\n', '     *  @return The address, kind, frozen status, and parent of the account at the given index\n', '     */\n', '    function accountGet(address addr)\n', '    external\n', '    view\n', '    returns(uint8, bool, address) {\n', '        AccountMap.Account memory acct = accounts.get(addr);\n', '        return (acct.kind, acct.frozen, acct.parent);\n', '    }\n', '\n', '    /**\n', '     *  Gets the parent address for the given account address\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the account\n', '     *  @return The parent address\n', '     */\n', '    function accountParent(address addr)\n', '    external\n', '    view\n', '    returns(address) {\n', '        return accounts.get(addr).parent;\n', '    }\n', '\n', '    /**\n', '     *  Gets the account kind, for the given account address\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the account\n', '     *  @return The kind of account\n', '     */\n', '    function accountKind(address addr)\n', '    external\n', '    view\n', '    returns(uint8) {\n', '        return accounts.get(addr).kind;\n', '    }\n', '\n', '    /**\n', '     *  Gets the frozen status of the account\n', '     *  THROWS when the account doesn&#39;t exist\n', '     *  @param addr The address of the account\n', '     *  @return The frozen status of the account\n', '     */\n', '    function accountFrozen(address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return accounts.get(addr).frozen;\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the account\n', '     *  Returns -1 for missing accounts\n', '     *  @param addr The address of the account to get the index for\n', '     *  @return The index of the given account address\n', '     */\n', '    function accountIndexOf(address addr)\n', '    external\n', '    view\n', '    returns(int256) {\n', '        return accounts.indexOf(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given address exists\n', '     *  @param addr The account address\n', '     *  @return If the given address exists\n', '     */\n', '    function accountExists(address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return accounts.exists(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given address exists for the given kind\n', '     *  @param addr The account address\n', '     *  @param kind The kind of address\n', '     *  @return If the given address exists with the given kind\n', '     */\n', '    function accountExists(address addr, uint8 kind)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        int256 index = accounts.indexOf(addr);\n', '        if (index < 0) {\n', '            return false;\n', '        }\n', '        return accounts.at(index).kind == kind;\n', '    }\n', '\n', '\n', '    // -------------------------- Permission Getters ---------------------------\n', '    /**\n', '     *  Retrieves the permission address at the index for the given type\n', '     *  THROWS when the index is out-of-bounds\n', '     *  @param kind The kind of permission\n', '     *  @param index The index of the item to retrieve\n', '     *  @return The permission address of the item at the given index\n', '     */\n', '    function permissionAt(uint8 kind, int256 index)\n', '    external\n', '    view\n', '    returns(address) {\n', '        return permissions[kind].at(index);\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the permission address for the given type\n', '     *  Returns -1 for missing permission\n', '     *  @param kind The kind of perission\n', '     *  @param addr The address of the permission to get the index for\n', '     *  @return The index of the given permission address\n', '     */\n', '    function permissionIndexOf(uint8 kind, address addr)\n', '    external\n', '    view\n', '    returns(int256) {\n', '        return permissions[kind].indexOf(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given permission address exists for the given type\n', '     *  @param kind The kind of permission\n', '     *  @param addr The address to check for permission\n', '     *  @return If the given address has permission or not\n', '     */\n', '    function permissionExists(uint8 kind, address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return permissions[kind].exists(addr);\n', '    }\n', '\n', '}\n', '\n', '\n', 'interface ComplianceRule {\n', '\n', '    /**\n', '     *  @dev Checks if a transfer can occur between the from/to addresses and MUST throw when the check fails.\n', '     *  @param initiator The address initiating the transfer.\n', '     *  @param from The address of the sender\n', '     *  @param to The address of the receiver\n', '     *  @param toKind The kind of the to address\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @param store The Storage contract\n', '     */\n', '    function check(address initiator, address from, address to, uint8 toKind, uint256 tokens, Storage store)\n', '    external;\n', '}\n', '\n', 'interface Compliance {\n', '\n', '    /**\n', '     *  This event is emitted when an address&#39;s frozen status has changed.\n', '     *  @param addr The address whose frozen status has been updated.\n', '     *  @param isFrozen Whether the custodian is being frozen.\n', '     *  @param owner The address that updated the frozen status.\n', '     */\n', '    event AddressFrozen(\n', '        address indexed addr,\n', '        bool indexed isFrozen,\n', '        address indexed owner\n', '    );\n', '\n', '    /**\n', '     *  Sets an address frozen status for this token\n', '     *  @param addr The address to update frozen status.\n', '     *  @param freeze Frozen status of the address.\n', '     */\n', '    function setFrozen(address addr, bool freeze)\n', '    external;\n', '\n', '    /**\n', '     *  Replaces all of the existing rules with the given ones\n', '     *  @param kind The bucket of rules to set.\n', '     *  @param rules New compliance rules.\n', '     */\n', '    function setRules(uint8 kind, ComplianceRule[] calldata rules)\n', '    external;\n', '\n', '    /**\n', '     *  Returns all of the current compliance rules for this token\n', '     *  @param kind The bucket of rules to get.\n', '     *  @return List of all compliance rules.\n', '     */\n', '    function getRules(uint8 kind)\n', '    external\n', '    view\n', '    returns (ComplianceRule[] memory);\n', '\n', '    /**\n', '     *  @dev Checks if issuance can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted and unfrozen\n', '     *  THROWS when the transfer should fail.\n', '     *  @param issuer The address initiating the issuance.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If a issuance can occur between the from/to addresses.\n', '     */\n', '    function canIssue(address issuer, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '\n', '    /**\n', '     *  @dev Checks if a transfer can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted, unfrozen, and pass all compliance rule checks.\n', '     *  THROWS when the transfer should fail.\n', '     *  @param initiator The address initiating the transfer.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If a transfer can occur between the from/to addresses.\n', '     */\n', '    function canTransfer(address initiator, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '\n', '    /**\n', '     *  @dev Checks if an override by the sender can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted and unfrozen.\n', '     *  THROWS when the sender is not allowed to override.\n', '     *  @param admin The address initiating the transfer.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If an override can occur between the from/to addresses.\n', '     */\n', '    function canOverride(address admin, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'contract T0ken is ERC20, Ownable, LockableDestroyable {\n', '\n', '    // ------------------------------- Variables -------------------------------\n', '\n', '    using AdditiveMath for uint256;\n', '    using AddressMap for AddressMap.Data;\n', '\n', '    address constant internal ZERO_ADDRESS = address(0);\n', '    string public constant name = "TZERO PREFERRED";\n', '    string public constant symbol = "TZROP";\n', '    uint8 public constant decimals = 0;\n', '\n', '    AddressMap.Data public shareholders;\n', '    Compliance public compliance;\n', '    address public issuer;\n', '    bool public issuingFinished = false;\n', '    mapping(address => address) public cancellations;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    uint256 internal totalSupplyTokens;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '\n', '    // ------------------------------- Modifiers -------------------------------\n', '\n', '    modifier onlyIssuer() {\n', '        require(msg.sender == issuer, "Only issuer allowed");\n', '        _;\n', '    }\n', '\n', '    modifier canIssue() {\n', '        require(!issuingFinished, "Issuing is already finished");\n', '        _;\n', '    }\n', '\n', '    modifier isNotCancelled(address addr) {\n', '        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");\n', '        _;\n', '    }\n', '\n', '    modifier hasFunds(address addr, uint256 tokens) {\n', '        require(tokens <= balances[addr], "Insufficient funds");\n', '        _;\n', '    }\n', '\n', '    // -------------------------------- Events ---------------------------------\n', '\n', '    /**\n', '     *  This event is emitted when an address is cancelled and replaced with\n', '     *  a new address.  This happens in the case where a shareholder has\n', '     *  lost access to their original address and needs to have their share\n', '     *  reissued to a new address.  This is the equivalent of issuing replacement\n', '     *  share certificates.\n', '     *  @param original The address being superseded.\n', '     *  @param replacement The new address.\n', '     *  @param sender The address that caused the address to be superseded.\n', '    */\n', '    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);\n', '    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);\n', '    event Issue(address indexed to, uint256 tokens);\n', '    event IssueFinished();\n', '    event ShareholderAdded(address shareholder);\n', '    event ShareholderRemoved(address shareholder);\n', '\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     *  @dev Transfers tokens to the whitelisted account.\n', '     *\n', '     *  If the &#39;to&#39; address is not currently a shareholder then it MUST become one.\n', '     *  If the transfer will reduce &#39;msg.sender&#39; balance to 0, then that address MUST be removed\n', '     *  from the list of shareholders.\n', '     *  MUST be removed from the list of shareholders.\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens The number of tokens to be transferred.\n', '     */\n', '    function transfer(address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(msg.sender, tokens)\n', '    returns (bool) {\n', '        bool transferAllowed;\n', '\n', '        // Issuance\n', '        if (msg.sender == issuer) {\n', '            transferAllowed = address(compliance) == ZERO_ADDRESS;\n', '            if (!transferAllowed) {\n', '                transferAllowed = compliance.canIssue(issuer, issuer, to, tokens);\n', '            }\n', '        }\n', '        // Transfer\n', '        else {\n', '            transferAllowed = canTransfer(msg.sender, to, tokens, false);\n', '        }\n', '\n', '        // Ensure the transfer is allowed.\n', '        if (transferAllowed) {\n', '            transferTokens(msg.sender, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', '     *  @dev Transfers tokens between whitelisted accounts.\n', '     *\n', '     *  If the &#39;to&#39; address is not currently a shareholder then it MUST become one.\n', '     *  If the transfer will reduce &#39;from&#39; balance to 0 then that address MUST be removed from the list of shareholders.\n', '     *  @param from The address to transfer from\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens uint256 the number of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(from, tokens)\n', '    returns (bool) {\n', '        require(tokens <= allowed[from][msg.sender], "Transfer exceeds allowance");\n', '\n', '        // Transfer the tokens\n', '        bool transferAllowed = canTransfer(from, to, tokens, false);\n', '        if (transferAllowed) {\n', '            // Update the allowance to reflect the transfer\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);\n', '            // Transfer the tokens\n', '            transferTokens(from, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', '     *  @dev Overrides a transfer of tokens to the whitelisted account.\n', '     *\n', '     *  If the &#39;to&#39; address is not currently a shareholder then it MUST become one.\n', '     *  If the transfer will reduce &#39;msg.sender&#39; balance to 0, then that address MUST be removed\n', '     *  from the list of shareholders.\n', '     *  MUST be removed from the list of shareholders.\n', '     *  @param from The address to transfer from\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens The number of tokens to be transferred.\n', '     */\n', '    function transferOverride(address from, address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(from, tokens)\n', '    returns (bool) {\n', '        // Ensure the sender can perform the override.\n', '        bool transferAllowed = canTransfer(from, to, tokens, true);\n', '        // Ensure the transfer is allowed.\n', '        if (transferAllowed) {\n', '            transferTokens(from, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', '     *  @dev Tokens will be issued to the issuer&#39;s address only.\n', '     *  @param quantity The number of tokens to mint.\n', '     *  @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function issueTokens(uint256 quantity)\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    canIssue\n', '    returns (bool) {\n', '        // Avoid doing any state changes for zero quantities\n', '        if (quantity > 0) {\n', '            totalSupplyTokens = totalSupplyTokens.add(quantity);\n', '            balances[issuer] = balances[issuer].add(quantity);\n', '            shareholders.append(issuer);\n', '        }\n', '        emit Issue(issuer, quantity);\n', '        emit Transfer(ZERO_ADDRESS, issuer, quantity);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Finishes token issuance.\n', '     *  This is a single use function, once invoked it cannot be undone.\n', '     */\n', '    function finishIssuing()\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    canIssue\n', '    returns (bool) {\n', '        issuingFinished = true;\n', '        emit IssueFinished();\n', '        return issuingFinished;\n', '    }\n', '\n', '    /**\n', '     *  @dev Cancel the original address and reissue the Tokens to the replacement address.\n', '     *\n', '     *  Access to this function is restricted to the Issuer only.\n', '     *  The &#39;original&#39; address MUST be removed from the set of whitelisted addresses.\n', '     *  Throw if the &#39;original&#39; address supplied is not a shareholder.\n', '     *  Throw if the &#39;replacement&#39; address is not a whitelisted address.\n', '     *  This function MUST emit the &#39;VerifiedAddressSuperseded&#39; event.\n', '     *  @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.\n', '     *  @param replacement The address  that supersedes the original. This address MUST be whitelisted.\n', '     */\n', '    function cancelAndReissue(address original, address replacement)\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    isNotCancelled(replacement) {\n', '        // Ensure the reissue can take place\n', '        require(shareholders.exists(original) && !shareholders.exists(replacement), "Original doesn&#39;t exist or replacement does");\n', '        if (address(compliance) != ZERO_ADDRESS) {\n', '            require(compliance.canIssue(msg.sender, original, replacement, balances[original]), "Failed &#39;canIssue&#39; check.");\n', '        }\n', '\n', '        // Replace the original shareholder with the replacement\n', '        shareholders.remove(original);\n', '        shareholders.append(replacement);\n', '        // Add the original as a cancelled address (preventing it from future trading)\n', '        cancellations[original] = replacement;\n', '        // Transfer the balance to the replacement\n', '        balances[replacement] = balances[original];\n', '        balances[original] = 0;\n', '        emit VerifiedAddressSuperseded(original, replacement, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified number of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param tokens The number of tokens of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(msg.sender)\n', '    returns (bool) {\n', '        require(shareholders.exists(msg.sender), "Must be a shareholder to approve token transfer");\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Set the issuer address.\n', '     *  @param newIssuer The address of the issuer.\n', '     */\n', '    function setIssuer(address newIssuer)\n', '    external\n', '    isUnlocked\n', '    onlyOwner {\n', '        issuer = newIssuer;\n', '        emit IssuerSet(issuer, newIssuer);\n', '    }\n', '\n', '    /**\n', '     *  @dev Sets the compliance contract address to use during transfers.\n', '     *  @param newComplianceAddress The address of the compliance contract.\n', '     */\n', '    function setCompliance(address newComplianceAddress)\n', '    external\n', '    isUnlocked\n', '    onlyOwner {\n', '        compliance = Compliance(newComplianceAddress);\n', '    }\n', '\n', '    // -------------------------------- Getters --------------------------------\n', '\n', '    /**\n', '     *  @dev Returns the total token supply\n', '     *  @return total number of tokens in existence\n', '     */\n', '    function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return totalSupplyTokens;\n', '    }\n', '\n', '    /**\n', '     *  @dev Gets the balance of the specified address.\n', '     *  @param addr The address to query the the balance of.\n', '     *  @return An uint256 representing the tokens owned by the passed address.\n', '     */\n', '    function balanceOf(address addr)\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return balances[addr];\n', '    }\n', '\n', '    /**\n', '     *  @dev Gets the number of tokens that an owner has allowed the spender to transfer.\n', '     *  @param addrOwner address The address which owns the funds.\n', '     *  @param spender address The address which will spend the funds.\n', '     *  @return A uint256 specifying the number of tokens still available for the spender.\n', '     */\n', '    function allowance(address addrOwner, address spender)\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return allowed[addrOwner][spender];\n', '    }\n', '\n', '    /**\n', '     *  By counting the number of token holders using &#39;holderCount&#39;\n', '     *  you can retrieve the complete list of token holders, one at a time.\n', '     *  It MUST throw if &#39;index >= holderCount()&#39;.\n', '     *  @dev Returns the holder at the given index.\n', '     *  @param index The zero-based index of the holder.\n', '     *  @return the address of the token holder with the given index.\n', '     */\n', '    function holderAt(int256 index)\n', '    external\n', '    view\n', '    returns (address){\n', '        return shareholders.at(index);\n', '    }\n', '\n', '    /**\n', '     *  @dev Checks to see if the supplied address is a share holder.\n', '     *  @param addr The address to check.\n', '     *  @return true if the supplied address owns a token.\n', '     */\n', '    function isHolder(address addr)\n', '    external\n', '    view\n', '    returns (bool) {\n', '        return shareholders.exists(addr);\n', '    }\n', '\n', '    /**\n', '     *  @dev Checks to see if the supplied address was superseded.\n', '     *  @param addr The address to check.\n', '     *  @return true if the supplied address was superseded by another address.\n', '     */\n', '    function isSuperseded(address addr)\n', '    external\n', '    view\n', '    returns (bool) {\n', '        return cancellations[addr] != ZERO_ADDRESS;\n', '    }\n', '\n', '    /**\n', '     *  Gets the most recent address, given a superseded one.\n', '     *  Addresses may be superseded multiple times, so this function needs to\n', '     *  follow the chain of addresses until it reaches the final, verified address.\n', '     *  @param addr The superseded address.\n', '     *  @return the verified address that ultimately holds the share.\n', '     */\n', '    function getSuperseded(address addr)\n', '    external\n', '    view\n', '    returns (address) {\n', '        require(addr != ZERO_ADDRESS, "Non-zero address required");\n', '\n', '        address candidate = cancellations[addr];\n', '        if (candidate == ZERO_ADDRESS) {\n', '            return ZERO_ADDRESS;\n', '        }\n', '        return candidate;\n', '    }\n', '\n', '\n', '    // -------------------------------- Private --------------------------------\n', '\n', '    /**\n', '     *  @dev Checks if a transfer/override may take place between the two accounts.\n', '     *\n', '     *   Validates that the transfer can take place.\n', '     *     - Ensure the &#39;to&#39; address is not cancelled\n', '     *     - Ensure the transfer is compliant\n', '     *  @param from The sender address.\n', '     *  @param to The recipient address.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @param isOverride If this is a transfer override\n', '     *  @return If the transfer can take place.\n', '     */\n', '    function canTransfer(address from, address to, uint256 tokens, bool isOverride)\n', '    private\n', '    isNotCancelled(to)\n', '    returns (bool) {\n', '        // Don&#39;t allow overrides and ignore compliance rules when compliance not set.\n', '        if (address(compliance) == ZERO_ADDRESS) {\n', '            return !isOverride;\n', '        }\n', '\n', '        // Ensure the override is valid, or that the transfer is compliant.\n', '        if (isOverride) {\n', '            return compliance.canOverride(msg.sender, from, to, tokens);\n', '        } else {\n', '            return compliance.canTransfer(msg.sender, from, to, tokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  @dev Transfers tokens from one address to another\n', '     *  @param from The sender address.\n', '     *  @param to The recipient address.\n', '     *  @param tokens The number of tokens being transferred.\n', '     */\n', '    function transferTokens(address from, address to, uint256 tokens)\n', '    private {\n', '        // Update balances\n', '        balances[from] = balances[from].subtract(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '\n', '        // Adds the shareholder if they don&#39;t already exist.\n', '        if (balances[to] > 0 && shareholders.append(to)) {\n', '            emit ShareholderAdded(to);\n', '        }\n', '        // Remove the shareholder if they no longer hold tokens.\n', '        if (balances[from] == 0 && shareholders.remove(from)) {\n', '            emit ShareholderRemoved(from);\n', '        }\n', '    }\n', '\n', '}']
['/**\n', ' * Licensed to the Apache Software Foundation (ASF) under one\n', ' * or more contributor license agreements.  See the NOTICE file\n', ' * distributed with this work for additional information\n', ' * regarding copyright ownership.  The ASF licenses this file\n', ' * to you under the Apache License, Version 2.0 (the\n', ' * "License"); you may not use this file except in compliance\n', ' * with the License.  You may obtain a copy of the License at\n', ' * \n', ' *   http://www.apache.org/licenses/LICENSE-2.0\n', ' * \n', ' * Unless required by applicable law or agreed to in writing,\n', ' * software distributed under the License is distributed on an\n', ' * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n', ' * KIND, either express or implied.  See the License for the\n', ' * specific language governing permissions and limitations\n', ' * under the License.\n', ' */\n', '\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' *  @title Ownable\n', ' *  @dev Provides a modifier that requires the caller to be the owner of the contract.\n', ' */\n', 'contract Ownable {\n', '    address payable public owner;\n', '\n', '    event OwnerTransferred(\n', '        address indexed oldOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Owner account is required");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwner(address payable newOwner)\n', '    public\n', '    onlyOwner {\n', '        require(newOwner != owner, "New Owner cannot be the current owner");\n', '        require(newOwner != address(0), "New Owner cannot be zero address");\n', '        address payable prevOwner = owner;\n', '        owner = newOwner;\n', '        emit OwnerTransferred(prevOwner, newOwner);\n', '    }\n', '}\n', '\n', '/**\n', ' *  @title Lockable\n', ' *  @dev The Lockable contract adds the ability for the contract owner to set the lock status\n', ' *  of the account. A modifier is provided that checks the throws when the contract is\n', ' *  in the locked state.\n', ' */\n', 'contract Lockable is Ownable {\n', '    bool public isLocked;\n', '\n', '    constructor() public {\n', '        isLocked = false;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '        require(!isLocked, "Contract is currently locked for modification");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     *  Set the contract to a read-only state.\n', '     *  @param locked The locked state to set the contract to.\n', '     */\n', '    function setLocked(bool locked)\n', '    onlyOwner\n', '    external {\n', '        require(isLocked != locked, "Contract already in requested lock state");\n', '\n', '        isLocked = locked;\n', '    }\n', '}\n', '\n', '/**\n', ' *  @title Destroyable\n', ' *  @dev The Destroyable contract alows the owner address to `selfdestruct` the contract.\n', ' */\n', 'contract Destroyable is Ownable {\n', '    /**\n', '     *  Allow the owner to destroy this contract.\n', '     */\n', '    function kill()\n', '    onlyOwner\n', '    external {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' *  Contract to facilitate locking and self destructing.\n', ' */\n', 'contract LockableDestroyable is Lockable, Destroyable { }\n', '\n', 'library AdditiveMath {\n', '    /**\n', '     *  Adds two numbers and returns the result\n', '     *  THROWS when the result overflows\n', '     *  @return The sum of the arguments\n', '     */\n', '    function add(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256) {\n', '        uint256 sum = x + y;\n', '        require(sum >= x, "Results in overflow");\n', '        return sum;\n', '    }\n', '\n', '    /**\n', '     *  Subtracts two numbers and returns the result\n', '     *  THROWS when the result underflows\n', '     *  @return The difference of the arguments\n', '     */\n', '    function subtract(uint256 x, uint256 y)\n', '    internal\n', '    pure\n', '    returns (uint256) {\n', '        require(y <= x, "Results in underflow");\n', '        return x - y;\n', '    }\n', '}\n', '\n', '/**\n', ' *\n', ' *  @title AddressMap\n', ' *  @dev Map of unique indexed addresseses.\n', ' *\n', ' *  **NOTE**\n', ' *    The internal collections are one-based.\n', ' *    This is simply because null values are expressed as zero,\n', ' *    which makes it hard to check for the existence of items within the array,\n', ' *    or grabbing the first item of an array for non-existent items.\n', ' *\n', ' *    This is only exposed internally, so callers still use zero-based indices.\n', ' *\n', ' */\n', 'library AddressMap {\n', '    struct Data {\n', '        int256 count;\n', '        mapping(address => int256) indices;\n', '        mapping(int256 => address) items;\n', '    }\n', '\n', '    address constant ZERO_ADDRESS = address(0);\n', '\n', '    /**\n', '     *  Appends the address to the end of the map, if the address is not\n', "     *  zero and the address doesn't currently exist.\n", '     *  @param addr The address to append.\n', '     *  @return true if the address was added.\n', '     */\n', '    function append(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return false;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index >= 0 && index < self.count) {\n', '            return false;\n', '        }\n', '\n', '        self.count++;\n', '        self.indices[addr] = self.count;\n', '        self.items[self.count] = addr;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Removes the given address from the map.\n', '     *  @param addr The address to remove from the map.\n', '     *  @return true if the address was removed.\n', '     */\n', '    function remove(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        int256 oneBasedIndex = self.indices[addr];\n', '        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\n', "            return false;  // address doesn't exist, or zero.\n", '        }\n', '\n', '        // When the item being removed is not the last item in the collection,\n', '        // replace that item with the last one, otherwise zero it out.\n', '        //\n', '        //  If {2} is the item to be removed\n', '        //     [0, 1, 2, 3, 4]\n', '        //  The result would be:\n', '        //     [0, 1, 4, 3]\n', '        //\n', '        if (oneBasedIndex < self.count) {\n', '            // Replace with last item\n', '            address last = self.items[self.count];  // Get the last item\n', '            self.indices[last] = oneBasedIndex;     // Update last items index to current index\n', '            self.items[oneBasedIndex] = last;       // Update current index to last item\n', "            delete self.items[self.count];          // Delete the last item, since it's moved\n", '        } else {\n', '            // Delete the address\n', '            delete self.items[oneBasedIndex];\n', '        }\n', '\n', '        delete self.indices[addr];\n', '        self.count--;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Clears all items within the map.\n', '     */\n', '    function clear(Data storage self)\n', '    internal {\n', '        self.count = 0;\n', '    }\n', '\n', '    /**\n', '     *  Retrieves the address at the given index.\n', '     *  THROWS when the index is invalid.\n', '     *  @param index The index of the item to retrieve.\n', '     *  @return The address of the item at the given index.\n', '     */\n', '    function at(Data storage self, int256 index)\n', '    internal\n', '    view\n', '    returns (address) {\n', '        require(index >= 0 && index < self.count, "Index outside of bounds.");\n', '        return self.items[index + 1];\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the given address.\n', '     *  @param addr The address of the item to get the index for.\n', '     *  @return The index of the given address.\n', '     */\n', '    function indexOf(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (int256) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return -1;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index < 0 || index >= self.count) {\n', '            return -1;\n', '        }\n', '        return index;\n', '    }\n', '\n', '    /**\n', '     *  Returns whether or not the given address exists within the map.\n', '     *  @param addr The address to check for existence.\n', '     *  @return If the given address exists or not.\n', '     */\n', '    function exists(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (bool) {\n', '        int256 index = self.indices[addr] - 1;\n', '        return index >= 0 && index < self.count;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' *\n', ' *  @title AccountMap\n', ' *  @dev Map of unique indexed accounts.\n', ' *\n', ' *  **NOTE**\n', ' *    The internal collections are one-based.\n', ' *    This is simply because null values are expressed as zero,\n', ' *    which makes it hard to check for the existence of items within the array,\n', ' *    or grabbing the first item of an array for non-existent items.\n', ' *\n', ' *    This is only exposed internally, so callers still use zero-based indices.\n', ' *\n', ' */\n', 'library AccountMap {\n', '    struct Account {\n', '        address addr;\n', '        uint8 kind;\n', '        bool frozen;\n', '        address parent;\n', '    }\n', '\n', '    struct Data {\n', '        int256 count;\n', '        mapping(address => int256) indices;\n', '        mapping(int256 => Account) items;\n', '    }\n', '\n', '    address constant ZERO_ADDRESS = address(0);\n', '\n', '    /**\n', '     *  Appends the address to the end of the map, if the addres is not\n', "     *  zero and the address doesn't currently exist.\n", '     *  @param addr The address to append.\n', '     *  @return true if the address was added.\n', '     */\n', '    function append(Data storage self, address addr, uint8 kind, bool isFrozen, address parent)\n', '    internal\n', '    returns (bool) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return false;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index >= 0 && index < self.count) {\n', '            return false;\n', '        }\n', '\n', '        self.count++;\n', '        self.indices[addr] = self.count;\n', '        self.items[self.count] = Account(addr, kind, isFrozen, parent);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Removes the given address from the map.\n', '     *  @param addr The address to remove from the map.\n', '     *  @return true if the address was removed.\n', '     */\n', '    function remove(Data storage self, address addr)\n', '    internal\n', '    returns (bool) {\n', '        int256 oneBasedIndex = self.indices[addr];\n', '        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\n', "            return false;  // address doesn't exist, or zero.\n", '        }\n', '\n', '        // When the item being removed is not the last item in the collection,\n', '        // replace that item with the last one, otherwise zero it out.\n', '        //\n', '        //  If {2} is the item to be removed\n', '        //     [0, 1, 2, 3, 4]\n', '        //  The result would be:\n', '        //     [0, 1, 4, 3]\n', '        //\n', '        if (oneBasedIndex < self.count) {\n', '            // Replace with last item\n', '            Account storage last = self.items[self.count];  // Get the last item\n', '            self.indices[last.addr] = oneBasedIndex;        // Update last items index to current index\n', '            self.items[oneBasedIndex] = last;               // Update current index to last item\n', "            delete self.items[self.count];                  // Delete the last item, since it's moved\n", '        } else {\n', '            // Delete the account\n', '            delete self.items[oneBasedIndex];\n', '        }\n', '\n', '        delete self.indices[addr];\n', '        self.count--;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Clears all items within the map.\n', '     */\n', '    function clear(Data storage self)\n', '    internal {\n', '        self.count = 0;\n', '    }\n', '\n', '    /**\n', '     *  Retrieves the address at the given index.\n', '     *  THROWS when the index is invalid.\n', '     *  @param index The index of the item to retrieve.\n', '     *  @return The address of the item at the given index.\n', '     */\n', '    function at(Data storage self, int256 index)\n', '    internal\n', '    view\n', '    returns (Account memory) {\n', '        require(index >= 0 && index < self.count, "Index outside of bounds.");\n', '        return self.items[index + 1];\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the given address.\n', '     *  @param addr The address of the item to get the index for.\n', '     *  @return The index of the given address.\n', '     */\n', '    function indexOf(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (int256) {\n', '        if (addr == ZERO_ADDRESS) {\n', '            return -1;\n', '        }\n', '\n', '        int256 index = self.indices[addr] - 1;\n', '        if (index < 0 || index >= self.count) {\n', '            return -1;\n', '        }\n', '        return index;\n', '    }\n', '\n', '    /**\n', '     *  Gets the Account for the given address.\n', "     *  THROWS when an account doesn't exist for the given address.\n", '     *  @param addr The address of the item to get.\n', '     *  @return The account of the given address.\n', '     */\n', '    function get(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (Account memory) {\n', '        return at(self, indexOf(self, addr));\n', '    }\n', '\n', '    /**\n', '     *  Returns whether or not the given address exists within the map.\n', '     *  @param addr The address to check for existence.\n', '     *  @return If the given address exists or not.\n', '     */\n', '    function exists(Data storage self, address addr)\n', '    internal\n', '    view\n', '    returns (bool) {\n', '        int256 index = self.indices[addr] - 1;\n', '        return index >= 0 && index < self.count;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' *  @title Registry Storage\n', ' */\n', 'contract Storage is Ownable, LockableDestroyable {\n', '  \n', '    using AccountMap for AccountMap.Data;\n', '    using AddressMap for AddressMap.Data;\n', '\n', '    // ------------------------------- Variables -------------------------------\n', '    // Number of data slots available for accounts\n', '    uint8 constant MAX_DATA = 30;\n', '\n', '    // Accounts\n', '    AccountMap.Data public accounts;\n', '\n', '    // Account Data\n', '    //   - mapping of:\n', '    //     (address        => (index =>    data))\n', '    mapping(address => mapping(uint8 => bytes32)) public data;\n', '\n', '    // Address write permissions\n', '    //     (kind  => address)\n', '    mapping(uint8 => AddressMap.Data) public permissions;\n', '\n', '\n', '    // ------------------------------- Modifiers -------------------------------\n', '    /**\n', '     *  Ensures the `msg.sender` has permission for the given kind/type of account.\n', '     *\n', '     *    - The `owner` account is always allowed\n', '     *    - Addresses/Contracts must have a corresponding entry, for the given kind\n', '     */\n', '    modifier isAllowed(uint8 kind) {\n', '        require(kind > 0, "Invalid, or missing permission");\n', '        if (msg.sender != owner) {\n', '            require(permissions[kind].exists(msg.sender), "Missing permission");\n', '        }\n', '        _;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     *  Adds an account to storage\n', "     *  THROWS when `msg.sender` doesn't have permission\n", '     *  THROWS when the account already exists\n', '     *  @param addr The address of the account\n', '     *  @param kind The kind of account\n', '     *  @param isFrozen The frozen status of the account\n', '     *  @param parent The account parent/owner\n', '     */\n', '    function addAccount(address addr, uint8 kind, bool isFrozen, address parent)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        require(accounts.append(addr, kind, isFrozen, parent), "Account already exists");\n', '    }\n', '\n', '    /**\n', "     *  Sets an account's frozen status\n", "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the account\n', '     *  @param frozen The frozen status of the account\n', '     */\n', '    function setAccountFrozen(address addr, bool frozen)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        // NOTE: Not bounds checking `index` here, as `isAllowed` ensures the address exists.\n', '        //       Indices are one-based internally, so we need to add one to compensate.\n', '        int256 index = accounts.indexOf(addr) + 1;\n', '        accounts.items[index].frozen = frozen;\n', '    }\n', '\n', '    /**\n', '     *  Removes an account from storage\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the account\n', '     */\n', '    function removeAccount(address addr)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        bytes32 ZERO_BYTES = bytes32(0);\n', '        mapping(uint8 => bytes32) storage accountData = data[addr];\n', '\n', '        // Remove data\n', '        for (uint8 i = 0; i < MAX_DATA; i++) {\n', '            if (accountData[i] != ZERO_BYTES) {\n', '                delete accountData[i];\n', '            }\n', '        }\n', '\n', '        // Remove account\n', '        accounts.remove(addr);\n', '    }\n', '\n', '    /**\n', '     *  Sets data for an address/caller\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address\n', '     *  @param index The index of the data\n', '     *  @param customData The data store set\n', '     */\n', '    function setAccountData(address addr, uint8 index, bytes32 customData)\n', '    isUnlocked\n', '    isAllowed(accounts.get(addr).kind)\n', '    external {\n', '        require(index < MAX_DATA, "index outside of bounds");\n', '        data[addr][index] = customData;\n', '    }\n', '\n', '    /**\n', '     *  Grants the address permission for the given kind\n', '     *  @param kind The kind of address\n', '     *  @param addr The address\n', '     */\n', '    function grantPermission(uint8 kind, address addr)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        permissions[kind].append(addr);\n', '    }\n', '\n', '    /**\n', '     *  Revokes the address permission for the given kind\n', '     *  @param kind The kind of address\n', '     *  @param addr The address\n', '     */\n', '    function revokePermission(uint8 kind, address addr)\n', '    isUnlocked\n', '    isAllowed(kind)\n', '    external {\n', '        permissions[kind].remove(addr);\n', '    }\n', '\n', '    // ---------------------------- Address Getters ----------------------------\n', '    /**\n', '     *  Gets the account at the given index\n', '     *  THROWS when the index is out-of-bounds\n', '     *  @param index The index of the item to retrieve\n', '     *  @return The address, kind, frozen status, and parent of the account at the given index\n', '     */\n', '    function accountAt(int256 index)\n', '    external\n', '    view\n', '    returns(address, uint8, bool, address) {\n', '        AccountMap.Account memory acct = accounts.at(index);\n', '        return (acct.addr, acct.kind, acct.frozen, acct.parent);\n', '    }\n', '\n', '    /**\n', '     *  Gets the account for the given address\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the item to retrieve\n', '     *  @return The address, kind, frozen status, and parent of the account at the given index\n', '     */\n', '    function accountGet(address addr)\n', '    external\n', '    view\n', '    returns(uint8, bool, address) {\n', '        AccountMap.Account memory acct = accounts.get(addr);\n', '        return (acct.kind, acct.frozen, acct.parent);\n', '    }\n', '\n', '    /**\n', '     *  Gets the parent address for the given account address\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the account\n', '     *  @return The parent address\n', '     */\n', '    function accountParent(address addr)\n', '    external\n', '    view\n', '    returns(address) {\n', '        return accounts.get(addr).parent;\n', '    }\n', '\n', '    /**\n', '     *  Gets the account kind, for the given account address\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the account\n', '     *  @return The kind of account\n', '     */\n', '    function accountKind(address addr)\n', '    external\n', '    view\n', '    returns(uint8) {\n', '        return accounts.get(addr).kind;\n', '    }\n', '\n', '    /**\n', '     *  Gets the frozen status of the account\n', "     *  THROWS when the account doesn't exist\n", '     *  @param addr The address of the account\n', '     *  @return The frozen status of the account\n', '     */\n', '    function accountFrozen(address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return accounts.get(addr).frozen;\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the account\n', '     *  Returns -1 for missing accounts\n', '     *  @param addr The address of the account to get the index for\n', '     *  @return The index of the given account address\n', '     */\n', '    function accountIndexOf(address addr)\n', '    external\n', '    view\n', '    returns(int256) {\n', '        return accounts.indexOf(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given address exists\n', '     *  @param addr The account address\n', '     *  @return If the given address exists\n', '     */\n', '    function accountExists(address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return accounts.exists(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given address exists for the given kind\n', '     *  @param addr The account address\n', '     *  @param kind The kind of address\n', '     *  @return If the given address exists with the given kind\n', '     */\n', '    function accountExists(address addr, uint8 kind)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        int256 index = accounts.indexOf(addr);\n', '        if (index < 0) {\n', '            return false;\n', '        }\n', '        return accounts.at(index).kind == kind;\n', '    }\n', '\n', '\n', '    // -------------------------- Permission Getters ---------------------------\n', '    /**\n', '     *  Retrieves the permission address at the index for the given type\n', '     *  THROWS when the index is out-of-bounds\n', '     *  @param kind The kind of permission\n', '     *  @param index The index of the item to retrieve\n', '     *  @return The permission address of the item at the given index\n', '     */\n', '    function permissionAt(uint8 kind, int256 index)\n', '    external\n', '    view\n', '    returns(address) {\n', '        return permissions[kind].at(index);\n', '    }\n', '\n', '    /**\n', '     *  Gets the index of the permission address for the given type\n', '     *  Returns -1 for missing permission\n', '     *  @param kind The kind of perission\n', '     *  @param addr The address of the permission to get the index for\n', '     *  @return The index of the given permission address\n', '     */\n', '    function permissionIndexOf(uint8 kind, address addr)\n', '    external\n', '    view\n', '    returns(int256) {\n', '        return permissions[kind].indexOf(addr);\n', '    }\n', '\n', '    /**\n', '     *  Returns wether or not the given permission address exists for the given type\n', '     *  @param kind The kind of permission\n', '     *  @param addr The address to check for permission\n', '     *  @return If the given address has permission or not\n', '     */\n', '    function permissionExists(uint8 kind, address addr)\n', '    external\n', '    view\n', '    returns(bool) {\n', '        return permissions[kind].exists(addr);\n', '    }\n', '\n', '}\n', '\n', '\n', 'interface ComplianceRule {\n', '\n', '    /**\n', '     *  @dev Checks if a transfer can occur between the from/to addresses and MUST throw when the check fails.\n', '     *  @param initiator The address initiating the transfer.\n', '     *  @param from The address of the sender\n', '     *  @param to The address of the receiver\n', '     *  @param toKind The kind of the to address\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @param store The Storage contract\n', '     */\n', '    function check(address initiator, address from, address to, uint8 toKind, uint256 tokens, Storage store)\n', '    external;\n', '}\n', '\n', 'interface Compliance {\n', '\n', '    /**\n', "     *  This event is emitted when an address's frozen status has changed.\n", '     *  @param addr The address whose frozen status has been updated.\n', '     *  @param isFrozen Whether the custodian is being frozen.\n', '     *  @param owner The address that updated the frozen status.\n', '     */\n', '    event AddressFrozen(\n', '        address indexed addr,\n', '        bool indexed isFrozen,\n', '        address indexed owner\n', '    );\n', '\n', '    /**\n', '     *  Sets an address frozen status for this token\n', '     *  @param addr The address to update frozen status.\n', '     *  @param freeze Frozen status of the address.\n', '     */\n', '    function setFrozen(address addr, bool freeze)\n', '    external;\n', '\n', '    /**\n', '     *  Replaces all of the existing rules with the given ones\n', '     *  @param kind The bucket of rules to set.\n', '     *  @param rules New compliance rules.\n', '     */\n', '    function setRules(uint8 kind, ComplianceRule[] calldata rules)\n', '    external;\n', '\n', '    /**\n', '     *  Returns all of the current compliance rules for this token\n', '     *  @param kind The bucket of rules to get.\n', '     *  @return List of all compliance rules.\n', '     */\n', '    function getRules(uint8 kind)\n', '    external\n', '    view\n', '    returns (ComplianceRule[] memory);\n', '\n', '    /**\n', '     *  @dev Checks if issuance can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted and unfrozen\n', '     *  THROWS when the transfer should fail.\n', '     *  @param issuer The address initiating the issuance.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If a issuance can occur between the from/to addresses.\n', '     */\n', '    function canIssue(address issuer, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '\n', '    /**\n', '     *  @dev Checks if a transfer can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted, unfrozen, and pass all compliance rule checks.\n', '     *  THROWS when the transfer should fail.\n', '     *  @param initiator The address initiating the transfer.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If a transfer can occur between the from/to addresses.\n', '     */\n', '    function canTransfer(address initiator, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '\n', '    /**\n', '     *  @dev Checks if an override by the sender can occur between the from/to addresses.\n', '     *\n', '     *  Both addresses must be whitelisted and unfrozen.\n', '     *  THROWS when the sender is not allowed to override.\n', '     *  @param admin The address initiating the transfer.\n', '     *  @param from The address of the sender.\n', '     *  @param to The address of the receiver.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @return If an override can occur between the from/to addresses.\n', '     */\n', '    function canOverride(address admin, address from, address to, uint256 tokens)\n', '    external\n', '    returns (bool);\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'contract T0ken is ERC20, Ownable, LockableDestroyable {\n', '\n', '    // ------------------------------- Variables -------------------------------\n', '\n', '    using AdditiveMath for uint256;\n', '    using AddressMap for AddressMap.Data;\n', '\n', '    address constant internal ZERO_ADDRESS = address(0);\n', '    string public constant name = "TZERO PREFERRED";\n', '    string public constant symbol = "TZROP";\n', '    uint8 public constant decimals = 0;\n', '\n', '    AddressMap.Data public shareholders;\n', '    Compliance public compliance;\n', '    address public issuer;\n', '    bool public issuingFinished = false;\n', '    mapping(address => address) public cancellations;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    uint256 internal totalSupplyTokens;\n', '\n', '    mapping (address => mapping (address => uint256)) private allowed;\n', '\n', '    // ------------------------------- Modifiers -------------------------------\n', '\n', '    modifier onlyIssuer() {\n', '        require(msg.sender == issuer, "Only issuer allowed");\n', '        _;\n', '    }\n', '\n', '    modifier canIssue() {\n', '        require(!issuingFinished, "Issuing is already finished");\n', '        _;\n', '    }\n', '\n', '    modifier isNotCancelled(address addr) {\n', '        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");\n', '        _;\n', '    }\n', '\n', '    modifier hasFunds(address addr, uint256 tokens) {\n', '        require(tokens <= balances[addr], "Insufficient funds");\n', '        _;\n', '    }\n', '\n', '    // -------------------------------- Events ---------------------------------\n', '\n', '    /**\n', '     *  This event is emitted when an address is cancelled and replaced with\n', '     *  a new address.  This happens in the case where a shareholder has\n', '     *  lost access to their original address and needs to have their share\n', '     *  reissued to a new address.  This is the equivalent of issuing replacement\n', '     *  share certificates.\n', '     *  @param original The address being superseded.\n', '     *  @param replacement The new address.\n', '     *  @param sender The address that caused the address to be superseded.\n', '    */\n', '    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);\n', '    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);\n', '    event Issue(address indexed to, uint256 tokens);\n', '    event IssueFinished();\n', '    event ShareholderAdded(address shareholder);\n', '    event ShareholderRemoved(address shareholder);\n', '\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     *  @dev Transfers tokens to the whitelisted account.\n', '     *\n', "     *  If the 'to' address is not currently a shareholder then it MUST become one.\n", "     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\n", '     *  from the list of shareholders.\n', '     *  MUST be removed from the list of shareholders.\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens The number of tokens to be transferred.\n', '     */\n', '    function transfer(address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(msg.sender, tokens)\n', '    returns (bool) {\n', '        bool transferAllowed;\n', '\n', '        // Issuance\n', '        if (msg.sender == issuer) {\n', '            transferAllowed = address(compliance) == ZERO_ADDRESS;\n', '            if (!transferAllowed) {\n', '                transferAllowed = compliance.canIssue(issuer, issuer, to, tokens);\n', '            }\n', '        }\n', '        // Transfer\n', '        else {\n', '            transferAllowed = canTransfer(msg.sender, to, tokens, false);\n', '        }\n', '\n', '        // Ensure the transfer is allowed.\n', '        if (transferAllowed) {\n', '            transferTokens(msg.sender, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', '     *  @dev Transfers tokens between whitelisted accounts.\n', '     *\n', "     *  If the 'to' address is not currently a shareholder then it MUST become one.\n", "     *  If the transfer will reduce 'from' balance to 0 then that address MUST be removed from the list of shareholders.\n", '     *  @param from The address to transfer from\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens uint256 the number of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(from, tokens)\n', '    returns (bool) {\n', '        require(tokens <= allowed[from][msg.sender], "Transfer exceeds allowance");\n', '\n', '        // Transfer the tokens\n', '        bool transferAllowed = canTransfer(from, to, tokens, false);\n', '        if (transferAllowed) {\n', '            // Update the allowance to reflect the transfer\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);\n', '            // Transfer the tokens\n', '            transferTokens(from, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', '     *  @dev Overrides a transfer of tokens to the whitelisted account.\n', '     *\n', "     *  If the 'to' address is not currently a shareholder then it MUST become one.\n", "     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\n", '     *  from the list of shareholders.\n', '     *  MUST be removed from the list of shareholders.\n', '     *  @param from The address to transfer from\n', '     *  @param to The address to transfer to.\n', '     *  @param tokens The number of tokens to be transferred.\n', '     */\n', '    function transferOverride(address from, address to, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(to)\n', '    hasFunds(from, tokens)\n', '    returns (bool) {\n', '        // Ensure the sender can perform the override.\n', '        bool transferAllowed = canTransfer(from, to, tokens, true);\n', '        // Ensure the transfer is allowed.\n', '        if (transferAllowed) {\n', '            transferTokens(from, to, tokens);\n', '        }\n', '        return transferAllowed;\n', '    }\n', '\n', '    /**\n', "     *  @dev Tokens will be issued to the issuer's address only.\n", '     *  @param quantity The number of tokens to mint.\n', '     *  @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function issueTokens(uint256 quantity)\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    canIssue\n', '    returns (bool) {\n', '        // Avoid doing any state changes for zero quantities\n', '        if (quantity > 0) {\n', '            totalSupplyTokens = totalSupplyTokens.add(quantity);\n', '            balances[issuer] = balances[issuer].add(quantity);\n', '            shareholders.append(issuer);\n', '        }\n', '        emit Issue(issuer, quantity);\n', '        emit Transfer(ZERO_ADDRESS, issuer, quantity);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Finishes token issuance.\n', '     *  This is a single use function, once invoked it cannot be undone.\n', '     */\n', '    function finishIssuing()\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    canIssue\n', '    returns (bool) {\n', '        issuingFinished = true;\n', '        emit IssueFinished();\n', '        return issuingFinished;\n', '    }\n', '\n', '    /**\n', '     *  @dev Cancel the original address and reissue the Tokens to the replacement address.\n', '     *\n', '     *  Access to this function is restricted to the Issuer only.\n', "     *  The 'original' address MUST be removed from the set of whitelisted addresses.\n", "     *  Throw if the 'original' address supplied is not a shareholder.\n", "     *  Throw if the 'replacement' address is not a whitelisted address.\n", "     *  This function MUST emit the 'VerifiedAddressSuperseded' event.\n", '     *  @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.\n', '     *  @param replacement The address  that supersedes the original. This address MUST be whitelisted.\n', '     */\n', '    function cancelAndReissue(address original, address replacement)\n', '    external\n', '    isUnlocked\n', '    onlyIssuer\n', '    isNotCancelled(replacement) {\n', '        // Ensure the reissue can take place\n', '        require(shareholders.exists(original) && !shareholders.exists(replacement), "Original doesn\'t exist or replacement does");\n', '        if (address(compliance) != ZERO_ADDRESS) {\n', '            require(compliance.canIssue(msg.sender, original, replacement, balances[original]), "Failed \'canIssue\' check.");\n', '        }\n', '\n', '        // Replace the original shareholder with the replacement\n', '        shareholders.remove(original);\n', '        shareholders.append(replacement);\n', '        // Add the original as a cancelled address (preventing it from future trading)\n', '        cancellations[original] = replacement;\n', '        // Transfer the balance to the replacement\n', '        balances[replacement] = balances[original];\n', '        balances[original] = 0;\n', '        emit VerifiedAddressSuperseded(original, replacement, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified number of tokens on behalf of msg.sender.\n', '     *\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param tokens The number of tokens of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 tokens)\n', '    external\n', '    isUnlocked\n', '    isNotCancelled(msg.sender)\n', '    returns (bool) {\n', '        require(shareholders.exists(msg.sender), "Must be a shareholder to approve token transfer");\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  @dev Set the issuer address.\n', '     *  @param newIssuer The address of the issuer.\n', '     */\n', '    function setIssuer(address newIssuer)\n', '    external\n', '    isUnlocked\n', '    onlyOwner {\n', '        issuer = newIssuer;\n', '        emit IssuerSet(issuer, newIssuer);\n', '    }\n', '\n', '    /**\n', '     *  @dev Sets the compliance contract address to use during transfers.\n', '     *  @param newComplianceAddress The address of the compliance contract.\n', '     */\n', '    function setCompliance(address newComplianceAddress)\n', '    external\n', '    isUnlocked\n', '    onlyOwner {\n', '        compliance = Compliance(newComplianceAddress);\n', '    }\n', '\n', '    // -------------------------------- Getters --------------------------------\n', '\n', '    /**\n', '     *  @dev Returns the total token supply\n', '     *  @return total number of tokens in existence\n', '     */\n', '    function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return totalSupplyTokens;\n', '    }\n', '\n', '    /**\n', '     *  @dev Gets the balance of the specified address.\n', '     *  @param addr The address to query the the balance of.\n', '     *  @return An uint256 representing the tokens owned by the passed address.\n', '     */\n', '    function balanceOf(address addr)\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return balances[addr];\n', '    }\n', '\n', '    /**\n', '     *  @dev Gets the number of tokens that an owner has allowed the spender to transfer.\n', '     *  @param addrOwner address The address which owns the funds.\n', '     *  @param spender address The address which will spend the funds.\n', '     *  @return A uint256 specifying the number of tokens still available for the spender.\n', '     */\n', '    function allowance(address addrOwner, address spender)\n', '    external\n', '    view\n', '    returns (uint256) {\n', '        return allowed[addrOwner][spender];\n', '    }\n', '\n', '    /**\n', "     *  By counting the number of token holders using 'holderCount'\n", '     *  you can retrieve the complete list of token holders, one at a time.\n', "     *  It MUST throw if 'index >= holderCount()'.\n", '     *  @dev Returns the holder at the given index.\n', '     *  @param index The zero-based index of the holder.\n', '     *  @return the address of the token holder with the given index.\n', '     */\n', '    function holderAt(int256 index)\n', '    external\n', '    view\n', '    returns (address){\n', '        return shareholders.at(index);\n', '    }\n', '\n', '    /**\n', '     *  @dev Checks to see if the supplied address is a share holder.\n', '     *  @param addr The address to check.\n', '     *  @return true if the supplied address owns a token.\n', '     */\n', '    function isHolder(address addr)\n', '    external\n', '    view\n', '    returns (bool) {\n', '        return shareholders.exists(addr);\n', '    }\n', '\n', '    /**\n', '     *  @dev Checks to see if the supplied address was superseded.\n', '     *  @param addr The address to check.\n', '     *  @return true if the supplied address was superseded by another address.\n', '     */\n', '    function isSuperseded(address addr)\n', '    external\n', '    view\n', '    returns (bool) {\n', '        return cancellations[addr] != ZERO_ADDRESS;\n', '    }\n', '\n', '    /**\n', '     *  Gets the most recent address, given a superseded one.\n', '     *  Addresses may be superseded multiple times, so this function needs to\n', '     *  follow the chain of addresses until it reaches the final, verified address.\n', '     *  @param addr The superseded address.\n', '     *  @return the verified address that ultimately holds the share.\n', '     */\n', '    function getSuperseded(address addr)\n', '    external\n', '    view\n', '    returns (address) {\n', '        require(addr != ZERO_ADDRESS, "Non-zero address required");\n', '\n', '        address candidate = cancellations[addr];\n', '        if (candidate == ZERO_ADDRESS) {\n', '            return ZERO_ADDRESS;\n', '        }\n', '        return candidate;\n', '    }\n', '\n', '\n', '    // -------------------------------- Private --------------------------------\n', '\n', '    /**\n', '     *  @dev Checks if a transfer/override may take place between the two accounts.\n', '     *\n', '     *   Validates that the transfer can take place.\n', "     *     - Ensure the 'to' address is not cancelled\n", '     *     - Ensure the transfer is compliant\n', '     *  @param from The sender address.\n', '     *  @param to The recipient address.\n', '     *  @param tokens The number of tokens being transferred.\n', '     *  @param isOverride If this is a transfer override\n', '     *  @return If the transfer can take place.\n', '     */\n', '    function canTransfer(address from, address to, uint256 tokens, bool isOverride)\n', '    private\n', '    isNotCancelled(to)\n', '    returns (bool) {\n', "        // Don't allow overrides and ignore compliance rules when compliance not set.\n", '        if (address(compliance) == ZERO_ADDRESS) {\n', '            return !isOverride;\n', '        }\n', '\n', '        // Ensure the override is valid, or that the transfer is compliant.\n', '        if (isOverride) {\n', '            return compliance.canOverride(msg.sender, from, to, tokens);\n', '        } else {\n', '            return compliance.canTransfer(msg.sender, from, to, tokens);\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  @dev Transfers tokens from one address to another\n', '     *  @param from The sender address.\n', '     *  @param to The recipient address.\n', '     *  @param tokens The number of tokens being transferred.\n', '     */\n', '    function transferTokens(address from, address to, uint256 tokens)\n', '    private {\n', '        // Update balances\n', '        balances[from] = balances[from].subtract(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '\n', "        // Adds the shareholder if they don't already exist.\n", '        if (balances[to] > 0 && shareholders.append(to)) {\n', '            emit ShareholderAdded(to);\n', '        }\n', '        // Remove the shareholder if they no longer hold tokens.\n', '        if (balances[from] == 0 && shareholders.remove(from)) {\n', '            emit ShareholderRemoved(from);\n', '        }\n', '    }\n', '\n', '}']
