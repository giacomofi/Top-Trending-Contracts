['pragma solidity ^0.4.18;\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public view returns (string) {}\n', '    function symbol() public view returns (string) {}\n', '    function decimals() public view returns (uint8) {}\n', '    function totalSupply() public view returns (uint256) {}\n', '    function balanceOf(address _owner) public view returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public view returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '\n', '/*\n', '    Bancor Gas Price Limit interface\n', '*/\n', 'contract IBancorGasPriceLimit {\n', '    function gasPrice() public view returns (uint256) {}\n', '    function validateGasPrice(uint256) public view;\n', '}\n', '\n', '\n', '\n', '/*\n', '    EIP228 Token Converter interface\n', '*/\n', 'contract ITokenConverter {\n', '    function convertibleTokenCount() public view returns (uint16);\n', '    function convertibleToken(uint16 _tokenIndex) public view returns (address);\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\n', '    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '    // deprecated, backward compatibility\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '/*\n', '    Bancor Quick Converter interface\n', '*/\n', 'contract IBancorQuickConverter {\n', '    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\n', '    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\n', '    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    constructor () public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '\n', '/*\n', '    We consider every contract to be a &#39;token holder&#39; since it&#39;s currently not possible\n', '    for a contract to deny receiving tokens.\n', '\n', '    The TokenHolder&#39;s contract sole purpose is to provide a safety mechanism that allows\n', '    the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '*/\n', 'contract TokenHolder is ITokenHolder, Owned, Utils {\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Ether Token interface\n', '*/\n', 'contract IEtherToken is ITokenHolder, IERC20Token {\n', '    function deposit() public payable;\n', '    function withdraw(uint256 _amount) public;\n', '    function withdrawTo(address _to, uint256 _amount) public;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '\n', '\n', '/*\n', '    The BancorQuickConverter contract provides allows converting between any token in the \n', '    bancor network in a single transaction.\n', '\n', '    A note on conversion paths -\n', '    Conversion path is a data structure that&#39;s used when converting a token to another token in the bancor network\n', '    when the conversion cannot necessarily be done by single converter and might require multiple &#39;hops&#39;.\n', '    The path defines which converters should be used and what kind of conversion should be done in each step.\n', '\n', '    The path format doesn&#39;t include complex structure and instead, it is represented by a single array\n', '    in which each &#39;hop&#39; is represented by a 2-tuple - smart token & to token.\n', '    In addition, the first element is always the source token.\n', '    The smart token is only used as a pointer to a converter (since converter addresses are more likely to change).\n', '\n', '    Format:\n', '    [source token, smart token, to token, smart token, to token...]\n', '*/\n', 'contract BancorQuickConverter is IBancorQuickConverter, TokenHolder {\n', '    address public signerAddress = 0x0; // verified address that allows conversions with higher gas price\n', '    IBancorGasPriceLimit public gasPriceLimit; // bancor universal gas price limit contract\n', '    mapping (address => bool) public etherTokens;   // list of all supported ether tokens\n', '    mapping (bytes32 => bool) public conversionHashes;\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function BancorQuickConverter() public {\n', '    }\n', '\n', '    // validates a conversion path - verifies that the number of elements is odd and that maximum number of &#39;hops&#39; is 10\n', '    modifier validConversionPath(IERC20Token[] _path) {\n', '        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\n', '        _;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the gas price limit contract address\n', '\n', '        @param _gasPriceLimit   address of a bancor gas price limit contract\n', '    */\n', '    function setGasPriceLimit(IBancorGasPriceLimit _gasPriceLimit)\n', '        public\n', '        ownerOnly\n', '        validAddress(_gasPriceLimit)\n', '        notThis(_gasPriceLimit)\n', '    {\n', '        gasPriceLimit = _gasPriceLimit;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the signer address\n', '\n', '        @param _signerAddress    new signer address\n', '    */\n', '    function setSignerAddress(address _signerAddress)\n', '        public\n', '        ownerOnly\n', '        validAddress(_signerAddress)\n', '        notThis(_signerAddress)\n', '    {\n', '        signerAddress = _signerAddress;\n', '    }\n', '\n', '    /**\n', '        @dev allows the owner to register/unregister ether tokens\n', '\n', '        @param _token       ether token contract address\n', '        @param _register    true to register, false to unregister\n', '    */\n', '    function registerEtherToken(IEtherToken _token, bool _register)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        notThis(_token)\n', '    {\n', '        etherTokens[_token] = _register;\n', '    }\n', '\n', '    /**\n', '        @dev verifies that the signer address is trusted by recovering \n', '        the address associated with the public key from elliptic \n', '        curve signature, returns zero on error.\n', '        notice that the signature is valid only for one conversion\n', '        and expires after the give block.\n', '\n', '        @return true if the signer is verified\n', '    */\n', '    function verifyTrustedSender(uint256 _block, address _addr, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) private returns(bool) {\n', '        bytes32 hash = sha256(_block, tx.gasprice, _addr, _nonce);\n', '\n', '        // checking that it is the first conversion with the given signature\n', '        // and that the current block number doesn&#39;t exceeded the maximum block\n', '        // number that&#39;s allowed with the current signature\n', '        require(!conversionHashes[hash] && block.number <= _block);\n', '\n', '        // recovering the signing address and comparing it to the trusted signer\n', '        // address that was set in the contract\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedHash = keccak256(prefix, hash);\n', '        bool verified = ecrecover(prefixedHash, _v, _r, _s) == signerAddress;\n', '\n', '        // if the signer is the trusted signer - mark the hash so that it can&#39;t\n', '        // be used multiple times\n', '        if (verified)\n', '            conversionHashes[hash] = true;\n', '        return verified;\n', '    }\n', '\n', '/**\n', '        @dev converts the token to any other token in the bancor network by following\n', '        a predefined conversion path and transfers the result tokens to a target account\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256) {\n', '        return convertForPrioritized(_path, _amount, _minReturn, _for, 0x0, 0x0, 0x0, 0x0, 0x0);\n', '    }\n', '\n', '    /**\n', '        @dev converts the token to any other token in the bancor network\n', '        by following a predefined conversion path and transfers the result\n', '        tokens to a target account.\n', '        this specific version of the function also allows the verified signer\n', '        to bypass the universal gas price limit.\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s)\n', '        public\n', '        payable\n', '        validConversionPath(_path)\n', '        returns (uint256)\n', '    {\n', '        if (_v == 0x0 && _r == 0x0 && _s == 0x0)\n', '            gasPriceLimit.validateGasPrice(tx.gasprice);\n', '        else\n', '            require(verifyTrustedSender(_block, _for, _nonce, _v, _r, _s));\n', '\n', '        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\n', '        IERC20Token fromToken = _path[0];\n', '        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));\n', '\n', '        IERC20Token toToken;\n', '\n', '        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it\n', '        // otherwise, we assume we already have the tokens\n', '        if (msg.value > 0)\n', '            IEtherToken(fromToken).deposit.value(msg.value)();\n', '        \n', '        (_amount, toToken) = convertByPath(_path, _amount, _minReturn, fromToken);\n', '\n', '        // finished the conversion, transfer the funds to the target account\n', '        // if the target token is an ether token, withdraw the tokens and send them as ETH\n', '        // otherwise, transfer the tokens as is\n', '        if (etherTokens[toToken])\n', '            IEtherToken(toToken).withdrawTo(_for, _amount);\n', '        else\n', '            assert(toToken.transfer(_for, _amount));\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function convertByPath(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, IERC20Token _fromToken) private returns (uint256, IERC20Token) {\n', '        ISmartToken smartToken;\n', '        IERC20Token toToken;\n', '        ITokenConverter converter;\n', '\n', '        // iterate over the conversion path\n', '        uint256 pathLength = _path.length;\n', '\n', '        for (uint256 i = 1; i < pathLength; i += 2) {\n', '            smartToken = ISmartToken(_path[i]);\n', '            toToken = _path[i + 1];\n', '            converter = ITokenConverter(smartToken.owner());\n', '\n', '            // if the smart token isn&#39;t the source (from token), the converter doesn&#39;t have control over it and thus we need to approve the request\n', '            if (smartToken != _fromToken)\n', '                ensureAllowance(_fromToken, converter, _amount);\n', '\n', '            // make the conversion - if it&#39;s the last one, also provide the minimum return value\n', '            _amount = converter.change(_fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\n', '            _fromToken = toToken;\n', '        }\n', '        return (_amount, toToken);\n', '    }\n', '\n', '    /**\n', '        @dev claims the caller&#39;s tokens, converts them to any other token in the bancor network\n', '        by following a predefined conversion path and transfers the result tokens to a target account\n', '        note that allowance must be set beforehand\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public returns (uint256) {\n', '        // we need to transfer the tokens from the caller to the converter before we follow\n', '        // the conversion path, to allow it to execute the conversion on behalf of the caller\n', '        // note: we assume we already have allowance\n', '        IERC20Token fromToken = _path[0];\n', '        assert(fromToken.transferFrom(msg.sender, this, _amount));\n', '        return convertFor(_path, _amount, _minReturn, _for);\n', '    }\n', '\n', '    /**\n', '        @dev converts the token to any other token in the bancor network by following\n', '        a predefined conversion path and transfers the result tokens back to the sender\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\n', '        return convertFor(_path, _amount, _minReturn, msg.sender);\n', '    }\n', '\n', '    /**\n', '        @dev claims the caller&#39;s tokens, converts them to any other token in the bancor network\n', '        by following a predefined conversion path and transfers the result tokens back to the sender\n', '        note that allowance must be set beforehand\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\n', '        return claimAndConvertFor(_path, _amount, _minReturn, msg.sender);\n', '    }\n', '\n', '    /**\n', '        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn&#39;t\n', '\n', '        @param _token   token to check the allowance in\n', '        @param _spender approved address\n', '        @param _value   allowance amount\n', '    */\n', '    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\n', '        // check if allowance for the given amount already exists\n', '        if (_token.allowance(this, _spender) >= _value)\n', '            return;\n', '\n', '        // if the allowance is nonzero, must reset it to 0 first\n', '        if (_token.allowance(this, _spender) != 0)\n', '            assert(_token.approve(_spender, 0));\n', '\n', '        // approve the new allowance\n', '        assert(_token.approve(_spender, _value));\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', "    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n", '    function name() public view returns (string) {}\n', '    function symbol() public view returns (string) {}\n', '    function decimals() public view returns (uint8) {}\n', '    function totalSupply() public view returns (uint256) {}\n', '    function balanceOf(address _owner) public view returns (uint256) { _owner; }\n', '    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public view returns (address) {}\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '\n', '/*\n', '    Bancor Gas Price Limit interface\n', '*/\n', 'contract IBancorGasPriceLimit {\n', '    function gasPrice() public view returns (uint256) {}\n', '    function validateGasPrice(uint256) public view;\n', '}\n', '\n', '\n', '\n', '/*\n', '    EIP228 Token Converter interface\n', '*/\n', 'contract ITokenConverter {\n', '    function convertibleTokenCount() public view returns (uint16);\n', '    function convertibleToken(uint16 _tokenIndex) public view returns (address);\n', '    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public view returns (uint256);\n', '    function convert(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '    // deprecated, backward compatibility\n', '    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '/*\n', '    Bancor Quick Converter interface\n', '*/\n', 'contract IBancorQuickConverter {\n', '    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256);\n', '    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256);\n', '    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) public payable returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    constructor () public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '\n', '/*\n', "    We consider every contract to be a 'token holder' since it's currently not possible\n", '    for a contract to deny receiving tokens.\n', '\n', "    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n", '    the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '*/\n', 'contract TokenHolder is ITokenHolder, Owned, Utils {\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Ether Token interface\n', '*/\n', 'contract IEtherToken is ITokenHolder, IERC20Token {\n', '    function deposit() public payable;\n', '    function withdraw(uint256 _amount) public;\n', '    function withdrawTo(address _to, uint256 _amount) public;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is IOwned, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '\n', '\n', '/*\n', '    The BancorQuickConverter contract provides allows converting between any token in the \n', '    bancor network in a single transaction.\n', '\n', '    A note on conversion paths -\n', "    Conversion path is a data structure that's used when converting a token to another token in the bancor network\n", "    when the conversion cannot necessarily be done by single converter and might require multiple 'hops'.\n", '    The path defines which converters should be used and what kind of conversion should be done in each step.\n', '\n', "    The path format doesn't include complex structure and instead, it is represented by a single array\n", "    in which each 'hop' is represented by a 2-tuple - smart token & to token.\n", '    In addition, the first element is always the source token.\n', '    The smart token is only used as a pointer to a converter (since converter addresses are more likely to change).\n', '\n', '    Format:\n', '    [source token, smart token, to token, smart token, to token...]\n', '*/\n', 'contract BancorQuickConverter is IBancorQuickConverter, TokenHolder {\n', '    address public signerAddress = 0x0; // verified address that allows conversions with higher gas price\n', '    IBancorGasPriceLimit public gasPriceLimit; // bancor universal gas price limit contract\n', '    mapping (address => bool) public etherTokens;   // list of all supported ether tokens\n', '    mapping (bytes32 => bool) public conversionHashes;\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function BancorQuickConverter() public {\n', '    }\n', '\n', "    // validates a conversion path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\n", '    modifier validConversionPath(IERC20Token[] _path) {\n', '        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\n', '        _;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the gas price limit contract address\n', '\n', '        @param _gasPriceLimit   address of a bancor gas price limit contract\n', '    */\n', '    function setGasPriceLimit(IBancorGasPriceLimit _gasPriceLimit)\n', '        public\n', '        ownerOnly\n', '        validAddress(_gasPriceLimit)\n', '        notThis(_gasPriceLimit)\n', '    {\n', '        gasPriceLimit = _gasPriceLimit;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the signer address\n', '\n', '        @param _signerAddress    new signer address\n', '    */\n', '    function setSignerAddress(address _signerAddress)\n', '        public\n', '        ownerOnly\n', '        validAddress(_signerAddress)\n', '        notThis(_signerAddress)\n', '    {\n', '        signerAddress = _signerAddress;\n', '    }\n', '\n', '    /**\n', '        @dev allows the owner to register/unregister ether tokens\n', '\n', '        @param _token       ether token contract address\n', '        @param _register    true to register, false to unregister\n', '    */\n', '    function registerEtherToken(IEtherToken _token, bool _register)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        notThis(_token)\n', '    {\n', '        etherTokens[_token] = _register;\n', '    }\n', '\n', '    /**\n', '        @dev verifies that the signer address is trusted by recovering \n', '        the address associated with the public key from elliptic \n', '        curve signature, returns zero on error.\n', '        notice that the signature is valid only for one conversion\n', '        and expires after the give block.\n', '\n', '        @return true if the signer is verified\n', '    */\n', '    function verifyTrustedSender(uint256 _block, address _addr, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s) private returns(bool) {\n', '        bytes32 hash = sha256(_block, tx.gasprice, _addr, _nonce);\n', '\n', '        // checking that it is the first conversion with the given signature\n', "        // and that the current block number doesn't exceeded the maximum block\n", "        // number that's allowed with the current signature\n", '        require(!conversionHashes[hash] && block.number <= _block);\n', '\n', '        // recovering the signing address and comparing it to the trusted signer\n', '        // address that was set in the contract\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedHash = keccak256(prefix, hash);\n', '        bool verified = ecrecover(prefixedHash, _v, _r, _s) == signerAddress;\n', '\n', "        // if the signer is the trusted signer - mark the hash so that it can't\n", '        // be used multiple times\n', '        if (verified)\n', '            conversionHashes[hash] = true;\n', '        return verified;\n', '    }\n', '\n', '/**\n', '        @dev converts the token to any other token in the bancor network by following\n', '        a predefined conversion path and transfers the result tokens to a target account\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public payable returns (uint256) {\n', '        return convertForPrioritized(_path, _amount, _minReturn, _for, 0x0, 0x0, 0x0, 0x0, 0x0);\n', '    }\n', '\n', '    /**\n', '        @dev converts the token to any other token in the bancor network\n', '        by following a predefined conversion path and transfers the result\n', '        tokens to a target account.\n', '        this specific version of the function also allows the verified signer\n', '        to bypass the universal gas price limit.\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convertForPrioritized(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for, uint256 _block, uint256 _nonce, uint8 _v, bytes32 _r, bytes32 _s)\n', '        public\n', '        payable\n', '        validConversionPath(_path)\n', '        returns (uint256)\n', '    {\n', '        if (_v == 0x0 && _r == 0x0 && _s == 0x0)\n', '            gasPriceLimit.validateGasPrice(tx.gasprice);\n', '        else\n', '            require(verifyTrustedSender(_block, _for, _nonce, _v, _r, _s));\n', '\n', '        // if ETH is provided, ensure that the amount is identical to _amount and verify that the source token is an ether token\n', '        IERC20Token fromToken = _path[0];\n', '        require(msg.value == 0 || (_amount == msg.value && etherTokens[fromToken]));\n', '\n', '        IERC20Token toToken;\n', '\n', '        // if ETH was sent with the call, the source is an ether token - deposit the ETH in it\n', '        // otherwise, we assume we already have the tokens\n', '        if (msg.value > 0)\n', '            IEtherToken(fromToken).deposit.value(msg.value)();\n', '        \n', '        (_amount, toToken) = convertByPath(_path, _amount, _minReturn, fromToken);\n', '\n', '        // finished the conversion, transfer the funds to the target account\n', '        // if the target token is an ether token, withdraw the tokens and send them as ETH\n', '        // otherwise, transfer the tokens as is\n', '        if (etherTokens[toToken])\n', '            IEtherToken(toToken).withdrawTo(_for, _amount);\n', '        else\n', '            assert(toToken.transfer(_for, _amount));\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function convertByPath(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, IERC20Token _fromToken) private returns (uint256, IERC20Token) {\n', '        ISmartToken smartToken;\n', '        IERC20Token toToken;\n', '        ITokenConverter converter;\n', '\n', '        // iterate over the conversion path\n', '        uint256 pathLength = _path.length;\n', '\n', '        for (uint256 i = 1; i < pathLength; i += 2) {\n', '            smartToken = ISmartToken(_path[i]);\n', '            toToken = _path[i + 1];\n', '            converter = ITokenConverter(smartToken.owner());\n', '\n', "            // if the smart token isn't the source (from token), the converter doesn't have control over it and thus we need to approve the request\n", '            if (smartToken != _fromToken)\n', '                ensureAllowance(_fromToken, converter, _amount);\n', '\n', "            // make the conversion - if it's the last one, also provide the minimum return value\n", '            _amount = converter.change(_fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\n', '            _fromToken = toToken;\n', '        }\n', '        return (_amount, toToken);\n', '    }\n', '\n', '    /**\n', "        @dev claims the caller's tokens, converts them to any other token in the bancor network\n", '        by following a predefined conversion path and transfers the result tokens to a target account\n', '        note that allowance must be set beforehand\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '        @param _for         account that will receive the conversion result\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function claimAndConvertFor(IERC20Token[] _path, uint256 _amount, uint256 _minReturn, address _for) public returns (uint256) {\n', '        // we need to transfer the tokens from the caller to the converter before we follow\n', '        // the conversion path, to allow it to execute the conversion on behalf of the caller\n', '        // note: we assume we already have allowance\n', '        IERC20Token fromToken = _path[0];\n', '        assert(fromToken.transferFrom(msg.sender, this, _amount));\n', '        return convertFor(_path, _amount, _minReturn, _for);\n', '    }\n', '\n', '    /**\n', '        @dev converts the token to any other token in the bancor network by following\n', '        a predefined conversion path and transfers the result tokens back to the sender\n', '        note that the converter should already own the source tokens\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {\n', '        return convertFor(_path, _amount, _minReturn, msg.sender);\n', '    }\n', '\n', '    /**\n', "        @dev claims the caller's tokens, converts them to any other token in the bancor network\n", '        by following a predefined conversion path and transfers the result tokens back to the sender\n', '        note that allowance must be set beforehand\n', '\n', '        @param _path        conversion path, see conversion path format above\n', '        @param _amount      amount to convert from (in the initial source token)\n', '        @param _minReturn   if the conversion results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n', '\n', '        @return tokens issued in return\n', '    */\n', '    function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {\n', '        return claimAndConvertFor(_path, _amount, _minReturn, msg.sender);\n', '    }\n', '\n', '    /**\n', "        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't\n", '\n', '        @param _token   token to check the allowance in\n', '        @param _spender approved address\n', '        @param _value   allowance amount\n', '    */\n', '    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\n', '        // check if allowance for the given amount already exists\n', '        if (_token.allowance(this, _spender) >= _value)\n', '            return;\n', '\n', '        // if the allowance is nonzero, must reset it to 0 first\n', '        if (_token.allowance(this, _spender) != 0)\n', '            assert(_token.approve(_spender, 0));\n', '\n', '        // approve the new allowance\n', '        assert(_token.approve(_spender, _value));\n', '    }\n', '}']
