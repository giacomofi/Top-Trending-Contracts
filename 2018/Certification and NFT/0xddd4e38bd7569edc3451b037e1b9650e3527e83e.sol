['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', 'contract CryptocurrencyRaz is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    uint public numberOfRazzes = 3;\n', '    uint idCounter = 1;\n', '    struct RazInformation\n', '    {\n', '        uint razInstance;\n', '        uint winningBet;\n', '        address winningAddress;\n', '        address[] allLosers;\n', '        uint timestamp;\n', '        uint id;\n', '    }\n', '    \n', '    struct previousBets\n', '    {\n', '        uint timestamp;\n', '        uint[] bets;\n', '    }\n', '    mapping(uint=>mapping(uint=>RazInformation)) public RazInstanceInformation;\n', '    mapping(uint=>mapping(uint=>mapping(address=>previousBets))) public userBetsInEachRazInstance;\n', '    \n', '    mapping(uint=>uint) public runningRazInstance;\n', '   \n', '    mapping(uint=>bool) public razCompletion;\n', '    mapping(uint=>mapping(uint=>address)) public numbersTaken;\n', '    mapping(uint=>uint) public maxBetsForEachRaz;\n', '    mapping(uint=>uint256) public participationFeeForEachRaz;\n', '    mapping(uint=>uint256) public winnerPrizeMoneyForEachRaz;\n', '    mapping(uint=>uint256) public ownerPrizeMoneyForEachRaz;\n', '    mapping(uint=>string) public razName;\n', '    mapping (address=>uint[]) public pastWinnings;\n', '    mapping (address=>uint[]) public pastLosings;\n', '    \n', '    \n', '    uint[] razList;\n', '    uint[] empty;\n', '    \n', '    uint[] winOrLoseArray;\n', '    uint WinOrLoseNumber;\n', '    previousBets aBet;\n', '    address[] losers;\n', '    \n', '    RazInformation information;\n', '    \n', '    event BetPlaced(address gambler, string razName, uint[] bets);\n', '    event BetWon(address gambler, string razName, uint betNum, uint razNumber, uint razInstance);\n', '    event allBetsPlaced(uint[] b);\n', '    uint[] bb;\n', '    \n', '    constructor(address _owner) public \n', '    {\n', '        owner = _owner;\n', '        Setup();\n', '    }\n', '    \n', '    function Setup() internal {\n', '        maxBetsForEachRaz[1] = 10;\n', '        maxBetsForEachRaz[2] = 20;\n', '        maxBetsForEachRaz[3] = 10;\n', '        \n', '        razName[1] = "Mighty genesis";\n', '        razName[2] = "Second titan";\n', '        razName[3] = "Trinity affair";\n', '        \n', '        participationFeeForEachRaz[1] = 3 * 10 ** 16;\n', '        participationFeeForEachRaz[2] = 1 * 10 ** 16;\n', '        participationFeeForEachRaz[3] = 1 * 10 ** 16;\n', '        \n', '        winnerPrizeMoneyForEachRaz[1] = 21 * 10 ** 16;\n', '        winnerPrizeMoneyForEachRaz[2] = 15 * 10 ** 16;\n', '        winnerPrizeMoneyForEachRaz[3] = 7 * 10 ** 16;\n', '        \n', '        ownerPrizeMoneyForEachRaz[1] = 9 * 10 ** 16;\n', '        ownerPrizeMoneyForEachRaz[2] = 5 * 10 ** 16;\n', '        ownerPrizeMoneyForEachRaz[3] = 3 * 10 ** 16;\n', '        \n', '        runningRazInstance[1] = 1;\n', '        runningRazInstance[2] = 1;\n', '        runningRazInstance[3] = 1;\n', '    }\n', '    \n', '    function EnterBetsForRaz(uint razNumber, uint[] bets) public payable\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        uint numBets = bets.length;     //finding the numbers of bets the user has placed\n', '        require(msg.value>=participationFeeForEachRaz[razNumber].mul(numBets));    //user has to pay according to the number of bets placed\n', '        require(razCompletion[razNumber] == false);\n', '        uint instance = runningRazInstance[razNumber];\n', '        bb = userBetsInEachRazInstance[razNumber][instance][msg.sender].bets;\n', '        for (uint i=0;i<numBets;i++)\n', '        {\n', '            require(numbersTaken[razNumber][bets[i]] == 0);\n', '            require(bets[i]>=1 && bets[i]<=maxBetsForEachRaz[razNumber]);\n', '            numbersTaken[razNumber][bets[i]] = msg.sender;\n', '            bb.push(bets[i]);\n', '        }\n', '        aBet.bets = bb;\n', '        aBet.timestamp = now;\n', '        userBetsInEachRazInstance[razNumber][instance][msg.sender] = aBet;\n', '        MarkRazAsComplete(razNumber);\n', '       \n', '        emit BetPlaced(msg.sender,razName[razNumber],bets);\n', '    }\n', '    \n', '    function MarkRazAsComplete(uint razNumber) internal returns (bool)\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] == 0)\n', '            return false;\n', '        }\n', '        razCompletion[razNumber] = true;\n', '        uint randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%maxBetsForEachRaz[razNumber]);\n', '        randomNumber = randomNumber.add(1);\n', '        declareWinnerForRaz(razNumber,randomNumber);\n', '        return true;\n', '    }\n', '   \n', '    function getAvailableNumbersForRaz (uint razNumber) public returns (uint[])\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        razList = empty;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] == 0)\n', '                razList.push(i);\n', '        }\n', '        return razList;\n', '    }\n', '    \n', '    function resetRaz(uint razNumber,address winningAddress, uint winningNumber) internal \n', '    {\n', '        delete losers;\n', '        \n', '        bool isRepeat;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            isRepeat = false;\n', '            if (numbersTaken[razNumber][i] == winningAddress && i == winningNumber)\n', '            {\n', '                winOrLoseArray = pastWinnings[numbersTaken[razNumber][i]];\n', '                winOrLoseArray.push(razNumber);\n', '                pastWinnings[numbersTaken[razNumber][i]] = winOrLoseArray;\n', '            }\n', '            else\n', '            {\n', '                if (numbersTaken[razNumber][i] != winningAddress)\n', '                {\n', '                    for (uint j=0;j<losers.length;j++)\n', '                    {\n', '                        if (numbersTaken[razNumber][i] == losers[j])\n', '                            isRepeat = true;\n', '                    }\n', '                    if (!isRepeat)\n', '                    {\n', '                        winOrLoseArray = pastLosings[numbersTaken[razNumber][i]];\n', '                        winOrLoseArray.push(razNumber);\n', '                        pastLosings[numbersTaken[razNumber][i]] = winOrLoseArray;\n', '                        losers.push(numbersTaken[razNumber][i]);\n', '                    }\n', '                }\n', '            }\n', '            numbersTaken[razNumber][i]=0;\n', '        }   \n', '        razCompletion[razNumber] = false;\n', '        uint thisInstance = runningRazInstance[razNumber];\n', '        information = RazInformation({razInstance:thisInstance, winningBet: winningNumber, winningAddress: winningAddress,allLosers: losers, timestamp:now, id:idCounter});\n', '        idCounter = idCounter.add(1);\n', '        RazInstanceInformation[razNumber][thisInstance] = information;\n', '        runningRazInstance[razNumber] = runningRazInstance[razNumber].add(1);\n', '    }\n', '    \n', '    function declareWinnerForRaz(uint razNumber,uint winningNumber) internal\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        require(razCompletion[razNumber] == true);   \n', '        address winningAddress =  numbersTaken[razNumber][winningNumber];\n', '        winningAddress.transfer(winnerPrizeMoneyForEachRaz[razNumber]);\n', '        owner.transfer(ownerPrizeMoneyForEachRaz[razNumber]);\n', '        emit BetWon(winningAddress,razName[razNumber],winningNumber,razNumber,runningRazInstance[razNumber]);\n', '        resetRaz(razNumber,winningAddress,winningNumber);\n', '    }\n', '    \n', '    function GetUserBetsInRaz(address userAddress, uint razNumber) public returns (uint[])\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        razList = empty;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i]==userAddress)\n', '                razList.push(i);\n', '        }   \n', '        return razList;\n', '    }\n', '    function changeParticipationFeeForRaz(uint razNumber,uint participationFee) public onlyOwner \n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        participationFeeForEachRaz[razNumber] = participationFee;\n', '    }\n', '    \n', '     function changeWinnerPrizeMoneyForRaz(uint razNumber,uint prizeMoney) public onlyOwner \n', '     {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        winnerPrizeMoneyForEachRaz[razNumber] = prizeMoney;\n', '    }\n', '    \n', '    function addNewRaz(uint maxBets, uint winningAmount, uint ownerAmount, uint particFee, string name) public onlyOwner returns (uint) \n', '    {\n', '        require(maxBets.mul(particFee) == winningAmount.add(ownerAmount));\n', '        numberOfRazzes = numberOfRazzes.add(1);\n', '        maxBetsForEachRaz[numberOfRazzes] = maxBets;\n', '        participationFeeForEachRaz[numberOfRazzes] = particFee;\n', '        winnerPrizeMoneyForEachRaz[numberOfRazzes] = winningAmount;\n', '        ownerPrizeMoneyForEachRaz[numberOfRazzes] = ownerAmount;    \n', '        razName[numberOfRazzes] = name;\n', '        runningRazInstance[numberOfRazzes] = 1;\n', '        return numberOfRazzes;\n', '    }\n', '    \n', '    function updateExistingRaz(uint razNumber, uint maxBets, uint winningAmount, uint ownerAmount, uint particFee, string name) public onlyOwner returns (uint) \n', '    {\n', '        require (razNumber<=numberOfRazzes);\n', '        require(!IsRazRunning(razNumber));\n', '        require(maxBets.mul(particFee) == winningAmount.add(ownerAmount));\n', '        maxBetsForEachRaz[razNumber] = maxBets;\n', '        participationFeeForEachRaz[razNumber] = particFee;\n', '        winnerPrizeMoneyForEachRaz[razNumber] = winningAmount;\n', '        ownerPrizeMoneyForEachRaz[razNumber] = ownerAmount;   \n', '        razName[razNumber] = name;\n', '    }\n', '    function getMyPastWins(address addr) public constant returns (uint[])\n', '    {\n', '        return pastWinnings[addr];\n', '    }\n', '    function getMyPastLosses(address addr) public constant returns (uint[]) \n', '    {\n', '        return pastLosings[addr];\n', '    }\n', '    \n', '    function getRazInstanceInformation(uint razNumber, uint instanceNumber) public constant returns (uint, address, address[],uint,uint)\n', '    {\n', '        return (RazInstanceInformation[razNumber][instanceNumber].winningBet, \n', '                RazInstanceInformation[razNumber][instanceNumber].winningAddress,\n', '                RazInstanceInformation[razNumber][instanceNumber].allLosers,\n', '                RazInstanceInformation[razNumber][instanceNumber].timestamp,\n', '                RazInstanceInformation[razNumber][instanceNumber].id);\n', '    }\n', '    function getRunningRazInstance(uint razNumber) public constant returns (uint)\n', '    {\n', '        return runningRazInstance[razNumber];\n', '    }\n', '    \n', '    function getUserBetsInARazInstance(uint razNumber, uint instanceNumber) public constant returns(uint[])\n', '    {\n', '        return (userBetsInEachRazInstance[razNumber][instanceNumber][msg.sender].bets);\n', '    }\n', '    function getUserBetsTimeStampInARazInstance(uint razNumber, uint instanceNumber) public constant returns(uint)\n', '    {\n', '        return (userBetsInEachRazInstance[razNumber][instanceNumber][msg.sender].timestamp);\n', '    }\n', '    \n', '    function IsRazRunning(uint razNumber) constant public returns (bool)\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] != 0)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal pure returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', 'contract CryptocurrencyRaz is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    uint public numberOfRazzes = 3;\n', '    uint idCounter = 1;\n', '    struct RazInformation\n', '    {\n', '        uint razInstance;\n', '        uint winningBet;\n', '        address winningAddress;\n', '        address[] allLosers;\n', '        uint timestamp;\n', '        uint id;\n', '    }\n', '    \n', '    struct previousBets\n', '    {\n', '        uint timestamp;\n', '        uint[] bets;\n', '    }\n', '    mapping(uint=>mapping(uint=>RazInformation)) public RazInstanceInformation;\n', '    mapping(uint=>mapping(uint=>mapping(address=>previousBets))) public userBetsInEachRazInstance;\n', '    \n', '    mapping(uint=>uint) public runningRazInstance;\n', '   \n', '    mapping(uint=>bool) public razCompletion;\n', '    mapping(uint=>mapping(uint=>address)) public numbersTaken;\n', '    mapping(uint=>uint) public maxBetsForEachRaz;\n', '    mapping(uint=>uint256) public participationFeeForEachRaz;\n', '    mapping(uint=>uint256) public winnerPrizeMoneyForEachRaz;\n', '    mapping(uint=>uint256) public ownerPrizeMoneyForEachRaz;\n', '    mapping(uint=>string) public razName;\n', '    mapping (address=>uint[]) public pastWinnings;\n', '    mapping (address=>uint[]) public pastLosings;\n', '    \n', '    \n', '    uint[] razList;\n', '    uint[] empty;\n', '    \n', '    uint[] winOrLoseArray;\n', '    uint WinOrLoseNumber;\n', '    previousBets aBet;\n', '    address[] losers;\n', '    \n', '    RazInformation information;\n', '    \n', '    event BetPlaced(address gambler, string razName, uint[] bets);\n', '    event BetWon(address gambler, string razName, uint betNum, uint razNumber, uint razInstance);\n', '    event allBetsPlaced(uint[] b);\n', '    uint[] bb;\n', '    \n', '    constructor(address _owner) public \n', '    {\n', '        owner = _owner;\n', '        Setup();\n', '    }\n', '    \n', '    function Setup() internal {\n', '        maxBetsForEachRaz[1] = 10;\n', '        maxBetsForEachRaz[2] = 20;\n', '        maxBetsForEachRaz[3] = 10;\n', '        \n', '        razName[1] = "Mighty genesis";\n', '        razName[2] = "Second titan";\n', '        razName[3] = "Trinity affair";\n', '        \n', '        participationFeeForEachRaz[1] = 3 * 10 ** 16;\n', '        participationFeeForEachRaz[2] = 1 * 10 ** 16;\n', '        participationFeeForEachRaz[3] = 1 * 10 ** 16;\n', '        \n', '        winnerPrizeMoneyForEachRaz[1] = 21 * 10 ** 16;\n', '        winnerPrizeMoneyForEachRaz[2] = 15 * 10 ** 16;\n', '        winnerPrizeMoneyForEachRaz[3] = 7 * 10 ** 16;\n', '        \n', '        ownerPrizeMoneyForEachRaz[1] = 9 * 10 ** 16;\n', '        ownerPrizeMoneyForEachRaz[2] = 5 * 10 ** 16;\n', '        ownerPrizeMoneyForEachRaz[3] = 3 * 10 ** 16;\n', '        \n', '        runningRazInstance[1] = 1;\n', '        runningRazInstance[2] = 1;\n', '        runningRazInstance[3] = 1;\n', '    }\n', '    \n', '    function EnterBetsForRaz(uint razNumber, uint[] bets) public payable\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        uint numBets = bets.length;     //finding the numbers of bets the user has placed\n', '        require(msg.value>=participationFeeForEachRaz[razNumber].mul(numBets));    //user has to pay according to the number of bets placed\n', '        require(razCompletion[razNumber] == false);\n', '        uint instance = runningRazInstance[razNumber];\n', '        bb = userBetsInEachRazInstance[razNumber][instance][msg.sender].bets;\n', '        for (uint i=0;i<numBets;i++)\n', '        {\n', '            require(numbersTaken[razNumber][bets[i]] == 0);\n', '            require(bets[i]>=1 && bets[i]<=maxBetsForEachRaz[razNumber]);\n', '            numbersTaken[razNumber][bets[i]] = msg.sender;\n', '            bb.push(bets[i]);\n', '        }\n', '        aBet.bets = bb;\n', '        aBet.timestamp = now;\n', '        userBetsInEachRazInstance[razNumber][instance][msg.sender] = aBet;\n', '        MarkRazAsComplete(razNumber);\n', '       \n', '        emit BetPlaced(msg.sender,razName[razNumber],bets);\n', '    }\n', '    \n', '    function MarkRazAsComplete(uint razNumber) internal returns (bool)\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] == 0)\n', '            return false;\n', '        }\n', '        razCompletion[razNumber] = true;\n', '        uint randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%maxBetsForEachRaz[razNumber]);\n', '        randomNumber = randomNumber.add(1);\n', '        declareWinnerForRaz(razNumber,randomNumber);\n', '        return true;\n', '    }\n', '   \n', '    function getAvailableNumbersForRaz (uint razNumber) public returns (uint[])\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        razList = empty;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] == 0)\n', '                razList.push(i);\n', '        }\n', '        return razList;\n', '    }\n', '    \n', '    function resetRaz(uint razNumber,address winningAddress, uint winningNumber) internal \n', '    {\n', '        delete losers;\n', '        \n', '        bool isRepeat;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            isRepeat = false;\n', '            if (numbersTaken[razNumber][i] == winningAddress && i == winningNumber)\n', '            {\n', '                winOrLoseArray = pastWinnings[numbersTaken[razNumber][i]];\n', '                winOrLoseArray.push(razNumber);\n', '                pastWinnings[numbersTaken[razNumber][i]] = winOrLoseArray;\n', '            }\n', '            else\n', '            {\n', '                if (numbersTaken[razNumber][i] != winningAddress)\n', '                {\n', '                    for (uint j=0;j<losers.length;j++)\n', '                    {\n', '                        if (numbersTaken[razNumber][i] == losers[j])\n', '                            isRepeat = true;\n', '                    }\n', '                    if (!isRepeat)\n', '                    {\n', '                        winOrLoseArray = pastLosings[numbersTaken[razNumber][i]];\n', '                        winOrLoseArray.push(razNumber);\n', '                        pastLosings[numbersTaken[razNumber][i]] = winOrLoseArray;\n', '                        losers.push(numbersTaken[razNumber][i]);\n', '                    }\n', '                }\n', '            }\n', '            numbersTaken[razNumber][i]=0;\n', '        }   \n', '        razCompletion[razNumber] = false;\n', '        uint thisInstance = runningRazInstance[razNumber];\n', '        information = RazInformation({razInstance:thisInstance, winningBet: winningNumber, winningAddress: winningAddress,allLosers: losers, timestamp:now, id:idCounter});\n', '        idCounter = idCounter.add(1);\n', '        RazInstanceInformation[razNumber][thisInstance] = information;\n', '        runningRazInstance[razNumber] = runningRazInstance[razNumber].add(1);\n', '    }\n', '    \n', '    function declareWinnerForRaz(uint razNumber,uint winningNumber) internal\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        require(razCompletion[razNumber] == true);   \n', '        address winningAddress =  numbersTaken[razNumber][winningNumber];\n', '        winningAddress.transfer(winnerPrizeMoneyForEachRaz[razNumber]);\n', '        owner.transfer(ownerPrizeMoneyForEachRaz[razNumber]);\n', '        emit BetWon(winningAddress,razName[razNumber],winningNumber,razNumber,runningRazInstance[razNumber]);\n', '        resetRaz(razNumber,winningAddress,winningNumber);\n', '    }\n', '    \n', '    function GetUserBetsInRaz(address userAddress, uint razNumber) public returns (uint[])\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        razList = empty;\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i]==userAddress)\n', '                razList.push(i);\n', '        }   \n', '        return razList;\n', '    }\n', '    function changeParticipationFeeForRaz(uint razNumber,uint participationFee) public onlyOwner \n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        participationFeeForEachRaz[razNumber] = participationFee;\n', '    }\n', '    \n', '     function changeWinnerPrizeMoneyForRaz(uint razNumber,uint prizeMoney) public onlyOwner \n', '     {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        winnerPrizeMoneyForEachRaz[razNumber] = prizeMoney;\n', '    }\n', '    \n', '    function addNewRaz(uint maxBets, uint winningAmount, uint ownerAmount, uint particFee, string name) public onlyOwner returns (uint) \n', '    {\n', '        require(maxBets.mul(particFee) == winningAmount.add(ownerAmount));\n', '        numberOfRazzes = numberOfRazzes.add(1);\n', '        maxBetsForEachRaz[numberOfRazzes] = maxBets;\n', '        participationFeeForEachRaz[numberOfRazzes] = particFee;\n', '        winnerPrizeMoneyForEachRaz[numberOfRazzes] = winningAmount;\n', '        ownerPrizeMoneyForEachRaz[numberOfRazzes] = ownerAmount;    \n', '        razName[numberOfRazzes] = name;\n', '        runningRazInstance[numberOfRazzes] = 1;\n', '        return numberOfRazzes;\n', '    }\n', '    \n', '    function updateExistingRaz(uint razNumber, uint maxBets, uint winningAmount, uint ownerAmount, uint particFee, string name) public onlyOwner returns (uint) \n', '    {\n', '        require (razNumber<=numberOfRazzes);\n', '        require(!IsRazRunning(razNumber));\n', '        require(maxBets.mul(particFee) == winningAmount.add(ownerAmount));\n', '        maxBetsForEachRaz[razNumber] = maxBets;\n', '        participationFeeForEachRaz[razNumber] = particFee;\n', '        winnerPrizeMoneyForEachRaz[razNumber] = winningAmount;\n', '        ownerPrizeMoneyForEachRaz[razNumber] = ownerAmount;   \n', '        razName[razNumber] = name;\n', '    }\n', '    function getMyPastWins(address addr) public constant returns (uint[])\n', '    {\n', '        return pastWinnings[addr];\n', '    }\n', '    function getMyPastLosses(address addr) public constant returns (uint[]) \n', '    {\n', '        return pastLosings[addr];\n', '    }\n', '    \n', '    function getRazInstanceInformation(uint razNumber, uint instanceNumber) public constant returns (uint, address, address[],uint,uint)\n', '    {\n', '        return (RazInstanceInformation[razNumber][instanceNumber].winningBet, \n', '                RazInstanceInformation[razNumber][instanceNumber].winningAddress,\n', '                RazInstanceInformation[razNumber][instanceNumber].allLosers,\n', '                RazInstanceInformation[razNumber][instanceNumber].timestamp,\n', '                RazInstanceInformation[razNumber][instanceNumber].id);\n', '    }\n', '    function getRunningRazInstance(uint razNumber) public constant returns (uint)\n', '    {\n', '        return runningRazInstance[razNumber];\n', '    }\n', '    \n', '    function getUserBetsInARazInstance(uint razNumber, uint instanceNumber) public constant returns(uint[])\n', '    {\n', '        return (userBetsInEachRazInstance[razNumber][instanceNumber][msg.sender].bets);\n', '    }\n', '    function getUserBetsTimeStampInARazInstance(uint razNumber, uint instanceNumber) public constant returns(uint)\n', '    {\n', '        return (userBetsInEachRazInstance[razNumber][instanceNumber][msg.sender].timestamp);\n', '    }\n', '    \n', '    function IsRazRunning(uint razNumber) constant public returns (bool)\n', '    {\n', '        require(razNumber>=1 && razNumber<=numberOfRazzes);\n', '        for (uint i=1;i<=maxBetsForEachRaz[razNumber];i++)\n', '        {\n', '            if (numbersTaken[razNumber][i] != 0)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '}']
