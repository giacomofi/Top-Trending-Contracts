['pragma solidity ^0.4.19;\n', '/*standart library for uint\n', '*/\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0 || b == 0){\n', '        return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/*\n', 'contract to identify owner\n', '*/\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  address public newOwner;\n', '\n', '  address public techSupport;\n', '\n', '  address public newTechSupport;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier onlyTechSupport() {\n', '    require(msg.sender == techSupport);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    require(_newOwner != address(0));\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() public {\n', '    if (msg.sender == newOwner) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '  function transferTechSupport (address _newSupport) public{\n', '    require (msg.sender == owner || msg.sender == techSupport);\n', '    newTechSupport = _newSupport;\n', '  }\n', '\n', '  function acceptSupport() public{\n', '    if(msg.sender == newTechSupport){\n', '      techSupport = newTechSupport;\n', '    }\n', '  }\n', '}\n', '\n', '/*\n', 'ERC - 20 token contract\n', '*/\n', 'contract VGCToken {\n', '  function setCrowdsaleContract (address _address) public {}\n', '  function burnTokens(address _address) public{}\n', '  function getCrowdsaleBalance() public view returns(uint) {}\n', '  function getRefBalSended () public view returns(bool){}\n', '  function sendCrowdsaleBalance (address _address, uint _value) public {}\n', '  function finishIco() public{}\n', '}\n', '\n', '//Crowdsale contract\n', 'contract Crowdsale is Ownable{\n', '\n', '  using SafeMath for uint;\n', '  //power function\n', '  function pow(uint256 a, uint256 b) internal pure returns (uint256){\n', '   return (a**b);\n', '  }\n', '\n', '  uint decimals = 2;\n', '  // Token contract address\n', '  VGCToken public token;\n', '\n', '  struct Ico{\n', '    uint bonus;\n', '    uint balance;\n', '  }\n', '  // Constructor\n', '  function Crowdsale(address _tokenAddress, address _addressOwner) public{\n', '    token = VGCToken(_tokenAddress);\n', '    owner = _addressOwner;\n', '    structurePreIco.push(Ico(55555555555,1000000*pow(10,decimals))); //80% bonus\n', '    structurePreIco.push(Ico(58823529411,1000000*pow(10,decimals))); //70\n', '    structurePreIco.push(Ico(62500000000,1000000*pow(10,decimals))); //60\n', '    structurePreIco.push(Ico(66666666666,1000000*pow(10,decimals))); //50\n', '    structurePreIco.push(Ico(71428571428,1000000*pow(10,decimals))); //40\n', '    structurePreIco.push(Ico(76923076923,1000000*pow(10,decimals))); //30\n', '\n', '\n', '    structureIco.push(Ico(83333333333,10000000*pow(10,decimals))); //20\n', '    structureIco.push(Ico(90909090909,10000000*pow(10,decimals))); //10\n', '    structureIco.push(Ico(100000000000,10000000*pow(10,decimals))); //0\n', '\n', '    techSupport = msg.sender;\n', '    token.setCrowdsaleContract(this);\n', '  }\n', '  //ICO structures (technical decision)\n', '  Ico[] public structurePreIco;\n', '  Ico[] public structureIco;\n', '    // Buy constants\n', '  uint public tokenPrice = 2000000000000000 / pow(10,decimals);\n', '  uint minDeposit = 100000000000000000; //0.1 ETH\n', '\n', '    // preIco constants\n', '  uint public preIcoStart = 1516320000; // 01/19/2018\n', '  uint public preIcoFinish = 1521590400; // 03/21/2018\n', '\n', '    // Ico constants\n', '  uint public icoStart = 1521590401; // 03/21/2018\n', '  uint public icoFinish = 1529625600; //06/21/2018\n', '  uint icoMinCap = 300000*pow(10,decimals);\n', '\n', '  //check is now preICO\n', '  function isPreIco(uint _time) constant public returns (bool){\n', '    if((preIcoStart <= _time) && (_time <= preIcoFinish)){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //check is now ICO\n', '  function isIco(uint _time) constant public returns (bool){\n', '    if((icoStart <= _time) && (_time <= icoFinish)){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //crowdsale variables\n', '  uint public preIcoTokensSold = 0;\n', '  uint public iCoTokensSold = 0;\n', '  uint public tokensSold = 0;\n', '  uint public ethCollected = 0;\n', '\n', "  //Ethereum investor balances (how much Eth they're donate to ICO)\n", '  mapping (address => uint) public investorBalances;\n', '\n', '  //function calculate how many tokens will be send to investor in preIco\n', '  function  buyIfPreIcoDiscount (uint _value) internal returns(uint,uint) {\n', '    uint buffer = 0;\n', '    uint bufferEth = 0;\n', '    uint bufferValue = _value;\n', '    uint res = 0;\n', '\n', '    for (uint i = 0; i<structurePreIco.length; i++){\n', '      res = _value/(tokenPrice*structurePreIco[i].bonus/100000000000);\n', '\n', '      //Purchase over 5,000 VGC and get extra 10% bonus\n', '      if(res >= (uint)(5000).mul(pow(10,decimals))){\n', '        res = res.add(res/10);\n', '      }\n', '      if (res<=structurePreIco[i].balance){\n', '        structurePreIco[i].balance = structurePreIco[i].balance.sub(res);\n', '        buffer = res.add(buffer);\n', '        return (buffer,0);\n', '      }else {\n', '        buffer = buffer.add(structurePreIco[i].balance);\n', '        bufferEth += structurePreIco[i].balance*tokenPrice*structurePreIco[i].bonus/100000000000;\n', '        _value = _value.sub(structurePreIco[i].balance*tokenPrice*structurePreIco[i].bonus/100000000000);\n', '        structurePreIco[i].balance = 0;\n', '        }\n', '      }\n', '    return  (buffer,bufferValue.sub(bufferEth));\n', '  }\n', '\n', '  //function calculate how many tokens will be send to investor in Ico\n', '  function  buyIfIcoDiscount (uint _value) internal returns(uint,uint) {\n', '    uint buffer = 0;\n', '    uint bufferEth = 0;\n', '    uint bufferValue = _value;\n', '    uint res = 0;\n', '\n', '    for (uint i = 0; i<structureIco.length; i++){\n', '      res = _value/(tokenPrice*structureIco[i].bonus/100000000000);\n', '\n', '      //Purchase over 5,000 VGC and get extra 10% bonus\n', '      if(res >= (uint)(5000).mul(pow(10,decimals))){\n', '        res = res.add(res/10);\n', '      }\n', '        if (res<=structureIco[i].balance){\n', '          bufferEth = bufferEth+_value;\n', '          structureIco[i].balance = structureIco[i].balance.sub(res);\n', '          buffer = res.add(buffer);\n', '          return (buffer,0);\n', '        }else {\n', '          buffer = buffer.add(structureIco[i].balance);\n', '          bufferEth += structureIco[i].balance*tokenPrice*structureIco[i].bonus/100000000000;\n', '          _value = _value.sub(structureIco[i].balance*tokenPrice*structureIco[i].bonus/100000000000);\n', '          structureIco[i].balance = 0;\n', '      }\n', '    }\n', '    return  (buffer,bufferValue.sub(bufferEth));\n', '  }\n', '\n', '  //fallback function (when investor send ether to contract)\n', '  function() public payable{\n', '    require(msg.value >= minDeposit);\n', '    require(isIco(now) || isPreIco(now));\n', '    require(buy(msg.sender,msg.value,now,false)); //redirect to func buy\n', '  }\n', '\n', '  bool public preIcoEnded = false;\n', '  //function buy Tokens\n', '  function buy(address _address, uint _value, uint _time, bool dashboard) internal returns (bool){\n', '    uint tokensForSend;\n', '    uint etherForSend;\n', '    if (isPreIco(_time)){\n', '      (tokensForSend,etherForSend) = buyIfPreIcoDiscount(_value);\n', '      assert (tokensForSend >= 50*pow(10,decimals));\n', '      preIcoTokensSold += tokensForSend;\n', '      if (etherForSend!=0 && !dashboard){\n', '        _address.transfer(etherForSend);\n', '      }\n', '      owner.transfer(this.balance);\n', '    }\n', '    if (isIco(_time)){\n', '      if(!preIcoEnded){\n', '        for (uint i = 0; i<structurePreIco.length; i++){\n', '          structureIco[structureIco.length-1].balance = structureIco[structureIco.length-1].balance.add(structurePreIco[i].balance);\n', '          structurePreIco[i].balance = 0;\n', '        }\n', '       preIcoEnded = true;\n', '      }\n', '      (tokensForSend,etherForSend) = buyIfIcoDiscount(_value);\n', '      assert (tokensForSend >= 50*pow(10,decimals));\n', '      iCoTokensSold += tokensForSend;\n', '\n', '      if (etherForSend!=0 && !dashboard){\n', '        _address.transfer(etherForSend);\n', '      }\n', '      investorBalances[_address] += _value.sub(etherForSend);\n', '\n', '      if (isIcoTrue()){\n', '        owner.transfer(this.balance);\n', '      }\n', '    }\n', '\n', '    tokensSold += tokensForSend;\n', '\n', '    token.sendCrowdsaleBalance(_address,tokensForSend);\n', '\n', '    ethCollected = ethCollected.add(_value.sub(etherForSend));\n', '\n', '    return true;\n', '  }\n', '\n', '  //someone can end ICO using this function (require 3 days after ICO end)\n', '  function finishIco() public {\n', '    require (now > icoFinish + 3 days);\n', '    require (token.getRefBalSended());\n', '    for (uint i = 0; i<structureIco.length; i++){\n', '      structureIco[i].balance = 0;\n', '    }\n', '    for (i = 0; i<structurePreIco.length; i++){\n', '      structurePreIco[i].balance = 0;\n', '    }\n', '    token.finishIco();\n', '  }\n', '\n', '  //function check is ICO complete (minCap exceeded)\n', '  function isIcoTrue() public constant returns (bool){\n', '    if (tokensSold >= icoMinCap){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //if ICO failed and now = ICO finished date +3 days then investor can withdrow his ether\n', '  function refund() public{\n', '    require (!isIcoTrue());\n', '    require (icoFinish + 3 days <= now);\n', '\n', '    token.burnTokens(msg.sender);\n', '    msg.sender.transfer(investorBalances[msg.sender]);\n', '    investorBalances[msg.sender] = 0;\n', '  }\n', '\n', '\n', '  //ICO cabinets function\n', '  function sendEtherManually(address _address, uint _value) public onlyTechSupport{\n', '    require(buy(_address,_value,now,true));\n', '  }\n', '\n', '  //ICO cabinets function, just for view\n', '  function tokensCount(uint _value) public view onlyTechSupport returns(uint res) {\n', '    if (isPreIco(now)){\n', '      (res,) = buyIfPreIcoDiscount(_value);\n', '    }\n', '    if (isIco(now)){\n', '      (res,) = buyIfIcoDiscount(_value);\n', '    }\n', '    return res;\n', '  }\n', '\n', '  function getEtherBalanceOnCrowdsale() public view returns(uint) {\n', '    return this.balance;\n', '  }\n', '}']