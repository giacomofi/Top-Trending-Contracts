['pragma solidity 0.4.21;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Destructible.sol\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/marketplace/Marketplace.sol\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-20\n', ' */\n', 'contract ERC20Interface {\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-721\n', ' */\n', 'contract ERC721Interface {\n', '    function ownerOf(uint256 assetId) public view returns (address);\n', '    function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '    function isAuthorized(address operator, uint256 assetId) public view returns (bool);\n', '}\n', '\n', 'contract Marketplace is Ownable, Pausable, Destructible {\n', '    using SafeMath for uint256;\n', '\n', '    ERC20Interface public acceptedToken;\n', '    ERC721Interface public nonFungibleRegistry;\n', '\n', '    struct Auction {\n', '        // Auction ID\n', '        bytes32 id;\n', '        // Owner of the NFT\n', '        address seller;\n', '        // Price (in wei) for the published item\n', '        uint256 price;\n', '        // Time when this sale ends\n', '        uint256 expiresAt;\n', '    }\n', '\n', '    mapping (uint256 => Auction) public auctionByAssetId;\n', '\n', '    uint256 public ownerCutPercentage;\n', '    uint256 public publicationFeeInWei;\n', '\n', '    /* EVENTS */\n', '    event AuctionCreated(\n', '        bytes32 id,\n', '        uint256 indexed assetId,\n', '        address indexed seller, \n', '        uint256 priceInWei, \n', '        uint256 expiresAt\n', '    );\n', '    event AuctionSuccessful(\n', '        bytes32 id,\n', '        uint256 indexed assetId, \n', '        address indexed seller, \n', '        uint256 totalPrice, \n', '        address indexed winner\n', '    );\n', '    event AuctionCancelled(\n', '        bytes32 id,\n', '        uint256 indexed assetId, \n', '        address indexed seller\n', '    );\n', '\n', '    event ChangedPublicationFee(uint256 publicationFee);\n', '    event ChangedOwnerCut(uint256 ownerCut);\n', '\n', '\n', '    /**\n', '     * @dev Constructor for this contract.\n', '     * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\n', '     * @param _nonFungibleRegistry - Address of the ERC721 registry contract.\n', '     */\n', '    function Marketplace(address _acceptedToken, address _nonFungibleRegistry) public {\n', '        acceptedToken = ERC20Interface(_acceptedToken);\n', '        nonFungibleRegistry = ERC721Interface(_nonFungibleRegistry);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the publication fee that&#39;s charged to users to publish items\n', '     * @param publicationFee - Fee amount in wei this contract charges to publish an item\n', '     */\n', '    function setPublicationFee(uint256 publicationFee) onlyOwner public {\n', '        publicationFeeInWei = publicationFee;\n', '\n', '        ChangedPublicationFee(publicationFeeInWei);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the share cut for the owner of the contract that&#39;s\n', '     *  charged to the seller on a successful sale.\n', '     * @param ownerCut - Share amount, from 0 to 100\n', '     */\n', '    function setOwnerCut(uint8 ownerCut) onlyOwner public {\n', '        require(ownerCut < 100);\n', '\n', '        ownerCutPercentage = ownerCut;\n', '\n', '        ChangedOwnerCut(ownerCutPercentage);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel an already published order\n', '     * @param assetId - ID of the published NFT\n', '     * @param priceInWei - Price in Wei for the supported coin.\n', '     * @param expiresAt - Duration of the auction (in hours)\n', '     */\n', '    function createOrder(uint256 assetId, uint256 priceInWei, uint256 expiresAt) public whenNotPaused {\n', '        address assetOwner = nonFungibleRegistry.ownerOf(assetId);\n', '        require(msg.sender == assetOwner);\n', '        require(nonFungibleRegistry.isAuthorized(address(this), assetId));\n', '        require(priceInWei > 0);\n', '        require(expiresAt > now.add(1 minutes));\n', '\n', '        bytes32 auctionId = keccak256(\n', '            block.timestamp, \n', '            assetOwner,\n', '            assetId, \n', '            priceInWei\n', '        );\n', '\n', '        auctionByAssetId[assetId] = Auction({\n', '            id: auctionId,\n', '            seller: assetOwner,\n', '            price: priceInWei,\n', '            expiresAt: expiresAt\n', '        });\n', '\n', '        // Check if there&#39;s a publication fee and\n', '        // transfer the amount to marketplace owner.\n', '        if (publicationFeeInWei > 0) {\n', '            require(acceptedToken.transferFrom(\n', '                msg.sender,\n', '                owner,\n', '                publicationFeeInWei\n', '            ));\n', '        }\n', '\n', '        AuctionCreated(\n', '            auctionId,\n', '            assetId, \n', '            assetOwner,\n', '            priceInWei, \n', '            expiresAt\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel an already published order\n', '     *  can only be canceled by seller or the contract owner.\n', '     * @param assetId - ID of the published NFT\n', '     */\n', '    function cancelOrder(uint256 assetId) public whenNotPaused {\n', '        require(auctionByAssetId[assetId].seller == msg.sender || msg.sender == owner);\n', '\n', '        bytes32 auctionId = auctionByAssetId[assetId].id;\n', '        address auctionSeller = auctionByAssetId[assetId].seller;\n', '        delete auctionByAssetId[assetId];\n', '\n', '        AuctionCancelled(auctionId, assetId, auctionSeller);\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the sale for a published NTF\n', '     * @param assetId - ID of the published NFT\n', '     */\n', '    function executeOrder(uint256 assetId, uint256 price) public whenNotPaused {\n', '        address seller = auctionByAssetId[assetId].seller;\n', '\n', '        require(seller != address(0));\n', '        require(seller != msg.sender);\n', '        require(auctionByAssetId[assetId].price == price);\n', '        require(now < auctionByAssetId[assetId].expiresAt);\n', '\n', '        require(seller == nonFungibleRegistry.ownerOf(assetId));\n', '\n', '        uint saleShareAmount = 0;\n', '\n', '        if (ownerCutPercentage > 0) {\n', '\n', '            // Calculate sale share\n', '            saleShareAmount = price.mul(ownerCutPercentage).div(100);\n', '\n', '            // Transfer share amount for marketplace Owner.\n', '            acceptedToken.transferFrom(\n', '                msg.sender,\n', '                owner,\n', '                saleShareAmount\n', '            );\n', '        }\n', '\n', '        // Transfer sale amount to seller\n', '        acceptedToken.transferFrom(\n', '            msg.sender,\n', '            seller,\n', '            price.sub(saleShareAmount)\n', '        );\n', '\n', '        // Transfer asset owner\n', '        nonFungibleRegistry.safeTransferFrom(\n', '            seller,\n', '            msg.sender,\n', '            assetId\n', '        );\n', '\n', '\n', '        bytes32 auctionId = auctionByAssetId[assetId].id;\n', '        delete auctionByAssetId[assetId];\n', '\n', '        AuctionSuccessful(auctionId, assetId, seller, price, msg.sender);\n', '    }\n', ' }']
['pragma solidity 0.4.21;\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Destructible.sol\n', '\n', '/**\n', ' * @title Destructible\n', ' * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n', ' */\n', 'contract Destructible is Ownable {\n', '\n', '  function Destructible() public payable { }\n', '\n', '  /**\n', '   * @dev Transfers the current balance to the owner and terminates the contract.\n', '   */\n', '  function destroy() onlyOwner public {\n', '    selfdestruct(owner);\n', '  }\n', '\n', '  function destroyAndSend(address _recipient) onlyOwner public {\n', '    selfdestruct(_recipient);\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/marketplace/Marketplace.sol\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-20\n', ' */\n', 'contract ERC20Interface {\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '}\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-721\n', ' */\n', 'contract ERC721Interface {\n', '    function ownerOf(uint256 assetId) public view returns (address);\n', '    function safeTransferFrom(address from, address to, uint256 assetId) public;\n', '    function isAuthorized(address operator, uint256 assetId) public view returns (bool);\n', '}\n', '\n', 'contract Marketplace is Ownable, Pausable, Destructible {\n', '    using SafeMath for uint256;\n', '\n', '    ERC20Interface public acceptedToken;\n', '    ERC721Interface public nonFungibleRegistry;\n', '\n', '    struct Auction {\n', '        // Auction ID\n', '        bytes32 id;\n', '        // Owner of the NFT\n', '        address seller;\n', '        // Price (in wei) for the published item\n', '        uint256 price;\n', '        // Time when this sale ends\n', '        uint256 expiresAt;\n', '    }\n', '\n', '    mapping (uint256 => Auction) public auctionByAssetId;\n', '\n', '    uint256 public ownerCutPercentage;\n', '    uint256 public publicationFeeInWei;\n', '\n', '    /* EVENTS */\n', '    event AuctionCreated(\n', '        bytes32 id,\n', '        uint256 indexed assetId,\n', '        address indexed seller, \n', '        uint256 priceInWei, \n', '        uint256 expiresAt\n', '    );\n', '    event AuctionSuccessful(\n', '        bytes32 id,\n', '        uint256 indexed assetId, \n', '        address indexed seller, \n', '        uint256 totalPrice, \n', '        address indexed winner\n', '    );\n', '    event AuctionCancelled(\n', '        bytes32 id,\n', '        uint256 indexed assetId, \n', '        address indexed seller\n', '    );\n', '\n', '    event ChangedPublicationFee(uint256 publicationFee);\n', '    event ChangedOwnerCut(uint256 ownerCut);\n', '\n', '\n', '    /**\n', '     * @dev Constructor for this contract.\n', '     * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\n', '     * @param _nonFungibleRegistry - Address of the ERC721 registry contract.\n', '     */\n', '    function Marketplace(address _acceptedToken, address _nonFungibleRegistry) public {\n', '        acceptedToken = ERC20Interface(_acceptedToken);\n', '        nonFungibleRegistry = ERC721Interface(_nonFungibleRegistry);\n', '    }\n', '\n', '    /**\n', "     * @dev Sets the publication fee that's charged to users to publish items\n", '     * @param publicationFee - Fee amount in wei this contract charges to publish an item\n', '     */\n', '    function setPublicationFee(uint256 publicationFee) onlyOwner public {\n', '        publicationFeeInWei = publicationFee;\n', '\n', '        ChangedPublicationFee(publicationFeeInWei);\n', '    }\n', '\n', '    /**\n', "     * @dev Sets the share cut for the owner of the contract that's\n", '     *  charged to the seller on a successful sale.\n', '     * @param ownerCut - Share amount, from 0 to 100\n', '     */\n', '    function setOwnerCut(uint8 ownerCut) onlyOwner public {\n', '        require(ownerCut < 100);\n', '\n', '        ownerCutPercentage = ownerCut;\n', '\n', '        ChangedOwnerCut(ownerCutPercentage);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel an already published order\n', '     * @param assetId - ID of the published NFT\n', '     * @param priceInWei - Price in Wei for the supported coin.\n', '     * @param expiresAt - Duration of the auction (in hours)\n', '     */\n', '    function createOrder(uint256 assetId, uint256 priceInWei, uint256 expiresAt) public whenNotPaused {\n', '        address assetOwner = nonFungibleRegistry.ownerOf(assetId);\n', '        require(msg.sender == assetOwner);\n', '        require(nonFungibleRegistry.isAuthorized(address(this), assetId));\n', '        require(priceInWei > 0);\n', '        require(expiresAt > now.add(1 minutes));\n', '\n', '        bytes32 auctionId = keccak256(\n', '            block.timestamp, \n', '            assetOwner,\n', '            assetId, \n', '            priceInWei\n', '        );\n', '\n', '        auctionByAssetId[assetId] = Auction({\n', '            id: auctionId,\n', '            seller: assetOwner,\n', '            price: priceInWei,\n', '            expiresAt: expiresAt\n', '        });\n', '\n', "        // Check if there's a publication fee and\n", '        // transfer the amount to marketplace owner.\n', '        if (publicationFeeInWei > 0) {\n', '            require(acceptedToken.transferFrom(\n', '                msg.sender,\n', '                owner,\n', '                publicationFeeInWei\n', '            ));\n', '        }\n', '\n', '        AuctionCreated(\n', '            auctionId,\n', '            assetId, \n', '            assetOwner,\n', '            priceInWei, \n', '            expiresAt\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel an already published order\n', '     *  can only be canceled by seller or the contract owner.\n', '     * @param assetId - ID of the published NFT\n', '     */\n', '    function cancelOrder(uint256 assetId) public whenNotPaused {\n', '        require(auctionByAssetId[assetId].seller == msg.sender || msg.sender == owner);\n', '\n', '        bytes32 auctionId = auctionByAssetId[assetId].id;\n', '        address auctionSeller = auctionByAssetId[assetId].seller;\n', '        delete auctionByAssetId[assetId];\n', '\n', '        AuctionCancelled(auctionId, assetId, auctionSeller);\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the sale for a published NTF\n', '     * @param assetId - ID of the published NFT\n', '     */\n', '    function executeOrder(uint256 assetId, uint256 price) public whenNotPaused {\n', '        address seller = auctionByAssetId[assetId].seller;\n', '\n', '        require(seller != address(0));\n', '        require(seller != msg.sender);\n', '        require(auctionByAssetId[assetId].price == price);\n', '        require(now < auctionByAssetId[assetId].expiresAt);\n', '\n', '        require(seller == nonFungibleRegistry.ownerOf(assetId));\n', '\n', '        uint saleShareAmount = 0;\n', '\n', '        if (ownerCutPercentage > 0) {\n', '\n', '            // Calculate sale share\n', '            saleShareAmount = price.mul(ownerCutPercentage).div(100);\n', '\n', '            // Transfer share amount for marketplace Owner.\n', '            acceptedToken.transferFrom(\n', '                msg.sender,\n', '                owner,\n', '                saleShareAmount\n', '            );\n', '        }\n', '\n', '        // Transfer sale amount to seller\n', '        acceptedToken.transferFrom(\n', '            msg.sender,\n', '            seller,\n', '            price.sub(saleShareAmount)\n', '        );\n', '\n', '        // Transfer asset owner\n', '        nonFungibleRegistry.safeTransferFrom(\n', '            seller,\n', '            msg.sender,\n', '            assetId\n', '        );\n', '\n', '\n', '        bytes32 auctionId = auctionByAssetId[assetId].id;\n', '        delete auctionByAssetId[assetId];\n', '\n', '        AuctionSuccessful(auctionId, assetId, seller, price, msg.sender);\n', '    }\n', ' }']
