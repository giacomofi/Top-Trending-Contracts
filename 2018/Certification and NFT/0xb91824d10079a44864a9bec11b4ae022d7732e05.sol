['pragma solidity ^0.4.8;\n', '\n', '//代币合约\n', ' contract token {\n', '     string public name = "cao token"; //代币名称\n', '     string public symbol = "CAO"; //代币符号比如&#39;$&#39;\n', '     uint8 public decimals = 18;  //代币单位，展示的小数点后面多少个0,和以太币一样后面是是18个0\n', '     uint256 public totalSupply; //代币总量,这里没有做限制,你也可以限定\n', '\n', '    //地址对应的余额\n', '     mapping (address => uint256) public balanceOf;\n', '\n', '     event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件\n', '\n', '     /* 初始化合约，并且把初始的所有代币都给这合约的创建者\n', '      * @param _owned 合约的管理者\n', '      * @param tokenName 代币名称\n', '      * @param tokenSymbol 代币符号\n', '      */\n', '\n', '     function token(address _owned, string tokenName, string tokenSymbol) public {\n', '         //合约的创建者获得的所有代币\n', '         balanceOf[_owned] = totalSupply;\n', '         name = tokenName;\n', '         symbol = tokenSymbol;\n', '     }\n', '\n', '     /**\n', '      * 转帐，具体可以根据自己的需求来实现\n', '      * @param  _to address 接受代币的地址\n', '      * @param  _value uint256 接受代币的数量\n', '      */\n', '     function transfer(address _to, uint256 _value) public{\n', '       //从发送者减掉发送额\n', '       balanceOf[msg.sender] -= _value;\n', '\n', '       //给接收者加上相同的量\n', '       balanceOf[_to] += _value;\n', '\n', '       //通知任何监听该交易的客户端\n', '       Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '     /**\n', '      * 增加代币，并将代币发送给捐赠新用户,即所谓的增发,本文固定总量,\n', '      * @param  _to address 接受代币的地址\n', '      * @param  _amount uint256 接受代币的数量\n', '      */\n', '     function issue(address _to, uint256 _amount) public{\n', '         totalSupply = totalSupply + _amount;\n', '         balanceOf[_to] += _amount;\n', '\n', '         //通知任何监听该交易的客户端\n', '         Transfer(this, _to, _amount);\n', '     }\n', '  }\n', '\n', '/**\n', ' * 众筹合约\n', ' */\n', 'contract CAOsale is token {\n', '    address public beneficiary = msg.sender; //受益人地址，测试时为合约创建者,自己发自己\n', '    uint public fundingGoal;  //众筹目标，单位是ether\n', '    uint public amountRaised; //已筹集金额数量， 单位是wei\n', '    uint public deadline; //截止时间\n', '    uint public price;  //代币价格\n', '    bool public fundingGoalReached = false;  //达成众筹目标,默认未完成\n', '    bool public crowdsaleClosed = false; //众筹关闭,默认不关闭\n', '\n', '\n', '    mapping(address => uint256) public balance; //保存众筹地址\n', '\n', '    //记录已接收的eth通知\n', '    event GoalReached(address _beneficiary, uint _amountRaised);\n', '\n', '    //转帐时事件\n', '    event FundTransfer(address _backer, uint _amount, bool _isContribution);\n', '\n', '    /**\n', '     * 初始化构造函数\n', '     * @param fundingGoalInEthers 众筹以太币总量\n', '     * @param durationInMinutes 众筹截止,单位是分钟\n', '     * @param tokenName 代币名称\n', '     * @param tokenSymbol 代币符号\n', '     */\n', '\n', '    //  在初始化众筹合约构造函数的时候，我们会将众筹合约的帐户地址，\n', '    //  传递给代币做为管理地址，这里使用的是关键字this表示当前合约的地址，\n', '    //  也可以传递给某个人，初始创建时奖励给这个人指定量的代币。\n', '    function CAOsale(\n', '        uint fundingGoalInEthers,\n', '        uint durationInMinutes,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public token(this, tokenName, tokenSymbol){\n', '        fundingGoal = fundingGoalInEthers * 1 ether;\n', '        deadline = now + durationInMinutes * 1 minutes;\n', '        price = 0.00001 ether; //1个以太币可以买 1 个代币\n', '    }\n', '\n', '    // 在众筹合约中，用于设置众筹以太币总量、众筹截止时间、以太币和代币的兑换比例,\n', '    // 如果不使用单位进行声明换算，默认在以太坊中，所有的单位都是wei，1 ether=10^18 wei：\n', '\n', '    /**\n', '     * 默认函数\n', '     *\n', '     * 默认函数，可以向合约直接打款\n', '     */\n', '    function () payable public{\n', '        //判断是否关闭众筹\n', '        //如果关闭,则禁止打款.\n', '        require(!crowdsaleClosed);\n', '        // if (!crowdsaleClosed) throw; 这个是老写法,版本大坑啊!\n', '        uint amount = msg.value;\n', '\n', '        //捐款人的金额累加\n', '        balance[msg.sender] += amount;\n', '\n', '        //捐款总额累加\n', '        amountRaised += amount;\n', '\n', '        //转帐操作，转多少代币给捐款人\n', '        issue(msg.sender, amount / price * 10 ** uint256(decimals));\n', '        FundTransfer(msg.sender, amount, true);\n', '    }\n', '\n', '    /**\n', '     * 判断是否已经过了众筹截止限期\n', '     */\n', '    modifier afterDeadline() {\n', '        // if (this == msg.sender && now >= deadline) _; 并且该方法只能被创建者调用,严格一点\n', '        if (now >= deadline) _;\n', '        }\n', '\n', '    /**\n', '     * 检测众筹目标是否完成\n', '     */\n', '    function checkGoalReached() afterDeadline public{\n', '        if (amountRaised >= fundingGoal){\n', '            //达成众筹目标\n', '            fundingGoalReached = true;\n', '            GoalReached(beneficiary, amountRaised);\n', '        }\n', '        //关闭众筹,禁止打款\n', '        crowdsaleClosed = true;\n', '    }\n', '\n', '    /**\n', '     * 收回资金\n', '     * 检查是否达到了目标或时间限制，如果有，并且达到了资金目标，\n', '     * 将全部金额发送给受益人。如果没有达到目标，每个贡献者都可以退出\n', '     * 他们贡献的金额\n', '     */\n', '    function safeWithdrawal() afterDeadline public{\n', '\n', '        //如果没有达成众筹目标,清空代币\n', '        if (!fundingGoalReached) {\n', '            //获取合约调用者已捐款余额\n', '            uint amount = balance[msg.sender];\n', '\n', '            if (amount > 0) {\n', '                //返回合约发起者所有余额\n', '                //transfer是自带的方法,就是朝msg.sender转入数量的意思.类似方法还有 send\n', '                //文档具体地址:http://solidity.readthedocs.io/en/develop/types.html#members-of-addresses\n', '                msg.sender.transfer(amount);\n', '                FundTransfer(msg.sender, amount, false);\n', '                balance[msg.sender] = 0;\n', '            }\n', '        }\n', '\n', '        //如果达成众筹目标，并且合约调用者是受益人\n', '        if (fundingGoalReached && beneficiary == msg.sender) {\n', '\n', '            //将所有捐款从合约中给受益人\n', '            beneficiary.transfer(amountRaised);\n', '\n', '            FundTransfer(beneficiary, amount, false);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '//代币合约\n', ' contract token {\n', '     string public name = "cao token"; //代币名称\n', '     string public symbol = "CAO"; //代币符号比如\'$\'\n', '     uint8 public decimals = 18;  //代币单位，展示的小数点后面多少个0,和以太币一样后面是是18个0\n', '     uint256 public totalSupply; //代币总量,这里没有做限制,你也可以限定\n', '\n', '    //地址对应的余额\n', '     mapping (address => uint256) public balanceOf;\n', '\n', '     event Transfer(address indexed from, address indexed to, uint256 value);  //转帐通知事件\n', '\n', '     /* 初始化合约，并且把初始的所有代币都给这合约的创建者\n', '      * @param _owned 合约的管理者\n', '      * @param tokenName 代币名称\n', '      * @param tokenSymbol 代币符号\n', '      */\n', '\n', '     function token(address _owned, string tokenName, string tokenSymbol) public {\n', '         //合约的创建者获得的所有代币\n', '         balanceOf[_owned] = totalSupply;\n', '         name = tokenName;\n', '         symbol = tokenSymbol;\n', '     }\n', '\n', '     /**\n', '      * 转帐，具体可以根据自己的需求来实现\n', '      * @param  _to address 接受代币的地址\n', '      * @param  _value uint256 接受代币的数量\n', '      */\n', '     function transfer(address _to, uint256 _value) public{\n', '       //从发送者减掉发送额\n', '       balanceOf[msg.sender] -= _value;\n', '\n', '       //给接收者加上相同的量\n', '       balanceOf[_to] += _value;\n', '\n', '       //通知任何监听该交易的客户端\n', '       Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '     /**\n', '      * 增加代币，并将代币发送给捐赠新用户,即所谓的增发,本文固定总量,\n', '      * @param  _to address 接受代币的地址\n', '      * @param  _amount uint256 接受代币的数量\n', '      */\n', '     function issue(address _to, uint256 _amount) public{\n', '         totalSupply = totalSupply + _amount;\n', '         balanceOf[_to] += _amount;\n', '\n', '         //通知任何监听该交易的客户端\n', '         Transfer(this, _to, _amount);\n', '     }\n', '  }\n', '\n', '/**\n', ' * 众筹合约\n', ' */\n', 'contract CAOsale is token {\n', '    address public beneficiary = msg.sender; //受益人地址，测试时为合约创建者,自己发自己\n', '    uint public fundingGoal;  //众筹目标，单位是ether\n', '    uint public amountRaised; //已筹集金额数量， 单位是wei\n', '    uint public deadline; //截止时间\n', '    uint public price;  //代币价格\n', '    bool public fundingGoalReached = false;  //达成众筹目标,默认未完成\n', '    bool public crowdsaleClosed = false; //众筹关闭,默认不关闭\n', '\n', '\n', '    mapping(address => uint256) public balance; //保存众筹地址\n', '\n', '    //记录已接收的eth通知\n', '    event GoalReached(address _beneficiary, uint _amountRaised);\n', '\n', '    //转帐时事件\n', '    event FundTransfer(address _backer, uint _amount, bool _isContribution);\n', '\n', '    /**\n', '     * 初始化构造函数\n', '     * @param fundingGoalInEthers 众筹以太币总量\n', '     * @param durationInMinutes 众筹截止,单位是分钟\n', '     * @param tokenName 代币名称\n', '     * @param tokenSymbol 代币符号\n', '     */\n', '\n', '    //  在初始化众筹合约构造函数的时候，我们会将众筹合约的帐户地址，\n', '    //  传递给代币做为管理地址，这里使用的是关键字this表示当前合约的地址，\n', '    //  也可以传递给某个人，初始创建时奖励给这个人指定量的代币。\n', '    function CAOsale(\n', '        uint fundingGoalInEthers,\n', '        uint durationInMinutes,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public token(this, tokenName, tokenSymbol){\n', '        fundingGoal = fundingGoalInEthers * 1 ether;\n', '        deadline = now + durationInMinutes * 1 minutes;\n', '        price = 0.00001 ether; //1个以太币可以买 1 个代币\n', '    }\n', '\n', '    // 在众筹合约中，用于设置众筹以太币总量、众筹截止时间、以太币和代币的兑换比例,\n', '    // 如果不使用单位进行声明换算，默认在以太坊中，所有的单位都是wei，1 ether=10^18 wei：\n', '\n', '    /**\n', '     * 默认函数\n', '     *\n', '     * 默认函数，可以向合约直接打款\n', '     */\n', '    function () payable public{\n', '        //判断是否关闭众筹\n', '        //如果关闭,则禁止打款.\n', '        require(!crowdsaleClosed);\n', '        // if (!crowdsaleClosed) throw; 这个是老写法,版本大坑啊!\n', '        uint amount = msg.value;\n', '\n', '        //捐款人的金额累加\n', '        balance[msg.sender] += amount;\n', '\n', '        //捐款总额累加\n', '        amountRaised += amount;\n', '\n', '        //转帐操作，转多少代币给捐款人\n', '        issue(msg.sender, amount / price * 10 ** uint256(decimals));\n', '        FundTransfer(msg.sender, amount, true);\n', '    }\n', '\n', '    /**\n', '     * 判断是否已经过了众筹截止限期\n', '     */\n', '    modifier afterDeadline() {\n', '        // if (this == msg.sender && now >= deadline) _; 并且该方法只能被创建者调用,严格一点\n', '        if (now >= deadline) _;\n', '        }\n', '\n', '    /**\n', '     * 检测众筹目标是否完成\n', '     */\n', '    function checkGoalReached() afterDeadline public{\n', '        if (amountRaised >= fundingGoal){\n', '            //达成众筹目标\n', '            fundingGoalReached = true;\n', '            GoalReached(beneficiary, amountRaised);\n', '        }\n', '        //关闭众筹,禁止打款\n', '        crowdsaleClosed = true;\n', '    }\n', '\n', '    /**\n', '     * 收回资金\n', '     * 检查是否达到了目标或时间限制，如果有，并且达到了资金目标，\n', '     * 将全部金额发送给受益人。如果没有达到目标，每个贡献者都可以退出\n', '     * 他们贡献的金额\n', '     */\n', '    function safeWithdrawal() afterDeadline public{\n', '\n', '        //如果没有达成众筹目标,清空代币\n', '        if (!fundingGoalReached) {\n', '            //获取合约调用者已捐款余额\n', '            uint amount = balance[msg.sender];\n', '\n', '            if (amount > 0) {\n', '                //返回合约发起者所有余额\n', '                //transfer是自带的方法,就是朝msg.sender转入数量的意思.类似方法还有 send\n', '                //文档具体地址:http://solidity.readthedocs.io/en/develop/types.html#members-of-addresses\n', '                msg.sender.transfer(amount);\n', '                FundTransfer(msg.sender, amount, false);\n', '                balance[msg.sender] = 0;\n', '            }\n', '        }\n', '\n', '        //如果达成众筹目标，并且合约调用者是受益人\n', '        if (fundingGoalReached && beneficiary == msg.sender) {\n', '\n', '            //将所有捐款从合约中给受益人\n', '            beneficiary.transfer(amountRaised);\n', '\n', '            FundTransfer(beneficiary, amount, false);\n', '        }\n', '    }\n', '}']
