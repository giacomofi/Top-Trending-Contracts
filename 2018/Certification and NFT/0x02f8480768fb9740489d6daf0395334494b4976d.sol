['pragma solidity ^0.4.24;\n', '\n', '\n', 'interface App \n', '{\n', '    function mint(address receiver, uint64 wad) external returns (bool);\n', '    function changeGatewayAddr(address newer) external returns (bool);\n', '}\n', '\n', 'contract GatewayVote \n', '{\n', '    \n', '    struct Vote \n', '    {\n', '        bool done;\n', '        uint poll;\n', '        mapping(uint256 => uint8) voters;\n', '    }\n', '    \n', '    struct AppInfo\n', '    {\n', '        uint32 chainCode;\n', '        uint32 tokenCode;\n', '        uint256 app;\n', '    }\n', '\n', '\n', '    // FIELDS\n', '    bool    public mStopped;\n', '    uint32  public mMaxAppCode;\n', '    uint32  public mMaxChainCode;\n', '    uint256 public mNumVoters;\n', '    \n', '    mapping(uint256 => uint8) mVoters;\n', '    mapping(uint256 => Vote) mVotesStore;\n', '    \n', '    mapping(uint256 => uint32) mAppToCode;\n', '    mapping(uint32 => AppInfo) mCodeToAppInfo;\n', '    \n', '    mapping(string => uint32) mChainToCode;\n', '    mapping(uint32 => string) mCodeToChain;\n', '    \n', '\n', '    // EVENTS\n', '    event Stopped(uint256 indexed operation);\n', '    event Started(uint256 indexed operation);\n', '    \n', '    event Confirmation(address voter, uint256 indexed operation);\n', '    event OperationDone(address voter, uint256 indexed operation);\n', '    event Revoke(address revoker, uint256 indexed operation);\n', '    \n', '    event VoterChanged(address oldVoter, address newVoter, uint256 indexed operation);\n', '    event VoterAdded(address newVoter, uint256 indexed operation);\n', '    event VoterRemoved(address oldVoter, uint256 indexed operation);\n', '    \n', '    event ChainAdded(string chain, uint256 indexed operation);\n', '    \n', '    event AppAdded(address app, uint32 chain, uint32 token, uint256 indexed operation);\n', '    event AppRemoved(uint32 code, uint256 indexed operation);\n', '    \n', '    event MintByGateway(uint32 appCode, address receiver, uint64 wad, uint256 indexed operation);\n', '    event BurnForGateway(uint32 appCode, address from, string dstDescribe, uint64 wad, uint64 fee);\n', '\n', '    event GatewayAddrChanged(uint32 appCode, address newer, uint256 indexed operation);\n', '\n', '    // METHODS\n', '\n', '    constructor(address[] voters) public \n', '    {\n', '        mNumVoters = voters.length;\n', '        for (uint i = 0; i < voters.length; ++i)\n', '        {\n', '            mVoters[uint(voters[i])] = 1;\n', '        }\n', '    }\n', '    \n', '    function isVoter(address voter) public view returns (bool) \n', '    {\n', '        return mVoters[uint(voter)] == 1;\n', '    }\n', '    \n', '    function isApper(address app) public view returns (bool) \n', '    {\n', '        return mAppToCode[uint(app)] > 0;\n', '    }\n', '    \n', '    function isAppCode(uint32 code) public view returns (bool) \n', '    {\n', '        return mAppToCode[uint256(mCodeToAppInfo[code].app)] == code;\n', '    }\n', '    \n', '    function getAppAddress(uint32 code) public view returns (address) \n', '    {\n', '        return address(mCodeToAppInfo[code].app);\n', '    }\n', '    \n', '    function getAppChainCode(uint32 code) public view returns (uint32) \n', '    {\n', '        return mCodeToAppInfo[code].chainCode;\n', '    }\n', '    \n', '    function getAppTokenCode(uint32 code) public view returns (uint32)\n', '    {\n', '        return mCodeToAppInfo[code].tokenCode;\n', '    }\n', '    \n', '    function getAppInfo(uint32 code) public view returns (address, uint32, uint32)\n', '    {\n', '        return (address(mCodeToAppInfo[code].app), mCodeToAppInfo[code].chainCode, mCodeToAppInfo[code].tokenCode);\n', '    }\n', '    \n', '    function getAppCode(address app) public view returns (uint32) \n', '    {\n', '        return mAppToCode[uint256(app)];\n', '    }\n', '    \n', '    function isCaller(address addr) public view returns (bool) \n', '    {\n', '        return isVoter(addr) || isApper(addr);\n', '    }\n', '    \n', '    function isChain(string chain) public view returns (bool) \n', '    {\n', '        return mChainToCode[chain] > 0;\n', '    }\n', '    \n', '    function isChainCode(uint32 code) public view returns (bool)\n', '    {\n', '        return mChainToCode[mCodeToChain[code]] == code;\n', '    }\n', '    \n', '    function getChainName(uint32 code) public view returns (string) \n', '    {\n', '        return mCodeToChain[code];\n', '    }\n', '    \n', '    function getChainCode(string chain) public view returns (uint32) \n', '    {\n', '        return mChainToCode[chain];\n', '    }\n', '    \n', '    function hasConfirmed(uint256 operation, address voter) public constant returns (bool) \n', '    {\n', '        if (mVotesStore[operation].voters[uint(voter)] == 1) \n', '        {\n', '            return true;\n', '        } \n', '        else \n', '        {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function major(uint total) internal pure returns (uint r) \n', '    {\n', '        r = (total * 2 + 1);\n', '        return r%3==0 ? r/3 : r/3+1;\n', '    }\n', '\n', '    function confirmation(uint256 operation) internal returns (bool) \n', '    {\n', '        Vote storage vote = mVotesStore[operation];\n', '        \n', '        if (vote.done) return;\n', '        \n', '        if (vote.voters[uint(tx.origin)] == 0) \n', '        {\n', '            vote.voters[uint(tx.origin)] = 1;\n', '            vote.poll++;\n', '            emit Confirmation(tx.origin, operation);\n', '        }\n', '        \n', '        //check if poll is enough to go ahead.\n', '        if (vote.poll >= major(mNumVoters)) \n', '        {\n', '            vote.done = true;\n', '            emit OperationDone(tx.origin, operation);\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function stop(string proposal) external \n', '    {\n', '        // the origin tranx sender should be a voter\n', '        // contract should be running\n', '        require(isVoter(tx.origin) && !mStopped);\n', '        \n', '        // wait for voters until poll >= major\n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        // change state\n', '        mStopped = true;\n', '        \n', '        // log output\n', '        emit Stopped(uint(keccak256(msg.data)));\n', '    }\n', '    \n', '    function start(string proposal) external \n', '    {\n', '        \n', '        // the origin tranx sender should be a voter\n', '        // contract should be stopped\n', '        require(isVoter(tx.origin) && mStopped);\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mStopped = false;\n', '        \n', '        emit Started(uint(keccak256(msg.data)));\n', '    }\n', '    \n', '    function revoke(uint256 operation) external \n', '    {\n', '        \n', '        require(isVoter(tx.origin) && !mStopped);\n', '        \n', '        Vote storage vote = mVotesStore[operation];\n', '        \n', '        // the vote for this operation should not be done\n', '        // the origin tranx sender should have voted to this operation\n', '        require(!vote.done && (vote.voters[uint(tx.origin)] ==  1));\n', '        \n', '        vote.poll--;\n', '        delete vote.voters[uint(tx.origin)];\n', '        \n', '        emit Revoke(tx.origin, operation);\n', '    }\n', '    \n', '    function changeVoter(address older, address newer, string proposal) external \n', '    {\n', '        \n', '        require(isVoter(tx.origin) && !mStopped && isVoter(older) && !isVoter(newer));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mVoters[uint(newer)] = 1;\n', '        delete mVoters[uint(older)];\n', '        \n', '        emit VoterChanged(older, newer, uint(keccak256(msg.data)));\n', '    }\n', '    \n', '    function addVoter(address newer, string proposal) external \n', '    {\n', '        \n', '        require(isVoter(tx.origin) && !mStopped && !isVoter(newer));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mNumVoters++;\n', '        mVoters[uint(newer)] = 1;\n', '        \n', '        emit VoterAdded(newer, uint256(keccak256(msg.data)));\n', '    }\n', '    \n', '    function removeVoter(address older, string proposal) external \n', '    {\n', '        \n', '        require(isVoter(tx.origin) && !mStopped && isVoter(older));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mNumVoters--;\n', '        delete mVoters[uint(older)];\n', '        \n', '        emit VoterRemoved(older, uint256(keccak256(msg.data)));\n', '    }\n', '    \n', '    function addChain(string chain, string proposal) external \n', '    {\n', '        require(isVoter(tx.origin) && !mStopped && !isChain(chain));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mMaxChainCode++;\n', '        mChainToCode[chain] = mMaxChainCode;\n', '        mCodeToChain[mMaxChainCode] = chain;\n', '        \n', '        emit ChainAdded(chain, uint256(keccak256(msg.data)));\n', '    }\n', '    \n', '    function addApp(address app, uint32 chain, uint32 token, string proposal) external \n', '    {\n', '        require(isVoter(tx.origin) && !mStopped && !isApper(app) && isChainCode(chain));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        mMaxAppCode++;\n', '        mAppToCode[uint256(app)] =mMaxAppCode;\n', '        mCodeToAppInfo[mMaxAppCode] = AppInfo(chain, token, uint256(app));\n', '        \n', '        emit AppAdded(app, chain, token, uint256(keccak256(msg.data)));\n', '    }\n', '    \n', '    function removeApp(uint32 code, string proposal) external \n', '    {\n', '        require(isVoter(tx.origin) && !mStopped && isAppCode(code));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '    \n', '        delete mAppToCode[uint256(mCodeToAppInfo[code].app)];\n', '        \n', '        emit AppRemoved(code, uint256(keccak256(msg.data)));\n', '    }\n', '    \n', '    function mintByGateway(uint32 appCode, uint64 wad, address receiver, string proposal) external \n', '    {\n', '        require(isVoter(tx.origin) && !mStopped && isAppCode(appCode));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        if (App(address(mCodeToAppInfo[appCode].app)).mint(receiver, wad))\n', '        {\n', '            emit MintByGateway(appCode, receiver, wad, uint256(keccak256(msg.data)));\n', '        }\n', '    }\n', '    \n', '    function changeGatewayAddr(uint32 appCode, address newer, string proposal) external \n', '    {\n', '        require(isVoter(tx.origin) && !mStopped && isAppCode(appCode));\n', '        \n', '        if(!confirmation(uint256(keccak256(msg.data)))) return;\n', '        \n', '        if(App(address(mCodeToAppInfo[appCode].app)).changeGatewayAddr(newer)) \n', '        {\n', '            emit GatewayAddrChanged(appCode, newer, uint256(keccak256(msg.data)));\n', '        }\n', '    }\n', '    \n', '    function burnForGateway(address from, string dstDescribe, uint64 wad, uint64 fee) external \n', '    {\n', '        require(isApper(msg.sender));\n', '        emit BurnForGateway(mAppToCode[uint256(msg.sender)], from, dstDescribe, wad, fee);\n', '    }\n', '}']