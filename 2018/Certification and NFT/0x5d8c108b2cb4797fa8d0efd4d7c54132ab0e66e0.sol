['pragma solidity ^0.4.19;\n', '\n', '// Turn the usage of callcode\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract CreatorEnabled {\n', '    address public creator = 0x0;\n', '\n', '    modifier onlyCreator() { require(msg.sender==creator); _; }\n', '\n', '    function changeCreator(address _to) public onlyCreator {\n', '        creator = _to;\n', '    }\n', '}\n', '\n', '// ERC20 standard\n', 'contract StdToken is SafeMath {\n', '\n', '    mapping(address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint public totalSupply = 0;\n', '\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns(bool) {\n', '      require(0x0!=_to);\n', '\n', '      balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '      balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {\n', '      require(0x0!=_to);\n', '\n', '      balances[_to] = safeAdd(balances[_to],_value);\n', '      balances[_from] = safeSub(balances[_from],_value);\n', '      allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n', '\n', '      Transfer(_from, _to, _value);\n', '      return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '      return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool) {\n', '      // To change the approve amount you first have to reduce the addresses`\n', '      //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '      //  already 0 to mitigate the race condition described here:\n', '      //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '      require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '      allowed[msg.sender][_spender] = _value;\n', '      Approval(msg.sender, _spender, _value);\n', '      return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint _size) {\n', '      require(msg.data.length >= _size + 4);\n', '      _;\n', '    }\n', '}\n', '\n', 'contract IGoldFee {\n', '    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint);\n', '}\n', '\n', 'contract GoldFee is CreatorEnabled {\n', '\n', '    mapping(address => bool) exceptAddresses;\n', '\n', '    function GoldFee() {\n', '        creator = msg.sender;\n', '    }\n', '\n', '    function getMin(uint out)returns (uint) {\n', '        // 0.002 GOLD is min fee\n', '        uint minFee = (2 * 1 ether) / 1000;\n', '        if (out < minFee) {\n', '             return minFee;\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function getMax(uint out)returns (uint) {\n', '        // 0.02 GOLD is max fee\n', '        uint maxFee = (2 * 1 ether) / 100;\n', '        if (out >= maxFee) {\n', '             return maxFee;\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function calculateFee(address _sender, bool _isMigrationStarted, bool _isMigrationFinished, uint _mntpBalance, uint _value) public constant returns(uint)\n', '    {\n', '        return 0;\n', '\n', '       //if this is an excaptional address\n', '       if (exceptAddresses[_sender]) {\n', '            return 0;\n', '       }\n', '\n', '        // When migration process is finished (1 year from Goldmint blockchain launch), then transaction fee is 1% GOLD.\n', '        if (_isMigrationFinished) {\n', '             return (_value / 100);\n', '        }\n', '\n', '        // If the sender holds 0 MNTP, then the transaction fee is 1% GOLD.\n', '\n', '        // If the sender holds at least 10 MNTP, then the transaction fee is 0.333333% GOLD,\n', '        // but not less than 0.002 MNTP\n', '\n', '        // If the sender holds at least 1000 MNTP, then the transaction fee is 0.033333% GOLD,\n', '        // but not less than 0.002 MNTP\n', '\n', '        // If the sender holds at least 10000 MNTP, then the transaction fee is 0.0333333% GOLD,\n', '        // but not more than 0.02 MNTP\n', '        if (_mntpBalance >= (10000 * 1 ether)) {\n', '             return getMax((_value / 100) / 30);\n', '        }\n', '        if (_mntpBalance >= (1000 * 1 ether)) {\n', '             return getMin((_value / 100) / 30);\n', '        }\n', '        if (_mntpBalance >= (10 * 1 ether)) {\n', '             return getMin((_value / 100) / 3);\n', '        }\n', '\n', '        // 1%\n', '        return getMin(_value / 100);\n', '    }\n', '\n', '    function addExceptAddress(address _address) public onlyCreator {\n', '        exceptAddresses[_address] = true;\n', '    }\n', '\n', '    function removeExceptAddress(address _address) public onlyCreator {\n', '        exceptAddresses[_address] = false;\n', '    }\n', '\n', '    function isAddressExcept(address _address) public constant returns(bool) {\n', '        return exceptAddresses[_address];\n', '    }\n', '}\n', '\n', 'contract Gold is StdToken, CreatorEnabled {\n', '\n', '    string public constant name = "GoldMint GOLD cryptoasset";\n', '    string public constant symbol = "GOLD";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // this is used to send fees (that is then distributed as rewards)\n', '    address public migrationAddress = 0x0;\n', '    address public storageControllerAddress = 0x0;\n', '\n', '    address public goldmintTeamAddress = 0x0;\n', '    IMNTP public mntpToken;\n', '    IGoldFee public goldFee;\n', '\n', '\n', '    bool public transfersLocked = false;\n', '    bool public contractLocked = false;\n', '    bool public migrationStarted = false;\n', '    bool public migrationFinished = false;\n', '\n', '    uint public totalIssued = 0;\n', '    uint public totalBurnt = 0;\n', '\n', '    // Modifiers:\n', '    modifier onlyMigration() { require(msg.sender == migrationAddress); _; }\n', '    modifier onlyMigrationOrStorageController() { require(msg.sender == migrationAddress || msg.sender == storageControllerAddress); _; }\n', '    modifier onlyCreatorOrStorageController() { require(msg.sender == creator || msg.sender == storageControllerAddress); _; }\n', '    modifier onlyIfUnlocked() { require(!transfersLocked); _; }\n', '\n', '    // Functions:\n', '    function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {\n', '        creator = msg.sender;\n', '\n', '        mntpToken = IMNTP(_mntpContractAddress);\n', '        goldmintTeamAddress = _goldmintTeamAddress;\n', '        goldFee = IGoldFee(_goldFeeAddress);\n', '    }\n', '\n', '    function setCreator(address _address) public onlyCreator {\n', '       creator = _address;\n', '    }\n', '\n', '    function lockContract(bool _contractLocked) public onlyCreator {\n', '       contractLocked = _contractLocked;\n', '    }\n', '\n', '    function setStorageControllerContractAddress(address _address) public onlyCreator {\n', '        storageControllerAddress = _address;\n', '    }\n', '\n', '    function setMigrationContractAddress(address _migrationAddress) public onlyCreator {\n', '        migrationAddress = _migrationAddress;\n', '    }\n', '\n', '    function setGoldmintTeamAddress(address _teamAddress) public onlyCreator {\n', '        goldmintTeamAddress = _teamAddress;\n', '    }\n', '\n', '    function setGoldFeeAddress(address _goldFeeAddress) public onlyCreator {\n', '        goldFee = IGoldFee(_goldFeeAddress);\n', '    }\n', '\n', '    function issueTokens(address _who, uint _tokens) public onlyCreatorOrStorageController {\n', '        require(!contractLocked);\n', '\n', '        balances[_who] = safeAdd(balances[_who],_tokens);\n', '        totalSupply = safeAdd(totalSupply,_tokens);\n', '        totalIssued = safeAdd(totalIssued,_tokens);\n', '\n', '        Transfer(0x0, _who, _tokens);\n', '    }\n', '\n', '    function burnTokens(address _who, uint _tokens) public onlyMigrationOrStorageController {\n', '        require(!contractLocked);\n', '        balances[_who] = safeSub(balances[_who],_tokens);\n', '        totalSupply = safeSub(totalSupply,_tokens);\n', '        totalBurnt = safeAdd(totalBurnt,_tokens);\n', '    }\n', '\n', '    // there is no way to revert that\n', '    function startMigration() public onlyMigration {\n', '        require(false == migrationStarted);\n', '        migrationStarted = true;\n', '    }\n', '\n', '    // there is no way to revert that\n', '    function finishMigration() public onlyMigration {\n', '        require(true == migrationStarted);\n', '\n', '        migrationFinished = true;\n', '    }\n', '\n', '    function lockTransfer(bool _lock) public onlyMigration {\n', '        transfersLocked = _lock;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public onlyIfUnlocked onlyPayloadSize(2 * 32) returns(bool) {\n', '\n', '        uint yourCurrentMntpBalance = mntpToken.balanceOf(msg.sender);\n', '\n', '        // you can transfer if fee is ZERO\n', '        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\n', '        \n', '        uint sendThis = _value;\n', '        if (0 != fee) {\n', '             sendThis = safeSub(_value,fee);\n', '\n', '             // 1.Transfer fee\n', '             // A -> rewards account\n', '             //\n', '             // Each GOLD token transfer should send transaction fee to\n', '             // GoldmintMigration contract if Migration process is not started.\n', '             // Goldmint team if Migration process is started.\n', '             if (migrationStarted) {\n', '                  super.transfer(goldmintTeamAddress, fee);\n', '             } else {\n', '                  super.transfer(migrationAddress, fee);\n', '             }\n', '        }\n', '        \n', '        // 2.Transfer\n', '        // A -> B\n', '        return super.transfer(_to, sendThis);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyIfUnlocked returns(bool) {\n', '\n', '        uint yourCurrentMntpBalance = mntpToken.balanceOf(_from);\n', '\n', '        uint fee = goldFee.calculateFee(msg.sender, migrationStarted, migrationFinished, yourCurrentMntpBalance, _value);\n', '        if (0 != fee) {\n', '             // 1.Transfer fee\n', '             // A -> rewards account\n', '             //\n', '             // Each GOLD token transfer should send transaction fee to\n', '             // GoldmintMigration contract if Migration process is not started.\n', '             // Goldmint team if Migration process is started.\n', '             if (migrationStarted) {\n', '                  super.transferFrom(_from, goldmintTeamAddress, fee);\n', '             } else {\n', '                  super.transferFrom(_from, migrationAddress, fee);\n', '             }\n', '        }\n', '\n', '        // 2.Transfer\n', '        // A -> B\n', '        uint sendThis = safeSub(_value,fee);\n', '        return super.transferFrom(_from, _to, sendThis);\n', '    }\n', '\n', '    // Used to send rewards)\n', '    function transferRewardWithoutFee(address _to, uint _value) public onlyMigration onlyPayloadSize(2*32) {\n', '        require(0x0!=_to);\n', '\n', '        balances[migrationAddress] = safeSub(balances[migrationAddress],_value);\n', '        balances[_to] = safeAdd(balances[_to],_value);\n', '\n', '        Transfer(migrationAddress, _to, _value);\n', '    }\n', '\n', '    // This is an emergency function that can be called by Creator only\n', '    function rescueAllRewards(address _to) public onlyCreator {\n', '        require(0x0!=_to);\n', '\n', '        uint totalReward = balances[migrationAddress];\n', '\n', '        balances[_to] = safeAdd(balances[_to],totalReward);\n', '        balances[migrationAddress] = 0;\n', '\n', '        Transfer(migrationAddress, _to, totalReward);\n', '    }\n', '\n', '\n', '    function getTotalIssued() public constant returns (uint) {\n', '        return totalIssued;\n', '    }\n', '\n', '    function getTotalBurnt() public constant returns (uint) {\n', '        return totalBurnt;\n', '    }\n', '}\n', '\n', 'contract IMNTP is StdToken {\n', '    // Additional methods that MNTP contract provides\n', '    function lockTransfer(bool _lock);\n', '    function issueTokens(address _who, uint _tokens);\n', '    function burnTokens(address _who, uint _tokens);\n', '}\n', '\n', 'contract GoldmintMigration is CreatorEnabled {\n', '    \n', '    IMNTP public mntpToken;\n', '    Gold public goldToken;\n', '\n', '    address public managerAddress = 0x0;\n', '\n', '    event MntpHold(address _ethAddress, string _gmAddress, uint256 _amount);\n', '    event MntpUnhold(address _ethAddress, uint256 _amount);\n', '    event GoldHold(address _ethAddress, string _gmAddress, uint256 _amount);\n', '    event GoldUnhold(address _ethAddress, uint256 _amount);\n', '\n', '    modifier onlyManagerOrCreator() { require(msg.sender == managerAddress || msg.sender == creator); _; }\n', '\n', '\n', '    function GoldmintMigration(address _mntpContractAddress, address _goldContractAddress) public {\n', '        creator = msg.sender;\n', '\n', '        require(_mntpContractAddress != 0);\n', '        require(_goldContractAddress != 0);\n', '\n', '        mntpToken = IMNTP(_mntpContractAddress);\n', '        goldToken = Gold(_goldContractAddress);\n', '    }\n', '\n', '    function setManagerAddress(address _address) public onlyCreator {\n', '       managerAddress = _address;\n', '    }\n', '\n', '    function lockMntpTransfers(bool _lock) public onlyCreator {\n', '        mntpToken.lockTransfer(_lock);\n', '    }\n', '\n', '    function lockGoldTransfers(bool _lock) public onlyCreator {\n', '        goldToken.lockTransfer(_lock);\n', '    }\n', '\n', '    function unholdMntp(address _ethAddress, uint _amount) public onlyManagerOrCreator {\n', '        uint balance = mntpToken.balanceOf(address(this));\n', '        require(balance >= _amount);\n', '\n', '        mntpToken.transfer(_ethAddress, _amount);\n', '\n', '        MntpUnhold(_ethAddress, _amount);\n', '    }\n', '\n', '    function unholdGold(address _ethAddress, uint _amount) public onlyManagerOrCreator {\n', '        uint balance = goldToken.balanceOf(address(this));\n', '        require(balance >= _amount);\n', '\n', '        goldToken.transfer(_ethAddress, _amount);\n', '\n', '        GoldUnhold(_ethAddress, _amount);\n', '    }\n', '\n', '    // do not allow to send money to this contract...\n', '    function() external payable {\n', '        revert();\n', '    }\n', '}']