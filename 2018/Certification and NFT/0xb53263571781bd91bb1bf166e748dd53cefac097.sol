['pragma solidity ^0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(a <= c);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(a >= b);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn a / b;\n', '\t}\n', '}\n', '\n', '\n', 'contract AuctusToken {\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract AuctusPreSale {\n', '\tfunction getTokenAmount(address who) constant returns (uint256);\n', '}\n', '\n', '\n', 'contract ContractReceiver {\n', '\tfunction tokenFallback(address from, uint256 value, bytes data) public;\n', '}\n', '\n', '\n', 'contract AuctusBonusDistribution is ContractReceiver {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public auctusTokenAddress = 0xc12d099be31567add4e4e4d0D45691C3F58f5663;\n', '\taddress public auctusPreSaleAddress = 0x84D45E60f7036F0DE7dF8ed68E1Ee50471B963BA;\n', '\tuint256 public escrowedTokens;\n', '\tmapping(address => bool) public authorized;\n', '\tmapping(address => bool) public redeemed;\n', '\n', '\tevent Escrow(address indexed from, uint256 value);\n', '\tevent Redeem(address indexed to, uint256 value);\n', '\n', '\tmodifier isAuthorized() {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction AuctusBonusDistribution() public {\n', '\t\tauthorized[msg.sender] = true;\n', '\t}\n', '\n', '\tfunction setAuthorization(address _address, bool _authorized) isAuthorized public {\n', '\t\trequire(_address != address(0) && _address != msg.sender);\n', '\t\tauthorized[_address] = _authorized;\n', '\t}\n', '\n', '\tfunction drainAUC(uint256 value) isAuthorized public {\n', '\t\tassert(AuctusToken(auctusTokenAddress).transfer(msg.sender, value));\n', '\t}\n', '\n', '\tfunction tokenFallback(address from, uint256 value, bytes) public {\n', '\t\trequire(msg.sender == auctusTokenAddress);\n', '\t\tescrowedTokens = escrowedTokens.add(value);\n', '\t\temit Escrow(from, value);\n', '\t}\n', '\n', '\tfunction sendPreSaleBonusMany(address[] _addresses) isAuthorized public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tsendPreSaleBonus(_addresses[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendPreSaleBonus(address _address) public returns (bool) {\n', '\t\tif (!redeemed[_address]) {\n', '\t\t\tuint256 value = AuctusPreSale(auctusPreSaleAddress).getTokenAmount(_address).mul(12).div(100);\n', '\t\t\tif (value > 0) {\n', '\t\t\t\tredeemed[_address] = true;\n', '\t\t\t\tsendBonus(_address, value);\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction sendBonusMany(address[] _addresses, uint256[] _values) isAuthorized public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tsendBonus(_addresses[i], _values[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendBonus(address _address, uint256 value) internal {\n', '\t\tescrowedTokens = escrowedTokens.sub(value);\n', '\t\tassert(AuctusToken(auctusTokenAddress).transfer(_address, value));\n', '\t\temit Redeem(_address, value);\n', '\t}\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '\n', 'library SafeMath {\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\tassert(a <= c);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tassert(a >= b);\n', '\t\treturn a - b;\n', '\t}\n', '\t\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn a / b;\n', '\t}\n', '}\n', '\n', '\n', 'contract AuctusToken {\n', '\tfunction transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', '\n', 'contract AuctusPreSale {\n', '\tfunction getTokenAmount(address who) constant returns (uint256);\n', '}\n', '\n', '\n', 'contract ContractReceiver {\n', '\tfunction tokenFallback(address from, uint256 value, bytes data) public;\n', '}\n', '\n', '\n', 'contract AuctusBonusDistribution is ContractReceiver {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public auctusTokenAddress = 0xc12d099be31567add4e4e4d0D45691C3F58f5663;\n', '\taddress public auctusPreSaleAddress = 0x84D45E60f7036F0DE7dF8ed68E1Ee50471B963BA;\n', '\tuint256 public escrowedTokens;\n', '\tmapping(address => bool) public authorized;\n', '\tmapping(address => bool) public redeemed;\n', '\n', '\tevent Escrow(address indexed from, uint256 value);\n', '\tevent Redeem(address indexed to, uint256 value);\n', '\n', '\tmodifier isAuthorized() {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction AuctusBonusDistribution() public {\n', '\t\tauthorized[msg.sender] = true;\n', '\t}\n', '\n', '\tfunction setAuthorization(address _address, bool _authorized) isAuthorized public {\n', '\t\trequire(_address != address(0) && _address != msg.sender);\n', '\t\tauthorized[_address] = _authorized;\n', '\t}\n', '\n', '\tfunction drainAUC(uint256 value) isAuthorized public {\n', '\t\tassert(AuctusToken(auctusTokenAddress).transfer(msg.sender, value));\n', '\t}\n', '\n', '\tfunction tokenFallback(address from, uint256 value, bytes) public {\n', '\t\trequire(msg.sender == auctusTokenAddress);\n', '\t\tescrowedTokens = escrowedTokens.add(value);\n', '\t\temit Escrow(from, value);\n', '\t}\n', '\n', '\tfunction sendPreSaleBonusMany(address[] _addresses) isAuthorized public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tsendPreSaleBonus(_addresses[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendPreSaleBonus(address _address) public returns (bool) {\n', '\t\tif (!redeemed[_address]) {\n', '\t\t\tuint256 value = AuctusPreSale(auctusPreSaleAddress).getTokenAmount(_address).mul(12).div(100);\n', '\t\t\tif (value > 0) {\n', '\t\t\t\tredeemed[_address] = true;\n', '\t\t\t\tsendBonus(_address, value);\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction sendBonusMany(address[] _addresses, uint256[] _values) isAuthorized public {\n', '\t\tfor (uint256 i = 0; i < _addresses.length; i++) {\n', '\t\t\tsendBonus(_addresses[i], _values[i]);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendBonus(address _address, uint256 value) internal {\n', '\t\tescrowedTokens = escrowedTokens.sub(value);\n', '\t\tassert(AuctusToken(auctusTokenAddress).transfer(_address, value));\n', '\t\temit Redeem(_address, value);\n', '\t}\n', '}']
