['pragma solidity ^0.4.25;\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* Web site         - https://two4ever.club\n', '* Telegram_chat - https://t.me/two4everClub\n', '* Twitter          - https://twitter.com/ClubTwo4ever\n', '* Youtube          - https://www.youtube.com/channel/UCl4-t8RS3-kEJIGQN6Xbtng\n', '* Email:           - mailto:admin(at sign)two4ever.club  \n', '* \n', '* --- Contract configuration:\n', '*   - Daily payment of a deposit of 2%\n', '*   - Minimal contribution 0.01 eth\n', '*   - Currency and payment - ETH\n', '*   - Contribution allocation schemes:\n', '*       -- 5% Referral program (3% first level, 2% second level)\n', '*       -- 7% Advertising\n', '*       -- 5% Operating Expenses\n', '        -- 83% dividend payments\n', '* \n', '* --- Referral Program:\n', '*   - We have 2 level referral program.\n', '*   - After your referral investment you will receive 3% of his investment \n', '*   as one time bonus from 1 level and 2% form his referrals.\n', '*   - To become your referral, you future referral should specify your address\n', '*   in field DATA, while transferring ETH.\n', '*   - When making the every deposit, the referral must indicate your wallet in the data field!\n', '*   - You must have a deposit in the contract, otherwise the person invited by you will not be assigned to you\n', '*\n', '* --- Awards:   \n', '*   - The Best Investor\n', '*       Largest investor becomes common referrer for investors without referrer \n', '*       and get a lump sum of 3% of their deposits. To become winner you must invest\n', '*       more than previous winner.\n', '* \n', '*   - The Best Promoter\n', '*       Investor with the most referrals becomes common referrer for investors without referrer\n', '*       and get a lump sum of 2% of their deposits. To become winner you must invite more than\n', '*       previous winner.\n', '*\n', '* --- About the Project:\n', '*   ETH cryptocurrency distribution project\n', '*   Blockchain-enabled smart contracts have opened a new era of trustless relationships without intermediaries.\n', '*   This technology opens incredible financial possibilities. Our automated investment distribution model\n', '*   is written into a smart contract, uploaded to the Ethereum blockchain and can be freely accessed online.\n', "*   In order to insure our investors' complete secuirty, full control over the project has been transferred\n", "*   from the organizers to the smart contract: nobody can influence the system's permanent autonomous functioning.\n", '* \n', '* --- How to invest:\n', '*  1. Send from ETH wallet to the smart contract address any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', '* --- How to get dividends:\n', '*     Send 0 air to the address of the contract. Be careful. You can get your dividends only once every 24 hours.\n', '*  \n', '* --- RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '*     You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Two4ever. You can view the contract code by scrolling down.\n', '*/\n', 'contract Storage {\n', '// define investor model   \n', '    struct investor {\n', '        uint keyIndex;\n', '        uint value;\n', '        uint paymentTime;\n', '        uint refs;\n', '        uint refBonus;\n', '    }\n', '    // define bestAddress model for bestInvestor and bestPromoter\n', '    struct bestAddress {\n', '        uint value;\n', '        address addr;\n', '    }\n', '    // statistic model\n', '    struct recordStats {\n', '        uint strg;\n', '        uint invested;\n', '    }\n', '  \n', '    struct Data {\n', '        mapping(uint => recordStats) stats;\n', '        mapping(address => investor) investors;\n', '        address[] keys;\n', '        bestAddress bestInvestor;\n', '        bestAddress bestPromoter;\n', '    }\n', '\n', '    Data private d;\n', '\n', '    // define log event when change value of  "bestInvestor" or "bestPromoter" changed\n', '    event LogBestInvestorChanged(address indexed addr, uint when, uint invested);\n', '    event LogBestPromoterChanged(address indexed addr, uint when, uint refs);\n', '\n', '    //creating contract \n', '    constructor() public {\n', '        d.keys.length++;\n', '    }\n', '    //insert new investor  \n', '    function insert(address addr, uint value) public  returns (bool) {\n', '        uint keyIndex = d.investors[addr].keyIndex;\n', '        if (keyIndex != 0) return false;\n', '        d.investors[addr].value = value;\n', '        keyIndex = d.keys.length++;\n', '        d.investors[addr].keyIndex = keyIndex;\n', '        d.keys[keyIndex] = addr;\n', '        updateBestInvestor(addr, d.investors[addr].value);\n', '    \n', '        return true;\n', '    }\n', '    // get full information about investor by "addr"\n', '    function investorFullInfo(address addr) public view returns(uint, uint, uint, uint, uint) {\n', '        return (\n', '        d.investors[addr].keyIndex,\n', '        d.investors[addr].value,\n', '        d.investors[addr].paymentTime,\n', '        d.investors[addr].refs,\n', '        d.investors[addr].refBonus\n', '        );\n', '    }\n', '    // get base information about investor by "addr"\n', '    function investorBaseInfo(address addr) public view returns(uint, uint, uint, uint) {\n', '        return (\n', '        d.investors[addr].value,\n', '        d.investors[addr].paymentTime,\n', '        d.investors[addr].refs,\n', '        d.investors[addr].refBonus\n', '        );\n', '    }\n', '    // get short information about investor by "addr"\n', '    function investorShortInfo(address addr) public view returns(uint, uint) {\n', '        return (\n', '        d.investors[addr].value,\n', '        d.investors[addr].refBonus\n', '        );\n', '    }\n', '    // get current  Best Investor \n', '    function getBestInvestor() public view returns(uint, address) {\n', '        return (\n', '        d.bestInvestor.value,\n', '        d.bestInvestor.addr\n', '        );\n', '    }\n', '\n', '    // get current  Best Promoter \n', '    function getBestPromoter() public view returns(uint, address) {\n', '        return (\n', '        d.bestPromoter.value,\n', '        d.bestPromoter.addr\n', '        );\n', '    }\n', '\n', '    // add referral bonus to address \n', '    function addRefBonus(address addr, uint refBonus) public  returns (bool) {\n', '        if (d.investors[addr].keyIndex == 0) return false;\n', '        d.investors[addr].refBonus += refBonus;\n', '        return true;\n', '    }\n', '\n', '    // add referral bonus to address  and update current Best Promoter value\n', '    function addRefBonusWithRefs(address addr, uint refBonus) public  returns (bool) {\n', '        if (d.investors[addr].keyIndex == 0) return false;\n', '        d.investors[addr].refBonus += refBonus;\n', '        d.investors[addr].refs++;\n', '        updateBestPromoter(addr, d.investors[addr].refs);\n', '        return true;\n', '    }\n', '\n', '    //add  amount of invest by the address of  investor \n', '    function addValue(address addr, uint value) public  returns (bool) {\n', '        if (d.investors[addr].keyIndex == 0) return false;\n', '        d.investors[addr].value += value;\n', '        updateBestInvestor(addr, d.investors[addr].value);\n', '        return true;\n', '    }\n', '\n', '    // update statistics\n', '    function updateStats(uint dt, uint invested, uint strg) public {\n', '        d.stats[dt].invested += invested;\n', '        d.stats[dt].strg += strg;\n', '    }\n', '\n', '    // get current statistics\n', '    function stats(uint dt) public view returns (uint invested, uint strg) {\n', '        return ( \n', '        d.stats[dt].invested,\n', '        d.stats[dt].strg\n', '        );\n', '    }\n', '\n', '    // update current "Best Investor"\n', '    function updateBestInvestor(address addr, uint investorValue) internal {\n', '        if(investorValue > d.bestInvestor.value){\n', '            d.bestInvestor.value = investorValue;\n', '            d.bestInvestor.addr = addr;\n', '            emit LogBestInvestorChanged(addr, now, d.bestInvestor.value);\n', '        }      \n', '    }\n', '\n', '    // update value of current "Best Promoter"\n', '    function updateBestPromoter(address addr, uint investorRefs) internal {\n', '        if(investorRefs > d.bestPromoter.value){\n', '            d.bestPromoter.value = investorRefs;\n', '            d.bestPromoter.addr = addr;\n', '            emit LogBestPromoterChanged(addr, now, d.bestPromoter.value);\n', '        }      \n', '    }\n', '\n', '    // set time of payment \n', '    function setPaymentTime(address addr, uint paymentTime) public  returns (bool) {\n', '        if (d.investors[addr].keyIndex == 0) return false;\n', '        d.investors[addr].paymentTime = paymentTime;\n', '        return true;\n', '    }\n', '\n', '    // set referral bonus\n', '    function setRefBonus(address addr, uint refBonus) public  returns (bool) {\n', '        if (d.investors[addr].keyIndex == 0) return false;\n', '        d.investors[addr].refBonus = refBonus;\n', '        return true;\n', '    }\n', '\n', '    // check if contains such address in storage\n', '    function contains(address addr) public view returns (bool) {\n', '        return d.investors[addr].keyIndex > 0;\n', '    }\n', '\n', '    // return current number of investors\n', '    function size() public view returns (uint) {\n', '        return d.keys.length;\n', '    }\n', '}\n', '//contract for restricting access to special functionality\n', 'contract Accessibility {\n', '\n', '    address public owner;\n', '    //access modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "access denied");\n', '        _;\n', '    }\n', '    //constructor with assignment of contract holder value\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    // deletion of contract holder\n', '    function waiver() internal {\n', '        delete owner;\n', '    }\n', '}\n', '\n', '//main contract\n', 'contract Two4ever is Accessibility  {\n', '    //connecting needed libraries\n', '    using Helper for *;\n', '    using Math for *;\n', '    // define internal model of percents\n', '    struct percent {\n', '        uint val;\n', '        uint den;\n', '    }\n', '  // contract name\n', '    string public  name;\n', '  // define storage\n', '    Storage private strg;\n', '  // collection of key value pairs ffor referrals\n', '    mapping(address => address) private referrals;\n', '  //variable for admin address\n', '    address public adminAddr;\n', '  //variable for  advertise address\n', '    address public advertiseAddr;\n', '  // time  when start current wave\n', '    uint public waveStartup;\n', '\n', '    uint public totalInvestors;\n', '    uint public totalInvested;\n', '  // define constants\n', '  //size of minimal investing\n', '    uint public constant minInvesment = 10 finney; // 0.01 eth\n', '  //max size of balance \n', '    uint public constant maxBalance = 100000 ether; \n', '  // time period when dividends can be accrued\n', '    uint public constant dividendsPeriod = 24 hours; //24 hours\n', '\n', '  // define contracts percents \n', '    // percent of main dividends \n', '    percent private dividends;\n', '    // percent of admin interest \n', '    percent private adminInterest ;\n', '   // percent of 1-st level referral \n', '    percent private ref1Bonus ;\n', '   // percent of 2-nd level referral \n', '    percent private ref2Bonus ;\n', '   // percent of advertising interest \n', '    percent private advertisePersent ;\n', '    // event call when Balance has Changed\n', '    event LogBalanceChanged(uint when, uint balance);\n', '\n', '  // custom modifier for  event broadcasting\n', '    modifier balanceChanged {\n', '        _;\n', '        emit LogBalanceChanged(now, address(this).balance);\n', '    }\n', '    // constructor\n', '    // creating  contract. This function call once when contract is publishing.\n', '    constructor()  public {\n', '        name = "two4ever.club";\n', '      // set admin address by account address who  has published\n', '        adminAddr = msg.sender;\n', '        advertiseAddr = msg.sender;\n', '    //define value of main percents\n', '        dividends = percent(2, 100); //  2%\n', '        adminInterest = percent(5, 100); //  5%\n', '        ref1Bonus = percent(3, 100); //  3%\n', '        ref2Bonus = percent(2, 100); //  2%\n', '        advertisePersent = percent(7, 100); //  7% \n', '    // start new wave \n', '        startNewWave();\n', '    }\n', '    // set the value of the wallet address for advertising expenses\n', '    function setAdvertisingAddress(address addr) public onlyOwner {\n', '        if(addr.notEmptyAddr())\n', '        {\n', '            advertiseAddr = addr;\n', '        }\n', '    }\n', '    //set the value of the wallet address for operating expenses\n', '    function setAdminsAddress(address addr) public onlyOwner {\n', '        if(addr.notEmptyAddr())\n', '        {\n', '            adminAddr = addr;\n', '        }\n', '    }\n', '    // deletion of contract holder\n', '    function doWaiver() public onlyOwner {\n', '        waiver();\n', '    }\n', '\n', '    //functions is calling when transfer money to address of this contract\n', '    function() public payable {\n', '    // investor get him dividends when send value = 0   to address of this contract\n', '        if (msg.value == 0) {\n', '            getDividends();\n', '            return;\n', '        }\n', '\n', '    // getting referral address from data of request \n', '        address a = msg.data.toAddr();\n', '    //call invest function\n', '        invest(a);\n', '    }\n', '    // private function for get dividends\n', '    function _getMydividends(bool withoutThrow) private {\n', '    // get  investor info\n', '        Storage.investor memory investor = getMemInvestor(msg.sender);\n', '    //check if investor exists\n', '        if(investor.keyIndex <= 0){\n', '            if(withoutThrow){\n', '                return;\n', '            }\n', '            revert("sender is not investor");\n', '    }\n', '\n', '    // calculate how many days have passed after last payment\n', '        uint256 daysAfter = now.sub(investor.paymentTime).div(dividendsPeriod);\n', '        if(daysAfter <= 0){\n', '            if(withoutThrow){\n', '                return;\n', '            }\n', '            revert("the latest payment was earlier than dividends period");\n', '        }\n', '        assert(strg.setPaymentTime(msg.sender, now));\n', '\n', '    // calc valaue of dividends\n', '        uint value = Math.div(Math.mul(dividends.val,investor.value),dividends.den) * daysAfter;\n', '    // add referral bonus to dividends\n', '        uint divid = value+ investor.refBonus; \n', '    // check if enough money on balance of contract for payment\n', '        if (address(this).balance < divid) {\n', '            startNewWave();\n', '            return;\n', '        }\n', '  \n', '    // send dividends and ref bonus\n', '        if (investor.refBonus > 0) {\n', '            assert(strg.setRefBonus(msg.sender, 0));\n', '    //send dividends and referral bonus to investor\n', '            msg.sender.transfer(value+investor.refBonus);\n', '        } else {\n', '    //send dividends to investor\n', '            msg.sender.transfer(value);\n', '        }      \n', '    }\n', '    // public function for calling get dividends\n', '    function getDividends() public balanceChanged {\n', '        _getMydividends(false);\n', '    }\n', '    // function for investing money from investor\n', '    function invest(address ref) public payable balanceChanged {\n', '    //check minimum requirements\n', '        require(msg.value >= minInvesment, "msg.value must be >= minInvesment");\n', '        require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '    //save current money value\n', '        uint value = msg.value;\n', '    // ref system works only once for sender-referral\n', '        if (!referrals[msg.sender].notEmptyAddr()) {\n', '      //process first level of referrals\n', '            if (notZeroNotSender(ref) && strg.contains(ref)) {\n', '          //calc the reward\n', '                uint reward = Math.div(Math.mul(ref1Bonus.val,value),ref1Bonus.den);\n', '                assert(strg.addRefBonusWithRefs(ref, reward)); // referrer 1 bonus\n', '                referrals[msg.sender] = ref;\n', '\n', '        //process second level of referrals\n', '                if (notZeroNotSender(referrals[ref]) && strg.contains(referrals[ref]) && ref != referrals[ref]) { \n', '         //calc the reward\n', '                    reward = Math.div(Math.mul(ref2Bonus.val, value),ref2Bonus.den);\n', '                    assert(strg.addRefBonus(referrals[ref], reward)); // referrer 2 bonus\n', '                }\n', '                }else{\n', '         // get current Best Investor  \n', '                Storage.bestAddress memory bestInvestor = getMemBestInvestor();\n', '        // get current Best Promoter  \n', '                Storage.bestAddress memory bestPromoter = getMemBestPromoter();\n', '\n', '                if(notZeroNotSender(bestInvestor.addr)){\n', '                    assert(strg.addRefBonus(bestInvestor.addr, Math.div(Math.mul(ref1Bonus.val, value),ref1Bonus.den))); // referrer 1 bonus\n', '                    referrals[msg.sender] = bestInvestor.addr;\n', '                }\n', '                if(notZeroNotSender(bestPromoter.addr)){\n', '                    assert(strg.addRefBonus(bestPromoter.addr, Math.div(Math.mul(ref2Bonus.val, value),ref2Bonus.den))); // referrer 2 bonus\n', '                    referrals[msg.sender] = bestPromoter.addr;\n', '                }\n', '            }\n', '    }\n', '\n', '        _getMydividends(true);\n', '\n', '    // send admins share\n', '        adminAddr.transfer(Math.div(Math.mul(adminInterest.val, msg.value),adminInterest.den));\n', '    // send advertise share \n', '        advertiseAddr.transfer(Math.div(Math.mul(advertisePersent.val, msg.value),advertisePersent.den));\n', '    \n', '    // update statistics\n', '        if (strg.contains(msg.sender)) {\n', '            assert(strg.addValue(msg.sender, value));\n', '            strg.updateStats(now, value, 0);\n', '        } else {\n', '            assert(strg.insert(msg.sender, value));\n', '            strg.updateStats(now, value, 1);\n', '        }\n', '    \n', '        assert(strg.setPaymentTime(msg.sender, now));\n', '    //increase count of investments\n', '        totalInvestors++;\n', '    //increase amount of investments\n', '        totalInvested += msg.value;\n', '    }\n', '/*views */\n', '    // show number of investors\n', '    function investorsNumber() public view returns(uint) {\n', '        return strg.size()-1;\n', '    // -1 because see Storage constructor where keys.length++ \n', '    }\n', '    //show current contract balance\n', '    function balanceETH() public view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '    // show value of dividend percent\n', '    function DividendsPercent() public view returns(uint) {\n', '        return dividends.val;\n', '    }\n', '    // show value of admin percent\n', '    function AdminPercent() public view returns(uint) {\n', '        return adminInterest.val;\n', '    }\n', '     // show value of advertise persent\n', '    function AdvertisePersent() public view returns(uint) {\n', '        return advertisePersent.val;\n', '    }\n', '    // show value of referral of 1-st level percent\n', '    function FirstLevelReferrerPercent() public view returns(uint) {\n', '        return ref1Bonus.val; \n', '    }\n', '    // show value of referral of 2-nd level percent\n', '    function SecondLevelReferrerPercent() public view returns(uint) {\n', '        return ref2Bonus.val;\n', '    }\n', '    // show value of statisctics by date\n', '    function statistic(uint date) public view returns(uint amount, uint user) {\n', '        (amount, user) = strg.stats(date);\n', '    }\n', '    // show investor info  by address\n', '    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {\n', '        (value, paymentTime, refsCount, refBonus) = strg.investorBaseInfo(addr);\n', '        isReferral = referrals[addr].notEmptyAddr();\n', '    }\n', '  // show best investor info\n', '    function bestInvestor() public view returns(uint invested, address addr) {\n', '        (invested, addr) = strg.getBestInvestor();\n', '    }\n', '  // show best promoter info\n', '    function bestPromoter() public view returns(uint refs, address addr) {\n', '        (refs, addr) = strg.getBestPromoter();\n', '    }\n', '  // return full investor info by address\n', '    function getMemInvestor(address addr) internal view returns(Storage.investor) {\n', '        (uint a, uint b, uint c, uint d, uint e) = strg.investorFullInfo(addr);\n', '        return Storage.investor(a, b, c, d, e);\n', '    }\n', '  //return best investor  info \n', '    function getMemBestInvestor() internal view returns(Storage.bestAddress) {\n', '        (uint value, address addr) = strg.getBestInvestor();\n', '        return Storage.bestAddress(value, addr);\n', '    }\n', '  //return best investor promoter \n', '    function getMemBestPromoter() internal view returns(Storage.bestAddress) {\n', '        (uint value, address addr) = strg.getBestPromoter();\n', '        return Storage.bestAddress(value, addr);\n', '    }\n', '    // check if address is not empty and not equal sender address\n', '    function notZeroNotSender(address addr) internal view returns(bool) {\n', '        return addr.notEmptyAddr() && addr != msg.sender;\n', '    }\n', '\n', '/**end views */\n', '// start wave  \n', '    function startNewWave() private {\n', '        strg = new Storage();\n', '        totalInvestors = 0;\n', '        waveStartup = now;\n', '    }\n', '}\n', '\n', '// Math library with simple arithmetical functions\n', 'library Math {\n', '    //multiplying\n', '    function mul(uint256 num1, uint256 num2) internal pure returns (uint256) {\n', '        return  num1 * num2;\n', '        if (num1 == 0) {\n', '            return 0;\n', '        }\n', '        return num1 * num2;   \n', '    }\n', '    //divide\n', '    function div(uint256 num1, uint256 num2) internal pure returns (uint256) {\n', '        uint256 result = 0;\n', '        require(num2 > 0); \n', '        result = num1 / num2;\n', '        return result;\n', '    }\n', '    //subtract \n', '    function sub(uint256 num1, uint256 num2) internal pure returns (uint256) {\n', '        require(num2 <= num1);\n', '        uint256 result = 0;\n', '        result = num1 - num2;\n', '        return result;\n', '    }\n', '    //add \n', '    function add(uint256 num1, uint256 num2) internal pure returns (uint256) {\n', '        uint256 result = num1 + num2;\n', '        require(result >= num1);\n', '\n', '        return result;\n', '    }\n', '    //module\n', '    function mod(uint256 num1, uint256 num2) internal pure returns (uint256) {\n', '        require(num2 != 0);\n', '        return num1 % num2;\n', '    } \n', '}\n', '// Helper library with simple additional functions\n', 'library Helper{\n', '    //check if the address is not empty\n', '    function notEmptyAddr(address addr) internal pure returns(bool) {\n', '        return !(addr == address(0));\n', '    }\n', '     //check if the address is  empty\n', '    function isEmptyAddr(address addr) internal pure returns(bool) {\n', '        return addr == address(0);\n', '    }\n', '    // convert to address \n', '    function toAddr(uint source) internal pure returns(address) {\n', '        return address(source);\n', '    }\n', '    //convert  from bytes to address\n', '    function toAddr(bytes source) internal pure returns(address addr) {\n', '        assembly { addr := mload(add(source,0x14)) }\n', '        return addr;\n', '    }\n', '}']