['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', ' * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n', ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '/**\n', ' * @title RBACWithAdmin\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev It&#39;s recommended that you define constants in the contract,\n', ' * @dev like ROLE_ADMIN below, to avoid typos.\n', ' */\n', 'contract RBACWithAdmin is RBAC {\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBACWithAdmin()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '// Contract Code for Faculty - Faculty Devs\n', 'contract FacultyPool is RBACWithAdmin {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // Constants\n', '    // ========================================================\n', '    uint8 constant CONTRACT_OPEN = 1;\n', '    uint8 constant CONTRACT_CLOSED = 2;\n', '    uint8 constant CONTRACT_SUBMIT_FUNDS = 3;\n', '    // 500,000 max gas\n', '    uint256 constant public gasLimit = 50000000000;\n', '    // 0.1 ether\n', '    uint256 constant public minContribution = 100000000000000000;\n', '\n', '    // State Vars\n', '    // ========================================================\n', '    // recipient address for fee\n', '    address public owner;\n', '    // the fee taken in tokens from the pool\n', '    uint256 public feePct;\n', '    // open our contract initially\n', '    uint8 public contractStage = CONTRACT_OPEN;\n', '    // the current Beneficiary Cap level in wei\n', '    uint256 public currentBeneficiaryCap;\n', '    // the total cap in wei of the pool\n', '    uint256 public totalPoolCap;\n', '    // the destination for this contract\n', '    address public receiverAddress;\n', '    // our beneficiaries\n', '    mapping (address => Beneficiary) beneficiaries;\n', '    // the total we raised before closing pool\n', '    uint256 public finalBalance;\n', '    // a set of refund amounts we may need to process\n', '    uint256[] public ethRefundAmount;\n', '    // mapping that holds the token allocation struct for each token address\n', '    mapping (address => TokenAllocation) tokenAllocationMap;\n', '    // the default token address\n', '    address public defaultToken;\n', '\n', '\n', '    // Modifiers and Structs\n', '    // ========================================================\n', '    // only run certain methods when contract is open\n', '    modifier isOpenContract() {\n', '        require (contractStage == CONTRACT_OPEN);\n', '        _;\n', '    }\n', '\n', '    // stop double processing attacks\n', '    bool locked;\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '\n', '    // Beneficiary\n', '    struct Beneficiary {\n', '        uint256 ethRefund;\n', '        uint256 balance;\n', '        uint256 cap;\n', '        mapping (address => uint256) tokensClaimed;\n', '    }\n', '\n', '    // data structure for holding information related to token withdrawals.\n', '    struct TokenAllocation {\n', '        ERC20 token;\n', '        uint256[] pct;\n', '        uint256 balanceRemaining;\n', '    }\n', '\n', '    // Events\n', '    // ========================================================\n', '    event BeneficiaryBalanceChanged(address indexed beneficiary, uint256 totalBalance);\n', '    event ReceiverAddressSet(address indexed receiverAddress);\n', '    event ERC223Received(address indexed token, uint256 value);\n', '    event DepositReceived(address indexed beneficiary, uint256 amount, uint256 gas, uint256 gasprice, uint256 gasLimit);\n', '    event PoolStageChanged(uint8 stage);\n', '    event PoolSubmitted(address indexed receiver, uint256 amount);\n', '    event RefundReceived(address indexed sender, uint256 amount);\n', '    event TokenWithdrawal(address indexed beneficiary, address indexed token, uint256 amount);\n', '    event EthRefunded(address indexed beneficiary, uint256 amount);\n', '\n', '    // CODE BELOW HERE\n', '    // ========================================================\n', '\n', '    /*\n', '     * Construct a pool with a set of admins, the poolCap and the cap each beneficiary gets. And,\n', '     * optionally, the receiving address if know at time of contract creation.\n', '     * fee is in bips so 3.5% would be set as 350 and 100% == 100*100 => 10000\n', '     */\n', '    constructor(address[] _admins, uint256 _poolCap, uint256 _beneficiaryCap, address _receiverAddr, uint256 _feePct) public {\n', '        require(_admins.length > 0, "Must have at least one admin apart from msg.sender");\n', '        require(_poolCap >= _beneficiaryCap, "Cannot have the poolCap <= beneficiaryCap");\n', '        require(_feePct >=  0 && _feePct < 10000);\n', '        feePct = _feePct;\n', '        receiverAddress = _receiverAddr;\n', '        totalPoolCap = _poolCap;\n', '        currentBeneficiaryCap = _beneficiaryCap;\n', '        // setup privileges\n', '        owner = msg.sender;\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '        for (uint8 i = 0; i < _admins.length; i++) {\n', '            addRole(_admins[i], ROLE_ADMIN);\n', '        }\n', '    }\n', '\n', '    // we pay in here\n', '    function () payable public {\n', '        if (contractStage == CONTRACT_OPEN) {\n', '            emit DepositReceived(msg.sender, msg.value, gasleft(), tx.gasprice, gasLimit);\n', '            _receiveDeposit();\n', '        } else {\n', '            _receiveRefund();\n', '        }\n', '    }\n', '\n', '    // receive funds. gas limited. min contrib.\n', '    function _receiveDeposit() isOpenContract internal {\n', '        require(tx.gasprice <= gasLimit, "Gas too high");\n', '        require(address(this).balance <= totalPoolCap, "Deposit will put pool over limit. Reverting.");\n', '        // Now the code\n', '        Beneficiary storage b = beneficiaries[msg.sender];\n', '        uint256 newBalance = b.balance.add(msg.value);\n', '        require(newBalance >= minContribution, "contribution is lower than minContribution");\n', '        if(b.cap > 0){\n', '            require(newBalance <= b.cap, "balance is less than set cap for beneficiary");\n', '        } else if(currentBeneficiaryCap == 0) {\n', '            // we have an open cap, no limits\n', '            b.cap = totalPoolCap;\n', '        }else {\n', '            require(newBalance <= currentBeneficiaryCap, "balance is more than currentBeneficiaryCap");\n', '            // we set it to the default cap\n', '            b.cap = currentBeneficiaryCap;\n', '        }\n', '        b.balance = newBalance;\n', '        emit BeneficiaryBalanceChanged(msg.sender, newBalance);\n', '    }\n', '\n', '    // Handle refunds only in closed state.\n', '    function _receiveRefund() internal {\n', '        assert(contractStage >= 2);\n', '        require(hasRole(msg.sender, ROLE_ADMIN) || msg.sender == receiverAddress, "Receiver or Admins only");\n', '        ethRefundAmount.push(msg.value);\n', '        emit RefundReceived(msg.sender, msg.value);\n', '    }\n', '\n', '    function getCurrentBeneficiaryCap() public view returns(uint256 cap) {\n', '        return currentBeneficiaryCap;\n', '    }\n', '\n', '    function getPoolDetails() public view returns(uint256 total, uint256 currentBalance, uint256 remaining) {\n', '        remaining = totalPoolCap.sub(address(this).balance);\n', '        return (totalPoolCap, address(this).balance, remaining);\n', '    }\n', '\n', '    // close the pool from receiving more funds\n', '    function closePool() onlyAdmin isOpenContract public {\n', '        contractStage = CONTRACT_CLOSED;\n', '        emit PoolStageChanged(contractStage);\n', '    }\n', '\n', '    function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {\n', '        require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");\n', '        require(receiverAddress != 0x00, "receiver address cannot be empty");\n', '        uint256 contractBalance = address(this).balance;\n', '        if(weiAmount == 0){\n', '            weiAmount = contractBalance;\n', '        }\n', '        require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");\n', '        finalBalance = contractBalance;\n', '        // transfer to upstream receiverAddress\n', '        require(receiverAddress.call.value(weiAmount)\n', '            .gas(gasleft().sub(5000))(),\n', '            "Error submitting pool to receivingAddress");\n', '        // get balance post transfer\n', '        contractBalance = address(this).balance;\n', '        if(contractBalance > 0) {\n', '            ethRefundAmount.push(contractBalance);\n', '        }\n', '        contractStage = CONTRACT_SUBMIT_FUNDS;\n', '        emit PoolSubmitted(receiverAddress, weiAmount);\n', '    }\n', '\n', '    function viewBeneficiaryDetails(address beneficiary) public view returns (uint256 cap, uint256 balance, uint256 remaining, uint256 ethRefund){\n', '        Beneficiary storage b = beneficiaries[beneficiary];\n', '        return (b.cap, b.balance, b.cap.sub(b.balance), b.ethRefund);\n', '    }\n', '\n', '    function withdraw(address _tokenAddress) public {\n', '        Beneficiary storage b = beneficiaries[msg.sender];\n', '        require(b.balance > 0, "msg.sender has no balance. Nice Try!");\n', '        if(contractStage == CONTRACT_OPEN){\n', '            uint256 transferAmt = b.balance;\n', '            b.balance = 0;\n', '            msg.sender.transfer(transferAmt);\n', '            emit BeneficiaryBalanceChanged(msg.sender, 0);\n', '        } else {\n', '            _withdraw(msg.sender, _tokenAddress);\n', '        }\n', '    }\n', '\n', '    // This function allows the contract owner to force a withdrawal to any contributor.\n', '    function withdrawFor (address _beneficiary, address tokenAddr) public onlyAdmin {\n', '        require (contractStage == CONTRACT_SUBMIT_FUNDS, "Can only be done on Submitted Contract");\n', '        require (beneficiaries[_beneficiary].balance > 0, "Beneficary has no funds to withdraw");\n', '        _withdraw(_beneficiary, tokenAddr);\n', '    }\n', '\n', '    function _withdraw (address _beneficiary, address _tokenAddr) internal {\n', '        require(contractStage == CONTRACT_SUBMIT_FUNDS, "Cannot withdraw when contract is not CONTRACT_SUBMIT_FUNDS");\n', '        Beneficiary storage b = beneficiaries[_beneficiary];\n', '        if (_tokenAddr == 0x00) {\n', '            _tokenAddr = defaultToken;\n', '        }\n', '        TokenAllocation storage ta = tokenAllocationMap[_tokenAddr];\n', '        require ( (ethRefundAmount.length > b.ethRefund) || ta.pct.length > b.tokensClaimed[_tokenAddr] );\n', '\n', '        if (ethRefundAmount.length > b.ethRefund) {\n', '            uint256 pct = _toPct(b.balance,finalBalance);\n', '            uint256 ethAmount = 0;\n', '            for (uint i= b.ethRefund; i < ethRefundAmount.length; i++) {\n', '                ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\n', '            }\n', '            b.ethRefund = ethRefundAmount.length;\n', '            if (ethAmount > 0) {\n', '                _beneficiary.transfer(ethAmount);\n', '                emit EthRefunded(_beneficiary, ethAmount);\n', '            }\n', '        }\n', '        if (ta.pct.length > b.tokensClaimed[_tokenAddr]) {\n', '            uint tokenAmount = 0;\n', '            for (i= b.tokensClaimed[_tokenAddr]; i< ta.pct.length; i++) {\n', '                tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\n', '            }\n', '            b.tokensClaimed[_tokenAddr] = ta.pct.length;\n', '            if (tokenAmount > 0) {\n', '                require(ta.token.transfer(_beneficiary,tokenAmount));\n', '                ta.balanceRemaining = ta.balanceRemaining.sub(tokenAmount);\n', '                emit TokenWithdrawal(_beneficiary, _tokenAddr, tokenAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setReceiver(address addr) public onlyAdmin {\n', '        require (contractStage < CONTRACT_SUBMIT_FUNDS);\n', '        receiverAddress = addr;\n', '        emit ReceiverAddressSet(addr);\n', '    }\n', '\n', '    // once we have tokens we can enable the withdrawal\n', '    // setting this _useAsDefault to true will set this incoming address to the defaultToken.\n', '    function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy {\n', '        require (contractStage == CONTRACT_SUBMIT_FUNDS, "wrong contract stage");\n', '        if (_useAsDefault) {\n', '            defaultToken = _tokenAddr;\n', '        } else {\n', '            require (defaultToken != 0x00, "defaultToken must be set");\n', '        }\n', '        TokenAllocation storage ta  = tokenAllocationMap[_tokenAddr];\n', '        if (ta.pct.length==0){\n', '            ta.token = ERC20(_tokenAddr);\n', '        }\n', '        uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\n', '        require (amount > 0);\n', '        if (feePct > 0) {\n', '            uint256 feePctFromBips = _toPct(feePct, 10000);\n', '            uint256 feeAmount = _applyPct(amount, feePctFromBips);\n', '            require (ta.token.transfer(owner, feeAmount));\n', '            emit TokenWithdrawal(owner, _tokenAddr, feeAmount);\n', '        }\n', '        amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\n', '        ta.balanceRemaining = ta.token.balanceOf(this);\n', '        ta.pct.push(_toPct(amount,finalBalance));\n', '    }\n', '\n', '    // get the available tokens\n', '    function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\n', '        Beneficiary storage b = beneficiaries[addr];\n', '        TokenAllocation storage ta = tokenAllocationMap[tokenAddr];\n', '        for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) {\n', '            tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\n', '        }\n', '        return tokenAmount;\n', '    }\n', '\n', '    // This is a standard function required for ERC223 compatibility.\n', '    function tokenFallback (address from, uint value, bytes data) public {\n', '        emit ERC223Received (from, value);\n', '    }\n', '\n', '    // returns a value as a % accurate to 20 decimal points\n', '    function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n', '        return numerator.mul(10 ** 20) / denominator;\n', '    }\n', '\n', '    // returns % of any number, where % given was generated with toPct\n', '    function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n', '        return numerator.mul(pct) / (10 ** 20);\n', '    }\n', '\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' *      See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * @dev Supports unlimited numbers of roles and addresses.\n', ' * @dev See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' *  for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' *  to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '/**\n', ' * @title RBACWithAdmin\n', ' * @author Matt Condon (@Shrugs)\n', " * @dev It's recommended that you define constants in the contract,\n", ' * @dev like ROLE_ADMIN below, to avoid typos.\n', ' */\n', 'contract RBACWithAdmin is RBAC {\n', '  /**\n', '   * A constant role name for indicating admins.\n', '   */\n', '  string public constant ROLE_ADMIN = "admin";\n', '\n', '  /**\n', '   * @dev modifier to scope access to admins\n', '   * // reverts\n', '   */\n', '  modifier onlyAdmin()\n', '  {\n', '    checkRole(msg.sender, ROLE_ADMIN);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev constructor. Sets msg.sender as admin by default\n', '   */\n', '  function RBACWithAdmin()\n', '    public\n', '  {\n', '    addRole(msg.sender, ROLE_ADMIN);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminAddRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    addRole(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function adminRemoveRole(address addr, string roleName)\n', '    onlyAdmin\n', '    public\n', '  {\n', '    removeRole(addr, roleName);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', '\n', '// Contract Code for Faculty - Faculty Devs\n', 'contract FacultyPool is RBACWithAdmin {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // Constants\n', '    // ========================================================\n', '    uint8 constant CONTRACT_OPEN = 1;\n', '    uint8 constant CONTRACT_CLOSED = 2;\n', '    uint8 constant CONTRACT_SUBMIT_FUNDS = 3;\n', '    // 500,000 max gas\n', '    uint256 constant public gasLimit = 50000000000;\n', '    // 0.1 ether\n', '    uint256 constant public minContribution = 100000000000000000;\n', '\n', '    // State Vars\n', '    // ========================================================\n', '    // recipient address for fee\n', '    address public owner;\n', '    // the fee taken in tokens from the pool\n', '    uint256 public feePct;\n', '    // open our contract initially\n', '    uint8 public contractStage = CONTRACT_OPEN;\n', '    // the current Beneficiary Cap level in wei\n', '    uint256 public currentBeneficiaryCap;\n', '    // the total cap in wei of the pool\n', '    uint256 public totalPoolCap;\n', '    // the destination for this contract\n', '    address public receiverAddress;\n', '    // our beneficiaries\n', '    mapping (address => Beneficiary) beneficiaries;\n', '    // the total we raised before closing pool\n', '    uint256 public finalBalance;\n', '    // a set of refund amounts we may need to process\n', '    uint256[] public ethRefundAmount;\n', '    // mapping that holds the token allocation struct for each token address\n', '    mapping (address => TokenAllocation) tokenAllocationMap;\n', '    // the default token address\n', '    address public defaultToken;\n', '\n', '\n', '    // Modifiers and Structs\n', '    // ========================================================\n', '    // only run certain methods when contract is open\n', '    modifier isOpenContract() {\n', '        require (contractStage == CONTRACT_OPEN);\n', '        _;\n', '    }\n', '\n', '    // stop double processing attacks\n', '    bool locked;\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '\n', '    // Beneficiary\n', '    struct Beneficiary {\n', '        uint256 ethRefund;\n', '        uint256 balance;\n', '        uint256 cap;\n', '        mapping (address => uint256) tokensClaimed;\n', '    }\n', '\n', '    // data structure for holding information related to token withdrawals.\n', '    struct TokenAllocation {\n', '        ERC20 token;\n', '        uint256[] pct;\n', '        uint256 balanceRemaining;\n', '    }\n', '\n', '    // Events\n', '    // ========================================================\n', '    event BeneficiaryBalanceChanged(address indexed beneficiary, uint256 totalBalance);\n', '    event ReceiverAddressSet(address indexed receiverAddress);\n', '    event ERC223Received(address indexed token, uint256 value);\n', '    event DepositReceived(address indexed beneficiary, uint256 amount, uint256 gas, uint256 gasprice, uint256 gasLimit);\n', '    event PoolStageChanged(uint8 stage);\n', '    event PoolSubmitted(address indexed receiver, uint256 amount);\n', '    event RefundReceived(address indexed sender, uint256 amount);\n', '    event TokenWithdrawal(address indexed beneficiary, address indexed token, uint256 amount);\n', '    event EthRefunded(address indexed beneficiary, uint256 amount);\n', '\n', '    // CODE BELOW HERE\n', '    // ========================================================\n', '\n', '    /*\n', '     * Construct a pool with a set of admins, the poolCap and the cap each beneficiary gets. And,\n', '     * optionally, the receiving address if know at time of contract creation.\n', '     * fee is in bips so 3.5% would be set as 350 and 100% == 100*100 => 10000\n', '     */\n', '    constructor(address[] _admins, uint256 _poolCap, uint256 _beneficiaryCap, address _receiverAddr, uint256 _feePct) public {\n', '        require(_admins.length > 0, "Must have at least one admin apart from msg.sender");\n', '        require(_poolCap >= _beneficiaryCap, "Cannot have the poolCap <= beneficiaryCap");\n', '        require(_feePct >=  0 && _feePct < 10000);\n', '        feePct = _feePct;\n', '        receiverAddress = _receiverAddr;\n', '        totalPoolCap = _poolCap;\n', '        currentBeneficiaryCap = _beneficiaryCap;\n', '        // setup privileges\n', '        owner = msg.sender;\n', '        addRole(msg.sender, ROLE_ADMIN);\n', '        for (uint8 i = 0; i < _admins.length; i++) {\n', '            addRole(_admins[i], ROLE_ADMIN);\n', '        }\n', '    }\n', '\n', '    // we pay in here\n', '    function () payable public {\n', '        if (contractStage == CONTRACT_OPEN) {\n', '            emit DepositReceived(msg.sender, msg.value, gasleft(), tx.gasprice, gasLimit);\n', '            _receiveDeposit();\n', '        } else {\n', '            _receiveRefund();\n', '        }\n', '    }\n', '\n', '    // receive funds. gas limited. min contrib.\n', '    function _receiveDeposit() isOpenContract internal {\n', '        require(tx.gasprice <= gasLimit, "Gas too high");\n', '        require(address(this).balance <= totalPoolCap, "Deposit will put pool over limit. Reverting.");\n', '        // Now the code\n', '        Beneficiary storage b = beneficiaries[msg.sender];\n', '        uint256 newBalance = b.balance.add(msg.value);\n', '        require(newBalance >= minContribution, "contribution is lower than minContribution");\n', '        if(b.cap > 0){\n', '            require(newBalance <= b.cap, "balance is less than set cap for beneficiary");\n', '        } else if(currentBeneficiaryCap == 0) {\n', '            // we have an open cap, no limits\n', '            b.cap = totalPoolCap;\n', '        }else {\n', '            require(newBalance <= currentBeneficiaryCap, "balance is more than currentBeneficiaryCap");\n', '            // we set it to the default cap\n', '            b.cap = currentBeneficiaryCap;\n', '        }\n', '        b.balance = newBalance;\n', '        emit BeneficiaryBalanceChanged(msg.sender, newBalance);\n', '    }\n', '\n', '    // Handle refunds only in closed state.\n', '    function _receiveRefund() internal {\n', '        assert(contractStage >= 2);\n', '        require(hasRole(msg.sender, ROLE_ADMIN) || msg.sender == receiverAddress, "Receiver or Admins only");\n', '        ethRefundAmount.push(msg.value);\n', '        emit RefundReceived(msg.sender, msg.value);\n', '    }\n', '\n', '    function getCurrentBeneficiaryCap() public view returns(uint256 cap) {\n', '        return currentBeneficiaryCap;\n', '    }\n', '\n', '    function getPoolDetails() public view returns(uint256 total, uint256 currentBalance, uint256 remaining) {\n', '        remaining = totalPoolCap.sub(address(this).balance);\n', '        return (totalPoolCap, address(this).balance, remaining);\n', '    }\n', '\n', '    // close the pool from receiving more funds\n', '    function closePool() onlyAdmin isOpenContract public {\n', '        contractStage = CONTRACT_CLOSED;\n', '        emit PoolStageChanged(contractStage);\n', '    }\n', '\n', '    function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {\n', '        require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");\n', '        require(receiverAddress != 0x00, "receiver address cannot be empty");\n', '        uint256 contractBalance = address(this).balance;\n', '        if(weiAmount == 0){\n', '            weiAmount = contractBalance;\n', '        }\n', '        require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");\n', '        finalBalance = contractBalance;\n', '        // transfer to upstream receiverAddress\n', '        require(receiverAddress.call.value(weiAmount)\n', '            .gas(gasleft().sub(5000))(),\n', '            "Error submitting pool to receivingAddress");\n', '        // get balance post transfer\n', '        contractBalance = address(this).balance;\n', '        if(contractBalance > 0) {\n', '            ethRefundAmount.push(contractBalance);\n', '        }\n', '        contractStage = CONTRACT_SUBMIT_FUNDS;\n', '        emit PoolSubmitted(receiverAddress, weiAmount);\n', '    }\n', '\n', '    function viewBeneficiaryDetails(address beneficiary) public view returns (uint256 cap, uint256 balance, uint256 remaining, uint256 ethRefund){\n', '        Beneficiary storage b = beneficiaries[beneficiary];\n', '        return (b.cap, b.balance, b.cap.sub(b.balance), b.ethRefund);\n', '    }\n', '\n', '    function withdraw(address _tokenAddress) public {\n', '        Beneficiary storage b = beneficiaries[msg.sender];\n', '        require(b.balance > 0, "msg.sender has no balance. Nice Try!");\n', '        if(contractStage == CONTRACT_OPEN){\n', '            uint256 transferAmt = b.balance;\n', '            b.balance = 0;\n', '            msg.sender.transfer(transferAmt);\n', '            emit BeneficiaryBalanceChanged(msg.sender, 0);\n', '        } else {\n', '            _withdraw(msg.sender, _tokenAddress);\n', '        }\n', '    }\n', '\n', '    // This function allows the contract owner to force a withdrawal to any contributor.\n', '    function withdrawFor (address _beneficiary, address tokenAddr) public onlyAdmin {\n', '        require (contractStage == CONTRACT_SUBMIT_FUNDS, "Can only be done on Submitted Contract");\n', '        require (beneficiaries[_beneficiary].balance > 0, "Beneficary has no funds to withdraw");\n', '        _withdraw(_beneficiary, tokenAddr);\n', '    }\n', '\n', '    function _withdraw (address _beneficiary, address _tokenAddr) internal {\n', '        require(contractStage == CONTRACT_SUBMIT_FUNDS, "Cannot withdraw when contract is not CONTRACT_SUBMIT_FUNDS");\n', '        Beneficiary storage b = beneficiaries[_beneficiary];\n', '        if (_tokenAddr == 0x00) {\n', '            _tokenAddr = defaultToken;\n', '        }\n', '        TokenAllocation storage ta = tokenAllocationMap[_tokenAddr];\n', '        require ( (ethRefundAmount.length > b.ethRefund) || ta.pct.length > b.tokensClaimed[_tokenAddr] );\n', '\n', '        if (ethRefundAmount.length > b.ethRefund) {\n', '            uint256 pct = _toPct(b.balance,finalBalance);\n', '            uint256 ethAmount = 0;\n', '            for (uint i= b.ethRefund; i < ethRefundAmount.length; i++) {\n', '                ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\n', '            }\n', '            b.ethRefund = ethRefundAmount.length;\n', '            if (ethAmount > 0) {\n', '                _beneficiary.transfer(ethAmount);\n', '                emit EthRefunded(_beneficiary, ethAmount);\n', '            }\n', '        }\n', '        if (ta.pct.length > b.tokensClaimed[_tokenAddr]) {\n', '            uint tokenAmount = 0;\n', '            for (i= b.tokensClaimed[_tokenAddr]; i< ta.pct.length; i++) {\n', '                tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\n', '            }\n', '            b.tokensClaimed[_tokenAddr] = ta.pct.length;\n', '            if (tokenAmount > 0) {\n', '                require(ta.token.transfer(_beneficiary,tokenAmount));\n', '                ta.balanceRemaining = ta.balanceRemaining.sub(tokenAmount);\n', '                emit TokenWithdrawal(_beneficiary, _tokenAddr, tokenAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setReceiver(address addr) public onlyAdmin {\n', '        require (contractStage < CONTRACT_SUBMIT_FUNDS);\n', '        receiverAddress = addr;\n', '        emit ReceiverAddressSet(addr);\n', '    }\n', '\n', '    // once we have tokens we can enable the withdrawal\n', '    // setting this _useAsDefault to true will set this incoming address to the defaultToken.\n', '    function enableTokenWithdrawals (address _tokenAddr, bool _useAsDefault) public onlyAdmin noReentrancy {\n', '        require (contractStage == CONTRACT_SUBMIT_FUNDS, "wrong contract stage");\n', '        if (_useAsDefault) {\n', '            defaultToken = _tokenAddr;\n', '        } else {\n', '            require (defaultToken != 0x00, "defaultToken must be set");\n', '        }\n', '        TokenAllocation storage ta  = tokenAllocationMap[_tokenAddr];\n', '        if (ta.pct.length==0){\n', '            ta.token = ERC20(_tokenAddr);\n', '        }\n', '        uint256 amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\n', '        require (amount > 0);\n', '        if (feePct > 0) {\n', '            uint256 feePctFromBips = _toPct(feePct, 10000);\n', '            uint256 feeAmount = _applyPct(amount, feePctFromBips);\n', '            require (ta.token.transfer(owner, feeAmount));\n', '            emit TokenWithdrawal(owner, _tokenAddr, feeAmount);\n', '        }\n', '        amount = ta.token.balanceOf(this).sub(ta.balanceRemaining);\n', '        ta.balanceRemaining = ta.token.balanceOf(this);\n', '        ta.pct.push(_toPct(amount,finalBalance));\n', '    }\n', '\n', '    // get the available tokens\n', '    function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\n', '        Beneficiary storage b = beneficiaries[addr];\n', '        TokenAllocation storage ta = tokenAllocationMap[tokenAddr];\n', '        for (uint i = b.tokensClaimed[tokenAddr]; i < ta.pct.length; i++) {\n', '            tokenAmount = tokenAmount.add(_applyPct(b.balance, ta.pct[i]));\n', '        }\n', '        return tokenAmount;\n', '    }\n', '\n', '    // This is a standard function required for ERC223 compatibility.\n', '    function tokenFallback (address from, uint value, bytes data) public {\n', '        emit ERC223Received (from, value);\n', '    }\n', '\n', '    // returns a value as a % accurate to 20 decimal points\n', '    function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n', '        return numerator.mul(10 ** 20) / denominator;\n', '    }\n', '\n', '    // returns % of any number, where % given was generated with toPct\n', '    function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n', '        return numerator.mul(pct) / (10 ** 20);\n', '    }\n', '\n', '\n', '}']
