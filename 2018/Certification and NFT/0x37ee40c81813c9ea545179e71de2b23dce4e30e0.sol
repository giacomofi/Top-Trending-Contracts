['pragma solidity ^0.4.15;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface with DNN features.\n', '/// @author Dondrey Taylor - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2a4e45444e584f536a4e444404474f4e434b">[email&#160;protected]</a>>\n', 'contract DNNToken is StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Used to indicate which allocation we issue tokens from //\n', '    ////////////////////////////////////////////////////////////\n', '    enum DNNSupplyAllocations {\n', '        EarlyBackerSupplyAllocation,\n', '        PRETDESupplyAllocation,\n', '        TDESupplyAllocation,\n', '        BountySupplyAllocation,\n', '        WriterAccountSupplyAllocation,\n', '        AdvisorySupplyAllocation,\n', '        PlatformSupplyAllocation\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////\n', '    // Smart-Contract with permission to allocate tokens from supplies //\n', '    /////////////////////////////////////////////////////////////////////\n', '    address public allocatorAddress;\n', '    address public crowdfundContract;\n', '\n', '    /////////////////////\n', '    // Token Meta Data //\n', '    /////////////////////\n', '    string constant public name = "DNN";\n', '    string constant public symbol = "DNN";\n', '    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\n', '\n', '    /////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN //\n', '    /////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    /////////////////////////\n', '    // Address of Platform //\n', '    /////////////////////////\n', '    address public platform;\n', '\n', '    /////////////////////////////////////////////\n', '    // Token Distributions (% of total supply) //\n', '    /////////////////////////////////////////////\n', '    uint256 public earlyBackerSupply; // 10%\n', '    uint256 public PRETDESupply; // 10%\n', '    uint256 public TDESupply; // 40%\n', '    uint256 public bountySupply; // 1%\n', '    uint256 public writerAccountSupply; // 4%\n', '    uint256 public advisorySupply; // 14%\n', '    uint256 public cofoundersSupply; // 10%\n', '    uint256 public platformSupply; // 11%\n', '\n', '    uint256 public earlyBackerSupplyRemaining; // 10%\n', '    uint256 public PRETDESupplyRemaining; // 10%\n', '    uint256 public TDESupplyRemaining; // 40%\n', '    uint256 public bountySupplyRemaining; // 1%\n', '    uint256 public writerAccountSupplyRemaining; // 4%\n', '    uint256 public advisorySupplyRemaining; // 14%\n', '    uint256 public cofoundersSupplyRemaining; // 10%\n', '    uint256 public platformSupplyRemaining; // 11%\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    uint256 public cofoundersSupplyVestingTranches = 10;\n', '    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\n', '    uint256 public cofoundersSupplyVestingStartDate; // Epoch\n', '    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\n', '\n', '    //////////////////////////////////////////////\n', '    // Prevents tokens from being transferrable //\n', '    //////////////////////////////////////////////\n', '    bool public tokensLocked = true;\n', '\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    // Event triggered when tokens are transferred from one address to another //\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Checks if tokens can be issued to founder at this time //\n', '    ////////////////////////////////////////////////////////////\n', '    modifier CofoundersTokensVested()\n', '    {\n', '        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\n', '        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\n', '\n', '        // Get current tranche based on the amount of time that has passed since vesting start date\n', '        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\n', '\n', '        // Amount of tranches that have been issued so far\n', '        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\n', '\n', '        // Amount of tranches that cofounders are entitled to\n', '        uint256 maxTranches = cofoundersSupplyVestingTranches;\n', '\n', '        // Make sure that we still have unvested tokens and that\n', '        // the tokens for the current tranche have not been issued.\n', '        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\n', '\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////\n', '    // Checks if tokens are unlocked //\n', '    ///////////////////////////////////\n', '    modifier TokensUnlocked()\n', '    {\n', '        require (tokensLocked == false);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // Checks if tokens are locked //\n', '    /////////////////////////////////\n', '    modifier TokensLocked()\n', '    {\n', '       require (tokensLocked == true);\n', '       _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders()\n', '    {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA()\n', '    {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB()\n', '    {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////\n', '    // Checks if Allocator is performing the action //\n', '    //////////////////////////////////////////////////\n', '    modifier onlyAllocator()\n', '    {\n', '        require (msg.sender == allocatorAddress);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract is performing the action //\n', '    ///////////////////////////////////////////////////////////\n', '    modifier onlyCrowdfundContract()\n', '    {\n', '        require (msg.sender == crowdfundContract);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\n', '    {\n', '        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is manage platform holding  //\n', '    //  @param newAddress Address of new issuance contract.              //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function changePlatform(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        platform = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\n', '    //  @param newAddress Address of new issuance contract.                                                              //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeCrowdfundContract(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        crowdfundContract = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\n', '    //  @param newAddress Address of new issuance contract.                                                    //\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeAllocator(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        allocatorAddress = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // Transfers tokens from senders address to another address //\n', '    //////////////////////////////////////////////////////////////\n', '    function transfer(address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(msg.sender, _to, _value);\n', '          return BasicToken.transfer(_to, _value);\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////\n', '    // Transfers tokens from one address to another address //\n', '    //////////////////////////////////////////////////////////\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(_from, _to, _value);\n', '          return StandardToken.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\n', '    //  @param beneficiary Address of receiver.                                                  //\n', '    //  @param tokenCount Number of tokens to issue.                                             //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    function issueCofoundersTokensIfPossible()\n', '        onlyCofounders\n', '        CofoundersTokensVested\n', '        returns (bool)\n', '    {\n', '        // Compute total amount of vested tokens to issue\n', '        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\n', '\n', '        // Make sure that there are cofounder tokens left\n', '        if (tokenCount > cofoundersSupplyRemaining) {\n', '           return false;\n', '        }\n', '\n', '        // Decrease cofounders supply\n', '        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\n', '\n', '        // Update how many tokens have been distributed to cofounders\n', '        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\n', '\n', '        // Split tokens between both founders\n', '        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\n', '        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\n', '\n', '        // Update that a tranche has been issued\n', '        cofoundersSupplyVestingTranchesIssued += 1;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    //////////////////\n', '    // Issue tokens //\n', '    //////////////////\n', '    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\n', '      onlyAllocatorOrCrowdfundContractOrPlatform\n', '      returns (bool)\n', '    {\n', '        // We&#39;ll use the following to determine whether the allocator, platform,\n', '        // or the crowdfunding contract can allocate specified supply\n', '        bool canAllocatorPerform = msg.sender == allocatorAddress;\n', '        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\n', '        bool canPlatformPerform = msg.sender == platform;\n', '\n', '        // Early Backers\n', '        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\n', '            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // PRE-TDE\n', '        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\n', '\n', '              // Check to see if we have enough tokens to satisfy this purchase\n', '              // using just the pre-tde.\n', '              if (PRETDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease pre-tde supply\n', '                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\n', '              }\n', '\n', '              // Check to see if we can satisfy this using pre-tde and tde supply combined\n', '              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease tde supply\n', '                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\n', '\n', '                    // Decrease pre-tde supply by its&#39; remaining tokens\n', '                    PRETDESupplyRemaining = 0;\n', '              }\n', '\n', '              // Otherwise, we can&#39;t satisfy this sale because we don&#39;t have enough tokens.\n', '              else {\n', '                  return false;\n', '              }\n', '        }\n', '\n', '        // TDE\n', '        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\n', '            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Bounty\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\n', '            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Writer Accounts\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\n', '            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Advisory\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\n', '            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\n', '        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\n', '            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        else {\n', '            return false;\n', '        }\n', '\n', '        // Transfer tokens\n', '        Transfer(address(this), beneficiary, tokenCount);\n', '\n', '        // Credit tokens to the address specified\n', '        balances[beneficiary] = balances[beneficiary].add(tokenCount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from TDE to Platform //\n', '    /////////////////////////////////////////////////\n', '    function sendUnsoldTDETokensToPlatform()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '        // Make sure we have tokens to send from TDE\n', '        if (TDESupplyRemaining > 0) {\n', '\n', '            // Add remaining tde tokens to platform remaining tokens\n', '            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\n', '\n', '            // Clear remaining tde token count\n', '            TDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from pre-TDE to Platform //\n', '    /////////////////////////////////////////////////////\n', '    function sendUnsoldPRETDETokensToTDE()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '          // Make sure we have tokens to send from pre-TDE\n', '          if (PRETDESupplyRemaining > 0) {\n', '\n', '              // Add remaining pre-tde tokens to tde remaining tokens\n', '              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\n', '\n', '              // Clear remaining pre-tde token count\n', '              PRETDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////\n', '    // @des Allows tokens to be transferrable. Returns lock state //\n', '    ////////////////////////////////////////////////////////////////\n', '    function unlockTokens()\n', '        external\n', '        onlyCrowdfundContract\n', '    {\n', '        // Make sure tokens are currently locked before proceeding to unlock them\n', '        require(tokensLocked == true);\n', '\n', '        tokensLocked = false;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Contract constructor function sets initial token balances.  //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function DNNToken()\n', '    {\n', '          // Start date\n', '          uint256 vestingStartDate = 1526072145;\n', '\n', '          // Set cofounder addresses\n', '          cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '          cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '          // Sets platform address\n', '          platform = address(this);\n', '\n', '          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\n', '          // 1 DNN = 10^18 atto-DNN\n', '          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\n', '\n', '          // Set Token Distributions (% of total supply)\n', '          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\n', '          PRETDESupply = totalSupply.mul(10).div(100); // 10%\n', '          TDESupply = totalSupply.mul(40).div(100); // 40%\n', '          bountySupply = totalSupply.mul(1).div(100); // 1%\n', '          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\n', '          advisorySupply = totalSupply.mul(14).div(100); // 14%\n', '          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\n', '          platformSupply = totalSupply.mul(11).div(100); // 11%\n', '\n', '          // Set each remaining token count equal to its&#39; respective supply\n', '          earlyBackerSupplyRemaining = earlyBackerSupply;\n', '          PRETDESupplyRemaining = PRETDESupply;\n', '          TDESupplyRemaining = TDESupply;\n', '          bountySupplyRemaining = bountySupply;\n', '          writerAccountSupplyRemaining = writerAccountSupply;\n', '          advisorySupplyRemaining = advisorySupply;\n', '          cofoundersSupplyRemaining = cofoundersSupply;\n', '          platformSupplyRemaining = platformSupply;\n', '\n', '          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\n', '          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\n', '    }\n', '}\n', '\n', '/// @title DNNTDE contract - Takes funds from users and issues tokens.\n', '/// @author Dondrey Taylor - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="95f1fafbf1e7f0ecd5f1fbfbbbf8f0f1fcf4">[email&#160;protected]</a>>\n', 'contract DNNTDE {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /////////////////////////\n', '    // DNN Token Contract  //\n', '    /////////////////////////\n', '    DNNToken public dnnToken;\n', '\n', '    //////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN. //\n', '    //////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    ///////////////////////////\n', '    // DNN Holding Multisig //\n', '    //////////////////////////\n', '    address public dnnHoldingMultisig;\n', '\n', '    ///////////////////////////\n', '    // Start date of the TDE //\n', '    ///////////////////////////\n', '    uint256 public TDEStartDate;  // Epoch\n', '\n', '    /////////////////////////\n', '    // End date of the TDE //\n', '    /////////////////////////\n', '    uint256 public TDEEndDate;  // Epoch\n', '\n', '    /////////////////////////////////\n', '    // Amount of atto-DNN per wei //\n', '    /////////////////////////////////\n', '    uint256 public tokenExchangeRateBase = 3000; // 1 Wei = 3000 atto-DNN\n', '\n', '    /////////////////////////////////////////////////\n', '    // Number of tokens distributed (in atto-DNN) //\n', '    /////////////////////////////////////////////////\n', '    uint256 public tokensDistributed = 0;\n', '\n', '    ///////////////////////////////////////////////\n', '    // Minumum Contributions for pre-TDE and TDE //\n', '    ///////////////////////////////////////////////\n', '    uint256 public minimumTDEContributionInWei = 0.001 ether;\n', '    uint256 public minimumPRETDEContributionInWei = 5 ether;\n', '\n', '    //////////////////////\n', '    // Funding Hard cap //\n', '    //////////////////////\n', '    uint256 public maximumFundingGoalInETH;\n', '\n', '    //////////////////\n', '    // Funds Raised //\n', '    //////////////////\n', '    uint256 public fundsRaisedInWei = 0;\n', '    uint256 public presaleFundsRaisedInWei = 0;\n', '    uint256 public tdeFundsRaisedInWei = 0;\n', '\n', '    ////////////////////////////////////////////\n', '    // Keep track of Wei contributed per user //\n', '    ////////////////////////////////////////////\n', '    mapping(address => uint256) ETHContributions;\n', '\n', '    ////////////////////////////////////////////////\n', '    // Keeps track of tokens per eth contribution //\n', '    ////////////////////////////////////////////////\n', '    mapping(address => uint256) ETHContributorTokens;\n', '\n', '\n', '    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    // Keeps track of pre-tde contributors and how many tokens they are entitled to get based on their contribution //\n', '    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    mapping(address => uint256) PRETDEContributorTokensPendingRelease;\n', '    uint256 PRETDEContributorsTokensPendingCount = 0; // keep track of contributors waiting for tokens\n', '    uint256 TokensPurchasedDuringPRETDE = 0; // keep track of how many tokens need to be issued to presale contributors\n', '\n', '\n', '    //////////////////\n', '    // Bonus ranges //\n', '    //////////////////\n', '    bool public trickleDownBonusesReleased = false;\n', '    uint256 public rangeETHAmount = 0;\n', '    uint256 public bonusRangeCount = 4;\n', '\n', '    uint256 public TDEContributorCount = 0;\n', '    mapping(uint256 => address) public TDEContributorAddresses;\n', '    mapping(address => uint256) public TDEContributorInitialBonusByAddress;\n', '\n', '    uint256 public tokensIssuedForBonusRangeOne    = 0;\n', '    uint256 public tokensIssuedForBonusRangeTwo    = 0;\n', '    uint256 public tokensIssuedForBonusRangeThree  = 0;\n', '    uint256 public tokensIssuedForBonusRangeFour   = 0;\n', '\n', '    //////////////////////////////////////////////////////\n', '    // Checks if trickle down bonuses not been released //\n', '    //////////////////////////////////////////////////////\n', '    modifier HasTrickleDownBonusesNotBeenReleased() {\n', '        require (trickleDownBonusesReleased == false);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    // Checks if all pre-tde contributors have received their tokens //\n', '    ///////////////////////////////////////////////////////////////////\n', '    modifier NoPRETDEContributorsAwaitingTokens() {\n', '        // Determine if all pre-tde contributors have received tokens\n', '        require(PRETDEContributorsTokensPendingCount == 0);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if there are any pre-tde contributors that have not recieved their tokens  //\n', '    ///////////////////////////////////////////////////////////////////////////////////////\n', '    modifier PRETDEContributorsAwaitingTokens() {\n', '\n', '        // Determine if there pre-tde contributors that have not received tokens\n', '        require(PRETDEContributorsTokensPendingCount > 0);\n', '\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders() {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA() {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB() {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////s\n', '    // Check if the tde has ended //\n', '    ////////////////////////////////\n', '    modifier TDEHasEnded() {\n', '       require (now >= TDEEndDate || fundsRaisedInWei >= maximumFundingGoalInETH);\n', '       _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////////\n', '    // Checksto see if the contribution is at least the minimum allowed for tde //\n', '    //////////////////////////////////////////////////////////////////////////////\n', '    modifier ContributionIsAtLeastMinimum() {\n', '        require (msg.value >= minimumTDEContributionInWei);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // Make sure max cap is not exceeded with added contribution //\n', '    ///////////////////////////////////////////////////////////////\n', '    modifier ContributionDoesNotCauseGoalExceedance() {\n', '       uint256 newFundsRaised = msg.value+fundsRaisedInWei;\n', '       require (newFundsRaised <= maximumFundingGoalInETH);\n', '       _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // Make sure max tokens is not exceeded with added contribution //\n', '    ///////////////////////////////////////////////////////////////\n', '    modifier TDEBonusesDoesNotCauseTokenExceedance() {\n', '       uint256 tokensDistributedPlusBonuses = getTokensDistributedPlusTrickleDownBonuses();\n', '       require (tokensDistributedPlusBonuses < dnnToken.TDESupplyRemaining());\n', '       _;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    // Check if the specified beneficiary has sent us funds before //\n', '    /////////////////////////////////////////////////////////////////\n', '    modifier HasPendingPRETDETokens(address _contributor) {\n', '        require (PRETDEContributorTokensPendingRelease[_contributor] !=  0);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////\n', '    // Check if pre-tde contributors is not waiting for tokens //\n', '    /////////////////////////////////////////////////////////////\n', '    modifier IsNotAwaitingPRETDETokens(address _contributor) {\n', '        require (PRETDEContributorTokensPendingRelease[_contributor] ==  0);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////\n', '    //  @des Tokens distributed plus trickle down bonuses. //\n', '    /////////////////////////////////////////////////////////\n', '    function getTokensDistributedPlusTrickleDownBonuses()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return tokensIssuedForBonusRangeOne.mul(220).div(100) + tokensIssuedForBonusRangeTwo.mul(190).div(100) + tokensIssuedForBonusRangeThree.mul(150).div(100) + tokensIssuedForBonusRangeFour.mul(100).div(100);\n', '    }\n', '\n', '    ////////////////////////////////////////\n', '    //  @des Function to extend tde       //\n', '    //  @param new crowdsale start date   //\n', '    ////////////////////////////////////////\n', '    function extendTDE(uint256 endDate)\n', '        onlyCofounders\n', '        returns (bool)\n', '    {\n', '        // Make sure that the new date is past the existing date and\n', '        // is not in the past.\n', '        if (endDate > now && endDate > TDEEndDate) {\n', '            TDEEndDate = endDate;\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    ////////////////////////////////////////\n', '    //  @des Function to extend pre-tde   //\n', '    //  @param new crowdsale start date   //\n', '    ////////////////////////////////////////\n', '    function extendPRETDE(uint256 startDate)\n', '        onlyCofounders\n', '        returns (bool)\n', '    {\n', '        // Make sure that the new date is past the existing date and\n', '        // is not in the past.\n', '        if (startDate > now && startDate > TDEStartDate) {\n', '            TDEEndDate = TDEEndDate + (startDate-TDEStartDate); // Move end date the same amount of days as start date\n', '            TDEStartDate = startDate; // set new start date\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change multisig address.       //\n', '    //  @param newAddress Address of new multisig.      //\n', '    //////////////////////////////////////////////////////\n', '    function changeDNNHoldingMultisig(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        dnnHoldingMultisig = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////\n', '    // @des ETH balance of each contributor //\n', '    //////////////////////////////////////////\n', '    function contributorETHBalance(address _owner)\n', '      constant\n', '      returns (uint256 balance)\n', '    {\n', '        return ETHContributions[_owner];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // @des Determines if an address is a pre-TDE contributor //\n', '    ////////////////////////////////////////////////////////////\n', '    function isAwaitingPRETDETokens(address _contributorAddress)\n', '       internal\n', '       returns (bool)\n', '    {\n', '        return PRETDEContributorTokensPendingRelease[_contributorAddress] > 0;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////\n', '    // @des Returns pending presale tokens for a given address //\n', '    /////////////////////////////////////////////////////////////\n', '    function getPendingPresaleTokens(address _contributor)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return PRETDEContributorTokensPendingRelease[_contributor];\n', '    }\n', '\n', '    ////////////////////////////////\n', '    // @des Returns current bonus //\n', '    ////////////////////////////////\n', '    function getCurrentTDEBonus()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return getTDETokenExchangeRate(now);\n', '    }\n', '\n', '\n', '    ////////////////////////////////\n', '    // @des Returns current bonus //\n', '    ////////////////////////////////\n', '    function getCurrentPRETDEBonus()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return getPRETDETokenExchangeRate(now);\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    // @des Returns bonus (in atto-DNN) per wei for the specific moment //\n', '    // @param timestamp Time of purchase (in seconds)                    //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function getTDETokenExchangeRate(uint256 timestamp)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // No bonus - TDE ended\n', '        if (timestamp > TDEEndDate) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // No bonus - TDE has not started\n', '        if (TDEStartDate > timestamp) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // Bonus One --> 0 - 25% of raise\n', '        if (tdeFundsRaisedInWei <= rangeETHAmount) {\n', '            return tokenExchangeRateBase.mul(120).div(100);\n', '        }\n', '        // Bonus Two --> 25% - 50% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '            return tokenExchangeRateBase.mul(130).div(100);\n', '        }\n', '        // Bonus Three --> 50% - 75% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '            return tokenExchangeRateBase.mul(140).div(100);\n', '        }\n', '        // Bonus Four --> 75% - 100% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(3) && tdeFundsRaisedInWei <= maximumFundingGoalInETH) {\n', '            return tokenExchangeRateBase.mul(150).div(100);\n', '        }\n', '        else {\n', '            return tokenExchangeRateBase;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Returns bonus (in atto-DNN) per wei for the specific contribution amount //\n', '    // @param weiamount The amount of wei being contributed                           //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    function getPRETDETokenExchangeRate(uint256 weiamount)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // Presale will only accept contributions above minimum\n', '        if (weiamount < minimumPRETDEContributionInWei) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // Minimum Contribution - 199 ETH (25% Bonus)\n', '        if (weiamount >= minimumPRETDEContributionInWei && weiamount <= 199 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(25).div(100);\n', '\n', '        // 200 ETH - 300 ETH Bonus (30% Bonus)\n', '        } else if (weiamount >= 200 ether && weiamount <= 300 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(30).div(100);\n', '\n', '        // 301 ETH - 2665 ETH Bonus (35% Bonus)\n', '        } else if (weiamount >= 301 ether && weiamount <= 2665 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(35).div(100);\n', '\n', '        // 2666+ ETH Bonus (50% Bonus)\n', '        } else {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(50).div(100);\n', '        }\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Computes how many tokens a buyer is entitled to based on contribution and time. //\n', '    //////////////////////////////////////////////////////////////////////////////////////////\n', '    function calculateTokens(uint256 weiamount, uint256 timestamp)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // Compute how many atto-DNN user is entitled to.\n', '        uint256 computedTokensForPurchase = weiamount.mul(timestamp >= TDEStartDate ? getTDETokenExchangeRate(timestamp) : getPRETDETokenExchangeRate(weiamount));\n', '\n', '        // Amount of atto-DNN to issue\n', '        return computedTokensForPurchase;\n', '     }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // @des Issues tokens for users who made purchase with ETH   //\n', '    // @param beneficiary Address the tokens will be issued to.  //\n', '    // @param weiamount ETH amount (in Wei)                      //\n', '    // @param timestamp Time of purchase (in seconds)            //\n', '    ///////////////////////////////////////////////////////////////\n', '    function buyTokens()\n', '        internal\n', '        ContributionIsAtLeastMinimum\n', '        ContributionDoesNotCauseGoalExceedance\n', '        TDEBonusesDoesNotCauseTokenExceedance\n', '        returns (bool)\n', '    {\n', '        // Determine how many tokens should be issued\n', '        uint256 tokenCount = calculateTokens(msg.value, now);\n', '\n', '         // Bonus Four\n', '        if (tdeFundsRaisedInWei > rangeETHAmount.mul(3) && tdeFundsRaisedInWei <= maximumFundingGoalInETH) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = tdeFundsRaisedInWei;\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus Three\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount.mul(3);\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus Two\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount.mul(2);\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus One\n', '        else if (tdeFundsRaisedInWei <= rangeETHAmount) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount;\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '\n', '        // Keep track of tokens issued within each range\n', '        // Bonus Four\n', '        if (TDEContributorInitialBonusByAddress[msg.sender] == tdeFundsRaisedInWei) {\n', '            tokensIssuedForBonusRangeFour = tokensIssuedForBonusRangeFour.add(tokenCount);\n', '        }\n', '        // Bonus Three\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount.mul(3)) {\n', '            tokensIssuedForBonusRangeThree = tokensIssuedForBonusRangeThree.add(tokenCount);\n', '        }\n', '        // Bonus Two\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount.mul(2)) {\n', '            tokensIssuedForBonusRangeTwo = tokensIssuedForBonusRangeTwo.add(tokenCount);\n', '        }\n', '        // Bonus One\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount) {\n', '            tokensIssuedForBonusRangeOne = tokensIssuedForBonusRangeOne.add(tokenCount);\n', '        }\n', '\n', '        // Get total tokens distributed plus bonuses\n', '        uint256 tokensDistributedPlusBonuses = getTokensDistributedPlusTrickleDownBonuses();\n', '\n', '        // Make sure we have enough tokens to satisfy the transaction\n', '        if (tokensDistributedPlusBonuses > dnnToken.TDESupplyRemaining()) {\n', '            revert();\n', '        }\n', '\n', '        // Update total amount of tokens distributed (in atto-DNN)\n', '        tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '        // Keep track of contributions (in Wei)\n', '        ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\n', '\n', '        // Keep track of how much tokens are issued to each contributor\n', '        ETHContributorTokens[msg.sender] = ETHContributorTokens[msg.sender].add(tokenCount);\n', '\n', '        // Increase total funds raised by contribution\n', '        fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\n', '\n', '        // Increase tde total funds raised by contribution\n', '        tdeFundsRaisedInWei = tdeFundsRaisedInWei.add(msg.value);\n', '\n', '        // Determine which token allocation we should be deducting from\n', '        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '        // Attempt to issue tokens to contributor\n', '        if (!dnnToken.issueTokens(msg.sender, tokenCount, allocationType)) {\n', '            revert();\n', '        }\n', '\n', '        // Transfer funds to multisig\n', '        dnnHoldingMultisig.transfer(msg.value);\n', '\n', '        return true;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Issues tokens for users who made purchase without using ETH during presale.   //\n', '    // @param beneficiary Address the tokens will be issued to.                           //\n', '    // @param weiamount ETH amount (in Wei)                                               //\n', '    ////////////////////////////////////////////////////////////////////////////////////////\n', '    function buyPRETDETokensWithoutETH(address beneficiary, uint256 weiamount, uint256 tokenCount)\n', '        onlyCofounders\n', '        IsNotAwaitingPRETDETokens(beneficiary)\n', '        returns (bool)\n', '    {\n', '\n', '          // Keep track of how much tokens are issued to each contributor\n', '          ETHContributorTokens[beneficiary] = ETHContributorTokens[beneficiary].add(tokenCount);\n', '\n', '          // Keep track of contributions (in Wei)\n', '          ETHContributions[beneficiary] = ETHContributions[beneficiary].add(weiamount);\n', '\n', '          // Increase total funds raised by contribution\n', '          fundsRaisedInWei = fundsRaisedInWei.add(weiamount);\n', '\n', '          // Keep track of presale funds in addition, separately\n', '          presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(weiamount);\n', '\n', '          // Add these tokens to the total amount of tokens this contributor is entitled to\n', '          PRETDEContributorTokensPendingRelease[beneficiary] = PRETDEContributorTokensPendingRelease[beneficiary].add(tokenCount);\n', '\n', '          // Incrment number of pre-tde contributors waiting for tokens\n', '          PRETDEContributorsTokensPendingCount += 1;\n', '\n', '          // Send tokens to contibutor\n', '          return issuePRETDETokens(beneficiary);\n', '      }\n', '\n', '      ////////////////////////////////////////////////////////////////////////////////////////////\n', '      // @des Issues tokens for users who made purchase without using ETH during public sale.   //\n', '      // @param beneficiary Address the tokens will be issued to.                               //\n', '      // @param weiamount ETH amount (in Wei)                                                   //\n', '      ////////////////////////////////////////////////////////////////////////////////////////////\n', '      function buyTDETokensWithoutETH(address beneficiary, uint256 weiamount, uint256 tokenCount)\n', '          onlyCofounders\n', '          returns (bool)\n', '      {\n', '            // Get total tokens distributed plus bonuses\n', '            uint256 tokensDistributedPlusBonuses = tokenCount.add(getTokensDistributedPlusTrickleDownBonuses());\n', '\n', '            // Make sure we have enough tokens to satisfy the transaction\n', '            if (tokensDistributedPlusBonuses > dnnToken.TDESupplyRemaining()) {\n', '                revert();\n', '            }\n', '\n', '            // Keep track of how much tokens are issued to each contributor\n', '            ETHContributorTokens[beneficiary] = ETHContributorTokens[beneficiary].add(tokenCount);\n', '\n', '            // Keep track of contributions (in Wei)\n', '            ETHContributions[beneficiary] = ETHContributions[beneficiary].add(weiamount);\n', '\n', '            // Increase total funds raised by contribution\n', '            fundsRaisedInWei = fundsRaisedInWei.add(weiamount);\n', '\n', '            // Keep track of tde funds in addition, separately\n', '            tdeFundsRaisedInWei = tdeFundsRaisedInWei.add(weiamount);\n', '\n', '            // Send tokens to contibutor\n', '            return issueTDETokens(beneficiary, tokenCount);\n', '        }\n', '\n', '      ///////////////////////////////////////////////////////////////\n', '      // @des Issues bulk token purchases                          //\n', '      // @param beneficiary Address the tokens will be issued to.  //\n', '      ///////////////////////////////////////////////////////////////\n', '      function issueTDETokens(address beneficiary, uint256 tokenCount)\n', '          internal\n', '          returns (bool)\n', '      {\n', '\n', '          // Update total amount of tokens distributed (in atto-DNN)\n', '          tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '          // Allocation type will be PRETDESupplyAllocation\n', '          DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '          // Attempt to issue tokens\n', '          if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\n', '              revert();\n', '          }\n', '\n', '          return true;\n', '      }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // @des Issues pending tokens to pre-tde contributor         //\n', '    // @param beneficiary Address the tokens will be issued to.  //\n', '    ///////////////////////////////////////////////////////////////\n', '    function issuePRETDETokens(address beneficiary)\n', '        onlyCofounders\n', '        PRETDEContributorsAwaitingTokens\n', '        HasPendingPRETDETokens(beneficiary)\n', '        returns (bool)\n', '    {\n', '        // Amount of tokens to credit pre-tde contributor\n', '        uint256 tokenCount = PRETDEContributorTokensPendingRelease[beneficiary];\n', '\n', '        // Update total amount of tokens distributed (in atto-DNN)\n', '        tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '        // Allocation type will be PRETDESupplyAllocation\n', '        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.PRETDESupplyAllocation;\n', '\n', '        // Attempt to issue tokens\n', '        if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\n', '            revert();\n', '        }\n', '\n', '        // Reduce number of pre-tde contributors waiting for tokens\n', '        PRETDEContributorsTokensPendingCount -= 1;\n', '\n', '        // Denote that tokens have been issued for this pre-tde contributor\n', '        PRETDEContributorTokensPendingRelease[beneficiary] = 0;\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////\n', '    // @des Issue trickle down bonuses //\n', '    /////////////////////////////////////\n', '    function releaseTrickleDownBonuses()\n', '      onlyCofounders\n', '    {\n', '        // Issue trickle down bonuses if we have not already done so\n', '        if (trickleDownBonusesReleased == false) {\n', '\n', '            // Determine which token allocation we should be deducting from\n', '            DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '            // Temporary reference to contribution\n', '            address contributorAddress;\n', '\n', '            // Temporary reference to contributor bonus tokens\n', '            uint256 bonusTokens;\n', '\n', '            // Iterate through contributors\n', '            for (uint256 iteration=0; iteration < TDEContributorCount; iteration++) {\n', '\n', '                // No bonus tokens to issue until contribute range and funds raised\n', '                // are determined.\n', '                bonusTokens = 0;\n', '\n', '                // If we have at least reached the bonus 2 range, issue bonuses to everyone in bonus 1\n', '                if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(130).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '\n', '                // If we have at least reached the bonus 3 range, issue bonuses to everyone in bonus 1 & 2\n', '                else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 and range 3 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(170).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(2)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(140).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '\n', '                // If we have at least reached the bonus 4 range, issue bonuses to everyone in bonus 1, 2, & 3\n', '                else if (tdeFundsRaisedInWei > rangeETHAmount.mul(3)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 and range 3 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(220).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(2)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(190).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(3)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(150).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '            }\n', '\n', '            // Mark down that bonuses have been released\n', '            trickleDownBonusesReleased = true;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // @des Marks TDE as completed //\n', '    /////////////////////////////////\n', '    function finalizeTDE()\n', '       onlyCofounders\n', '       TDEHasEnded\n', '    {\n', '        // Check if the tokens are locked and all pre-sale tokens have been\n', '        // transferred to the TDE Supply before unlocking tokens.\n', '        require(dnnToken.tokensLocked() == true && dnnToken.PRETDESupplyRemaining() == 0);\n', '\n', '        // Release Bonuses\n', '        releaseTrickleDownBonuses();\n', '\n', '        // Unlock tokens\n', '        dnnToken.unlockTokens();\n', '\n', '        // Update tokens distributed\n', '        tokensDistributed += dnnToken.TDESupplyRemaining();\n', '\n', '        // Transfer unsold TDE tokens to platform\n', '        dnnToken.sendUnsoldTDETokensToPlatform();\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    // @des Marks pre-TDE as completed by moving remaining tokens into TDE supply //\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    function finalizePRETDE()\n', '       onlyCofounders\n', '       NoPRETDEContributorsAwaitingTokens\n', '    {\n', '        // Check if we have tokens to transfer to TDE\n', '        require(dnnToken.PRETDESupplyRemaining() > 0);\n', '\n', '        // Transfer unsold TDE tokens to platform\n', '        dnnToken.sendUnsoldPRETDETokensToTDE();\n', '    }\n', '\n', '\n', '    ///////////////////////////////\n', '    // @des Contract constructor /xw/\n', '    ///////////////////////////////\n', '    function DNNTDE()\n', '    {\n', '        // Hard Cap\n', '        uint256 hardCap = 35000;\n', '\n', '        // Set token address\n', '        dnnToken = DNNToken(0x9D9832d1beb29CC949d75D61415FD00279f84Dc2);\n', '\n', '        // Set cofounder addresses\n', '        cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '        cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '        // Set DNN holding address\n', '        dnnHoldingMultisig = 0x5980a47514a0Af79a8d2F6276f8673a006ec9929;\n', '\n', '        // Set hard cap\n', '        maximumFundingGoalInETH = hardCap * 1 ether;\n', '\n', '        // Range ETH\n', '        rangeETHAmount = hardCap.div(bonusRangeCount) * 1 ether;\n', '\n', '        // Set Start Date\n', '        TDEStartDate = 1529020801;\n', '\n', '        // Set End date (Make sure the end date is at least 30 days from start date)\n', '        // Will default to a date that is exactly 30 days from start date.\n', '        TDEEndDate = (TDEStartDate + 35 days);\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////\n', '    // @des Handle&#39;s ETH sent directly to contract address //\n', '    /////////////////////////////////////////////////////////\n', '    function () payable {\n', '\n', '        // Handle pre-sale contribution (tokens held, until tx confirmation from contributor)\n', '        // Makes sure the user sends minimum PRE-TDE contribution, and that  pre-tde contributors\n', '        // are unable to send subsequent ETH contributors before being issued tokens.\n', '        if (now < TDEStartDate && msg.value >= minimumPRETDEContributionInWei && PRETDEContributorTokensPendingRelease[msg.sender] == 0) {\n', '\n', '            // Keep track of contributions (in Wei)\n', '            ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\n', '\n', '            // Increase total funds raised by contribution\n', '            fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\n', '\n', '            // Keep track of presale funds in addition, separately\n', '            presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(msg.value);\n', '\n', '            /// Make a note of how many tokens this user should get for their contribution to the presale\n', '            PRETDEContributorTokensPendingRelease[msg.sender] = PRETDEContributorTokensPendingRelease[msg.sender].add(calculateTokens(msg.value, now));\n', '\n', '            // Keep track of pending tokens\n', '            TokensPurchasedDuringPRETDE += calculateTokens(msg.value, now);\n', '\n', '            // Increment number of pre-tde contributors waiting for tokens\n', '            PRETDEContributorsTokensPendingCount += 1;\n', '\n', '            // Prevent contributions that will cause us to have a shortage of tokens during the pre-sale\n', '            if (TokensPurchasedDuringPRETDE > dnnToken.TDESupplyRemaining()+dnnToken.PRETDESupplyRemaining()) {\n', '                revert();\n', '            }\n', '\n', '            // Transfer contribution directly to multisig\n', '            dnnHoldingMultisig.transfer(msg.value);\n', '        }\n', '\n', '        // Handle public-sale contribution (tokens issued immediately)\n', '        else if (now >= TDEStartDate && now < TDEEndDate) buyTokens();\n', '\n', '        // Otherwise, reject the contribution\n', '        else revert();\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    // SafeMath.sub will throw if there is not enough balance.\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    require(_to != address(0));\n', '\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   */\n', '  function increaseApproval (address _spender, uint _addedValue)\n', '    returns (bool success) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval (address _spender, uint _subtractedValue)\n', '    returns (bool success) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface with DNN features.\n', '/// @author Dondrey Taylor - <dondrey@dnn.media>\n', 'contract DNNToken is StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Used to indicate which allocation we issue tokens from //\n', '    ////////////////////////////////////////////////////////////\n', '    enum DNNSupplyAllocations {\n', '        EarlyBackerSupplyAllocation,\n', '        PRETDESupplyAllocation,\n', '        TDESupplyAllocation,\n', '        BountySupplyAllocation,\n', '        WriterAccountSupplyAllocation,\n', '        AdvisorySupplyAllocation,\n', '        PlatformSupplyAllocation\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////\n', '    // Smart-Contract with permission to allocate tokens from supplies //\n', '    /////////////////////////////////////////////////////////////////////\n', '    address public allocatorAddress;\n', '    address public crowdfundContract;\n', '\n', '    /////////////////////\n', '    // Token Meta Data //\n', '    /////////////////////\n', '    string constant public name = "DNN";\n', '    string constant public symbol = "DNN";\n', '    uint8 constant public decimals = 18; // 1 DNN = 1 * 10^18 atto-DNN\n', '\n', '    /////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN //\n', '    /////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    /////////////////////////\n', '    // Address of Platform //\n', '    /////////////////////////\n', '    address public platform;\n', '\n', '    /////////////////////////////////////////////\n', '    // Token Distributions (% of total supply) //\n', '    /////////////////////////////////////////////\n', '    uint256 public earlyBackerSupply; // 10%\n', '    uint256 public PRETDESupply; // 10%\n', '    uint256 public TDESupply; // 40%\n', '    uint256 public bountySupply; // 1%\n', '    uint256 public writerAccountSupply; // 4%\n', '    uint256 public advisorySupply; // 14%\n', '    uint256 public cofoundersSupply; // 10%\n', '    uint256 public platformSupply; // 11%\n', '\n', '    uint256 public earlyBackerSupplyRemaining; // 10%\n', '    uint256 public PRETDESupplyRemaining; // 10%\n', '    uint256 public TDESupplyRemaining; // 40%\n', '    uint256 public bountySupplyRemaining; // 1%\n', '    uint256 public writerAccountSupplyRemaining; // 4%\n', '    uint256 public advisorySupplyRemaining; // 14%\n', '    uint256 public cofoundersSupplyRemaining; // 10%\n', '    uint256 public platformSupplyRemaining; // 11%\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // Amount of CoFounder Supply that has been distributed based on vesting schedule //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    uint256 public cofoundersSupplyVestingTranches = 10;\n', '    uint256 public cofoundersSupplyVestingTranchesIssued = 0;\n', '    uint256 public cofoundersSupplyVestingStartDate; // Epoch\n', '    uint256 public cofoundersSupplyDistributed = 0;  // # of atto-DNN distributed to founders\n', '\n', '    //////////////////////////////////////////////\n', '    // Prevents tokens from being transferrable //\n', '    //////////////////////////////////////////////\n', '    bool public tokensLocked = true;\n', '\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    // Event triggered when tokens are transferred from one address to another //\n', '    /////////////////////////////////////////////////////////////////////////////\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // Checks if tokens can be issued to founder at this time //\n', '    ////////////////////////////////////////////////////////////\n', '    modifier CofoundersTokensVested()\n', '    {\n', '        // Make sure that a starting vesting date has been set and 4 weeks have passed since vesting date\n', '        require (cofoundersSupplyVestingStartDate != 0 && (now-cofoundersSupplyVestingStartDate) >= 4 weeks);\n', '\n', '        // Get current tranche based on the amount of time that has passed since vesting start date\n', '        uint256 currentTranche = now.sub(cofoundersSupplyVestingStartDate) / 4 weeks;\n', '\n', '        // Amount of tranches that have been issued so far\n', '        uint256 issuedTranches = cofoundersSupplyVestingTranchesIssued;\n', '\n', '        // Amount of tranches that cofounders are entitled to\n', '        uint256 maxTranches = cofoundersSupplyVestingTranches;\n', '\n', '        // Make sure that we still have unvested tokens and that\n', '        // the tokens for the current tranche have not been issued.\n', '        require (issuedTranches != maxTranches && currentTranche > issuedTranches);\n', '\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////\n', '    // Checks if tokens are unlocked //\n', '    ///////////////////////////////////\n', '    modifier TokensUnlocked()\n', '    {\n', '        require (tokensLocked == false);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // Checks if tokens are locked //\n', '    /////////////////////////////////\n', '    modifier TokensLocked()\n', '    {\n', '       require (tokensLocked == true);\n', '       _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders()\n', '    {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA()\n', '    {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB()\n', '    {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////\n', '    // Checks if Allocator is performing the action //\n', '    //////////////////////////////////////////////////\n', '    modifier onlyAllocator()\n', '    {\n', '        require (msg.sender == allocatorAddress);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract is performing the action //\n', '    ///////////////////////////////////////////////////////////\n', '    modifier onlyCrowdfundContract()\n', '    {\n', '        require (msg.sender == crowdfundContract);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if Crowdfund Contract, Platform, or Allocator is performing the action //\n', '    ///////////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAllocatorOrCrowdfundContractOrPlatform()\n', '    {\n', '        require (msg.sender == allocatorAddress || msg.sender == crowdfundContract || msg.sender == platform);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is manage platform holding  //\n', '    //  @param newAddress Address of new issuance contract.              //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function changePlatform(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        platform = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Crowdfund contract can only be set once.   //\n', '    //  @param newAddress Address of new issuance contract.                                                              //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeCrowdfundContract(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        crowdfundContract = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Function to change address that is allowed to do token issuance. Allocator can only be set once.  //\n', '    //  @param newAddress Address of new issuance contract.                                                    //\n', '    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    function changeAllocator(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        allocatorAddress = newAddress;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '\n', '    //////////////////////////////////////////////////////////////\n', '    // Transfers tokens from senders address to another address //\n', '    //////////////////////////////////////////////////////////////\n', '    function transfer(address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(msg.sender, _to, _value);\n', '          return BasicToken.transfer(_to, _value);\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////\n', '    // Transfers tokens from one address to another address //\n', '    //////////////////////////////////////////////////////////\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '      TokensUnlocked\n', '      returns (bool)\n', '    {\n', '          Transfer(_from, _to, _value);\n', '          return StandardToken.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    //  @des Cofounders issue tokens to themsleves if within vesting period. Returns success.    //\n', '    //  @param beneficiary Address of receiver.                                                  //\n', '    //  @param tokenCount Number of tokens to issue.                                             //\n', '    ///////////////////////////////////////////////////////////////////////////////////////////////\n', '    function issueCofoundersTokensIfPossible()\n', '        onlyCofounders\n', '        CofoundersTokensVested\n', '        returns (bool)\n', '    {\n', '        // Compute total amount of vested tokens to issue\n', '        uint256 tokenCount = cofoundersSupply.div(cofoundersSupplyVestingTranches);\n', '\n', '        // Make sure that there are cofounder tokens left\n', '        if (tokenCount > cofoundersSupplyRemaining) {\n', '           return false;\n', '        }\n', '\n', '        // Decrease cofounders supply\n', '        cofoundersSupplyRemaining = cofoundersSupplyRemaining.sub(tokenCount);\n', '\n', '        // Update how many tokens have been distributed to cofounders\n', '        cofoundersSupplyDistributed = cofoundersSupplyDistributed.add(tokenCount);\n', '\n', '        // Split tokens between both founders\n', '        balances[cofounderA] = balances[cofounderA].add(tokenCount.div(2));\n', '        balances[cofounderB] = balances[cofounderB].add(tokenCount.div(2));\n', '\n', '        // Update that a tranche has been issued\n', '        cofoundersSupplyVestingTranchesIssued += 1;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    //////////////////\n', '    // Issue tokens //\n', '    //////////////////\n', '    function issueTokens(address beneficiary, uint256 tokenCount, DNNSupplyAllocations allocationType)\n', '      onlyAllocatorOrCrowdfundContractOrPlatform\n', '      returns (bool)\n', '    {\n', "        // We'll use the following to determine whether the allocator, platform,\n", '        // or the crowdfunding contract can allocate specified supply\n', '        bool canAllocatorPerform = msg.sender == allocatorAddress;\n', '        bool canCrowdfundContractPerform = msg.sender == crowdfundContract;\n', '        bool canPlatformPerform = msg.sender == platform;\n', '\n', '        // Early Backers\n', '        if (canAllocatorPerform && allocationType == DNNSupplyAllocations.EarlyBackerSupplyAllocation && tokenCount <= earlyBackerSupplyRemaining) {\n', '            earlyBackerSupplyRemaining = earlyBackerSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // PRE-TDE\n', '        else if (canCrowdfundContractPerform && msg.sender == crowdfundContract && allocationType == DNNSupplyAllocations.PRETDESupplyAllocation) {\n', '\n', '              // Check to see if we have enough tokens to satisfy this purchase\n', '              // using just the pre-tde.\n', '              if (PRETDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease pre-tde supply\n', '                    PRETDESupplyRemaining = PRETDESupplyRemaining.sub(tokenCount);\n', '              }\n', '\n', '              // Check to see if we can satisfy this using pre-tde and tde supply combined\n', '              else if (PRETDESupplyRemaining+TDESupplyRemaining >= tokenCount) {\n', '\n', '                    // Decrease tde supply\n', '                    TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount-PRETDESupplyRemaining);\n', '\n', "                    // Decrease pre-tde supply by its' remaining tokens\n", '                    PRETDESupplyRemaining = 0;\n', '              }\n', '\n', "              // Otherwise, we can't satisfy this sale because we don't have enough tokens.\n", '              else {\n', '                  return false;\n', '              }\n', '        }\n', '\n', '        // TDE\n', '        else if (canCrowdfundContractPerform && allocationType == DNNSupplyAllocations.TDESupplyAllocation && tokenCount <= TDESupplyRemaining) {\n', '            TDESupplyRemaining = TDESupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Bounty\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.BountySupplyAllocation && tokenCount <= bountySupplyRemaining) {\n', '            bountySupplyRemaining = bountySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Writer Accounts\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.WriterAccountSupplyAllocation && tokenCount <= writerAccountSupplyRemaining) {\n', '            writerAccountSupplyRemaining = writerAccountSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Advisory\n', '        else if (canAllocatorPerform && allocationType == DNNSupplyAllocations.AdvisorySupplyAllocation && tokenCount <= advisorySupplyRemaining) {\n', '            advisorySupplyRemaining = advisorySupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        // Platform (Also makes sure that the beneficiary is the platform address specified in this contract)\n', '        else if (canPlatformPerform && allocationType == DNNSupplyAllocations.PlatformSupplyAllocation && tokenCount <= platformSupplyRemaining) {\n', '            platformSupplyRemaining = platformSupplyRemaining.sub(tokenCount);\n', '        }\n', '\n', '        else {\n', '            return false;\n', '        }\n', '\n', '        // Transfer tokens\n', '        Transfer(address(this), beneficiary, tokenCount);\n', '\n', '        // Credit tokens to the address specified\n', '        balances[beneficiary] = balances[beneficiary].add(tokenCount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from TDE to Platform //\n', '    /////////////////////////////////////////////////\n', '    function sendUnsoldTDETokensToPlatform()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '        // Make sure we have tokens to send from TDE\n', '        if (TDESupplyRemaining > 0) {\n', '\n', '            // Add remaining tde tokens to platform remaining tokens\n', '            platformSupplyRemaining = platformSupplyRemaining.add(TDESupplyRemaining);\n', '\n', '            // Clear remaining tde token count\n', '            TDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////////////////////////\n', '    // Transfer Unsold tokens from pre-TDE to Platform //\n', '    /////////////////////////////////////////////////////\n', '    function sendUnsoldPRETDETokensToTDE()\n', '      external\n', '      onlyCrowdfundContract\n', '    {\n', '          // Make sure we have tokens to send from pre-TDE\n', '          if (PRETDESupplyRemaining > 0) {\n', '\n', '              // Add remaining pre-tde tokens to tde remaining tokens\n', '              TDESupplyRemaining = TDESupplyRemaining.add(PRETDESupplyRemaining);\n', '\n', '              // Clear remaining pre-tde token count\n', '              PRETDESupplyRemaining = 0;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////\n', '    // @des Allows tokens to be transferrable. Returns lock state //\n', '    ////////////////////////////////////////////////////////////////\n', '    function unlockTokens()\n', '        external\n', '        onlyCrowdfundContract\n', '    {\n', '        // Make sure tokens are currently locked before proceeding to unlock them\n', '        require(tokensLocked == true);\n', '\n', '        tokensLocked = false;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    //  @des Contract constructor function sets initial token balances.  //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function DNNToken()\n', '    {\n', '          // Start date\n', '          uint256 vestingStartDate = 1526072145;\n', '\n', '          // Set cofounder addresses\n', '          cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '          cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '          // Sets platform address\n', '          platform = address(this);\n', '\n', '          // Set total supply - 1 Billion DNN Tokens = (1,000,000,000 * 10^18) atto-DNN\n', '          // 1 DNN = 10^18 atto-DNN\n', '          totalSupply = uint256(1000000000).mul(uint256(10)**decimals);\n', '\n', '          // Set Token Distributions (% of total supply)\n', '          earlyBackerSupply = totalSupply.mul(10).div(100); // 10%\n', '          PRETDESupply = totalSupply.mul(10).div(100); // 10%\n', '          TDESupply = totalSupply.mul(40).div(100); // 40%\n', '          bountySupply = totalSupply.mul(1).div(100); // 1%\n', '          writerAccountSupply = totalSupply.mul(4).div(100); // 4%\n', '          advisorySupply = totalSupply.mul(14).div(100); // 14%\n', '          cofoundersSupply = totalSupply.mul(10).div(100); // 10%\n', '          platformSupply = totalSupply.mul(11).div(100); // 11%\n', '\n', "          // Set each remaining token count equal to its' respective supply\n", '          earlyBackerSupplyRemaining = earlyBackerSupply;\n', '          PRETDESupplyRemaining = PRETDESupply;\n', '          TDESupplyRemaining = TDESupply;\n', '          bountySupplyRemaining = bountySupply;\n', '          writerAccountSupplyRemaining = writerAccountSupply;\n', '          advisorySupplyRemaining = advisorySupply;\n', '          cofoundersSupplyRemaining = cofoundersSupply;\n', '          platformSupplyRemaining = platformSupply;\n', '\n', '          // Sets cofounder vesting start date (Ensures that it is a date in the future, otherwise it will default to now)\n', '          cofoundersSupplyVestingStartDate = vestingStartDate >= now ? vestingStartDate : now;\n', '    }\n', '}\n', '\n', '/// @title DNNTDE contract - Takes funds from users and issues tokens.\n', '/// @author Dondrey Taylor - <dondrey@dnn.media>\n', 'contract DNNTDE {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /////////////////////////\n', '    // DNN Token Contract  //\n', '    /////////////////////////\n', '    DNNToken public dnnToken;\n', '\n', '    //////////////////////////////////////////\n', '    // Addresses of the co-founders of DNN. //\n', '    //////////////////////////////////////////\n', '    address public cofounderA;\n', '    address public cofounderB;\n', '\n', '    ///////////////////////////\n', '    // DNN Holding Multisig //\n', '    //////////////////////////\n', '    address public dnnHoldingMultisig;\n', '\n', '    ///////////////////////////\n', '    // Start date of the TDE //\n', '    ///////////////////////////\n', '    uint256 public TDEStartDate;  // Epoch\n', '\n', '    /////////////////////////\n', '    // End date of the TDE //\n', '    /////////////////////////\n', '    uint256 public TDEEndDate;  // Epoch\n', '\n', '    /////////////////////////////////\n', '    // Amount of atto-DNN per wei //\n', '    /////////////////////////////////\n', '    uint256 public tokenExchangeRateBase = 3000; // 1 Wei = 3000 atto-DNN\n', '\n', '    /////////////////////////////////////////////////\n', '    // Number of tokens distributed (in atto-DNN) //\n', '    /////////////////////////////////////////////////\n', '    uint256 public tokensDistributed = 0;\n', '\n', '    ///////////////////////////////////////////////\n', '    // Minumum Contributions for pre-TDE and TDE //\n', '    ///////////////////////////////////////////////\n', '    uint256 public minimumTDEContributionInWei = 0.001 ether;\n', '    uint256 public minimumPRETDEContributionInWei = 5 ether;\n', '\n', '    //////////////////////\n', '    // Funding Hard cap //\n', '    //////////////////////\n', '    uint256 public maximumFundingGoalInETH;\n', '\n', '    //////////////////\n', '    // Funds Raised //\n', '    //////////////////\n', '    uint256 public fundsRaisedInWei = 0;\n', '    uint256 public presaleFundsRaisedInWei = 0;\n', '    uint256 public tdeFundsRaisedInWei = 0;\n', '\n', '    ////////////////////////////////////////////\n', '    // Keep track of Wei contributed per user //\n', '    ////////////////////////////////////////////\n', '    mapping(address => uint256) ETHContributions;\n', '\n', '    ////////////////////////////////////////////////\n', '    // Keeps track of tokens per eth contribution //\n', '    ////////////////////////////////////////////////\n', '    mapping(address => uint256) ETHContributorTokens;\n', '\n', '\n', '    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    // Keeps track of pre-tde contributors and how many tokens they are entitled to get based on their contribution //\n', '    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '    mapping(address => uint256) PRETDEContributorTokensPendingRelease;\n', '    uint256 PRETDEContributorsTokensPendingCount = 0; // keep track of contributors waiting for tokens\n', '    uint256 TokensPurchasedDuringPRETDE = 0; // keep track of how many tokens need to be issued to presale contributors\n', '\n', '\n', '    //////////////////\n', '    // Bonus ranges //\n', '    //////////////////\n', '    bool public trickleDownBonusesReleased = false;\n', '    uint256 public rangeETHAmount = 0;\n', '    uint256 public bonusRangeCount = 4;\n', '\n', '    uint256 public TDEContributorCount = 0;\n', '    mapping(uint256 => address) public TDEContributorAddresses;\n', '    mapping(address => uint256) public TDEContributorInitialBonusByAddress;\n', '\n', '    uint256 public tokensIssuedForBonusRangeOne    = 0;\n', '    uint256 public tokensIssuedForBonusRangeTwo    = 0;\n', '    uint256 public tokensIssuedForBonusRangeThree  = 0;\n', '    uint256 public tokensIssuedForBonusRangeFour   = 0;\n', '\n', '    //////////////////////////////////////////////////////\n', '    // Checks if trickle down bonuses not been released //\n', '    //////////////////////////////////////////////////////\n', '    modifier HasTrickleDownBonusesNotBeenReleased() {\n', '        require (trickleDownBonusesReleased == false);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////\n', '    // Checks if all pre-tde contributors have received their tokens //\n', '    ///////////////////////////////////////////////////////////////////\n', '    modifier NoPRETDEContributorsAwaitingTokens() {\n', '        // Determine if all pre-tde contributors have received tokens\n', '        require(PRETDEContributorsTokensPendingCount == 0);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////////////////////\n', '    // Checks if there are any pre-tde contributors that have not recieved their tokens  //\n', '    ///////////////////////////////////////////////////////////////////////////////////////\n', '    modifier PRETDEContributorsAwaitingTokens() {\n', '\n', '        // Determine if there pre-tde contributors that have not received tokens\n', '        require(PRETDEContributorsTokensPendingCount > 0);\n', '\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounders are performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounders() {\n', '        require (msg.sender == cofounderA || msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder A is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderA() {\n', '        require (msg.sender == cofounderA);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////\n', '    // Checks if CoFounder B is performing the action //\n', '    ////////////////////////////////////////////////////\n', '    modifier onlyCofounderB() {\n', '        require (msg.sender == cofounderB);\n', '        _;\n', '    }\n', '\n', '    ////////////////////////////////s\n', '    // Check if the tde has ended //\n', '    ////////////////////////////////\n', '    modifier TDEHasEnded() {\n', '       require (now >= TDEEndDate || fundsRaisedInWei >= maximumFundingGoalInETH);\n', '       _;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////////\n', '    // Checksto see if the contribution is at least the minimum allowed for tde //\n', '    //////////////////////////////////////////////////////////////////////////////\n', '    modifier ContributionIsAtLeastMinimum() {\n', '        require (msg.value >= minimumTDEContributionInWei);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // Make sure max cap is not exceeded with added contribution //\n', '    ///////////////////////////////////////////////////////////////\n', '    modifier ContributionDoesNotCauseGoalExceedance() {\n', '       uint256 newFundsRaised = msg.value+fundsRaisedInWei;\n', '       require (newFundsRaised <= maximumFundingGoalInETH);\n', '       _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // Make sure max tokens is not exceeded with added contribution //\n', '    ///////////////////////////////////////////////////////////////\n', '    modifier TDEBonusesDoesNotCauseTokenExceedance() {\n', '       uint256 tokensDistributedPlusBonuses = getTokensDistributedPlusTrickleDownBonuses();\n', '       require (tokensDistributedPlusBonuses < dnnToken.TDESupplyRemaining());\n', '       _;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////////\n', '    // Check if the specified beneficiary has sent us funds before //\n', '    /////////////////////////////////////////////////////////////////\n', '    modifier HasPendingPRETDETokens(address _contributor) {\n', '        require (PRETDEContributorTokensPendingRelease[_contributor] !=  0);\n', '        _;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////\n', '    // Check if pre-tde contributors is not waiting for tokens //\n', '    /////////////////////////////////////////////////////////////\n', '    modifier IsNotAwaitingPRETDETokens(address _contributor) {\n', '        require (PRETDEContributorTokensPendingRelease[_contributor] ==  0);\n', '        _;\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////\n', '    //  @des Function to change founder A address.       //\n', '    //  @param newAddress Address of new founder A.      //\n', '    ///////////////////////////////////////////////////////\n', '    function changeCofounderA(address newAddress)\n', '        onlyCofounderA\n', '    {\n', '        cofounderA = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change founder B address.      //\n', '    //  @param newAddress Address of new founder B.     //\n', '    //////////////////////////////////////////////////////\n', '    function changeCofounderB(address newAddress)\n', '        onlyCofounderB\n', '    {\n', '        cofounderB = newAddress;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////\n', '    //  @des Tokens distributed plus trickle down bonuses. //\n', '    /////////////////////////////////////////////////////////\n', '    function getTokensDistributedPlusTrickleDownBonuses()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return tokensIssuedForBonusRangeOne.mul(220).div(100) + tokensIssuedForBonusRangeTwo.mul(190).div(100) + tokensIssuedForBonusRangeThree.mul(150).div(100) + tokensIssuedForBonusRangeFour.mul(100).div(100);\n', '    }\n', '\n', '    ////////////////////////////////////////\n', '    //  @des Function to extend tde       //\n', '    //  @param new crowdsale start date   //\n', '    ////////////////////////////////////////\n', '    function extendTDE(uint256 endDate)\n', '        onlyCofounders\n', '        returns (bool)\n', '    {\n', '        // Make sure that the new date is past the existing date and\n', '        // is not in the past.\n', '        if (endDate > now && endDate > TDEEndDate) {\n', '            TDEEndDate = endDate;\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    ////////////////////////////////////////\n', '    //  @des Function to extend pre-tde   //\n', '    //  @param new crowdsale start date   //\n', '    ////////////////////////////////////////\n', '    function extendPRETDE(uint256 startDate)\n', '        onlyCofounders\n', '        returns (bool)\n', '    {\n', '        // Make sure that the new date is past the existing date and\n', '        // is not in the past.\n', '        if (startDate > now && startDate > TDEStartDate) {\n', '            TDEEndDate = TDEEndDate + (startDate-TDEStartDate); // Move end date the same amount of days as start date\n', '            TDEStartDate = startDate; // set new start date\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    //////////////////////////////////////////////////////\n', '    //  @des Function to change multisig address.       //\n', '    //  @param newAddress Address of new multisig.      //\n', '    //////////////////////////////////////////////////////\n', '    function changeDNNHoldingMultisig(address newAddress)\n', '        onlyCofounders\n', '    {\n', '        dnnHoldingMultisig = newAddress;\n', '    }\n', '\n', '    //////////////////////////////////////////\n', '    // @des ETH balance of each contributor //\n', '    //////////////////////////////////////////\n', '    function contributorETHBalance(address _owner)\n', '      constant\n', '      returns (uint256 balance)\n', '    {\n', '        return ETHContributions[_owner];\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////\n', '    // @des Determines if an address is a pre-TDE contributor //\n', '    ////////////////////////////////////////////////////////////\n', '    function isAwaitingPRETDETokens(address _contributorAddress)\n', '       internal\n', '       returns (bool)\n', '    {\n', '        return PRETDEContributorTokensPendingRelease[_contributorAddress] > 0;\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////////\n', '    // @des Returns pending presale tokens for a given address //\n', '    /////////////////////////////////////////////////////////////\n', '    function getPendingPresaleTokens(address _contributor)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return PRETDEContributorTokensPendingRelease[_contributor];\n', '    }\n', '\n', '    ////////////////////////////////\n', '    // @des Returns current bonus //\n', '    ////////////////////////////////\n', '    function getCurrentTDEBonus()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return getTDETokenExchangeRate(now);\n', '    }\n', '\n', '\n', '    ////////////////////////////////\n', '    // @des Returns current bonus //\n', '    ////////////////////////////////\n', '    function getCurrentPRETDEBonus()\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        return getPRETDETokenExchangeRate(now);\n', '    }\n', '\n', '    ///////////////////////////////////////////////////////////////////////\n', '    // @des Returns bonus (in atto-DNN) per wei for the specific moment //\n', '    // @param timestamp Time of purchase (in seconds)                    //\n', '    ///////////////////////////////////////////////////////////////////////\n', '    function getTDETokenExchangeRate(uint256 timestamp)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // No bonus - TDE ended\n', '        if (timestamp > TDEEndDate) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // No bonus - TDE has not started\n', '        if (TDEStartDate > timestamp) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // Bonus One --> 0 - 25% of raise\n', '        if (tdeFundsRaisedInWei <= rangeETHAmount) {\n', '            return tokenExchangeRateBase.mul(120).div(100);\n', '        }\n', '        // Bonus Two --> 25% - 50% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '            return tokenExchangeRateBase.mul(130).div(100);\n', '        }\n', '        // Bonus Three --> 50% - 75% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '            return tokenExchangeRateBase.mul(140).div(100);\n', '        }\n', '        // Bonus Four --> 75% - 100% of raise\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(3) && tdeFundsRaisedInWei <= maximumFundingGoalInETH) {\n', '            return tokenExchangeRateBase.mul(150).div(100);\n', '        }\n', '        else {\n', '            return tokenExchangeRateBase;\n', '        }\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Returns bonus (in atto-DNN) per wei for the specific contribution amount //\n', '    // @param weiamount The amount of wei being contributed                           //\n', '    ////////////////////////////////////////////////////////////////////////////////////\n', '    function getPRETDETokenExchangeRate(uint256 weiamount)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // Presale will only accept contributions above minimum\n', '        if (weiamount < minimumPRETDEContributionInWei) {\n', '            return uint256(0);\n', '        }\n', '\n', '        // Minimum Contribution - 199 ETH (25% Bonus)\n', '        if (weiamount >= minimumPRETDEContributionInWei && weiamount <= 199 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(25).div(100);\n', '\n', '        // 200 ETH - 300 ETH Bonus (30% Bonus)\n', '        } else if (weiamount >= 200 ether && weiamount <= 300 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(30).div(100);\n', '\n', '        // 301 ETH - 2665 ETH Bonus (35% Bonus)\n', '        } else if (weiamount >= 301 ether && weiamount <= 2665 ether) {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(35).div(100);\n', '\n', '        // 2666+ ETH Bonus (50% Bonus)\n', '        } else {\n', '            return tokenExchangeRateBase + tokenExchangeRateBase.mul(50).div(100);\n', '        }\n', '    }\n', '\n', '    //////////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Computes how many tokens a buyer is entitled to based on contribution and time. //\n', '    //////////////////////////////////////////////////////////////////////////////////////////\n', '    function calculateTokens(uint256 weiamount, uint256 timestamp)\n', '        constant\n', '        returns (uint256)\n', '    {\n', '        // Compute how many atto-DNN user is entitled to.\n', '        uint256 computedTokensForPurchase = weiamount.mul(timestamp >= TDEStartDate ? getTDETokenExchangeRate(timestamp) : getPRETDETokenExchangeRate(weiamount));\n', '\n', '        // Amount of atto-DNN to issue\n', '        return computedTokensForPurchase;\n', '     }\n', '\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // @des Issues tokens for users who made purchase with ETH   //\n', '    // @param beneficiary Address the tokens will be issued to.  //\n', '    // @param weiamount ETH amount (in Wei)                      //\n', '    // @param timestamp Time of purchase (in seconds)            //\n', '    ///////////////////////////////////////////////////////////////\n', '    function buyTokens()\n', '        internal\n', '        ContributionIsAtLeastMinimum\n', '        ContributionDoesNotCauseGoalExceedance\n', '        TDEBonusesDoesNotCauseTokenExceedance\n', '        returns (bool)\n', '    {\n', '        // Determine how many tokens should be issued\n', '        uint256 tokenCount = calculateTokens(msg.value, now);\n', '\n', '         // Bonus Four\n', '        if (tdeFundsRaisedInWei > rangeETHAmount.mul(3) && tdeFundsRaisedInWei <= maximumFundingGoalInETH) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = tdeFundsRaisedInWei;\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus Three\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount.mul(3);\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus Two\n', '        else if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount.mul(2);\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '        // Bonus One\n', '        else if (tdeFundsRaisedInWei <= rangeETHAmount) {\n', '            if (TDEContributorInitialBonusByAddress[msg.sender] == 0) {\n', '                TDEContributorInitialBonusByAddress[msg.sender] = rangeETHAmount;\n', '                TDEContributorAddresses[TDEContributorCount] = msg.sender;\n', '                TDEContributorCount++;\n', '            }\n', '        }\n', '\n', '        // Keep track of tokens issued within each range\n', '        // Bonus Four\n', '        if (TDEContributorInitialBonusByAddress[msg.sender] == tdeFundsRaisedInWei) {\n', '            tokensIssuedForBonusRangeFour = tokensIssuedForBonusRangeFour.add(tokenCount);\n', '        }\n', '        // Bonus Three\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount.mul(3)) {\n', '            tokensIssuedForBonusRangeThree = tokensIssuedForBonusRangeThree.add(tokenCount);\n', '        }\n', '        // Bonus Two\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount.mul(2)) {\n', '            tokensIssuedForBonusRangeTwo = tokensIssuedForBonusRangeTwo.add(tokenCount);\n', '        }\n', '        // Bonus One\n', '        else if (TDEContributorInitialBonusByAddress[msg.sender] == rangeETHAmount) {\n', '            tokensIssuedForBonusRangeOne = tokensIssuedForBonusRangeOne.add(tokenCount);\n', '        }\n', '\n', '        // Get total tokens distributed plus bonuses\n', '        uint256 tokensDistributedPlusBonuses = getTokensDistributedPlusTrickleDownBonuses();\n', '\n', '        // Make sure we have enough tokens to satisfy the transaction\n', '        if (tokensDistributedPlusBonuses > dnnToken.TDESupplyRemaining()) {\n', '            revert();\n', '        }\n', '\n', '        // Update total amount of tokens distributed (in atto-DNN)\n', '        tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '        // Keep track of contributions (in Wei)\n', '        ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\n', '\n', '        // Keep track of how much tokens are issued to each contributor\n', '        ETHContributorTokens[msg.sender] = ETHContributorTokens[msg.sender].add(tokenCount);\n', '\n', '        // Increase total funds raised by contribution\n', '        fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\n', '\n', '        // Increase tde total funds raised by contribution\n', '        tdeFundsRaisedInWei = tdeFundsRaisedInWei.add(msg.value);\n', '\n', '        // Determine which token allocation we should be deducting from\n', '        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '        // Attempt to issue tokens to contributor\n', '        if (!dnnToken.issueTokens(msg.sender, tokenCount, allocationType)) {\n', '            revert();\n', '        }\n', '\n', '        // Transfer funds to multisig\n', '        dnnHoldingMultisig.transfer(msg.value);\n', '\n', '        return true;\n', '    }\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////////////\n', '    // @des Issues tokens for users who made purchase without using ETH during presale.   //\n', '    // @param beneficiary Address the tokens will be issued to.                           //\n', '    // @param weiamount ETH amount (in Wei)                                               //\n', '    ////////////////////////////////////////////////////////////////////////////////////////\n', '    function buyPRETDETokensWithoutETH(address beneficiary, uint256 weiamount, uint256 tokenCount)\n', '        onlyCofounders\n', '        IsNotAwaitingPRETDETokens(beneficiary)\n', '        returns (bool)\n', '    {\n', '\n', '          // Keep track of how much tokens are issued to each contributor\n', '          ETHContributorTokens[beneficiary] = ETHContributorTokens[beneficiary].add(tokenCount);\n', '\n', '          // Keep track of contributions (in Wei)\n', '          ETHContributions[beneficiary] = ETHContributions[beneficiary].add(weiamount);\n', '\n', '          // Increase total funds raised by contribution\n', '          fundsRaisedInWei = fundsRaisedInWei.add(weiamount);\n', '\n', '          // Keep track of presale funds in addition, separately\n', '          presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(weiamount);\n', '\n', '          // Add these tokens to the total amount of tokens this contributor is entitled to\n', '          PRETDEContributorTokensPendingRelease[beneficiary] = PRETDEContributorTokensPendingRelease[beneficiary].add(tokenCount);\n', '\n', '          // Incrment number of pre-tde contributors waiting for tokens\n', '          PRETDEContributorsTokensPendingCount += 1;\n', '\n', '          // Send tokens to contibutor\n', '          return issuePRETDETokens(beneficiary);\n', '      }\n', '\n', '      ////////////////////////////////////////////////////////////////////////////////////////////\n', '      // @des Issues tokens for users who made purchase without using ETH during public sale.   //\n', '      // @param beneficiary Address the tokens will be issued to.                               //\n', '      // @param weiamount ETH amount (in Wei)                                                   //\n', '      ////////////////////////////////////////////////////////////////////////////////////////////\n', '      function buyTDETokensWithoutETH(address beneficiary, uint256 weiamount, uint256 tokenCount)\n', '          onlyCofounders\n', '          returns (bool)\n', '      {\n', '            // Get total tokens distributed plus bonuses\n', '            uint256 tokensDistributedPlusBonuses = tokenCount.add(getTokensDistributedPlusTrickleDownBonuses());\n', '\n', '            // Make sure we have enough tokens to satisfy the transaction\n', '            if (tokensDistributedPlusBonuses > dnnToken.TDESupplyRemaining()) {\n', '                revert();\n', '            }\n', '\n', '            // Keep track of how much tokens are issued to each contributor\n', '            ETHContributorTokens[beneficiary] = ETHContributorTokens[beneficiary].add(tokenCount);\n', '\n', '            // Keep track of contributions (in Wei)\n', '            ETHContributions[beneficiary] = ETHContributions[beneficiary].add(weiamount);\n', '\n', '            // Increase total funds raised by contribution\n', '            fundsRaisedInWei = fundsRaisedInWei.add(weiamount);\n', '\n', '            // Keep track of tde funds in addition, separately\n', '            tdeFundsRaisedInWei = tdeFundsRaisedInWei.add(weiamount);\n', '\n', '            // Send tokens to contibutor\n', '            return issueTDETokens(beneficiary, tokenCount);\n', '        }\n', '\n', '      ///////////////////////////////////////////////////////////////\n', '      // @des Issues bulk token purchases                          //\n', '      // @param beneficiary Address the tokens will be issued to.  //\n', '      ///////////////////////////////////////////////////////////////\n', '      function issueTDETokens(address beneficiary, uint256 tokenCount)\n', '          internal\n', '          returns (bool)\n', '      {\n', '\n', '          // Update total amount of tokens distributed (in atto-DNN)\n', '          tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '          // Allocation type will be PRETDESupplyAllocation\n', '          DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '          // Attempt to issue tokens\n', '          if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\n', '              revert();\n', '          }\n', '\n', '          return true;\n', '      }\n', '\n', '    ///////////////////////////////////////////////////////////////\n', '    // @des Issues pending tokens to pre-tde contributor         //\n', '    // @param beneficiary Address the tokens will be issued to.  //\n', '    ///////////////////////////////////////////////////////////////\n', '    function issuePRETDETokens(address beneficiary)\n', '        onlyCofounders\n', '        PRETDEContributorsAwaitingTokens\n', '        HasPendingPRETDETokens(beneficiary)\n', '        returns (bool)\n', '    {\n', '        // Amount of tokens to credit pre-tde contributor\n', '        uint256 tokenCount = PRETDEContributorTokensPendingRelease[beneficiary];\n', '\n', '        // Update total amount of tokens distributed (in atto-DNN)\n', '        tokensDistributed = tokensDistributed.add(tokenCount);\n', '\n', '        // Allocation type will be PRETDESupplyAllocation\n', '        DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.PRETDESupplyAllocation;\n', '\n', '        // Attempt to issue tokens\n', '        if (!dnnToken.issueTokens(beneficiary, tokenCount, allocationType)) {\n', '            revert();\n', '        }\n', '\n', '        // Reduce number of pre-tde contributors waiting for tokens\n', '        PRETDEContributorsTokensPendingCount -= 1;\n', '\n', '        // Denote that tokens have been issued for this pre-tde contributor\n', '        PRETDEContributorTokensPendingRelease[beneficiary] = 0;\n', '\n', '        return true;\n', '    }\n', '\n', '    /////////////////////////////////////\n', '    // @des Issue trickle down bonuses //\n', '    /////////////////////////////////////\n', '    function releaseTrickleDownBonuses()\n', '      onlyCofounders\n', '    {\n', '        // Issue trickle down bonuses if we have not already done so\n', '        if (trickleDownBonusesReleased == false) {\n', '\n', '            // Determine which token allocation we should be deducting from\n', '            DNNToken.DNNSupplyAllocations allocationType = DNNToken.DNNSupplyAllocations.TDESupplyAllocation;\n', '\n', '            // Temporary reference to contribution\n', '            address contributorAddress;\n', '\n', '            // Temporary reference to contributor bonus tokens\n', '            uint256 bonusTokens;\n', '\n', '            // Iterate through contributors\n', '            for (uint256 iteration=0; iteration < TDEContributorCount; iteration++) {\n', '\n', '                // No bonus tokens to issue until contribute range and funds raised\n', '                // are determined.\n', '                bonusTokens = 0;\n', '\n', '                // If we have at least reached the bonus 2 range, issue bonuses to everyone in bonus 1\n', '                if (tdeFundsRaisedInWei > rangeETHAmount && tdeFundsRaisedInWei <= rangeETHAmount.mul(2)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(130).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '\n', '                // If we have at least reached the bonus 3 range, issue bonuses to everyone in bonus 1 & 2\n', '                else if (tdeFundsRaisedInWei > rangeETHAmount.mul(2) && tdeFundsRaisedInWei <= rangeETHAmount.mul(3)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 and range 3 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(170).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(2)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(140).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '\n', '                // If we have at least reached the bonus 4 range, issue bonuses to everyone in bonus 1, 2, & 3\n', '                else if (tdeFundsRaisedInWei > rangeETHAmount.mul(3)) {\n', '\n', '                    // Contributor address to send tokens to\n', '                    contributorAddress = TDEContributorAddresses[iteration];\n', '\n', '                    // Issue a range 2 and range 3 bonus if the contributor was in range 1\n', '                    if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(220).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(2)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(190).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '                    // Issue a range 3 bonus if the contributor was in range 2\n', '                    else if (TDEContributorInitialBonusByAddress[contributorAddress] == rangeETHAmount.mul(3)) {\n', '                        bonusTokens = ETHContributorTokens[contributorAddress].mul(150).div(100).sub(ETHContributorTokens[contributorAddress]);\n', '                    }\n', '\n', '                    // Issue tokens to contributor address if bonus applies\n', '                    if (bonusTokens > 0 && !dnnToken.issueTokens(contributorAddress, bonusTokens, allocationType)) {\n', '                        revert();\n', '                    }\n', '                }\n', '            }\n', '\n', '            // Mark down that bonuses have been released\n', '            trickleDownBonusesReleased = true;\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////\n', '    // @des Marks TDE as completed //\n', '    /////////////////////////////////\n', '    function finalizeTDE()\n', '       onlyCofounders\n', '       TDEHasEnded\n', '    {\n', '        // Check if the tokens are locked and all pre-sale tokens have been\n', '        // transferred to the TDE Supply before unlocking tokens.\n', '        require(dnnToken.tokensLocked() == true && dnnToken.PRETDESupplyRemaining() == 0);\n', '\n', '        // Release Bonuses\n', '        releaseTrickleDownBonuses();\n', '\n', '        // Unlock tokens\n', '        dnnToken.unlockTokens();\n', '\n', '        // Update tokens distributed\n', '        tokensDistributed += dnnToken.TDESupplyRemaining();\n', '\n', '        // Transfer unsold TDE tokens to platform\n', '        dnnToken.sendUnsoldTDETokensToPlatform();\n', '    }\n', '\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    // @des Marks pre-TDE as completed by moving remaining tokens into TDE supply //\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    function finalizePRETDE()\n', '       onlyCofounders\n', '       NoPRETDEContributorsAwaitingTokens\n', '    {\n', '        // Check if we have tokens to transfer to TDE\n', '        require(dnnToken.PRETDESupplyRemaining() > 0);\n', '\n', '        // Transfer unsold TDE tokens to platform\n', '        dnnToken.sendUnsoldPRETDETokensToTDE();\n', '    }\n', '\n', '\n', '    ///////////////////////////////\n', '    // @des Contract constructor /xw/\n', '    ///////////////////////////////\n', '    function DNNTDE()\n', '    {\n', '        // Hard Cap\n', '        uint256 hardCap = 35000;\n', '\n', '        // Set token address\n', '        dnnToken = DNNToken(0x9D9832d1beb29CC949d75D61415FD00279f84Dc2);\n', '\n', '        // Set cofounder addresses\n', '        cofounderA = 0x3Cf26a9FE33C219dB87c2e50572e50803eFb2981;\n', '        cofounderB = 0x9FFE2aD5D76954C7C25be0cEE30795279c4Cab9f;\n', '\n', '        // Set DNN holding address\n', '        dnnHoldingMultisig = 0x5980a47514a0Af79a8d2F6276f8673a006ec9929;\n', '\n', '        // Set hard cap\n', '        maximumFundingGoalInETH = hardCap * 1 ether;\n', '\n', '        // Range ETH\n', '        rangeETHAmount = hardCap.div(bonusRangeCount) * 1 ether;\n', '\n', '        // Set Start Date\n', '        TDEStartDate = 1529020801;\n', '\n', '        // Set End date (Make sure the end date is at least 30 days from start date)\n', '        // Will default to a date that is exactly 30 days from start date.\n', '        TDEEndDate = (TDEStartDate + 35 days);\n', '    }\n', '\n', '    /////////////////////////////////////////////////////////\n', "    // @des Handle's ETH sent directly to contract address //\n", '    /////////////////////////////////////////////////////////\n', '    function () payable {\n', '\n', '        // Handle pre-sale contribution (tokens held, until tx confirmation from contributor)\n', '        // Makes sure the user sends minimum PRE-TDE contribution, and that  pre-tde contributors\n', '        // are unable to send subsequent ETH contributors before being issued tokens.\n', '        if (now < TDEStartDate && msg.value >= minimumPRETDEContributionInWei && PRETDEContributorTokensPendingRelease[msg.sender] == 0) {\n', '\n', '            // Keep track of contributions (in Wei)\n', '            ETHContributions[msg.sender] = ETHContributions[msg.sender].add(msg.value);\n', '\n', '            // Increase total funds raised by contribution\n', '            fundsRaisedInWei = fundsRaisedInWei.add(msg.value);\n', '\n', '            // Keep track of presale funds in addition, separately\n', '            presaleFundsRaisedInWei = presaleFundsRaisedInWei.add(msg.value);\n', '\n', '            /// Make a note of how many tokens this user should get for their contribution to the presale\n', '            PRETDEContributorTokensPendingRelease[msg.sender] = PRETDEContributorTokensPendingRelease[msg.sender].add(calculateTokens(msg.value, now));\n', '\n', '            // Keep track of pending tokens\n', '            TokensPurchasedDuringPRETDE += calculateTokens(msg.value, now);\n', '\n', '            // Increment number of pre-tde contributors waiting for tokens\n', '            PRETDEContributorsTokensPendingCount += 1;\n', '\n', '            // Prevent contributions that will cause us to have a shortage of tokens during the pre-sale\n', '            if (TokensPurchasedDuringPRETDE > dnnToken.TDESupplyRemaining()+dnnToken.PRETDESupplyRemaining()) {\n', '                revert();\n', '            }\n', '\n', '            // Transfer contribution directly to multisig\n', '            dnnHoldingMultisig.transfer(msg.value);\n', '        }\n', '\n', '        // Handle public-sale contribution (tokens issued immediately)\n', '        else if (now >= TDEStartDate && now < TDEEndDate) buyTokens();\n', '\n', '        // Otherwise, reject the contribution\n', '        else revert();\n', '    }\n', '}']
