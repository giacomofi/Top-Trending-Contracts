['/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint256 _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint256 _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint256 oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', " * functions, this simplifies the implementation of 'user permissions'.\n", ' */\n', '\n', '/// @title Ownable\n', '/// @author Applicature\n', '/// @notice helper mixed to other contracts to link contract on an owner\n', '/// @dev Base class\n', 'contract Ownable {\n', '    //Variables\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    //    Modifiers\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param _newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0));\n', '        newOwner = _newOwner;\n', '\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '/**\n', ' * @title TokenVesting\n', ' * @dev A token holder contract that can release its token balance gradually like a\n', ' * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\n', ' * owner.\n', ' */\n', 'contract TokenVesting is Ownable {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for ERC20Basic;\n', '\n', '  event Released(uint256 amount);\n', '  event Revoked();\n', '\n', '  // beneficiary of tokens after they are released\n', '  address public beneficiary;\n', '\n', '  uint256 public cliff;\n', '  uint256 public start;\n', '  uint256 public duration;\n', '\n', '  bool public revocable;\n', '\n', '  mapping (address => uint256) public released;\n', '  mapping (address => bool) public revoked;\n', '\n', '  /**\n', '   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\n', '   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\n', '   * of the balance will have vested.\n', '   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\n', '   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\n', '   * @param _start the time (as Unix time) at which point vesting starts \n', '   * @param _duration duration in seconds of the period in which the tokens will vest\n', '   * @param _revocable whether the vesting is revocable or not\n', '   */\n', '  constructor(\n', '    address _beneficiary,\n', '    uint256 _start,\n', '    uint256 _cliff,\n', '    uint256 _duration,\n', '    bool _revocable\n', '  )\n', '    public\n', '  {\n', '    require(_beneficiary != address(0));\n', '    require(_cliff <= _duration);\n', '\n', '    beneficiary = _beneficiary;\n', '    revocable = _revocable;\n', '    duration = _duration;\n', '    cliff = _start.add(_cliff);\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers vested tokens to beneficiary.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function release(ERC20Basic token) public {\n', '    uint256 unreleased = releasableAmount(token);\n', '\n', '    require(unreleased > 0);\n', '\n', '    released[token] = released[token].add(unreleased);\n', '\n', '    token.safeTransfer(beneficiary, unreleased);\n', '\n', '    emit Released(unreleased);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the owner to revoke the vesting. Tokens already vested\n', '   * remain in the contract, the rest are returned to the owner.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function revoke(ERC20Basic token) public onlyOwner {\n', '    require(revocable);\n', '    require(!revoked[token]);\n', '\n', '    uint256 balance = token.balanceOf(this);\n', '\n', '    uint256 unreleased = releasableAmount(token);\n', '    uint256 refund = balance.sub(unreleased);\n', '\n', '    revoked[token] = true;\n', '\n', '    token.safeTransfer(owner, refund);\n', '\n', '    emit Revoked();\n', '  }\n', '\n', '  /**\n', "   * @dev Calculates the amount that has already vested but hasn't been released yet.\n", '   * @param token ERC20 token which is being vested\n', '   */\n', '  function releasableAmount(ERC20Basic token) public view returns (uint256) {\n', '    return vestedAmount(token).sub(released[token]);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the amount that has already vested.\n', '   * @param token ERC20 token which is being vested\n', '   */\n', '  function vestedAmount(ERC20Basic token) public view returns (uint256) {\n', '    uint256 currentBalance = token.balanceOf(this);\n', '    uint256 totalBalance = currentBalance.add(released[token]);\n', '\n', '    if (block.timestamp < cliff) {\n', '      return 0;\n', '    } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n', '      return totalBalance;\n', '    } else {\n', '      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n', '    }\n', '  }\n', '}\n', '/// @title OpenZeppelinERC20\n', '/// @author Applicature\n', '/// @notice Open Zeppelin implementation of standart ERC20\n', '/// @dev Base class\n', 'contract OpenZeppelinERC20 is StandardToken, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    uint8 public decimals;\n', '    string public name;\n', '    string public symbol;\n', '    string public standard;\n', '\n', '    constructor(\n', '        uint256 _totalSupply,\n', '        string _tokenName,\n', '        uint8 _decimals,\n', '        string _tokenSymbol,\n', '        bool _transferAllSupplyToOwner\n', '    ) public {\n', "        standard = 'ERC20 0.1';\n", '        totalSupply_ = _totalSupply;\n', '\n', '        if (_transferAllSupplyToOwner) {\n', '            balances[msg.sender] = _totalSupply;\n', '        } else {\n', '            balances[this] = _totalSupply;\n', '        }\n', '\n', '        name = _tokenName;\n', '        // Set the name for display purposes\n', '        symbol = _tokenSymbol;\n', '        // Set the symbol for display purposes\n', '        decimals = _decimals;\n', '    }\n', '\n', '}\n', '/// @title MintableToken\n', '/// @author Applicature\n', '/// @notice allow to mint tokens\n', '/// @dev Base class\n', 'contract MintableToken is BasicToken, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public maxSupply;\n', '    bool public allowedMinting;\n', '    mapping(address => bool) public mintingAgents;\n', '    mapping(address => bool) public stateChangeAgents;\n', '\n', '    event Mint(address indexed holder, uint256 tokens);\n', '\n', '    modifier onlyMintingAgents () {\n', '        require(mintingAgents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyStateChangeAgents () {\n', '        require(stateChangeAgents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    constructor(uint256 _maxSupply, uint256 _mintedSupply, bool _allowedMinting) public {\n', '        maxSupply = _maxSupply;\n', '        totalSupply_ = totalSupply_.add(_mintedSupply);\n', '        allowedMinting = _allowedMinting;\n', '        mintingAgents[msg.sender] = true;\n', '    }\n', '\n', '    /// @notice allow to mint tokens\n', '    function mint(address _holder, uint256 _tokens) public onlyMintingAgents() {\n', '        require(allowedMinting == true && totalSupply_.add(_tokens) <= maxSupply);\n', '\n', '        totalSupply_ = totalSupply_.add(_tokens);\n', '\n', '        balances[_holder] = balances[_holder].add(_tokens);\n', '\n', '        if (totalSupply_ == maxSupply) {\n', '            allowedMinting = false;\n', '        }\n', '        emit Transfer(address(0), _holder, _tokens);\n', '        emit Mint(_holder, _tokens);\n', '    }\n', '\n', '    /// @notice update allowedMinting flat\n', '    function disableMinting() public onlyStateChangeAgents() {\n', '        allowedMinting = false;\n', '    }\n', '\n', '    /// @notice update minting agent\n', '    function updateMintingAgent(address _agent, bool _status) public onlyOwner {\n', '        mintingAgents[_agent] = _status;\n', '    }\n', '\n', '    /// @notice update state change agent\n', '    function updateStateChangeAgent(address _agent, bool _status) public onlyOwner {\n', '        stateChangeAgents[_agent] = _status;\n', '    }\n', '\n', '    /// @return available tokens\n', '    function availableTokens() public view returns (uint256 tokens) {\n', '        return maxSupply.sub(totalSupply_);\n', '    }\n', '}\n', '/**\n', ' * @title Burnable Token\n', ' * @dev Token that can be irreversibly burned (destroyed).\n', ' */\n', 'contract BurnableToken is BasicToken {\n', '\n', '  event Burn(address indexed burner, uint256 value);\n', '\n', '  /**\n', '   * @dev Burns a specific amount of tokens.\n', '   * @param _value The amount of token to be burned.\n', '   */\n', '  function burn(uint256 _value) public {\n', '    _burn(msg.sender, _value);\n', '  }\n', '\n', '  function _burn(address _who, uint256 _value) internal {\n', '    require(_value <= balances[_who]);\n', '    // no need to require value <= totalSupply, since that would imply the\n', "    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n", '\n', '    balances[_who] = balances[_who].sub(_value);\n', '    totalSupply_ = totalSupply_.sub(_value);\n', '    emit Burn(_who, _value);\n', '    emit Transfer(_who, address(0), _value);\n', '  }\n', '}\n', '/// @title MintableBurnableToken\n', '/// @author Applicature\n', '/// @notice helper mixed to other contracts to burn tokens\n', '/// @dev implementation\n', 'contract MintableBurnableToken is MintableToken, BurnableToken {\n', '\n', '    mapping (address => bool) public burnAgents;\n', '\n', '    modifier onlyBurnAgents () {\n', '        require(burnAgents[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _maxSupply,\n', '        uint256 _mintedSupply,\n', '        bool _allowedMinting\n', '    ) public MintableToken(\n', '        _maxSupply,\n', '        _mintedSupply,\n', '        _allowedMinting\n', '    ) {\n', '\n', '    }\n', '\n', '    /// @notice update burn agent\n', '    function updateBurnAgent(address _agent, bool _status) public onlyOwner {\n', '        burnAgents[_agent] = _status;\n', '    }\n', '\n', '    function burnByAgent(address _holder, uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n', '        if (_tokensToBurn == 0) {\n', '            _tokensToBurn = balances[_holder];\n', '        }\n', '        _burn(_holder, _tokensToBurn);\n', '\n', '        return _tokensToBurn;\n', '    }\n', '\n', '    function _burn(address _who, uint256 _value) internal {\n', '        super._burn(_who, _value);\n', '        maxSupply = maxSupply.sub(_value);\n', '    }\n', '}\n', '/// @title TimeLocked\n', '/// @author Applicature\n', '/// @notice helper mixed to other contracts to lock contract on a timestamp\n', '/// @dev Base class\n', 'contract TimeLocked {\n', '    uint256 public time;\n', '    mapping(address => bool) public excludedAddresses;\n', '\n', '    modifier isTimeLocked(address _holder, bool _timeLocked) {\n', '        bool locked = (block.timestamp < time);\n', '        require(excludedAddresses[_holder] == true || locked == _timeLocked);\n', '        _;\n', '    }\n', '\n', '    constructor(uint256 _time) public {\n', '        time = _time;\n', '    }\n', '\n', '    function updateExcludedAddress(address _address, bool _status) public;\n', '}\n', '/// @title TimeLockedToken\n', '/// @author Applicature\n', '/// @notice helper mixed to other contracts to lock contract on a timestamp\n', '/// @dev Base class\n', 'contract TimeLockedToken is TimeLocked, StandardToken {\n', '\n', '    constructor(uint256 _time) public TimeLocked(_time) {}\n', '\n', '    function transfer(address _to, uint256 _tokens) public isTimeLocked(msg.sender, false) returns (bool) {\n', '        return super.transfer(_to, _tokens);\n', '    }\n', '\n', '    function transferFrom(address _holder, address _to, uint256 _tokens)\n', '        public\n', '        isTimeLocked(_holder, false)\n', '        returns (bool)\n', '    {\n', '        return super.transferFrom(_holder, _to, _tokens);\n', '    }\n', '}\n', 'contract ICUToken is OpenZeppelinERC20, MintableBurnableToken, TimeLockedToken {\n', '\n', '    ICUCrowdsale public crowdsale;\n', '\n', '    bool public isSoftCapAchieved;\n', '\n', '    constructor(uint256 _unlockTokensTime)\n', '        public\n', "        OpenZeppelinERC20(0, 'iCumulate', 18, 'ICU', false)\n", '        MintableBurnableToken(4700000000e18, 0, true)\n', '        TimeLockedToken(_unlockTokensTime)\n', '    {}\n', '\n', '    function setUnlockTime(uint256 _unlockTokensTime) public onlyStateChangeAgents {\n', '        time = _unlockTokensTime;\n', '    }\n', '\n', '    function setIsSoftCapAchieved() public onlyStateChangeAgents {\n', '        isSoftCapAchieved = true;\n', '    }\n', '\n', '    function setCrowdSale(address _crowdsale) public onlyOwner {\n', '        require(_crowdsale != address(0));\n', '        crowdsale = ICUCrowdsale(_crowdsale);\n', '    }\n', '\n', '    function updateExcludedAddress(address _address, bool _status) public onlyOwner {\n', '        excludedAddresses[_address] = _status;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokens) public returns (bool) {\n', '        require(true == isTransferAllowed(msg.sender));\n', '        return super.transfer(_to, _tokens);\n', '    }\n', '\n', '    function transferFrom(address _holder, address _to, uint256 _tokens) public returns (bool) {\n', '        require(true == isTransferAllowed(_holder));\n', '        return super.transferFrom(_holder, _to, _tokens);\n', '    }\n', '\n', '    function isTransferAllowed(address _address) public view returns (bool) {\n', '        if (excludedAddresses[_address] == true) {\n', '            return true;\n', '        }\n', '\n', '        if (!isSoftCapAchieved && (address(crowdsale) == address(0) || false == crowdsale.isSoftCapAchieved(0))) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function burnUnsoldTokens(uint256 _tokensToBurn) public onlyBurnAgents() returns (uint256) {\n', '        require(maxSupply.sub(_tokensToBurn) >= totalSupply_);\n', '\n', '        maxSupply = maxSupply.sub(_tokensToBurn);\n', '\n', '        emit Burn(address(0), _tokensToBurn);\n', '\n', '        return _tokensToBurn;\n', '    }\n', '\n', '}\n', '/// @title Agent\n', '/// @author Applicature\n', '/// @notice Contract which takes actions on state change and contribution\n', '/// @dev Base class\n', 'contract Agent {\n', '    using SafeMath for uint256;\n', '\n', '    function isInitialized() public view returns (bool) {\n', '        return false;\n', '    }\n', '}\n', '/// @title CrowdsaleAgent\n', '/// @author Applicature\n', '/// @notice Contract which takes actions on state change and contribution\n', '/// @dev Base class\n', 'contract CrowdsaleAgent is Agent {\n', '\n', '    Crowdsale public crowdsale;\n', '    bool public _isInitialized;\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(msg.sender == address(crowdsale));\n', '        _;\n', '    }\n', '\n', '    constructor(Crowdsale _crowdsale) public {\n', '        crowdsale = _crowdsale;\n', '\n', '        if (address(0) != address(_crowdsale)) {\n', '            _isInitialized = true;\n', '        } else {\n', '            _isInitialized = false;\n', '        }\n', '    }\n', '\n', '    function isInitialized() public view returns (bool) {\n', '        return _isInitialized;\n', '    }\n', '\n', '    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus)\n', '        public onlyCrowdsale();\n', '\n', '    function onStateChange(Crowdsale.State _state) public onlyCrowdsale();\n', '\n', '    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned);\n', '}\n', '/// @title MintableCrowdsaleOnSuccessAgent\n', '/// @author Applicature\n', '/// @notice Contract which takes actions on state change and contribution\n', '/// un-pause tokens and disable minting on Crowdsale success\n', '/// @dev implementation\n', 'contract MintableCrowdsaleOnSuccessAgent is CrowdsaleAgent {\n', '\n', '    MintableToken public token;\n', '    bool public _isInitialized;\n', '\n', '    constructor(Crowdsale _crowdsale, MintableToken _token) public CrowdsaleAgent(_crowdsale) {\n', '        token = _token;\n', '\n', '        if (address(0) != address(_token) && address(0) != address(_crowdsale)) {\n', '            _isInitialized = true;\n', '        } else {\n', '            _isInitialized = false;\n', '        }\n', '    }\n', '\n', '    /// @notice Check whether contract is initialised\n', '    /// @return true if initialized\n', '    function isInitialized() public view returns (bool) {\n', '        return _isInitialized;\n', '    }\n', '\n', '    /// @notice Takes actions on contribution\n', '    function onContribution(address _contributor, uint256 _weiAmount, uint256 _tokens, uint256 _bonus) public onlyCrowdsale;\n', '\n', '    /// @notice Takes actions on state change,\n', '    /// un-pause tokens and disable minting on Crowdsale success\n', '    /// @param _state Crowdsale.State\n', '    function onStateChange(Crowdsale.State _state) public onlyCrowdsale;\n', '}\n', 'contract ICUAgent is MintableCrowdsaleOnSuccessAgent {\n', '\n', '    ICUStrategy public strategy;\n', '    ICUCrowdsale public crowdsale;\n', '\n', '    bool public burnStatus;\n', '\n', '    constructor(\n', '        ICUCrowdsale _crowdsale,\n', '        ICUToken _token,\n', '        ICUStrategy _strategy\n', '    ) public MintableCrowdsaleOnSuccessAgent(_crowdsale, _token) {\n', '        require(address(_strategy) != address(0) && address(_crowdsale) != address(0));\n', '        strategy = _strategy;\n', '        crowdsale = _crowdsale;\n', '    }\n', '\n', '    /// @notice Takes actions on contribution\n', '    function onContribution(\n', '        address,\n', '        uint256 _tierIndex,\n', '        uint256 _tokens,\n', '        uint256 _bonus\n', '    ) public onlyCrowdsale() {\n', '        strategy.updateTierState(_tierIndex, _tokens, _bonus);\n', '    }\n', '\n', '    function onStateChange(Crowdsale.State _state) public onlyCrowdsale() {\n', '        ICUToken icuToken = ICUToken(token);\n', '        if (\n', '            icuToken.isSoftCapAchieved() == false\n', '            && (_state == Crowdsale.State.Success || _state == Crowdsale.State.Finalized)\n', '            && crowdsale.isSoftCapAchieved(0)\n', '        ) {\n', '            icuToken.setIsSoftCapAchieved();\n', '        }\n', '\n', '        if (_state > Crowdsale.State.InCrowdsale && burnStatus == false) {\n', '            uint256 unsoldTokensAmount = strategy.getUnsoldTokens();\n', '\n', '            burnStatus = true;\n', '\n', '            icuToken.burnUnsoldTokens(unsoldTokensAmount);\n', '        }\n', '\n', '    }\n', '\n', '    function onRefund(address _contributor, uint256 _tokens) public onlyCrowdsale() returns (uint256 burned) {\n', '        burned = ICUToken(token).burnByAgent(_contributor, _tokens);\n', '    }\n', '\n', '    function updateLockPeriod(uint256 _time) public {\n', '        require(msg.sender == address(strategy));\n', '        ICUToken(token).setUnlockTime(_time);\n', '    }\n', '\n', '}\n', '/// @title TokenAllocator\n', '/// @author Applicature\n', '/// @notice Contract responsible for defining distribution logic of tokens.\n', '/// @dev Base class\n', 'contract TokenAllocator is Ownable {\n', '\n', '\n', '    mapping(address => bool) public crowdsales;\n', '\n', '    modifier onlyCrowdsale() {\n', '        require(crowdsales[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function addCrowdsales(address _address) public onlyOwner {\n', '        crowdsales[_address] = true;\n', '    }\n', '\n', '    function removeCrowdsales(address _address) public onlyOwner {\n', '        crowdsales[_address] = false;\n', '    }\n', '\n', '    function isInitialized() public view returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    function allocate(address _holder, uint256 _tokens) public onlyCrowdsale() {\n', '        internalAllocate(_holder, _tokens);\n', '    }\n', '\n', '    function tokensAvailable() public view returns (uint256);\n', '\n', '    function internalAllocate(address _holder, uint256 _tokens) internal onlyCrowdsale();\n', '}\n', '/// @title MintableTokenAllocator\n', '/// @author Applicature\n', '/// @notice Contract responsible for defining distribution logic of tokens.\n', '/// @dev implementation\n', 'contract MintableTokenAllocator is TokenAllocator {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    MintableToken public token;\n', '\n', '    constructor(MintableToken _token) public {\n', '        require(address(0) != address(_token));\n', '        token = _token;\n', '    }\n', '\n', '    /// @notice update instance of MintableToken\n', '    function setToken(MintableToken _token) public onlyOwner {\n', '        token = _token;\n', '    }\n', '\n', '    function internalAllocate(address _holder, uint256 _tokens) internal {\n', '        token.mint(_holder, _tokens);\n', '    }\n', '\n', '    /// @notice Check whether contract is initialised\n', '    /// @return true if initialized\n', '    function isInitialized() public view returns (bool) {\n', '        return token.mintingAgents(this);\n', '    }\n', '\n', '    /// @return available tokens\n', '    function tokensAvailable() public view returns (uint256) {\n', '        return token.availableTokens();\n', '    }\n', '\n', '}\n', '/// @title ContributionForwarder\n', '/// @author Applicature\n', '/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n', '/// @dev Base class\n', 'contract ContributionForwarder {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public weiCollected;\n', '    uint256 public weiForwarded;\n', '\n', '    event ContributionForwarded(address receiver, uint256 weiAmount);\n', '\n', '    function isInitialized() public view returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    /// @notice transfer wei to receiver\n', '    function forward() public payable {\n', '        require(msg.value > 0);\n', '\n', '        weiCollected += msg.value;\n', '\n', '        internalForward();\n', '    }\n', '\n', '    function internalForward() internal;\n', '}\n', '/// @title DistributedDirectContributionForwarder\n', '/// @author Applicature\n', '/// @notice Contract is responsible for distributing collected ethers, that are received from CrowdSale.\n', '/// @dev implementation\n', 'contract DistributedDirectContributionForwarder is ContributionForwarder {\n', '    Receiver[] public receivers;\n', '    uint256 public proportionAbsMax;\n', '    bool public isInitialized_;\n', '\n', '    struct Receiver {\n', '        address receiver;\n', '        uint256 proportion; // abslolute value in range of 0 - proportionAbsMax\n', '        uint256 forwardedWei;\n', '    }\n', '\n', '    constructor(uint256 _proportionAbsMax, address[] _receivers, uint256[] _proportions) public {\n', '        proportionAbsMax = _proportionAbsMax;\n', '\n', '        require(_receivers.length == _proportions.length);\n', '\n', '        require(_receivers.length > 0);\n', '\n', '        uint256 totalProportion;\n', '\n', '        for (uint256 i = 0; i < _receivers.length; i++) {\n', '            uint256 proportion = _proportions[i];\n', '\n', '            totalProportion = totalProportion.add(proportion);\n', '\n', '            receivers.push(Receiver(_receivers[i], proportion, 0));\n', '        }\n', '\n', '        require(totalProportion == proportionAbsMax);\n', '        isInitialized_ = true;\n', '    }\n', '\n', '    /// @notice Check whether contract is initialised\n', '    /// @return true if initialized\n', '    function isInitialized() public view returns (bool) {\n', '        return isInitialized_;\n', '    }\n', '\n', '    function internalForward() internal {\n', '        uint256 transferred;\n', '\n', '        for (uint256 i = 0; i < receivers.length; i++) {\n', '            Receiver storage receiver = receivers[i];\n', '\n', '            uint256 value = msg.value.mul(receiver.proportion).div(proportionAbsMax);\n', '\n', '            if (i == receivers.length - 1) {\n', '                value = msg.value.sub(transferred);\n', '            }\n', '\n', '            transferred = transferred.add(value);\n', '\n', '            receiver.receiver.transfer(value);\n', '\n', '            emit ContributionForwarded(receiver.receiver, value);\n', '        }\n', '\n', '        weiForwarded = weiForwarded.add(transferred);\n', '    }\n', '}\n', 'contract Crowdsale {\n', '\n', '    uint256 public tokensSold;\n', '\n', '    enum State {Unknown, Initializing, BeforeCrowdsale, InCrowdsale, Success, Finalized, Refunding}\n', '\n', '    function externalContribution(address _contributor, uint256 _wei) public payable;\n', '\n', '    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable;\n', '\n', '    function getState() public view returns (State);\n', '\n', '    function updateState() public;\n', '\n', '    function internalContribution(address _contributor, uint256 _wei) internal;\n', '\n', '}\n', '/// @title Crowdsale\n', '/// @author Applicature\n', '/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n', 'contract CrowdsaleImpl is Crowdsale, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    State public currentState;\n', '    TokenAllocator public allocator;\n', '    ContributionForwarder public contributionForwarder;\n', '    PricingStrategy public pricingStrategy;\n', '    CrowdsaleAgent public crowdsaleAgent;\n', '    bool public finalized;\n', '    uint256 public startDate;\n', '    uint256 public endDate;\n', '    bool public allowWhitelisted;\n', '    bool public allowSigned;\n', '    bool public allowAnonymous;\n', '    mapping(address => bool) public whitelisted;\n', '    mapping(address => bool) public signers;\n', '    mapping(address => bool) public externalContributionAgents;\n', '\n', '    event Contribution(address _contributor, uint256 _wei, uint256 _tokensExcludingBonus, uint256 _bonus);\n', '\n', '    constructor(\n', '        TokenAllocator _allocator,\n', '        ContributionForwarder _contributionForwarder,\n', '        PricingStrategy _pricingStrategy,\n', '        uint256 _startDate,\n', '        uint256 _endDate,\n', '        bool _allowWhitelisted,\n', '        bool _allowSigned,\n', '        bool _allowAnonymous\n', '    ) public {\n', '        allocator = _allocator;\n', '        contributionForwarder = _contributionForwarder;\n', '        pricingStrategy = _pricingStrategy;\n', '\n', '        startDate = _startDate;\n', '        endDate = _endDate;\n', '\n', '        allowWhitelisted = _allowWhitelisted;\n', '        allowSigned = _allowSigned;\n', '        allowAnonymous = _allowAnonymous;\n', '\n', '        currentState = State.Unknown;\n', '    }\n', '\n', '    /// @notice default payable function\n', '    function() public payable {\n', '        require(allowWhitelisted || allowAnonymous);\n', '\n', '        if (!allowAnonymous) {\n', '            if (allowWhitelisted) {\n', '                require(whitelisted[msg.sender]);\n', '            }\n', '        }\n', '\n', '        internalContribution(msg.sender, msg.value);\n', '    }\n', '\n', '    /// @notice update crowdsale agent\n', '    function setCrowdsaleAgent(CrowdsaleAgent _crowdsaleAgent) public onlyOwner {\n', '        require(address(_crowdsaleAgent) != address(0));\n', '        crowdsaleAgent = _crowdsaleAgent;\n', '    }\n', '\n', '    /// @notice allows external user to do contribution\n', '    function externalContribution(address _contributor, uint256 _wei) public payable {\n', '        require(externalContributionAgents[msg.sender]);\n', '        internalContribution(_contributor, _wei);\n', '    }\n', '\n', '    /// @notice update external contributor\n', '    function addExternalContributor(address _contributor) public onlyOwner {\n', '        externalContributionAgents[_contributor] = true;\n', '    }\n', '\n', '    /// @notice update external contributor\n', '    function removeExternalContributor(address _contributor) public onlyOwner {\n', '        externalContributionAgents[_contributor] = false;\n', '    }\n', '\n', '    /// @notice update whitelisting address\n', '    function updateWhitelist(address _address, bool _status) public onlyOwner {\n', '        whitelisted[_address] = _status;\n', '    }\n', '\n', '    /// @notice update signer\n', '    function addSigner(address _signer) public onlyOwner {\n', '        signers[_signer] = true;\n', '    }\n', '\n', '    /// @notice update signer\n', '    function removeSigner(address _signer) public onlyOwner {\n', '        signers[_signer] = false;\n', '    }\n', '\n', '    /// @notice allows to do signed contributions\n', '    function contribute(uint8 _v, bytes32 _r, bytes32 _s) public payable {\n', '        address recoveredAddress = verify(msg.sender, _v, _r, _s);\n', '        require(signers[recoveredAddress]);\n', '        internalContribution(msg.sender, msg.value);\n', '    }\n', '\n', '    /// @notice check sign\n', '    function verify(address _sender, uint8 _v, bytes32 _r, bytes32 _s) public view returns (address) {\n', '        bytes32 hash = keccak256(abi.encodePacked(this, _sender));\n', '\n', "        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n", '\n', '        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n', '    }\n', '\n', '    /// @return Crowdsale state\n', '    function getState() public view returns (State) {\n', '        if (finalized) {\n', '            return State.Finalized;\n', '        } else if (allocator.isInitialized() == false) {\n', '            return State.Initializing;\n', '        } else if (contributionForwarder.isInitialized() == false) {\n', '            return State.Initializing;\n', '        } else if (pricingStrategy.isInitialized() == false) {\n', '            return State.Initializing;\n', '        } else if (block.timestamp < startDate) {\n', '            return State.BeforeCrowdsale;\n', '        } else if (block.timestamp >= startDate && block.timestamp <= endDate) {\n', '            return State.InCrowdsale;\n', '        } else if (block.timestamp > endDate) {\n', '            return State.Success;\n', '        }\n', '\n', '        return State.Unknown;\n', '    }\n', '\n', '    /// @notice Crowdsale state\n', '    function updateState() public {\n', '        State state = getState();\n', '\n', '        if (currentState != state) {\n', '            if (crowdsaleAgent != address(0)) {\n', '                crowdsaleAgent.onStateChange(state);\n', '            }\n', '\n', '            currentState = state;\n', '        }\n', '    }\n', '\n', '    function internalContribution(address _contributor, uint256 _wei) internal {\n', '        require(getState() == State.InCrowdsale);\n', '\n', '        uint256 tokensAvailable = allocator.tokensAvailable();\n', '        uint256 collectedWei = contributionForwarder.weiCollected();\n', '\n', '        uint256 tokens;\n', '        uint256 tokensExcludingBonus;\n', '        uint256 bonus;\n', '\n', '        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n', '            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n', '\n', '        require(tokens > 0 && tokens <= tokensAvailable);\n', '        tokensSold = tokensSold.add(tokens);\n', '\n', '        allocator.allocate(_contributor, tokens);\n', '\n', '        if (msg.value > 0) {\n', '            contributionForwarder.forward.value(msg.value)();\n', '        }\n', '\n', '        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '    }\n', '\n', '}\n', '/// @title HardCappedCrowdsale\n', '/// @author Applicature\n', '/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n', '/// with hard limit\n', 'contract HardCappedCrowdsale is CrowdsaleImpl {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public hardCap;\n', '\n', '    constructor(\n', '        TokenAllocator _allocator,\n', '        ContributionForwarder _contributionForwarder,\n', '        PricingStrategy _pricingStrategy,\n', '        uint256 _startDate,\n', '        uint256 _endDate,\n', '        bool _allowWhitelisted,\n', '        bool _allowSigned,\n', '        bool _allowAnonymous,\n', '        uint256 _hardCap\n', '    ) public CrowdsaleImpl(\n', '        _allocator,\n', '        _contributionForwarder,\n', '        _pricingStrategy,\n', '        _startDate,\n', '        _endDate,\n', '        _allowWhitelisted,\n', '        _allowSigned,\n', '        _allowAnonymous\n', '    ) {\n', '        hardCap = _hardCap;\n', '    }\n', '\n', '    /// @return Crowdsale state\n', '    function getState() public view returns (State) {\n', '        State state = super.getState();\n', '\n', '        if (state == State.InCrowdsale) {\n', '            if (isHardCapAchieved(0)) {\n', '                return State.Success;\n', '            }\n', '        }\n', '\n', '        return state;\n', '    }\n', '\n', '    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n', '        if (hardCap <= tokensSold.add(_value)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function internalContribution(address _contributor, uint256 _wei) internal {\n', '        require(getState() == State.InCrowdsale);\n', '\n', '        uint256 tokensAvailable = allocator.tokensAvailable();\n', '        uint256 collectedWei = contributionForwarder.weiCollected();\n', '\n', '        uint256 tokens;\n', '        uint256 tokensExcludingBonus;\n', '        uint256 bonus;\n', '\n', '        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n', '            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n', '\n', '        require(tokens <= tokensAvailable && tokens > 0 && false == isHardCapAchieved(tokens.sub(1)));\n', '\n', '        tokensSold = tokensSold.add(tokens);\n', '\n', '        allocator.allocate(_contributor, tokens);\n', '\n', '        if (msg.value > 0) {\n', '            contributionForwarder.forward.value(msg.value)();\n', '        }\n', '        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '    }\n', '}\n', '/// @title RefundableCrowdsale\n', '/// @author Applicature\n', '/// @notice Contract is responsible for collecting, refunding, allocating tokens during different stages of Crowdsale.\n', '/// with hard and soft limits\n', 'contract RefundableCrowdsale is HardCappedCrowdsale {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public softCap;\n', '    mapping(address => uint256) public contributorsWei;\n', '    address[] public contributors;\n', '\n', '    event Refund(address _holder, uint256 _wei, uint256 _tokens);\n', '\n', '    constructor(\n', '        TokenAllocator _allocator,\n', '        ContributionForwarder _contributionForwarder,\n', '        PricingStrategy _pricingStrategy,\n', '        uint256 _startDate,\n', '        uint256 _endDate,\n', '        bool _allowWhitelisted,\n', '        bool _allowSigned,\n', '        bool _allowAnonymous,\n', '        uint256 _softCap,\n', '        uint256 _hardCap\n', '\n', '    ) public HardCappedCrowdsale(\n', '        _allocator, _contributionForwarder, _pricingStrategy,\n', '        _startDate, _endDate,\n', '        _allowWhitelisted, _allowSigned, _allowAnonymous, _hardCap\n', '    ) {\n', '        softCap = _softCap;\n', '    }\n', '\n', '    /// @return Crowdsale state\n', '    function getState() public view returns (State) {\n', '        State state = super.getState();\n', '\n', '        if (state == State.Success) {\n', '            if (!isSoftCapAchieved(0)) {\n', '                return State.Refunding;\n', '            }\n', '        }\n', '\n', '        return state;\n', '    }\n', '\n', '    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n', '        if (softCap <= tokensSold.add(_value)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice refund ethers to contributor\n', '    function refund() public {\n', '        internalRefund(msg.sender);\n', '    }\n', '\n', '    /// @notice refund ethers to delegate\n', '    function delegatedRefund(address _address) public {\n', '        internalRefund(_address);\n', '    }\n', '\n', '    function internalContribution(address _contributor, uint256 _wei) internal {\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);\n', '\n', '        uint256 tokensAvailable = allocator.tokensAvailable();\n', '        uint256 collectedWei = contributionForwarder.weiCollected();\n', '\n', '        uint256 tokens;\n', '        uint256 tokensExcludingBonus;\n', '        uint256 bonus;\n', '\n', '        (tokens, tokensExcludingBonus, bonus) = pricingStrategy.getTokens(\n', '            _contributor, tokensAvailable, tokensSold, _wei, collectedWei);\n', '\n', '        require(tokens <= tokensAvailable && tokens > 0 && hardCap > tokensSold.add(tokens));\n', '\n', '        tokensSold = tokensSold.add(tokens);\n', '\n', '        allocator.allocate(_contributor, tokens);\n', '\n', '        // transfer only if softcap is reached\n', '        if (isSoftCapAchieved(0)) {\n', '            if (msg.value > 0) {\n', '                contributionForwarder.forward.value(address(this).balance)();\n', '            }\n', '        } else {\n', '            // store contributor if it is not stored before\n', '            if (contributorsWei[_contributor] == 0) {\n', '                contributors.push(_contributor);\n', '            }\n', '            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n', '        }\n', '        crowdsaleAgent.onContribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '    }\n', '\n', '    function internalRefund(address _holder) internal {\n', '        updateState();\n', '        require(block.timestamp > endDate);\n', '        require(!isSoftCapAchieved(0));\n', '        require(crowdsaleAgent != address(0));\n', '\n', '        uint256 value = contributorsWei[_holder];\n', '\n', '        require(value > 0);\n', '\n', '        contributorsWei[_holder] = 0;\n', '        uint256 burnedTokens = crowdsaleAgent.onRefund(_holder, 0);\n', '\n', '        _holder.transfer(value);\n', '\n', '        emit Refund(_holder, value, burnedTokens);\n', '    }\n', '}\n', 'contract ICUCrowdsale is RefundableCrowdsale {\n', '\n', '    uint256 public maxSaleSupply = 2350000000e18;\n', '\n', '    uint256 public availableBonusAmount = 447500000e18;\n', '\n', '    uint256 public usdCollected;\n', '\n', '    mapping(address => uint256) public contributorBonuses;\n', '\n', '    constructor(\n', '        MintableTokenAllocator _allocator,\n', '        DistributedDirectContributionForwarder _contributionForwarder,\n', '        ICUStrategy _pricingStrategy,\n', '        uint256 _startTime,\n', '        uint256 _endTime\n', '    ) public RefundableCrowdsale(\n', '        _allocator,\n', '        _contributionForwarder,\n', '        _pricingStrategy,\n', '        _startTime,\n', '        _endTime,\n', '        true,\n', '        true,\n', '        false,\n', '        2500000e5, //softCap\n', '        23500000e5//hardCap\n', '    ) {}\n', '\n', '    function updateState() public {\n', '        (startDate, endDate) = ICUStrategy(pricingStrategy).getActualDates();\n', '        super.updateState();\n', '    }\n', '\n', '    function claimBonuses() public {\n', '        require(isSoftCapAchieved(0) && contributorBonuses[msg.sender] > 0);\n', '\n', '        uint256 bonus = contributorBonuses[msg.sender];\n', '        contributorBonuses[msg.sender] = 0;\n', '        allocator.allocate(msg.sender, bonus);\n', '    }\n', '\n', '    function addExternalContributor(address) public onlyOwner {\n', '        require(false);\n', '    }\n', '\n', '    function isHardCapAchieved(uint256 _value) public view returns (bool) {\n', '        if (hardCap <= usdCollected.add(_value)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isSoftCapAchieved(uint256 _value) public view returns (bool) {\n', '        if (softCap <= usdCollected.add(_value)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function internalContribution(address _contributor, uint256 _wei) internal {\n', '        updateState();\n', '        require(currentState == State.InCrowdsale);\n', '\n', '        ICUStrategy pricing = ICUStrategy(pricingStrategy);\n', '        uint256 usdAmount = pricing.getUSDAmount(_wei);\n', '        require(!isHardCapAchieved(usdAmount.sub(1)));\n', '\n', '        uint256 tokensAvailable = allocator.tokensAvailable();\n', '        uint256 collectedWei = contributionForwarder.weiCollected();\n', '        uint256 tierIndex = pricing.getTierIndex();\n', '        uint256 tokens;\n', '        uint256 tokensExcludingBonus;\n', '        uint256 bonus;\n', '\n', '        (tokens, tokensExcludingBonus, bonus) = pricing.getTokens(\n', '            _contributor, tokensAvailable, tokensSold, _wei, collectedWei\n', '        );\n', '\n', '        require(tokens > 0);\n', '        tokensSold = tokensSold.add(tokens);\n', '        allocator.allocate(_contributor, tokensExcludingBonus);\n', '\n', '        if (isSoftCapAchieved(usdAmount)) {\n', '            if (msg.value > 0) {\n', '                contributionForwarder.forward.value(address(this).balance)();\n', '            }\n', '        } else {\n', '            // store contributor if it is not stored before\n', '            if (contributorsWei[_contributor] == 0) {\n', '                contributors.push(_contributor);\n', '            }\n', '            contributorsWei[_contributor] = contributorsWei[_contributor].add(msg.value);\n', '        }\n', '\n', '        usdCollected = usdCollected.add(usdAmount);\n', '\n', '        if (availableBonusAmount > 0) {\n', '            if (availableBonusAmount >= bonus) {\n', '                availableBonusAmount -= bonus;\n', '            } else {\n', '                bonus = availableBonusAmount;\n', '                availableBonusAmount = 0;\n', '            }\n', '            contributorBonuses[_contributor] = contributorBonuses[_contributor].add(bonus);\n', '        } else {\n', '            bonus = 0;\n', '        }\n', '\n', '        crowdsaleAgent.onContribution(pricing, tierIndex, tokensExcludingBonus, bonus);\n', '        emit Contribution(_contributor, _wei, tokensExcludingBonus, bonus);\n', '    }\n', '\n', '}\n', '/// @title PricingStrategy\n', '/// @author Applicature\n', '/// @notice Contract is responsible for calculating tokens amount depending on different criterias\n', '/// @dev Base class\n', 'contract PricingStrategy {\n', '\n', '    function isInitialized() public view returns (bool);\n', '\n', '    function getTokens(\n', '        address _contributor,\n', '        uint256 _tokensAvailable,\n', '        uint256 _tokensSold,\n', '        uint256 _weiAmount,\n', '        uint256 _collectedWei\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 tokens, uint256 tokensExludingBonus, uint256 bonus);\n', '\n', '    function getWeis(\n', '        uint256 _collectedWei,\n', '        uint256 _tokensSold,\n', '        uint256 _tokens\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 weiAmount, uint256 tokensBonus);\n', '}\n', '/// @title TokenDateCappedTiersPricingStrategy\n', '/// @author Applicature\n', '/// @notice Contract is responsible for calculating tokens amount depending on price in USD\n', '/// @dev implementation\n', 'contract TokenDateCappedTiersPricingStrategy is PricingStrategy, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public etherPriceInUSD;\n', '\n', '    uint256 public capsAmount;\n', '\n', '    struct Tier {\n', '        uint256 tokenInUSD;\n', '        uint256 maxTokensCollected;\n', '        uint256 soldTierTokens;\n', '        uint256 bonusTierTokens;\n', '        uint256 discountPercents;\n', '        uint256 minInvestInUSD;\n', '        uint256 startDate;\n', '        uint256 endDate;\n', '        bool unsoldProcessed;\n', '        uint256[] capsData;\n', '    }\n', '\n', '    Tier[] public tiers;\n', '    uint256 public decimals;\n', '\n', '    constructor(\n', '        uint256[] _tiers,\n', '        uint256[] _capsData,\n', '        uint256 _decimals,\n', '        uint256 _etherPriceInUSD\n', '    )\n', '        public\n', '    {\n', '        decimals = _decimals;\n', '        require(_etherPriceInUSD > 0);\n', '        etherPriceInUSD = _etherPriceInUSD;\n', '\n', '        require(_tiers.length % 6 == 0);\n', '        uint256 length = _tiers.length / 6;\n', '\n', '        require(_capsData.length % 2 == 0);\n', '        uint256 lengthCaps = _capsData.length / 2;\n', '\n', '        uint256[] memory emptyArray;\n', '\n', '        for (uint256 i = 0; i < length; i++) {\n', '            tiers.push(\n', '                Tier(\n', '                    _tiers[i * 6],//tokenInUSD\n', '                    _tiers[i * 6 + 1],//maxTokensCollected\n', '                    0,//soldTierTokens\n', '                    0,//bonusTierTokens\n', '                    _tiers[i * 6 + 2],//discountPercents\n', '                    _tiers[i * 6 + 3],//minInvestInUSD\n', '                    _tiers[i * 6 + 4],//startDate\n', '                    _tiers[i * 6 + 5],//endDate\n', '                    false,\n', '                    emptyArray//capsData\n', '                )\n', '            );\n', '\n', '            for (uint256 j = 0; j < lengthCaps; j++) {\n', '                tiers[i].capsData.push(_capsData[i * lengthCaps + j]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @return tier index\n', '    function getTierIndex() public view returns (uint256) {\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (\n', '                block.timestamp >= tiers[i].startDate &&\n', '                block.timestamp < tiers[i].endDate &&\n', '                tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n', '            ) {\n', '                return i;\n', '            }\n', '        }\n', '\n', '        return tiers.length;\n', '    }\n', '\n', '    function getActualTierIndex() public view returns (uint256) {\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            if (\n', '                block.timestamp >= tiers[i].startDate\n', '                && block.timestamp < tiers[i].endDate\n', '                && tiers[i].maxTokensCollected > tiers[i].soldTierTokens\n', '                || block.timestamp < tiers[i].startDate\n', '            ) {\n', '                return i;\n', '            }\n', '        }\n', '\n', '        return tiers.length.sub(1);\n', '    }\n', '\n', '    /// @return actual dates\n', '    function getActualDates() public view returns (uint256 startDate, uint256 endDate) {\n', '        uint256 tierIndex = getActualTierIndex();\n', '        startDate = tiers[tierIndex].startDate;\n', '        endDate = tiers[tierIndex].endDate;\n', '    }\n', '\n', '    function getTokensWithoutRestrictions(uint256 _weiAmount) public view returns (\n', '        uint256 tokens,\n', '        uint256 tokensExcludingBonus,\n', '        uint256 bonus\n', '    ) {\n', '        if (_weiAmount == 0) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        uint256 tierIndex = getActualTierIndex();\n', '\n', '        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\n', '        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n', '        tokens = tokensExcludingBonus.add(bonus);\n', '    }\n', '\n', '    /// @return tokens based on sold tokens and wei amount\n', '    function getTokens(\n', '        address,\n', '        uint256 _tokensAvailable,\n', '        uint256,\n', '        uint256 _weiAmount,\n', '        uint256\n', '    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n', '        if (_weiAmount == 0) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        uint256 tierIndex = getTierIndex();\n', '        if (tierIndex == tiers.length || _weiAmount.mul(etherPriceInUSD).div(1e18) < tiers[tierIndex].minInvestInUSD) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        tokensExcludingBonus = _weiAmount.mul(etherPriceInUSD).div(getTokensInUSD(tierIndex));\n', '\n', '        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(tokensExcludingBonus)) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        bonus = calculateBonusAmount(tierIndex, tokensExcludingBonus);\n', '        tokens = tokensExcludingBonus.add(bonus);\n', '\n', '        if (tokens > _tokensAvailable) {\n', '            return (0, 0, 0);\n', '        }\n', '    }\n', '\n', '    /// @return weis based on sold and required tokens\n', '    function getWeis(\n', '        uint256,\n', '        uint256,\n', '        uint256 _tokens\n', '    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n', '        if (_tokens == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 tierIndex = getTierIndex();\n', '        if (tierIndex == tiers.length) {\n', '            return (0, 0);\n', '        }\n', '        if (tiers[tierIndex].maxTokensCollected < tiers[tierIndex].soldTierTokens.add(_tokens)) {\n', '            return (0, 0);\n', '        }\n', '        uint256 usdAmount = _tokens.mul(getTokensInUSD(tierIndex)).div(1e18);\n', '        totalWeiAmount = usdAmount.mul(1e18).div(etherPriceInUSD);\n', '\n', '        if (totalWeiAmount < uint256(1 ether).mul(tiers[tierIndex].minInvestInUSD).div(etherPriceInUSD)) {\n', '            return (0, 0);\n', '        }\n', '\n', '        tokensBonus = calculateBonusAmount(tierIndex, _tokens);\n', '    }\n', '\n', '    function calculateBonusAmount(uint256 _tierIndex, uint256 _tokens) public view returns (uint256 bonus) {\n', '        uint256 length = tiers[_tierIndex].capsData.length.div(2);\n', '\n', '        uint256 remainingTokens = _tokens;\n', '        uint256 newSoldTokens = tiers[_tierIndex].soldTierTokens;\n', '\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (tiers[_tierIndex].capsData[i.mul(2)] == 0) {\n', '                break;\n', '            }\n', '            if (newSoldTokens.add(remainingTokens) <= tiers[_tierIndex].capsData[i.mul(2)]) {\n', '                bonus += remainingTokens.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\n', '                break;\n', '            } else {\n', '                uint256 diff = tiers[_tierIndex].capsData[i.mul(2)].sub(newSoldTokens);\n', '                remainingTokens -= diff;\n', '                newSoldTokens += diff;\n', '                bonus += diff.mul(tiers[_tierIndex].capsData[i.mul(2).add(1)]).div(100);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getTokensInUSD(uint256 _tierIndex) public view returns (uint256) {\n', '        if (_tierIndex < uint256(tiers.length)) {\n', '            return tiers[_tierIndex].tokenInUSD;\n', '        }\n', '    }\n', '\n', '    function getDiscount(uint256 _tierIndex) public view returns (uint256) {\n', '        if (_tierIndex < uint256(tiers.length)) {\n', '            return tiers[_tierIndex].discountPercents;\n', '        }\n', '    }\n', '\n', '    function getMinEtherInvest(uint256 _tierIndex) public view returns (uint256) {\n', '        if (_tierIndex < uint256(tiers.length)) {\n', '            return tiers[_tierIndex].minInvestInUSD.mul(1 ether).div(etherPriceInUSD);\n', '        }\n', '    }\n', '\n', '    function getUSDAmount(uint256 _weiAmount) public view returns (uint256) {\n', '        return _weiAmount.mul(etherPriceInUSD).div(1 ether);\n', '    }\n', '\n', '    /// @notice Check whether contract is initialised\n', '    /// @return true if initialized\n', '    function isInitialized() public view returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /// @notice updates tier start/end dates by id\n', '    function updateDates(uint8 _tierId, uint256 _start, uint256 _end) public onlyOwner() {\n', '        if (_start != 0 && _start < _end && _tierId < tiers.length) {\n', '            Tier storage tier = tiers[_tierId];\n', '            tier.startDate = _start;\n', '            tier.endDate = _end;\n', '        }\n', '    }\n', '}\n', 'contract ICUStrategy is TokenDateCappedTiersPricingStrategy {\n', '\n', '    ICUAgent public agent;\n', '\n', '    event UnsoldTokensProcessed(uint256 fromTier, uint256 toTier, uint256 tokensAmount);\n', '\n', '    constructor(\n', '        uint256[] _emptyArray,\n', '        uint256 _etherPriceInUSD\n', '    ) public TokenDateCappedTiersPricingStrategy(\n', '        _emptyArray,\n', '        _emptyArray,\n', '        18,\n', '        _etherPriceInUSD\n', '    ) {\n', '        //Pre-ICO\n', '        tiers.push(\n', '            Tier(\n', '                0.01e5,//tokenInUSD\n', '                1000000000e18,//maxTokensCollected\n', '                0,//soldTierTokens\n', '                0,//bonusTierTokens\n', '                0,//discountPercents\n', '                uint256(20).mul(_etherPriceInUSD),//minInvestInUSD | 20 ethers\n', '                1543579200,//startDate | 2018/11/30 12:00:00 PM UTC\n', '                1544184000,//endDate | 2018/12/07 12:00:00 PM UTC\n', '                false,\n', '                _emptyArray\n', '            )\n', '        );\n', '        //ICO\n', '        tiers.push(\n', '            Tier(\n', '                0.01e5,//tokenInUSD\n', '                1350000000e18,//maxTokensCollected\n', '                0,//soldTierTokens\n', '                0,//bonusTierTokens\n', '                0,//discountPercents\n', '                uint256(_etherPriceInUSD).div(10),//minInvestInUSD | 0.1 ether\n', '                1544443200,//startDate | 2018/12/10\t12:00:00 PM UTC\n', '                1546257600,//endDate | 2018/12/31 12:00:00 PM UTC\n', '                false,\n', '                _emptyArray\n', '            )\n', '        );\n', '\n', '        //Pre-ICO caps data\n', '        tiers[0].capsData.push(1000000000e18);//cap $10,000,000 in tokens\n', '        tiers[0].capsData.push(30);//bonus percents\n', '\n', '        //ICO caps data\n', '        tiers[1].capsData.push(400000000e18);//cap $4,000,000 in tokens\n', '        tiers[1].capsData.push(20);//bonus percents\n', '\n', '        tiers[1].capsData.push(800000000e18);//cap $4,000,000 in tokens\n', '        tiers[1].capsData.push(10);//bonus percents\n', '\n', '        tiers[1].capsData.push(1350000000e18);//cap $5,500,000 in tokens\n', '        tiers[1].capsData.push(5);//bonus percents\n', '\n', '    }\n', '\n', '    function getArrayOfTiers() public view returns (uint256[14] tiersData) {\n', '        uint256 j = 0;\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            tiersData[j++] = uint256(tiers[i].tokenInUSD);\n', '            tiersData[j++] = uint256(tiers[i].maxTokensCollected);\n', '            tiersData[j++] = uint256(tiers[i].soldTierTokens);\n', '            tiersData[j++] = uint256(tiers[i].discountPercents);\n', '            tiersData[j++] = uint256(tiers[i].minInvestInUSD);\n', '            tiersData[j++] = uint256(tiers[i].startDate);\n', '            tiersData[j++] = uint256(tiers[i].endDate);\n', '        }\n', '    }\n', '\n', '    function updateTier(\n', '        uint256 _tierId,\n', '        uint256 _start,\n', '        uint256 _end,\n', '        uint256 _minInvest,\n', '        uint256 _price,\n', '        uint256 _discount,\n', '        uint256[] _capsData,\n', '        bool updateLockNeeded\n', '    ) public onlyOwner() {\n', '        require(\n', '            _start != 0 &&\n', '            _price != 0 &&\n', '            _start < _end &&\n', '            _tierId < tiers.length &&\n', '            _capsData.length > 0 &&\n', '            _capsData.length % 2 == 0\n', '        );\n', '\n', '        if (updateLockNeeded) {\n', '            agent.updateLockPeriod(_end);\n', '        }\n', '\n', '        Tier storage tier = tiers[_tierId];\n', '        tier.tokenInUSD = _price;\n', '        tier.discountPercents = _discount;\n', '        tier.minInvestInUSD = _minInvest;\n', '        tier.startDate = _start;\n', '        tier.endDate = _end;\n', '        tier.capsData = _capsData;\n', '    }\n', '\n', '    function setCrowdsaleAgent(ICUAgent _crowdsaleAgent) public onlyOwner {\n', '        agent = _crowdsaleAgent;\n', '    }\n', '\n', '    function updateTierState(uint256 _tierId, uint256 _soldTokens, uint256 _bonusTokens) public {\n', '        require(\n', '            msg.sender == address(agent) &&\n', '            _tierId < tiers.length &&\n', '            _soldTokens > 0\n', '        );\n', '\n', '        Tier storage tier = tiers[_tierId];\n', '\n', '        if (_tierId > 0 && !tiers[_tierId.sub(1)].unsoldProcessed) {\n', '            Tier storage prevTier = tiers[_tierId.sub(1)];\n', '            prevTier.unsoldProcessed = true;\n', '\n', '            uint256 unsold = prevTier.maxTokensCollected.sub(prevTier.soldTierTokens);\n', '            tier.maxTokensCollected = tier.maxTokensCollected.add(unsold);\n', '            tier.capsData[0] = tier.capsData[0].add(unsold);\n', '\n', '            emit UnsoldTokensProcessed(_tierId.sub(1), _tierId, unsold);\n', '        }\n', '\n', '        tier.soldTierTokens = tier.soldTierTokens.add(_soldTokens);\n', '        tier.bonusTierTokens = tier.bonusTierTokens.add(_bonusTokens);\n', '    }\n', '\n', '    function getTierUnsoldTokens(uint256 _tierId) public view returns (uint256) {\n', '        if (_tierId >= tiers.length || tiers[_tierId].unsoldProcessed) {\n', '            return 0;\n', '        }\n', '\n', '        return tiers[_tierId].maxTokensCollected.sub(tiers[_tierId].soldTierTokens);\n', '    }\n', '\n', '    function getUnsoldTokens() public view returns (uint256 unsoldTokens) {\n', '        for (uint256 i = 0; i < tiers.length; i++) {\n', '            unsoldTokens += getTierUnsoldTokens(i);\n', '        }\n', '    }\n', '\n', '    function getCapsData(uint256 _tierId) public view returns (uint256[]) {\n', '        if (_tierId < tiers.length) {\n', '            return tiers[_tierId].capsData;\n', '        }\n', '    }\n', '\n', '}\n', 'contract Referral is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    MintableTokenAllocator public allocator;\n', '    CrowdsaleImpl public crowdsale;\n', '\n', '    uint256 public constant DECIMALS = 18;\n', '\n', '    uint256 public totalSupply;\n', '    bool public unLimited;\n', '    bool public sentOnce;\n', '\n', '    mapping(address => bool) public claimed;\n', '    mapping(address => uint256) public claimedBalances;\n', '\n', '    constructor(\n', '        uint256 _totalSupply,\n', '        address _allocator,\n', '        address _crowdsale,\n', '        bool _sentOnce\n', '    ) public {\n', '        require(_allocator != address(0) && _crowdsale != address(0));\n', '        totalSupply = _totalSupply;\n', '        if (totalSupply == 0) {\n', '            unLimited = true;\n', '        }\n', '        allocator = MintableTokenAllocator(_allocator);\n', '        crowdsale = CrowdsaleImpl(_crowdsale);\n', '        sentOnce = _sentOnce;\n', '    }\n', '\n', '    function setAllocator(address _allocator) public onlyOwner {\n', '        require(_allocator != address(0));\n', '        allocator = MintableTokenAllocator(_allocator);\n', '    }\n', '\n', '    function setCrowdsale(address _crowdsale) public onlyOwner {\n', '        require(_crowdsale != address(0));\n', '        crowdsale = CrowdsaleImpl(_crowdsale);\n', '    }\n', '\n', '    function multivestMint(\n', '        address _address,\n', '        uint256 _amount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) public {\n', '        require(true == crowdsale.signers(verify(msg.sender, _amount, _v, _r, _s)));\n', '        if (true == sentOnce) {\n', '            require(claimed[_address] == false);\n', '            claimed[_address] = true;\n', '        }\n', '        require(\n', '            _address == msg.sender &&\n', '            _amount > 0 &&\n', '            (true == unLimited || _amount <= totalSupply)\n', '        );\n', '        claimedBalances[_address] = claimedBalances[_address].add(_amount);\n', '        if (false == unLimited) {\n', '            totalSupply = totalSupply.sub(_amount);\n', '        }\n', '        allocator.allocate(_address, _amount);\n', '    }\n', '\n', '    /// @notice check sign\n', '    function verify(address _sender, uint256 _amount, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\n', '        bytes32 hash = keccak256(abi.encodePacked(_sender, _amount));\n', '\n', "        bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n", '\n', '        return ecrecover(keccak256(abi.encodePacked(prefix, hash)), _v, _r, _s);\n', '    }\n', '}\n', 'contract ICUReferral is Referral {\n', '\n', '    constructor(\n', '        address _allocator,\n', '        address _crowdsale\n', '    ) public Referral(35000000e18, _allocator, _crowdsale, true) {}\n', '\n', '    function multivestMint(\n', '        address _address,\n', '        uint256 _amount,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) public {\n', '        ICUCrowdsale icuCrowdsale = ICUCrowdsale(crowdsale);\n', '        icuCrowdsale.updateState();\n', '        require(icuCrowdsale.isSoftCapAchieved(0) && block.timestamp > icuCrowdsale.endDate());\n', '        super.multivestMint(_address, _amount, _v, _r, _s);\n', '    }\n', '}\n', 'contract Stats {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    MintableToken public token;\n', '    MintableTokenAllocator public allocator;\n', '    ICUCrowdsale public crowdsale;\n', '    ICUStrategy public pricing;\n', '\n', '    constructor(\n', '        MintableToken _token,\n', '        MintableTokenAllocator _allocator,\n', '        ICUCrowdsale _crowdsale,\n', '        ICUStrategy _pricing\n', '    ) public {\n', '        token = _token;\n', '        allocator = _allocator;\n', '        crowdsale = _crowdsale;\n', '        pricing = _pricing;\n', '    }\n', '\n', '    function getTokens(\n', '        uint256,\n', '        uint256 _weiAmount\n', '    ) public view returns (uint256 tokens, uint256 tokensExcludingBonus, uint256 bonus) {\n', '        return pricing.getTokensWithoutRestrictions(_weiAmount);\n', '    }\n', '\n', '    function getWeis(\n', '        uint256,\n', '        uint256 _tokenAmount\n', '    ) public view returns (uint256 totalWeiAmount, uint256 tokensBonus) {\n', '        return pricing.getWeis(0, 0, _tokenAmount);\n', '    }\n', '\n', '    function getStats(uint256 _userType, uint256[7] _ethPerCurrency) public view returns (\n', '        uint256[8] stats,\n', '        uint256[26] tiersData,\n', '        uint256[21] currencyContr //tokensPerEachCurrency,\n', '    ) {\n', '        stats = getStatsData(_userType);\n', '        tiersData = getTiersData(_userType);\n', '        currencyContr = getCurrencyContrData(_userType, _ethPerCurrency);\n', '    }\n', '\n', '    function getTiersData(uint256) public view returns (\n', '        uint256[26] tiersData\n', '    ) {\n', '        uint256[14] memory tiers = pricing.getArrayOfTiers();\n', '        uint256 tierElements = tiers.length.div(2);\n', '        uint256 j = 0;\n', '        for (uint256 i = 0; i <= tierElements; i += tierElements) {\n', '            tiersData[j++] = uint256(1e23).div(tiers[i]);// tokenInUSD;\n', '            tiersData[j++] = 0;// tokenInWei;\n', '            tiersData[j++] = uint256(tiers[i.add(1)]);// maxTokensCollected;\n', '            tiersData[j++] = uint256(tiers[i.add(2)]);// soldTierTokens;\n', '            tiersData[j++] = 0;// discountPercents;\n', '            tiersData[j++] = 0;// bonusPercents;\n', '            tiersData[j++] = uint256(tiers[i.add(4)]);// minInvestInUSD;\n', '            tiersData[j++] = 0;// minInvestInWei;\n', '            tiersData[j++] = 0;// maxInvestInUSD;\n', '            tiersData[j++] = 0;// maxInvestInWei;\n', '            tiersData[j++] = uint256(tiers[i.add(5)]);// startDate;\n', '            tiersData[j++] = uint256(tiers[i.add(6)]);// endDate;\n', '            tiersData[j++] = 1;\n', '        }\n', '\n', '        tiersData[25] = 2;\n', '    }\n', '\n', '    function getStatsData(uint256 _type) public view returns (\n', '        uint256[8] stats\n', '    ) {\n', '        _type = _type;\n', '        stats[0] = token.maxSupply();\n', '        stats[1] = token.totalSupply();\n', '        stats[2] = crowdsale.maxSaleSupply();\n', '        stats[3] = crowdsale.tokensSold();\n', '        stats[4] = uint256(crowdsale.currentState());\n', '        stats[5] = pricing.getActualTierIndex();\n', '        stats[6] = pricing.getTierUnsoldTokens(stats[5]);\n', '        stats[7] = pricing.getMinEtherInvest(stats[5]);\n', '    }\n', '\n', '    function getCurrencyContrData(uint256 _type, uint256[7] _ethPerCurrency) public view returns (\n', '        uint256[21] currencyContr\n', '    ) {\n', '        _type = _type;\n', '        uint256 j = 0;\n', '        for (uint256 i = 0; i < _ethPerCurrency.length; i++) {\n', '            (currencyContr[j++], currencyContr[j++], currencyContr[j++]) = pricing.getTokensWithoutRestrictions(\n', '                _ethPerCurrency[i]\n', '            );\n', '        }\n', '    }\n', '\n', '}\n', 'contract PeriodicTokenVesting is TokenVesting {\n', '    address public unreleasedHolder;\n', '    uint256 public periods;\n', '\n', '    constructor(\n', '        address _beneficiary,\n', '        uint256 _start,\n', '        uint256 _cliff,\n', '        uint256 _duration,\n', '        uint256 _periods,\n', '        bool _revocable,\n', '        address _unreleasedHolder\n', '    )\n', '        public TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable)\n', '    {\n', '        require(_revocable == false || _unreleasedHolder != address(0));\n', '        periods = _periods;\n', '        unreleasedHolder = _unreleasedHolder;\n', '    }\n', '\n', '    /**\n', '    * @dev Calculates the amount that has already vested.\n', '    * @param token ERC20 token which is being vested\n', '    */\n', '    function vestedAmount(ERC20Basic token) public view returns (uint256) {\n', '        uint256 currentBalance = token.balanceOf(this);\n', '        uint256 totalBalance = currentBalance.add(released[token]);\n', '\n', '        if (now < cliff) {\n', '            return 0;\n', '        } else if (now >= start.add(duration * periods) || revoked[token]) {\n', '            return totalBalance;\n', '        } else {\n', '\n', '            uint256 periodTokens = totalBalance.div(periods);\n', '\n', '            uint256 periodsOver = now.sub(start).div(duration);\n', '\n', '            if (periodsOver >= periods) {\n', '                return totalBalance;\n', '            }\n', '\n', '            return periodTokens.mul(periodsOver);\n', '        }\n', '    }\n', '\n', '    /**\n', ' * @notice Allows the owner to revoke the vesting. Tokens already vested\n', ' * remain in the contract, the rest are returned to the owner.\n', ' * @param token ERC20 token which is being vested\n', ' */\n', '    function revoke(ERC20Basic token) public onlyOwner {\n', '        require(revocable);\n', '        require(!revoked[token]);\n', '\n', '        uint256 balance = token.balanceOf(this);\n', '\n', '        uint256 unreleased = releasableAmount(token);\n', '        uint256 refund = balance.sub(unreleased);\n', '\n', '        revoked[token] = true;\n', '\n', '        token.safeTransfer(unreleasedHolder, refund);\n', '\n', '        emit Revoked();\n', '    }\n', '}\n', 'contract ICUAllocation is Ownable {\n', '\n', '    using SafeERC20 for ERC20Basic;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant BOUNTY_TOKENS = 47000000e18;\n', '    uint256 public constant MAX_TREASURY_TOKENS = 2350000000e18;\n', '\n', '    uint256 public icoEndTime;\n', '\n', '    address[] public vestings;\n', '\n', '    address public bountyAddress;\n', '\n', '    address public treasuryAddress;\n', '\n', '    bool public isBountySent;\n', '\n', '    bool public isTeamSent;\n', '\n', '    event VestingCreated(\n', '        address _vesting,\n', '        address _beneficiary,\n', '        uint256 _start,\n', '        uint256 _cliff,\n', '        uint256 _duration,\n', '        uint256 _periods,\n', '        bool _revocable\n', '    );\n', '\n', '    event VestingRevoked(address _vesting);\n', '\n', '    constructor(address _bountyAddress, address _treasuryAddress) public {\n', '        require(_bountyAddress != address(0) && _treasuryAddress != address(0));\n', '        bountyAddress = _bountyAddress;\n', '        treasuryAddress = _treasuryAddress;\n', '    }\n', '\n', '    function setICOEndTime(uint256 _icoEndTime) public onlyOwner {\n', '        icoEndTime = _icoEndTime;\n', '    }\n', '\n', '    function allocateBounty(MintableTokenAllocator _allocator, ICUCrowdsale _crowdsale) public onlyOwner {\n', '        require(!isBountySent && icoEndTime < block.timestamp && _crowdsale.isSoftCapAchieved(0));\n', '\n', '        isBountySent = true;\n', '        _allocator.allocate(bountyAddress, BOUNTY_TOKENS);\n', '    }\n', '\n', '    function allocateTreasury(MintableTokenAllocator _allocator) public onlyOwner {\n', "        require(icoEndTime < block.timestamp, 'ICO is not ended');\n", "        require(isBountySent, 'Bounty is not sent');\n", "        require(isTeamSent, 'Team vesting is not created');\n", "        require(MAX_TREASURY_TOKENS >= _allocator.tokensAvailable(), 'Unsold tokens are not burned');\n", '\n', '        _allocator.allocate(treasuryAddress, _allocator.tokensAvailable());\n', '    }\n', '\n', '    function createVesting(\n', '        address _beneficiary,\n', '        uint256 _start,\n', '        uint256 _cliff,\n', '        uint256 _duration,\n', '        uint256 _periods,\n', '        bool _revocable,\n', '        address _unreleasedHolder,\n', '        MintableTokenAllocator _allocator,\n', '        uint256 _amount\n', '    ) public onlyOwner returns (PeriodicTokenVesting) {\n', '        require(icoEndTime > 0 && _amount > 0);\n', '\n', '        isTeamSent = true;\n', '\n', '        PeriodicTokenVesting vesting = new PeriodicTokenVesting(\n', '            _beneficiary, _start, _cliff, _duration, _periods, _revocable, _unreleasedHolder\n', '        );\n', '\n', '        vestings.push(vesting);\n', '\n', '        emit VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\n', '\n', '        _allocator.allocate(address(vesting), _amount);\n', '\n', '        return vesting;\n', '    }\n', '\n', '    function revokeVesting(PeriodicTokenVesting _vesting, ERC20Basic token) public onlyOwner() {\n', '        _vesting.revoke(token);\n', '\n', '        emit VestingRevoked(_vesting);\n', '    }\n', '}']