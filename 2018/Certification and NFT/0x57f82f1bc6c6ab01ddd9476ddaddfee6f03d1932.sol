['pragma solidity ^0.4.18;\n', '\n', 'library SafeMath {\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a);\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= a);\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((b == 0 || (c = a * b) / b == a));\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'interface Token {\n', '    function mintTokens(address _recipient, uint _value) external returns(bool success);\n', '    function balanceOf(address _holder) public returns(uint256 tokens);\n', '    function totalSupply() public returns(uint256 _totalSupply);\n', '}\n', '\n', 'contract Presale {\n', '    using SafeMath for uint256;\n', '    \n', '    Token public tokenContract;\n', '\n', '    address public beneficiaryAddress;\n', '    uint256 public tokensPerEther;\n', '    uint256 public minimumContribution;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    uint256 public hardcapInEther;\n', '    uint256 public fundsRaised;\n', '    \n', '\n', '    mapping (address => uint256) public contributionBy;\n', '    \n', '    event ContributionReceived(address contributer, uint256 amount, uint256 totalContributions,uint totalAmountRaised);\n', '    event FundsWithdrawn(uint256 funds, address beneficiaryAddress);\n', '\n', '    function Presale(\n', '        address _beneficiaryAddress,\n', '        uint256 _tokensPerEther,\n', '        uint256 _minimumContributionInFinney,\n', '        uint256 _startTime,\n', '        uint256 _saleLengthinHours,\n', '        address _tokenContractAddress,\n', '        uint256 _hardcapInEther) {\n', '        startTime = _startTime;\n', '        endTime = startTime + (_saleLengthinHours * 1 hours);\n', '        beneficiaryAddress = _beneficiaryAddress;\n', '        tokensPerEther = _tokensPerEther;\n', '        minimumContribution = _minimumContributionInFinney * 1 finney;\n', '        tokenContract = Token(_tokenContractAddress);\n', '        hardcapInEther = _hardcapInEther * 1 ether;\n', '    }\n', '\n', '    function () public payable {\n', '        require(presaleOpen());\n', '        require(msg.value >= minimumContribution);\n', '        uint256 contribution = msg.value;\n', '        uint256 refund;\n', '        if(this.balance > hardcapInEther){\n', '            refund = this.balance.sub(hardcapInEther);\n', '            contribution = msg.value.sub(refund);\n', '            msg.sender.transfer(refund);\n', '        }\n', '        fundsRaised = fundsRaised.add(contribution);\n', '        contributionBy[msg.sender] = contributionBy[msg.sender].add(contribution);\n', '        tokenContract.mintTokens(msg.sender, contribution.mul(tokensPerEther));\n', '        ContributionReceived(msg.sender, contribution, contributionBy[msg.sender], this.balance);\n', '    }\n', '\n', '\n', '    function presaleOpen() public view returns(bool) {return(now >= startTime &&\n', '                                                            now <= endTime &&\n', '                                                            fundsRaised < hardcapInEther);} \n', '\n', '    function withdrawFunds() public {\n', '        require(this.balance > 0);\n', '        beneficiaryAddress.transfer(this.balance);\n', '        FundsWithdrawn(this.balance, beneficiaryAddress);\n', '    }\n', '}']