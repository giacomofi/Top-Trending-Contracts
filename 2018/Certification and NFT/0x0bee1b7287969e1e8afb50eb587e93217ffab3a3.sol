['pragma solidity ^0.4.18;\n', '/**\n', '* @title ICO CONTRACT\n', '* @dev ERC-20 Token Standard Complian\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract token {\n', '\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '}\n', '\n', '\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '  // The token being sold\n', '  token public token_reward;\n', '  // start and end timestamps where investments are allowed (both inclusive\n', '  \n', '  uint256 public start_time = now; //for testing\n', '  //uint256 public start_time = 1517846400; //02/05/2018 @ 4:00pm (UTC) or 5 PM (UTC + 1)\n', '  uint256 public end_Time = 1524355200; // 04/22/2018 @ 12:00am (UTC)\n', '\n', '  uint256 public phase_1_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_2_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_3_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_4_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_5_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '\n', '  uint256 public phase_1_bonus  = 40;\n', '  uint256 public phase_2_bonus  = 20;\n', '  uint256 public phase_3_bonus  = 15;\n', '  uint256 public phase_4_bonus  = 10;\n', '  uint256 public phase_5_bonus  = 5;\n', '\n', '  uint256 public token_price  = 2;// 2 cents\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '  // Ether to $ price\n', '  uint256 public eth_to_usd = 1000;\n', '  // amount of raised money in wei\n', '  uint256 public weiRaised;\n', '  /**\n', '   * event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  // rate change event\n', '  event EthToUsdChanged(address indexed owner, uint256 old_eth_to_usd, uint256 new_eth_to_usd);\n', '  \n', '  // constructor\n', '  function Crowdsale(address tokenContractAddress) public{\n', '    wallet = 0x1aC024482b91fa9AaF22450Ff60680BAd60bF8D3;//wallet where ETH will be transferred\n', '    token_reward = token(tokenContractAddress);\n', '  }\n', '  \n', ' function tokenBalance() constant public returns (uint256){\n', '    return token_reward.balanceOf(this);\n', '  }\n', '\n', '  function getRate() constant public returns (uint256){\n', '    return eth_to_usd.mul(100).div(token_price);\n', '  }\n', '\n', '  // @return true if the transaction can buy tokens\n', '  function validPurchase() internal constant returns (bool) {\n', '    bool withinPeriod = now >= start_time && now <= end_Time;\n', '    bool allPhaseFinished = phase_5_remaining_tokens > 0;\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    bool minPurchase = eth_to_usd*msg.value >= 100; // minimum purchase $100\n', '    return withinPeriod && nonZeroPurchase && allPhaseFinished && minPurchase;\n', '  }\n', '\n', '  // @return true if the admin can send tokens manually\n', '  function validPurchaseForManual() internal constant returns (bool) {\n', '    bool withinPeriod = now >= start_time && now <= end_Time;\n', '    bool allPhaseFinished = phase_5_remaining_tokens > 0;\n', '    return withinPeriod && allPhaseFinished;\n', '  }\n', '\n', '\n', '  // check token availibility for current phase and max allowed token balance\n', '  function checkAndUpdateTokenForManual(uint256 _tokens) internal returns (bool){\n', '    if(phase_1_remaining_tokens > 0){\n', '      if(_tokens > phase_1_remaining_tokens){\n', '        uint256 tokens_from_phase_2 = _tokens.sub(phase_1_remaining_tokens);\n', '        phase_1_remaining_tokens = 0;\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(tokens_from_phase_2);\n', '      }else{\n', '        phase_1_remaining_tokens = phase_1_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_2_remaining_tokens > 0){\n', '      if(_tokens > phase_2_remaining_tokens){\n', '        uint256 tokens_from_phase_3 = _tokens.sub(phase_2_remaining_tokens);\n', '        phase_2_remaining_tokens = 0;\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(tokens_from_phase_3);\n', '      }else{\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_3_remaining_tokens > 0){\n', '      if(_tokens > phase_3_remaining_tokens){\n', '        uint256 tokens_from_phase_4 = _tokens.sub(phase_3_remaining_tokens);\n', '        phase_3_remaining_tokens = 0;\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(tokens_from_phase_4);\n', '      }else{\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_4_remaining_tokens > 0){\n', '      if(_tokens > phase_4_remaining_tokens){\n', '        uint256 tokens_from_phase_5 = _tokens.sub(phase_4_remaining_tokens);\n', '        phase_4_remaining_tokens = 0;\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(tokens_from_phase_5);\n', '      }else{\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_5_remaining_tokens > 0){\n', '      if(_tokens > phase_5_remaining_tokens){\n', '        return false;\n', '      }else{\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(_tokens);\n', '       }\n', '    }else{\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // function to transfer token manually\n', '  function transferManually(uint256 _tokens, address to_address) onlyOwner public returns (bool){\n', '    require(to_address != 0x0);\n', '    require(validPurchaseForManual());\n', '    require(checkAndUpdateTokenForManual(_tokens));\n', '    token_reward.transfer(to_address, _tokens);\n', '    return true;\n', '  }\n', '\n', '\n', '  // check token availibility for current phase and max allowed token balance\n', '  function transferIfTokenAvailable(uint256 _tokens, uint256 _weiAmount, address _beneficiary) internal returns (bool){\n', '\n', '    uint256 total_token_to_transfer = 0;\n', '    uint256 bonus = 0;\n', '    if(phase_1_remaining_tokens > 0){\n', '      if(_tokens > phase_1_remaining_tokens){\n', '        uint256 tokens_from_phase_2 = _tokens.sub(phase_1_remaining_tokens);\n', '        bonus = (phase_1_remaining_tokens.mul(phase_1_bonus).div(100)).add(tokens_from_phase_2.mul(phase_2_bonus).div(100));\n', '        phase_1_remaining_tokens = 0;\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(tokens_from_phase_2);\n', '      }else{\n', '        phase_1_remaining_tokens = phase_1_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_1_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_2_remaining_tokens > 0){\n', '      if(_tokens > phase_2_remaining_tokens){\n', '        uint256 tokens_from_phase_3 = _tokens.sub(phase_2_remaining_tokens);\n', '        bonus = (phase_2_remaining_tokens.mul(phase_2_bonus).div(100)).add(tokens_from_phase_3.mul(phase_3_bonus).div(100));\n', '        phase_2_remaining_tokens = 0;\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(tokens_from_phase_3);\n', '      }else{\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_2_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_3_remaining_tokens > 0){\n', '      if(_tokens > phase_3_remaining_tokens){\n', '        uint256 tokens_from_phase_4 = _tokens.sub(phase_3_remaining_tokens);\n', '        bonus = (phase_3_remaining_tokens.mul(phase_3_bonus).div(100)).add(tokens_from_phase_4.mul(phase_4_bonus).div(100));\n', '        phase_3_remaining_tokens = 0;\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(tokens_from_phase_4);\n', '      }else{\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_3_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_4_remaining_tokens > 0){\n', '      if(_tokens > phase_4_remaining_tokens){\n', '        uint256 tokens_from_phase_5 = _tokens.sub(phase_4_remaining_tokens);\n', '        bonus = (phase_4_remaining_tokens.mul(phase_4_bonus).div(100)).add(tokens_from_phase_5.mul(phase_5_bonus).div(100));\n', '        phase_4_remaining_tokens = 0;\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(tokens_from_phase_5);\n', '      }else{\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_4_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_5_remaining_tokens > 0){\n', '      if(_tokens > phase_5_remaining_tokens){\n', '        total_token_to_transfer = 0;\n', '      }else{\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_5_bonus).div(100);\n', '        total_token_to_transfer = _tokens + bonus;\n', '      }\n', '    }else{\n', '      total_token_to_transfer = 0;\n', '    }\n', '    if(total_token_to_transfer > 0){\n', '      token_reward.transfer(_beneficiary, total_token_to_transfer);\n', '      TokenPurchase(msg.sender, _beneficiary, _weiAmount, total_token_to_transfer);\n', '      return true;\n', '    }else{\n', '      return false;\n', '    }\n', '    \n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () payable public{\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    require(beneficiary != 0x0);\n', '    require(validPurchase());\n', '    uint256 weiAmount = msg.value;\n', '    // calculate token amount to be created\n', '    uint256 tokens = (weiAmount.mul(getRate())).div(10 ** uint256(10));\n', '    // Check is there are enough token available for current phase and per person  \n', '    require(transferIfTokenAvailable(tokens, weiAmount, beneficiary));\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    \n', '    forwardFunds();\n', '  }\n', '  \n', '  // send ether to the fund collection wallet\n', '  // override to create custom fund forwarding mechanisms\n', '  function forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '  \n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > end_Time;\n', '  }\n', '  // function to transfer token back to owner\n', '  function transferBack(uint256 tokens, address to_address) onlyOwner public returns (bool){\n', '    token_reward.transfer(to_address, tokens);\n', '    return true;\n', '  }\n', '  // function to change rate\n', '  function changeEth_to_usd(uint256 _eth_to_usd) onlyOwner public returns (bool){\n', '    EthToUsdChanged(msg.sender, eth_to_usd, _eth_to_usd);\n', '    eth_to_usd = _eth_to_usd;\n', '    return true;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '/**\n', '* @title ICO CONTRACT\n', '* @dev ERC-20 Token Standard Complian\n', '*/\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract token {\n', '\n', '  function balanceOf(address _owner) public constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '}\n', '\n', '\n', 'contract Crowdsale is Ownable {\n', '  using SafeMath for uint256;\n', '  // The token being sold\n', '  token public token_reward;\n', '  // start and end timestamps where investments are allowed (both inclusive\n', '  \n', '  uint256 public start_time = now; //for testing\n', '  //uint256 public start_time = 1517846400; //02/05/2018 @ 4:00pm (UTC) or 5 PM (UTC + 1)\n', '  uint256 public end_Time = 1524355200; // 04/22/2018 @ 12:00am (UTC)\n', '\n', '  uint256 public phase_1_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_2_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_3_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_4_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '  uint256 public phase_5_remaining_tokens  = 50000000 * (10 ** uint256(8));\n', '\n', '  uint256 public phase_1_bonus  = 40;\n', '  uint256 public phase_2_bonus  = 20;\n', '  uint256 public phase_3_bonus  = 15;\n', '  uint256 public phase_4_bonus  = 10;\n', '  uint256 public phase_5_bonus  = 5;\n', '\n', '  uint256 public token_price  = 2;// 2 cents\n', '\n', '  // address where funds are collected\n', '  address public wallet;\n', '  // Ether to $ price\n', '  uint256 public eth_to_usd = 1000;\n', '  // amount of raised money in wei\n', '  uint256 public weiRaised;\n', '  /**\n', '   * event for token purchase logging\n', '   * @param purchaser who paid for the tokens\n', '   * @param beneficiary who got the tokens\n', '   * @param value weis paid for purchase\n', '   * @param amount amount of tokens purchased\n', '   */\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  // rate change event\n', '  event EthToUsdChanged(address indexed owner, uint256 old_eth_to_usd, uint256 new_eth_to_usd);\n', '  \n', '  // constructor\n', '  function Crowdsale(address tokenContractAddress) public{\n', '    wallet = 0x1aC024482b91fa9AaF22450Ff60680BAd60bF8D3;//wallet where ETH will be transferred\n', '    token_reward = token(tokenContractAddress);\n', '  }\n', '  \n', ' function tokenBalance() constant public returns (uint256){\n', '    return token_reward.balanceOf(this);\n', '  }\n', '\n', '  function getRate() constant public returns (uint256){\n', '    return eth_to_usd.mul(100).div(token_price);\n', '  }\n', '\n', '  // @return true if the transaction can buy tokens\n', '  function validPurchase() internal constant returns (bool) {\n', '    bool withinPeriod = now >= start_time && now <= end_Time;\n', '    bool allPhaseFinished = phase_5_remaining_tokens > 0;\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    bool minPurchase = eth_to_usd*msg.value >= 100; // minimum purchase $100\n', '    return withinPeriod && nonZeroPurchase && allPhaseFinished && minPurchase;\n', '  }\n', '\n', '  // @return true if the admin can send tokens manually\n', '  function validPurchaseForManual() internal constant returns (bool) {\n', '    bool withinPeriod = now >= start_time && now <= end_Time;\n', '    bool allPhaseFinished = phase_5_remaining_tokens > 0;\n', '    return withinPeriod && allPhaseFinished;\n', '  }\n', '\n', '\n', '  // check token availibility for current phase and max allowed token balance\n', '  function checkAndUpdateTokenForManual(uint256 _tokens) internal returns (bool){\n', '    if(phase_1_remaining_tokens > 0){\n', '      if(_tokens > phase_1_remaining_tokens){\n', '        uint256 tokens_from_phase_2 = _tokens.sub(phase_1_remaining_tokens);\n', '        phase_1_remaining_tokens = 0;\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(tokens_from_phase_2);\n', '      }else{\n', '        phase_1_remaining_tokens = phase_1_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_2_remaining_tokens > 0){\n', '      if(_tokens > phase_2_remaining_tokens){\n', '        uint256 tokens_from_phase_3 = _tokens.sub(phase_2_remaining_tokens);\n', '        phase_2_remaining_tokens = 0;\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(tokens_from_phase_3);\n', '      }else{\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_3_remaining_tokens > 0){\n', '      if(_tokens > phase_3_remaining_tokens){\n', '        uint256 tokens_from_phase_4 = _tokens.sub(phase_3_remaining_tokens);\n', '        phase_3_remaining_tokens = 0;\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(tokens_from_phase_4);\n', '      }else{\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_4_remaining_tokens > 0){\n', '      if(_tokens > phase_4_remaining_tokens){\n', '        uint256 tokens_from_phase_5 = _tokens.sub(phase_4_remaining_tokens);\n', '        phase_4_remaining_tokens = 0;\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(tokens_from_phase_5);\n', '      }else{\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(_tokens);\n', '      }\n', '      return true;\n', '    }else if(phase_5_remaining_tokens > 0){\n', '      if(_tokens > phase_5_remaining_tokens){\n', '        return false;\n', '      }else{\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(_tokens);\n', '       }\n', '    }else{\n', '      return false;\n', '    }\n', '  }\n', '\n', '  // function to transfer token manually\n', '  function transferManually(uint256 _tokens, address to_address) onlyOwner public returns (bool){\n', '    require(to_address != 0x0);\n', '    require(validPurchaseForManual());\n', '    require(checkAndUpdateTokenForManual(_tokens));\n', '    token_reward.transfer(to_address, _tokens);\n', '    return true;\n', '  }\n', '\n', '\n', '  // check token availibility for current phase and max allowed token balance\n', '  function transferIfTokenAvailable(uint256 _tokens, uint256 _weiAmount, address _beneficiary) internal returns (bool){\n', '\n', '    uint256 total_token_to_transfer = 0;\n', '    uint256 bonus = 0;\n', '    if(phase_1_remaining_tokens > 0){\n', '      if(_tokens > phase_1_remaining_tokens){\n', '        uint256 tokens_from_phase_2 = _tokens.sub(phase_1_remaining_tokens);\n', '        bonus = (phase_1_remaining_tokens.mul(phase_1_bonus).div(100)).add(tokens_from_phase_2.mul(phase_2_bonus).div(100));\n', '        phase_1_remaining_tokens = 0;\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(tokens_from_phase_2);\n', '      }else{\n', '        phase_1_remaining_tokens = phase_1_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_1_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_2_remaining_tokens > 0){\n', '      if(_tokens > phase_2_remaining_tokens){\n', '        uint256 tokens_from_phase_3 = _tokens.sub(phase_2_remaining_tokens);\n', '        bonus = (phase_2_remaining_tokens.mul(phase_2_bonus).div(100)).add(tokens_from_phase_3.mul(phase_3_bonus).div(100));\n', '        phase_2_remaining_tokens = 0;\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(tokens_from_phase_3);\n', '      }else{\n', '        phase_2_remaining_tokens = phase_2_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_2_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_3_remaining_tokens > 0){\n', '      if(_tokens > phase_3_remaining_tokens){\n', '        uint256 tokens_from_phase_4 = _tokens.sub(phase_3_remaining_tokens);\n', '        bonus = (phase_3_remaining_tokens.mul(phase_3_bonus).div(100)).add(tokens_from_phase_4.mul(phase_4_bonus).div(100));\n', '        phase_3_remaining_tokens = 0;\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(tokens_from_phase_4);\n', '      }else{\n', '        phase_3_remaining_tokens = phase_3_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_3_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_4_remaining_tokens > 0){\n', '      if(_tokens > phase_4_remaining_tokens){\n', '        uint256 tokens_from_phase_5 = _tokens.sub(phase_4_remaining_tokens);\n', '        bonus = (phase_4_remaining_tokens.mul(phase_4_bonus).div(100)).add(tokens_from_phase_5.mul(phase_5_bonus).div(100));\n', '        phase_4_remaining_tokens = 0;\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(tokens_from_phase_5);\n', '      }else{\n', '        phase_4_remaining_tokens = phase_4_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_4_bonus).div(100);\n', '      }\n', '      total_token_to_transfer = _tokens + bonus;\n', '    }else if(phase_5_remaining_tokens > 0){\n', '      if(_tokens > phase_5_remaining_tokens){\n', '        total_token_to_transfer = 0;\n', '      }else{\n', '        phase_5_remaining_tokens = phase_5_remaining_tokens.sub(_tokens);\n', '        bonus = _tokens.mul(phase_5_bonus).div(100);\n', '        total_token_to_transfer = _tokens + bonus;\n', '      }\n', '    }else{\n', '      total_token_to_transfer = 0;\n', '    }\n', '    if(total_token_to_transfer > 0){\n', '      token_reward.transfer(_beneficiary, total_token_to_transfer);\n', '      TokenPurchase(msg.sender, _beneficiary, _weiAmount, total_token_to_transfer);\n', '      return true;\n', '    }else{\n', '      return false;\n', '    }\n', '    \n', '  }\n', '\n', '  // fallback function can be used to buy tokens\n', '  function () payable public{\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  // low level token purchase function\n', '  function buyTokens(address beneficiary) public payable {\n', '    require(beneficiary != 0x0);\n', '    require(validPurchase());\n', '    uint256 weiAmount = msg.value;\n', '    // calculate token amount to be created\n', '    uint256 tokens = (weiAmount.mul(getRate())).div(10 ** uint256(10));\n', '    // Check is there are enough token available for current phase and per person  \n', '    require(transferIfTokenAvailable(tokens, weiAmount, beneficiary));\n', '    // update state\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    \n', '    forwardFunds();\n', '  }\n', '  \n', '  // send ether to the fund collection wallet\n', '  // override to create custom fund forwarding mechanisms\n', '  function forwardFunds() internal {\n', '    wallet.transfer(msg.value);\n', '  }\n', '  \n', '  // @return true if crowdsale event has ended\n', '  function hasEnded() public constant returns (bool) {\n', '    return now > end_Time;\n', '  }\n', '  // function to transfer token back to owner\n', '  function transferBack(uint256 tokens, address to_address) onlyOwner public returns (bool){\n', '    token_reward.transfer(to_address, tokens);\n', '    return true;\n', '  }\n', '  // function to change rate\n', '  function changeEth_to_usd(uint256 _eth_to_usd) onlyOwner public returns (bool){\n', '    EthToUsdChanged(msg.sender, eth_to_usd, _eth_to_usd);\n', '    eth_to_usd = _eth_to_usd;\n', '    return true;\n', '  }\n', '}']
