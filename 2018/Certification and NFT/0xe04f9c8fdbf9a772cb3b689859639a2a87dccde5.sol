['pragma solidity 0.4.25;\n', '\n', '/**\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* \n', '* Web              - https://333eth.io\n', '* \n', '* Twitter          - https://twitter.com/333eth_io\n', '* \n', '* Telegram_channel - https://t.me/Ethereum333\n', '* \n', '* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\n', '* \n', '* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\n', '* \n', '* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\n', '* \n', '* Email:             mailto:support(at sign)333eth.io\n', '* \n', '* \n', '* \n', '* When the timer reaches zero then latest bettor takes the bank. Each bet restart a timer again.\n', '* \n', '* Bet in 1 ETH - the timer turns on for 3 minutes 33 seconds.\n', '* \n', '* Bet 0.1ETH - the timer turns on for 6 minutes 33 seconds.\n', '* \n', '* Bet 0.01 ETH - the timer turns on for 9 minutes 33 seconds.\n', '* You need to send such bet`s amounts. If more was sent, then contract will return the difference to the wallet. For example, sending 0.99 ETH system will perceive as a contribution to 0.1 ETH and difference 0.89\n', '* \n', '* The game does not have a fraudulent Ponzi scheme. No fraudulent referral programs.\n', '* \n', '* In the contract of the game realized the refusal of ownership. It is impossible to stop the flow of bets. Bet from smart contracts is prohibited.\n', '* \n', '* Eth distribution:\n', '* 50% paid to the winner.\n', '* 40% is transferred to the next level of the game with the same rules and so on.\n', '* 10% commission (7.5% of them to shareholders, 2.5% of the administration).\n', '* \n', '* RECOMMENDED GAS LIMIT: 100000\n', '* \n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '*/\n', '\n', '\n', 'library Zero {\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function requireNotZero(uint val) internal pure {\n', '    require(val != 0, "require not zero value");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '\n', '  function isZero(uint a) internal pure returns(bool) {\n', '    return a == 0;\n', '  }\n', '\n', '  function notZero(uint a) internal pure returns(bool) {\n', '    return a != 0;\n', '  }\n', '}\n', '\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  \n', '  // storage\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '\n', '  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\n', '    return Percent.percent(p.num, p.den);\n', '  }\n', '\n', '  // memory \n', '  function mmul(percent memory p, uint a) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function mdiv(percent memory p, uint a) internal pure returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function msub(percent memory p, uint a) internal pure returns (uint) {\n', '    uint b = mmul(p, a);\n', '    if (b >= a) {\n', '      return 0;\n', '    }\n', '    return a - b;\n', '  }\n', '\n', '  function madd(percent memory p, uint a) internal pure returns (uint) {\n', '    return a + mmul(p, a);\n', '  }\n', '}\n', '\n', 'library Address {\n', '  function toAddress(bytes source) internal pure returns(address addr) {\n', '    // solium-disable security/no-inline-assembly\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '\n', '  function isNotContract(address addr) internal view returns(bool) {\n', '    // solium-disable security/no-inline-assembly\n', '    uint length;\n', '    assembly { length := extcodesize(addr) }\n', '    return length == 0;\n', '  }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '  address private owner;\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function disown() internal {\n', '    delete owner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', 'library Timer {\n', '  using SafeMath for uint;\n', '  struct timer {\n', '    uint duration;\n', '    uint startup;\n', '  }\n', '  function start(timer storage t, uint duration) internal {\n', '    t.startup = now;\n', '    t.duration = duration;\n', '  }\n', '\n', '  function timeLeft(timer storage t) internal view returns (uint) {\n', '    if (now >= t.startup.add(t.duration)) {\n', '      return 0;\n', '    }\n', '    return (t.startup+t.duration).sub(now);\n', '  }\n', '}\n', '\n', '\n', 'library Bet {\n', '  struct bet {\n', '    address bettor;\n', '    uint amount;\n', '    uint excess;\n', '    uint duration;\n', '  }\n', '\n', '  function New(address bettor, uint value) internal pure returns(bet memory b ) {\n', '    \n', '    (uint[3] memory vals, uint[3] memory durs) = bets();\n', '    if (value >= vals[0]) {\n', '      b.amount = vals[0];\n', '      b.duration = durs[0];\n', '    } else if (vals[1] <= value && value < vals[0]) {\n', '      b.amount = vals[1];\n', '      b.duration = durs[1];\n', '    } else if (vals[2] <= value && value < vals[1]) {\n', '      b.amount = vals[2];\n', '      b.duration = durs[2];\n', '    } else {\n', '      return b;\n', '    }\n', '\n', '    b.bettor = bettor;\n', '    b.excess = value - b.amount;\n', '  }\n', '\n', '  function bets() internal pure returns(uint[3] memory vals, uint[3] memory durs) {\n', '    (vals[0], vals[1], vals[2]) = (1 ether, 0.1 ether, 0.01 ether); \n', '    (durs[0], durs[1], durs[2]) = (3 minutes + 33 seconds, 6 minutes + 33 seconds, 9 minutes + 33 seconds);\n', '  }\n', '\n', '  function transferExcess(bet memory b) internal {\n', '    b.bettor.transfer(b.excess);\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract LastHero is Accessibility {\n', '  using Percent for Percent.percent;\n', '  using Timer for Timer.timer;\n', '  using Address for address;\n', '  using Bet for Bet.bet;\n', '  using Zero for *;\n', '  \n', '  Percent.percent private m_bankPercent = Percent.percent(50,100);\n', '  Percent.percent private m_nextLevelPercent = Percent.percent(40,100);\n', '  Percent.percent private m_adminsPercent = Percent.percent(10,100);\n', '  \n', '  uint public nextLevelBankAmount;\n', '  uint public bankAmount;\n', '  uint public level;\n', '  address public bettor;\n', '  address public adminsAddress;\n', '  Timer.timer private m_timer;\n', '\n', '  modifier notFromContract() {\n', '    require(msg.sender.isNotContract(), "only externally accounts");\n', '    _;\n', '  }\n', '\n', '  event LogSendExcessOfEther(address indexed addr, uint excess, uint when);\n', '  event LogNewWinner(address indexed addr, uint indexed level, uint amount, uint when);\n', '  event LogNewLevel(uint indexed level, uint bankAmount, uint when);\n', '  event LogNewBet(address indexed addr, uint indexed amount, uint duration, uint indexed level, uint when);\n', '  event LogDisown(uint when);\n', '\n', '\n', '  constructor() public {\n', '    level = 1;\n', '    emit LogNewLevel(level, address(this).balance, now);\n', '    adminsAddress = msg.sender;\n', '    m_timer.duration = uint(-1);\n', '  }\n', '\n', '  function() public payable {\n', '    doBet();\n', '  }\n', '\n', '  function doDisown() public onlyOwner {\n', '    disown();\n', '    emit LogDisown(now);\n', '  }\n', '\n', '  function setAdminsAddress(address addr) public onlyOwner {\n', '    addr.requireNotZero();\n', '    adminsAddress = addr;\n', '  }\n', '\n', '  function bankPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_bankPercent.num, m_bankPercent.den);\n', '  }\n', '\n', '  function nextLevelPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_nextLevelPercent.num, m_nextLevelPercent.den);\n', '  }\n', '\n', '  function adminsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\n', '  }\n', '\n', '  function timeLeft() public view returns(uint duration) {\n', '    duration = m_timer.timeLeft();\n', '  }\n', '\n', '  function timerInfo() public view returns(uint startup, uint duration) {\n', '    (startup, duration) = (m_timer.startup, m_timer.duration);\n', '  }\n', '\n', '  function durationForBetAmount(uint betAmount) public view returns(uint duration) {\n', '    Bet.bet memory bet = Bet.New(msg.sender, betAmount);\n', '    duration = bet.duration;\n', '  }\n', '\n', '  function availableBets() public view returns(uint[3] memory vals, uint[3] memory durs) {\n', '    (vals, durs) = Bet.bets();\n', '  }\n', '\n', '  function doBet() public payable notFromContract {\n', '\n', '    // send ether to bettor if needed\n', '    if (m_timer.timeLeft().isZero()) {\n', '      bettor.transfer(bankAmount);\n', '      emit LogNewWinner(bettor, level, bankAmount, now);\n', '\n', '      bankAmount = nextLevelBankAmount;\n', '      nextLevelBankAmount = 0;\n', '      level++;\n', '      emit LogNewLevel(level, bankAmount, now);\n', '    }\n', '\n', '    Bet.bet memory bet = Bet.New(msg.sender, msg.value);\n', '    bet.amount.requireNotZero();\n', '\n', '    // send bet`s excess of ether if needed\n', '    if (bet.excess.notZero()) {\n', '      bet.transferExcess();\n', '      emit LogSendExcessOfEther(bet.bettor, bet.excess, now);\n', '    }\n', '\n', '    // commision\n', '    nextLevelBankAmount += m_nextLevelPercent.mul(bet.amount);\n', '    bankAmount += m_bankPercent.mul(bet.amount);\n', '    adminsAddress.send(m_adminsPercent.mul(bet.amount));\n', '  \n', '    m_timer.start(bet.duration);\n', '    bettor = bet.bettor;\n', '\n', '    emit LogNewBet(bet.bettor, bet.amount, bet.duration, level, now);\n', '  }\n', '}']