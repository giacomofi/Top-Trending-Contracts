['pragma solidity ^0.4.18;\n', '\n', 'contract ERC721 {\n', '    // ERC20 compatible functions\n', '    // use variable getter\n', '    // function name() constant returns (string name);\n', '    // function symbol() constant returns (string symbol);\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '    function ownerOf(uint256 _tokenId) public constant returns (address owner);\n', '    function approve(address _to, uint256 _tokenId) public ;\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 tokenId);\n', '    function transfer(address _to, uint256 _tokenId) external ;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    \n', '    // Optional\n', '    // function takeOwnership(uint256 _tokenId) public ;\n', '    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external constant returns (uint tokenId);\n', '    // function tokenMetadata(uint256 _tokenId) public constant returns (string infoUrl);\n', '    \n', '    // Events\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '}\n', '\n', 'contract ERC20 {\n', '    // Get the total token supply\n', '    function totalSupply() public constant returns (uint256 _totalSupply);\n', ' \n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', ' \n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    \n', '    // transfer _value amount of token approved by address _from\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    \n', '    // approve an address with _value amount of tokens\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    // get remaining token approved by _owner to _spender\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  \n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', ' \n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract VirtualGift is ERC721 {\n', '    \n', '    // load GTO to Virtual Gift contract, to interact with GTO\n', '    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n', '    \n', '    // Gift data\n', '    struct Gift {\n', '        // gift price\n', '        uint256 price;\n', '        // gift description\n', '        string description;\n', '    }\n', '    \n', '    address public owner;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\n', '    event Creation(address indexed _owner, uint256 indexed GiftId);\n', '    \n', '    string public constant name = "VirtualGift";\n', '    string public constant symbol = "VTG";\n', '    \n', '    // Gift object storage in array\n', '    Gift[] giftStorage;\n', '    \n', '    // total Gift of an address\n', '    mapping(address => uint256) private balances;\n', '    \n', '    // index of Gift array to Owner\n', '    mapping(uint256 => address) private GiftIndexToOwners;\n', '    \n', '    // Gift exist or not\n', '    mapping(uint256 => bool) private GiftExists;\n', '    \n', '    // mapping from owner and approved address to GiftId\n', '    mapping(address => mapping (address => uint256)) private allowed;\n', '    \n', '    // mapping from owner and index Gift of owner to GiftId\n', '    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\n', '    \n', '    // Gift metadata\n', '    mapping(uint256 => string) GiftLinks;\n', '\n', '    modifier onlyOwner(){\n', '         require(msg.sender == owner);\n', '         _;\n', '    }\n', '\n', '    modifier onlyGiftOwner(uint256 GiftId){\n', '        require(msg.sender == GiftIndexToOwners[GiftId]);\n', '        _;\n', '    }\n', '    \n', '    modifier validGift(uint256 GiftId){\n', '        require(GiftExists[GiftId]);\n', '        _;\n', '    }\n', '\n', '    /// @dev constructor\n', '    function VirtualGift()\n', '    public{\n', '        owner = msg.sender;\n', '        // save temporaryly new Gift\n', '        Gift memory newGift = Gift({\n', '            price: 0,\n', '            description: "MYTHICAL"\n', '        });\n', '        // push to array and return the length is the id of new Gift\n', '        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\n', '        // mythical Gift is not exist\n', '        GiftExists[mythicalGift] = false;\n', '        // assign url for Gift\n', '        GiftLinks[mythicalGift] = "mythicalGift";\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, msg.sender, mythicalGift);\n', '        // event create new Gift for msg.sender\n', '        Creation(msg.sender, mythicalGift);\n', '    }\n', '    \n', '    /// @dev this function change GTO address, this mean you can use many token to buy gift\n', '    /// by change GTO address to BNB address\n', '    /// @param newAddress is new address of GTO or another Gift like BNB\n', '    function changeGTOAddress(address newAddress)\n', '    public\n', '    onlyOwner{\n', '        GTO = ERC20(newAddress);\n', '    }\n', '    \n', '    /// @dev return current GTO address\n', '    function getGTOAddress()\n', '    public\n', '    constant\n', '    returns (address) {\n', '        return address(GTO);\n', '    }\n', '    \n', '    /// @dev return total supply of Gift\n', '    /// @return length of Gift storage array, except Gift Zero\n', '    function totalSupply()\n', '    public \n', '    constant\n', '    returns (uint256){\n', '        // exclusive Gift Zero\n', '        return giftStorage.length - 1;\n', '    }\n', '    \n', '    /// @dev allow people to buy Gift\n', '    /// @param GiftId : id of gift user want to buy\n', '    function buy(uint256 GiftId) \n', '    validGift(GiftId)\n', '    public {\n', '        // get old owner of Gift\n', '        address oldowner = ownerOf(GiftId);\n', '        // tell gifto transfer GTO from new owner to oldowner\n', '        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\n', '        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\n', '        // assign new owner for GiftId\n', '        // TODO: old owner should have something to confirm that he want to sell this Gift\n', '        _transfer(oldowner, msg.sender, GiftId);\n', '    }\n', '    \n', '    /// @dev owner send gift to recipient when VG was approved\n', '    /// @param recipient : received gift\n', '    /// @param GiftId : id of gift which recipient want to buy\n', '    function sendGift(address recipient, uint256 GiftId)\n', '    onlyGiftOwner(GiftId)\n', '    validGift(GiftId)\n', '    public {\n', '        // transfer GTO to owner\n', '        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\n', '        // transfer gift to recipient\n', '        _transfer(msg.sender, recipient, GiftId);\n', '    }\n', '    \n', '    /// @dev get total Gift of an address\n', '    /// @param _owner to get balance\n', '    /// @return balance of an address\n', '    function balanceOf(address _owner) \n', '    public \n', '    constant \n', '    returns (uint256 balance){\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function isExist(uint256 GiftId)\n', '    public\n', '    constant\n', '    returns(bool){\n', '        return GiftExists[GiftId];\n', '    }\n', '    \n', '    /// @dev get owner of an Gift id\n', '    /// @param _GiftId : id of Gift to get owner\n', '    /// @return owner : owner of an Gift id\n', '    function ownerOf(uint256 _GiftId)\n', '    public\n', '    constant \n', '    returns (address _owner) {\n', '        require(GiftExists[_GiftId]);\n', '        return GiftIndexToOwners[_GiftId];\n', '    }\n', '    \n', '    /// @dev approve Gift id from msg.sender to an address\n', '    /// @param _to : address is approved\n', '    /// @param _GiftId : id of Gift in array\n', '    function approve(address _to, uint256 _GiftId)\n', '    validGift(_GiftId)\n', '    public {\n', '        require(msg.sender == ownerOf(_GiftId));\n', '        require(msg.sender != _to);\n', '        \n', '        allowed[msg.sender][_to] = _GiftId;\n', '        Approval(msg.sender, _to, _GiftId);\n', '    }\n', '    \n', '    /// @dev get id of Gift was approved from owner to spender\n', '    /// @param _owner : address owner of Gift\n', '    /// @param _spender : spender was approved\n', '    /// @return GiftId\n', '    function allowance(address _owner, address _spender) \n', '    public \n', '    constant \n', '    returns (uint256 GiftId) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /// @dev a spender take owner ship of Gift id, when he was approved\n', '    /// @param _GiftId : id of Gift has being takeOwnership\n', '    function takeOwnership(uint256 _GiftId)\n', '    validGift(_GiftId)\n', '    public {\n', '        // get oldowner of Giftid\n', '        address oldOwner = ownerOf(_GiftId);\n', '        // new owner is msg sender\n', '        address newOwner = msg.sender;\n', '        \n', '        require(newOwner != oldOwner);\n', '        // newOwner must be approved by oldOwner\n', '        require(allowed[oldOwner][newOwner] == _GiftId);\n', '\n', '        // transfer Gift for new owner\n', '        _transfer(oldOwner, newOwner, _GiftId);\n', '\n', '        // delete approve when being done take owner ship\n', '        delete allowed[oldOwner][newOwner];\n', '\n', '        Transfer(oldOwner, newOwner, _GiftId);\n', '    }\n', '    \n', '    /// @dev transfer ownership of a specific Gift to an address.\n', '    /// @param _from : address owner of Giftid\n', "    /// @param _to : address's received\n", '    /// @param _GiftId : Gift id\n', '    function _transfer(address _from, address _to, uint256 _GiftId) \n', '    internal {\n', "        // Since the number of Gift is capped to 2^32 we can't overflow this\n", '        balances[_to]++;\n', '        // transfer ownership\n', '        GiftIndexToOwners[_GiftId] = _to;\n', "        // When creating new Gift _from is 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            balances[_from]--;\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _GiftId);\n', '    }\n', '    \n', '    /// @dev transfer ownership of Giftid from msg sender to an address\n', "    /// @param _to : address's received\n", '    /// @param _GiftId : Gift id\n', '    function transfer(address _to, uint256 _GiftId)\n', '    validGift(_GiftId)\n', '    external {\n', '        // not transfer to zero\n', '        require(_to != 0x0);\n', '        // address received different from sender\n', '        require(msg.sender != _to);\n', '        // sender must be owner of Giftid\n', '        require(msg.sender == ownerOf(_GiftId));\n', '        // do not send to Gift contract\n', '        require(_to != address(this));\n', '        \n', '        _transfer(msg.sender, _to, _GiftId);\n', '    }\n', '    \n', '    /// @dev transfer Giftid was approved by _from to _to\n', '    /// @param _from : address owner of Giftid\n', '    /// @param _to : address is received\n', '    /// @param _GiftId : Gift id\n', '    function transferFrom(address _from, address _to, uint256 _GiftId)\n', '    validGift(_GiftId)\n', '    external {\n', '        require(_from == ownerOf(_GiftId));\n', '        // Check for approval and valid ownership\n', '        require(allowance(_from, msg.sender) == _GiftId);\n', '        // address received different from _owner\n', '        require(_from != _to);\n', '        \n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any Gift\n', '        require(_to != address(this));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _GiftId);\n', '    }\n', '    \n', '    /// @dev Returns a list of all Gift IDs assigned to an address.\n', '    /// @param _owner The owner whose Gift we are interested in.\n', "    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n", '    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n', '    /// @return ownerGifts : list Gift of owner\n', '    function GiftsOfOwner(address _owner) \n', '    public \n', '    view \n', '    returns(uint256[] ownerGifts) {\n', '        \n', '        uint256 GiftCount = balanceOf(_owner);\n', '        if (GiftCount == 0) {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](GiftCount);\n', '            uint256 total = totalSupply();\n', '            uint256 resultIndex = 0;\n', '\n', '            // We count on the fact that all Gift have IDs starting at 1 and increasing\n', '            // sequentially up to the totalCat count.\n', '            uint256 GiftId;\n', '            \n', '            // scan array and filter Gift of owner\n', '            for (GiftId = 0; GiftId <= total; GiftId++) {\n', '                if (GiftIndexToOwners[GiftId] == _owner) {\n', '                    result[resultIndex] = GiftId;\n', '                    resultIndex++;\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '    \n', '    /// @dev Returns a Gift IDs assigned to an address.\n', '    /// @param _owner The owner whose Gift we are interested in.\n', '    /// @param _index to owner Gift list\n', "    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n", '    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n', '    ///  it is only supported for web3 calls, and\n', '    ///  not contract-to-contract calls.\n', '    function giftOwnerByIndex(address _owner, uint256 _index)\n', '    external\n', '    constant \n', '    returns (uint256 GiftId) {\n', '        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\n', '        return ownerGifts[_index];\n', '    }\n', '    \n', '    /// @dev get Gift metadata (url) from GiftLinks\n', '    /// @param _GiftId : Gift id\n', '    /// @return infoUrl : url of Gift\n', '    function GiftMetadata(uint256 _GiftId)\n', '    public\n', '    constant\n', '    returns (string infoUrl) {\n', '        return GiftLinks[_GiftId];\n', '    }\n', '    \n', '    /// @dev function create new Gift\n', '    /// @param _price : Gift property\n', '    /// @param _description : Gift property\n', '    /// @return GiftId\n', '    function createGift(uint256 _price, string _description, string _url)\n', '    public\n', '    onlyOwner\n', '    returns (uint256) {\n', '        // save temporarily new Gift\n', '        Gift memory newGift = Gift({\n', '            price: _price,\n', '            description: _description\n', '        });\n', '        // push to array and return the length is the id of new Gift\n', '        uint256 newGiftId = giftStorage.push(newGift) - 1;\n', '        // turn on existen\n', '        GiftExists[newGiftId] = true;\n', '        // assin gift url\n', '        GiftLinks[newGiftId] = _url;\n', '        // event create new Gift for msg.sender\n', '        Creation(msg.sender, newGiftId);\n', '        \n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(0, msg.sender, newGiftId);\n', '        \n', '        return newGiftId;\n', '    }\n', '    \n', '    /// @dev get Gift property\n', '    /// @param GiftId : id of Gift\n', '    /// @return properties of Gift\n', '    function getGift(uint256 GiftId)\n', '    public\n', '    constant \n', '    returns (uint256, string){\n', '        if(GiftId > giftStorage.length){\n', '            return (0, "");\n', '        }\n', '        Gift memory newGift = giftStorage[GiftId];\n', '        return (newGift.price, newGift.description);\n', '    }\n', '    \n', '    /// @dev change gift properties\n', '    /// @param GiftId : to change\n', '    /// @param _price : new price of gift\n', '    /// @param _description : new description\n', '    /// @param _giftUrl : new url \n', '    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\n', '    public\n', '    onlyOwner {\n', '        // check Gift exist First\n', '        require(GiftExists[GiftId]);\n', '        // setting new properties\n', '        giftStorage[GiftId].price = _price;\n', '        giftStorage[GiftId].description = _description;\n', '        GiftLinks[GiftId] = _giftUrl;\n', '    }\n', '    \n', '    /// @dev remove gift \n', '    /// @param GiftId : gift id to remove\n', '    function removeGift(uint256 GiftId)\n', '    public\n', '    onlyOwner {\n', '        // just setting GiftExists equal to false\n', '        GiftExists[GiftId] = false;\n', '    }\n', '    \n', '    /// @dev withdraw GTO in this contract\n', '    function withdrawGTO()\n', '    onlyOwner\n', '    public {\n', '        GTO.transfer(owner, GTO.balanceOf(address(this)));\n', '    }\n', '    \n', '}']