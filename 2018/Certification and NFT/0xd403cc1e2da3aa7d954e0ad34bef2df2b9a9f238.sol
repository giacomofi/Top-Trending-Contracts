['pragma solidity ^0.4.18;\n', '\n', 'interface ERC20 {\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Distribution {\n', '  using SafeMath for uint256;\n', '\n', '  enum State {\n', '    AwaitingTokens,\n', '    DistributingNormally,\n', '    DistributingProRata,\n', '    Done\n', '  }\n', ' \n', '  address admin;\n', '  ERC20 tokenContract;\n', '  State state;\n', '  uint256 actualTotalTokens;\n', '  uint256 tokensTransferred;\n', '\n', '  bytes32[] contributionHashes;\n', '  uint256 expectedTotalTokens;\n', '\n', '  function Distribution(address _admin, ERC20 _tokenContract,\n', '                        bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public {\n', '    expectedTotalTokens = _expectedTotalTokens;\n', '    contributionHashes = _contributionHashes;\n', '    tokenContract = _tokenContract;\n', '    admin = _admin;\n', '\n', '    state = State.AwaitingTokens;\n', '  }\n', '\n', '  function handleTokensReceived() public {\n', '    require(state == State.AwaitingTokens);\n', '    uint256 totalTokens = tokenContract.balanceOf(this);\n', '    require(totalTokens > 0);\n', '\n', '    tokensTransferred = 0;\n', '    if (totalTokens == expectedTotalTokens) {\n', '      state = State.DistributingNormally;\n', '    } else {\n', '      actualTotalTokens = totalTokens;\n', '      state = State.DistributingProRata;\n', '    }\n', '  }\n', '\n', '  function _numTokensForContributor(uint256 contributorExpectedTokens, State _state)\n', '      internal view returns (uint256) {\n', '    if (_state == State.DistributingNormally) {\n', '      return contributorExpectedTokens;\n', '    } else if (_state == State.DistributingProRata) {\n', '      uint256 tokensRemaining = actualTotalTokens - tokensTransferred;\n', '      uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens;\n', '\n', '      // Handle roundoff on last contributor.\n', '      if (tokens < tokensRemaining) {\n', '        return tokens;\n', '      } else {\n', '        return tokensRemaining;\n', '      }\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function doDistribution(uint256 contributorIndex, address contributor,\n', '                          uint256 contributorExpectedTokens)\n', '      public {\n', '    require(contributionHashes[contributorIndex] == keccak256(contributor, contributorExpectedTokens));\n', '\n', '    uint256 numTokens = _numTokensForContributor(contributorExpectedTokens, state);\n', '    contributionHashes[contributorIndex] = 0x00000000000000000000000000000000;\n', '    tokensTransferred += numTokens;\n', '    if (tokensTransferred == actualTotalTokens) {\n', '      state = State.Done;\n', '    }\n', '\n', '    require(tokenContract.transfer(contributor, numTokens));\n', '  }\n', '\n', '  function doDistributionRange(uint256 start, address[] contributors,\n', '                               uint256[] contributorExpectedTokens) public {\n', '    require(contributors.length == contributorExpectedTokens.length);\n', '\n', '    uint256 tokensTransferredThisCall = 0;\n', '    uint256 end = start + contributors.length;\n', '    State _state = state;\n', '    for (uint256 i = start; i < end; ++i) {\n', '      address contributor = contributors[i];\n', '      uint256 expectedTokens = contributorExpectedTokens[i];\n', '      require(contributionHashes[i] == keccak256(contributor, expectedTokens));\n', '      contributionHashes[i] = 0x00000000000000000000000000000000;\n', '\n', '      uint256 numTokens = _numTokensForContributor(expectedTokens, _state);\n', '      tokensTransferredThisCall += numTokens;\n', '      require(tokenContract.transfer(contributor, numTokens));\n', '    }\n', '\n', '    tokensTransferred += tokensTransferredThisCall;\n', '    if (tokensTransferred == actualTotalTokens) {\n', '      state = State.Done;\n', '    }\n', '  }\n', '\n', '  function numTokensForContributor(uint256 contributorExpectedTokens)\n', '      public view returns (uint256) {\n', '    return _numTokensForContributor(contributorExpectedTokens, state);\n', '  }\n', '\n', '  function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n', '    require(msg.sender == admin);\n', '    require(to.call.value(value)(data));\n', '  }\n', '\n', '  function temporaryKill(address to) public {\n', '    require(msg.sender == admin);\n', '    require(tokenContract.balanceOf(this) == 0);\n', '    selfdestruct(to);\n', '  }\n', '}']