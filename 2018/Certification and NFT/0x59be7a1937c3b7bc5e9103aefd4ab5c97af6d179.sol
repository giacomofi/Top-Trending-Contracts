['pragma solidity ^0.4.23;\n', '\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* Web              - https://444eth.com\n', '\n', '* \n', '*  - GAIN 4,44% PER 24 HOURS (every 5900 blocks)\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 eth\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 83% payments\n', '*    -- 17% Marketing + Operating Expenses\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', '*  freely accessed online. In order to insure our investors&#39; complete security, full control over the \n', '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', '*  system&#39;s permanent autonomous functioning.\n', '* \n', '* ---How to use:\n', '*  1. Send from ETH wallet to the smart contract address\n', '*     any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', '*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don&#39;t care unless you&#39;re \n', '*      spending too much on GAS)\n', '*  OR\n', '*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \n', '*      transaction), and only after that, deposit the amount that you want to reinvest.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 200000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Revolution. Scroll down to find it.\n', '*/\n', '\n', '\n', 'contract InvestorsStorage {\n', '  struct investor {\n', '    uint keyIndex;\n', '    uint value;\n', '    uint paymentTime;\n', '    uint refBonus;\n', '  }\n', '  struct itmap {\n', '    mapping(address => investor) data;\n', '    address[] keys;\n', '  }\n', '  itmap private s;\n', '  address private owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    s.keys.length++;\n', '  }\n', '\n', '  function insert(address addr, uint value) public onlyOwner returns (bool) {\n', '    uint keyIndex = s.data[addr].keyIndex;\n', '    if (keyIndex != 0) return false;\n', '    s.data[addr].value = value;\n', '    keyIndex = s.keys.length++;\n', '    s.data[addr].keyIndex = keyIndex;\n', '    s.keys[keyIndex] = addr;\n', '    return true;\n', '  }\n', '\n', '  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].keyIndex,\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorBaseInfo(address addr) public view returns(uint, uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorShortInfo(address addr) public view returns(uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    return true;\n', '  }\n', '\n', '  function addValue(address addr, uint value) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].value += value;\n', '    return true;\n', '  }\n', '\n', '  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].paymentTime = paymentTime;\n', '    return true;\n', '  }\n', '\n', '  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus = refBonus;\n', '    return true;\n', '  }\n', '\n', '  function keyFromIndex(uint i) public view returns (address) {\n', '    return s.keys[i];\n', '  }\n', '\n', '  function contains(address addr) public view returns (bool) {\n', '    return s.data[addr].keyIndex > 0;\n', '  }\n', '\n', '  function size() public view returns (uint) {\n', '    return s.keys.length;\n', '  }\n', '\n', '  function iterStart() public pure returns (uint) {\n', '    return 1;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '  enum AccessRank { None, Payout, Paymode, Full }\n', '  mapping(address => AccessRank) internal m_admins;\n', '  modifier onlyAdmin(AccessRank  r) {\n', '    require(\n', '      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\n', '      "access denied"\n', '    );\n', '    _;\n', '  }\n', '  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\n', '\n', '  constructor() public {\n', '    m_admins[msg.sender] = AccessRank.Full;\n', '    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\n', '  }\n', '  \n', '  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\n', '    require(rank <= AccessRank.Full, "invalid access rank");\n', '    require(m_admins[addr] != AccessRank.Full, "cannot change full access rank");\n', '    if (m_admins[addr] != rank) {\n', '      m_admins[addr] = rank;\n', '      emit LogProvideAccess(addr, now, rank);\n', '    }\n', '  }\n', '\n', '  function access(address addr) public view returns(AccessRank rank) {\n', '    rank = m_admins[addr];\n', '  }\n', '}\n', '\n', '\n', 'contract PaymentSystem {\n', '  // https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\n', '  enum Paymode { Push, Pull }\n', '  struct PaySys {\n', '    uint latestTime;\n', '    uint latestKeyIndex;\n', '    Paymode mode; \n', '  }\n', '  PaySys internal m_paysys;\n', '\n', '  modifier atPaymode(Paymode mode) {\n', '    require(m_paysys.mode == mode, "pay mode does not the same");\n', '    _;\n', '  }\n', '  event LogPaymodeChanged(uint when, Paymode indexed mode);\n', '  \n', '  function paymode() public view returns(Paymode mode) {\n', '    mode = m_paysys.mode;\n', '  }\n', '\n', '  function changePaymode(Paymode mode) internal {\n', '    require(mode <= Paymode.Pull, "invalid pay mode");\n', '    if (mode == m_paysys.mode ) return; \n', '    if (mode == Paymode.Pull) require(m_paysys.latestTime != 0, "cannot set pull pay mode if latest time is 0");\n', '    if (mode == Paymode.Push) m_paysys.latestTime = 0;\n', '    m_paysys.mode = mode;\n', '    emit LogPaymodeChanged(now, m_paysys.mode);\n', '  }\n', '}\n', '\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', '\n', 'contract Revolution is Accessibility, PaymentSystem {\n', '  using Percent for Percent.percent;\n', '  using SafeMath for uint;\n', '  using Zero for *;\n', '  using ToAddress for *;\n', '\n', '  // investors storage - iterable map;\n', '  InvestorsStorage private m_investors;\n', '  mapping(address => bool) private m_referrals;\n', '  bool private m_nextWave;\n', '\n', '  // automatically generates getters\n', '  address public adminAddr;\n', '  address public payerAddr;\n', '  uint public waveStartup;\n', '  uint public investmentsNum;\n', '  uint public constant minInvesment = 50 finney; // 0.01 eth\n', '  uint public constant maxBalance = 333e5 ether; // 33,300,000 eth\n', '  uint public constant pauseOnNextWave = 168 hours; \n', '\n', '  // percents \n', '  Percent.percent private m_dividendsPercent = Percent.percent(444, 10000); // 444/10000*100% = 4.44%\n', '  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%\n', '  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%\n', '  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%\n', '\n', '  // more events for easy read from blockchain\n', '  event LogNewInvestor(address indexed addr, uint when, uint value);\n', '  event LogNewInvesment(address indexed addr, uint when, uint value);\n', '  event LogNewReferral(address indexed addr, uint when, uint value);\n', '  event LogPayDividends(address indexed addr, uint when, uint value);\n', '  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n', '  event LogBalanceChanged(uint when, uint balance);\n', '  event LogAdminAddrChanged(address indexed addr, uint when);\n', '  event LogPayerAddrChanged(address indexed addr, uint when);\n', '  event LogNextWave(uint when);\n', '\n', '  modifier balanceChanged {\n', '    _;\n', '    emit LogBalanceChanged(now, address(this).balance);\n', '  }\n', '\n', '  modifier notOnPause() {\n', '    require(waveStartup+pauseOnNextWave <= now, "pause on next wave not expired");\n', '    _;\n', '  }\n', '\n', '  constructor(address admin) public {\n', '    adminAddr = admin;\n', '    emit LogAdminAddrChanged(msg.sender, now);\n', '\n', '    payerAddr = admin;\n', '    emit LogPayerAddrChanged(msg.sender, now);\n', '\n', '    nextWave();\n', '    waveStartup = waveStartup.sub(pauseOnNextWave);\n', '  }\n', '\n', '  function() public payable {\n', '    // investor get him dividends\n', '    if (msg.value == 0) {\n', '      getMyDividends();\n', '      return;\n', '    }\n', '\n', '    // sender do invest\n', '    address a = msg.data.toAddr();\n', '    address[3] memory refs;\n', '    if (a.notZero()) {\n', '      refs[0] = a;\n', '      doInvest(refs); \n', '    } else {\n', '      doInvest(refs);\n', '    }\n', '  }\n', '\n', '  function investorsNumber() public view returns(uint) {\n', '    return m_investors.size()-1;\n', '    // -1 because see InvestorsStorage constructor where keys.length++ \n', '  }\n', '\n', '  function balanceETH() public view returns(uint) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function payerPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);\n', '  }\n', '\n', '  function dividendsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\n', '  }\n', '\n', '  function adminPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\n', '  }\n', '\n', '  function referrerPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent.num, m_refPercent.den);\n', '  }\n', '\n', '  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {\n', '    (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);\n', '    isReferral = m_referrals[addr];\n', '  }\n', '\n', '  function latestPayout() public view returns(uint timestamp) {\n', '    return m_paysys.latestTime;\n', '  }\n', '\n', '  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {\n', '    // check investor info\n', '    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\n', '    require(investor.keyIndex > 0, "sender is not investor"); \n', '    if (investor.paymentTime < m_paysys.latestTime) {\n', '      assert(m_investors.setPaymentTime(msg.sender, m_paysys.latestTime));\n', '      investor.paymentTime = m_paysys.latestTime;\n', '    }\n', '\n', '    // calculate days after latest payment\n', '    uint256 daysAfter = now.sub(investor.paymentTime).div(24 hours);\n', '    require(daysAfter > 0, "the latest payment was earlier than 24 hours");\n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    // check enough eth \n', '    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\n', '    if (address(this).balance < value + investor.refBonus) {\n', '      nextWave();\n', '      return;\n', '    }\n', '\n', '    // send dividends and ref bonus\n', '    if (investor.refBonus > 0) {\n', '      assert(m_investors.setRefBonus(msg.sender, 0));\n', '      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\n', '    } else {\n', '      sendDividends(msg.sender, value);\n', '    }\n', '  }\n', '\n', '  function doInvest(address[3] refs) public payable notOnPause balanceChanged {\n', '    require(msg.value >= minInvesment, "msg.value must be >= minInvesment");\n', '    require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '    uint value = msg.value;\n', '    // ref system works only once for sender-referral\n', '    if (!m_referrals[msg.sender]) {\n', '      // level 1\n', '      if (notZeroNotSender(refs[0]) && m_investors.contains(refs[0])) {\n', '        uint reward = m_refPercent.mul(value);\n', '        assert(m_investors.addRefBonus(refs[0], reward)); // referrer 1 bonus\n', '        m_referrals[msg.sender] = true;\n', '        value = m_dividendsPercent.add(value); // referral bonus\n', '        emit LogNewReferral(msg.sender, now, value);\n', '        // level 2\n', '        if (notZeroNotSender(refs[1]) && m_investors.contains(refs[1]) && refs[0] != refs[1]) { \n', '          assert(m_investors.addRefBonus(refs[1], reward)); // referrer 2 bonus\n', '          // level 3\n', '          if (notZeroNotSender(refs[2]) && m_investors.contains(refs[2]) && refs[0] != refs[2] && refs[1] != refs[2]) { \n', '            assert(m_investors.addRefBonus(refs[2], reward)); // referrer 3 bonus\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    // commission\n', '    adminAddr.transfer(m_adminPercent.mul(msg.value));\n', '    payerAddr.transfer(m_payerPercent.mul(msg.value));    \n', '    \n', '    // write to investors storage\n', '    if (m_investors.contains(msg.sender)) {\n', '      assert(m_investors.addValue(msg.sender, value));\n', '    } else {\n', '      assert(m_investors.insert(msg.sender, value));\n', '      emit LogNewInvestor(msg.sender, now, value); \n', '    }\n', '    \n', '    if (m_paysys.mode == Paymode.Pull)\n', '      assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    emit LogNewInvesment(msg.sender, now, value);   \n', '    investmentsNum++;\n', '  }\n', '\n', '  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {\n', '    if (m_nextWave) {\n', '      nextWave(); \n', '      return;\n', '    }\n', '   \n', '    // if m_paysys.latestKeyIndex == m_investors.iterStart() then payout NOT in process and we must check latest time of payment.\n', '    if (m_paysys.latestKeyIndex == m_investors.iterStart()) {\n', '      require(now>m_paysys.latestTime+12 hours, "the latest payment was earlier than 12 hours");\n', '      m_paysys.latestTime = now;\n', '    }\n', '\n', '    uint i = m_paysys.latestKeyIndex;\n', '    uint value;\n', '    uint refBonus;\n', '    uint size = m_investors.size();\n', '    address investorAddr;\n', '    \n', '    // gasleft and latest key index  - prevent gas block limit \n', '    for (i; i < size && gasleft() > 50000; i++) {\n', '      investorAddr = m_investors.keyFromIndex(i);\n', '      (value, refBonus) = m_investors.investorShortInfo(investorAddr);\n', '      value = m_dividendsPercent.mul(value);\n', '\n', '      if (address(this).balance < value + refBonus) {\n', '        m_nextWave = true;\n', '        break;\n', '      }\n', '\n', '      if (refBonus > 0) {\n', '        require(m_investors.setRefBonus(investorAddr, 0), "internal error");\n', '        sendDividendsWithRefBonus(investorAddr, value, refBonus);\n', '        continue;\n', '      }\n', '\n', '      sendDividends(investorAddr, value);\n', '    }\n', '\n', '    if (i == size) \n', '      m_paysys.latestKeyIndex = m_investors.iterStart();\n', '    else \n', '      m_paysys.latestKeyIndex = i;\n', '  }\n', '\n', '  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {\n', '    addr.requireNotZero();\n', '    if (adminAddr != addr) {\n', '      adminAddr = addr;\n', '      emit LogAdminAddrChanged(addr, now);\n', '    }    \n', '  }\n', '\n', '  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {\n', '    addr.requireNotZero();\n', '    if (payerAddr != addr) {\n', '      payerAddr = addr;\n', '      emit LogPayerAddrChanged(addr, now);\n', '    }  \n', '  }\n', '\n', '  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {\n', '    changePaymode(Paymode.Pull);\n', '  }\n', '\n', '  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\n', '    (uint a, uint b, uint c, uint d) = m_investors.investorFullInfo(addr);\n', '    return InvestorsStorage.investor(a, b, c, d);\n', '  }\n', '\n', '  function notZeroNotSender(address addr) internal view returns(bool) {\n', '    return addr.notZero() && addr != msg.sender;\n', '  }\n', '\n', '  function sendDividends(address addr, uint value) private {\n', '    if (addr.send(value)) emit LogPayDividends(addr, now, value); \n', '  }\n', '\n', '  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\n', '    if (addr.send(value+refBonus)) {\n', '      emit LogPayDividends(addr, now, value);\n', '      emit LogPayReferrerBonus(addr, now, refBonus);\n', '    }\n', '  }\n', '\n', '  function nextWave() private {\n', '    m_investors = new InvestorsStorage();\n', '    changePaymode(Paymode.Push);\n', '    m_paysys.latestKeyIndex = m_investors.iterStart();\n', '    investmentsNum = 0;\n', '    waveStartup = now;\n', '    m_nextWave = false;\n', '    emit LogNextWave(now);\n', '  }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* Web              - https://444eth.com\n', '\n', '* \n', '*  - GAIN 4,44% PER 24 HOURS (every 5900 blocks)\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 eth\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 83% payments\n', '*    -- 17% Marketing + Operating Expenses\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', "*  freely accessed online. In order to insure our investors' complete security, full control over the \n", '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', "*  system's permanent autonomous functioning.\n", '* \n', '* ---How to use:\n', '*  1. Send from ETH wallet to the smart contract address\n', '*     any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', "*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \n", '*      spending too much on GAS)\n', '*  OR\n', '*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \n', '*      transaction), and only after that, deposit the amount that you want to reinvest.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 200000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Revolution. Scroll down to find it.\n', '*/\n', '\n', '\n', 'contract InvestorsStorage {\n', '  struct investor {\n', '    uint keyIndex;\n', '    uint value;\n', '    uint paymentTime;\n', '    uint refBonus;\n', '  }\n', '  struct itmap {\n', '    mapping(address => investor) data;\n', '    address[] keys;\n', '  }\n', '  itmap private s;\n', '  address private owner;\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    s.keys.length++;\n', '  }\n', '\n', '  function insert(address addr, uint value) public onlyOwner returns (bool) {\n', '    uint keyIndex = s.data[addr].keyIndex;\n', '    if (keyIndex != 0) return false;\n', '    s.data[addr].value = value;\n', '    keyIndex = s.keys.length++;\n', '    s.data[addr].keyIndex = keyIndex;\n', '    s.keys[keyIndex] = addr;\n', '    return true;\n', '  }\n', '\n', '  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].keyIndex,\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorBaseInfo(address addr) public view returns(uint, uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorShortInfo(address addr) public view returns(uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    return true;\n', '  }\n', '\n', '  function addValue(address addr, uint value) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].value += value;\n', '    return true;\n', '  }\n', '\n', '  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].paymentTime = paymentTime;\n', '    return true;\n', '  }\n', '\n', '  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus = refBonus;\n', '    return true;\n', '  }\n', '\n', '  function keyFromIndex(uint i) public view returns (address) {\n', '    return s.keys[i];\n', '  }\n', '\n', '  function contains(address addr) public view returns (bool) {\n', '    return s.data[addr].keyIndex > 0;\n', '  }\n', '\n', '  function size() public view returns (uint) {\n', '    return s.keys.length;\n', '  }\n', '\n', '  function iterStart() public pure returns (uint) {\n', '    return 1;\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', '\n', 'contract Accessibility {\n', '  enum AccessRank { None, Payout, Paymode, Full }\n', '  mapping(address => AccessRank) internal m_admins;\n', '  modifier onlyAdmin(AccessRank  r) {\n', '    require(\n', '      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\n', '      "access denied"\n', '    );\n', '    _;\n', '  }\n', '  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\n', '\n', '  constructor() public {\n', '    m_admins[msg.sender] = AccessRank.Full;\n', '    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\n', '  }\n', '  \n', '  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\n', '    require(rank <= AccessRank.Full, "invalid access rank");\n', '    require(m_admins[addr] != AccessRank.Full, "cannot change full access rank");\n', '    if (m_admins[addr] != rank) {\n', '      m_admins[addr] = rank;\n', '      emit LogProvideAccess(addr, now, rank);\n', '    }\n', '  }\n', '\n', '  function access(address addr) public view returns(AccessRank rank) {\n', '    rank = m_admins[addr];\n', '  }\n', '}\n', '\n', '\n', 'contract PaymentSystem {\n', '  // https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\n', '  enum Paymode { Push, Pull }\n', '  struct PaySys {\n', '    uint latestTime;\n', '    uint latestKeyIndex;\n', '    Paymode mode; \n', '  }\n', '  PaySys internal m_paysys;\n', '\n', '  modifier atPaymode(Paymode mode) {\n', '    require(m_paysys.mode == mode, "pay mode does not the same");\n', '    _;\n', '  }\n', '  event LogPaymodeChanged(uint when, Paymode indexed mode);\n', '  \n', '  function paymode() public view returns(Paymode mode) {\n', '    mode = m_paysys.mode;\n', '  }\n', '\n', '  function changePaymode(Paymode mode) internal {\n', '    require(mode <= Paymode.Pull, "invalid pay mode");\n', '    if (mode == m_paysys.mode ) return; \n', '    if (mode == Paymode.Pull) require(m_paysys.latestTime != 0, "cannot set pull pay mode if latest time is 0");\n', '    if (mode == Paymode.Push) m_paysys.latestTime = 0;\n', '    m_paysys.mode = mode;\n', '    emit LogPaymodeChanged(now, m_paysys.mode);\n', '  }\n', '}\n', '\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', '\n', 'contract Revolution is Accessibility, PaymentSystem {\n', '  using Percent for Percent.percent;\n', '  using SafeMath for uint;\n', '  using Zero for *;\n', '  using ToAddress for *;\n', '\n', '  // investors storage - iterable map;\n', '  InvestorsStorage private m_investors;\n', '  mapping(address => bool) private m_referrals;\n', '  bool private m_nextWave;\n', '\n', '  // automatically generates getters\n', '  address public adminAddr;\n', '  address public payerAddr;\n', '  uint public waveStartup;\n', '  uint public investmentsNum;\n', '  uint public constant minInvesment = 50 finney; // 0.01 eth\n', '  uint public constant maxBalance = 333e5 ether; // 33,300,000 eth\n', '  uint public constant pauseOnNextWave = 168 hours; \n', '\n', '  // percents \n', '  Percent.percent private m_dividendsPercent = Percent.percent(444, 10000); // 444/10000*100% = 4.44%\n', '  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%\n', '  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%\n', '  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%\n', '\n', '  // more events for easy read from blockchain\n', '  event LogNewInvestor(address indexed addr, uint when, uint value);\n', '  event LogNewInvesment(address indexed addr, uint when, uint value);\n', '  event LogNewReferral(address indexed addr, uint when, uint value);\n', '  event LogPayDividends(address indexed addr, uint when, uint value);\n', '  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n', '  event LogBalanceChanged(uint when, uint balance);\n', '  event LogAdminAddrChanged(address indexed addr, uint when);\n', '  event LogPayerAddrChanged(address indexed addr, uint when);\n', '  event LogNextWave(uint when);\n', '\n', '  modifier balanceChanged {\n', '    _;\n', '    emit LogBalanceChanged(now, address(this).balance);\n', '  }\n', '\n', '  modifier notOnPause() {\n', '    require(waveStartup+pauseOnNextWave <= now, "pause on next wave not expired");\n', '    _;\n', '  }\n', '\n', '  constructor(address admin) public {\n', '    adminAddr = admin;\n', '    emit LogAdminAddrChanged(msg.sender, now);\n', '\n', '    payerAddr = admin;\n', '    emit LogPayerAddrChanged(msg.sender, now);\n', '\n', '    nextWave();\n', '    waveStartup = waveStartup.sub(pauseOnNextWave);\n', '  }\n', '\n', '  function() public payable {\n', '    // investor get him dividends\n', '    if (msg.value == 0) {\n', '      getMyDividends();\n', '      return;\n', '    }\n', '\n', '    // sender do invest\n', '    address a = msg.data.toAddr();\n', '    address[3] memory refs;\n', '    if (a.notZero()) {\n', '      refs[0] = a;\n', '      doInvest(refs); \n', '    } else {\n', '      doInvest(refs);\n', '    }\n', '  }\n', '\n', '  function investorsNumber() public view returns(uint) {\n', '    return m_investors.size()-1;\n', '    // -1 because see InvestorsStorage constructor where keys.length++ \n', '  }\n', '\n', '  function balanceETH() public view returns(uint) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function payerPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);\n', '  }\n', '\n', '  function dividendsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\n', '  }\n', '\n', '  function adminPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\n', '  }\n', '\n', '  function referrerPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent.num, m_refPercent.den);\n', '  }\n', '\n', '  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {\n', '    (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);\n', '    isReferral = m_referrals[addr];\n', '  }\n', '\n', '  function latestPayout() public view returns(uint timestamp) {\n', '    return m_paysys.latestTime;\n', '  }\n', '\n', '  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {\n', '    // check investor info\n', '    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\n', '    require(investor.keyIndex > 0, "sender is not investor"); \n', '    if (investor.paymentTime < m_paysys.latestTime) {\n', '      assert(m_investors.setPaymentTime(msg.sender, m_paysys.latestTime));\n', '      investor.paymentTime = m_paysys.latestTime;\n', '    }\n', '\n', '    // calculate days after latest payment\n', '    uint256 daysAfter = now.sub(investor.paymentTime).div(24 hours);\n', '    require(daysAfter > 0, "the latest payment was earlier than 24 hours");\n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    // check enough eth \n', '    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\n', '    if (address(this).balance < value + investor.refBonus) {\n', '      nextWave();\n', '      return;\n', '    }\n', '\n', '    // send dividends and ref bonus\n', '    if (investor.refBonus > 0) {\n', '      assert(m_investors.setRefBonus(msg.sender, 0));\n', '      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\n', '    } else {\n', '      sendDividends(msg.sender, value);\n', '    }\n', '  }\n', '\n', '  function doInvest(address[3] refs) public payable notOnPause balanceChanged {\n', '    require(msg.value >= minInvesment, "msg.value must be >= minInvesment");\n', '    require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '    uint value = msg.value;\n', '    // ref system works only once for sender-referral\n', '    if (!m_referrals[msg.sender]) {\n', '      // level 1\n', '      if (notZeroNotSender(refs[0]) && m_investors.contains(refs[0])) {\n', '        uint reward = m_refPercent.mul(value);\n', '        assert(m_investors.addRefBonus(refs[0], reward)); // referrer 1 bonus\n', '        m_referrals[msg.sender] = true;\n', '        value = m_dividendsPercent.add(value); // referral bonus\n', '        emit LogNewReferral(msg.sender, now, value);\n', '        // level 2\n', '        if (notZeroNotSender(refs[1]) && m_investors.contains(refs[1]) && refs[0] != refs[1]) { \n', '          assert(m_investors.addRefBonus(refs[1], reward)); // referrer 2 bonus\n', '          // level 3\n', '          if (notZeroNotSender(refs[2]) && m_investors.contains(refs[2]) && refs[0] != refs[2] && refs[1] != refs[2]) { \n', '            assert(m_investors.addRefBonus(refs[2], reward)); // referrer 3 bonus\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    // commission\n', '    adminAddr.transfer(m_adminPercent.mul(msg.value));\n', '    payerAddr.transfer(m_payerPercent.mul(msg.value));    \n', '    \n', '    // write to investors storage\n', '    if (m_investors.contains(msg.sender)) {\n', '      assert(m_investors.addValue(msg.sender, value));\n', '    } else {\n', '      assert(m_investors.insert(msg.sender, value));\n', '      emit LogNewInvestor(msg.sender, now, value); \n', '    }\n', '    \n', '    if (m_paysys.mode == Paymode.Pull)\n', '      assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    emit LogNewInvesment(msg.sender, now, value);   \n', '    investmentsNum++;\n', '  }\n', '\n', '  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {\n', '    if (m_nextWave) {\n', '      nextWave(); \n', '      return;\n', '    }\n', '   \n', '    // if m_paysys.latestKeyIndex == m_investors.iterStart() then payout NOT in process and we must check latest time of payment.\n', '    if (m_paysys.latestKeyIndex == m_investors.iterStart()) {\n', '      require(now>m_paysys.latestTime+12 hours, "the latest payment was earlier than 12 hours");\n', '      m_paysys.latestTime = now;\n', '    }\n', '\n', '    uint i = m_paysys.latestKeyIndex;\n', '    uint value;\n', '    uint refBonus;\n', '    uint size = m_investors.size();\n', '    address investorAddr;\n', '    \n', '    // gasleft and latest key index  - prevent gas block limit \n', '    for (i; i < size && gasleft() > 50000; i++) {\n', '      investorAddr = m_investors.keyFromIndex(i);\n', '      (value, refBonus) = m_investors.investorShortInfo(investorAddr);\n', '      value = m_dividendsPercent.mul(value);\n', '\n', '      if (address(this).balance < value + refBonus) {\n', '        m_nextWave = true;\n', '        break;\n', '      }\n', '\n', '      if (refBonus > 0) {\n', '        require(m_investors.setRefBonus(investorAddr, 0), "internal error");\n', '        sendDividendsWithRefBonus(investorAddr, value, refBonus);\n', '        continue;\n', '      }\n', '\n', '      sendDividends(investorAddr, value);\n', '    }\n', '\n', '    if (i == size) \n', '      m_paysys.latestKeyIndex = m_investors.iterStart();\n', '    else \n', '      m_paysys.latestKeyIndex = i;\n', '  }\n', '\n', '  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {\n', '    addr.requireNotZero();\n', '    if (adminAddr != addr) {\n', '      adminAddr = addr;\n', '      emit LogAdminAddrChanged(addr, now);\n', '    }    \n', '  }\n', '\n', '  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {\n', '    addr.requireNotZero();\n', '    if (payerAddr != addr) {\n', '      payerAddr = addr;\n', '      emit LogPayerAddrChanged(addr, now);\n', '    }  \n', '  }\n', '\n', '  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {\n', '    changePaymode(Paymode.Pull);\n', '  }\n', '\n', '  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\n', '    (uint a, uint b, uint c, uint d) = m_investors.investorFullInfo(addr);\n', '    return InvestorsStorage.investor(a, b, c, d);\n', '  }\n', '\n', '  function notZeroNotSender(address addr) internal view returns(bool) {\n', '    return addr.notZero() && addr != msg.sender;\n', '  }\n', '\n', '  function sendDividends(address addr, uint value) private {\n', '    if (addr.send(value)) emit LogPayDividends(addr, now, value); \n', '  }\n', '\n', '  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\n', '    if (addr.send(value+refBonus)) {\n', '      emit LogPayDividends(addr, now, value);\n', '      emit LogPayReferrerBonus(addr, now, refBonus);\n', '    }\n', '  }\n', '\n', '  function nextWave() private {\n', '    m_investors = new InvestorsStorage();\n', '    changePaymode(Paymode.Push);\n', '    m_paysys.latestKeyIndex = m_investors.iterStart();\n', '    investmentsNum = 0;\n', '    waveStartup = now;\n', '    m_nextWave = false;\n', '    emit LogNextWave(now);\n', '  }\n', '}']
