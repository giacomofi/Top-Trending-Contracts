['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Certificate is Ownable {\n', '\n', '  event LogAddCertificateAuthority(address indexed ca_address);\n', '  event LogRemoveCertificateAuthority(address indexed ca_address);\n', '  event LogAddCertificate(address indexed ca_address, bytes32 certificate_hash);\n', '  event LogRevokeCertificate(address indexed ca_address, bytes32 certificate_hash);\n', '  event LogBindCertificate2Wallet(address indexed ca_address, bytes32 certificate_hash, address indexed wallet);\n', '\n', '  struct CertificateAuthority {\n', '    string lookup_api;\n', '    string organization;\n', '    string common_name;\n', '    string country;\n', '    string province;\n', '    string locality;\n', '  }\n', '\n', '  struct CertificateMeta {\n', '    address ca_address;\n', '    uint256 expires;\n', '    bytes32 sealed_hash;\n', '    bytes32 certificate_hash;\n', '  }\n', '\n', '  // Mapping of certificate authority address to the certificate authority\n', '  mapping(address => CertificateAuthority) private certificate_authority;\n', '\n', '  // Mapping of Ethereum wallet address to mapping of certificate authority address to wallet certificate hash\n', '  mapping(address => mapping(address => bytes32)) private wallet_authority_certificate;\n', '\n', '  // Mapping of wallet certificate hash to wallet certificate meta data\n', '  mapping(bytes32 => CertificateMeta) private certificates;\n', '\n', '  modifier onlyCA() {\n', '    require(bytes(certificate_authority[msg.sender].lookup_api).length != 0);\n', '    _;\n', '  }\n', '\n', '  /// @dev Adds a new approved certificate authority\n', '  /// @param ca_address Address of certificate authority to add\n', '  /// @param lookup_api certificate lookup API for the given authority\n', '  /// @param organization Name of the organization this certificate authority represents\n', '  /// @param common_name Common name of this certificate authority\n', '  /// @param country Certificate authority jurisdiction country\n', '  /// @param province Certificate authority jurisdiction state/province\n', '  /// @param locality Certificate authority jurisdiction locality\n', '  function addCA(\n', '    address ca_address,\n', '    string lookup_api,\n', '    string organization,\n', '    string common_name,\n', '    string country,\n', '    string province,\n', '    string locality\n', '  ) public onlyOwner {\n', '    require (ca_address != 0x0);\n', '    require (ca_address != msg.sender);\n', '    require (bytes(lookup_api).length != 0);\n', '    require (bytes(organization).length > 3);\n', '    require (bytes(common_name).length > 3);\n', '    require (bytes(country).length > 1);\n', '\n', '    certificate_authority[ca_address] = CertificateAuthority(\n', '      lookup_api,\n', '      organization,\n', '      common_name,\n', '      country,\n', '      province,\n', '      locality\n', '    );\n', '    LogAddCertificateAuthority(ca_address);\n', '  }\n', '\n', '  /// @dev Removes an existing certificate authority, preventing it from issuing new certificates\n', '  /// @param ca_address Address of certificate authority to remove\n', '  function removeCA(address ca_address) public onlyOwner {\n', '    delete certificate_authority[ca_address];\n', '    LogRemoveCertificateAuthority(ca_address);\n', '  }\n', '\n', '  /// @dev Checks whether an address represents a certificate authority\n', '  /// @param ca_address Address to check\n', '  /// @return true if the address is a valid certificate authority; false otherwise\n', '  function isCA(address ca_address) public view returns (bool) {\n', '    return bytes(certificate_authority[ca_address].lookup_api).length != 0;\n', '  }\n', '\n', '  /// @dev Returns the certificate lookup API for the certificate authority\n', '  /// @param ca_address Address of certificate authority\n', '  /// @return lookup api, organization name, common name, country, state/province, and locality of the certificate authority\n', '  function getCA(address ca_address) public view returns (string, string, string, string, string, string) {\n', '    CertificateAuthority storage ca = certificate_authority[ca_address];\n', '    return (ca.lookup_api, ca.organization, ca.common_name, ca.country, ca.province, ca.locality);\n', '  }\n', '\n', '  /// @dev Adds a new certificate by the calling certificate authority\n', '  /// @param expires seconds from epoch until certificate expires\n', '  /// @param sealed_hash hash of sealed portion of the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function addNewCertificate(uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\n', '    require(expires > now);\n', '\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires == 0);\n', '\n', '    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\n', '    LogAddCertificate(msg.sender, certificate_hash);\n', '  }\n', '\n', '  /// @dev Adds a new certificate by the calling certificate authority and binds to given wallet\n', '  /// @param wallet Wallet to which the certificate is being bound to\n', '  /// @param expires seconds from epoch until certificate expires\n', '  /// @param sealed_hash hash of sealed portion of the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function addCertificateAndBind2Wallet(address wallet, uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\n', '    require(expires > now);\n', '\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires == 0);\n', '\n', '    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\n', '    LogAddCertificate(msg.sender, certificate_hash);\n', '    wallet_authority_certificate[wallet][msg.sender] = certificate_hash;\n', '    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\n', '  }\n', '\n', '  /// @dev Bind an existing certificate to a wallet - can be called by certificate authority that issued the certificate or a wallet already bound to the certificate\n', '  /// @param wallet Wallet to which the certificate is being bound to\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function bindCertificate2Wallet(address wallet, bytes32 certificate_hash) public {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires > now);\n', '\n', '    bytes32 sender_certificate_hash = wallet_authority_certificate[msg.sender][cert.ca_address];\n', '\n', '    require(cert.ca_address == msg.sender || cert.certificate_hash == sender_certificate_hash);\n', '\n', '    wallet_authority_certificate[wallet][cert.ca_address] = certificate_hash;\n', '    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\n', '  }\n', '\n', '  /// @dev Revokes an existing certificate - can be called by certificate authority that issued the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function revokeCertificate(bytes32 certificate_hash) public onlyCA {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.ca_address == msg.sender);\n', '    cert.expires = 0;\n', '    LogRevokeCertificate(msg.sender, certificate_hash);\n', '  }\n', '\n', '  /// @dev returns certificate metadata given the certificate hash\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  /// @return certificate authority address, certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\n', '  function getCertificate(bytes32 certificate_hash) public view returns (address, uint256, bytes32, bytes32) {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    if (isCA(cert.ca_address)) {\n', '      return (cert.ca_address, cert.expires, cert.sealed_hash, cert.certificate_hash);\n', '    } else {\n', '      return (0x0, 0, 0x0, 0x0);\n', '    }\n', '  }\n', '\n', '  /// @dev returns certificate metadata for a given wallet from a particular certificate authority\n', '  /// @param wallet Wallet for which the certificate is being looked up\n', '  /// @param ca_address Address of certificate authority\n', '  /// @return certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\n', '  function getCertificateForWallet(address wallet, address ca_address) public view returns (uint256, bytes32, bytes32) {\n', '    bytes32 certificate_hash = wallet_authority_certificate[wallet][ca_address];\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    if (isCA(cert.ca_address)) {\n', '      return (cert.expires, cert.sealed_hash, cert.certificate_hash);\n', '    } else {\n', '      return (0, 0x0, 0x0);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Certificate is Ownable {\n', '\n', '  event LogAddCertificateAuthority(address indexed ca_address);\n', '  event LogRemoveCertificateAuthority(address indexed ca_address);\n', '  event LogAddCertificate(address indexed ca_address, bytes32 certificate_hash);\n', '  event LogRevokeCertificate(address indexed ca_address, bytes32 certificate_hash);\n', '  event LogBindCertificate2Wallet(address indexed ca_address, bytes32 certificate_hash, address indexed wallet);\n', '\n', '  struct CertificateAuthority {\n', '    string lookup_api;\n', '    string organization;\n', '    string common_name;\n', '    string country;\n', '    string province;\n', '    string locality;\n', '  }\n', '\n', '  struct CertificateMeta {\n', '    address ca_address;\n', '    uint256 expires;\n', '    bytes32 sealed_hash;\n', '    bytes32 certificate_hash;\n', '  }\n', '\n', '  // Mapping of certificate authority address to the certificate authority\n', '  mapping(address => CertificateAuthority) private certificate_authority;\n', '\n', '  // Mapping of Ethereum wallet address to mapping of certificate authority address to wallet certificate hash\n', '  mapping(address => mapping(address => bytes32)) private wallet_authority_certificate;\n', '\n', '  // Mapping of wallet certificate hash to wallet certificate meta data\n', '  mapping(bytes32 => CertificateMeta) private certificates;\n', '\n', '  modifier onlyCA() {\n', '    require(bytes(certificate_authority[msg.sender].lookup_api).length != 0);\n', '    _;\n', '  }\n', '\n', '  /// @dev Adds a new approved certificate authority\n', '  /// @param ca_address Address of certificate authority to add\n', '  /// @param lookup_api certificate lookup API for the given authority\n', '  /// @param organization Name of the organization this certificate authority represents\n', '  /// @param common_name Common name of this certificate authority\n', '  /// @param country Certificate authority jurisdiction country\n', '  /// @param province Certificate authority jurisdiction state/province\n', '  /// @param locality Certificate authority jurisdiction locality\n', '  function addCA(\n', '    address ca_address,\n', '    string lookup_api,\n', '    string organization,\n', '    string common_name,\n', '    string country,\n', '    string province,\n', '    string locality\n', '  ) public onlyOwner {\n', '    require (ca_address != 0x0);\n', '    require (ca_address != msg.sender);\n', '    require (bytes(lookup_api).length != 0);\n', '    require (bytes(organization).length > 3);\n', '    require (bytes(common_name).length > 3);\n', '    require (bytes(country).length > 1);\n', '\n', '    certificate_authority[ca_address] = CertificateAuthority(\n', '      lookup_api,\n', '      organization,\n', '      common_name,\n', '      country,\n', '      province,\n', '      locality\n', '    );\n', '    LogAddCertificateAuthority(ca_address);\n', '  }\n', '\n', '  /// @dev Removes an existing certificate authority, preventing it from issuing new certificates\n', '  /// @param ca_address Address of certificate authority to remove\n', '  function removeCA(address ca_address) public onlyOwner {\n', '    delete certificate_authority[ca_address];\n', '    LogRemoveCertificateAuthority(ca_address);\n', '  }\n', '\n', '  /// @dev Checks whether an address represents a certificate authority\n', '  /// @param ca_address Address to check\n', '  /// @return true if the address is a valid certificate authority; false otherwise\n', '  function isCA(address ca_address) public view returns (bool) {\n', '    return bytes(certificate_authority[ca_address].lookup_api).length != 0;\n', '  }\n', '\n', '  /// @dev Returns the certificate lookup API for the certificate authority\n', '  /// @param ca_address Address of certificate authority\n', '  /// @return lookup api, organization name, common name, country, state/province, and locality of the certificate authority\n', '  function getCA(address ca_address) public view returns (string, string, string, string, string, string) {\n', '    CertificateAuthority storage ca = certificate_authority[ca_address];\n', '    return (ca.lookup_api, ca.organization, ca.common_name, ca.country, ca.province, ca.locality);\n', '  }\n', '\n', '  /// @dev Adds a new certificate by the calling certificate authority\n', '  /// @param expires seconds from epoch until certificate expires\n', '  /// @param sealed_hash hash of sealed portion of the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function addNewCertificate(uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\n', '    require(expires > now);\n', '\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires == 0);\n', '\n', '    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\n', '    LogAddCertificate(msg.sender, certificate_hash);\n', '  }\n', '\n', '  /// @dev Adds a new certificate by the calling certificate authority and binds to given wallet\n', '  /// @param wallet Wallet to which the certificate is being bound to\n', '  /// @param expires seconds from epoch until certificate expires\n', '  /// @param sealed_hash hash of sealed portion of the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function addCertificateAndBind2Wallet(address wallet, uint256 expires, bytes32 sealed_hash, bytes32 certificate_hash) public onlyCA {\n', '    require(expires > now);\n', '\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires == 0);\n', '\n', '    certificates[certificate_hash] = CertificateMeta(msg.sender, expires, sealed_hash, certificate_hash);\n', '    LogAddCertificate(msg.sender, certificate_hash);\n', '    wallet_authority_certificate[wallet][msg.sender] = certificate_hash;\n', '    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\n', '  }\n', '\n', '  /// @dev Bind an existing certificate to a wallet - can be called by certificate authority that issued the certificate or a wallet already bound to the certificate\n', '  /// @param wallet Wallet to which the certificate is being bound to\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function bindCertificate2Wallet(address wallet, bytes32 certificate_hash) public {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.expires > now);\n', '\n', '    bytes32 sender_certificate_hash = wallet_authority_certificate[msg.sender][cert.ca_address];\n', '\n', '    require(cert.ca_address == msg.sender || cert.certificate_hash == sender_certificate_hash);\n', '\n', '    wallet_authority_certificate[wallet][cert.ca_address] = certificate_hash;\n', '    LogBindCertificate2Wallet(msg.sender, certificate_hash, wallet);\n', '  }\n', '\n', '  /// @dev Revokes an existing certificate - can be called by certificate authority that issued the certificate\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  function revokeCertificate(bytes32 certificate_hash) public onlyCA {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    require(cert.ca_address == msg.sender);\n', '    cert.expires = 0;\n', '    LogRevokeCertificate(msg.sender, certificate_hash);\n', '  }\n', '\n', '  /// @dev returns certificate metadata given the certificate hash\n', '  /// @param certificate_hash hash of public portion of the certificate\n', '  /// @return certificate authority address, certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\n', '  function getCertificate(bytes32 certificate_hash) public view returns (address, uint256, bytes32, bytes32) {\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    if (isCA(cert.ca_address)) {\n', '      return (cert.ca_address, cert.expires, cert.sealed_hash, cert.certificate_hash);\n', '    } else {\n', '      return (0x0, 0, 0x0, 0x0);\n', '    }\n', '  }\n', '\n', '  /// @dev returns certificate metadata for a given wallet from a particular certificate authority\n', '  /// @param wallet Wallet for which the certificate is being looked up\n', '  /// @param ca_address Address of certificate authority\n', '  /// @return certificate expiration time, hash of sealed portion of the certificate, hash of public portion of the certificate\n', '  function getCertificateForWallet(address wallet, address ca_address) public view returns (uint256, bytes32, bytes32) {\n', '    bytes32 certificate_hash = wallet_authority_certificate[wallet][ca_address];\n', '    CertificateMeta storage cert = certificates[certificate_hash];\n', '    if (isCA(cert.ca_address)) {\n', '      return (cert.expires, cert.sealed_hash, cert.certificate_hash);\n', '    } else {\n', '      return (0, 0x0, 0x0);\n', '    }\n', '  }\n', '}']
