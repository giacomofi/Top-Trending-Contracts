['pragma solidity ^0.4.13;\n', '\n', '// Check balances for multiple ERC20 tokens in 1 batched request\n', '// address 0x0 is used to indicate ETH\n', '// Based on DeltaBalances 0x3e25f0ba291f202188ae9bda3004a7b3a803599a\n', '\n', '// Exchange contract Interface\n', 'contract Exchange {\n', '  function balanceOf(address /*token*/, address /*user*/) public constant returns (uint);\n', '}\n', '\n', '// ERC20 contract interface\n', 'contract Token {\n', '  function balanceOf(address /*tokenOwner*/) public constant returns (uint /*balance*/);\n', '  function transfer(address /*to*/, uint /*tokens*/) public returns (bool /*success*/);\n', '}\n', '\n', 'contract TokenStoreBalances {\n', '\n', '  // Fallback function, don&#39;t accept any ETH\n', '  function() public payable {\n', '    revert();\n', '  }\n', '\n', ' /* Check the token balance of a wallet in a token contract\n', '    Avoids possible errors:\n', '    - returns 0 on invalid exchange contract\n', '    - return 0 on non-contract address\n', '\n', '    Mainly for internal use, but public for anyone who thinks it is useful    */\n', '  function tokenBalance(address user, address token) public constant returns (uint) {\n', '    // check if token is actually a contract\n', '    uint256 tokenCode;\n', '    assembly { tokenCode := extcodesize(token) } // contract code size\n', '\n', '   // is it a contract and does it implement balanceOf\n', '    if(tokenCode > 0 && token.call(bytes4(0x70a08231), user)) {    // bytes4(keccak256("balanceOf(address)")) == bytes4(0x70a08231)\n', '      return Token(token).balanceOf(user);\n', '    } else {\n', '      return 0; // not a valid token, return 0 instead of error\n', '    }\n', '  }\n', '\n', ' /* get both exchange and wallet balances for multiple tokens\n', '    Possible error throws:\n', '        - extremely large arrays (gas cost too high)\n', '\n', '    Returns array of token balances in wei units, 2* input length.\n', '    even index [0] is exchange balance, odd [1] is wallet balance\n', '    [tok0ex, tok0, tok1ex, tok1, .. ] */\n', '  function allBalances(address exchange, address user, address[] tokens) external constant returns (uint[]) {\n', '    Exchange ex = Exchange(exchange);\n', '    uint[] memory balances = new uint[](tokens.length * 2);\n', '\n', '    for(uint i = 0; i < tokens.length; i++) {\n', '      uint j = i * 2;\n', '      balances[j] = ex.balanceOf(tokens[i], user);\n', '      if(tokens[i] != address(0x0)) {\n', '        balances[j + 1] = tokenBalance(user, tokens[i]);\n', '      } else {\n', '        balances[j + 1] = user.balance; // ETH balance\n', '      }\n', '    }\n', '    return balances;\n', '  }\n', '\n', '}']