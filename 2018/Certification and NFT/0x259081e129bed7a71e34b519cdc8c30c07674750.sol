['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '    address public secondOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier bothOwner() {\n', '        require(msg.sender == owner || msg.sender == secondOwner);\n', '        _;\n', '    }\n', '\n', '    function changeSecOwner(address targetAddress) public bothOwner {\n', '        require(targetAddress != address(0));\n', '        secondOwner = targetAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public bothOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) public returns (bool);\n', '    function redeemToken(uint256 _mtcTokens, address _from) public;\n', '}\n', '\n', 'contract addressKeeper is Ownable {\n', '    address public tokenAddress;\n', '    address public boardAddress;\n', '    address public teamAddress;\n', '    function setTokenAdd(address addr) onlyOwner public {\n', '        tokenAddress = addr;\n', '    }\n', '    function setBoardAdd(address addr) onlyOwner public {\n', '        boardAddress = addr;\n', '    }\n', '    function setTeamAdd(address addr) onlyOwner public {\n', '        teamAddress = addr;\n', '    }\n', '}\n', '\n', 'contract MoatFund is addressKeeper {\n', '\n', '    // wei per MTC\n', '    // 1 ETH = 5000 MTC\n', '    // 1 MTC = 200000000000000 wei\n', '    uint256 public mtcRate; // in wei\n', '    bool public mintBool;\n', '    uint256 public minInvest; // minimum investment in wei\n', '\n', '    uint256 public redeemRate;     // When redeeming, 1MTC=fixed ETH\n', '    bool public redeemBool;\n', '\n', '    uint256 public ethRaised;       // ETH deposited in owner&#39;s address\n', '    uint256 public ethRedeemed;     // ETH transferred from owner&#39;s address\n', '\n', '    // function to start minting MTC\n', '    function startMint(uint256 _rate, bool canMint, uint256 _minWeiInvest) onlyOwner public {\n', '        minInvest = _minWeiInvest;\n', '        mtcRate = _rate;\n', '        mintBool = canMint;\n', '    }\n', '\n', '    // function to redeem ETH from MTC\n', '    function startRedeem(uint256 _rate, bool canRedeem) onlyOwner public {\n', '        redeemRate = _rate;\n', '        redeemBool = canRedeem;\n', '    }\n', '\n', '    function () public payable {\n', '        transferToken();\n', '    }\n', '\n', '    // function called from MoatFund.sol\n', '    function transferToken() public payable {\n', '        if (msg.sender != owner &&\n', '            msg.sender != tokenAddress &&\n', '            msg.sender != boardAddress) {\n', '                require(mintBool);\n', '                require(msg.value >= minInvest);\n', '\n', '                uint256 MTCToken = (msg.value / mtcRate);\n', '                uint256 teamToken = (MTCToken / 20);\n', '\n', '                ethRaised += msg.value;\n', '\n', '                token tokenTransfer = token(tokenAddress);\n', '                tokenTransfer.transfer(msg.sender, MTCToken);\n', '                tokenTransfer.transfer(teamAddress, teamToken);\n', '        }\n', '    }\n', '\n', '    // calculate value of MTC that can be redeemed from the ETH\n', '    function redeem(uint256 _mtcTokens) public {\n', '        if (msg.sender != owner) {\n', '            require(redeemBool);\n', '\n', '            token tokenBalance = token(tokenAddress);\n', '            tokenBalance.redeemToken(_mtcTokens, msg.sender);\n', '\n', '            uint256 weiVal = (_mtcTokens * redeemRate);\n', '            ethRedeemed += weiVal;                                  // adds the value of transferred ETH to the redeemed ETH till now\n', '            // it need to stay last for reentery attack purpose\n', '            msg.sender.transfer(weiVal);                            // transfer the amount of ETH\n', '        }\n', '    }\n', '\n', '    function sendETHtoBoard(uint _wei) onlyOwner public {\n', '        boardAddress.transfer(_wei);\n', '    }\n', '\n', '    function collectERC20(address tokenAddress, uint256 amount) onlyOwner public {\n', '        token tokenTransfer = token(tokenAddress);\n', '        tokenTransfer.transfer(owner, amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '    address public secondOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier bothOwner() {\n', '        require(msg.sender == owner || msg.sender == secondOwner);\n', '        _;\n', '    }\n', '\n', '    function changeSecOwner(address targetAddress) public bothOwner {\n', '        require(targetAddress != address(0));\n', '        secondOwner = targetAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public bothOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) public returns (bool);\n', '    function redeemToken(uint256 _mtcTokens, address _from) public;\n', '}\n', '\n', 'contract addressKeeper is Ownable {\n', '    address public tokenAddress;\n', '    address public boardAddress;\n', '    address public teamAddress;\n', '    function setTokenAdd(address addr) onlyOwner public {\n', '        tokenAddress = addr;\n', '    }\n', '    function setBoardAdd(address addr) onlyOwner public {\n', '        boardAddress = addr;\n', '    }\n', '    function setTeamAdd(address addr) onlyOwner public {\n', '        teamAddress = addr;\n', '    }\n', '}\n', '\n', 'contract MoatFund is addressKeeper {\n', '\n', '    // wei per MTC\n', '    // 1 ETH = 5000 MTC\n', '    // 1 MTC = 200000000000000 wei\n', '    uint256 public mtcRate; // in wei\n', '    bool public mintBool;\n', '    uint256 public minInvest; // minimum investment in wei\n', '\n', '    uint256 public redeemRate;     // When redeeming, 1MTC=fixed ETH\n', '    bool public redeemBool;\n', '\n', "    uint256 public ethRaised;       // ETH deposited in owner's address\n", "    uint256 public ethRedeemed;     // ETH transferred from owner's address\n", '\n', '    // function to start minting MTC\n', '    function startMint(uint256 _rate, bool canMint, uint256 _minWeiInvest) onlyOwner public {\n', '        minInvest = _minWeiInvest;\n', '        mtcRate = _rate;\n', '        mintBool = canMint;\n', '    }\n', '\n', '    // function to redeem ETH from MTC\n', '    function startRedeem(uint256 _rate, bool canRedeem) onlyOwner public {\n', '        redeemRate = _rate;\n', '        redeemBool = canRedeem;\n', '    }\n', '\n', '    function () public payable {\n', '        transferToken();\n', '    }\n', '\n', '    // function called from MoatFund.sol\n', '    function transferToken() public payable {\n', '        if (msg.sender != owner &&\n', '            msg.sender != tokenAddress &&\n', '            msg.sender != boardAddress) {\n', '                require(mintBool);\n', '                require(msg.value >= minInvest);\n', '\n', '                uint256 MTCToken = (msg.value / mtcRate);\n', '                uint256 teamToken = (MTCToken / 20);\n', '\n', '                ethRaised += msg.value;\n', '\n', '                token tokenTransfer = token(tokenAddress);\n', '                tokenTransfer.transfer(msg.sender, MTCToken);\n', '                tokenTransfer.transfer(teamAddress, teamToken);\n', '        }\n', '    }\n', '\n', '    // calculate value of MTC that can be redeemed from the ETH\n', '    function redeem(uint256 _mtcTokens) public {\n', '        if (msg.sender != owner) {\n', '            require(redeemBool);\n', '\n', '            token tokenBalance = token(tokenAddress);\n', '            tokenBalance.redeemToken(_mtcTokens, msg.sender);\n', '\n', '            uint256 weiVal = (_mtcTokens * redeemRate);\n', '            ethRedeemed += weiVal;                                  // adds the value of transferred ETH to the redeemed ETH till now\n', '            // it need to stay last for reentery attack purpose\n', '            msg.sender.transfer(weiVal);                            // transfer the amount of ETH\n', '        }\n', '    }\n', '\n', '    function sendETHtoBoard(uint _wei) onlyOwner public {\n', '        boardAddress.transfer(_wei);\n', '    }\n', '\n', '    function collectERC20(address tokenAddress, uint256 amount) onlyOwner public {\n', '        token tokenTransfer = token(tokenAddress);\n', '        tokenTransfer.transfer(owner, amount);\n', '    }\n', '\n', '}']
