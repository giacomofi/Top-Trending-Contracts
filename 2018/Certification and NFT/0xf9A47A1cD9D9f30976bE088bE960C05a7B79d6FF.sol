['pragma solidity 0.4.24;\n', '/**\n', '* @title TECH ICO Contract\n', '* @dev TECH is an ERC-20 Standar Compliant Token\n', '* Contact: WorkChainCenters@gmail.com  www.WorkChainCenters.io\n', '*/\n', '\n', '/**\n', ' * @title SafeMath by OpenZeppelin\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title admined\n', ' * @notice This contract is administered\n', ' */\n', 'contract admined {\n', '    //mapping to user levels\n', '    mapping(address => uint8) public level;\n', '    //0 normal user\n', '    //1 basic admin\n', '    //2 master admin\n', '\n', '    /**\n', '    * @dev This contructor takes the msg.sender as the first master admin\n', '    */\n', '    constructor() internal {\n', '        level[msg.sender] = 2; //Set initial admin to contract creator\n', '        emit AdminshipUpdated(msg.sender,2); //Log the admin set\n', '    }\n', '\n', '    /**\n', '    * @dev This modifier limits function execution to the admin\n', '    */\n', '    modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions\n', '        require(level[msg.sender] >= _level ); //It require the user level to be more or equal than _level\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice This function transfer the adminship of the contract to _newAdmin\n', '    * @param _newAdmin The new admin of the contract\n', '    */\n', '    function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set\n', '        require(_newAdmin != address(0)); //The new admin must not be zero address\n', '        level[_newAdmin] = _level; //New level is set\n', '        emit AdminshipUpdated(_newAdmin,_level); //Log the admin set\n', '    }\n', '\n', '    /**\n', '    * @dev Log Events\n', '    */\n', '    event AdminshipUpdated(address _newAdmin, uint8 _level);\n', '\n', '}\n', '\n', 'contract TECHICO is admined {\n', '\n', '    using SafeMath for uint256;\n', '    //This ico have these possible states\n', '    enum State {\n', '        MainSale,\n', '        Paused,\n', '        Successful\n', '    }\n', '    //Public variables\n', '\n', '    //Time-state Related\n', '    State public state = State.MainSale; //Set initial stage\n', '    uint256 constant public SaleStart = 1527879600; //Human time (GMT): Friday, 1 de June de 2018 19:00:00\n', '    uint256 public SaleDeadline = 1535569200; //Human time (GMT): Wednesday, 29 August 2018 19:00:00\n', '    uint256 public completedAt; //Set when ico finish\n', '    //Token-eth related\n', '    uint256 public totalRaised; //eth collected in wei\n', '    uint256 public totalDistributed; //Whole sale tokens distributed\n', '    ERC20Basic public tokenReward; //Token contract address\n', '    uint256 public hardCap = 31200000 * (10 ** 18); // 31.200.000 tokens\n', '    mapping(address => uint256) public pending; //tokens pending to being transfered\n', '    //Contract details\n', '    address public creator; //Creator address\n', '    string public version = &#39;2&#39;; //Contract version\n', '    //Bonus Related - How much tokens per bonus\n', '    uint256 bonus1Remain = 1440000*10**18; //+20%\n', '    uint256 bonus2Remain = 2380000*10**18; //+15%\n', '    uint256 bonus3Remain = 3420000*10**18; //+10%\n', '    uint256 bonus4Remain = 5225000*10**18; //+5%\n', '\n', '    uint256 remainingActualState;\n', '    State laststate;\n', '\n', '    //User rights handlers\n', '    mapping (address => bool) public whiteList; //List of allowed to send eth\n', '\n', '    //Price related\n', '    uint256 rate = 3000; //3000 tokens per ether unit\n', '\n', '    //events for log\n', '    event LogFundrisingInitialized(address _creator);\n', '    event LogFundingReceived(address _addr, uint _amount, uint _currentTotal);\n', '    event LogBeneficiaryPaid(address _beneficiaryAddress);\n', '    event LogContributorsPayout(address _addr, uint _amount);\n', '    event LogFundingSuccessful(uint _totalRaised);\n', '    event LogSalePaused(bool _paused);\n', '\n', '    //Modifier to prevent execution if ico has ended or is holded\n', '    modifier notFinished() {\n', '        require(state != State.Successful && state != State.Paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice ICO constructor\n', '    * @param _addressOfTokenUsedAsReward is the token to distribute\n', '    */\n', '    constructor(ERC20Basic _addressOfTokenUsedAsReward ) public {\n', '\n', '        creator = msg.sender; //Creator is set from deployer address\n', '        tokenReward = _addressOfTokenUsedAsReward; //Token address is set during deployment\n', '        emit LogFundrisingInitialized(creator); //Log contract initialization\n', '\n', '        //PreSale tokens already sold = 4.720.047 tokens\n', '        pending[0x8eBBcb4c4177941428E9E9E68C4914fb5A89650E] = 4720047000000000000002000;\n', '        //To no exceed total tokens to sell, update numbers - bonuses not affected\n', '        totalDistributed = 4720047000000000000002000;\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice Check remaining and cost function\n', '    * @dev The cost function doesn&#39;t include the bonuses calculation\n', '    */\n', '    function remainingTokensAndCost() public view returns (uint256[2]){\n', '        uint256 remaining = hardCap.sub(totalDistributed);\n', '        uint256 cost = remaining.sub((bonus1Remain.mul(2)).div(10));\n', '        cost = cost.sub((bonus2Remain.mul(15)).div(100));\n', '        cost = cost.sub(bonus3Remain.div(10));\n', '        cost = cost.sub((bonus4Remain.mul(5)).div(100));\n', '        cost = cost.div(3000);\n', '        return [remaining,cost];\n', '    }\n', '\n', '    /**\n', '    * @notice Whitelist function\n', '    * @param _user User address to be modified on list\n', '    * @param _flag Whitelist status to set\n', '    */\n', '    function whitelistAddress(address _user, bool _flag) public onlyAdmin(1) {\n', '        whiteList[_user] = _flag; //Assign status to user on whitelist\n', '    }\n', '\n', '\n', '    /**\n', '    * @notice Pause function\n', '    * @param _flag Pause status to set\n', '    */\n', '    function pauseSale(bool _flag) onlyAdmin(2) public {\n', '        require(state != State.Successful);\n', '\n', '        if(_flag == true){\n', '            require(state != State.Paused);\n', '            laststate = state;\n', '            remainingActualState = SaleDeadline.sub(now);\n', '            state = State.Paused;\n', '            emit LogSalePaused(true);\n', '        } else {\n', '            require(state == State.Paused);\n', '            state = laststate;\n', '            SaleDeadline = now.add(remainingActualState);\n', '            emit LogSalePaused(false);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice contribution handler\n', '    */\n', '    function contribute(address _target) public notFinished payable {\n', '        require(now > SaleStart); //This time must be equal or greater than the start time\n', '\n', '        //To handle admin guided contributions\n', '        address user;\n', '        //Let&#39;s if user is an admin and is givin a valid target\n', '        if(_target != address(0) && level[msg.sender] >= 1){\n', '          user = _target;\n', '        } else {\n', '          user = msg.sender; //If not the user is the sender\n', '        }\n', '\n', '        require(whiteList[user] == true); //User must be whitelisted\n', '\n', '        totalRaised = totalRaised.add(msg.value); //ether received updated\n', '\n', '        uint256 tokenBought = msg.value.mul(rate); //base tokens amount calculation\n', '\n', '        //Bonus calc helpers\n', '        uint256 bonus = 0; //How much bonus for this sale\n', '        uint256 buyHelper = tokenBought; //Base tokens bought\n', '\n', '        //Bonus Stage 1\n', '        if(bonus1Remain > 0){ //If there still are some tokens with bonus\n', '\n', '          //Lets check if tokens bought are less or more than remaining available\n', '          //tokens whit bonus\n', '          if(buyHelper <= bonus1Remain){ //If purchase is less\n', '              bonus1Remain = bonus1Remain.sub(buyHelper); //Sub from remaining\n', '              //Calculate the bonus for the total bought amount\n', '              bonus = bonus.add((buyHelper.mul(2)).div(10));//+20%\n', '              buyHelper = 0; //Clear buy helper\n', '          }else{ //If purchase is more\n', '              buyHelper = buyHelper.sub(bonus1Remain); //Sub from purchase helper the remaining\n', '              //Calculate bonus for the remaining bonus tokens\n', '              bonus = bonus.add((bonus1Remain.mul(2)).div(10));//+20%\n', '              bonus1Remain = 0; //Clear bonus remaining tokens\n', '          }\n', '\n', '        }\n', '\n', '        //Lets check if tokens bought are less or more than remaining available\n', '        //tokens whit bonus\n', '        if(bonus2Remain > 0 && buyHelper > 0){\n', '\n', '          if(buyHelper <= bonus2Remain){ //If purchase is less\n', '              bonus2Remain = bonus2Remain.sub(buyHelper);//Sub from remaining\n', '              //Calculate the bonus for the total bought amount\n', '              bonus = bonus.add((buyHelper.mul(15)).div(100));//+15%\n', '              buyHelper = 0; //Clear buy helper\n', '          }else{ //If purchase is more\n', '              buyHelper = buyHelper.sub(bonus2Remain);//Sub from purchase helper the remaining\n', '              //Calculate bonus for the remaining bonus tokens\n', '              bonus = bonus.add((bonus2Remain.mul(15)).div(100));//+15%\n', '              bonus2Remain = 0; //Clear bonus remaining tokens\n', '          }\n', '\n', '        }\n', '\n', '        //Lets check if tokens bought are less or more than remaining available\n', '        //tokens whit bonus\n', '        if(bonus3Remain > 0 && buyHelper > 0){\n', '\n', '          if(buyHelper <= bonus3Remain){ //If purchase is less\n', '              bonus3Remain = bonus3Remain.sub(buyHelper);//Sub from remaining\n', '              //Calculate the bonus for the total bought amount\n', '              bonus = bonus.add(buyHelper.div(10));//+10%\n', '              buyHelper = 0; //Clear buy helper\n', '          }else{ //If purchase is more\n', '              buyHelper = buyHelper.sub(bonus3Remain);//Sub from purchase helper the remaining\n', '              //Calculate bonus for the remaining bonus tokens\n', '              bonus = bonus.add(bonus3Remain.div(10));//+10%\n', '              bonus3Remain = 0; //Clear bonus remaining tokens\n', '          }\n', '\n', '        }\n', '\n', '        //Lets check if tokens bought are less or more than remaining available\n', '        //tokens whit bonus\n', '        if(bonus4Remain > 0 && buyHelper > 0){\n', '\n', '          if(buyHelper <= bonus4Remain){ //If purchase is less\n', '              bonus4Remain = bonus4Remain.sub(buyHelper);//Sub from remaining\n', '              //Calculate the bonus for the total bought amount\n', '              bonus = bonus.add((buyHelper.mul(5)).div(100));//+5%\n', '              buyHelper = 0; //Clear buy helper\n', '          }else{ //If purchase is more\n', '              buyHelper = buyHelper.sub(bonus4Remain);//Sub from purchase helper the remaining\n', '              //Calculate bonus for the remaining bonus tokens\n', '              bonus = bonus.add((bonus4Remain.mul(5)).div(100));//+5%\n', '              bonus4Remain = 0; //Clear bonus remaining tokens\n', '          }\n', '\n', '        }\n', '\n', '        tokenBought = tokenBought.add(bonus); //Sum Up Bonus(es) to base purchase\n', '\n', '        require(totalDistributed.add(tokenBought) <= hardCap); //The total amount after sum up must not be more than the hardCap\n', '\n', '        pending[user] = pending[user].add(tokenBought); //Pending balance to distribute is updated\n', '        totalDistributed = totalDistributed.add(tokenBought); //Whole tokens sold updated\n', '\n', '        emit LogFundingReceived(user, msg.value, totalRaised); //Log the purchase\n', '\n', '        checkIfFundingCompleteOrExpired(); //Execute state checks\n', '    }\n', '\n', '    /**\n', '    * @notice Funtion to let users claim their tokens at the end of ico process\n', '    */\n', '    function claimTokensByUser() public{\n', '        require(state == State.Successful); //Once ico is successful\n', '        uint256 temp = pending[msg.sender]; //Get the user pending balance\n', '        pending[msg.sender] = 0; //Clear it\n', '        require(tokenReward.transfer(msg.sender,temp)); //Try to transfer\n', '        emit LogContributorsPayout(msg.sender,temp); //Log the claim\n', '    }\n', '\n', '    /**\n', '    * @notice Funtion to let admins claim users tokens on behalf of them at the end of ico process\n', '    * @param _user Target user of token claim\n', '    */\n', '    function claimTokensByAdmin(address _user) onlyAdmin(1) public{\n', '        require(state == State.Successful); //Once ico is successful\n', '        uint256 temp = pending[_user]; //Get the user pending balance\n', '        pending[_user] = 0; //Clear it\n', '        require(tokenReward.transfer(_user,temp)); //Try to transfer\n', '        emit LogContributorsPayout(_user,temp); //Log the claim\n', '    }\n', '\n', '    /**\n', '    * @notice Process to check contract current status\n', '    */\n', '    function checkIfFundingCompleteOrExpired() public {\n', '         //If hardacap or deadline is reached and not yet successful\n', '        if ( (totalDistributed == hardCap || now > SaleDeadline)\n', '            && state != State.Successful \n', '            && state != State.Paused) {\n', '            //remanent tokens are assigned to creator for later handle\n', '            pending[creator] = tokenReward.balanceOf(address(this)).sub(totalDistributed);\n', '\n', '            state = State.Successful; //ICO becomes Successful\n', '            completedAt = now; //ICO is complete\n', '\n', '            emit LogFundingSuccessful(totalRaised); //we log the finish\n', '            successful(); //and execute closure\n', '\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice successful closure handler\n', '    */\n', '    function successful() public {\n', '        require(state == State.Successful); //When successful\n', '        uint256 temp = pending[creator]; //Remanent tokens handle\n', '        pending[creator] = 0; //Clear user balance\n', '        require(tokenReward.transfer(creator,temp)); //Try to transfer\n', '\n', '        emit LogContributorsPayout(creator,temp); //Log transaction\n', '\n', '        creator.transfer(address(this).balance); //After successful, eth is send to creator\n', '\n', '        emit LogBeneficiaryPaid(creator); //Log transaction\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice Function to claim any token stuck on contract\n', '    * @param _address Address of target token\n', '    */\n', '    function externalTokensRecovery(ERC20Basic _address) onlyAdmin(2) public{\n', '        require(state == State.Successful); //Only when sale finish\n', '        require(_address != address(tokenReward)); //Target token must be different from token on sale\n', '\n', '        uint256 remainder = _address.balanceOf(this); //Check remainder tokens\n', '        _address.transfer(msg.sender,remainder); //Transfer tokens to admin\n', '\n', '    }\n', '\n', '    /*\n', '    * @dev Direct payments handler\n', '    */\n', '    function () public payable {\n', '\n', '        contribute(address(0)); //Forward to contribute function\n', '\n', '    }\n', '}']