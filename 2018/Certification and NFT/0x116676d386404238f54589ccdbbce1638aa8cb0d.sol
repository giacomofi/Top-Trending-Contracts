['pragma solidity ^0.4.20;\n', ' \n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    \n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract AGASCrowdsale is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    event Print(string _message, address _msgSender);\n', '\n', '    address public multisig = 0x0A9465529653815E61E5187517392d9C10d0f9dd; \n', '    address public addressOfERC20Tocken = 0xa7A1F840CF741B96F5A80D5856ae02F0f474251f;\n', '    ERC20 public token;\n', '    \n', '    \n', '    uint public startPreICO = 1521435600; //Mon, 19 Mar 2018 05:00:00 GMT \n', '    uint public startICO = 1523854800; //Mon, 16 Apr 2018 05:00:00 GMT\n', '    uint public startProICO = 1526274000; //Mon, 14 May 2018 05:00:00 GMT\n', '    \n', '    uint public tokenDec = 1000000000000000000; //18\n', '    \n', '    uint public PreICOHardcap = 2000000*tokenDec;\n', '    uint public ICOHardcap = 6000000*tokenDec;\n', '    uint public ProICOHardcap = 8000000*tokenDec;\n', '    uint public tokensSold = 0;\n', '    \n', '    uint public bonusAmount = 200000*tokenDec;\n', '    uint public givenBonus = 0;\n', '    \n', '    uint public PreICOPrice = 1000000000000000; // 0.001 ETH \n', '    uint public ICOPrice = 2000000000000000; // 0.002 ETH\n', '    uint public ProICOPrice = 4000000000000000; // 0.004 ETH\n', '    \n', '    \n', '    \n', '    function AGASCrowdsale(){\n', '        owner = msg.sender;\n', '        token = ERC20(addressOfERC20Tocken);\n', '    }    \n', '    \n', '    \n', '   \n', '    function tokenBalance() constant returns (uint256) {\n', '        return token.balanceOf(address(this));\n', '    } \n', '    \n', '   \n', '    function setAddressOfERC20Tocken(address _addressOfERC20Tocken) onlyOwner {\n', '        addressOfERC20Tocken =  _addressOfERC20Tocken;\n', '        token = ERC20(addressOfERC20Tocken);\n', '        \n', '    }\n', '    \n', '\n', '    function transferToken(address _to, uint _value) onlyOwner returns (bool) {\n', '        return token.transfer(_to,  _value);\n', '    }\n', '    \n', '    function() payable {\n', '        doPurchase();\n', '    }\n', '\n', '\n', '\n', '    function doPurchase() payable {\n', '       \n', '        require(now >= startPreICO);\n', '        \n', '       \n', '        require(msg.value >= 100000000000000); \n', '    \n', '        uint sum = msg.value;\n', '        uint rest = 0;\n', '        uint tokensAmount = 0;\n', '        \n', '        \n', '      \n', '        if(now >= startPreICO && now < startICO){\n', '           \n', '            require(PreICOHardcap > tokensSold);\n', '            \n', '           \n', '            tokensAmount = sum.mul(tokenDec).div(PreICOPrice);\n', '            \n', '            \n', '            if(tokensAmount.add(tokensSold) > PreICOHardcap) {\n', '              \n', '                tokensAmount = PreICOHardcap.sub(tokensSold);\n', '               \n', '                rest = sum.sub(tokensAmount.mul(PreICOPrice).div(tokenDec));\n', '            }\n', '                \n', '          \n', '        } else if(now >= startICO && now < startProICO){\n', '            \n', '            require(ICOHardcap > tokensSold);\n', '            \n', '            \n', '            tokensAmount = sum.mul(tokenDec).div(ICOPrice);\n', '            \n', '             \n', '            if(tokensAmount.add(tokensSold) > ICOHardcap) {\n', '                \n', '                tokensAmount = ICOHardcap.sub(tokensSold);\n', '              \n', '                rest = sum.sub(tokensAmount.mul(ICOPrice).div(tokenDec));\n', '            }\n', '        \n', '        \n', '        } else {\n', '            \n', '            require(ProICOHardcap > tokensSold);\n', '            \n', '            tokensAmount = sum.mul(tokenDec).div(ProICOPrice);\n', '            \n', '             \n', '            if(tokensAmount.add(tokensSold) > ProICOHardcap) {\n', '              \n', '                tokensAmount = ProICOHardcap.sub(tokensSold);\n', '              \n', '                rest = sum.sub(tokensAmount.mul(ProICOPrice).div(tokenDec));\n', '            }\n', '            \n', '        }         \n', '        \n', '      \n', '        tokensSold = tokensSold.add(tokensAmount);\n', '        \n', '\n', '\n', '        if(givenBonus < bonusAmount && tokensAmount >= 500*tokenDec){\n', '            \n', '            uint bonus = 0;\n', '            \n', '            \n', '            if(tokensAmount >= 500*tokenDec && tokensAmount <1000*tokenDec)\n', '            { \n', '               \n', '                bonus = 20*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 1000*tokenDec && tokensAmount <5000*tokenDec ) {\n', '              \n', '                bonus = 100*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 5000*tokenDec && tokensAmount <10000*tokenDec ) {\n', '               \n', '                bonus = 600*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 10000*tokenDec ) {\n', '            \n', '                bonus = 1500*tokenDec;\n', '            }\n', '\n', '            bonus = (bonus < (bonusAmount - givenBonus) ) ? bonus : (bonusAmount - givenBonus);\n', '            \n', '     \n', '            givenBonus = givenBonus.add(bonus);\n', '       \n', '            tokensAmount = tokensAmount.add(bonus);\n', '            \n', '        } \n', '\n', '        require(tokenBalance() > tokensAmount);\n', '        \n', '        require(token.transfer(msg.sender, tokensAmount));\n', '       \n', '        if(rest==0){\n', '\n', '            multisig.transfer(msg.value);\n', '        }else{\n', '\n', '            multisig.transfer(msg.value.sub(rest)); \n', '\n', '            msg.sender.transfer(rest);\n', '        }\n', '             \n', '    }\n', '\n', '}']
['pragma solidity ^0.4.20;\n', ' \n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    \n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract AGASCrowdsale is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    event Print(string _message, address _msgSender);\n', '\n', '    address public multisig = 0x0A9465529653815E61E5187517392d9C10d0f9dd; \n', '    address public addressOfERC20Tocken = 0xa7A1F840CF741B96F5A80D5856ae02F0f474251f;\n', '    ERC20 public token;\n', '    \n', '    \n', '    uint public startPreICO = 1521435600; //Mon, 19 Mar 2018 05:00:00 GMT \n', '    uint public startICO = 1523854800; //Mon, 16 Apr 2018 05:00:00 GMT\n', '    uint public startProICO = 1526274000; //Mon, 14 May 2018 05:00:00 GMT\n', '    \n', '    uint public tokenDec = 1000000000000000000; //18\n', '    \n', '    uint public PreICOHardcap = 2000000*tokenDec;\n', '    uint public ICOHardcap = 6000000*tokenDec;\n', '    uint public ProICOHardcap = 8000000*tokenDec;\n', '    uint public tokensSold = 0;\n', '    \n', '    uint public bonusAmount = 200000*tokenDec;\n', '    uint public givenBonus = 0;\n', '    \n', '    uint public PreICOPrice = 1000000000000000; // 0.001 ETH \n', '    uint public ICOPrice = 2000000000000000; // 0.002 ETH\n', '    uint public ProICOPrice = 4000000000000000; // 0.004 ETH\n', '    \n', '    \n', '    \n', '    function AGASCrowdsale(){\n', '        owner = msg.sender;\n', '        token = ERC20(addressOfERC20Tocken);\n', '    }    \n', '    \n', '    \n', '   \n', '    function tokenBalance() constant returns (uint256) {\n', '        return token.balanceOf(address(this));\n', '    } \n', '    \n', '   \n', '    function setAddressOfERC20Tocken(address _addressOfERC20Tocken) onlyOwner {\n', '        addressOfERC20Tocken =  _addressOfERC20Tocken;\n', '        token = ERC20(addressOfERC20Tocken);\n', '        \n', '    }\n', '    \n', '\n', '    function transferToken(address _to, uint _value) onlyOwner returns (bool) {\n', '        return token.transfer(_to,  _value);\n', '    }\n', '    \n', '    function() payable {\n', '        doPurchase();\n', '    }\n', '\n', '\n', '\n', '    function doPurchase() payable {\n', '       \n', '        require(now >= startPreICO);\n', '        \n', '       \n', '        require(msg.value >= 100000000000000); \n', '    \n', '        uint sum = msg.value;\n', '        uint rest = 0;\n', '        uint tokensAmount = 0;\n', '        \n', '        \n', '      \n', '        if(now >= startPreICO && now < startICO){\n', '           \n', '            require(PreICOHardcap > tokensSold);\n', '            \n', '           \n', '            tokensAmount = sum.mul(tokenDec).div(PreICOPrice);\n', '            \n', '            \n', '            if(tokensAmount.add(tokensSold) > PreICOHardcap) {\n', '              \n', '                tokensAmount = PreICOHardcap.sub(tokensSold);\n', '               \n', '                rest = sum.sub(tokensAmount.mul(PreICOPrice).div(tokenDec));\n', '            }\n', '                \n', '          \n', '        } else if(now >= startICO && now < startProICO){\n', '            \n', '            require(ICOHardcap > tokensSold);\n', '            \n', '            \n', '            tokensAmount = sum.mul(tokenDec).div(ICOPrice);\n', '            \n', '             \n', '            if(tokensAmount.add(tokensSold) > ICOHardcap) {\n', '                \n', '                tokensAmount = ICOHardcap.sub(tokensSold);\n', '              \n', '                rest = sum.sub(tokensAmount.mul(ICOPrice).div(tokenDec));\n', '            }\n', '        \n', '        \n', '        } else {\n', '            \n', '            require(ProICOHardcap > tokensSold);\n', '            \n', '            tokensAmount = sum.mul(tokenDec).div(ProICOPrice);\n', '            \n', '             \n', '            if(tokensAmount.add(tokensSold) > ProICOHardcap) {\n', '              \n', '                tokensAmount = ProICOHardcap.sub(tokensSold);\n', '              \n', '                rest = sum.sub(tokensAmount.mul(ProICOPrice).div(tokenDec));\n', '            }\n', '            \n', '        }         \n', '        \n', '      \n', '        tokensSold = tokensSold.add(tokensAmount);\n', '        \n', '\n', '\n', '        if(givenBonus < bonusAmount && tokensAmount >= 500*tokenDec){\n', '            \n', '            uint bonus = 0;\n', '            \n', '            \n', '            if(tokensAmount >= 500*tokenDec && tokensAmount <1000*tokenDec)\n', '            { \n', '               \n', '                bonus = 20*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 1000*tokenDec && tokensAmount <5000*tokenDec ) {\n', '              \n', '                bonus = 100*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 5000*tokenDec && tokensAmount <10000*tokenDec ) {\n', '               \n', '                bonus = 600*tokenDec;\n', '            \n', '            } else if ( tokensAmount >= 10000*tokenDec ) {\n', '            \n', '                bonus = 1500*tokenDec;\n', '            }\n', '\n', '            bonus = (bonus < (bonusAmount - givenBonus) ) ? bonus : (bonusAmount - givenBonus);\n', '            \n', '     \n', '            givenBonus = givenBonus.add(bonus);\n', '       \n', '            tokensAmount = tokensAmount.add(bonus);\n', '            \n', '        } \n', '\n', '        require(tokenBalance() > tokensAmount);\n', '        \n', '        require(token.transfer(msg.sender, tokensAmount));\n', '       \n', '        if(rest==0){\n', '\n', '            multisig.transfer(msg.value);\n', '        }else{\n', '\n', '            multisig.transfer(msg.value.sub(rest)); \n', '\n', '            msg.sender.transfer(rest);\n', '        }\n', '             \n', '    }\n', '\n', '}']
