['pragma solidity ^0.4.16;\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface Token {\n', '  function transfer(address _to, uint256 _value) returns (bool);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract AirDrop is Ownable {\n', '\n', '  Token token;\n', '\n', '  event TransferredToken(address indexed to, uint256 value);\n', '  event FailedTransfer(address indexed to, uint256 value);\n', '\n', '  modifier whenDropIsActive() {\n', '    assert(isActive());\n', '\n', '    _;\n', '  }\n', '\n', '  function AirDrop () {\n', '      address _tokenAddr = 0xCEb99b21d2C9CB017d4fE97E48962A89E579b744;\n', '      token = Token(_tokenAddr);\n', '  }\n', '\n', '  function isActive() constant returns (bool) {\n', '    return (\n', '        tokensAvailable() > 0 // Tokens must be available to send\n', '    );\n', '  }\n', '  //below function can be used when you want to send every recipeint with different number of tokens\n', '  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {\n', '    uint256 i = 0;\n', '    while (i < dests.length) {\n', '        uint256 toSend = values[i] * 10**18;\n', '        sendInternally(dests[i] , toSend, values[i]);\n', '        i++;\n', '    }\n', '  }\n', '\n', '  // this function can be used when you want to send same number of tokens to all the recipients\n', '  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {\n', '    uint256 i = 0;\n', '    uint256 toSend = value * 10**18;\n', '    while (i < dests.length) {\n', '        sendInternally(dests[i] , toSend, value);\n', '        i++;\n', '    }\n', '  }  \n', '\n', '  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {\n', '    if(recipient == address(0)) return;\n', '\n', '    if(tokensAvailable() >= tokensToSend) {\n', '      token.transfer(recipient, tokensToSend);\n', '      TransferredToken(recipient, valueToPresent);\n', '    } else {\n', '      FailedTransfer(recipient, valueToPresent); \n', '    }\n', '  }   \n', '\n', '\n', '  function tokensAvailable() constant returns (uint256) {\n', '    return token.balanceOf(this);\n', '  }\n', '\n', '  function destroy() onlyOwner {\n', '    uint256 balance = tokensAvailable();\n', '    require (balance > 0);\n', '    token.transfer(owner, balance);\n', '    selfdestruct(owner);\n', '  }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'interface Token {\n', '  function transfer(address _to, uint256 _value) returns (bool);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract AirDrop is Ownable {\n', '\n', '  Token token;\n', '\n', '  event TransferredToken(address indexed to, uint256 value);\n', '  event FailedTransfer(address indexed to, uint256 value);\n', '\n', '  modifier whenDropIsActive() {\n', '    assert(isActive());\n', '\n', '    _;\n', '  }\n', '\n', '  function AirDrop () {\n', '      address _tokenAddr = 0xCEb99b21d2C9CB017d4fE97E48962A89E579b744;\n', '      token = Token(_tokenAddr);\n', '  }\n', '\n', '  function isActive() constant returns (bool) {\n', '    return (\n', '        tokensAvailable() > 0 // Tokens must be available to send\n', '    );\n', '  }\n', '  //below function can be used when you want to send every recipeint with different number of tokens\n', '  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {\n', '    uint256 i = 0;\n', '    while (i < dests.length) {\n', '        uint256 toSend = values[i] * 10**18;\n', '        sendInternally(dests[i] , toSend, values[i]);\n', '        i++;\n', '    }\n', '  }\n', '\n', '  // this function can be used when you want to send same number of tokens to all the recipients\n', '  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {\n', '    uint256 i = 0;\n', '    uint256 toSend = value * 10**18;\n', '    while (i < dests.length) {\n', '        sendInternally(dests[i] , toSend, value);\n', '        i++;\n', '    }\n', '  }  \n', '\n', '  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {\n', '    if(recipient == address(0)) return;\n', '\n', '    if(tokensAvailable() >= tokensToSend) {\n', '      token.transfer(recipient, tokensToSend);\n', '      TransferredToken(recipient, valueToPresent);\n', '    } else {\n', '      FailedTransfer(recipient, valueToPresent); \n', '    }\n', '  }   \n', '\n', '\n', '  function tokensAvailable() constant returns (uint256) {\n', '    return token.balanceOf(this);\n', '  }\n', '\n', '  function destroy() onlyOwner {\n', '    uint256 balance = tokensAvailable();\n', '    require (balance > 0);\n', '    token.transfer(owner, balance);\n', '    selfdestruct(owner);\n', '  }\n', '}']
