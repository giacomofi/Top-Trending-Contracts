['pragma solidity ^0.4.21;\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface Baliv {\n', '    function getPrice(address fromToken_, address toToken_) external view returns(uint256);\n', '}\n', '\n', 'contract TokenRecipient {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint256 z = x + y;\n', '        require((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        uint z = x * y;\n', '        require((x == 0) || (z / x == y));\n', '        return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '        bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '        return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => bool) internal authbook;\n', '    address[] public operators;\n', '    address public owner;\n', '    bool public powerStatus = true;\n', '    function Authorization()\n', '        public\n', '        payable\n', '    {\n', '        owner = msg.sender;\n', '        assignOperator(msg.sender);\n', '    }\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(checkOperator(msg.sender));\n', '        _;\n', '    }\n', '    modifier onlyActive\n', '    {\n', '        assert(powerStatus);\n', '        _;\n', '    }\n', '    function powerSwitch(\n', '        bool onOff_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        powerStatus = onOff_;\n', '    }\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if(user_ != address(0) && !authbook[user_]) {\n', '            authbook[user_] = true;\n', '            operators.push(user_);\n', '        }\n', '    }\n', '    \n', '    function dismissOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        delete authbook[user_];\n', '        for(uint i = 0; i < operators.length; i++) {\n', '            if(operators[i] == user_) {\n', '                operators[i] = operators[operators.length - 1];\n', '                operators.length -= 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function checkOperator(address user_)\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return authbook[user_];\n', '    }\n', '}\n', '\n', 'contract StandardToken is SafeMath {\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Issue(address indexed _to, uint256 indexed _value);\n', '    event Burn(address indexed _from, uint256 indexed _value);\n', '\n', '    /* constructure */\n', '    function StandardToken() public payable {}\n', '\n', '    /* Send coins */\n', '    function transfer(\n', '        address to_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        if(balances[msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], amount_);\n', '            balances[to_] = safeAdd(balances[to_], amount_);\n', '            emit Transfer(msg.sender, to_, amount_);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(\n', '        address from_,\n', '        address to_,\n', '        uint256 amount_\n', '    ) public returns(bool success) {\n', '        if(balances[from_] >= amount_ && allowed[from_][msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[to_] = safeAdd(balances[to_], amount_);\n', '            balances[from_] = safeSub(balances[from_], amount_);\n', '            allowed[from_][msg.sender] = safeSub(allowed[from_][msg.sender], amount_);\n', '            emit Transfer(from_, to_, amount_);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        constant\n', '        public\n', '    returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value\n', '    )\n', '        public\n', '    returns (bool success) {\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _value,\n', '        bytes _extraData\n', '    )\n', '        public\n', '    returns (bool success) {    \n', '        if (approve(_spender, _value)) {\n', '            TokenRecipient(_spender).receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract XPAAssetToken is StandardToken, Authorization {\n', '    // metadata\n', '    address[] public burners;\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public defaultExchangeRate;\n', '    uint256 public constant decimals = 18;\n', '\n', '    // constructor\n', '    function XPAAssetToken(\n', '        string symbol_,\n', '        string name_,\n', '        uint256 defaultExchangeRate_\n', '    )\n', '        public\n', '    {\n', '        totalSupply = 0;\n', '        symbol = symbol_;\n', '        name = name_;\n', '        defaultExchangeRate = defaultExchangeRate_ > 0 ? defaultExchangeRate_ : 0.01 ether;\n', '    }\n', '\n', '    function transferOwnership(\n', '        address newOwner_\n', '    )\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '\n', '    function create(\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool success) {\n', '        if(amount_ > 0 && user_ != address(0)) {\n', '            totalSupply = safeAdd(totalSupply, amount_);\n', '            balances[user_] = safeAdd(balances[user_], amount_);\n', '            emit Issue(owner, amount_);\n', '            emit Transfer(owner, user_, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        require(allowToBurn(msg.sender));\n', '        if(amount_ > 0 && balances[msg.sender] >= amount_) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], amount_);\n', '            totalSupply = safeSub(totalSupply, amount_);\n', '            emit Transfer(msg.sender, owner, amount_);\n', '            emit Burn(owner, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burnFrom(\n', '        address user_,\n', '        uint256 amount_\n', '    )\n', '        public\n', '    returns(bool success) {\n', '        require(allowToBurn(msg.sender));\n', '        if(balances[user_] >= amount_ && allowed[user_][msg.sender] >= amount_ && amount_ > 0) {\n', '            balances[user_] = safeSub(balances[user_], amount_);\n', '            totalSupply = safeSub(totalSupply, amount_);\n', '            allowed[user_][msg.sender] = safeSub(allowed[user_][msg.sender], amount_);\n', '            emit Transfer(user_, owner, amount_);\n', '            emit Burn(owner, amount_);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function getDefaultExchangeRate(\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return defaultExchangeRate;\n', '    }\n', '\n', '    function getSymbol(\n', '    )\n', '        public\n', '        view\n', '    returns(bytes32) {\n', '        return keccak256(symbol);\n', '    }\n', '\n', '    function assignBurner(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                return;\n', '            }\n', '        }\n', '        burners.push(account_);\n', '    }\n', '\n', '    function dismissBunner(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                burners[i] = burners[burners.length - 1];\n', '                burners.length -= 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function allowToBurn(\n', '        address account_\n', '    )\n', '        public\n', '        view\n', '    returns(bool) {\n', '        if(checkOperator(account_)) {\n', '            return true;\n', '        }\n', '        for(uint256 i = 0; i < burners.length; i++) {\n', '            if(burners[i] == account_) {\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract TokenFactory is Authorization {\n', '    string public version = "0.5.0";\n', '\n', '    event eNominatingExchange(address);\n', '    event eNominatingXPAAssets(address);\n', '    event eNominatingETHAssets(address);\n', '    event eCancelNominatingExchange(address);\n', '    event eCancelNominatingXPAAssets(address);\n', '    event eCancelNominatingETHAssets(address);\n', '    event eChangeExchange(address, address);\n', '    event eChangeXPAAssets(address, address);\n', '    event eChangeETHAssets(address, address);\n', '    event eAddFundAccount(address);\n', '    event eRemoveFundAccount(address);\n', '\n', '    address[] public assetTokens;\n', '    address[] public fundAccounts;\n', '    address public exchange = 0x008ea74569c1b9bbb13780114b6b5e93396910070a;\n', '    address public exchangeOldVersion = 0x0013b4b9c415213bb2d0a5d692b6f2e787b927c211;\n', '    address public XPAAssets = address(0);\n', '    address public ETHAssets = address(0);\n', '    address public candidateXPAAssets = address(0);\n', '    address public candidateETHAssets = address(0);\n', '    address public candidateExchange = address(0);\n', '    uint256 public candidateTillXPAAssets = 0;\n', '    uint256 public candidateTillETHAssets = 0;\n', '    uint256 public candidateTillExchange = 0;\n', '    address public XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '    address public ETH = address(0);\n', '\n', '     /* constructor */\n', '    function TokenFactory(\n', '        address XPAAddr, \n', '        address balivAddr\n', '    ) public {\n', '        XPA = XPAAddr;\n', '        exchange = balivAddr;\n', '    }\n', '\n', '    function createToken(\n', '        string symbol_,\n', '        string name_,\n', '        uint256 defaultExchangeRate_\n', '    )\n', '        public\n', '    returns(address) {\n', '        require(msg.sender == XPAAssets);\n', '        bool tokenRepeat = false;\n', '        address newAsset;\n', '        for(uint256 i = 0; i < assetTokens.length; i++) {\n', '            if(XPAAssetToken(assetTokens[i]).getSymbol() == keccak256(symbol_)){\n', '                tokenRepeat = true;\n', '                newAsset = assetTokens[i];\n', '                break;\n', '            }\n', '        }\n', '        if(!tokenRepeat){\n', '            newAsset = new XPAAssetToken(symbol_, name_, defaultExchangeRate_);\n', '            XPAAssetToken(newAsset).assignOperator(XPAAssets);\n', '            XPAAssetToken(newAsset).assignOperator(ETHAssets);\n', '            for(uint256 j = 0; j < fundAccounts.length; j++) {\n', '                XPAAssetToken(newAsset).assignBurner(fundAccounts[j]);\n', '            }\n', '            assetTokens.push(newAsset);\n', '        }\n', '        return newAsset;\n', '    }\n', '\n', '    // set to candadite, after 7 days set to exchange, set again after 7 days\n', '    function setExchange(\n', '        address exchange_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(\n', '            exchange_ != address(0)\n', '        );\n', '        if(\n', '            exchange_ == exchange &&\n', '            candidateExchange != address(0)\n', '        ) {\n', '            emit eCancelNominatingExchange(candidateExchange);\n', '            candidateExchange = address(0);\n', '            candidateTillExchange = 0;\n', '        } else if(\n', '            exchange == address(0)\n', '        ) {\n', '            // initial value\n', '            emit eChangeExchange(address(0), exchange_);\n', '            exchange = exchange_;\n', '            exchangeOldVersion = exchange_;\n', '        } else if(\n', '            exchange_ != candidateExchange &&\n', '            candidateTillExchange + 86400 * 7 < block.timestamp\n', '        ) {\n', '            // set to candadite\n', '            emit eNominatingExchange(exchange_);\n', '            candidateExchange = exchange_;\n', '            candidateTillExchange = block.timestamp + 86400 * 7;\n', '        } else if(\n', '            exchange_ == candidateExchange &&\n', '            candidateTillExchange < block.timestamp\n', '        ) {\n', '            // set to exchange\n', '            emit eChangeExchange(exchange, candidateExchange);\n', '            exchangeOldVersion = exchange;\n', '            exchange = candidateExchange;\n', '            candidateExchange = address(0);\n', '        }\n', '    }\n', '\n', '    function setXPAAssets(\n', '        address XPAAssets_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(\n', '            XPAAssets_ != address(0)\n', '        );\n', '        if(\n', '            XPAAssets_ == XPAAssets &&\n', '            candidateXPAAssets != address(0)\n', '        ) {\n', '            emit eCancelNominatingXPAAssets(candidateXPAAssets);\n', '            candidateXPAAssets = address(0);\n', '            candidateTillXPAAssets = 0;\n', '        } else if(\n', '            XPAAssets == address(0)\n', '        ) {\n', '            // initial value\n', '            emit eChangeXPAAssets(address(0), XPAAssets_);\n', '            XPAAssets = XPAAssets_;\n', '        } else if(\n', '            XPAAssets_ != candidateXPAAssets &&\n', '            candidateTillXPAAssets + 86400 * 7 < block.timestamp\n', '        ) {\n', '            // set to candadite\n', '            emit eNominatingXPAAssets(XPAAssets_);\n', '            candidateXPAAssets = XPAAssets_;\n', '            candidateTillXPAAssets = block.timestamp + 86400 * 7;\n', '        } else if(\n', '            XPAAssets_ == candidateXPAAssets &&\n', '            candidateTillXPAAssets < block.timestamp\n', '        ) {\n', '            // set to XPAAssets\n', '            emit eChangeXPAAssets(XPAAssets, candidateXPAAssets);\n', '            dismissTokenOperator(XPAAssets);\n', '            assignTokenOperator(candidateXPAAssets);\n', '            XPAAssets = candidateXPAAssets;\n', '            candidateXPAAssets = address(0);\n', '        }\n', '    }\n', '\n', '    function setETHAssets(\n', '        address ETHAssets_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(\n', '            ETHAssets_ != address(0)\n', '        );\n', '        if(\n', '            ETHAssets_ == ETHAssets &&\n', '            candidateETHAssets != address(0)\n', '        ) {\n', '            emit eCancelNominatingETHAssets(candidateETHAssets);\n', '            candidateETHAssets = address(0);\n', '            candidateTillETHAssets = 0;\n', '        } else if(\n', '            ETHAssets == address(0)\n', '        ) {\n', '            // initial value\n', '            ETHAssets = ETHAssets_;\n', '        } else if(\n', '            ETHAssets_ != candidateETHAssets &&\n', '            candidateTillETHAssets + 86400 * 7 < block.timestamp\n', '        ) {\n', '            // set to candadite\n', '            emit eNominatingETHAssets(ETHAssets_);\n', '            candidateETHAssets = ETHAssets_;\n', '            candidateTillETHAssets = block.timestamp + 86400 * 7;\n', '        } else if(\n', '            ETHAssets_ == candidateETHAssets &&\n', '            candidateTillETHAssets < block.timestamp\n', '        ) {\n', '            // set to ETHAssets\n', '            emit eChangeETHAssets(ETHAssets, candidateETHAssets);\n', '            dismissTokenOperator(ETHAssets);\n', '            assignTokenOperator(candidateETHAssets);\n', '            ETHAssets = candidateETHAssets;\n', '            candidateETHAssets = address(0);\n', '        }\n', '    }\n', '\n', '    function addFundAccount(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        for(uint256 i = 0; i < fundAccounts.length; i++) {\n', '            if(fundAccounts[i] == account_) {\n', '                return;\n', '            }\n', '        }\n', '        for(uint256 j = 0; j < assetTokens.length; j++) {\n', '            XPAAssetToken(assetTokens[i]).assignBurner(account_);\n', '        }\n', '        emit eAddFundAccount(account_);\n', '        fundAccounts.push(account_);\n', '    }\n', '\n', '    function removeFundAccount(\n', '        address account_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        require(account_ != address(0));\n', '        uint256 i = 0;\n', '        uint256 j = 0;\n', '        for(i = 0; i < fundAccounts.length; i++) {\n', '            if(fundAccounts[i] == account_) {\n', '                for(j = 0; j < assetTokens.length; j++) {\n', '                    XPAAssetToken(assetTokens[i]).dismissBunner(account_);\n', '                }\n', '                fundAccounts[i] = fundAccounts[fundAccounts.length - 1];\n', '                fundAccounts.length -= 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getPrice(\n', '        address token_\n', '    ) \n', '        public\n', '        view\n', '    returns(uint256) {\n', '        uint256 currPrice = Baliv(exchange).getPrice(XPA, token_);\n', '        if(currPrice == 0) {\n', '            currPrice = XPAAssetToken(token_).getDefaultExchangeRate();\n', '        }\n', '        return currPrice;\n', '    }\n', '\n', '    function getAssetLength(\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return assetTokens.length;\n', '    }\n', '\n', '    function getAssetToken(\n', '        uint256 index_\n', '    )\n', '        public\n', '        view\n', '    returns(address) {\n', '        return assetTokens[index_];\n', '    }\n', '\n', '    function assignTokenOperator(address user_)\n', '        internal\n', '    {\n', '        if(user_ != address(0)) {\n', '            for(uint256 i = 0; i < assetTokens.length; i++) {\n', '                XPAAssetToken(assetTokens[i]).assignOperator(user_);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function dismissTokenOperator(address user_)\n', '        internal\n', '    {\n', '        if(user_ != address(0)) {\n', '            for(uint256 i = 0; i < assetTokens.length; i++) {\n', '                XPAAssetToken(assetTokens[i]).dismissOperator(user_);\n', '            }\n', '        }\n', '    }\n', '}']