['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title InteractiveCrowdsaleLib\n', ' * @author Modular, Inc\n', ' *\n', ' * version 2.0.0\n', ' * Copyright (c) 2017 Modular, Inc\n', ' * The MIT License (MIT)\n', ' *\n', ' * The InteractiveCrowdsale Library provides functionality to create a crowdsale\n', ' * based on the white paper initially proposed by Jason Teutsch and Vitalik\n', ' * Buterin. See https://people.cs.uchicago.edu/~teutsch/papers/ico.pdf for\n', ' * further information.\n', ' *\n', ' * This library was developed in a collaborative effort among many organizations\n', ' * including TrueBit, Modular, and Consensys.\n', ' * For further information: truebit.io, modular.network,\n', ' * consensys.net\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' */\n', '\n', 'library InteractiveCrowdsaleLib {\n', '  using SafeMath for uint256;\n', '  using TokenLib for TokenLib.TokenStorage;\n', '  using LinkedListLib for LinkedListLib.LinkedList;\n', '\n', '  // Node constants for use in the linked list\n', '  uint256 constant NULL = 0;\n', '  uint256 constant HEAD = 0;\n', '  bool constant PREV = false;\n', '  bool constant NEXT = true;\n', '\n', '  struct InteractiveCrowdsaleStorage {\n', '\n', '    address owner;     //owner of the crowdsale\n', '\n', '  \tuint256 tokensPerEth;  //number of tokens received per ether\n', '  \tuint256 startTime; //ICO start time, timestamp\n', '  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n', '    uint256 ownerBalance; //owner wei Balance\n', '    uint256 startingTokenBalance; //initial amount of tokens for sale\n', '\n', '    //shows how much wei an address has contributed\n', '  \tmapping (address => uint256) hasContributed;\n', '\n', '    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n', '  \tmapping (address => uint256) withdrawTokensMap;\n', '\n', '    // any leftover wei that buyers contributed that didn&#39;t add up to a whole token amount\n', '    mapping (address => uint256) leftoverWei;\n', '\n', '  \tInteractiveCrowdsaleToken token; //token being sold\n', '\n', '    // List of personal valuations, sorted from smallest to largest (from LinkedListLib)\n', '    LinkedListLib.LinkedList valuationsList;\n', '\n', '    // Info holder for token creation\n', '    TokenLib.TokenStorage tokenInfo;\n', '\n', '    uint256 endWithdrawalTime;   // time when manual withdrawals are no longer allowed\n', '\n', '    // current total valuation of the sale\n', '    // actual amount of ETH committed, taking into account partial purchases\n', '    uint256 totalValuation;\n', '\n', '    // amount of value committed at this valuation, cannot rely on owner balance\n', '    // due to fluctations in commitment calculations needed after owner withdraws\n', '    // in other words, the total amount of ETH committed, including total bids\n', '    // that will eventually get partial purchases\n', '    uint256 valueCommitted;\n', '\n', '    // the bucket that sits either at or just below current total valuation.\n', '    // determines where the cutoff point is for bids in the sale\n', '    uint256 currentBucket;\n', '\n', '    // the fraction of each minimal valuation bidder&#39;s ether refund, &#39;q&#39; is from the paper\n', '    // and is calculated when finalizing the sale\n', '    uint256 q;\n', '\n', '    // minimim amount that the sale needs to make to be successfull\n', '    uint256 minimumRaise;\n', '\n', '    // percentage of total tokens being sold in this sale\n', '    uint8 percentBeingSold;\n', '\n', '    // the bonus amount for early bidders.  This is a percentage of the base token\n', '    // price that gets added on the the base token price used in getCurrentBonus()\n', '    uint256 priceBonusPercent;\n', '\n', '    // Indicates that the owner has finalized the sale and withdrawn Ether\n', '    bool isFinalized;\n', '\n', '    // Set to true if the sale is canceled\n', '    bool isCanceled;\n', '\n', '    // shows the price that the address purchased tokens at\n', '    mapping (address => uint256) pricePurchasedAt;\n', '\n', '    // the sums of bids at each valuation.  Used to calculate the current bucket for the valuation pointer\n', '    mapping (uint256 => uint256) valuationSums;\n', '\n', '    // the number of active bids at a certain valuation cap\n', '    mapping (uint256 => uint256) numBidsAtValuation;\n', '\n', '    // the valuation cap that each address has submitted\n', '    mapping (address => uint256) personalCaps;\n', '\n', '    // shows if an address has done a manual withdrawal. manual withdrawals are only allowed once\n', '    mapping (address => bool) hasManuallyWithdrawn;\n', '  }\n', '\n', '  // Indicates when an address has withdrawn their supply of tokens\n', '  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n', '\n', '  // Indicates when an address has withdrawn their supply of extra wei\n', '  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n', '\n', '  // Logs when owner has pulled eth\n', '  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n', '\n', '  // Indicates when a bidder submits a bid to the crowdsale\n', '  event LogBidAccepted(address indexed bidder, uint256 amount, uint256 personalValuation);\n', '\n', '  // Indicates when a bidder manually withdraws their bid from the crowdsale\n', '  event LogBidWithdrawn(address indexed bidder, uint256 amount, uint256 personalValuation);\n', '\n', '  // Indicates when a bid is removed by the automated bid removal process\n', '  event LogBidRemoved(address indexed bidder, uint256 personalValuation);\n', '\n', '  // Generic Error Msg Event\n', '  event LogErrorMsg(uint256 amount, string Msg);\n', '\n', '  // Indicates when the price of the token changes\n', '  event LogTokenPriceChange(uint256 amount, string Msg);\n', '\n', '  // Logs the current bucket that the valuation points to, the total valuation of\n', '  // the sale, and the amount of ETH committed, including total bids that will eventually get partial purchases\n', '  event BucketAndValuationAndCommitted(uint256 bucket, uint256 valuation, uint256 committed);\n', '\n', '  modifier saleEndedNotFinal(InteractiveCrowdsaleStorage storage self) {\n', '    require(now > self.endTime && (!self.isFinalized));\n', '    _;\n', '  }\n', '\n', '  /// @dev Called by a crowdsale contract upon creation.\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _owner Address of crowdsale owner\n', '  /// @param _priceBonusPercent the bonus amount for early bidders\n', '  /// @param _minimumRaise minimim amount that the sale needs to make to be successfull\n', '  /// @param _tokensPerEth the number of tokens to be received per ether sent\n', '  /// @param _startTime timestamp of sale start time\n', '  /// @param _endWithdrawalTime timestamp that indicates that manual withdrawals are no longer allowed\n', '  /// @param _endTime Timestamp of sale end time\n', '  /// @param _percentBeingSold percentage of total tokens being sold in the sale\n', '  /// @param _tokenName name of the token being sold. ex: "Jason Network Token"\n', '  /// @param _tokenSymbol symbol of the token. ex: "JNT"\n', '  /// @param _tokenDecimals number of decimals in the token\n', '  function init(InteractiveCrowdsaleStorage storage self,\n', '                address _owner,\n', '                uint256 _priceBonusPercent,\n', '                uint256 _minimumRaise,\n', '                uint256 _tokensPerEth,\n', '                uint256 _startTime,\n', '                uint256 _endWithdrawalTime,\n', '                uint256 _endTime,\n', '                uint8 _percentBeingSold,\n', '                string _tokenName,\n', '                string _tokenSymbol,\n', '                uint8 _tokenDecimals) internal\n', '  {\n', '    //g base.startTime is start of ICO\n', '    //g base.endTime is end of ICO\n', '    //g times are checked endTime > endWithdrawalTime > startTime\n', '    require(self.owner == 0);\n', '    require(_owner > 0);\n', '    require(_endWithdrawalTime < _endTime);\n', '    require(_endWithdrawalTime > _startTime);\n', '    require(_minimumRaise > 0);\n', '    require(_percentBeingSold > 0);\n', '    require(_percentBeingSold <= 100);\n', '    require(_priceBonusPercent > 0);\n', '\n', '    /* Just sets a bunch of parameters for the sale in the struct. */\n', '    self.owner = _owner;\n', '    self.priceBonusPercent = _priceBonusPercent;\n', '    self.minimumRaise = _minimumRaise;\n', '    self.tokensPerEth = _tokensPerEth;\n', '    self.startTime = _startTime;\n', '    self.endWithdrawalTime = _endWithdrawalTime;\n', '    self.endTime = _endTime;\n', '    self.percentBeingSold = _percentBeingSold;\n', '    self.tokenInfo.name = _tokenName;\n', '    self.tokenInfo.symbol = _tokenSymbol;\n', '    self.tokenInfo.decimals = _tokenDecimals;\n', '  }\n', '\n', '  /// @dev calculates the number of digits in a given number\n', '  /// @param _number the number for which we&#39;re caluclating digits\n', '  /// @return _digits the number of digits in _number\n', '  /* J: I tested out this and it seemed to work for  */\n', '  function numDigits(uint256 _number) private pure returns (uint256) {\n', '    uint256 _digits = 0;\n', '    while (_number != 0) {\n', '      _number /= 10;\n', '      _digits++;\n', '    }\n', '    return _digits;\n', '  }\n', '\n', '  /// @dev calculates the number of tokens purchased based on the amount of wei\n', '  ///      spent and the price of tokens\n', '  /// @param _amount amound of wei that the buyer sent\n', '  /// @param _price price of tokens in the sale, in tokens/ETH\n', '  /// @return uint256 numTokens the number of tokens purchased\n', '  /// @return remainder  any remaining wei leftover from integer division\n', '  function calculateTokenPurchase(uint256 _amount,\n', '                                  uint256 _price)\n', '                                  private\n', '                                  pure\n', '                                  returns (uint256,uint256)\n', '  {\n', '    uint256 remainder = 0; //temp calc holder for division remainder for leftover wei\n', '\n', '    uint256 numTokens;\n', '    uint256 weiTokens; //temp calc holder\n', '\n', '    // Find the number of tokens as a function in wei\n', '    weiTokens = _amount.mul(_price);\n', '\n', '    numTokens = weiTokens / 1000000000000000000;\n', '    remainder = weiTokens % 1000000000000000000;\n', '    remainder = remainder / _price;\n', '\n', '    return (numTokens,remainder);\n', '  }\n', '\n', '  /// @dev Called when an address wants to submit a bid to the sale\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return currentBonus percentage of the bonus that is applied for the purchase\n', '  function getCurrentBonus(InteractiveCrowdsaleStorage storage self) private view returns (uint256){\n', '\n', '    uint256 bonusTime;\n', '    uint256 elapsed;\n', '    uint256 currentBonus;\n', '\n', '    bonusTime = self.endWithdrawalTime.sub(self.startTime);\n', '    elapsed = now.sub(self.startTime);\n', '\n', '    uint256 percentElapsed = (elapsed.mul(100))/bonusTime;\n', '\n', '    currentBonus = self.priceBonusPercent.sub(((percentElapsed.mul(self.priceBonusPercent))/100));\n', '\n', '    return currentBonus;\n', '  }\n', '\n', '  function isAValidPurchase(InteractiveCrowdsaleStorage storage self) private view returns (bool){\n', '    require(msg.sender != self.owner);\n', '\n', '    bool nonZeroPurchase = msg.value != 0;\n', '    require(nonZeroPurchase);\n', '    // bidder can&#39;t have already bid   /* Hmmm... why not? Probably just makes logic easier. */ <--- To prevent false signaling\n', '    require((self.personalCaps[msg.sender] == 0) && (self.hasContributed[msg.sender] == 0));\n', '    return true;\n', '  }\n', '\n', '  /// @dev Called when an address wants to submit bid to the sale\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @param _amount amound of wei that the buyer is sending\n', '  /// @param _personalCap the total crowdsale valuation (wei) that the bidder is comfortable with\n', '  /// @param _valuePredict prediction of where the valuation will go in the linked list. saves on searching time\n', '  /// @return true on succesful bid\n', '  function submitBid(InteractiveCrowdsaleStorage storage self,\n', '                      uint256 _amount,\n', '                      uint256 _personalCap,\n', '                      uint256 _valuePredict)\n', '                      public\n', '                      returns (bool)\n', '  {\n', '    require(crowdsaleIsActive(self));\n', '    require(isAValidPurchase(self));\n', '    uint256 _bonusPercent;\n', '    uint256 placeholder;\n', '    // token purchase bonus only applies before the withdrawal lock\n', '    if (isBeforeWithdrawalLock(self)) { /* first half of the sale */\n', '      require(_personalCap > _amount); /* Kind of a silly check, but I guess it would be bad if this was false. */\n', '      _bonusPercent = getCurrentBonus(self);\n', '    } else { /* Thus we&#39;re in the second half of the sale. validPurchase ensures it&#39;s not over.*/\n', '      // The personal valuation submitted must be greater than the current\n', '      // valuation plus the bid if after the withdrawal lock.\n', '      require(_personalCap >= self.totalValuation.add(_amount)); /* Your max cap must be at least the current total valuation, plus your contribution. */\n', '    }\n', '\n', '    // personal valuation and minimum should be set to the proper granularity,\n', '    // only three most significant values can be non-zero. reduces the number of possible\n', '    // valuation buckets in the linked list\n', '    placeholder = numDigits(_personalCap);\n', '    if(placeholder > 3) {\n', '      /* Must be divisible by 10x the number of digits over 3.\n', '        ie. 1230 has 4 digits. It&#39;s divisible by (4-3)*10 = 10, so it&#39;s OK.\n', '       */\n', '      require((_personalCap % (10**(placeholder - 3))) == 0);\n', '    }\n', '\n', '    // add the bid to the sorted valuations list\n', '    // duplicate personal valuation caps share a spot in the linked list\n', '    if(!self.valuationsList.nodeExists(_personalCap)){\n', '        placeholder = self.valuationsList.getSortedSpot(_valuePredict,_personalCap,NEXT);\n', '        self.valuationsList.insert(placeholder,_personalCap,PREV);\n', '    }\n', '\n', '    // add the bid to the address => cap mapping\n', '    self.personalCaps[msg.sender] = _personalCap;\n', '\n', '    // add the bid to the sum of bids at this valuation. Needed for calculating correct valuation pointer\n', '    self.valuationSums[_personalCap] = self.valuationSums[_personalCap].add(_amount);\n', '\n', '    self.numBidsAtValuation[_personalCap] = self.numBidsAtValuation[_personalCap].add(1);\n', '\n', '    // add the bid to bidder&#39;s contribution amount\n', '    self.hasContributed[msg.sender] = self.hasContributed[msg.sender].add(_amount);\n', '\n', '    // temp variables for calculation\n', '    uint256 _proposedCommit;\n', '    uint256 _currentBucket;\n', '    bool loop;\n', '    bool exists;\n', '\n', '    // we only affect the pointer if we are coming in above it\n', '    if(_personalCap > self.currentBucket){\n', '\n', '      // if our valuation is sitting at the current bucket then we are using\n', '      // commitments right at their cap\n', '      if (self.totalValuation == self.currentBucket) {\n', '        // we are going to drop those commitments to see if we are going to be\n', '        // greater than the current bucket without them\n', '        _proposedCommit = (self.valueCommitted.sub(self.valuationSums[self.currentBucket])).add(_amount);\n', '\n', '        if(_proposedCommit > self.currentBucket){ loop = true; }\n', '      } else {\n', '        // else we&#39;re sitting in between buckets and have already dropped the\n', '        // previous commitments\n', '        _proposedCommit = self.totalValuation.add(_amount);\n', '        loop = true;\n', '      }\n', '\n', '      if(loop){\n', '        // if we&#39;re going to loop we move to the next bucket\n', '        (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, NEXT);\n', '\n', '        while(_proposedCommit >= _currentBucket){\n', '          // while we are proposed higher than the next bucket we drop commitments\n', '          // and iterate to the next\n', '          _proposedCommit = _proposedCommit.sub(self.valuationSums[_currentBucket]);\n', '\n', '          /**Stop checking err here**/\n', '          (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, NEXT);\n', '        }\n', '        // once we&#39;ve reached a bucket too high we move back to the last bucket and set it\n', '        (exists, _currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV);\n', '        self.currentBucket = _currentBucket;\n', '      } else {\n', '        // else we&#39;re staying at the current bucket\n', '        _currentBucket = self.currentBucket;\n', '      }\n', '      // if our proposed commitment is less than or equal to the bucket\n', '      if(_proposedCommit <= _currentBucket){\n', '        // we add the commitments in that bucket\n', '        _proposedCommit = self.valuationSums[_currentBucket].add(_proposedCommit);\n', '        // and our value is capped at that bucket\n', '        self.totalValuation = _currentBucket;\n', '      } else {\n', '        // else our total value is in between buckets and it equals the total commitements\n', '        self.totalValuation = _proposedCommit;\n', '      }\n', '\n', '      self.valueCommitted = _proposedCommit;\n', '    } else if(_personalCap == self.totalValuation){\n', '      self.valueCommitted = self.valueCommitted.add(_amount);\n', '    }\n', '\n', '    self.pricePurchasedAt[msg.sender] = (self.tokensPerEth.mul(_bonusPercent.add(100)))/100;\n', '    LogBidAccepted(msg.sender, _amount, _personalCap);\n', '    BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted);\n', '    return true;\n', '  }\n', '\n', '\n', '  /// @dev Called when an address wants to manually withdraw their bid from the\n', '  ///      sale. puts their wei in the LeftoverWei mapping\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true on succesful\n', '  function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n', '    // The sender has to have already bid on the sale\n', '    require(self.personalCaps[msg.sender] > 0);\n', '    require(crowdsaleIsActive(self));\n', '    uint256 refundWei;\n', '    // cannot withdraw after compulsory withdraw period is over unless the bid&#39;s\n', '    // valuation is below the cutoff\n', '    if (isAfterWithdrawalLock(self)) {\n', '      require(self.personalCaps[msg.sender] < self.totalValuation);\n', '\n', '      // full refund because their bid no longer affects the total sale valuation\n', '      refundWei = self.hasContributed[msg.sender];\n', '    } else {\n', '      require(!self.hasManuallyWithdrawn[msg.sender]);  // manual withdrawals are only allowed once\n', '      /***********************************************************************\n', '      The following lines were commented out due to stack depth, but they represent\n', '      the variables and calculations from the paper. The actual code is the same\n', '      thing spelled out using current variables.  See section 4 of the white paper for formula used\n', '      ************************************************************************/\n', '      //uint256 t = self.endWithdrawalTime - self.startTime;\n', '      //uint256 s = now - self.startTime;\n', '      //uint256 pa = self.pricePurchasedAt[msg.sender];\n', '      //uint256 pu = self.tokensPerEth;\n', '      //uint256 multiplierPercent =  (100*(t - s))/t;\n', '      //self.pricePurchasedAt = pa-((pa-pu)/3)\n', '      uint256 timeLeft;\n', '\n', '      timeLeft = self.endWithdrawalTime.sub(now);\n', '      uint256 multiplierPercent = (timeLeft.mul(100)) / (self.endWithdrawalTime.sub(self.startTime));\n', '\n', '      refundWei = (multiplierPercent.mul(self.hasContributed[msg.sender])) / 100;\n', '      self.valuationSums[self.personalCaps[msg.sender]] = self.valuationSums[self.personalCaps[msg.sender]].sub(refundWei);\n', '\n', '      self.numBidsAtValuation[self.personalCaps[msg.sender]] = self.numBidsAtValuation[self.personalCaps[msg.sender]].sub(1);\n', '\n', '      uint256 bonusAmount;\n', '      bonusAmount = self.pricePurchasedAt[msg.sender].sub(self.tokensPerEth);\n', '      self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender].sub(bonusAmount / 3);\n', '\n', '      self.hasManuallyWithdrawn[msg.sender] = true;\n', '\n', '    }\n', '\n', '    // Put the sender&#39;s contributed wei into the leftoverWei mapping for later withdrawal\n', '    self.leftoverWei[msg.sender] = self.leftoverWei[msg.sender].add(refundWei);\n', '\n', '    // subtract the bidder&#39;s refund from its total contribution\n', '    self.hasContributed[msg.sender] = self.hasContributed[msg.sender].sub(refundWei);\n', '\n', '    uint256 _proposedCommit;\n', '    uint256 _proposedValue;\n', '    uint256 _currentBucket;\n', '    bool loop;\n', '    bool exists;\n', '\n', '    // bidder&#39;s withdrawal only affects the pointer if the personal cap is at or\n', '    // above the current valuation\n', '    if(self.personalCaps[msg.sender] >= self.totalValuation){\n', '\n', '      // first we remove the refundWei from the committed value\n', '      _proposedCommit = self.valueCommitted.sub(refundWei);\n', '\n', '      // if we&#39;ve dropped below the current bucket\n', '      if(_proposedCommit <= self.currentBucket){\n', '        // and current valuation is above the bucket\n', '        if(self.totalValuation > self.currentBucket){\n', '          _proposedCommit = self.valuationSums[self.currentBucket].add(_proposedCommit);\n', '        }\n', '\n', '        if(_proposedCommit >= self.currentBucket){\n', '          _proposedValue = self.currentBucket;\n', '        } else {\n', '          // if we are still below the current bucket then we need to iterate\n', '          loop = true;\n', '        }\n', '      } else {\n', '        if(self.totalValuation == self.currentBucket){\n', '          _proposedValue = self.totalValuation;\n', '        } else {\n', '          _proposedValue = _proposedCommit;\n', '        }\n', '      }\n', '\n', '      if(loop){\n', '        // if we&#39;re going to loop we move to the previous bucket\n', '        (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV);\n', '        while(_proposedCommit <= _currentBucket){\n', '          // while we are proposed lower than the previous bucket we add commitments\n', '          _proposedCommit = self.valuationSums[_currentBucket].add(_proposedCommit);\n', '          // and iterate to the previous\n', '          if(_proposedCommit >= _currentBucket){\n', '            _proposedValue = _currentBucket;\n', '          } else {\n', '            (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV);\n', '          }\n', '        }\n', '\n', '        if(_proposedValue == 0) { _proposedValue = _proposedCommit; }\n', '\n', '        self.currentBucket = _currentBucket;\n', '      }\n', '\n', '      self.totalValuation = _proposedValue;\n', '      self.valueCommitted = _proposedCommit;\n', '    }\n', '\n', '    LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]);\n', '    BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted);\n', '    return true;\n', '  }\n', '\n', '  /// @dev This should be called once the sale is over to commit all bids into\n', '  ///      the owner&#39;s bucket.\n', '  /// @param self stored crowdsale from crowdsale contract\n', '\n', '  //g !!! Shouldn&#39;t this just be callable by the owner !!!\n', '  function finalizeSale(InteractiveCrowdsaleStorage storage self) public\n', '           saleEndedNotFinal(self)\n', '           returns (bool)\n', '  {\n', '    setCanceled(self);\n', '\n', '    self.isFinalized = true;\n', '    require(launchToken(self));\n', '    //g may need to be computed due to EVM rounding errors\n', '    uint256 computedValue;\n', '\n', '    //g if it has not been canceld then calculate the ownerBalance\n', '    if(!self.isCanceled){\n', '      if(self.totalValuation == self.currentBucket){\n', '        // calculate the fraction of each minimal valuation bidders ether and tokens to refund\n', '        self.q = ((((self.valueCommitted.sub(self.totalValuation)).mul(100)))/self.valuationSums[self.totalValuation]).add(uint256(1));\n', '        computedValue = self.valueCommitted.sub(self.valuationSums[self.totalValuation]);\n', '        computedValue = computedValue.add(((uint256(100).sub(self.q)).mul(self.valuationSums[self.totalValuation]))/100);\n', '      } else {\n', '        // no computation necessary\n', '        computedValue = self.totalValuation;\n', '      }\n', '      self.ownerBalance = computedValue;  // sets ETH raised in the sale to be ready for withdrawal\n', '    }\n', '  }\n', '\n', '  /// @dev Mints the token being sold by taking the percentage of the token supply\n', '  ///      being sold in this sale along with the valuation, derives all necessary\n', '  ///      values and then transfers owner tokens to the owner.\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  function launchToken(InteractiveCrowdsaleStorage storage self) private returns (bool) {\n', '    // total valuation of all the tokens not including the bonus\n', '    uint256 _fullValue = (self.totalValuation.mul(100))/uint256(self.percentBeingSold);\n', '    // total valuation of bonus tokens\n', '    uint256 _bonusValue = ((self.totalValuation.mul(self.priceBonusPercent.add(100)))/100).sub(self.totalValuation);\n', '    // total supply of all tokens not including the bonus\n', '    uint256 _supply = (_fullValue.mul(self.tokensPerEth))/1000000000000000000;\n', '    // total number of bonus tokens\n', '    uint256 _bonusTokens = (_bonusValue.mul(self.tokensPerEth))/1000000000000000000;\n', '    // tokens allocated to the owner of the sale\n', '    uint256 _ownerTokens = _supply.sub((_supply.mul(uint256(self.percentBeingSold)))/100);\n', '    // total supply of tokens including the bonus tokens\n', '    uint256 _totalSupply = _supply.add(_bonusTokens);\n', '\n', '    // deploy new token contract with total number of tokens\n', '    self.token = new InteractiveCrowdsaleToken(address(this),\n', '                                               self.tokenInfo.name,\n', '                                               self.tokenInfo.symbol,\n', '                                               self.tokenInfo.decimals,\n', '                                               _totalSupply);\n', '\n', '\n', '    if(!self.isCanceled){\n', '      //g only the owner tokens go to the owner\n', '      self.token.transfer(self.owner, _ownerTokens);\n', '    } else {\n', '      //g if the sale got canceled, then all the tokens go to the owner and bonus tokens are burned\n', '      self.token.transfer(self.owner, _supply);\n', '      self.token.burnToken(_bonusTokens);\n', '    }\n', '    // the owner of the crowdsale becomes the new owner of the token contract\n', '    self.token.changeOwner(self.owner);\n', '    self.startingTokenBalance = _supply.sub(_ownerTokens);\n', '\n', '    return true;\n', '  }\n', '\n', '  /// @dev returns a boolean indicating if the sale is canceled.\n', '  ///      This can either be if the minimum raise hasn&#39;t been met\n', '  ///      or if it is 30 days after the sale and the owner hasn&#39;t finalized the sale.\n', '  /* That&#39;s a weird condition */\n', '  /// @return bool canceled indicating if the sale is canceled or not\n', '  function setCanceled(InteractiveCrowdsaleStorage storage self) private returns(bool){\n', '    bool canceled = (self.totalValuation < self.minimumRaise) ||\n', '                    ((now > (self.endTime + 30 days)) && !self.isFinalized);\n', '\n', '    if(canceled) {self.isCanceled = true;}\n', '\n', '    return self.isCanceled;\n', '  }\n', '\n', '  /// @dev If the address&#39; personal cap is below the pointer, refund them all their ETH.\n', '  ///      if it is above the pointer, calculate tokens purchased and refund leftoever ETH\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return bool success if the contract runs successfully\n', '  /* What should not happen here? */\n', '  function retrieveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n', '    require(now > self.endTime); /* This ensure that the endTime is past */\n', '    require(self.personalCaps[msg.sender] > 0); /* This requires that  */\n', '\n', '    uint256 numTokens; /* setup some pointers */\n', '    uint256 remainder;\n', '\n', '    if(!self.isFinalized){\n', '      require(setCanceled(self));\n', '    }\n', '\n', '    if (self.isCanceled) {\n', '      // if the sale was canceled, everyone gets a full refund\n', '      self.leftoverWei[msg.sender] = self.leftoverWei[msg.sender].add(self.hasContributed[msg.sender]);\n', '      self.hasContributed[msg.sender] = 0;\n', '      LogErrorMsg(self.totalValuation, "Sale is canceled, all bids have been refunded!");\n', '      return true;\n', '    }\n', '\n', '    if (self.personalCaps[msg.sender] < self.totalValuation) {\n', '\n', '      // full refund if personal cap is less than total valuation\n', '      self.leftoverWei[msg.sender] += self.hasContributed[msg.sender];\n', '\n', '      // set hasContributed to 0 to prevent participant from calling this over and over\n', '      self.hasContributed[msg.sender] = 0;\n', '\n', '      return withdrawLeftoverWei(self);\n', '\n', '    } else if (self.personalCaps[msg.sender] == self.totalValuation) {\n', '\n', '      // calculate the portion that this address has to take out of their bid\n', '      uint256 refundAmount = (self.q.mul(self.hasContributed[msg.sender]))/100;\n', '      uint256 dust = (self.q.mul(self.hasContributed[msg.sender]))%100;\n', '\n', '      // refund that amount of wei to the address\n', '      self.leftoverWei[msg.sender] = self.leftoverWei[msg.sender].add(refundAmount);\n', '\n', '      // subtract that amount the address&#39; contribution\n', '      self.hasContributed[msg.sender] = self.hasContributed[msg.sender].sub(refundAmount);\n', '      if(dust > 0) {\n', '        self.leftoverWei[msg.sender] = self.leftoverWei[msg.sender].add(dust);\n', '        self.hasContributed[msg.sender] = self.hasContributed[msg.sender].sub(dust);\n', '      }\n', '    }\n', '\n', '    // calculate the number of tokens that the bidder purchased\n', '    (numTokens, remainder) = calculateTokenPurchase(self.hasContributed[msg.sender],\n', '                                                    self.pricePurchasedAt[msg.sender]);\n', '\n', '    self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender].add(numTokens);\n', '    self.valueCommitted = self.valueCommitted.sub(remainder);\n', '    self.hasContributed[msg.sender] = self.hasContributed[msg.sender].sub(remainder);\n', '    self.leftoverWei[msg.sender] = self.leftoverWei[msg.sender].add(remainder);\n', '\n', '    // burn any extra bonus tokens\n', '    uint256 _fullBonus;\n', '    uint256 _fullBonusPrice = (self.tokensPerEth.mul(self.priceBonusPercent.add(100)))/100;\n', '    (_fullBonus, remainder) = calculateTokenPurchase(self.hasContributed[msg.sender], _fullBonusPrice);\n', '    uint256 _leftoverBonus = _fullBonus.sub(numTokens);\n', '\n', '    self.token.burnToken(_leftoverBonus);\n', '\n', '    self.hasContributed[msg.sender] = 0;\n', '\n', '    // send tokens and leftoverWei to the address calling the function\n', '    withdrawTokens(self);\n', '\n', '    withdrawLeftoverWei(self);\n', '\n', '  }\n', '\n', '  /// @dev Function called by purchasers to pull tokens\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if tokens were withdrawn\n', '  function withdrawTokens(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n', '    bool ok;\n', '\n', '    if (self.withdrawTokensMap[msg.sender] == 0) {\n', '      LogErrorMsg(0, "Sender has no tokens to withdraw!");\n', '      return false;\n', '    }\n', '\n', '    if (msg.sender == self.owner) {\n', '      if(!self.isFinalized){\n', '        LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!");\n', '        return false;\n', '      }\n', '    }\n', '\n', '    uint256 total = self.withdrawTokensMap[msg.sender];\n', '    self.withdrawTokensMap[msg.sender] = 0;\n', '    ok = self.token.transfer(msg.sender, total);\n', '    require(ok);\n', '    LogTokensWithdrawn(msg.sender, total);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Function called by purchasers to pull leftover wei from their purchases\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if wei was withdrawn\n', '  function withdrawLeftoverWei(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n', '    if (self.leftoverWei[msg.sender] == 0) {\n', '      LogErrorMsg(0, "Sender has no extra wei to withdraw!");\n', '      return false;\n', '    }\n', '\n', '    uint256 total = self.leftoverWei[msg.sender];\n', '    self.leftoverWei[msg.sender] = 0;\n', '    msg.sender.transfer(total);\n', '    LogWeiWithdrawn(msg.sender, total);\n', '    return true;\n', '  }\n', '\n', '  /// @dev send ether from the completed crowdsale to the owners wallet address\n', '  /// @param self Stored crowdsale from crowdsale contract\n', '  /// @return true if owner withdrew eth\n', '  function withdrawOwnerEth(InteractiveCrowdsaleStorage storage self) public returns (bool) {\n', '    require(msg.sender == self.owner);\n', '    require(self.ownerBalance > 0);\n', '    require(self.isFinalized);\n', '\n', '    uint256 amount = self.ownerBalance;\n', '    self.ownerBalance = 0;\n', '    self.owner.transfer(amount);\n', '    LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!");\n', '\n', '    return true;\n', '  }\n', '\n', '  function crowdsaleIsActive(InteractiveCrowdsaleStorage storage self) public view returns (bool) {\n', '    return (now >= self.startTime && now <= self.endTime);\n', '  }\n', '\n', '  function isBeforeWithdrawalLock(InteractiveCrowdsaleStorage storage self) public view returns (bool) {\n', '    return now < self.endWithdrawalTime;\n', '  }\n', '\n', '  function isAfterWithdrawalLock(InteractiveCrowdsaleStorage storage self) public view returns (bool) {\n', '    return now >= self.endWithdrawalTime;\n', '  }\n', '\n', '  function getPersonalCap(InteractiveCrowdsaleStorage storage self, address _bidder) public view returns (uint256) {\n', '    return self.personalCaps[_bidder];\n', '  }\n', '\n', '}\n', '\n', 'pragma solidity 0.4.21;\n', '\n', '/**\n', ' * @title LinkedListLib\n', ' * @author Darryl Morris (o0ragman0o) and Modular.network\n', ' *\n', ' * This utility library was forked from https://github.com/o0ragman0o/LibCLL\n', ' * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\n', ' * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\n', ' * coding patterns.\n', ' *\n', ' * version 1.1.1\n', ' * Copyright (c) 2017 Modular Inc.\n', ' * The MIT License (MIT)\n', ' * https://github.com/Modular-network/ethereum-libraries/blob/master/LICENSE\n', ' *\n', ' * The LinkedListLib provides functionality for implementing data indexing using\n', ' * a circlular linked list\n', ' *\n', ' * Modular provides smart contract services and security reviews for contract\n', ' * deployments in addition to working on open source projects in the Ethereum\n', ' * community. Our purpose is to test, document, and deploy reusable code onto the\n', ' * blockchain and improve both security and usability. We also educate non-profits,\n', ' * schools, and other community members about the application of blockchain\n', ' * technology. For further information: modular.network\n', ' *\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', '*/\n', '\n', '\n', 'library LinkedListLib {\n', '\n', '    uint256 constant NULL = 0;\n', '    uint256 constant HEAD = 0;\n', '    bool constant PREV = false;\n', '    bool constant NEXT = true;\n', '\n', '    struct LinkedList{\n', '        mapping (uint256 => mapping (bool => uint256)) list;\n', '    }\n', '\n', '    /// @dev returns true if the list exists\n', '    /// @param self stored linked list from contract\n', '    function listExists(LinkedList storage self)\n', '        public\n', '        view returns (bool)\n', '    {\n', '        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n', '        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev returns true if the node exists\n', '    /// @param self stored linked list from contract\n', '    /// @param _node a node to search for\n', '    function nodeExists(LinkedList storage self, uint256 _node)\n', '        public\n', '        view returns (bool)\n', '    {\n', '        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n', '            if (self.list[HEAD][NEXT] == _node) {\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the number of elements in the list\n', '    /// @param self stored linked list from contract\n', '    function sizeOf(LinkedList storage self) public view returns (uint256 numElements) {\n', '        bool exists;\n', '        uint256 i;\n', '        (exists,i) = getAdjacent(self, HEAD, NEXT);\n', '        while (i != HEAD) {\n', '            (exists,i) = getAdjacent(self, i, NEXT);\n', '            numElements++;\n', '        }\n', '        return;\n', '    }\n', '\n', '    /// @dev Returns the links of a node as a tuple\n', '    /// @param self stored linked list from contract\n', '    /// @param _node id of the node to get\n', '    function getNode(LinkedList storage self, uint256 _node)\n', '        public view returns (bool,uint256,uint256)\n', '    {\n', '        if (!nodeExists(self,_node)) {\n', '            return (false,0,0);\n', '        } else {\n', '            return (true,self.list[_node][PREV], self.list[_node][NEXT]);\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the link of a node `_node` in direction `_direction`.\n', '    /// @param self stored linked list from contract\n', '    /// @param _node id of the node to step from\n', '    /// @param _direction direction to step in\n', '    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\n', '        public view returns (bool,uint256)\n', '    {\n', '        if (!nodeExists(self,_node)) {\n', '            return (false,0);\n', '        } else {\n', '            return (true,self.list[_node][_direction]);\n', '        }\n', '    }\n', '\n', '    /// @dev Can be used before `insert` to build an ordered list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node an existing node to search from, e.g. HEAD.\n', '    /// @param _value value to seek\n', '    /// @param _direction direction to seek in\n', '    //  @return next first node beyond &#39;_node&#39; in direction `_direction`\n', '    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\n', '        public view returns (uint256)\n', '    {\n', '        if (sizeOf(self) == 0) { return 0; }\n', '        require((_node == 0) || nodeExists(self,_node));\n', '        bool exists;\n', '        uint256 next;\n', '        (exists,next) = getAdjacent(self, _node, _direction);\n', '        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\n', '        return next;\n', '    }\n', '\n', '    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\n', '    /// @param self stored linked list from contract\n', '    /// @param _node first node for linking\n', '    /// @param _link  node to link to in the _direction\n', '    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) private  {\n', '        self.list[_link][!_direction] = _node;\n', '        self.list[_node][_direction] = _link;\n', '    }\n', '\n', '    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n', '    /// @param self stored linked list from contract\n', '    /// @param _node existing node\n', '    /// @param _new  new node to insert\n', '    /// @param _direction direction to insert node in\n', '    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n', '        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\n', '            uint256 c = self.list[_node][_direction];\n', '            createLink(self, _node, _new, _direction);\n', '            createLink(self, _new, c, _direction);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev removes an entry from the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node node to remove from the list\n', '    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\n', '        if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; }\n', '        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\n', '        delete self.list[_node][PREV];\n', '        delete self.list[_node][NEXT];\n', '        return _node;\n', '    }\n', '\n', '    /// @dev pushes an enrty to the head of the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _node new entry to push to the head\n', '    /// @param _direction push to the head (NEXT) or tail (PREV)\n', '    function push(LinkedList storage self, uint256 _node, bool _direction) internal  {\n', '        insert(self, HEAD, _node, _direction);\n', '    }\n', '\n', '    /// @dev pops the first entry from the linked list\n', '    /// @param self stored linked list from contract\n', '    /// @param _direction pop from the head (NEXT) or the tail (PREV)\n', '    function pop(LinkedList storage self, bool _direction) internal returns (uint256) {\n', '        bool exists;\n', '        uint256 adj;\n', '\n', '        (exists,adj) = getAdjacent(self, HEAD, _direction);\n', '\n', '        return remove(self, adj);\n', '    }\n', '}\n', '\n', 'library BasicMathLib {\n', '  /// @dev Multiplies two numbers and checks for overflow before returning.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The product of a and b, or 0 if there is overflow\n', '  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := mul(a,b)\n', '      switch or(iszero(b), eq(div(res,b), a))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Divides two numbers but checks for 0 in the divisor first.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if `b` is 0\n', '  /// @return res The quotient of a and b, or 0 if `b` is 0\n', '  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n', '    uint256 res;\n', '    assembly{\n', '      switch iszero(b)\n', '      case 0 {\n', '        res := div(a,b)\n', '        let loc := mload(0x40)\n', '        mstore(add(loc,0x20),res)\n', '        i := mload(add(loc,0x20))\n', '      }\n', '      default {\n', '        err := 1\n', '        i := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Adds two numbers and checks for overflow before returning.\n', '  /// Does not throw.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The sum of a and b, or 0 if there is overflow\n', '  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n', '    assembly{\n', '      res := add(a,b)\n', '      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Subtracts two numbers and checks for underflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is underflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is underflow\n', '  /// @return res The difference between a and b, or 0 if there is underflow\n', '  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := sub(a,b)\n', '      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n', '      case 0 {\n', '        err := 1\n', '        res := 0\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'library TokenLib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct TokenStorage {\n', '    bool initialized;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    string name;\n', '    string symbol;\n', '    uint256 totalSupply;\n', '    uint256 initialSupply;\n', '    address owner;\n', '    uint8 decimals;\n', '    bool stillMinting;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event OwnerChange(address from, address to);\n', '  event Burn(address indexed burner, uint256 value);\n', '  event MintingClosed(bool mintingClosed);\n', '\n', '  /// @dev Called by the Standard Token upon creation.\n', '  /// @param self Stored token from token contract\n', '  /// @param _name Name of the new token\n', '  /// @param _symbol Symbol of the new token\n', '  /// @param _decimals Decimal places for the token represented\n', '  /// @param _initial_supply The initial token supply\n', '  /// @param _allowMinting True if additional tokens can be created, false otherwise\n', '  function init(TokenStorage storage self,\n', '                address _owner,\n', '                string _name,\n', '                string _symbol,\n', '                uint8 _decimals,\n', '                uint256 _initial_supply,\n', '                bool _allowMinting)\n', '                public\n', '  {\n', '    require(!self.initialized);\n', '    self.initialized = true;\n', '    self.name = _name;\n', '    self.symbol = _symbol;\n', '    self.totalSupply = _initial_supply;\n', '    self.initialSupply = _initial_supply;\n', '    self.decimals = _decimals;\n', '    self.owner = _owner;\n', '    self.stillMinting = _allowMinting;\n', '    self.balances[_owner] = _initial_supply;\n', '  }\n', '\n', '  /// @dev Transfer tokens from caller&#39;s account to another account.\n', '  /// @param self Stored token from token contract\n', '  /// @param _to Address to send tokens\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    bool err;\n', '    uint256 balance;\n', '\n', '    (err,balance) = self.balances[msg.sender].minus(_value);\n', '    require(!err);\n', '    self.balances[msg.sender] = balance;\n', '    //It&#39;s not possible to overflow token supply\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Authorized caller transfers tokens from one account to another\n', '  /// @param self Stored token from token contract\n', '  /// @param _from Address to send tokens from\n', '  /// @param _to Address to send tokens to\n', '  /// @param _value Number of tokens to send\n', '  /// @return True if completed\n', '  function transferFrom(TokenStorage storage self,\n', '                        address _from,\n', '                        address _to,\n', '                        uint256 _value)\n', '                        public\n', '                        returns (bool)\n', '  {\n', '    uint256 _allowance = self.allowed[_from][msg.sender];\n', '    bool err;\n', '    uint256 balanceOwner;\n', '    uint256 balanceSpender;\n', '\n', '    (err,balanceOwner) = self.balances[_from].minus(_value);\n', '    require(!err);\n', '\n', '    (err,balanceSpender) = _allowance.minus(_value);\n', '    require(!err);\n', '\n', '    self.balances[_from] = balanceOwner;\n', '    self.allowed[_from][msg.sender] = balanceSpender;\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Retrieve token balance for an account\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address to retrieve balance of\n', '  /// @return balance The number of tokens in the subject account\n', '  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n', '    return self.balances[_owner];\n', '  }\n', '\n', '  /// @dev Authorize an account to send tokens on caller&#39;s behalf\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _value Number of tokens authorized account may send\n', '  /// @return True if completed\n', '  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n', '    // must set to zero before changing approval amount in accordance with spec\n', '    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n', '\n', '    self.allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Remaining tokens third party spender has to send\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address of token holder\n', '  /// @param _spender Address of authorized spender\n', '  /// @return remaining Number of tokens spender has left in owner&#39;s account\n', '  function allowance(TokenStorage storage self, address _owner, address _spender)\n', '                     public\n', '                     view\n', '                     returns (uint256 remaining) {\n', '    return self.allowed[_owner][_spender];\n', '  }\n', '\n', '  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\n', '  /// @param _increase True if increasing allowance, false if decreasing allowance\n', '  /// @return True if completed\n', '  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n', '                          public returns (bool)\n', '  {\n', '    uint256 _newAllowed;\n', '    bool err;\n', '\n', '    if(_increase) {\n', '      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n', '      require(!err);\n', '\n', '      self.allowed[msg.sender][_spender] = _newAllowed;\n', '    } else {\n', '      if (_valueChange > self.allowed[msg.sender][_spender]) {\n', '        self.allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n', '        self.allowed[msg.sender][_spender] = _newAllowed;\n', '      }\n', '    }\n', '\n', '    emit Approval(msg.sender, _spender, _newAllowed);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Change owning address of the token contract, specifically for minting\n', '  /// @param self Stored token from token contract\n', '  /// @param _newOwner Address for the new owner\n', '  /// @return True if completed\n', '  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n', '    require((self.owner == msg.sender) && (_newOwner > 0));\n', '\n', '    self.owner = _newOwner;\n', '    emit OwnerChange(msg.sender, _newOwner);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Mints additional tokens, new tokens go to owner\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Number of tokens to mint\n', '  /// @return True if completed\n', '  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n', '    require((self.owner == msg.sender) && self.stillMinting);\n', '    uint256 _newAmount;\n', '    bool err;\n', '\n', '    (err, _newAmount) = self.totalSupply.plus(_amount);\n', '    require(!err);\n', '\n', '    self.totalSupply =  _newAmount;\n', '    self.balances[self.owner] = self.balances[self.owner] + _amount;\n', '    emit Transfer(0x0, self.owner, _amount);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanent stops minting\n', '  /// @param self Stored token from token contract\n', '  /// @return True if completed\n', '  function closeMint(TokenStorage storage self) public returns (bool) {\n', '    require(self.owner == msg.sender);\n', '\n', '    self.stillMinting = false;\n', '    emit MintingClosed(true);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Permanently burn tokens\n', '  /// @param self Stored token from token contract\n', '  /// @param _amount Amount of tokens to burn\n', '  /// @return True if completed\n', '  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n', '      uint256 _newBalance;\n', '      bool err;\n', '\n', '      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n', '      require(!err);\n', '\n', '      self.balances[msg.sender] = _newBalance;\n', '      self.totalSupply = self.totalSupply - _amount;\n', '      emit Burn(msg.sender, _amount);\n', '      emit Transfer(msg.sender, 0x0, _amount);\n', '      return true;\n', '  }\n', '}\n', '\n', 'contract InteractiveCrowdsaleToken {\n', '  using TokenLib for TokenLib.TokenStorage;\n', '\n', '  TokenLib.TokenStorage public token;\n', '\n', '  /* FLAG: the owner can mint new tokens. This is an issue if not properly configured. */\n', '  function InteractiveCrowdsaleToken(address owner,\n', '                                     string name,\n', '                                     string symbol,\n', '                                     uint8 decimals,\n', '                                     uint256 initialSupply) public\n', '  {\n', '    token.init(owner, name, symbol, decimals, initialSupply, false);\n', '  }\n', '\n', '  function name() public view returns (string) {\n', '    return token.name;\n', '  }\n', '\n', '  function symbol() public view returns (string) {\n', '    return token.symbol;\n', '  }\n', '\n', '  function decimals() public view returns (uint8) {\n', '    return token.decimals;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return token.totalSupply;\n', '  }\n', '\n', '  function initialSupply() public view returns (uint256) {\n', '    return token.initialSupply;\n', '  }\n', '\n', '  function balanceOf(address who) public view returns (uint256) {\n', '    return token.balanceOf(who);\n', '  }\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return token.allowance(owner, spender);\n', '  }\n', '\n', '  function transfer(address to, uint value) public returns (bool ok) {\n', '    return token.transfer(to, value);\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n', '    return token.transferFrom(from, to, value);\n', '  }\n', '\n', '  function approve(address spender, uint value) public returns (bool ok) {\n', '    return token.approve(spender, value);\n', '  }\n', '\n', '  function approveChange(address spender, uint256 valueChange, bool increase)\n', '                         public returns (bool ok)\n', '  {\n', '    return token.approveChange(spender, valueChange, increase);\n', '  }\n', '\n', '  function changeOwner(address newOwner) public returns (bool ok) {\n', '    return token.changeOwner(newOwner);\n', '  }\n', '\n', '  function mintToken(uint256 amount) public returns (bool ok) {\n', '    return token.mintToken(amount);\n', '  }\n', '\n', '  function closeMint() public returns (bool ok) {\n', '    return token.closeMint();\n', '  }\n', '\n', '  function burnToken(uint256 amount) public returns (bool ok) {\n', '    return token.burnToken(amount);\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']