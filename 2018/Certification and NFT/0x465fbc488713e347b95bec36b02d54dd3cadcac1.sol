['pragma solidity ^0.4.24;\n', '\n', '/* COOPEX Smart Contract */\n', '/* This is the smart &#39;hotwallet&#39; for the Cooperative Exchange. All Ethereum assets will be stored on this smart contract. This smart contract will be used while we work on a fully decentralized exchange. */\n', '/* Visit us at https://coopex.market */\n', '\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', 'contract Exchange {\n', '    \n', '    \n', '\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '  \n', '  constructor() {\n', '    owner = msg.sender;\n', '    locked = false;\n', '    secure = false;\n', '  }\n', '  \n', '  address public owner;\n', '  mapping (address => bool) public admins;\n', '  bool locked;\n', '  bool secure;\n', '  \n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  event Deposit(address token, address user, uint256 amount);\n', '  event Withdraw(address token, address user, uint256 amount);\n', '  event Lock(bool lock);\n', '  \n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyAdmin {\n', '    require(msg.sender != owner && !admins[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  function setOwner(address newOwner) onlyOwner {\n', '    SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  \n', '  function getOwner() view returns (address out) {\n', '    return owner;\n', '  }\n', '\n', '  function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '\n', '\n', '  function() public payable {\n', '    Deposit(0, msg.sender, msg.value);\n', '  }\n', '\n', ' \n', '\n', '  function withdraw(address token, uint256 amount) onlyAdmin returns (bool success) {\n', '    require(!locked);\n', '    if (token == address(0)) {\n', '        if(msg.sender != owner && secure && (amount > this.balance / 3)){\n', '            locked = true;\n', '            Lock(true);\n', '        }\n', '        else{\n', '            require(msg.sender.send(amount));\n', '        }\n', '    } else {\n', '      require(amount <= Token(token).balanceOf(this));\n', '      require(Token(token).transfer(msg.sender, amount));\n', '    }\n', '    Withdraw(token, msg.sender, amount);\n', '    return true;\n', '  }\n', '\n', '  function lock() onlyOwner{\n', '      locked = true;\n', '      Lock(true);\n', '  }\n', '  \n', '  function unlock() onlyOwner{\n', '      locked = false;\n', '      Lock(false);\n', '  }\n', '  \n', '  function secureMode() onlyOwner{\n', '      secure = true;\n', '  }\n', '  \n', '  function insecureMode() onlyOwner{\n', '      secure = false;\n', '  }\n', '  \n', '  function getBalance(address token) view returns (uint256 balance){\n', '      if(token == address(0)){\n', '          return this.balance;\n', '      }\n', '      else{\n', '          return Token(token).balanceOf(this);\n', '      }\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/* COOPEX Smart Contract */\n', "/* This is the smart 'hotwallet' for the Cooperative Exchange. All Ethereum assets will be stored on this smart contract. This smart contract will be used while we work on a fully decentralized exchange. */\n", '/* Visit us at https://coopex.market */\n', '\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', 'contract Exchange {\n', '    \n', '    \n', '\n', '  function safeMul(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '  \n', '  constructor() {\n', '    owner = msg.sender;\n', '    locked = false;\n', '    secure = false;\n', '  }\n', '  \n', '  address public owner;\n', '  mapping (address => bool) public admins;\n', '  bool locked;\n', '  bool secure;\n', '  \n', '  event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '  event Deposit(address token, address user, uint256 amount);\n', '  event Withdraw(address token, address user, uint256 amount);\n', '  event Lock(bool lock);\n', '  \n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  modifier onlyAdmin {\n', '    require(msg.sender != owner && !admins[msg.sender]);\n', '    _;\n', '  }\n', '  \n', '  function setOwner(address newOwner) onlyOwner {\n', '    SetOwner(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '  \n', '  function getOwner() view returns (address out) {\n', '    return owner;\n', '  }\n', '\n', '  function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '    admins[admin] = isAdmin;\n', '  }\n', '\n', '\n', '\n', '  function() public payable {\n', '    Deposit(0, msg.sender, msg.value);\n', '  }\n', '\n', ' \n', '\n', '  function withdraw(address token, uint256 amount) onlyAdmin returns (bool success) {\n', '    require(!locked);\n', '    if (token == address(0)) {\n', '        if(msg.sender != owner && secure && (amount > this.balance / 3)){\n', '            locked = true;\n', '            Lock(true);\n', '        }\n', '        else{\n', '            require(msg.sender.send(amount));\n', '        }\n', '    } else {\n', '      require(amount <= Token(token).balanceOf(this));\n', '      require(Token(token).transfer(msg.sender, amount));\n', '    }\n', '    Withdraw(token, msg.sender, amount);\n', '    return true;\n', '  }\n', '\n', '  function lock() onlyOwner{\n', '      locked = true;\n', '      Lock(true);\n', '  }\n', '  \n', '  function unlock() onlyOwner{\n', '      locked = false;\n', '      Lock(false);\n', '  }\n', '  \n', '  function secureMode() onlyOwner{\n', '      secure = true;\n', '  }\n', '  \n', '  function insecureMode() onlyOwner{\n', '      secure = false;\n', '  }\n', '  \n', '  function getBalance(address token) view returns (uint256 balance){\n', '      if(token == address(0)){\n', '          return this.balance;\n', '      }\n', '      else{\n', '          return Token(token).balanceOf(this);\n', '      }\n', '  }\n', '\n', '}']
