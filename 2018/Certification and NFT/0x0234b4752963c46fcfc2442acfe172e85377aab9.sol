['pragma solidity 0.4.24;\n', '\n', '/* script to setup contracts after full redeploy on Rinkeby.\n', '    called via  StabilityBoardProxy (MultiSig) but deployer account is the only signer yet because\n', '        these working on the new contracts only.\n', '        Stability Board and pretoken signers will be added and deployer will be removed when setup is successful.\n', '*/\n', '\n', 'contract Main0001_initFirstDeploy {\n', '    address constant DEPLOYER_ACCOUNT = 0x7b534c2D0F9Ee973e0b6FE8D4000cA711A20f22e;\n', '    address constant RATES_FEEDER_ACCOUNT = 0x8C58187a978979947b88824DCdA5Cb5fD4410387;\n', '\n', '    // new contracts\n', '    address constant preTokenProxyAddress = 0x1411b3B189B01f6e6d1eA883bFFcbD3a5224934C;\n', '    address constant stabilityBoardProxyAddress = 0x4686f017D456331ed2C1de66e134D8d05B24413D;\n', '\n', '    PreToken constant preToken = PreToken(0xeCb782B19Be6E657ae2D88831dD98145A00D32D5);\n', '    Rates constant rates = Rates(0x4babbe57453e2b6AF125B4e304256fCBDf744480);\n', '    FeeAccount constant feeAccount = FeeAccount(0xF6B541E1B5e001DCc11827C1A16232759aeA730a);\n', '    AugmintReserves constant augmintReserves = AugmintReserves(0x633cb544b2EF1bd9269B2111fD2B66fC05cd3477);\n', '    InterestEarnedAccount constant interestEarnedAccount = InterestEarnedAccount(0x5C1a44E07541203474D92BDD03f803ea74f6947c);\n', '    TokenAEur constant tokenAEur = TokenAEur(0x86A635EccEFFfA70Ff8A6DB29DA9C8DB288E40D0);\n', '    MonetarySupervisor constant monetarySupervisor = MonetarySupervisor(0x1Ca4F9d261707aF8A856020a4909B777da218868);\n', '    LoanManager constant loanManager = LoanManager(0xCBeFaF199b800DEeB9EAd61f358EE46E06c54070);\n', '    Locker constant locker = Locker(0x095c0F071Fd75875a6b5a1dEf3f3a993F591080c);\n', '    Exchange constant exchange = Exchange(0x8b52b019d237d0bbe8Baedf219132D5254e0690b);\n', '\n', '    function execute(Main0001_initFirstDeploy /* self, not used */) external {\n', '        // called via StabilityBoardProxy\n', '        require(address(this) == stabilityBoardProxyAddress, "only deploy via stabilityboardsigner");\n', '\n', '        /******************************************************************************\n', '         * Set up permissions\n', '         ******************************************************************************/\n', '        //  preToken Permissions\n', '        bytes32[] memory preTokenPermissions = new bytes32[](2); // dynamic array needed for grantMultiplePermissions()\n', '        preTokenPermissions[0] = "PreTokenSigner";\n', '        preTokenPermissions[1] = "PermissionGranter";\n', '        preToken.grantMultiplePermissions(preTokenProxyAddress, preTokenPermissions);\n', '\n', '        // StabilityBoard\n', '        rates.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        feeAccount.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        interestEarnedAccount.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        tokenAEur.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        augmintReserves.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        monetarySupervisor.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        loanManager.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        locker.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '        exchange.grantPermission(stabilityBoardProxyAddress, "StabilityBoard");\n', '\n', '        // RatesFeeder permissions to allow calling setRate()\n', '        rates.grantPermission(RATES_FEEDER_ACCOUNT, "RatesFeeder");\n', '\n', '        // set NoTransferFee permissions\n', '        feeAccount.grantPermission(feeAccount, "NoTransferFee");\n', '        feeAccount.grantPermission(augmintReserves, "NoTransferFee");\n', '        feeAccount.grantPermission(interestEarnedAccount, "NoTransferFee");\n', '        feeAccount.grantPermission(monetarySupervisor, "NoTransferFee");\n', '        feeAccount.grantPermission(loanManager, "NoTransferFee");\n', '        feeAccount.grantPermission(locker, "NoTransferFee");\n', '        feeAccount.grantPermission(exchange, "NoTransferFee");\n', '\n', '        // set MonetarySupervisor permissions\n', '        interestEarnedAccount.grantPermission(monetarySupervisor, "MonetarySupervisor");\n', '        tokenAEur.grantPermission(monetarySupervisor, "MonetarySupervisor");\n', '        augmintReserves.grantPermission(monetarySupervisor, "MonetarySupervisor");\n', '\n', '        // set LoanManager permissions\n', '        monetarySupervisor.grantPermission(loanManager, "LoanManager");\n', '\n', '        // set Locker permissions\n', '        monetarySupervisor.grantPermission(locker, "Locker");\n', '\n', '        /******************************************************************************\n', '         * Add loan products\n', '         ******************************************************************************/\n', '        // term (in sec), discountRate, loanCoverageRatio, minDisbursedAmount (w/ 4 decimals), defaultingFeePt, isActive\n', '        loanManager.addLoanProduct(30 days, 990641, 600000, 1000, 50000, true); //  12% p.a.\n', '        loanManager.addLoanProduct(14 days, 996337, 600000, 1000, 50000, true); // 10% p.a.\n', '        loanManager.addLoanProduct(7 days, 998170, 600000, 1000, 50000, true); // 10% p.a.\n', '\n', '        /******************************************************************************\n', '         * Add lock products\n', '         ******************************************************************************/\n', '        // (perTermInterest, durationInSecs, minimumLockAmount, isActive)\n', '        locker.addLockProduct(4019, 30 days, 1000, true);  // 5% p.a.\n', '        locker.addLockProduct(1506, 14 days, 1000, true);  // 4% p.a.\n', '        locker.addLockProduct(568, 7 days, 1000, true);    //  3% p.a.\n', '\n', '        /******************************************************************************\n', '         * Revoke PermissionGranter from deployer account\n', '         *   NB: migration scripts mistekanly granted it to deployer account (account[0])\n', '         *          instead of StabilityBoardProxy in constructors\n', '         ******************************************************************************/\n', '         preToken.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         rates.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         feeAccount.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         augmintReserves.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         interestEarnedAccount.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         tokenAEur.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         monetarySupervisor.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         loanManager.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         locker.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '         exchange.revokePermission(DEPLOYER_ACCOUNT, "PermissionGranter");\n', '\n', '         /******************************************************************************\n', '          * Revoke PermissionGranter from this contract on preToken\n', '          * NB: deploy script temporarly granted PermissionGranter to this script\n', '          *   now we can remove it as we granted it to preTokenProxy above\n', '          ******************************************************************************/\n', '         preToken.revokePermission(stabilityBoardProxyAddress, "PermissionGranter");\n', '    }\n', '}\n', '\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '\n', '    TODO: check against ds-math: https://blog.dapphub.com/ds-math/\n', '    TODO: move roundedDiv to a sep lib? (eg. Math.sol)\n', '*/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        require(a == 0 || c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 c = a / b;\n', '        // require(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n', '        require(b > 0, "div by 0"); // Solidity automatically throws for div by 0 but require to emit reason\n', '        uint256 z = a / b;\n', '        if (a % b >= b / 2) {\n', '            z++;  // no need for safe add b/c it can happen only if we divided the input\n', '        }\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Generic contract to authorise calls to certain functions only from a given address.\n', '    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\n', '\n', '    deployment works as:\n', '           1. contract deployer account deploys contracts\n', '           2. constructor grants "PermissionGranter" permission to deployer account\n', '           3. deployer account executes initial setup (no multiSig)\n', '           4. deployer account grants PermissionGranter permission for the MultiSig contract\n', '                (e.g. StabilityBoardProxy or PreTokenProxy)\n', '           5. deployer account revokes its own PermissionGranter permission\n', '*/\n', '\n', 'contract Restricted {\n', '\n', '    // NB: using bytes32 rather than the string type because it&#39;s cheaper gas-wise:\n', '    mapping (address => mapping (bytes32 => bool)) public permissions;\n', '\n', '    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\n', '    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\n', '\n', '    modifier restrict(bytes32 requiredPermission) {\n', '        require(permissions[msg.sender][requiredPermission], "msg.sender must have permission");\n', '        _;\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public {\n', '        require(permissionGranterContract != address(0), "permissionGranterContract must be set");\n', '        permissions[permissionGranterContract]["PermissionGranter"] = true;\n', '        emit PermissionGranted(permissionGranterContract, "PermissionGranter");\n', '    }\n', '\n', '    function grantPermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = true;\n', '        emit PermissionGranted(agent, requiredPermission);\n', '    }\n', '\n', '    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            grantPermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function revokePermission(address agent, bytes32 requiredPermission) public {\n', '        require(permissions[msg.sender]["PermissionGranter"],\n', '            "msg.sender must have PermissionGranter permission");\n', '        permissions[agent][requiredPermission] = false;\n', '        emit PermissionRevoked(agent, requiredPermission);\n', '    }\n', '\n', '    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\n', '        uint256 length = requiredPermissions.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            revokePermission(agent, requiredPermissions[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/* Abstract multisig contract to allow multi approval execution of atomic contracts scripts\n', '        e.g. migrations or settings.\n', '    * Script added by signing a script address by a signer  (NEW state)\n', '    * Script goes to ALLOWED state once a quorom of signers sign it (quorom fx is defined in each derived contracts)\n', '    * Script can be signed even in APPROVED state\n', '    * APPROVED scripts can be executed only once.\n', '        - if script succeeds then state set to DONE\n', '        - If script runs out of gas or reverts then script state set to FAILEd and not allowed to run again\n', '          (To avoid leaving "behind" scripts which fail in a given state but eventually execute in the future)\n', '    * Scripts can be cancelled by an other multisig script approved and calling cancelScript()\n', '    * Adding/removing signers is only via multisig approved scripts using addSigners / removeSigners fxs\n', '*/\n', '\n', 'contract MultiSig {\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    mapping(address => bool) public isSigner;\n', '    address[] public allSigners; // all signers, even the disabled ones\n', '                                // NB: it can contain duplicates when a signer is added, removed then readded again\n', '                                //   the purpose of this array is to being able to iterate on signers in isSigner\n', '    uint public activeSignersCount;\n', '\n', '    enum ScriptState {New, Approved, Done, Cancelled, Failed}\n', '\n', '    struct Script {\n', '        ScriptState state;\n', '        uint signCount;\n', '        mapping(address => bool) signedBy;\n', '        address[] allSigners;\n', '    }\n', '\n', '    mapping(address => Script) public scripts;\n', '    address[] public scriptAddresses;\n', '\n', '    event SignerAdded(address signer);\n', '    event SignerRemoved(address signer);\n', '\n', '    event ScriptSigned(address scriptAddress, address signer);\n', '    event ScriptApproved(address scriptAddress);\n', '    event ScriptCancelled(address scriptAddress);\n', '\n', '    event ScriptExecuted(address scriptAddress, bool result);\n', '\n', '    constructor() public {\n', '        // deployer address is the first signer. Deployer can configure new contracts by itself being the only "signer"\n', '        // The first script which sets the new contracts live should add signers and revoke deployer&#39;s signature right\n', '        isSigner[msg.sender] = true;\n', '        allSigners.push(msg.sender);\n', '        activeSignersCount = 1;\n', '        emit SignerAdded(msg.sender);\n', '    }\n', '\n', '    function sign(address scriptAddress) public {\n', '        require(isSigner[msg.sender], "sender must be signer");\n', '        Script storage script = scripts[scriptAddress];\n', '        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\n', '                "script state must be New or Approved");\n', '        require(!script.signedBy[msg.sender], "script must not be signed by signer yet");\n', '\n', '        if(script.allSigners.length == 0) {\n', '            // first sign of a new script\n', '            scriptAddresses.push(scriptAddress);\n', '        }\n', '\n', '        script.allSigners.push(msg.sender);\n', '        script.signedBy[msg.sender] =  true;\n', '        script.signCount = script.signCount.add(1);\n', '\n', '        emit ScriptSigned(scriptAddress, msg.sender);\n', '\n', '        if(checkQuorum(script.signCount)){\n', '            script.state = ScriptState.Approved;\n', '            emit ScriptApproved(scriptAddress);\n', '        }\n', '    }\n', '\n', '    function execute(address scriptAddress) public returns (bool result) {\n', '        // only allow execute to signers to avoid someone set an approved script failed by calling it with low gaslimit\n', '        require(isSigner[msg.sender], "sender must be signer");\n', '        Script storage script = scripts[scriptAddress];\n', '        require(script.state == ScriptState.Approved, "script state must be Approved");\n', '\n', '        /* init to failed because if delegatecall rans out of gas we won&#39;t have enough left to set it.\n', '           NB: delegatecall leaves 63/64 part of gasLimit for the caller.\n', '                Therefore the execute might revert with out of gas, leaving script in Approved state\n', '                when execute() is called with small gas limits.\n', '        */\n', '        script.state = ScriptState.Failed;\n', '\n', '        // passing scriptAddress to allow called script access its own public fx-s if needed\n', '        if(scriptAddress.delegatecall(bytes4(keccak256("execute(address)")), scriptAddress)) {\n', '            script.state = ScriptState.Done;\n', '            result = true;\n', '        } else {\n', '            result = false;\n', '        }\n', '        emit ScriptExecuted(scriptAddress, result);\n', '    }\n', '\n', '    function cancelScript(address scriptAddress) public {\n', '        require(msg.sender == address(this), "only callable via MultiSig");\n', '        Script storage script = scripts[scriptAddress];\n', '        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\n', '                "script state must be New or Approved");\n', '\n', '        script.state= ScriptState.Cancelled;\n', '\n', '        emit ScriptCancelled(scriptAddress);\n', '    }\n', '\n', '    /* requires quorum so it&#39;s callable only via a script executed by this contract */\n', '    function addSigners(address[] signers) public {\n', '        require(msg.sender == address(this), "only callable via MultiSig");\n', '        for (uint i= 0; i < signers.length; i++) {\n', '            if (!isSigner[signers[i]]) {\n', '                require(signers[i] != address(0), "new signer must not be 0x0");\n', '                activeSignersCount++;\n', '                allSigners.push(signers[i]);\n', '                isSigner[signers[i]] = true;\n', '                emit SignerAdded(signers[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /* requires quorum so it&#39;s callable only via a script executed by this contract */\n', '    function removeSigners(address[] signers) public {\n', '        require(msg.sender == address(this), "only callable via MultiSig");\n', '        for (uint i= 0; i < signers.length; i++) {\n', '            if (isSigner[signers[i]]) {\n', '                require(activeSignersCount > 1, "must not remove last signer");\n', '                activeSignersCount--;\n', '                isSigner[signers[i]] = false;\n', '                emit SignerRemoved(signers[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /* implement it in derived contract */\n', '    function checkQuorum(uint signersCount) internal view returns(bool isQuorum);\n', '\n', '    function getAllSignersCount() view external returns (uint allSignersCount) {\n', '        return allSigners.length;\n', '    }\n', '\n', '    // UI helper fx - Returns signers from offset as [signer id (index in allSigners), address as uint, isActive 0 or 1]\n', '    function getAllSigners(uint offset) external view returns(uint[3][CHUNK_SIZE] signersResult) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allSigners.length; i++) {\n', '            address signerAddress = allSigners[i + offset];\n', '            signersResult[i] = [ i + offset, uint(signerAddress), isSigner[signerAddress] ? 1 : 0 ];\n', '        }\n', '    }\n', '\n', '    function getScriptsCount() view external returns (uint scriptsCount) {\n', '        return scriptAddresses.length;\n', '    }\n', '\n', '    // UI helper fx - Returns scripts from offset as\n', '    //  [scriptId (index in scriptAddresses[]), address as uint, state, signCount]\n', '    function getAllScripts(uint offset) external view returns(uint[4][CHUNK_SIZE] scriptsResult) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < scriptAddresses.length; i++) {\n', '            address scriptAddress = scriptAddresses[i + offset];\n', '            scriptsResult[i] = [ i + offset, uint(scriptAddress), uint(scripts[scriptAddress].state),\n', '                            scripts[scriptAddress].signCount ];\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '/* Augmint pretoken contract to record agreements and tokens allocated based on the agreement.\n', '\n', '    Important: this is NOT an ERC20 token!\n', '\n', '    PreTokens are non-fungible: agreements can have different conditions (valuationCap and discount)\n', '        and pretokens are not tradable.\n', '\n', '    Ownership can be transferred if owner wants to change wallet but the whole agreement and\n', '        the total pretoken amount is moved to a new account\n', '\n', '    PreTokenSigner can (via MultiSig):\n', '      - add agreements and issue pretokens to an agreement\n', '      - change owner of any agreement to handle if an owner lost a private keys\n', '      - burn pretokens from any agreement to fix potential erroneous issuance\n', '    These are known compromises on trustlessness hence all these tokens distributed based on signed agreements and\n', '        preTokens are issued only to a closed group of contributors / team members.\n', '    If despite these something goes wrong then as a last resort a new pretoken contract can be recreated from agreements.\n', '\n', '    Some ERC20 functions are implemented so agreement owners can see their balances and use transfer in standard wallets.\n', '    Restrictions:\n', '      - only total balance can be transfered - effectively ERC20 transfer used to transfer agreement ownership\n', '      - only agreement holders can transfer\n', '        (i.e. can&#39;t transfer 0 amount if have no agreement to avoid polluting logs with Transfer events)\n', '      - transfer is only allowed to accounts without an agreement yet\n', '      - no approval and transferFrom ERC20 functions\n', ' */\n', 'contract PreToken is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    string constant public name = "Augmint pretokens"; // solhint-disable-line const-name-snakecase\n', '    string constant public symbol = "APRE"; // solhint-disable-line const-name-snakecase\n', '    uint8 constant public decimals = 0; // solhint-disable-line const-name-snakecase\n', '\n', '    uint public totalSupply;\n', '\n', '    struct Agreement {\n', '        address owner;\n', '        uint balance;\n', '        uint32 discount; //  discountRate in parts per million , ie. 10,000 = 1%\n', '        uint32 valuationCap; // in USD (no decimals)\n', '    }\n', '\n', '    /* Agreement hash is the SHA-2 (SHA-256) hash of signed agreement document.\n', '         To generate:\n', '            OSX: shasum -a 256 agreement.pdf\n', '            Windows: certUtil -hashfile agreement.pdf SHA256 */\n', '    mapping(address => bytes32) public agreementOwners; // to lookup agrement by owner\n', '    mapping(bytes32 => Agreement) public agreements;\n', '\n', '    bytes32[] public allAgreements; // all agreements to able to iterate over\n', '\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    event NewAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function addAgreement(address owner, bytes32 agreementHash, uint32 discount, uint32 valuationCap)\n', '    external restrict("PreTokenSigner") {\n', '        require(owner != address(0), "owner must not be 0x0");\n', '        require(agreementOwners[owner] == 0x0, "owner must not have an aggrement yet");\n', '        require(agreementHash != 0x0, "agreementHash must not be 0x0");\n', '        require(discount > 0, "discount must be > 0");\n', '        require(agreements[agreementHash].discount == 0, "agreement must not exist yet");\n', '\n', '        agreements[agreementHash] = Agreement(owner, 0, discount, valuationCap);\n', '        agreementOwners[owner] = agreementHash;\n', '        allAgreements.push(agreementHash);\n', '\n', '        emit NewAgreement(owner, agreementHash, discount, valuationCap);\n', '    }\n', '\n', '    function issueTo(bytes32 agreementHash, uint amount) external restrict("PreTokenSigner") {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist");\n', '\n', '        agreement.balance = agreement.balance.add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '\n', '        emit Transfer(0x0, agreement.owner, amount);\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix incorrect issuance */\n', '    function burnFrom(bytes32 agreementHash, uint amount)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        Agreement storage agreement = agreements[agreementHash];\n', '        require(agreement.discount > 0, "agreement must exist"); // this is redundant b/c of next requires but be explicit\n', '        require(amount > 0, "burn amount must be > 0");\n', '        require(agreement.balance >= amount, "must not burn more than balance"); // .sub would revert anyways but emit reason\n', '\n', '        agreement.balance = agreement.balance.sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '\n', '        emit Transfer(agreement.owner, 0x0, amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address owner) public view returns (uint) {\n', '        return agreements[agreementOwners[owner]].balance;\n', '    }\n', '\n', '    /* function to transfer agreement ownership to other wallet by owner\n', '        it&#39;s in ERC20 form so owners can use standard ERC20 wallet just need to pass full balance as value */\n', '    function transfer(address to, uint amount) public returns (bool) { // solhint-disable-line no-simple-event-func-name\n', '        require(amount == agreements[agreementOwners[msg.sender]].balance, "must transfer full balance");\n', '        _transfer(msg.sender, to);\n', '        return true;\n', '    }\n', '\n', '    /* Restricted function to allow pretoken signers to fix if pretoken owner lost keys */\n', '    function transferAgreement(bytes32 agreementHash, address to)\n', '    public restrict("PreTokenSigner") returns (bool) {\n', '        _transfer(agreements[agreementHash].owner, to);\n', '        return true;\n', '    }\n', '\n', '    /* private function used by transferAgreement & transfer */\n', '    function _transfer(address from, address to) private {\n', '        Agreement storage agreement = agreements[agreementOwners[from]];\n', '        require(agreementOwners[from] != 0x0, "from agreement must exists");\n', '        require(agreementOwners[to] == 0, "to must not have an agreement");\n', '        require(to != 0x0, "must not transfer to 0x0");\n', '\n', '        agreement.owner = to;\n', '\n', '        agreementOwners[to] = agreementOwners[from];\n', '        agreementOwners[from] = 0x0;\n', '\n', '        emit Transfer(from, to, agreement.balance);\n', '    }\n', '\n', '    function getAgreementsCount() external view returns (uint agreementsCount) {\n', '        return allAgreements.length;\n', '    }\n', '\n', '    // UI helper fx - Returns all agreements from offset as\n', '    // [index in allAgreements, account address as uint, balance, agreementHash as uint,\n', '    //          discount as uint, valuationCap as uint ]\n', '    function getAllAgreements(uint offset) external view returns(uint[6][CHUNK_SIZE] agreementsResult) {\n', '\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allAgreements.length; i++) {\n', '            bytes32 agreementHash = allAgreements[i + offset];\n', '            Agreement storage agreement = agreements[agreementHash];\n', '\n', '            agreementsResult[i] = [ i + offset, uint(agreement.owner), agreement.balance,\n', '                uint(agreementHash), uint(agreement.discount), uint(agreement.valuationCap)];\n', '        }\n', '    }\n', '}\n', '\n', '/*\n', ' Generic symbol / WEI rates contract.\n', ' only callable by trusted price oracles.\n', ' Being regularly called by a price oracle\n', '    TODO: trustless/decentrilezed price Oracle\n', '    TODO: shall we use blockNumber instead of now for lastUpdated?\n', '    TODO: consider if we need storing rates with variable decimals instead of fixed 4\n', '    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\n', '*/\n', 'contract Rates is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    struct RateInfo {\n', '        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\n', '                    // 0 rate means no rate info available\n', '        uint lastUpdated;\n', '    }\n', '\n', '    // mapping currency symbol => rate. all rates are stored with 4 decimals. i.e. ETH/EUR = 989.12 then rate = 989,1200\n', '    mapping(bytes32 => RateInfo) public rates;\n', '\n', '    event RateChanged(bytes32 symbol, uint newRate);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function setRate(bytes32 symbol, uint newRate) external restrict("RatesFeeder") {\n', '        rates[symbol] = RateInfo(newRate, now);\n', '        emit RateChanged(symbol, newRate);\n', '    }\n', '\n', '    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict("RatesFeeder") {\n', '        require(symbols.length == newRates.length, "symobls and newRates lengths must be equal");\n', '        for (uint256 i = 0; i < symbols.length; i++) {\n', '            rates[symbols[i]] = RateInfo(newRates[i], now);\n', '            emit RateChanged(symbols[i], newRates[i]);\n', '        }\n', '    }\n', '\n', '    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\n', '    }\n', '\n', '    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\n', '        // next line would revert with div by zero but require to emit reason\n', '        require(rates[bSymbol].rate > 0, "rates[bSymbol] must be > 0");\n', '        /* TODO: can we make this not loosing max scale? */\n', '        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract SystemAccount is Restricted {\n', '    event WithdrawFromSystemAccount(address tokenAddress, address to, uint tokenAmount, uint weiAmount,\n', '                                    string narrative);\n', '\n', '    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    /* TODO: this is only for first pilots to avoid funds stuck in contract due to bugs.\n', '      remove this function for higher volume pilots */\n', '    function withdraw(AugmintToken tokenAddress, address to, uint tokenAmount, uint weiAmount, string narrative)\n', '    external restrict("StabilityBoard") {\n', '        tokenAddress.transferWithNarrative(to, tokenAmount, narrative);\n', '        if (weiAmount > 0) {\n', '            to.transfer(weiAmount);\n', '        }\n', '\n', '        emit WithdrawFromSystemAccount(tokenAddress, to, tokenAmount, weiAmount, narrative);\n', '    }\n', '\n', '}\n', '\n', 'interface TokenReceiver {\n', '    function transferNotification(address from, uint256 amount, uint data) external;\n', '}\n', '\n', 'interface TransferFeeInterface {\n', '    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee);\n', '}\n', '\n', 'interface ExchangeFeeInterface {\n', '    function calculateExchangeFee(uint weiAmount) external view returns (uint256 weiFee);\n', '}\n', '\n', 'interface ERC20Interface {\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '\n', '}\n', '\n', '/* Augmint Token interface (abstract contract)\n', '\n', 'TODO: overload transfer() & transferFrom() instead of transferWithNarrative() & transferFromWithNarrative()\n', '      when this fix available in web3& truffle also uses that web3: https://github.com/ethereum/web3.js/pull/1185\n', 'TODO: shall we use bytes for narrative?\n', ' */\n', 'contract AugmintTokenInterface is Restricted, ERC20Interface {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    bytes32 public peggedSymbol;\n', '    uint8 public decimals;\n', '\n', '    uint public totalSupply;\n', '    mapping(address => uint256) public balances; // Balances for each account\n', '    mapping(address => mapping (address => uint256)) public allowed; // allowances added with approve()\n', '\n', '    address public stabilityBoardProxy;\n', '    TransferFeeInterface public feeAccount;\n', '    mapping(bytes32 => bool) public delegatedTxHashesUsed; // record txHashes used by delegatedTransfer\n', '\n', '    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event AugmintTransfer(address indexed from, address indexed to, uint amount, string narrative, uint fee);\n', '    event TokenIssued(uint amount);\n', '    event TokenBurned(uint amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function approve(address spender, uint value) external returns (bool);\n', '\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                    bytes32 nonce, /* random nonce generated by client */\n', '                                    /* ^^^^ end of signed data ^^^^ */\n', '                                    bytes signature,\n', '                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                ) external;\n', '\n', '    function increaseApproval(address spender, uint addedValue) external returns (bool);\n', '    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\n', '\n', '    function issueTo(address to, uint amount) external; // restrict it to "MonetarySupervisor" in impl.;\n', '    function burn(uint amount) external;\n', '\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external;\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external;\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external;\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    function balanceOf(address who) external view returns (uint);\n', '\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ECRecovery.sol\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '  }\n', '}\n', '\n', '/* Generic Augmint Token implementation (ERC20 token)\n', '    This contract manages:\n', '        * Balances of Augmint holders and transactions between them\n', '        * Issues/burns tokens\n', '\n', '    TODO:\n', '        - reconsider delegatedTransfer and how to structure it\n', '        - shall we allow change of txDelegator?\n', '        - consider generic bytes arg instead of uint for transferAndNotify\n', '        - consider separate transfer fee params and calculation to separate contract (to feeAccount?)\n', '*/\n', '\n', 'contract AugmintToken is AugmintTokenInterface {\n', '\n', '    event FeeAccountChanged(TransferFeeInterface newFeeAccount);\n', '\n', '    constructor(address permissionGranterContract, string _name, string _symbol, bytes32 _peggedSymbol, uint8 _decimals, TransferFeeInterface _feeAccount)\n', '    public Restricted(permissionGranterContract) {\n', '        require(_feeAccount != address(0), "feeAccount must be set");\n', '        require(bytes(_name).length > 0, "name must be set");\n', '        require(bytes(_symbol).length > 0, "symbol must be set");\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        peggedSymbol = _peggedSymbol;\n', '        decimals = _decimals;\n', '\n', '        feeAccount = _feeAccount;\n', '\n', '    }\n', '    function transfer(address to, uint256 amount) external returns (bool) {\n', '        _transfer(msg.sender, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    /* Transfers based on an offline signed transfer instruction. */\n', '    function delegatedTransfer(address from, address to, uint amount, string narrative,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, to, amount, narrative, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, to, amount, narrative);\n', '    }\n', '\n', '    function approve(address _spender, uint256 amount) external returns (bool) {\n', '        require(_spender != 0x0, "spender must be set");\n', '        allowed[msg.sender][_spender] = amount;\n', '        emit Approval(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     ERC20 transferFrom attack protection: https://github.com/DecentLabs/dcm-poc/issues/57\n', '     approve should be called when allowed[_spender] == 0. To increment allowed value is better\n', '     to use this function to avoid 2 calls (and wait until the first transaction is mined)\n', '     Based on MonolithDAO Token.sol */\n', '    function increaseApproval(address _spender, uint _addedValue) external returns (bool) {\n', '        return _increaseApproval(msg.sender, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n', '        _transferFrom(from, to, amount, "");\n', '        return true;\n', '    }\n', '\n', '    // Issue tokens. See MonetarySupervisor but as a rule of thumb issueTo is only allowed:\n', '    //      - on new loan (by trusted Lender contracts)\n', '    //      - when converting old tokens using MonetarySupervisor\n', '    //      - strictly to reserve by Stability Board (via MonetarySupervisor)\n', '    function issueTo(address to, uint amount) external restrict("MonetarySupervisor") {\n', '        balances[to] = balances[to].add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '        emit Transfer(0x0, to, amount);\n', '        emit AugmintTransfer(0x0, to, amount, "", 0);\n', '    }\n', '\n', '    // Burn tokens. Anyone can burn from its own account. YOLO.\n', '    // Used by to burn from Augmint reserve or by Lender contract after loan repayment\n', '    function burn(uint amount) external {\n', '        require(balances[msg.sender] >= amount, "balance must be >= amount");\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Transfer(msg.sender, 0x0, amount);\n', '        emit AugmintTransfer(msg.sender, 0x0, amount, "", 0);\n', '    }\n', '\n', '    /* to upgrade feeAccount (eg. for fee calculation changes) */\n', '    function setFeeAccount(TransferFeeInterface newFeeAccount) external restrict("StabilityBoard") {\n', '        feeAccount = newFeeAccount;\n', '        emit FeeAccountChanged(newFeeAccount);\n', '    }\n', '\n', '    /*  transferAndNotify can be used by contracts which require tokens to have only 1 tx (instead of approve + call)\n', '        Eg. repay loan, lock funds, token sell order on exchange\n', '        Reverts on failue:\n', '            - transfer fails\n', '            - if transferNotification fails (callee must revert on failure)\n', '            - if targetContract is an account or targetContract doesn&#39;t have neither transferNotification or fallback fx\n', '        TODO: make data param generic bytes (see receiver code attempt in Locker.transferNotification)\n', '    */\n', '    function transferAndNotify(TokenReceiver target, uint amount, uint data) external {\n', '        _transfer(msg.sender, target, amount, "");\n', '\n', '        target.transferNotification(msg.sender, amount, data);\n', '    }\n', '\n', '    /* transferAndNotify based on an  instruction signed offline  */\n', '    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\n', '                                     uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\n', '                                     bytes32 nonce, /* random nonce generated by client */\n', '                                     /* ^^^^ end of signed data ^^^^ */\n', '                                     bytes signature,\n', '                                     uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\n', '                                     )\n', '    external {\n', '        bytes32 txHash = keccak256(abi.encodePacked(this, from, target, amount, data, maxExecutorFeeInToken, nonce));\n', '\n', '        _checkHashAndTransferExecutorFee(txHash, signature, from, maxExecutorFeeInToken, requestedExecutorFeeInToken);\n', '\n', '        _transfer(from, target, amount, "");\n', '        target.transferNotification(from, amount, data);\n', '    }\n', '\n', '\n', '    function transferWithNarrative(address to, uint256 amount, string narrative) external {\n', '        _transfer(msg.sender, to, amount, narrative);\n', '    }\n', '\n', '    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external {\n', '        _transferFrom(from, to, amount, narrative);\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function _checkHashAndTransferExecutorFee(bytes32 txHash, bytes signature, address signer,\n', '                                                uint maxExecutorFeeInToken, uint requestedExecutorFeeInToken) private {\n', '        require(requestedExecutorFeeInToken <= maxExecutorFeeInToken, "requestedExecutorFee must be <= maxExecutorFee");\n', '        require(!delegatedTxHashesUsed[txHash], "txHash already used");\n', '        delegatedTxHashesUsed[txHash] = true;\n', '\n', '        address recovered = ECRecovery.recover(ECRecovery.toEthSignedMessageHash(txHash), signature);\n', '        require(recovered == signer, "invalid signature");\n', '\n', '        _transfer(signer, msg.sender, requestedExecutorFeeInToken, "Delegated transfer fee", 0);\n', '    }\n', '\n', '    function _increaseApproval(address _approver, address _spender, uint _addedValue) private returns (bool) {\n', '        allowed[_approver][_spender] = allowed[_approver][_spender].add(_addedValue);\n', '        emit Approval(_approver, _spender, allowed[_approver][_spender]);\n', '    }\n', '\n', '    function _transferFrom(address from, address to, uint256 amount, string narrative) private {\n', '        require(balances[from] >= amount, "balance must >= amount");\n', '        require(allowed[from][msg.sender] >= amount, "allowance must be >= amount");\n', '        // don&#39;t allow 0 transferFrom if no approval:\n', '        require(allowed[from][msg.sender] > 0, "allowance must be >= 0 even with 0 amount");\n', '\n', '        /* NB: fee is deducted from owner. It can result that transferFrom of amount x to fail\n', '                when x + fee is not availale on owner balance */\n', '        _transfer(from, to, amount, narrative);\n', '\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative) private {\n', '        uint fee = feeAccount.calculateTransferFee(from, to, transferAmount);\n', '\n', '        _transfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint transferAmount, string narrative, uint fee) private {\n', '        require(to != 0x0, "to must be set");\n', '        uint amountWithFee = transferAmount.add(fee);\n', '        // to emit proper reason instead of failing on from.sub()\n', '        require(balances[from] >= amountWithFee, "balance must be >= amount + transfer fee");\n', '\n', '        if (fee > 0) {\n', '            balances[feeAccount] = balances[feeAccount].add(fee);\n', '            emit Transfer(from, feeAccount, fee);\n', '        }\n', '\n', '        balances[from] = balances[from].sub(amountWithFee);\n', '        balances[to] = balances[to].add(transferAmount);\n', '\n', '        emit Transfer(from, to, transferAmount);\n', '        emit AugmintTransfer(from, to, transferAmount, narrative, fee);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to collect fees from system\n', '    TODO: calculateExchangeFee + Exchange params and setters\n', '*/\n', 'contract FeeAccount is SystemAccount, TransferFeeInterface {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct TransferFee {\n', '        uint pt;  // in parts per million (ppm) , ie. 2,000 = 0.2%\n', '        uint min; // with base unit of augmint token, eg. 2 decimals for token, eg. 310 = 3.1 ACE\n', '        uint max; // with base unit of augmint token, eg. 2 decimals for token, eg. 310 = 3.1 ACE\n', '    }\n', '\n', '    TransferFee public transferFee;\n', '\n', '    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\n', '\n', '    constructor(address permissionGranterContract, uint transferFeePt, uint transferFeeMin, uint transferFeeMax)\n', '    public SystemAccount(permissionGranterContract) {\n', '        transferFee = TransferFee(transferFeePt, transferFeeMin, transferFeeMax);\n', '    }\n', '\n', '    function () public payable { // solhint-disable-line no-empty-blocks\n', '        // to accept ETH sent into feeAccount (defaulting fee in ETH )\n', '    }\n', '\n', '    function setTransferFees(uint transferFeePt, uint transferFeeMin, uint transferFeeMax)\n', '    external restrict("StabilityBoard") {\n', '        transferFee = TransferFee(transferFeePt, transferFeeMin, transferFeeMax);\n', '        emit TransferFeesChanged(transferFeePt, transferFeeMin, transferFeeMax);\n', '    }\n', '\n', '    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee) {\n', '        if (!permissions[from]["NoTransferFee"] && !permissions[to]["NoTransferFee"]) {\n', '            fee = amount.mul(transferFee.pt).div(1000000);\n', '            if (fee > transferFee.max) {\n', '                fee = transferFee.max;\n', '            } else if (fee < transferFee.min) {\n', '                fee = transferFee.min;\n', '            }\n', '        }\n', '        return fee;\n', '    }\n', '\n', '    function calculateExchangeFee(uint weiAmount) external view returns (uint256 weiFee) {\n', '        /* TODO: to be implemented and use in Exchange.sol. always revert for now */\n', '        require(weiAmount != weiAmount, "not yet implemented");\n', '        weiFee = transferFee.max; // to silence compiler warnings until it&#39;s implemented\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold earned interest from loans repaid\n', '   premiums for locks are being accrued (i.e. transferred) to Locker */\n', 'contract InterestEarnedAccount is SystemAccount {\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function transferInterest(AugmintTokenInterface augmintToken, address locker, uint interestAmount)\n', '    external restrict("MonetarySupervisor") {\n', '        augmintToken.transfer(locker, interestAmount);\n', '    }\n', '\n', '}\n', '\n', '/* Contract to hold Augmint reserves (ETH & Token)\n', '    - ETH as regular ETH balance of the contract\n', '    - ERC20 token reserve (stored as regular Token balance under the contract address)\n', '\n', 'NB: reserves are held under the contract address, therefore any transaction on the reserve is limited to the\n', '    tx-s defined here (i.e. transfer is not allowed even by the contract owner or StabilityBoard or MonetarySupervisor)\n', '\n', ' */\n', 'contract AugmintReserves is SystemAccount {\n', '\n', '    function () public payable { // solhint-disable-line no-empty-blocks\n', '        // to accept ETH sent into reserve (from defaulted loan&#39;s collateral )\n', '    }\n', '\n', '    constructor(address permissionGranterContract) public SystemAccount(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\n', '\n', '    function burn(AugmintTokenInterface augmintToken, uint amount) external restrict("MonetarySupervisor") {\n', '        augmintToken.burn(amount);\n', '    }\n', '\n', '}\n', '\n', '/* MonetarySupervisor\n', '    - maintains system wide KPIs (eg totalLockAmount, totalLoanAmount)\n', '    - holds system wide parameters/limits\n', '    - enforces system wide limits\n', '    - burns and issues to AugmintReserves\n', '    - Send funds from reserve to exchange when intervening (not implemented yet)\n', '    - Converts older versions of AugmintTokens in 1:1 to new\n', '*/\n', 'contract MonetarySupervisor is Restricted, TokenReceiver { // solhint-disable-line no-empty-blocks\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant PERCENT_100 = 1000000;\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    InterestEarnedAccount public interestEarnedAccount;\n', '    AugmintReserves public augmintReserves;\n', '\n', '    uint public issuedByStabilityBoard; // token issued  by Stability Board\n', '\n', '    uint public totalLoanAmount; // total amount of all loans without interest, in token\n', '    uint public totalLockedAmount; // total amount of all locks without premium, in token\n', '\n', '    /**********\n', '        Parameters to ensure totalLoanAmount or totalLockedAmount difference is within limits and system also works\n', '        when total loan or lock amounts are low.\n', '            for test calculations: https://docs.google.com/spreadsheets/d/1MeWYPYZRIm1n9lzpvbq8kLfQg1hhvk5oJY6NrR401S0\n', '    **********/\n', '    struct LtdParams {\n', '        uint  lockDifferenceLimit; /* only allow a new lock if Loan To Deposit ratio would stay above\n', '                                            (1 - lockDifferenceLimit) with new lock. Stored as parts per million */\n', '        uint  loanDifferenceLimit; /* only allow a new loan if Loan To Deposit ratio would stay above\n', '                                            (1 + loanDifferenceLimit) with new loan. Stored as parts per million */\n', '        /* allowedDifferenceAmount param is to ensure the system is not "freezing" when totalLoanAmount or\n', '            totalLockAmount is low.\n', '        It allows a new loan or lock (up to an amount to reach this difference) even if LTD will go below / above\n', '            lockDifferenceLimit / loanDifferenceLimit with the new lock/loan */\n', '        uint  allowedDifferenceAmount;\n', '    }\n', '\n', '    LtdParams public ltdParams;\n', '\n', '    /* Previously deployed AugmintTokens which are accepted for conversion (see transferNotification() )\n', '        NB: it&#39;s not iterable so old version addresses needs to be added for UI manually after each deploy */\n', '    mapping(address => bool) public acceptedLegacyAugmintTokens;\n', '\n', '    event LtdParamsChanged(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount);\n', '\n', '    event AcceptedLegacyAugmintTokenChanged(address augmintTokenAddress, bool newAcceptedState);\n', '\n', '    event LegacyTokenConverted(address oldTokenAddress, address account, uint amount);\n', '\n', '    event KPIsAdjusted(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment);\n', '\n', '    event SystemContractsChanged(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, AugmintReserves _augmintReserves,\n', '        InterestEarnedAccount _interestEarnedAccount,\n', '        uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        augmintReserves = _augmintReserves;\n', '        interestEarnedAccount = _interestEarnedAccount;\n', '\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    function issueToReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.add(amount);\n', '        augmintToken.issueTo(augmintReserves, amount);\n', '    }\n', '\n', '    function burnFromReserve(uint amount) external restrict("StabilityBoard") {\n', '        issuedByStabilityBoard = issuedByStabilityBoard.sub(amount);\n', '        augmintReserves.burn(augmintToken, amount);\n', '    }\n', '\n', '    /* Locker requesting interest when locking funds. Enforcing LTD to stay within range allowed by LTD params\n', '        NB: it does not know about min loan amount, it&#39;s the loan contract&#39;s responsibility to enforce it  */\n', '    function requestInterest(uint amountToLock, uint interestAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        require(amountToLock <= getMaxLockAmountAllowedByLtd(), "amountToLock must be <= maxLockAmountAllowedByLtd");\n', '\n', '        totalLockedAmount = totalLockedAmount.add(amountToLock);\n', '        // next line would revert but require to emit reason:\n', '        require(augmintToken.balanceOf(address(interestEarnedAccount)) >= interestAmount,\n', '            "interestEarnedAccount balance must be >= interestAmount");\n', '        interestEarnedAccount.transferInterest(augmintToken, msg.sender, interestAmount); // transfer interest to Locker\n', '    }\n', '\n', '    // Locker notifying when releasing funds to update KPIs\n', '    function releaseFundsNotification(uint lockedAmount) external {\n', '        // only whitelisted Locker\n', '        require(permissions[msg.sender]["Locker"], "msg.sender must have Locker permission");\n', '        totalLockedAmount = totalLockedAmount.sub(lockedAmount);\n', '    }\n', '\n', '    /* Issue loan if LTD stays within range allowed by LTD params\n', '        NB: it does not know about min loan amount, it&#39;s the loan contract&#39;s responsibility to enforce it */\n', '    function issueLoan(address borrower, uint loanAmount) external {\n', '         // only whitelisted LoanManager contracts\n', '        require(permissions[msg.sender]["LoanManager"],\n', '            "msg.sender must have LoanManager permission");\n', '        require(loanAmount <= getMaxLoanAmountAllowedByLtd(), "loanAmount must be <= maxLoanAmountAllowedByLtd");\n', '        totalLoanAmount = totalLoanAmount.add(loanAmount);\n', '        augmintToken.issueTo(borrower, loanAmount);\n', '    }\n', '\n', '    function loanRepaymentNotification(uint loanAmount) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(loanAmount);\n', '    }\n', '\n', '    // NB: this is called by Lender contract with the sum of all loans collected in batch\n', '    function loanCollectionNotification(uint totalLoanAmountCollected) external {\n', '        // only whitelisted LoanManager contracts\n', '       require(permissions[msg.sender]["LoanManager"],\n', '           "msg.sender must have LoanManager permission");\n', '        totalLoanAmount = totalLoanAmount.sub(totalLoanAmountCollected);\n', '    }\n', '\n', '    function setAcceptedLegacyAugmintToken(address legacyAugmintTokenAddress, bool newAcceptedState)\n', '    external restrict("StabilityBoard") {\n', '        acceptedLegacyAugmintTokens[legacyAugmintTokenAddress] = newAcceptedState;\n', '        emit AcceptedLegacyAugmintTokenChanged(legacyAugmintTokenAddress, newAcceptedState);\n', '    }\n', '\n', '    function setLtdParams(uint lockDifferenceLimit, uint loanDifferenceLimit, uint allowedDifferenceAmount)\n', '    external restrict("StabilityBoard") {\n', '        ltdParams = LtdParams(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '\n', '        emit LtdParamsChanged(lockDifferenceLimit, loanDifferenceLimit, allowedDifferenceAmount);\n', '    }\n', '\n', '    /* function to migrate old totalLoanAmount and totalLockedAmount from old monetarySupervisor contract\n', '        when it&#39;s upgraded.\n', '        Set new monetarySupervisor contract in all locker and loanManager contracts before executing this */\n', '    function adjustKPIs(uint totalLoanAmountAdjustment, uint totalLockedAmountAdjustment)\n', '    external restrict("StabilityBoard") {\n', '        totalLoanAmount = totalLoanAmount.add(totalLoanAmountAdjustment);\n', '        totalLockedAmount = totalLockedAmount.add(totalLockedAmountAdjustment);\n', '\n', '        emit KPIsAdjusted(totalLoanAmountAdjustment, totalLockedAmountAdjustment);\n', '    }\n', '\n', '    /* to allow upgrades of InterestEarnedAccount and AugmintReserves contracts. */\n', '    function setSystemContracts(InterestEarnedAccount newInterestEarnedAccount, AugmintReserves newAugmintReserves)\n', '    external restrict("StabilityBoard") {\n', '        interestEarnedAccount = newInterestEarnedAccount;\n', '        augmintReserves = newAugmintReserves;\n', '        emit SystemContractsChanged(newInterestEarnedAccount, newAugmintReserves);\n', '    }\n', '\n', '    /* User can request to convert their tokens from older AugmintToken versions in 1:1\n', '      transferNotification is called from AugmintToken&#39;s transferAndNotify\n', '     Flow for converting old tokens:\n', '        1) user calls old token contract&#39;s transferAndNotify with the amount to convert,\n', '                addressing the new MonetarySupervisor Contract\n', '        2) transferAndNotify transfers user&#39;s old tokens to the current MonetarySupervisor contract&#39;s address\n', '        3) transferAndNotify calls MonetarySupervisor.transferNotification\n', '        4) MonetarySupervisor checks if old AugmintToken is permitted\n', '        5) MonetarySupervisor issues new tokens to user&#39;s account in current AugmintToken\n', '        6) MonetarySupervisor burns old tokens from own balance\n', '    */\n', '    function transferNotification(address from, uint amount, uint /* data, not used */ ) external {\n', '        AugmintTokenInterface legacyToken = AugmintTokenInterface(msg.sender);\n', '        require(acceptedLegacyAugmintTokens[legacyToken], "msg.sender must be allowed in acceptedLegacyAugmintTokens");\n', '\n', '        legacyToken.burn(amount);\n', '        augmintToken.issueTo(from, amount);\n', '        emit LegacyTokenConverted(msg.sender, from, amount);\n', '    }\n', '\n', '    function getLoanToDepositRatio() external view returns (uint loanToDepositRatio) {\n', '        loanToDepositRatio = totalLockedAmount == 0 ? 0 : totalLockedAmount.mul(PERCENT_100).div(totalLoanAmount);\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max lock amount based on minLockAmount, interestPt, using LTD params & interestEarnedAccount balance */\n', '    function getMaxLockAmount(uint minLockAmount, uint interestPt) external view returns (uint maxLock) {\n', '        uint allowedByEarning = augmintToken.balanceOf(address(interestEarnedAccount)).mul(PERCENT_100).div(interestPt);\n', '        uint allowedByLtd = getMaxLockAmountAllowedByLtd();\n', '        maxLock = allowedByEarning < allowedByLtd ? allowedByEarning : allowedByLtd;\n', '        maxLock = maxLock < minLockAmount ? 0 : maxLock;\n', '    }\n', '\n', '    /* Helper function for UI.\n', '        Returns max loan amount based on minLoanAmont using LTD params */\n', '    function getMaxLoanAmount(uint minLoanAmount) external view returns (uint maxLoan) {\n', '        uint allowedByLtd = getMaxLoanAmountAllowedByLtd();\n', '        maxLoan = allowedByLtd < minLoanAmount ? 0 : allowedByLtd;\n', '    }\n', '\n', '    /* returns maximum lockable token amount allowed by LTD params. */\n', '    function getMaxLockAmountAllowedByLtd() public view returns(uint maxLockByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLoanAmount.mul(PERCENT_100).div(PERCENT_100\n', '                                            .sub(ltdParams.lockDifferenceLimit));\n', '        allowedByLtdDifferencePt = totalLockedAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLockedAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLockedAmount >= totalLoanAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLoanAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLockedAmount);\n', '\n', '        maxLockByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '    /* returns maximum borrowable token amount allowed by LTD params */\n', '    function getMaxLoanAmountAllowedByLtd() public view returns(uint maxLoanByLtd) {\n', '        uint allowedByLtdDifferencePt = totalLockedAmount.mul(ltdParams.loanDifferenceLimit.add(PERCENT_100))\n', '                                            .div(PERCENT_100);\n', '        allowedByLtdDifferencePt = totalLoanAmount >= allowedByLtdDifferencePt ?\n', '                                        0 : allowedByLtdDifferencePt.sub(totalLoanAmount);\n', '\n', '        uint allowedByLtdDifferenceAmount =\n', '            totalLoanAmount >= totalLockedAmount.add(ltdParams.allowedDifferenceAmount) ?\n', '                0 : totalLockedAmount.add(ltdParams.allowedDifferenceAmount).sub(totalLoanAmount);\n', '\n', '        maxLoanByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ?\n', '                                        allowedByLtdDifferencePt : allowedByLtdDifferenceAmount;\n', '    }\n', '\n', '}\n', '\n', '/* Augmint&#39;s Internal Exchange\n', '\n', '  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\n', '\n', '    TODO:\n', '        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\n', '        - deduct fee\n', '        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\n', '        - use Rates interface?\n', '*/\n', 'pragma solidity 0.4.24;\n', 'contract Exchange is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    Rates public rates;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    struct Order {\n', '        uint64 index;\n', '        address maker;\n', '\n', '        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\n', '        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\n', '        uint32 price;\n', '\n', '        // buy order: amount in wei\n', '        // sell order: token amount\n', '        uint amount;\n', '    }\n', '\n', '    uint64 public orderCount;\n', '    mapping(uint64 => Order) public buyTokenOrders;\n', '    mapping(uint64 => Order) public sellTokenOrders;\n', '\n', '    uint64[] private activeBuyOrders;\n', '    uint64[] private activeSellOrders;\n', '\n', '    /* used to stop executing matchMultiple when running out of gas.\n', '        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\n', '    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\n', '\n', '    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\n', '\n', '    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\n', '        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint fillRate, uint weiAmount, uint tokenAmount);\n', '\n', '    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\n', '\n', '    event RatesContractChanged(Rates newRatesContract);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        rates = _rates;\n', '    }\n', '\n', '    /* to allow upgrade of Rates  contract */\n', '    function setRatesContract(Rates newRatesContract)\n', '    external restrict("StabilityBoard") {\n', '        rates = newRatesContract;\n', '        emit RatesContractChanged(newRatesContract);\n', '    }\n', '\n', '    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\n', '        require(price > 0, "price must be > 0");\n', '        require(msg.value > 0, "msg.value must be > 0");\n', '\n', '        orderId = ++orderCount;\n', '        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\n', '        activeBuyOrders.push(orderId);\n', '\n', '        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\n', '    }\n', '\n', '    /* this function requires previous approval to transfer tokens */\n', '    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\n', '        augmintToken.transferFrom(msg.sender, this, tokenAmount);\n', '        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\n', '    }\n', '\n', '    /* place sell token order called from AugmintToken&#39;s transferAndNotify\n', '     Flow:\n', '        1) user calls token contract&#39;s transferAndNotify price passed in data arg\n', '        2) transferAndNotify transfers tokens to the Exchange contract\n', '        3) transferAndNotify calls Exchange.transferNotification with lockProductId\n', '    */\n', '    function transferNotification(address maker, uint tokenAmount, uint price) external {\n', '        require(msg.sender == address(augmintToken), "msg.sender must be augmintToken");\n', '        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\n', '    }\n', '\n', '    function cancelBuyTokenOrder(uint64 buyTokenId) external {\n', '        Order storage order = buyTokenOrders[buyTokenId];\n', '        require(order.maker == msg.sender, "msg.sender must be order.maker");\n', '        require(order.amount > 0, "buy order already removed");\n', '\n', '        uint amount = order.amount;\n', '        order.amount = 0;\n', '        _removeBuyOrder(order);\n', '\n', '        msg.sender.transfer(amount);\n', '\n', '        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\n', '    }\n', '\n', '    function cancelSellTokenOrder(uint64 sellTokenId) external {\n', '        Order storage order = sellTokenOrders[sellTokenId];\n', '        require(order.maker == msg.sender, "msg.sender must be order.maker");\n', '        require(order.amount > 0, "sell order already removed");\n', '\n', '        uint amount = order.amount;\n', '        order.amount = 0;\n', '        _removeSellOrder(order);\n', '\n', '        augmintToken.transferWithNarrative(msg.sender, amount, "Sell token order cancelled");\n', '\n', '        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\n', '    }\n', '\n', '    /* matches any two orders if the sell price >= buy price\n', '        trade price is the price of the maker (the order placed earlier)\n', '        reverts if any of the orders have been removed\n', '    */\n', '    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\n', '        require(_fillOrder(buyTokenId, sellTokenId), "fill order failed");\n', '    }\n', '\n', '    /*  matches as many orders as possible from the passed orders\n', '        Runs as long as gas is available for the call.\n', '        Reverts if any match is invalid (e.g sell price > buy price)\n', '        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\n', '    */\n', '    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\n', '        uint len = buyTokenIds.length;\n', '        require(len == sellTokenIds.length, "buyTokenIds and sellTokenIds lengths must be equal");\n', '\n', '        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\n', '            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\n', '                matchCount++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\n', '        return(activeBuyOrders.length, activeSellOrders.length);\n', '    }\n', '\n', '    // returns CHUNK_SIZE orders starting from offset\n', '    // orders are encoded as [id, maker, price, amount]\n', '    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\n', '            uint64 orderId = activeBuyOrders[offset + i];\n', '            Order storage order = buyTokenOrders[orderId];\n', '            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n', '        }\n', '    }\n', '\n', '    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\n', '            uint64 orderId = activeSellOrders[offset + i];\n', '            Order storage order = sellTokenOrders[orderId];\n', '            response[i] = [orderId, uint(order.maker), order.price, order.amount];\n', '        }\n', '    }\n', '\n', '    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\n', '        Order storage buy = buyTokenOrders[buyTokenId];\n', '        Order storage sell = sellTokenOrders[sellTokenId];\n', '        if( buy.amount == 0 || sell.amount == 0 ) {\n', '            return false; // one order is already filled and removed.\n', '                          // we let matchMultiple continue, indivudal match will revert\n', '        }\n', '\n', '        require(buy.price >= sell.price, "buy price must be >= sell price");\n', '\n', '        // pick maker&#39;s price (whoever placed order sooner considered as maker)\n', '        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\n', '\n', '        uint publishedRate;\n', '        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\n', '        uint fillRate = publishedRate.mul(price).roundedDiv(1000000);\n', '\n', '        uint sellWei = sell.amount.mul(1 ether).roundedDiv(fillRate);\n', '\n', '        uint tradedWei;\n', '        uint tradedTokens;\n', '        if (sellWei <= buy.amount) {\n', '            tradedWei = sellWei;\n', '            tradedTokens = sell.amount;\n', '        } else {\n', '            tradedWei = buy.amount;\n', '            tradedTokens = buy.amount.mul(fillRate).roundedDiv(1 ether);\n', '        }\n', '\n', '        buy.amount = buy.amount.sub(tradedWei);\n', '        if (buy.amount == 0) {\n', '            _removeBuyOrder(buy);\n', '        }\n', '\n', '        sell.amount = sell.amount.sub(tradedTokens);\n', '        if (sell.amount == 0) {\n', '            _removeSellOrder(sell);\n', '        }\n', '\n', '        augmintToken.transferWithNarrative(buy.maker, tradedTokens, "Buy token order fill");\n', '        sell.maker.transfer(tradedWei);\n', '\n', '        emit OrderFill(buy.maker, sell.maker, buyTokenId,\n', '            sellTokenId, publishedRate, price, fillRate, tradedWei, tradedTokens);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\n', '    private returns (uint64 orderId) {\n', '        require(price > 0, "price must be > 0");\n', '        require(tokenAmount > 0, "tokenAmount must be > 0");\n', '\n', '        orderId = ++orderCount;\n', '        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\n', '        activeSellOrders.push(orderId);\n', '\n', '        emit NewOrder(orderId, maker, price, tokenAmount, 0);\n', '    }\n', '\n', '    function _removeBuyOrder(Order storage order) private {\n', '        _removeOrder(activeBuyOrders, order.index);\n', '    }\n', '\n', '    function _removeSellOrder(Order storage order) private {\n', '        _removeOrder(activeSellOrders, order.index);\n', '    }\n', '\n', '    function _removeOrder(uint64[] storage orders, uint64 index) private {\n', '        if (index < orders.length - 1) {\n', '            orders[index] = orders[orders.length - 1];\n', '        }\n', '        orders.length--;\n', '    }\n', '\n', '}\n', '\n', '/* Augmint Crypto Euro token (A-EUR) implementation */\n', 'contract TokenAEur is AugmintToken {\n', '    constructor(address _permissionGranterContract, TransferFeeInterface _feeAccount)\n', '    public AugmintToken(_permissionGranterContract, "Augmint Crypto Euro", "AEUR", "EUR", 2, _feeAccount)\n', '    {} // solhint-disable-line no-empty-blocks\n', '\n', '}\n', '\n', '\n', '/*\n', '    Contract to manage Augmint token loan contracts backed by ETH\n', '    For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/loanFlow.png\n', '\n', '    TODO:\n', '        - create MonetarySupervisor interface and use it instead?\n', '        - make data arg generic bytes?\n', '        - make collect() run as long as gas provided allows\n', '*/\n', 'contract LoanManager is Restricted {\n', '    using SafeMath for uint256;\n', '\n', '    uint16 public constant CHUNK_SIZE = 100;\n', '\n', '    enum LoanState { Open, Repaid, Defaulted, Collected } // NB: Defaulted state is not stored, only getters calculate\n', '\n', '    struct LoanProduct {\n', '        uint minDisbursedAmount; // 0: with decimals set in AugmintToken.decimals\n', '        uint32 term;            // 1\n', '        uint32 discountRate;    // 2: discountRate in parts per million , ie. 10,000 = 1%\n', '        uint32 collateralRatio; // 3: loan token amount / colleteral pegged ccy value\n', '                                //      in parts per million , ie. 10,000 = 1%\n', '        uint32 defaultingFeePt; // 4: % of collateral in parts per million , ie. 50,000 = 5%\n', '        bool isActive;          // 5\n', '    }\n', '\n', '    /* NB: we don&#39;t need to store loan parameters because loan products can&#39;t be altered (only disabled/enabled) */\n', '    struct LoanData {\n', '        uint collateralAmount; // 0\n', '        uint repaymentAmount; // 1\n', '        address borrower; // 2\n', '        uint32 productId; // 3\n', '        LoanState state; // 4\n', '        uint40 maturity; // 5\n', '    }\n', '\n', '    LoanProduct[] public products;\n', '\n', '    LoanData[] public loans;\n', '    mapping(address => uint[]) public accountLoans;  // owner account address =>  array of loan Ids\n', '\n', '    Rates public rates; // instance of ETH/pegged currency rate provider contract\n', '    AugmintTokenInterface public augmintToken; // instance of token contract\n', '    MonetarySupervisor public monetarySupervisor;\n', '\n', '    event NewLoan(uint32 productId, uint loanId, address indexed borrower, uint collateralAmount, uint loanAmount,\n', '        uint repaymentAmount, uint40 maturity);\n', '\n', '    event LoanProductActiveStateChanged(uint32 productId, bool newState);\n', '\n', '    event LoanProductAdded(uint32 productId);\n', '\n', '    event LoanRepayed(uint loanId, address borrower);\n', '\n', '    event LoanCollected(uint loanId, address indexed borrower, uint collectedCollateral,\n', '        uint releasedCollateral, uint defaultingFee);\n', '\n', '    event SystemContractsChanged(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor);\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n', '                    MonetarySupervisor _monetarySupervisor, Rates _rates)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        monetarySupervisor = _monetarySupervisor;\n', '        rates = _rates;\n', '    }\n', '\n', '    function addLoanProduct(uint32 term, uint32 discountRate, uint32 collateralRatio, uint minDisbursedAmount,\n', '                                uint32 defaultingFeePt, bool isActive)\n', '    external restrict("StabilityBoard") {\n', '\n', '        uint _newProductId = products.push(\n', '            LoanProduct(minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, isActive)\n', '        ) - 1;\n', '\n', '        uint32 newProductId = uint32(_newProductId);\n', '        require(newProductId == _newProductId, "productId overflow");\n', '\n', '        emit LoanProductAdded(newProductId);\n', '    }\n', '\n', '    function setLoanProductActiveState(uint32 productId, bool newState)\n', '    external restrict ("StabilityBoard") {\n', '        require(productId < products.length, "invalid productId"); // next line would revert but require to emit reason\n', '        products[productId].isActive = false;\n', '        emit LoanProductActiveStateChanged(productId, newState);\n', '    }\n', '\n', '    function newEthBackedLoan(uint32 productId) external payable {\n', '        require(productId < products.length, "invalid productId"); // next line would revert but require to emit reason\n', '        LoanProduct storage product = products[productId];\n', '        require(product.isActive, "product must be in active state"); // valid product\n', '\n', '\n', '        // calculate loan values based on ETH sent in with Tx\n', '        uint tokenValue = rates.convertFromWei(augmintToken.peggedSymbol(), msg.value);\n', '        uint repaymentAmount = tokenValue.mul(product.collateralRatio).div(1000000);\n', '\n', '        uint loanAmount;\n', '        (loanAmount, ) = calculateLoanValues(product, repaymentAmount);\n', '\n', '        require(loanAmount >= product.minDisbursedAmount, "loanAmount must be >= minDisbursedAmount");\n', '\n', '        uint expiration = now.add(product.term);\n', '        uint40 maturity = uint40(expiration);\n', '        require(maturity == expiration, "maturity overflow");\n', '\n', '        // Create new loan\n', '        uint loanId = loans.push(LoanData(msg.value, repaymentAmount, msg.sender,\n', '                                            productId, LoanState.Open, maturity)) - 1;\n', '\n', '        // Store ref to new loan\n', '        accountLoans[msg.sender].push(loanId);\n', '\n', '        // Issue tokens and send to borrower\n', '        monetarySupervisor.issueLoan(msg.sender, loanAmount);\n', '\n', '        emit NewLoan(productId, loanId, msg.sender, msg.value, loanAmount, repaymentAmount, maturity);\n', '    }\n', '\n', '    /* repay loan, called from AugmintToken&#39;s transferAndNotify\n', '     Flow for repaying loan:\n', '        1) user calls token contract&#39;s transferAndNotify loanId passed in data arg\n', '        2) transferAndNotify transfers tokens to the Lender contract\n', '        3) transferAndNotify calls Lender.transferNotification with lockProductId\n', '    */\n', '    // from arg is not used as we allow anyone to repay a loan:\n', '    function transferNotification(address, uint repaymentAmount, uint loanId) external {\n', '        require(msg.sender == address(augmintToken), "msg.sender must be augmintToken");\n', '\n', '        _repayLoan(loanId, repaymentAmount);\n', '    }\n', '\n', '    function collect(uint[] loanIds) external {\n', '        /* when there are a lots of loans to be collected then\n', '             the client need to call it in batches to make sure tx won&#39;t exceed block gas limit.\n', '         Anyone can call it - can&#39;t cause harm as it only allows to collect loans which they are defaulted\n', '         TODO: optimise defaulting fee calculations\n', '        */\n', '        uint totalLoanAmountCollected;\n', '        uint totalCollateralToCollect;\n', '        uint totalDefaultingFee;\n', '        for (uint i = 0; i < loanIds.length; i++) {\n', '            require(i < loans.length, "invalid loanId"); // next line would revert but require to emit reason\n', '            LoanData storage loan = loans[loanIds[i]];\n', '            require(loan.state == LoanState.Open, "loan state must be Open");\n', '            require(now >= loan.maturity, "current time must be later than maturity");\n', '            LoanProduct storage product = products[loan.productId];\n', '\n', '            uint loanAmount;\n', '            (loanAmount, ) = calculateLoanValues(product, loan.repaymentAmount);\n', '\n', '            totalLoanAmountCollected = totalLoanAmountCollected.add(loanAmount);\n', '\n', '            loan.state = LoanState.Collected;\n', '\n', '            // send ETH collateral to augmintToken reserve\n', '            uint defaultingFeeInToken = loan.repaymentAmount.mul(product.defaultingFeePt).div(1000000);\n', '            uint defaultingFee = rates.convertToWei(augmintToken.peggedSymbol(), defaultingFeeInToken);\n', '            uint targetCollection = rates.convertToWei(augmintToken.peggedSymbol(),\n', '                                                            loan.repaymentAmount).add(defaultingFee);\n', '\n', '            uint releasedCollateral;\n', '            if (targetCollection < loan.collateralAmount) {\n', '                releasedCollateral = loan.collateralAmount.sub(targetCollection);\n', '                loan.borrower.transfer(releasedCollateral);\n', '            }\n', '            uint collateralToCollect = loan.collateralAmount.sub(releasedCollateral);\n', '            if (defaultingFee >= collateralToCollect) {\n', '                defaultingFee = collateralToCollect;\n', '                collateralToCollect = 0;\n', '            } else {\n', '                collateralToCollect = collateralToCollect.sub(defaultingFee);\n', '            }\n', '            totalDefaultingFee = totalDefaultingFee.add(defaultingFee);\n', '\n', '            totalCollateralToCollect = totalCollateralToCollect.add(collateralToCollect);\n', '\n', '            emit LoanCollected(loanIds[i], loan.borrower, collateralToCollect.add(defaultingFee), releasedCollateral, defaultingFee);\n', '        }\n', '\n', '        if (totalCollateralToCollect > 0) {\n', '            address(monetarySupervisor.augmintReserves()).transfer(totalCollateralToCollect);\n', '        }\n', '\n', '        if (totalDefaultingFee > 0){\n', '            address(augmintToken.feeAccount()).transfer(totalDefaultingFee);\n', '        }\n', '\n', '        monetarySupervisor.loanCollectionNotification(totalLoanAmountCollected);// update KPIs\n', '\n', '    }\n', '\n', '    /* to allow upgrade of Rates and MonetarySupervisor contracts */\n', '    function setSystemContracts(Rates newRatesContract, MonetarySupervisor newMonetarySupervisor)\n', '    external restrict("StabilityBoard") {\n', '        rates = newRatesContract;\n', '        monetarySupervisor = newMonetarySupervisor;\n', '        emit SystemContractsChanged(newRatesContract, newMonetarySupervisor);\n', '    }\n', '\n', '    function getProductCount() external view returns (uint ct) {\n', '        return products.length;\n', '    }\n', '\n', '    // returns CHUNK_SIZE loan products starting from some offset:\n', '    // [ productId, minDisbursedAmount, term, discountRate, collateralRatio, defaultingFeePt, maxLoanAmount, isActive ]\n', '    function getProducts(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n', '\n', '        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= products.length) { break; }\n', '\n', '            LoanProduct storage product = products[offset + i];\n', '\n', '            response[i] = [offset + i, product.minDisbursedAmount, product.term, product.discountRate,\n', '                            product.collateralRatio, product.defaultingFeePt,\n', '                            monetarySupervisor.getMaxLoanAmount(product.minDisbursedAmount), product.isActive ? 1 : 0 ];\n', '        }\n', '    }\n', '\n', '    function getLoanCount() external view returns (uint ct) {\n', '        return loans.length;\n', '    }\n', '\n', '    /* returns CHUNK_SIZE loans starting from some offset. Loans data encoded as:\n', '        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n', '                                                                                    loanAmount, interestAmount ]   */\n', '    function getLoans(uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n', '\n', '        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= loans.length) { break; }\n', '\n', '            response[i] = getLoanTuple(offset + i);\n', '        }\n', '    }\n', '\n', '    function getLoanCountForAddress(address borrower) external view returns (uint) {\n', '        return accountLoans[borrower].length;\n', '    }\n', '\n', '    /* returns CHUNK_SIZE loans of a given account, starting from some offset. Loans data encoded as:\n', '        [loanId, collateralAmount, repaymentAmount, borrower, productId, state, maturity, disbursementTime,\n', '                                                                                    loanAmount, interestAmount ] */\n', '    function getLoansForAddress(address borrower, uint offset) external view returns (uint[10][CHUNK_SIZE] response) {\n', '\n', '        uint[] storage loansForAddress = accountLoans[borrower];\n', '\n', '        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= loansForAddress.length) { break; }\n', '\n', '            response[i] = getLoanTuple(loansForAddress[offset + i]);\n', '        }\n', '    }\n', '\n', '    function getLoanTuple(uint loanId) public view returns (uint[10] result) {\n', '        require(loanId < loans.length, "invalid loanId"); // next line would revert but require to emit reason\n', '        LoanData storage loan = loans[loanId];\n', '        LoanProduct storage product = products[loan.productId];\n', '\n', '        uint loanAmount;\n', '        uint interestAmount;\n', '        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n', '        uint disbursementTime = loan.maturity - product.term;\n', '\n', '        LoanState loanState =\n', '                        loan.state == LoanState.Open && now >= loan.maturity ? LoanState.Defaulted : loan.state;\n', '\n', '        result = [loanId, loan.collateralAmount, loan.repaymentAmount, uint(loan.borrower),\n', '                    loan.productId, uint(loanState), loan.maturity, disbursementTime, loanAmount, interestAmount];\n', '    }\n', '\n', '    function calculateLoanValues(LoanProduct storage product, uint repaymentAmount)\n', '    internal view returns (uint loanAmount, uint interestAmount) {\n', '        // calculate loan values based on repayment amount\n', '        loanAmount = repaymentAmount.mul(product.discountRate).div(1000000);\n', '        interestAmount = loanAmount > repaymentAmount ? 0 : repaymentAmount.sub(loanAmount);\n', '    }\n', '\n', '    /* internal function, assuming repayment amount already transfered  */\n', '    function _repayLoan(uint loanId, uint repaymentAmount) internal {\n', '        require(loanId < loans.length, "invalid loanId"); // next line would revert but require to emit reason\n', '        LoanData storage loan = loans[loanId];\n', '        require(loan.state == LoanState.Open, "loan state must be Open");\n', '        require(repaymentAmount == loan.repaymentAmount, "repaymentAmount must be equal to tokens sent");\n', '        require(now <= loan.maturity, "current time must be earlier than maturity");\n', '\n', '        LoanProduct storage product = products[loan.productId];\n', '        uint loanAmount;\n', '        uint interestAmount;\n', '        (loanAmount, interestAmount) = calculateLoanValues(product, loan.repaymentAmount);\n', '\n', '        loans[loanId].state = LoanState.Repaid;\n', '\n', '        if (interestAmount > 0) {\n', '            augmintToken.transfer(monetarySupervisor.interestEarnedAccount(), interestAmount);\n', '            augmintToken.burn(loanAmount);\n', '        } else {\n', '            // negative or zero interest (i.e. discountRate >= 0)\n', '            augmintToken.burn(repaymentAmount);\n', '        }\n', '\n', '        monetarySupervisor.loanRepaymentNotification(loanAmount); // update KPIs\n', '\n', '        loan.borrower.transfer(loan.collateralAmount); // send back ETH collateral\n', '\n', '        emit LoanRepayed(loanId, loan.borrower);\n', '    }\n', '\n', '}\n', '\n', '\n', '/* contract for tracking locked funds\n', '\n', ' requirements\n', '  -> lock funds\n', '  -> unlock funds\n', '  -> index locks by address\n', '\n', ' For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/lockFlow.png\n', '\n', ' TODO / think about:\n', '  -> self-destruct function?\n', '\n', '*/\n', 'contract Locker is Restricted, TokenReceiver {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint public constant CHUNK_SIZE = 100;\n', '\n', '    event NewLockProduct(uint32 indexed lockProductId, uint32 perTermInterest, uint32 durationInSecs,\n', '                            uint32 minimumLockAmount, bool isActive);\n', '\n', '    event LockProductActiveChange(uint32 indexed lockProductId, bool newActiveState);\n', '\n', '    // NB: amountLocked includes the original amount, plus interest\n', '    event NewLock(address indexed lockOwner, uint lockId, uint amountLocked, uint interestEarned,\n', '                    uint40 lockedUntil, uint32 perTermInterest, uint32 durationInSecs);\n', '\n', '    event LockReleased(address indexed lockOwner, uint lockId);\n', '\n', '    event MonetarySupervisorChanged(MonetarySupervisor newMonetarySupervisor);\n', '\n', '    struct LockProduct {\n', '        // perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n', '        uint32 perTermInterest;\n', '        uint32 durationInSecs;\n', '        uint32 minimumLockAmount;\n', '        bool isActive;\n', '    }\n', '\n', '    /* NB: we don&#39;t need to store lock parameters because lockProducts can&#39;t be altered (only disabled/enabled) */\n', '    struct Lock {\n', '        uint amountLocked;\n', '        address owner;\n', '        uint32 productId;\n', '        uint40 lockedUntil;\n', '        bool isActive;\n', '    }\n', '\n', '    AugmintTokenInterface public augmintToken;\n', '    MonetarySupervisor public monetarySupervisor;\n', '\n', '    LockProduct[] public lockProducts;\n', '\n', '    Lock[] public locks;\n', '\n', '    // lock ids for an account\n', '    mapping(address => uint[]) public accountLocks;\n', '\n', '    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken,\n', '                    MonetarySupervisor _monetarySupervisor)\n', '    public Restricted(permissionGranterContract) {\n', '        augmintToken = _augmintToken;\n', '        monetarySupervisor = _monetarySupervisor;\n', '\n', '    }\n', '\n', '    function addLockProduct(uint32 perTermInterest, uint32 durationInSecs, uint32 minimumLockAmount, bool isActive)\n', '    external restrict("StabilityBoard") {\n', '\n', '        uint _newLockProductId = lockProducts.push(\n', '                                    LockProduct(perTermInterest, durationInSecs, minimumLockAmount, isActive)) - 1;\n', '        uint32 newLockProductId = uint32(_newLockProductId);\n', '        require(newLockProductId == _newLockProductId, "lockProduct overflow");\n', '        emit NewLockProduct(newLockProductId, perTermInterest, durationInSecs, minimumLockAmount, isActive);\n', '\n', '    }\n', '\n', '    function setLockProductActiveState(uint32 lockProductId, bool isActive) external restrict("StabilityBoard") {\n', '        // next line would revert but require to emit reason:\n', '        require(lockProductId < lockProducts.length, "invalid lockProductId");\n', '\n', '        lockProducts[lockProductId].isActive = isActive;\n', '        emit LockProductActiveChange(lockProductId, isActive);\n', '\n', '    }\n', '\n', '    /* lock funds, called from AugmintToken&#39;s transferAndNotify\n', '     Flow for locking tokens:\n', '        1) user calls token contract&#39;s transferAndNotify lockProductId passed in data arg\n', '        2) transferAndNotify transfers tokens to the Lock contract\n', '        3) transferAndNotify calls Lock.transferNotification with lockProductId\n', '    */\n', '    function transferNotification(address from, uint256 amountToLock, uint _lockProductId) external {\n', '        require(msg.sender == address(augmintToken), "msg.sender must be augmintToken");\n', '        // next line would revert but require to emit reason:\n', '        require(lockProductId < lockProducts.length, "invalid lockProductId");\n', '        uint32 lockProductId = uint32(_lockProductId);\n', '        require(lockProductId == _lockProductId, "lockProductId overflow");\n', '        /* TODO: make data arg generic bytes\n', '            uint productId;\n', '            assembly { // solhint-disable-line no-inline-assembly\n', '                productId := mload(data)\n', '        } */\n', '        _createLock(lockProductId, from, amountToLock);\n', '    }\n', '\n', '    function releaseFunds(uint lockId) external {\n', '        // next line would revert but require to emit reason:\n', '        require(lockId < locks.length, "invalid lockId");\n', '        Lock storage lock = locks[lockId];\n', '        LockProduct storage lockProduct = lockProducts[lock.productId];\n', '\n', '        require(lock.isActive, "lock must be in active state");\n', '        require(now >= lock.lockedUntil, "current time must be later than lockedUntil");\n', '\n', '        lock.isActive = false;\n', '\n', '        uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n', '\n', '        monetarySupervisor.releaseFundsNotification(lock.amountLocked); // to maintain totalLockAmount\n', '        augmintToken.transferWithNarrative(lock.owner, lock.amountLocked.add(interestEarned),\n', '                                                                                "Funds released from lock");\n', '\n', '        emit LockReleased(lock.owner, lockId);\n', '    }\n', '\n', '    function setMonetarySupervisor(MonetarySupervisor newMonetarySupervisor) external restrict("StabilityBoard") {\n', '        monetarySupervisor = newMonetarySupervisor;\n', '        emit MonetarySupervisorChanged(newMonetarySupervisor);\n', '    }\n', '\n', '    function getLockProductCount() external view returns (uint) {\n', '\n', '        return lockProducts.length;\n', '\n', '    }\n', '\n', '    // returns 20 lock products starting from some offset\n', '    // lock products are encoded as [ perTermInterest, durationInSecs, minimumLockAmount, maxLockAmount, isActive ]\n', '    function getLockProducts(uint offset) external view returns (uint[5][CHUNK_SIZE] response) {\n', '        for (uint8 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= lockProducts.length) { break; }\n', '\n', '            LockProduct storage lockProduct = lockProducts[offset + i];\n', '\n', '            response[i] = [ lockProduct.perTermInterest, lockProduct.durationInSecs, lockProduct.minimumLockAmount,\n', '                        monetarySupervisor.getMaxLockAmount(lockProduct.minimumLockAmount, lockProduct.perTermInterest),\n', '                        lockProduct.isActive ? 1 : 0 ];\n', '        }\n', '    }\n', '\n', '    function getLockCount() external view returns (uint) {\n', '        return locks.length;\n', '    }\n', '\n', '    function getLockCountForAddress(address lockOwner) external view returns (uint) {\n', '        return accountLocks[lockOwner].length;\n', '    }\n', '\n', '    // returns CHUNK_SIZE locks starting from some offset\n', '    // lock products are encoded as\n', '    //       [lockId, owner, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n', '    // NB: perTermInterest is in millionths (i.e. 1,000,000 = 100%):\n', '    function getLocks(uint offset) external view returns (uint[8][CHUNK_SIZE] response) {\n', '\n', '        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= locks.length) { break; }\n', '\n', '            Lock storage lock = locks[offset + i];\n', '            LockProduct storage lockProduct = lockProducts[lock.productId];\n', '\n', '            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n', '\n', '            response[i] = [uint(offset + i), uint(lock.owner), lock.amountLocked, interestEarned, lock.lockedUntil,\n', '                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0];\n', '        }\n', '    }\n', '\n', '    // returns CHUNK_SIZE locks of a given account, starting from some offset\n', '    // lock products are encoded as\n', '    //             [lockId, amountLocked, interestEarned, lockedUntil, perTermInterest, durationInSecs, isActive ]\n', '    function getLocksForAddress(address lockOwner, uint offset) external view returns (uint[7][CHUNK_SIZE] response) {\n', '\n', '        uint[] storage locksForAddress = accountLocks[lockOwner];\n', '\n', '        for (uint16 i = 0; i < CHUNK_SIZE; i++) {\n', '\n', '            if (offset + i >= locksForAddress.length) { break; }\n', '\n', '            Lock storage lock = locks[locksForAddress[offset + i]];\n', '            LockProduct storage lockProduct = lockProducts[lock.productId];\n', '\n', '            uint interestEarned = calculateInterest(lockProduct.perTermInterest, lock.amountLocked);\n', '\n', '            response[i] = [ locksForAddress[offset + i], lock.amountLocked, interestEarned, lock.lockedUntil,\n', '                                lockProduct.perTermInterest, lockProduct.durationInSecs, lock.isActive ? 1 : 0 ];\n', '        }\n', '    }\n', '\n', '    function calculateInterest(uint32 perTermInterest, uint amountToLock) public pure returns (uint interestEarned) {\n', '        interestEarned = amountToLock.mul(perTermInterest).div(1000000);\n', '    }\n', '\n', '    // Internal function. assumes amountToLock is already transferred to this Lock contract\n', '    function _createLock(uint32 lockProductId, address lockOwner, uint amountToLock) internal returns(uint lockId) {\n', '        LockProduct storage lockProduct = lockProducts[lockProductId];\n', '        require(lockProduct.isActive, "lockProduct must be in active state");\n', '        require(amountToLock >= lockProduct.minimumLockAmount, "amountToLock must be >= minimumLockAmount");\n', '\n', '        uint interestEarned = calculateInterest(lockProduct.perTermInterest, amountToLock);\n', '        uint expiration = now.add(lockProduct.durationInSecs);\n', '        uint40 lockedUntil = uint40(expiration);\n', '        require(lockedUntil == expiration, "lockedUntil overflow");\n', '\n', '        lockId = locks.push(Lock(amountToLock, lockOwner, lockProductId, lockedUntil, true)) - 1;\n', '        accountLocks[lockOwner].push(lockId);\n', '\n', '        monetarySupervisor.requestInterest(amountToLock, interestEarned); // update KPIs & transfer interest here\n', '\n', '        emit NewLock(lockOwner, lockId, amountToLock, interestEarned, lockedUntil, lockProduct.perTermInterest,\n', '                    lockProduct.durationInSecs);\n', '    }\n', '\n', '}']