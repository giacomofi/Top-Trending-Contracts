['pragma solidity ^0.4.25;\n', '\n', 'interface ERC721 {\n', '    function totalSupply() external view returns (uint256 tokens);\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function exists(uint256 tokenId) external view returns (bool tokenExists);\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function tokensOf(address owner) external view returns (uint256[] tokens);\n', '    //function tokenByIndex(uint256 index) external view returns (uint256 token);\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '}\n', '\n', 'contract WWGClanCoupon is ERC721 {\n', '    using SafeMath for uint256;\n', '    \n', '    // Clan contract not finalized/deployed yet, so buyers get an ERC-721 coupon \n', '    // which will be burnt in exchange for real clan token in next few weeks \n', '    \n', '    address preLaunchMinter;\n', '    address wwgClanContract;\n', '    \n', '    uint256 numClans;\n', '    address owner; // Minor management\n', '    \n', '    event ClanMinted(address to, uint256 clanId);\n', '    \n', '    // ERC721 stuff\n', '    mapping (uint256 => address) public tokenOwner;\n', '    mapping (uint256 => address) public tokenApprovals;\n', '    mapping (address => uint256[]) public ownedTokens;\n', '    mapping(uint256 => uint256) public ownedTokensIndex;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function setCouponMinter(address prelaunchContract) external {\n', '        require(msg.sender == owner);\n', '        require(preLaunchMinter == address(0));\n', '        preLaunchMinter = prelaunchContract;\n', '    }\n', '    \n', '    function setClanContract(address clanContract) external {\n', '        require(msg.sender == owner);\n', '        wwgClanContract = address(clanContract);\n', '    }\n', '    \n', '    function mintClan(uint256 clanId, address clanOwner) external {\n', '        require(msg.sender == address(preLaunchMinter));\n', '        require(tokenOwner[clanId] == address(0));\n', '\n', '        numClans++;\n', '        addTokenTo(clanOwner, clanId);\n', '        emit Transfer(address(0), clanOwner, clanId);\n', '    }\n', '    \n', '    // Finalized clan contract has control to redeem, so will burn this coupon upon doing so\n', '    function burnCoupon(address clanOwner, uint256 tokenId) external {\n', '        require (msg.sender == wwgClanContract);\n', '        removeTokenFrom(clanOwner, tokenId);\n', '        numClans = numClans.sub(1);\n', '        \n', '        emit ClanMinted(clanOwner, tokenId);\n', '    }\n', '    \n', '    function balanceOf(address player) public view returns (uint256) {\n', '        return ownedTokens[player].length;\n', '    }\n', '    \n', '    function ownerOf(uint256 clanId) external view returns (address) {\n', '        return tokenOwner[clanId];\n', '    }\n', '    \n', '    function totalSupply() external view returns (uint256) {\n', '        return numClans;\n', '    }\n', '    \n', '    function exists(uint256 clanId) public view returns (bool) {\n', '        return tokenOwner[clanId] != address(0);\n', '    }\n', '    \n', '    function approve(address to, uint256 clanId) external {\n', '        require(tokenOwner[clanId] == msg.sender);\n', '        tokenApprovals[clanId] = to;\n', '        emit Approval(msg.sender, to, clanId);\n', '    }\n', '\n', '    function getApproved(uint256 clanId) external view returns (address operator) {\n', '        return tokenApprovals[clanId];\n', '    }\n', '    \n', '    function tokensOf(address player) external view returns (uint256[] tokens) {\n', '         return ownedTokens[player];\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(tokenApprovals[tokenId] == msg.sender || tokenOwner[tokenId] == msg.sender);\n', '\n', '        removeTokenFrom(from, tokenId);\n', '        addTokenTo(to, tokenId);\n', '\n', '        delete tokenApprovals[tokenId]; // Clear approval\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    function removeTokenFrom(address from, uint256 tokenId) internal {\n', '        require(tokenOwner[tokenId] == from);\n', '        tokenOwner[tokenId] = address(0);\n', '        delete tokenApprovals[tokenId]; // Clear approval\n', '\n', '        uint256 tokenIndex = ownedTokensIndex[tokenId];\n', '        uint256 lastTokenIndex = ownedTokens[from].length.sub(1);\n', '        uint256 lastToken = ownedTokens[from][lastTokenIndex];\n', '\n', '        ownedTokens[from][tokenIndex] = lastToken;\n', '        ownedTokens[from][lastTokenIndex] = 0;\n', '\n', '        ownedTokens[from].length--;\n', '        ownedTokensIndex[tokenId] = 0;\n', '        ownedTokensIndex[lastToken] = tokenIndex;\n', '    }\n', '\n', '    function addTokenTo(address to, uint256 tokenId) internal {\n', '        require(balanceOf(to) == 0); // Can only own one clan (thus coupon to keep things simple)\n', '        tokenOwner[tokenId] = to;\n', '\n', '        ownedTokensIndex[tokenId] = ownedTokens[to].length;\n', '        ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']