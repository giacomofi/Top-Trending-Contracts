['pragma solidity ^0.4.21;\n', 'contract owned {\n', '    address public owner;\n', '    event Log(string s);\n', '\n', '    constructor()payable public {\n', '        owner = msg.sender;\n', '    }\n', '    function fallback() public payable{\n', '        revert();\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '    function isOwner()public{\n', '        if(msg.sender==owner)emit Log("Owner");\n', '        else{\n', '            emit Log("Not Owner");\n', '        }\n', '    }\n', '}\n', 'contract verifier is owned{\n', '    struct action {\n', '        uint timestamp;\n', '        uint256 value;\n', '        address from;\n', '    }\n', '    mapping(string => mapping(uint => action))register;\n', '    mapping(string => uint256)transactionCount;\n', '    \n', '    event actionLog(uint timestamp, uint256 value,address from);\n', '    event Blog(string);\n', '    \n', '    constructor()public payable{\n', '    }\n', '    function registerTransaction(string neo,address ethA,uint256 value)internal{\n', '        register[neo][transactionCount[neo]]=action(now,value,ethA);\n', '        transactionCount[neo]+=1;\n', '    }\n', '    function verifyYourself(string neo, uint256 value)public payable{\n', '        registerTransaction(neo,msg.sender,value);\n', '    }\n', '    function viewAll(string neo)public onlyOwner{\n', '        uint i;\n', '        for(i=0;i<transactionCount[neo];i++){\n', '            emit actionLog(register[neo][i].timestamp,\n', '                        register[neo][i].value,\n', '                        register[neo][i].from);\n', '        }\n', '    }\n', '    function viewSpecific(string neo, uint256 index)public onlyOwner{\n', '        emit actionLog(register[neo][index].timestamp,\n', '                        register[neo][index].value,\n', '                        register[neo][index].from);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', 'contract owned {\n', '    address public owner;\n', '    event Log(string s);\n', '\n', '    constructor()payable public {\n', '        owner = msg.sender;\n', '    }\n', '    function fallback() public payable{\n', '        revert();\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '    function isOwner()public{\n', '        if(msg.sender==owner)emit Log("Owner");\n', '        else{\n', '            emit Log("Not Owner");\n', '        }\n', '    }\n', '}\n', 'contract verifier is owned{\n', '    struct action {\n', '        uint timestamp;\n', '        uint256 value;\n', '        address from;\n', '    }\n', '    mapping(string => mapping(uint => action))register;\n', '    mapping(string => uint256)transactionCount;\n', '    \n', '    event actionLog(uint timestamp, uint256 value,address from);\n', '    event Blog(string);\n', '    \n', '    constructor()public payable{\n', '    }\n', '    function registerTransaction(string neo,address ethA,uint256 value)internal{\n', '        register[neo][transactionCount[neo]]=action(now,value,ethA);\n', '        transactionCount[neo]+=1;\n', '    }\n', '    function verifyYourself(string neo, uint256 value)public payable{\n', '        registerTransaction(neo,msg.sender,value);\n', '    }\n', '    function viewAll(string neo)public onlyOwner{\n', '        uint i;\n', '        for(i=0;i<transactionCount[neo];i++){\n', '            emit actionLog(register[neo][i].timestamp,\n', '                        register[neo][i].value,\n', '                        register[neo][i].from);\n', '        }\n', '    }\n', '    function viewSpecific(string neo, uint256 index)public onlyOwner{\n', '        emit actionLog(register[neo][index].timestamp,\n', '                        register[neo][index].value,\n', '                        register[neo][index].from);\n', '    }\n', '}']
