['pragma solidity ^0.4.24;\n', '// This is based on https://github.com/OpenZeppelin/openzeppelin-solidity.\n', '// We announced each .sol file and omitted the verbose comments.\n', '// Gas limit : 3,000,000\n', '\n', 'library SafeMath {                             //SafeMath.sol\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) { return 0; }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract QurozToken { // pulbic functions of Token\n', '  function transfer(address _to, uint256 _value) public returns (bool) {}\n', '}\n', '\n', 'contract QforaSale {\n', '  using SafeMath for uint256;                         //RefundableCrowdsale.sol\n', '  uint256 public goal;                                //RefundableCrowdsale.sol, goal of wei\n', '  uint256 public rate;                                //Crowdsale.sol, Token = wei * rate\n', '  uint256 public openingTime;                         //TimedCrowdsale.sol\n', '  uint256 public closingTime;                         //TimedCrowdsale.sol\n', '  uint256 public weiRaised;                           //Crowdsale.sol\n', '  uint256 public tokenSold;          //new\n', '  uint256 public threshold;          //new\n', '  uint256 public hardCap;            //new\n', '  uint256 public bonusRate;          // new, 20 means 20% \n', '  address public wallet;                              //RefundVault.sol\n', '  address public owner;                               //Ownable.sol\n', '  bool public isFinalized;                     //FinalizableCrowdsale.sol\n', '  mapping(address => uint256) public balances;       //PostDeliveryCrowdsale.sol, info for withdraw\n', '  mapping(address => uint256) public deposited;      //RefundVault.sol,           info for refund\n', '  mapping(address => bool) public whitelist;          //WhitelistedCrowdsale.sol\n', '  enum State { Active, Refunding, Closed }            //RefundVault.sol\n', '  State public state;                                 //RefundVault.sol\n', '  QurozToken public token;\n', '\n', '  event Closed();                                     //RefundVault.sol\n', '  event RefundsEnabled();                             //RefundVault.sol\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);   //RefundVault.sol\n', '  event Finalized();                                      //FinalizableCrowdsale.sol\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);  //Ownable.sol\n', '  event TokenPurchase(address indexed purchaser,address indexed beneficiary,uint256 value,uint256 amount); //Crowdsale\n', '\n', '  constructor(address _wallet, QurozToken _token) public {\n', '    require(_wallet != address(0) && _token != address(0));\n', '    owner = msg.sender;\n', '    wallet = _wallet;\n', '    token = _token;\n', '    goal = 5000e18;\n', '    rate = 10000;\n', '    threshold = 100e18;\n', '    hardCap = 50000e18;\n', '    bonusRate = 20;\n', '    openingTime = now.add(3 hours + 5 minutes);\n', '    closingTime = openingTime.add(28 days);\n', '    require(block.timestamp <= openingTime && openingTime <= closingTime);\n', '  }\n', '\n', '  modifier onlyOwner() {require(msg.sender == owner); _;}            //Ownable.sol\n', '  modifier isWhitelisted(address _beneficiary) {require(whitelist[_beneficiary]); _;}  //WhitelistedCrowdsale.sol\n', '\n', '  function addToWhitelist(address _beneficiary) public onlyOwner {      //WhitelistedCrowdsale.sol (external to public)\n', '    whitelist[_beneficiary] = true;\n', '  }\n', '\n', '  function addManyToWhitelist(address[] _beneficiaries) public onlyOwner { //WhitelistedCrowdsale.sol (external to public)\n', '    for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '      whitelist[_beneficiaries[i]] = true;\n', '    }\n', '  }\n', '\n', '  function removeFromWhitelist(address _beneficiary) public onlyOwner { //WhitelistedCrowdsale.sol (external to public)\n', '    whitelist[_beneficiary] = false;\n', '  }\n', '\n', '  function () external payable {                                            //Crowdsale.sol\n', '    require(openingTime <= block.timestamp && block.timestamp <= closingTime);      // new\n', '    require(whitelist[msg.sender]);        // new\n', '    require(msg.value >= threshold );      // new\n', '    require(weiRaised.add(msg.value) <= hardCap );      // new\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {                           //Crowdsale.sol\n', '    uint256 weiAmount = msg.value;\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '    uint256 totalTokens = tokens.mul(100 + bonusRate).div(100);\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    tokenSold = tokenSold.add(totalTokens);          // new\n', '    _processPurchase(_beneficiary, totalTokens);     // changed parameter to totalTokens\n', '    deposit(_beneficiary, msg.value);           // new\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '//    _updatePurchasingState(_beneficiary, weiAmount);\n', '//    _forwardFunds();                                // masking for refund\n', '//    _postValidatePurchase(_beneficiary, weiAmount);\n', '  }\n', '\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {    \n', '      //Crowdsale.sol, WhitelistedCrowdsale.sol\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '\n', '  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {        //Crowdsale.sol\n', '    return _weiAmount.mul(rate);\n', '  }\n', '\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {      //PostDeliveryCrowdsale.sol\n', '//    _deliverTokens(_beneficiary, _tokenAmount);  //Crowdsale.sol\n', '    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);  // new\n', '\n', '  }\n', '\n', '  function hasClosed() public view returns (bool) {               //TimedCrowdsale.sol\n', '    return block.timestamp > closingTime;\n', '  }\n', '\n', '  function deposit(address investor, uint256 value) internal {  //RefundVault.sol (liternal, no payable, add value)\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(value);\n', '  }\n', '\n', '  function goalReached() public view returns (bool) {    //RefundableCrowdsale.sol\n', '    return weiRaised >= goal;\n', '  }\n', '\n', '  function finalize() onlyOwner public {          //FinalizableCrowdsale.sol\n', '    require(!isFinalized);\n', '    require(hasClosed());   // finalizing after timeout\n', '    finalization();\n', '    emit Finalized();\n', '    isFinalized = true;\n', '  }\n', '\n', '  function finalization() internal {                     //RefundableCrowdsale.sol (change state)\n', '    if (goalReached()) { close(); } \n', '    else               { enableRefunds(); }\n', '    //super.finalization();\n', '  }\n', '\n', '  function close() onlyOwner public {   //RefundVault.sol (Active -> Closed if goal reached)\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public { //RefundVault.sol (Active -> Refunding if goal not reached)\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '\n', '  function claimRefund() public {                         //RefundableCrowdsale.sol\n', '    require(isFinalized);\n', '    require(!goalReached());\n', '    refund(msg.sender);\n', '  }\n', '\n', '  function refund(address investor) public {       //RefundVault.sol\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    balances[investor] = 0;                                                                             // new\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    emit Refunded(investor, depositedValue);\n', '  }\n', '\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {       //Crowdsale.sol\n', '    token.transfer(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function withdrawTokens() public {                              //PostDeliveryCrowdsale.sol\n', '    require(hasClosed());\n', '    uint256 amount = balances[msg.sender];\n', '    require(amount > 0);\n', '    balances[msg.sender] = 0;\n', '    _deliverTokens(msg.sender, amount);\n', '    deposited[msg.sender] = 0;                        //new\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner { //Ownable.sol\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address _newOwner) internal {       //Ownable.sol\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '    \n', '  function destroyAndSend(address _recipient) onlyOwner public {   //Destructible.sol\n', '    selfdestruct(_recipient);\n', '  }\n', '\n', '/* new functions */\n', '  function transferToken(address to, uint256 value) onlyOwner public { \n', '    token.transfer(to, value);\n', '  }\n', '  \n', '  function setBonusRate(uint256 _bonusRate) public onlyOwner{\n', '    _setBonusRate(_bonusRate);\n', '  }\n', '\n', '  function _setBonusRate(uint256 _bonusRate) internal {\n', '    bonusRate = _bonusRate;\n', '  }\n', '  \n', '  function getWeiBalance() public view returns(uint256) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function getBalanceOf(address investor) public view returns(uint256) {\n', '    return balances[investor];\n', '  }\n', '\n', '  function getDepositedOf(address investor) public view returns(uint256) {\n', '    return deposited[investor];\n', '  }\n', '\n', '  function getWeiRaised() public view returns(uint256) {\n', '    return weiRaised;\n', '  }\n', '\n', '  function getTokenSold() public view returns(uint256) {\n', '    return tokenSold;\n', '  }\n', '\n', '  function setSmallInvestor(address _beneficiary, uint256 weiAmount, uint256 totalTokens) public onlyOwner {\n', '    require(whitelist[_beneficiary]); \n', '    require(weiAmount >= 1 ether ); \n', '    require(weiRaised.add(weiAmount) <= hardCap ); \n', '    weiRaised = weiRaised.add(weiAmount);\n', '    tokenSold = tokenSold.add(totalTokens); \n', '    _processPurchase(_beneficiary, totalTokens);     \n', '    deposit(_beneficiary, weiAmount);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '// This is based on https://github.com/OpenZeppelin/openzeppelin-solidity.\n', '// We announced each .sol file and omitted the verbose comments.\n', '// Gas limit : 3,000,000\n', '\n', 'library SafeMath {                             //SafeMath.sol\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) { return 0; }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract QurozToken { // pulbic functions of Token\n', '  function transfer(address _to, uint256 _value) public returns (bool) {}\n', '}\n', '\n', 'contract QforaSale {\n', '  using SafeMath for uint256;                         //RefundableCrowdsale.sol\n', '  uint256 public goal;                                //RefundableCrowdsale.sol, goal of wei\n', '  uint256 public rate;                                //Crowdsale.sol, Token = wei * rate\n', '  uint256 public openingTime;                         //TimedCrowdsale.sol\n', '  uint256 public closingTime;                         //TimedCrowdsale.sol\n', '  uint256 public weiRaised;                           //Crowdsale.sol\n', '  uint256 public tokenSold;          //new\n', '  uint256 public threshold;          //new\n', '  uint256 public hardCap;            //new\n', '  uint256 public bonusRate;          // new, 20 means 20% \n', '  address public wallet;                              //RefundVault.sol\n', '  address public owner;                               //Ownable.sol\n', '  bool public isFinalized;                     //FinalizableCrowdsale.sol\n', '  mapping(address => uint256) public balances;       //PostDeliveryCrowdsale.sol, info for withdraw\n', '  mapping(address => uint256) public deposited;      //RefundVault.sol,           info for refund\n', '  mapping(address => bool) public whitelist;          //WhitelistedCrowdsale.sol\n', '  enum State { Active, Refunding, Closed }            //RefundVault.sol\n', '  State public state;                                 //RefundVault.sol\n', '  QurozToken public token;\n', '\n', '  event Closed();                                     //RefundVault.sol\n', '  event RefundsEnabled();                             //RefundVault.sol\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);   //RefundVault.sol\n', '  event Finalized();                                      //FinalizableCrowdsale.sol\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);  //Ownable.sol\n', '  event TokenPurchase(address indexed purchaser,address indexed beneficiary,uint256 value,uint256 amount); //Crowdsale\n', '\n', '  constructor(address _wallet, QurozToken _token) public {\n', '    require(_wallet != address(0) && _token != address(0));\n', '    owner = msg.sender;\n', '    wallet = _wallet;\n', '    token = _token;\n', '    goal = 5000e18;\n', '    rate = 10000;\n', '    threshold = 100e18;\n', '    hardCap = 50000e18;\n', '    bonusRate = 20;\n', '    openingTime = now.add(3 hours + 5 minutes);\n', '    closingTime = openingTime.add(28 days);\n', '    require(block.timestamp <= openingTime && openingTime <= closingTime);\n', '  }\n', '\n', '  modifier onlyOwner() {require(msg.sender == owner); _;}            //Ownable.sol\n', '  modifier isWhitelisted(address _beneficiary) {require(whitelist[_beneficiary]); _;}  //WhitelistedCrowdsale.sol\n', '\n', '  function addToWhitelist(address _beneficiary) public onlyOwner {      //WhitelistedCrowdsale.sol (external to public)\n', '    whitelist[_beneficiary] = true;\n', '  }\n', '\n', '  function addManyToWhitelist(address[] _beneficiaries) public onlyOwner { //WhitelistedCrowdsale.sol (external to public)\n', '    for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '      whitelist[_beneficiaries[i]] = true;\n', '    }\n', '  }\n', '\n', '  function removeFromWhitelist(address _beneficiary) public onlyOwner { //WhitelistedCrowdsale.sol (external to public)\n', '    whitelist[_beneficiary] = false;\n', '  }\n', '\n', '  function () external payable {                                            //Crowdsale.sol\n', '    require(openingTime <= block.timestamp && block.timestamp <= closingTime);      // new\n', '    require(whitelist[msg.sender]);        // new\n', '    require(msg.value >= threshold );      // new\n', '    require(weiRaised.add(msg.value) <= hardCap );      // new\n', '    buyTokens(msg.sender);\n', '  }\n', '\n', '  function buyTokens(address _beneficiary) public payable {                           //Crowdsale.sol\n', '    uint256 weiAmount = msg.value;\n', '    _preValidatePurchase(_beneficiary, weiAmount);\n', '    uint256 tokens = _getTokenAmount(weiAmount);\n', '    uint256 totalTokens = tokens.mul(100 + bonusRate).div(100);\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    tokenSold = tokenSold.add(totalTokens);          // new\n', '    _processPurchase(_beneficiary, totalTokens);     // changed parameter to totalTokens\n', '    deposit(_beneficiary, msg.value);           // new\n', '    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '//    _updatePurchasingState(_beneficiary, weiAmount);\n', '//    _forwardFunds();                                // masking for refund\n', '//    _postValidatePurchase(_beneficiary, weiAmount);\n', '  }\n', '\n', '  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {    \n', '      //Crowdsale.sol, WhitelistedCrowdsale.sol\n', '    require(_beneficiary != address(0));\n', '    require(_weiAmount != 0);\n', '  }\n', '\n', '  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {        //Crowdsale.sol\n', '    return _weiAmount.mul(rate);\n', '  }\n', '\n', '  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {      //PostDeliveryCrowdsale.sol\n', '//    _deliverTokens(_beneficiary, _tokenAmount);  //Crowdsale.sol\n', '    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);  // new\n', '\n', '  }\n', '\n', '  function hasClosed() public view returns (bool) {               //TimedCrowdsale.sol\n', '    return block.timestamp > closingTime;\n', '  }\n', '\n', '  function deposit(address investor, uint256 value) internal {  //RefundVault.sol (liternal, no payable, add value)\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(value);\n', '  }\n', '\n', '  function goalReached() public view returns (bool) {    //RefundableCrowdsale.sol\n', '    return weiRaised >= goal;\n', '  }\n', '\n', '  function finalize() onlyOwner public {          //FinalizableCrowdsale.sol\n', '    require(!isFinalized);\n', '    require(hasClosed());   // finalizing after timeout\n', '    finalization();\n', '    emit Finalized();\n', '    isFinalized = true;\n', '  }\n', '\n', '  function finalization() internal {                     //RefundableCrowdsale.sol (change state)\n', '    if (goalReached()) { close(); } \n', '    else               { enableRefunds(); }\n', '    //super.finalization();\n', '  }\n', '\n', '  function close() onlyOwner public {   //RefundVault.sol (Active -> Closed if goal reached)\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function enableRefunds() onlyOwner public { //RefundVault.sol (Active -> Refunding if goal not reached)\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '\n', '  function claimRefund() public {                         //RefundableCrowdsale.sol\n', '    require(isFinalized);\n', '    require(!goalReached());\n', '    refund(msg.sender);\n', '  }\n', '\n', '  function refund(address investor) public {       //RefundVault.sol\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    balances[investor] = 0;                                                                             // new\n', '    deposited[investor] = 0;\n', '    investor.transfer(depositedValue);\n', '    emit Refunded(investor, depositedValue);\n', '  }\n', '\n', '  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {       //Crowdsale.sol\n', '    token.transfer(_beneficiary, _tokenAmount);\n', '  }\n', '\n', '  function withdrawTokens() public {                              //PostDeliveryCrowdsale.sol\n', '    require(hasClosed());\n', '    uint256 amount = balances[msg.sender];\n', '    require(amount > 0);\n', '    balances[msg.sender] = 0;\n', '    _deliverTokens(msg.sender, amount);\n', '    deposited[msg.sender] = 0;                        //new\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) public onlyOwner { //Ownable.sol\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address _newOwner) internal {       //Ownable.sol\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '    \n', '  function destroyAndSend(address _recipient) onlyOwner public {   //Destructible.sol\n', '    selfdestruct(_recipient);\n', '  }\n', '\n', '/* new functions */\n', '  function transferToken(address to, uint256 value) onlyOwner public { \n', '    token.transfer(to, value);\n', '  }\n', '  \n', '  function setBonusRate(uint256 _bonusRate) public onlyOwner{\n', '    _setBonusRate(_bonusRate);\n', '  }\n', '\n', '  function _setBonusRate(uint256 _bonusRate) internal {\n', '    bonusRate = _bonusRate;\n', '  }\n', '  \n', '  function getWeiBalance() public view returns(uint256) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function getBalanceOf(address investor) public view returns(uint256) {\n', '    return balances[investor];\n', '  }\n', '\n', '  function getDepositedOf(address investor) public view returns(uint256) {\n', '    return deposited[investor];\n', '  }\n', '\n', '  function getWeiRaised() public view returns(uint256) {\n', '    return weiRaised;\n', '  }\n', '\n', '  function getTokenSold() public view returns(uint256) {\n', '    return tokenSold;\n', '  }\n', '\n', '  function setSmallInvestor(address _beneficiary, uint256 weiAmount, uint256 totalTokens) public onlyOwner {\n', '    require(whitelist[_beneficiary]); \n', '    require(weiAmount >= 1 ether ); \n', '    require(weiRaised.add(weiAmount) <= hardCap ); \n', '    weiRaised = weiRaised.add(weiAmount);\n', '    tokenSold = tokenSold.add(totalTokens); \n', '    _processPurchase(_beneficiary, totalTokens);     \n', '    deposit(_beneficiary, weiAmount);\n', '  }\n', '\n', '}']
