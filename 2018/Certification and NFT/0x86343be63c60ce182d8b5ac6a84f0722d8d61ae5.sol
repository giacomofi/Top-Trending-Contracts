['/*\n', '\n', '  Copyright 2018 bZeroX, LLC\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', 'contract GasTracker {\n', '\n', '    uint internal gasUsed;\n', '\n', '    modifier tracksGas() {\n', '        gasUsed = gasleft();\n', '        _;\n', '        gasUsed = 0;\n', '    }\n', '}\n', '\n', 'contract BZxObjects {\n', '\n', '    struct LoanOrder {\n', '        address maker;\n', '        address loanTokenAddress;\n', '        address interestTokenAddress;\n', '        address collateralTokenAddress;\n', '        address feeRecipientAddress;\n', '        address oracleAddress;\n', '        uint loanTokenAmount;\n', '        uint interestAmount;\n', '        uint initialMarginAmount;\n', '        uint maintenanceMarginAmount;\n', '        uint lenderRelayFee;\n', '        uint traderRelayFee;\n', '        uint expirationUnixTimestampSec;\n', '        bytes32 loanOrderHash;\n', '    }\n', '\n', '    struct LoanRef {\n', '        bytes32 loanOrderHash;\n', '        address trader;\n', '    }\n', '\n', '    struct LoanPosition {\n', '        address lender;\n', '        address trader;\n', '        address collateralTokenAddressFilled;\n', '        address positionTokenAddressFilled;\n', '        uint loanTokenAmountFilled;\n', '        uint collateralTokenAmountFilled;\n', '        uint positionTokenAmountFilled;\n', '        uint loanStartUnixTimestampSec;\n', '        uint index;\n', '        bool active;\n', '    }\n', '\n', '    struct InterestData {\n', '        address lender;\n', '        address interestTokenAddress;\n', '        uint interestTotalAccrued;\n', '        uint interestPaidSoFar;\n', '    }\n', '\n', '    event LogLoanTaken (\n', '        address lender,\n', '        address trader,\n', '        address collateralTokenAddressFilled,\n', '        address positionTokenAddressFilled,\n', '        uint loanTokenAmountFilled,\n', '        uint collateralTokenAmountFilled,\n', '        uint positionTokenAmountFilled,\n', '        uint loanStartUnixTimestampSec,\n', '        bool active,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogLoanCancelled(\n', '        address maker,\n', '        uint cancelLoanTokenAmount,\n', '        uint remainingLoanTokenAmount,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogLoanClosed(\n', '        address lender,\n', '        address trader,\n', '        bool isLiquidation,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogPositionTraded(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount,\n', '        uint destTokenAmount\n', '    );\n', '\n', '    event LogMarginLevels(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        uint initialMarginAmount,\n', '        uint maintenanceMarginAmount,\n', '        uint currentMarginAmount\n', '    );\n', '\n', '    event LogWithdrawProfit(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        uint profitWithdrawn,\n', '        uint remainingPosition\n', '    );\n', '\n', '    event LogPayInterest(\n', '        bytes32 loanOrderHash,\n', '        address lender,\n', '        address trader,\n', '        uint amountPaid,\n', '        uint totalAccrued\n', '    );\n', '\n', '    function buildLoanOrderStruct(\n', '        bytes32 loanOrderHash,\n', '        address[6] addrs,\n', '        uint[9] uints) \n', '        internal\n', '        pure\n', '        returns (LoanOrder) {\n', '\n', '        return LoanOrder({\n', '            maker: addrs[0],\n', '            loanTokenAddress: addrs[1],\n', '            interestTokenAddress: addrs[2],\n', '            collateralTokenAddress: addrs[3],\n', '            feeRecipientAddress: addrs[4],\n', '            oracleAddress: addrs[5],\n', '            loanTokenAmount: uints[0],\n', '            interestAmount: uints[1],\n', '            initialMarginAmount: uints[2],\n', '            maintenanceMarginAmount: uints[3],\n', '            lenderRelayFee: uints[4],\n', '            traderRelayFee: uints[5],\n', '            expirationUnixTimestampSec: uints[6],\n', '            loanOrderHash: loanOrderHash\n', '        });\n', '    }\n', '}\n', '\n', 'contract BZxStorage is BZxObjects, ReentrancyGuard, Ownable, GasTracker {\n', '    uint internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    address public bZRxTokenContract;\n', '    address public vaultContract;\n', '    address public oracleRegistryContract;\n', '    address public bZxTo0xContract;\n', '    bool public DEBUG_MODE = false;\n', '\n', '    mapping (bytes32 => LoanOrder) public orders; // mapping of loanOrderHash to taken loanOrders\n', '    mapping (address => bytes32[]) public orderList; // mapping of lenders and trader addresses to array of loanOrderHashes\n', '    mapping (bytes32 => address) public orderLender; // mapping of loanOrderHash to lender address\n', '    mapping (bytes32 => address[]) public orderTraders; // mapping of loanOrderHash to array of trader addresses\n', '    mapping (bytes32 => uint) public orderFilledAmounts; // mapping of loanOrderHash to loanTokenAmount filled\n', '    mapping (bytes32 => uint) public orderCancelledAmounts; // mapping of loanOrderHash to loanTokenAmount cancelled\n', '    mapping (address => address) public oracleAddresses; // mapping of oracles to their current logic contract\n', '    mapping (bytes32 => mapping (address => LoanPosition)) public loanPositions; // mapping of loanOrderHash to mapping of traders to loanPositions\n', '    mapping (bytes32 => mapping (address => uint)) public interestPaid; // mapping of loanOrderHash to mapping of traders to amount of interest paid so far to a lender\n', '\n', '    LoanRef[] public loanList; // array of loans that need to be checked for liquidation or expiration\n', '}\n', '\n', 'contract Proxiable {\n', '    mapping (bytes4 => address) public targets;\n', '\n', '    function initialize(address _target) public;\n', '\n', '    function _replaceContract(address _target) internal {\n', '        // bytes4(keccak256("initialize(address)")) == 0xc4d66de8\n', '        require(_target.delegatecall(0xc4d66de8, _target), "Proxiable::_replaceContract: failed");\n', '    }\n', '}\n', '\n', 'contract BZxProxy is BZxStorage, Proxiable {\n', '\n', '    function() public {\n', '        address target = targets[msg.sig];\n', '        bytes memory data = msg.data;\n', '        assembly {\n', '            let result := delegatecall(gas, target, add(data, 0x20), mload(data), 0, 0)\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function initialize(\n', '        address)\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '\n', '    /*\n', '     * Owner only functions\n', '     */\n', '    function replaceContract(\n', '        address _target)\n', '        public\n', '        onlyOwner\n', '    {\n', '        _replaceContract(_target);\n', '    }\n', '\n', '    function setTarget(\n', '        string _funcId,  // example: "takeLoanOrderAsTrader(address[6],uint256[9],address,uint256,bytes)"\n', '        address _target) // logic contract address\n', '        public\n', '        onlyOwner\n', '        returns(bytes4)\n', '    {\n', '        bytes4 f = bytes4(keccak256(abi.encodePacked(_funcId)));\n', '        targets[f] = _target;\n', '        return f;\n', '    }\n', '\n', '    function setBZxAddresses(\n', '        address _bZRxToken,\n', '        address _vault,\n', '        address _oracleregistry,\n', '        address _exchange0xWrapper) \n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_bZRxToken != address(0) && _vault != address(0) && _oracleregistry != address(0) && _exchange0xWrapper != address(0))\n', '        bZRxTokenContract = _bZRxToken;\n', '        vaultContract = _vault;\n', '        oracleRegistryContract = _oracleregistry;\n', '        bZxTo0xContract = _exchange0xWrapper;\n', '    }\n', '\n', '    function setDebugMode (\n', '        bool _debug)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (DEBUG_MODE != _debug)\n', '            DEBUG_MODE = _debug;\n', '    }\n', '\n', '    function setBZRxToken (\n', '        address _token)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_token != address(0))\n', '            bZRxTokenContract = _token;\n', '    }\n', '\n', '    function setVault (\n', '        address _vault)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_vault != address(0))\n', '            vaultContract = _vault;\n', '    }\n', '\n', '    function setOracleRegistry (\n', '        address _registry)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_registry != address(0))\n', '            oracleRegistryContract = _registry;\n', '    }\n', '\n', '    function setOracleReference (\n', '        address _oracle,\n', '        address _logicContract)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (oracleAddresses[_oracle] != _logicContract)\n', '            oracleAddresses[_oracle] = _logicContract;\n', '    }\n', '\n', '    function set0xExchangeWrapper (\n', '        address _wrapper)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_wrapper != address(0))\n', '            bZxTo0xContract = _wrapper;\n', '    }\n', '\n', '    /*\n', '     * View functions\n', '     */\n', '\n', '    function getTarget(\n', '        string _funcId) // example: "takeLoanOrderAsTrader(address[6],uint256[9],address,uint256,bytes)"\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return targets[bytes4(keccak256(abi.encodePacked(_funcId)))];\n', '    }\n', '}']
['/*\n', '\n', '  Copyright 2018 bZeroX, LLC\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', 'contract GasTracker {\n', '\n', '    uint internal gasUsed;\n', '\n', '    modifier tracksGas() {\n', '        gasUsed = gasleft();\n', '        _;\n', '        gasUsed = 0;\n', '    }\n', '}\n', '\n', 'contract BZxObjects {\n', '\n', '    struct LoanOrder {\n', '        address maker;\n', '        address loanTokenAddress;\n', '        address interestTokenAddress;\n', '        address collateralTokenAddress;\n', '        address feeRecipientAddress;\n', '        address oracleAddress;\n', '        uint loanTokenAmount;\n', '        uint interestAmount;\n', '        uint initialMarginAmount;\n', '        uint maintenanceMarginAmount;\n', '        uint lenderRelayFee;\n', '        uint traderRelayFee;\n', '        uint expirationUnixTimestampSec;\n', '        bytes32 loanOrderHash;\n', '    }\n', '\n', '    struct LoanRef {\n', '        bytes32 loanOrderHash;\n', '        address trader;\n', '    }\n', '\n', '    struct LoanPosition {\n', '        address lender;\n', '        address trader;\n', '        address collateralTokenAddressFilled;\n', '        address positionTokenAddressFilled;\n', '        uint loanTokenAmountFilled;\n', '        uint collateralTokenAmountFilled;\n', '        uint positionTokenAmountFilled;\n', '        uint loanStartUnixTimestampSec;\n', '        uint index;\n', '        bool active;\n', '    }\n', '\n', '    struct InterestData {\n', '        address lender;\n', '        address interestTokenAddress;\n', '        uint interestTotalAccrued;\n', '        uint interestPaidSoFar;\n', '    }\n', '\n', '    event LogLoanTaken (\n', '        address lender,\n', '        address trader,\n', '        address collateralTokenAddressFilled,\n', '        address positionTokenAddressFilled,\n', '        uint loanTokenAmountFilled,\n', '        uint collateralTokenAmountFilled,\n', '        uint positionTokenAmountFilled,\n', '        uint loanStartUnixTimestampSec,\n', '        bool active,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogLoanCancelled(\n', '        address maker,\n', '        uint cancelLoanTokenAmount,\n', '        uint remainingLoanTokenAmount,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogLoanClosed(\n', '        address lender,\n', '        address trader,\n', '        bool isLiquidation,\n', '        bytes32 loanOrderHash\n', '    );\n', '\n', '    event LogPositionTraded(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        address sourceTokenAddress,\n', '        address destTokenAddress,\n', '        uint sourceTokenAmount,\n', '        uint destTokenAmount\n', '    );\n', '\n', '    event LogMarginLevels(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        uint initialMarginAmount,\n', '        uint maintenanceMarginAmount,\n', '        uint currentMarginAmount\n', '    );\n', '\n', '    event LogWithdrawProfit(\n', '        bytes32 loanOrderHash,\n', '        address trader,\n', '        uint profitWithdrawn,\n', '        uint remainingPosition\n', '    );\n', '\n', '    event LogPayInterest(\n', '        bytes32 loanOrderHash,\n', '        address lender,\n', '        address trader,\n', '        uint amountPaid,\n', '        uint totalAccrued\n', '    );\n', '\n', '    function buildLoanOrderStruct(\n', '        bytes32 loanOrderHash,\n', '        address[6] addrs,\n', '        uint[9] uints) \n', '        internal\n', '        pure\n', '        returns (LoanOrder) {\n', '\n', '        return LoanOrder({\n', '            maker: addrs[0],\n', '            loanTokenAddress: addrs[1],\n', '            interestTokenAddress: addrs[2],\n', '            collateralTokenAddress: addrs[3],\n', '            feeRecipientAddress: addrs[4],\n', '            oracleAddress: addrs[5],\n', '            loanTokenAmount: uints[0],\n', '            interestAmount: uints[1],\n', '            initialMarginAmount: uints[2],\n', '            maintenanceMarginAmount: uints[3],\n', '            lenderRelayFee: uints[4],\n', '            traderRelayFee: uints[5],\n', '            expirationUnixTimestampSec: uints[6],\n', '            loanOrderHash: loanOrderHash\n', '        });\n', '    }\n', '}\n', '\n', 'contract BZxStorage is BZxObjects, ReentrancyGuard, Ownable, GasTracker {\n', '    uint internal constant MAX_UINT = 2**256 - 1;\n', '\n', '    address public bZRxTokenContract;\n', '    address public vaultContract;\n', '    address public oracleRegistryContract;\n', '    address public bZxTo0xContract;\n', '    bool public DEBUG_MODE = false;\n', '\n', '    mapping (bytes32 => LoanOrder) public orders; // mapping of loanOrderHash to taken loanOrders\n', '    mapping (address => bytes32[]) public orderList; // mapping of lenders and trader addresses to array of loanOrderHashes\n', '    mapping (bytes32 => address) public orderLender; // mapping of loanOrderHash to lender address\n', '    mapping (bytes32 => address[]) public orderTraders; // mapping of loanOrderHash to array of trader addresses\n', '    mapping (bytes32 => uint) public orderFilledAmounts; // mapping of loanOrderHash to loanTokenAmount filled\n', '    mapping (bytes32 => uint) public orderCancelledAmounts; // mapping of loanOrderHash to loanTokenAmount cancelled\n', '    mapping (address => address) public oracleAddresses; // mapping of oracles to their current logic contract\n', '    mapping (bytes32 => mapping (address => LoanPosition)) public loanPositions; // mapping of loanOrderHash to mapping of traders to loanPositions\n', '    mapping (bytes32 => mapping (address => uint)) public interestPaid; // mapping of loanOrderHash to mapping of traders to amount of interest paid so far to a lender\n', '\n', '    LoanRef[] public loanList; // array of loans that need to be checked for liquidation or expiration\n', '}\n', '\n', 'contract Proxiable {\n', '    mapping (bytes4 => address) public targets;\n', '\n', '    function initialize(address _target) public;\n', '\n', '    function _replaceContract(address _target) internal {\n', '        // bytes4(keccak256("initialize(address)")) == 0xc4d66de8\n', '        require(_target.delegatecall(0xc4d66de8, _target), "Proxiable::_replaceContract: failed");\n', '    }\n', '}\n', '\n', 'contract BZxProxy is BZxStorage, Proxiable {\n', '\n', '    function() public {\n', '        address target = targets[msg.sig];\n', '        bytes memory data = msg.data;\n', '        assembly {\n', '            let result := delegatecall(gas, target, add(data, 0x20), mload(data), 0, 0)\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    function initialize(\n', '        address)\n', '        public\n', '    {\n', '        revert();\n', '    }\n', '\n', '    /*\n', '     * Owner only functions\n', '     */\n', '    function replaceContract(\n', '        address _target)\n', '        public\n', '        onlyOwner\n', '    {\n', '        _replaceContract(_target);\n', '    }\n', '\n', '    function setTarget(\n', '        string _funcId,  // example: "takeLoanOrderAsTrader(address[6],uint256[9],address,uint256,bytes)"\n', '        address _target) // logic contract address\n', '        public\n', '        onlyOwner\n', '        returns(bytes4)\n', '    {\n', '        bytes4 f = bytes4(keccak256(abi.encodePacked(_funcId)));\n', '        targets[f] = _target;\n', '        return f;\n', '    }\n', '\n', '    function setBZxAddresses(\n', '        address _bZRxToken,\n', '        address _vault,\n', '        address _oracleregistry,\n', '        address _exchange0xWrapper) \n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_bZRxToken != address(0) && _vault != address(0) && _oracleregistry != address(0) && _exchange0xWrapper != address(0))\n', '        bZRxTokenContract = _bZRxToken;\n', '        vaultContract = _vault;\n', '        oracleRegistryContract = _oracleregistry;\n', '        bZxTo0xContract = _exchange0xWrapper;\n', '    }\n', '\n', '    function setDebugMode (\n', '        bool _debug)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (DEBUG_MODE != _debug)\n', '            DEBUG_MODE = _debug;\n', '    }\n', '\n', '    function setBZRxToken (\n', '        address _token)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_token != address(0))\n', '            bZRxTokenContract = _token;\n', '    }\n', '\n', '    function setVault (\n', '        address _vault)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_vault != address(0))\n', '            vaultContract = _vault;\n', '    }\n', '\n', '    function setOracleRegistry (\n', '        address _registry)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_registry != address(0))\n', '            oracleRegistryContract = _registry;\n', '    }\n', '\n', '    function setOracleReference (\n', '        address _oracle,\n', '        address _logicContract)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (oracleAddresses[_oracle] != _logicContract)\n', '            oracleAddresses[_oracle] = _logicContract;\n', '    }\n', '\n', '    function set0xExchangeWrapper (\n', '        address _wrapper)\n', '        public\n', '        onlyOwner\n', '    {\n', '        if (_wrapper != address(0))\n', '            bZxTo0xContract = _wrapper;\n', '    }\n', '\n', '    /*\n', '     * View functions\n', '     */\n', '\n', '    function getTarget(\n', '        string _funcId) // example: "takeLoanOrderAsTrader(address[6],uint256[9],address,uint256,bytes)"\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return targets[bytes4(keccak256(abi.encodePacked(_funcId)))];\n', '    }\n', '}']
