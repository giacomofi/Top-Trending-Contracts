['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * this contract stands for the holds of WestIndia group\n', ' * all income will be split to holders according to their holds\n', ' * user can buy holds from shareholders at his will\n', ' */\n', 'contract Share {\n', '\n', '    bool public pause;\n', '    /**\n', '     * owner can pause the contract so that no one can withdrawal\n', '     * he can&#39;t do anything else\n', '     */\n', '    address public owner;\n', '    \n', '    /**\n', '     * the holds of every holder\n', '     * the total holds stick to 10000\n', '     */\n', '    mapping (address => uint) public holds;\n', '\n', '    /**\n', '     * since we don&#39;t record holders&#39; address in a list\n', '     * and we don&#39;t want to loop holders list everytime when there is income\n', '     *\n', '     * we use a mechanism called &#39;watermark&#39;\n', '     * \n', '     * the watermark indicates the value that brought into each holds from the begining\n', '     * it only goes up when new income send to the contract\n', '\n', '     * fullfilled indicate the amount that the holder has withdrawaled from his share\n', '     * it goes up when user withdrawal bonus\n', '     * and it goes up when user sell holds, goes down when user buy holds, since the total bonus of him stays the same.\n', '     */\n', '    mapping (address => uint256) public fullfilled;\n', '\n', '    /**\n', '     * any one can setup a price to sell his holds\n', '     * if set to 0, means not on sell\n', '     */\n', '    mapping (address => uint256) public sellPrice;\n', '    mapping (address => uint) public toSell;\n', '\n', '    uint256 public watermark;\n', '\n', '    event PAUSED();\n', '    event STARTED();\n', '\n', '    event SHARE_TRANSFER(address from, address to, uint amount);\n', '    event INCOME(uint256);\n', '    event PRICE_SET(address holder, uint shares, uint256 price, uint sell);\n', '    event WITHDRAWAL(address owner, uint256 amount);\n', '    event SELL_HOLDS(address from, address to, uint amount, uint256 price);\n', '    event SEND_HOLDS(address from, address to, uint amount);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notPaused() {\n', '        require(!pause);\n', '        _;\n', '    }\n', '    \n', '    function setState(bool _pause) onlyOwner public {\n', '        pause = _pause;\n', '        \n', '        if (_pause) {\n', '            emit PAUSED();\n', '        } else {\n', '            emit STARTED();\n', '        } \n', '    }\n', '\n', '    /**\n', '     * at start the owner has 100% share, which is 10,000 holds\n', '     */\n', '    function Share() public {        \n', '        owner = msg.sender;\n', '        holds[owner] = 10000;\n', '        pause = false;\n', '    }\n', '\n', '    /**\n', '     * when there&#39;s income, the water mark goes up\n', '     */\n', '    function onIncome() public payable {\n', '        if (msg.value > 0) {\n', '            watermark += (msg.value / 10000);\n', '            assert(watermark * 10000 > watermark);\n', '\n', '            emit INCOME(msg.value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * automatically split income\n', '     */\n', '    function() public payable {\n', '        onIncome();\n', '    }\n', '\n', '    function bonus() public view returns (uint256) {\n', '        return (watermark - fullfilled[msg.sender]) * holds[msg.sender];\n', '    }\n', '    \n', '    function setPrice(uint256 price, uint sell) public notPaused {\n', '        sellPrice[msg.sender] = price;\n', '        toSell[msg.sender] = sell;\n', '        emit PRICE_SET(msg.sender, holds[msg.sender], price, sell);\n', '    }\n', '\n', '    /**\n', '     * withdrawal the bonus\n', '     */\n', '    function withdrawal() public notPaused {\n', '        if (holds[msg.sender] == 0) {\n', '            //you don&#39;t have any, don&#39;t bother\n', '            return;\n', '        }\n', '        uint256 value = bonus();\n', '        fullfilled[msg.sender] = watermark;\n', '\n', '        msg.sender.transfer(value);\n', '\n', '        emit WITHDRAWAL(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * transfer holds from => to (only holds, no bouns)\n', '     * this will withdrawal the holder bonus of these holds\n', '     * and the to&#39;s fullfilled will go up, since total bonus unchanged, but holds goes more\n', '     */\n', '    function transferHolds(address from, address to, uint amount) internal {\n', '        require(holds[from] >= amount);\n', '        require(amount > 0);\n', '\n', '        uint256 fromBonus = (watermark - fullfilled[from]) * amount;\n', '        uint256 toBonus = (watermark - fullfilled[to]) * holds[to];\n', '        \n', '\n', '        holds[from] -= amount;\n', '        holds[to] += amount;\n', '        fullfilled[to] = watermark - toBonus / holds[to];\n', '\n', '        from.transfer(fromBonus);\n', '\n', '        emit SHARE_TRANSFER(from, to, amount);\n', '        emit WITHDRAWAL(from, fromBonus);\n', '    }\n', '\n', '    /**\n', '     * one can buy holds from anyone who set up an price,\n', '     * and u can buy @ price higher than he setup\n', '     */\n', '    function buyFrom(address from) public payable notPaused {\n', '        require(sellPrice[from] > 0);\n', '        uint256 amount = msg.value / sellPrice[from];\n', '\n', '        if (amount >= holds[from]) {\n', '            amount = holds[from];\n', '        }\n', '\n', '        if (amount >= toSell[from]) {\n', '            amount = toSell[from];\n', '        }\n', '\n', '        require(amount > 0);\n', '\n', '        toSell[from] -= amount;\n', '        transferHolds(from, msg.sender, amount);\n', '        from.transfer(msg.value);\n', '        \n', '        emit SELL_HOLDS(from, msg.sender, amount, sellPrice[from]);\n', '    }\n', '    \n', '    function transfer(address to, uint amount) public notPaused {\n', '        require(holds[msg.sender] >= amount);\n', '        transferHolds(msg.sender, to, amount);\n', '        \n', '        emit SEND_HOLDS(msg.sender, to, amount);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * this contract stands for the holds of WestIndia group\n', ' * all income will be split to holders according to their holds\n', ' * user can buy holds from shareholders at his will\n', ' */\n', 'contract Share {\n', '\n', '    bool public pause;\n', '    /**\n', '     * owner can pause the contract so that no one can withdrawal\n', "     * he can't do anything else\n", '     */\n', '    address public owner;\n', '    \n', '    /**\n', '     * the holds of every holder\n', '     * the total holds stick to 10000\n', '     */\n', '    mapping (address => uint) public holds;\n', '\n', '    /**\n', "     * since we don't record holders' address in a list\n", "     * and we don't want to loop holders list everytime when there is income\n", '     *\n', "     * we use a mechanism called 'watermark'\n", '     * \n', '     * the watermark indicates the value that brought into each holds from the begining\n', '     * it only goes up when new income send to the contract\n', '\n', '     * fullfilled indicate the amount that the holder has withdrawaled from his share\n', '     * it goes up when user withdrawal bonus\n', '     * and it goes up when user sell holds, goes down when user buy holds, since the total bonus of him stays the same.\n', '     */\n', '    mapping (address => uint256) public fullfilled;\n', '\n', '    /**\n', '     * any one can setup a price to sell his holds\n', '     * if set to 0, means not on sell\n', '     */\n', '    mapping (address => uint256) public sellPrice;\n', '    mapping (address => uint) public toSell;\n', '\n', '    uint256 public watermark;\n', '\n', '    event PAUSED();\n', '    event STARTED();\n', '\n', '    event SHARE_TRANSFER(address from, address to, uint amount);\n', '    event INCOME(uint256);\n', '    event PRICE_SET(address holder, uint shares, uint256 price, uint sell);\n', '    event WITHDRAWAL(address owner, uint256 amount);\n', '    event SELL_HOLDS(address from, address to, uint amount, uint256 price);\n', '    event SEND_HOLDS(address from, address to, uint amount);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier notPaused() {\n', '        require(!pause);\n', '        _;\n', '    }\n', '    \n', '    function setState(bool _pause) onlyOwner public {\n', '        pause = _pause;\n', '        \n', '        if (_pause) {\n', '            emit PAUSED();\n', '        } else {\n', '            emit STARTED();\n', '        } \n', '    }\n', '\n', '    /**\n', '     * at start the owner has 100% share, which is 10,000 holds\n', '     */\n', '    function Share() public {        \n', '        owner = msg.sender;\n', '        holds[owner] = 10000;\n', '        pause = false;\n', '    }\n', '\n', '    /**\n', "     * when there's income, the water mark goes up\n", '     */\n', '    function onIncome() public payable {\n', '        if (msg.value > 0) {\n', '            watermark += (msg.value / 10000);\n', '            assert(watermark * 10000 > watermark);\n', '\n', '            emit INCOME(msg.value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * automatically split income\n', '     */\n', '    function() public payable {\n', '        onIncome();\n', '    }\n', '\n', '    function bonus() public view returns (uint256) {\n', '        return (watermark - fullfilled[msg.sender]) * holds[msg.sender];\n', '    }\n', '    \n', '    function setPrice(uint256 price, uint sell) public notPaused {\n', '        sellPrice[msg.sender] = price;\n', '        toSell[msg.sender] = sell;\n', '        emit PRICE_SET(msg.sender, holds[msg.sender], price, sell);\n', '    }\n', '\n', '    /**\n', '     * withdrawal the bonus\n', '     */\n', '    function withdrawal() public notPaused {\n', '        if (holds[msg.sender] == 0) {\n', "            //you don't have any, don't bother\n", '            return;\n', '        }\n', '        uint256 value = bonus();\n', '        fullfilled[msg.sender] = watermark;\n', '\n', '        msg.sender.transfer(value);\n', '\n', '        emit WITHDRAWAL(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * transfer holds from => to (only holds, no bouns)\n', '     * this will withdrawal the holder bonus of these holds\n', "     * and the to's fullfilled will go up, since total bonus unchanged, but holds goes more\n", '     */\n', '    function transferHolds(address from, address to, uint amount) internal {\n', '        require(holds[from] >= amount);\n', '        require(amount > 0);\n', '\n', '        uint256 fromBonus = (watermark - fullfilled[from]) * amount;\n', '        uint256 toBonus = (watermark - fullfilled[to]) * holds[to];\n', '        \n', '\n', '        holds[from] -= amount;\n', '        holds[to] += amount;\n', '        fullfilled[to] = watermark - toBonus / holds[to];\n', '\n', '        from.transfer(fromBonus);\n', '\n', '        emit SHARE_TRANSFER(from, to, amount);\n', '        emit WITHDRAWAL(from, fromBonus);\n', '    }\n', '\n', '    /**\n', '     * one can buy holds from anyone who set up an price,\n', '     * and u can buy @ price higher than he setup\n', '     */\n', '    function buyFrom(address from) public payable notPaused {\n', '        require(sellPrice[from] > 0);\n', '        uint256 amount = msg.value / sellPrice[from];\n', '\n', '        if (amount >= holds[from]) {\n', '            amount = holds[from];\n', '        }\n', '\n', '        if (amount >= toSell[from]) {\n', '            amount = toSell[from];\n', '        }\n', '\n', '        require(amount > 0);\n', '\n', '        toSell[from] -= amount;\n', '        transferHolds(from, msg.sender, amount);\n', '        from.transfer(msg.value);\n', '        \n', '        emit SELL_HOLDS(from, msg.sender, amount, sellPrice[from]);\n', '    }\n', '    \n', '    function transfer(address to, uint amount) public notPaused {\n', '        require(holds[msg.sender] >= amount);\n', '        transferHolds(msg.sender, to, amount);\n', '        \n', '        emit SEND_HOLDS(msg.sender, to, amount);\n', '    }\n', '}']
