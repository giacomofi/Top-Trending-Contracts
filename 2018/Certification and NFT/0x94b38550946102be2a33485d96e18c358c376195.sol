['// Human token smart contract.\n', '// Developed by Phenom.Team <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b6dfd8d0d9f6c6ded3d8d9db98c2d3d7db">[email&#160;protected]</a>>\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' *   @title SafeMath\n', ' *   @dev Math operations with safety checks that throw on error\n', ' */\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal constant returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal constant returns(uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal constant returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal constant returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' *   @title ERC20\n', ' *   @dev Standart ERC20 token interface\n', ' */\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '}\n', '\n', '\n', '/**\n', ' *   @title HumanToken\n', ' *   @dev Human token smart-contract\n', ' */\n', 'contract HumanToken is ERC20 {\n', '    using SafeMath for uint;\n', '    string public name = "Human";\n', '    string public symbol = "Human";\n', '    uint public decimals = 18;\n', '    uint public voteCost = 10**18;\n', '\n', '    // Owner address\n', '    address public owner;\n', '    address public eventManager;\n', '\n', '    mapping (address => bool) isActiveEvent;\n', '            \n', '    //events        \n', '    event EventAdded(address _event);\n', '    event Contribute(address _event, address _contributor, uint _amount);\n', '    event Vote(address _event, address _contributor, bool _proposal);\n', '    \n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the event manager only\n', '    modifier onlyEventManager {\n', '        require(msg.sender == eventManager);\n', '        _;\n', '    }\n', '\n', '   // Allows contributing and voting only to human events \n', '    modifier onlyActive(address _event) {\n', '        require(isActiveEvent[_event]);\n', '        _;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets owner address\n', '    *   @param _owner        owner address\n', '    */\n', '    function HumanToken(address _owner, address _eventManager) public {\n', '       owner = _owner;\n', '       eventManager = _eventManager;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Function to add a new event from TheHuman team\n', '    *   @param _event       a new event address\n', '    */   \n', '    function  addEvent(address _event) external onlyEventManager {\n', '        require (!isActiveEvent[_event]);\n', '        isActiveEvent[_event] = true;\n', '        EventAdded(_event);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to change vote cost, by default vote cost equals 1 Human token\n', '    *   @param _voteCost     a new vote cost\n', '    */\n', '    function setVoteCost(uint _voteCost) external onlyEventManager {\n', '        voteCost = _voteCost;\n', '    }\n', '    \n', '   /**\n', '    *   @dev Function to donate for event\n', '    *   @param _event     address of event\n', '    *   @param _amount    donation amount    \n', '    */\n', '    function donate(address _event, uint _amount) public onlyActive(_event) {\n', '        require (transfer(_event, _amount));\n', '        require (HumanEvent(_event).contribute(msg.sender, _amount));\n', '        Contribute(_event, msg.sender, _amount);\n', '        \n', '    }\n', '\n', '   /**\n', '    *   @dev Function voting for the success of the event\n', '    *   @param _event     address of event\n', '    *   @param _proposal  true - event completed successfully, false - otherwise\n', '    */\n', '    function vote(address _event, bool _proposal) public onlyActive(_event) {\n', '        require(transfer(_event, voteCost));\n', '        require(HumanEvent(_event).vote(msg.sender, _proposal));\n', '        Vote(_event, msg.sender, _proposal);\n', '    }\n', '    \n', '    \n', '\n', '\n', '   /**\n', '    *   @dev Function to mint tokens\n', '    *   @param _holder       beneficiary address the tokens will be issued to\n', '    *   @param _value        number of tokens to issue\n', '    */\n', '    function mintTokens(address _holder, uint _value) external onlyOwner {\n', '       require(_value > 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '  \n', '   /**\n', '    *   @dev Get balance of tokens holder\n', '    *   @param _holder        holder&#39;s address\n', '    *   @return               balance of investor\n', '    */\n', '    function balanceOf(address _holder) constant returns (uint) {\n', '         return balances[_holder];\n', '    }\n', '\n', '   /**\n', '    *   @dev Send coins\n', '    *   throws on any error rather then return a false flag to minimize\n', '    *   user errors\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev An account/contract attempts to get the coins\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   @param _from         source address\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Allows another account/contract to spend some tokens on its behalf\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   also, to minimize the risk of the approve/transferFrom attack vector\n', '    *   approve has to be called twice in 2 separate transactions - once to\n', '    *   change the allowance to 0 and secondly to change it to the new allowance\n', '    *   value\n', '    *\n', '    *   @param _spender      approved address\n', '    *   @param _amount       allowance amount\n', '    *\n', '    *   @return true if the approval was successful\n', '    */\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    *   @param _owner        the address which owns the funds\n', '    *   @param _spender      the address which will spend the funds\n', '    *\n', '    *   @return              the amount of tokens still avaible for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner \n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', ' contract HumanEvent {\n', '    using SafeMath for uint;    \n', '    uint public totalRaised;\n', '    uint public softCap;\n', '    uint public positiveVotes;\n', '    uint public negativeVotes;\n', '\n', '    address public alternative;\n', '    address public owner;\n', '    HumanToken public human;\n', '\n', '    mapping (address => uint) public contributions;\n', '    mapping (address => bool) public voted;\n', '    mapping (address => bool) public claimed;\n', '    \n', '\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyHuman {\n', '        require(msg.sender == address(human));\n', '        _;\n', '    }\n', '\n', '\n', '    // Possible Event statuses\n', '    enum StatusEvent {\n', '        Created,\n', '        Fundraising,\n', '        Failed,\n', '        Evaluating,\n', '        Voting,\n', '        Finished\n', '    }\n', '    StatusEvent public statusEvent = StatusEvent.Created;\n', '\n', '    \n', '    function HumanEvent(\n', '        address _owner, \n', '        uint _softCap,\n', '        address _alternative,\n', '        address _human\n', '    ) public {\n', '        owner = _owner;\n', '        softCap = _softCap;\n', '        alternative = _alternative;\n', '        human = HumanToken(_human);\n', '    }\n', '\n', '    function startFundraising() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Created);\n', '        statusEvent = StatusEvent.Fundraising;\n', '        \n', '    }\n', '    \n', '\n', '    function startEvaluating() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Fundraising);\n', '        \n', '        if (totalRaised >= softCap) {\n', '            statusEvent = StatusEvent.Evaluating;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '\n', '    function startVoting() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Evaluating);\n', '        statusEvent = StatusEvent.Voting;\n', '    }\n', '\n', '    function finish() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Voting);\n', '        if (positiveVotes >= negativeVotes) {\n', '            statusEvent = StatusEvent.Finished;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '    \n', '    \n', '    function claim() public {\n', '        require(!claimed[msg.sender]);        \n', '        claimed[msg.sender] = true;\n', '        uint contribution;\n', '\n', '        if (statusEvent == StatusEvent.Failed) {\n', '            contribution = contribution.add(contributions[msg.sender]);\n', '            contributions[msg.sender] = 0;\n', '        }\n', '\n', '        if(voted[msg.sender] && statusEvent != StatusEvent.Voting) {\n', '            uint _voteCost = human.voteCost();\n', '            contribution = contribution.add(_voteCost);\n', '        }\n', '        require(contribution > 0);\n', '        require(human.transfer(msg.sender, contribution));\n', '    }\n', '\n', '    \n', '    function vote(address _voter, bool _proposal) external onlyHuman returns (bool) {\n', '        require(!voted[_voter] && statusEvent == StatusEvent.Voting);\n', '        voted[_voter] = true;\n', '        \n', '        if (_proposal) {\n', '            positiveVotes++;\n', '        } else {\n', '            negativeVotes++;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function contribute(address _contributor, uint _amount) external onlyHuman returns(bool) {\n', '        require (statusEvent == StatusEvent.Fundraising);\n', '        contributions[_contributor] =  contributions[_contributor].add(_amount);\n', '        totalRaised = totalRaised.add(_amount);\n', '        return true;\n', '    }\n', '    \n', '    function  withdraw() external onlyOwner {\n', '        require (statusEvent == StatusEvent.Finished);\n', '        require (human.transfer(alternative, totalRaised));\n', '    }\n', '\n', '}']
['// Human token smart contract.\n', '// Developed by Phenom.Team <info@phenom.team>\n', 'pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' *   @title SafeMath\n', ' *   @dev Math operations with safety checks that throw on error\n', ' */\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal constant returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal constant returns(uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal constant returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal constant returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' *   @title ERC20\n', ' *   @dev Standart ERC20 token interface\n', ' */\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '}\n', '\n', '\n', '/**\n', ' *   @title HumanToken\n', ' *   @dev Human token smart-contract\n', ' */\n', 'contract HumanToken is ERC20 {\n', '    using SafeMath for uint;\n', '    string public name = "Human";\n', '    string public symbol = "Human";\n', '    uint public decimals = 18;\n', '    uint public voteCost = 10**18;\n', '\n', '    // Owner address\n', '    address public owner;\n', '    address public eventManager;\n', '\n', '    mapping (address => bool) isActiveEvent;\n', '            \n', '    //events        \n', '    event EventAdded(address _event);\n', '    event Contribute(address _event, address _contributor, uint _amount);\n', '    event Vote(address _event, address _contributor, bool _proposal);\n', '    \n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the event manager only\n', '    modifier onlyEventManager {\n', '        require(msg.sender == eventManager);\n', '        _;\n', '    }\n', '\n', '   // Allows contributing and voting only to human events \n', '    modifier onlyActive(address _event) {\n', '        require(isActiveEvent[_event]);\n', '        _;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Contract constructor function sets owner address\n', '    *   @param _owner        owner address\n', '    */\n', '    function HumanToken(address _owner, address _eventManager) public {\n', '       owner = _owner;\n', '       eventManager = _eventManager;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Function to add a new event from TheHuman team\n', '    *   @param _event       a new event address\n', '    */   \n', '    function  addEvent(address _event) external onlyEventManager {\n', '        require (!isActiveEvent[_event]);\n', '        isActiveEvent[_event] = true;\n', '        EventAdded(_event);\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to change vote cost, by default vote cost equals 1 Human token\n', '    *   @param _voteCost     a new vote cost\n', '    */\n', '    function setVoteCost(uint _voteCost) external onlyEventManager {\n', '        voteCost = _voteCost;\n', '    }\n', '    \n', '   /**\n', '    *   @dev Function to donate for event\n', '    *   @param _event     address of event\n', '    *   @param _amount    donation amount    \n', '    */\n', '    function donate(address _event, uint _amount) public onlyActive(_event) {\n', '        require (transfer(_event, _amount));\n', '        require (HumanEvent(_event).contribute(msg.sender, _amount));\n', '        Contribute(_event, msg.sender, _amount);\n', '        \n', '    }\n', '\n', '   /**\n', '    *   @dev Function voting for the success of the event\n', '    *   @param _event     address of event\n', '    *   @param _proposal  true - event completed successfully, false - otherwise\n', '    */\n', '    function vote(address _event, bool _proposal) public onlyActive(_event) {\n', '        require(transfer(_event, voteCost));\n', '        require(HumanEvent(_event).vote(msg.sender, _proposal));\n', '        Vote(_event, msg.sender, _proposal);\n', '    }\n', '    \n', '    \n', '\n', '\n', '   /**\n', '    *   @dev Function to mint tokens\n', '    *   @param _holder       beneficiary address the tokens will be issued to\n', '    *   @param _value        number of tokens to issue\n', '    */\n', '    function mintTokens(address _holder, uint _value) external onlyOwner {\n', '       require(_value > 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '  \n', '   /**\n', '    *   @dev Get balance of tokens holder\n', "    *   @param _holder        holder's address\n", '    *   @return               balance of investor\n', '    */\n', '    function balanceOf(address _holder) constant returns (uint) {\n', '         return balances[_holder];\n', '    }\n', '\n', '   /**\n', '    *   @dev Send coins\n', '    *   throws on any error rather then return a false flag to minimize\n', '    *   user errors\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev An account/contract attempts to get the coins\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   @param _from         source address\n', '    *   @param _to           target address\n', '    *   @param _amount       transfer amount\n', '    *\n', '    *   @return true if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '   /**\n', '    *   @dev Allows another account/contract to spend some tokens on its behalf\n', '    *   throws on any error rather then return a false flag to minimize user errors\n', '    *\n', '    *   also, to minimize the risk of the approve/transferFrom attack vector\n', '    *   approve has to be called twice in 2 separate transactions - once to\n', '    *   change the allowance to 0 and secondly to change it to the new allowance\n', '    *   value\n', '    *\n', '    *   @param _spender      approved address\n', '    *   @param _amount       allowance amount\n', '    *\n', '    *   @return true if the approval was successful\n', '    */\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '   /**\n', '    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    *\n', '    *   @param _owner        the address which owns the funds\n', '    *   @param _spender      the address which will spend the funds\n', '    *\n', '    *   @return              the amount of tokens still avaible for the spender\n', '    */\n', '    function allowance(address _owner, address _spender) constant returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /** \n', '    *   @dev Allows owner to transfer out any accidentally sent ERC20 tokens\n', '    *   @param tokenAddress  token address\n', '    *   @param tokens        transfer amount\n', '    */\n', '    function transferAnyTokens(address tokenAddress, uint tokens) \n', '        public\n', '        onlyOwner \n', '        returns (bool success) {\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}\n', '\n', ' contract HumanEvent {\n', '    using SafeMath for uint;    \n', '    uint public totalRaised;\n', '    uint public softCap;\n', '    uint public positiveVotes;\n', '    uint public negativeVotes;\n', '\n', '    address public alternative;\n', '    address public owner;\n', '    HumanToken public human;\n', '\n', '    mapping (address => uint) public contributions;\n', '    mapping (address => bool) public voted;\n', '    mapping (address => bool) public claimed;\n', '    \n', '\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Allows execution by the contract owner only\n', '    modifier onlyHuman {\n', '        require(msg.sender == address(human));\n', '        _;\n', '    }\n', '\n', '\n', '    // Possible Event statuses\n', '    enum StatusEvent {\n', '        Created,\n', '        Fundraising,\n', '        Failed,\n', '        Evaluating,\n', '        Voting,\n', '        Finished\n', '    }\n', '    StatusEvent public statusEvent = StatusEvent.Created;\n', '\n', '    \n', '    function HumanEvent(\n', '        address _owner, \n', '        uint _softCap,\n', '        address _alternative,\n', '        address _human\n', '    ) public {\n', '        owner = _owner;\n', '        softCap = _softCap;\n', '        alternative = _alternative;\n', '        human = HumanToken(_human);\n', '    }\n', '\n', '    function startFundraising() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Created);\n', '        statusEvent = StatusEvent.Fundraising;\n', '        \n', '    }\n', '    \n', '\n', '    function startEvaluating() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Fundraising);\n', '        \n', '        if (totalRaised >= softCap) {\n', '            statusEvent = StatusEvent.Evaluating;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '\n', '    function startVoting() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Evaluating);\n', '        statusEvent = StatusEvent.Voting;\n', '    }\n', '\n', '    function finish() public onlyOwner {\n', '        require(statusEvent == StatusEvent.Voting);\n', '        if (positiveVotes >= negativeVotes) {\n', '            statusEvent = StatusEvent.Finished;\n', '        } else {\n', '            statusEvent = StatusEvent.Failed;\n', '        }\n', '    }\n', '    \n', '    \n', '    function claim() public {\n', '        require(!claimed[msg.sender]);        \n', '        claimed[msg.sender] = true;\n', '        uint contribution;\n', '\n', '        if (statusEvent == StatusEvent.Failed) {\n', '            contribution = contribution.add(contributions[msg.sender]);\n', '            contributions[msg.sender] = 0;\n', '        }\n', '\n', '        if(voted[msg.sender] && statusEvent != StatusEvent.Voting) {\n', '            uint _voteCost = human.voteCost();\n', '            contribution = contribution.add(_voteCost);\n', '        }\n', '        require(contribution > 0);\n', '        require(human.transfer(msg.sender, contribution));\n', '    }\n', '\n', '    \n', '    function vote(address _voter, bool _proposal) external onlyHuman returns (bool) {\n', '        require(!voted[_voter] && statusEvent == StatusEvent.Voting);\n', '        voted[_voter] = true;\n', '        \n', '        if (_proposal) {\n', '            positiveVotes++;\n', '        } else {\n', '            negativeVotes++;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    function contribute(address _contributor, uint _amount) external onlyHuman returns(bool) {\n', '        require (statusEvent == StatusEvent.Fundraising);\n', '        contributions[_contributor] =  contributions[_contributor].add(_amount);\n', '        totalRaised = totalRaised.add(_amount);\n', '        return true;\n', '    }\n', '    \n', '    function  withdraw() external onlyOwner {\n', '        require (statusEvent == StatusEvent.Finished);\n', '        require (human.transfer(alternative, totalRaised));\n', '    }\n', '\n', '}']
