['//solium-disable linebreak-style\n', 'pragma solidity ^0.4.24;\n', '\n', 'library ExtendedMath {\n', '    function limitLessThan(uint a, uint b) internal pure returns(uint c) {\n', '        if (a > b) return b;\n', '        return a;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', '        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns(uint256);\n', '\n', '    function balanceOf(address _who) public view returns(uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address _owner, address _spender) public view returns(uint256);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath\n', '    for uint256;\n', '\n', '    mapping(address => uint256) internal balances;\n', '\n', '    uint256 internal totalSupply_;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns(uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns(bool) {\n', '        require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) public view returns(uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns(bool) {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', '     * race condition is to first reduce the spender&#39;s allowance to 0 and set the desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        allowed[msg.sender][_spender] = (\n', '            allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'interface IcaelumVoting {\n', '    function getTokenProposalDetails() external view returns(address, uint, uint, uint);\n', '    function getExpiry() external view returns (uint);\n', '    function getContractType () external view returns (uint);\n', '}\n', '\n', 'contract abstractCaelum {\n', '    function isMasternodeOwner(address _candidate) public view returns(bool);\n', '    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\n', '    function addMasternode(address _candidate) internal returns(uint);\n', '    function deleteMasternode(uint entityAddress) internal returns(bool success);\n', '    function getLastPerUser(address _candidate) public view returns (uint);\n', '    function getMiningReward() public view returns(uint);\n', '}\n', '\n', 'contract NewTokenProposal is IcaelumVoting {\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '\n', '    VOTE_TYPE public contractType = VOTE_TYPE.TOKEN;\n', '    address contractAddress;\n', '    uint requiredAmount;\n', '    uint validUntil;\n', '    uint votingDurationInDays;\n', '\n', '    /**\n', '     * @dev Create a new vote proposal for an ERC20 token.\n', '     * @param _contract ERC20 contract\n', '     * @param _amount How many tokens are required as collateral\n', '     * @param _valid How long do we accept these tokens on the contract (UNIX timestamp)\n', '     * @param _voteDuration How many days is this vote available\n', '     */\n', '    constructor(address _contract, uint _amount, uint _valid, uint _voteDuration) public {\n', '        require(_voteDuration >= 14 && _voteDuration <= 50, "Proposed voting duration does not meet requirements");\n', '\n', '        contractAddress = _contract;\n', '        requiredAmount = _amount;\n', '        validUntil = _valid;\n', '        votingDurationInDays = _voteDuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about this proposal\n', '     */\n', '    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\n', '        return (contractAddress, requiredAmount, validUntil, uint(contractType));\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the expiry date of contract\n', '     * @return uint Days valid\n', '     */\n', '    function getExpiry() external view returns (uint) {\n', '        return votingDurationInDays;\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the type of contract\n', '     * @return uint Enum value {TOKEN, TEAM}\n', '     */\n', '    function getContractType () external view returns (uint){\n', '        return uint(contractType);\n', '    }\n', '}\n', '\n', 'contract NewMemberProposal is IcaelumVoting {\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '    VOTE_TYPE public contractType = VOTE_TYPE.TEAM;\n', '\n', '    address memberAddress;\n', '    uint totalMasternodes;\n', '    uint votingDurationInDays;\n', '\n', '    /**\n', '     * @dev Create a new vote proposal for a team member.\n', '     * @param _contract Future team member&#39;s address\n', '     * @param _total How many masternodes do we want to give\n', '     * @param _voteDuration How many days is this vote available\n', '     */\n', '    constructor(address _contract, uint _total, uint _voteDuration) public {\n', '        require(_voteDuration >= 14 && _voteDuration <= 50, "Proposed voting duration does not meet requirements");\n', '        memberAddress = _contract;\n', '        totalMasternodes = _total;\n', '        votingDurationInDays = _voteDuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about this proposal\n', '     */\n', '    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\n', '        return (memberAddress, totalMasternodes, 0, uint(contractType));\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the expiry date of contract\n', '     * @return uint Days valid\n', '     */\n', '    function getExpiry() external view returns (uint) {\n', '        return votingDurationInDays;\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the type of contract\n', '     * @return uint Enum value {TOKEN, TEAM}\n', '     */\n', '    function getContractType () external view returns (uint){\n', '        return uint(contractType);\n', '    }\n', '}\n', '\n', 'contract CaelumVotings is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '\n', '    struct Proposals {\n', '        address tokenContract;\n', '        uint totalVotes;\n', '        uint proposedOn;\n', '        uint acceptedOn;\n', '        VOTE_TYPE proposalType;\n', '    }\n', '\n', '    struct Voters {\n', '        bool isVoter;\n', '        address owner;\n', '        uint[] votedFor;\n', '    }\n', '\n', '    uint MAJORITY_PERCENTAGE_NEEDED = 60;\n', '    uint MINIMUM_VOTERS_NEEDED = 10;\n', '    bool public proposalPending;\n', '\n', '    mapping(uint => Proposals) public proposalList;\n', '    mapping (address => Voters) public voterMap;\n', '    mapping(uint => address) public voterProposals;\n', '    uint public proposalCounter;\n', '    uint public votersCount;\n', '    uint public votersCountTeam;\n', '\n', '    /**\n', '     * @notice Define abstract functions for later user\n', '     */\n', '    function isMasternodeOwner(address _candidate) public view returns(bool);\n', '    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\n', '    function addMasternode(address _candidate) internal returns(uint);\n', '    function updateMasternodeAsTeamMember(address _member) internal returns (bool);\n', '    function isTeamMember (address _candidate) public view returns (bool);\n', '    \n', '    event NewProposal(uint ProposalID);\n', '    event ProposalAccepted(uint ProposalID);\n', '\n', '    /**\n', '     * @dev Create a new proposal.\n', '     * @param _contract Proposal contract address\n', '     * @return uint ProposalID\n', '     */\n', '    function pushProposal(address _contract) onlyOwner public returns (uint) {\n', '        if(proposalCounter != 0)\n', '        require (pastProposalTimeRules (), "You need to wait 90 days before submitting a new proposal.");\n', '        require (!proposalPending, "Another proposal is pending.");\n', '\n', '        uint _contractType = IcaelumVoting(_contract).getContractType();\n', '        proposalList[proposalCounter] = Proposals(_contract, 0, now, 0, VOTE_TYPE(_contractType));\n', '\n', '        emit NewProposal(proposalCounter);\n', '        \n', '        proposalCounter++;\n', '        proposalPending = true;\n', '\n', '        return proposalCounter.sub(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that handles the proposal after it got accepted.\n', '     * This function determines if the proposal is a token or team member proposal and executes the corresponding functions.\n', '     * @return uint Returns the proposal ID.\n', '     */\n', '    function handleLastProposal () internal returns (uint) {\n', '        uint _ID = proposalCounter.sub(1);\n', '\n', '        proposalList[_ID].acceptedOn = now;\n', '        proposalPending = false;\n', '\n', '        address _address;\n', '        uint _required;\n', '        uint _valid;\n', '        uint _type;\n', '        (_address, _required, _valid, _type) = getTokenProposalDetails(_ID);\n', '\n', '        if(_type == uint(VOTE_TYPE.TOKEN)) {\n', '            addToWhitelist(_address,_required,_valid);\n', '        }\n', '\n', '        if(_type == uint(VOTE_TYPE.TEAM)) {\n', '            if(_required != 0) {\n', '                for (uint i = 0; i < _required; i++) {\n', '                    addMasternode(_address);\n', '                }\n', '            } else {\n', '                addMasternode(_address);\n', '            }\n', '            updateMasternodeAsTeamMember(_address);\n', '        }\n', '        \n', '        emit ProposalAccepted(_ID);\n', '        \n', '        return _ID;\n', '    }\n', '\n', '    /**\n', '     * @dev Rejects the last proposal after the allowed voting time has expired and it&#39;s not accepted.\n', '     */\n', '    function discardRejectedProposal() onlyOwner public returns (bool) {\n', '        require(proposalPending);\n', '        require (LastProposalCanDiscard());\n', '        proposalPending = false;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the last proposal allowed voting time has expired and it&#39;s not accepted.\n', '     * @return bool\n', '     */\n', '    function LastProposalCanDiscard () public view returns (bool) {\n', '        \n', '        uint daysBeforeDiscard = IcaelumVoting(proposalList[proposalCounter - 1].tokenContract).getExpiry();\n', '        uint entryDate = proposalList[proposalCounter - 1].proposedOn;\n', '        uint expiryDate = entryDate + (daysBeforeDiscard * 1 days);\n', '\n', '        if (now >= expiryDate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about a proposal\n', '     */\n', '    function getTokenProposalDetails(uint proposalID) public view returns(address, uint, uint, uint) {\n', '        return IcaelumVoting(proposalList[proposalID].tokenContract).getTokenProposalDetails();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if our 90 day cooldown has passed\n', '     * @return bool\n', '     */\n', '    function pastProposalTimeRules() public view returns (bool) {\n', '        uint lastProposal = proposalList[proposalCounter - 1].proposedOn;\n', '        if (now >= lastProposal + 90 days)\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allow any masternode user to become a voter.\n', '     */\n', '    function becomeVoter() public  {\n', '        require (isMasternodeOwner(msg.sender), "User has no masternodes");\n', '        require (!voterMap[msg.sender].isVoter, "User Already voted for this proposal");\n', '\n', '        voterMap[msg.sender].owner = msg.sender;\n', '        voterMap[msg.sender].isVoter = true;\n', '        votersCount = votersCount + 1;\n', '\n', '        if (isTeamMember(msg.sender))\n', '        votersCountTeam = votersCountTeam + 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow voters to submit their vote on a proposal. Voters can only cast 1 vote per proposal.\n', '     * If the proposed vote is about adding Team members, only Team members are able to vote.\n', '     * A proposal can only be published if the total of votes is greater then MINIMUM_VOTERS_NEEDED.\n', '     * @param proposalID proposalID\n', '     */\n', '    function voteProposal(uint proposalID) public returns (bool success) {\n', '        require(voterMap[msg.sender].isVoter, "Sender not listed as voter");\n', '        require(proposalID >= 0, "No proposal was selected.");\n', '        require(proposalID <= proposalCounter, "Proposal out of limits.");\n', '        require(voterProposals[proposalID] != msg.sender, "Already voted.");\n', '\n', '\n', '        if(proposalList[proposalID].proposalType == VOTE_TYPE.TEAM) {\n', '            require (isTeamMember(msg.sender), "Restricted for team members");\n', '            voterProposals[proposalID] = msg.sender;\n', '            proposalList[proposalID].totalVotes++;\n', '\n', '            if(reachedMajorityForTeam(proposalID)) {\n', '                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\n', '                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\n', '                handleLastProposal();\n', '                return true;\n', '            }\n', '        } else {\n', '            require(votersCount >= MINIMUM_VOTERS_NEEDED, "Not enough voters in existence to push a proposal");\n', '            voterProposals[proposalID] = msg.sender;\n', '            proposalList[proposalID].totalVotes++;\n', '\n', '            if(reachedMajority(proposalID)) {\n', '                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\n', '                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\n', '                handleLastProposal();\n', '                return true;\n', '            }\n', '        }\n', '\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajority (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majority())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majority () internal view returns (uint) {\n', '        uint a = (votersCount * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote for a team member\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajorityForTeam (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majorityForTeam())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majorityForTeam () internal view returns (uint) {\n', '        uint a = (votersCountTeam * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumFundraise is Ownable, BasicToken, abstractCaelum {\n', '\n', '    /**\n', '     * In no way is Caelum intended to raise funds. We leave this code to demonstrate the potential and functionality.\n', '     * Should you decide to buy a masternode instead of mining, you can by using this function. Feel free to consider this a tipping jar for our dev team.\n', '     * We strongly advice to use the `buyMasternode`function, but simply sending Ether to the contract should work as well.\n', '     */\n', '\n', '    uint AMOUNT_FOR_MASTERNODE = 50 ether;\n', '    uint SPOTS_RESERVED = 10;\n', '    uint COUNTER;\n', '    bool fundraiseClosed = false;\n', '\n', '    /**\n', '     * @dev Not recommended way to accept Ether. Can be safely used if no storage operations are called\n', '     * The contract may revert all the gas because of the gas limitions on the fallback operator.\n', '     * We leave it in as template for other projects, however, for Caelum the function deposit should be adviced.\n', '     */\n', '    function() payable public {\n', '        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\n', '        receivedFunds();\n', '    }\n', '\n', '    /** @dev This is the recommended way for users to deposit Ether in return of a masternode.\n', '     * Users should be encouraged to use this approach as there is not gas risk involved.\n', '     */\n', '    function buyMasternode () payable public {\n', '        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\n', '        receivedFunds();\n', '    }\n', '\n', '    /**\n', '     * @dev Forward funds to owner before making any action. owner.transfer will revert if fail.\n', '     */\n', '    function receivedFunds() internal {\n', '        require(!fundraiseClosed);\n', '        require (COUNTER <= SPOTS_RESERVED);\n', '        owner.transfer(msg.value);\n', '        addMasternode(msg.sender);\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumAcceptERC20 is Ownable, CaelumVotings, abstractCaelum { \n', '    using SafeMath for uint;\n', '\n', '    address[] public tokensList;\n', '    bool setOwnContract = true;\n', '\n', '    struct _whitelistTokens {\n', '        address tokenAddress;\n', '        bool active;\n', '        uint requiredAmount;\n', '        uint validUntil;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping(address => mapping(address => uint)) public tokens;\n', '    mapping(address => _whitelistTokens) acceptedTokens;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    /**\n', '     * @dev Return the base rewards. This should be overrided by the miner contract.\n', '     * Return a base value for standalone usage ONLY.\n', '     */\n', '    function getMiningReward() public view returns(uint) {\n', '        return 50 * 1e8;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Allow the dev to set it&#39;s own token as accepted payment.\n', '     * @dev Can be hardcoded in the constructor. Given the contract size, we decided to separate it.\n', '     * @return bool\n', '     */\n', '    function addOwnToken() onlyOwner public returns (bool) {\n', '        require(setOwnContract);\n', '        addToWhitelist(this, 5000 * 1e8, 36500);\n', '        setOwnContract = false;\n', '        return true;\n', '    }\n', '\n', '    // TODO: Set visibility\n', '    /**\n', '     * @notice Add a new token as accepted payment method.\n', '     * @param _token Token contract address.\n', '     * @param _amount Required amount of this Token as collateral\n', '     * @param daysAllowed How many days will we accept this token?\n', '     */\n', '    function addToWhitelist(address _token, uint _amount, uint daysAllowed) internal {\n', '        _whitelistTokens storage newToken = acceptedTokens[_token];\n', '        newToken.tokenAddress = _token;\n', '        newToken.requiredAmount = _amount;\n', '        newToken.timestamp = now;\n', '        newToken.validUntil = now + (daysAllowed * 1 days);\n', '        newToken.active = true;\n', '\n', '        tokensList.push(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if we accept this token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isAcceptedToken(address _ad) internal view returns(bool) {\n', '        return acceptedTokens[_ad].active;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine the requiredAmount for a specific token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function getAcceptedTokenAmount(address _ad) internal view returns(uint) {\n', '        return acceptedTokens[_ad].requiredAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if the token is still accepted timewise.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isValid(address _ad) internal view returns(bool) {\n', '        uint endTime = acceptedTokens[_ad].validUntil;\n', '        if (block.timestamp < endTime) return true;\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns an array of all accepted token. You can get more details by calling getTokenDetails function with this address.\n', '     * @return array Address\n', '     */\n', '    function listAcceptedTokens() public view returns(address[]) {\n', '        return tokensList;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns a full list of the token details\n', '     * @param token Token contract address\n', '     */\n', '    function getTokenDetails(address token) public view returns(address ad,uint required, bool active, uint valid) {\n', '        return (acceptedTokens[token].tokenAddress, acceptedTokens[token].requiredAmount,acceptedTokens[token].active, acceptedTokens[token].validUntil);\n', '    }\n', '\n', '    /**\n', '     * @notice Public function that allows any user to deposit accepted tokens as collateral to become a masternode.\n', '     * @param token Token contract address\n', '     * @param amount Amount to deposit\n', '     */\n', '    function depositCollateral(address token, uint amount) public {\n', '        require(isAcceptedToken(token), "ERC20 not authorised");  // Should be a token from our list\n', '        require(amount == getAcceptedTokenAmount(token));         // The amount needs to match our set amount\n', '        require(isValid(token));                                  // It should be called within the setup timeframe\n', '\n', '        tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '\n', '        require(StandardToken(token).transferFrom(msg.sender, this, amount), "error with token");\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        addMasternode(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Public function that allows any user to withdraw deposited tokens and stop as masternode\n', '     * @param token Token contract address\n', '     * @param amount Amount to withdraw\n', '     */\n', '    function withdrawCollateral(address token, uint amount) public {\n', '        require(token != 0); // token should be an actual address\n', '        require(isAcceptedToken(token), "ERC20 not authorised"); // Should be a token from our list\n', '        require(isMasternodeOwner(msg.sender)); // The sender must be a masternode prior to withdraw\n', '        require(tokens[token][msg.sender] == amount); // The amount must be exactly whatever is deposited\n', '\n', '        uint amountToWithdraw = tokens[token][msg.sender];\n', '        tokens[token][msg.sender] = 0;\n', '\n', '        deleteMasternode(getLastPerUser(msg.sender));\n', '\n', '        if (!StandardToken(token).transfer(msg.sender, amountToWithdraw)) revert();\n', '        emit Withdraw(token, msg.sender, amountToWithdraw, amountToWithdraw);\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumMasternode is CaelumFundraise, CaelumAcceptERC20{\n', '    using SafeMath for uint;\n', '\n', '    bool onTestnet = false;\n', '    bool genesisAdded = false;\n', '\n', '    uint  masternodeRound;\n', '    uint  masternodeCandidate;\n', '    uint  masternodeCounter;\n', '    uint  masternodeEpoch;\n', '    uint  miningEpoch;\n', '\n', '    uint rewardsProofOfWork;\n', '    uint rewardsMasternode;\n', '    uint rewardsGlobal = 50 * 1e8;\n', '\n', '    uint MINING_PHASE_DURATION_BLOCKS = 4500;\n', '\n', '    struct MasterNode {\n', '        address accountOwner;\n', '        bool isActive;\n', '        bool isTeamMember;\n', '        uint storedIndex;\n', '        uint startingRound;\n', '        uint[] indexcounter;\n', '    }\n', '\n', '    uint[] userArray;\n', '    address[] userAddressArray;\n', '\n', '    mapping(uint => MasterNode) userByIndex; // UINT masterMapping\n', '    mapping(address => MasterNode) userByAddress; //masterMapping\n', '    mapping(address => uint) userAddressIndex;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    event NewMasternode(address candidateAddress, uint timeStamp);\n', '    event RemovedMasternode(address candidateAddress, uint timeStamp);\n', '\n', '    /**\n', '     * @dev Add the genesis accounts\n', '     */\n', '    function addGenesis(address _genesis, bool _team) onlyOwner public {\n', '        require(!genesisAdded);\n', '\n', '        addMasternode(_genesis);\n', '\n', '        if (_team) {\n', '            updateMasternodeAsTeamMember(msg.sender);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Close the genesis accounts\n', '     */\n', '    function closeGenesis() onlyOwner public {\n', '        genesisAdded = true; // Forever lock this.\n', '    }\n', '\n', '    /**\n', '     * @dev Add a user as masternode. Called as internal since we only add masternodes by depositing collateral or by voting.\n', '     * @param _candidate Candidate address\n', '     * @return uint Masternode index\n', '     */\n', '    function addMasternode(address _candidate) internal returns(uint) {\n', '        userByIndex[masternodeCounter].accountOwner = _candidate;\n', '        userByIndex[masternodeCounter].isActive = true;\n', '        userByIndex[masternodeCounter].startingRound = masternodeRound + 1;\n', '        userByIndex[masternodeCounter].storedIndex = masternodeCounter;\n', '\n', '        userByAddress[_candidate].accountOwner = _candidate;\n', '        userByAddress[_candidate].indexcounter.push(masternodeCounter);\n', '\n', '        userArray.push(userArray.length);\n', '        masternodeCounter++;\n', '\n', '        emit NewMasternode(_candidate, now);\n', '        return masternodeCounter - 1; //\n', '    }\n', '\n', '    /**\n', '     * @dev Allow us to update a masternode&#39;s round to keep progress\n', '     * @param _candidate ID of masternode\n', '     */\n', '    function updateMasternode(uint _candidate) internal returns(bool) {\n', '        userByIndex[_candidate].startingRound++;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow us to update a masternode to team member status\n', '     * @param _member address\n', '     */\n', '    function updateMasternodeAsTeamMember(address _member) internal returns (bool) {\n', '        userByAddress[_member].isTeamMember = true;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', '     * @dev Let us know if an address is part of the team.\n', '     * @param _member address\n', '     */\n', '    function isTeamMember (address _member) public view returns (bool) {\n', '        if (userByAddress[_member].isTeamMember)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a specific masternode\n', '     * @param _masternodeID ID of the masternode to remove\n', '     */\n', '    function deleteMasternode(uint _masternodeID) internal returns(bool success) {\n', '\n', '        uint rowToDelete = userByIndex[_masternodeID].storedIndex;\n', '        uint keyToMove = userArray[userArray.length - 1];\n', '\n', '        userByIndex[_masternodeID].isActive = userByIndex[_masternodeID].isActive = (false);\n', '        userArray[rowToDelete] = keyToMove;\n', '        userByIndex[keyToMove].storedIndex = rowToDelete;\n', '        userArray.length = userArray.length - 1;\n', '\n', '        removeFromUserCounter(_masternodeID);\n', '\n', '        emit RemovedMasternode(userByIndex[_masternodeID].accountOwner, now);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev returns what account belongs to a masternode\n', '     */\n', '    function isPartOf(uint mnid) public view returns (address) {\n', '        return userByIndex[mnid].accountOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to remove a masternode from a user address if this address holds multpile masternodes\n', '     * @param index MasternodeID\n', '     */\n', '    function removeFromUserCounter(uint index)  internal returns(uint[]) {\n', '        address belong = isPartOf(index);\n', '\n', '        if (index >= userByAddress[belong].indexcounter.length) return;\n', '\n', '        for (uint i = index; i<userByAddress[belong].indexcounter.length-1; i++){\n', '            userByAddress[belong].indexcounter[i] = userByAddress[belong].indexcounter[i+1];\n', '        }\n', '\n', '        delete userByAddress[belong].indexcounter[userByAddress[belong].indexcounter.length-1];\n', '        userByAddress[belong].indexcounter.length--;\n', '        return userByAddress[belong].indexcounter;\n', '    }\n', '\n', '    /**\n', '     * @dev Primary contract function to update the current user and prepare the next one.\n', '     * A number of steps have been token to ensure the contract can never run out of gas when looping over our masternodes.\n', '     */\n', '    function setMasternodeCandidate() internal returns(address) {\n', '\n', '        uint hardlimitCounter = 0;\n', '\n', '        while (getFollowingCandidate() == 0x0) {\n', '            // We must return a value not to break the contract. Require is a secondary killswitch now.\n', '            require(hardlimitCounter < 6, "Failsafe switched on");\n', '            // Choose if loop over revert/require to terminate the loop and return a 0 address.\n', '            if (hardlimitCounter == 5) return (0);\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '            hardlimitCounter++;\n', '        }\n', '\n', '        if (masternodeCandidate == masternodeCounter - 1) {\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == masternodeRound) {\n', '                    updateMasternode(i);\n', '                    masternodeCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        masternodeRound = masternodeRound + 1;\n', '        return (0);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to loop through our masternodes at start and return the correct round\n', '     */\n', '    function getFollowingCandidate() internal view returns(address _address) {\n', '        uint tmpRound = masternodeRound;\n', '        uint tmpCandidate = masternodeCandidate;\n', '\n', '        if (tmpCandidate == masternodeCounter - 1) {\n', '            tmpRound = tmpRound + 1;\n', '            tmpCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == tmpRound) {\n', '                    tmpCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        tmpRound = tmpRound + 1;\n', '        return (0);\n', '    }\n', '\n', '    /**\n', '     * @dev Displays all masternodes belonging to a user address.\n', '     */\n', '    function belongsToUser(address userAddress) public view returns(uint[]) {\n', '        return (userByAddress[userAddress].indexcounter);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to know if an address owns masternodes\n', '     */\n', '    function isMasternodeOwner(address _candidate) public view returns(bool) {\n', '        if(userByAddress[_candidate].indexcounter.length <= 0) return false;\n', '        if (userByAddress[_candidate].accountOwner == _candidate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to get the last masternode belonging to a user\n', '     */\n', '    function getLastPerUser(address _candidate) public view returns (uint) {\n', '        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Calculate and set the reward schema for Caelum.\n', '     * Each mining phase is decided by multiplying the MINING_PHASE_DURATION_BLOCKS with factor 10.\n', '     * Depending on the outcome (solidity always rounds), we can detect the current stage of mining.\n', '     * First stage we cut the rewards to 5% to prevent instamining.\n', '     * Last stage we leave 2% for miners to incentivize keeping miners running.\n', '     */\n', '    function calculateRewardStructures() internal {\n', '        //ToDo: Set\n', '        uint _global_reward_amount = getMiningReward();\n', '        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\n', '\n', '        if (getStageOfMining < 10) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 5;\n', '            rewardsMasternode = 0;\n', '            return;\n', '        }\n', '\n', '        if (getStageOfMining > 90) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 2;\n', '            rewardsMasternode = _global_reward_amount / 100 * 98;\n', '            return;\n', '        }\n', '\n', '        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\n', '        uint _powreward = (_global_reward_amount - _mnreward);\n', '\n', '        setBaseRewards(_powreward, _mnreward);\n', '    }\n', '\n', '    function setBaseRewards(uint _pow, uint _mn) internal {\n', '        rewardsMasternode = _mn;\n', '        rewardsProofOfWork = _pow;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     */\n', '    function _arrangeMasternodeFlow() internal {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     * This is an emergency manual loop method.\n', '     */\n', '    function _emergencyLoop() onlyOwner public {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    function masternodeInfo(uint index) public view returns\n', '    (\n', '        address,\n', '        bool,\n', '        uint,\n', '        uint\n', '    )\n', '    {\n', '        return (\n', '            userByIndex[index].accountOwner,\n', '            userByIndex[index].isActive,\n', '            userByIndex[index].storedIndex,\n', '            userByIndex[index].startingRound\n', '        );\n', '    }\n', '\n', '    function contractProgress() public view returns\n', '    (\n', '        uint epoch,\n', '        uint candidate,\n', '        uint round,\n', '        uint miningepoch,\n', '        uint globalreward,\n', '        uint powreward,\n', '        uint masternodereward,\n', '        uint usercounter\n', '    )\n', '    {\n', '        return (\n', '            masternodeEpoch,\n', '            masternodeCandidate,\n', '            masternodeRound,\n', '            miningEpoch,\n', '            getMiningReward(),\n', '            rewardsProofOfWork,\n', '            rewardsMasternode,\n', '            masternodeCounter\n', '        );\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumMiner is StandardToken, CaelumMasternode {\n', '    using SafeMath for uint;\n', '    using ExtendedMath for uint;\n', '\n', '    string public symbol = "CLM";\n', '    string public name = "Caelum Token";\n', '    uint8 public decimals = 8;\n', '    uint256 public totalSupply = 2100000000000000;\n', '\n', '    uint public latestDifficultyPeriodStarted;\n', '    uint public epochCount;\n', '    uint public baseMiningReward = 50;\n', '    uint public blocksPerReadjustment = 512;\n', '    uint public _MINIMUM_TARGET = 2 ** 16;\n', '    uint public _MAXIMUM_TARGET = 2 ** 234;\n', '    uint public rewardEra = 0;\n', '\n', '    uint public maxSupplyForEra;\n', '    uint public MAX_REWARD_ERA = 39;\n', '    uint public MINING_RATE_FACTOR = 60; //mint the token 60 times less often than ether\n', '    //difficulty adjustment parameters- be careful modifying these\n', '    uint public MAX_ADJUSTMENT_PERCENT = 100;\n', '    uint public TARGET_DIVISOR = 2000;\n', '    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    bytes32 public challengeNumber;\n', '    uint public difficulty;\n', '    uint public tokensMinted;\n', '\n', '\n', '    struct Statistics {\n', '        address lastRewardTo;\n', '        uint lastRewardAmount;\n', '        uint lastRewardEthBlockNumber;\n', '        uint lastRewardTimestamp;\n', '    }\n', '\n', '    Statistics public statistics;\n', '    \n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '    event RewardMasternode(address candidate, uint amount);\n', '\n', '    constructor() public {\n', '        tokensMinted = 0;\n', '        maxSupplyForEra = totalSupply.div(2);\n', '        difficulty = _MAXIMUM_TARGET;\n', '        latestDifficultyPeriodStarted = block.number;\n', '        _newEpoch(0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(420000 * 1e8); // 2% Premine as determined by the community meeting.\n', '        emit Transfer(this, msg.sender, 420000 * 1e8);\n', '    }\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\n', '        // perform the hash function validation\n', '        _hash(nonce, challenge_digest);\n', '\n', '        _arrangeMasternodeFlow();\n', '\n', '        uint rewardAmount = _reward();\n', '        uint rewardMasternode = _reward_masternode();\n', '\n', '        tokensMinted += rewardAmount.add(rewardMasternode);\n', '\n', '        uint epochCounter = _newEpoch(nonce);\n', '\n', '        _adjustDifficulty();\n', '\n', '        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\n', '\n', '        emit Mint(msg.sender, rewardAmount, epochCounter, challengeNumber);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _newEpoch(uint256 nonce) internal returns(uint) {\n', '\n', '        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < MAX_REWARD_ERA) {\n', '            rewardEra = rewardEra + 1;\n', '        }\n', '        maxSupplyForEra = totalSupply - totalSupply.div(2 ** (rewardEra + 1));\n', '        epochCount = epochCount.add(1);\n', '        challengeNumber = blockhash(block.number - 1);\n', '        return (epochCount);\n', '    }\n', '\n', '    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns(bytes32 digest) {\n', '        digest = keccak256(challengeNumber, msg.sender, nonce);\n', '        if (digest != challenge_digest) revert();\n', '        if (uint256(digest) > difficulty) revert();\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        solutionForChallenge[challengeNumber] = digest;\n', '        if (solution != 0x0) revert(); //prevent the same answer from awarding twice\n', '    }\n', '\n', '    function _reward() internal returns(uint) {\n', '\n', '        uint _pow = rewardsProofOfWork;\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(_pow);\n', '        emit Transfer(this, msg.sender, _pow);\n', '\n', '        return _pow;\n', '    }\n', '\n', '    function _reward_masternode() internal returns(uint) {\n', '\n', '        uint _mnReward = rewardsMasternode;\n', '        if (masternodeCounter == 0) return 0;\n', '\n', '        address _mnCandidate = userByIndex[masternodeCandidate].accountOwner;\n', '        if (_mnCandidate == 0x0) return 0;\n', '\n', '        balances[_mnCandidate] = balances[_mnCandidate].add(_mnReward);\n', '        emit Transfer(this, _mnCandidate, _mnReward);\n', '\n', '        emit RewardMasternode(_mnCandidate, _mnReward);\n', '\n', '        return _mnReward;\n', '    }\n', '\n', '\n', '    //DO NOT manually edit this method unless you know EXACTLY what you are doing\n', '    function _adjustDifficulty() internal returns(uint) {\n', '        //every so often, readjust difficulty. Dont readjust when deploying\n', '        if (epochCount % blocksPerReadjustment != 0) {\n', '            return difficulty;\n', '        }\n', '\n', '        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n', '        //assume 360 ethereum blocks per hour\n', '        //we want miners to spend 10 minutes to mine each &#39;block&#39;, about 60 ethereum blocks = one 0xbitcoin epoch\n', '        uint epochsMined = blocksPerReadjustment;\n', '        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\n', '        //if there were less eth blocks passed in time than expected\n', '        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\n', '            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\n', '            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\n', '            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n', '            //make it harder\n', '            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra)); //by up to 50 %\n', '        } else {\n', '            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\n', '            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\n', '            //make it easier\n', '            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra)); //by up to 50 %\n', '        }\n', '        latestDifficultyPeriodStarted = block.number;\n', '        if (difficulty < _MINIMUM_TARGET) //very difficult\n', '        {\n', '            difficulty = _MINIMUM_TARGET;\n', '        }\n', '        if (difficulty > _MAXIMUM_TARGET) //very easy\n', '        {\n', '            difficulty = _MAXIMUM_TARGET;\n', '        }\n', '    }\n', '    //this is a recent ethereum block hash, used to prevent pre-mining future blocks\n', '    function getChallengeNumber() public view returns(bytes32) {\n', '        return challengeNumber;\n', '    }\n', '    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts\n', '    function getMiningDifficulty() public view returns(uint) {\n', '        return _MAXIMUM_TARGET.div(difficulty);\n', '    }\n', '\n', '    function getMiningTarget() public view returns(uint) {\n', '        return difficulty;\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return (baseMiningReward * 1e8).div(2 ** rewardEra);\n', '    }\n', '\n', '    //help debug mining software\n', '    function getMintDigest(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number\n', '    )\n', '    public view returns(bytes32 digesttest) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        return digest;\n', '    }\n', '    //help debug mining software\n', '    function checkMintSolution(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number,\n', '        uint testTarget\n', '    )\n', '    public view returns(bool success) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        if (uint256(digest) > testTarget) revert();\n', '        return (digest == challenge_digest);\n', '    }\n', '}']
['//solium-disable linebreak-style\n', 'pragma solidity ^0.4.24;\n', '\n', 'library ExtendedMath {\n', '    function limitLessThan(uint a, uint b) internal pure returns(uint c) {\n', '        if (a > b) return b;\n', '        return a;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, reverts on overflow.\n', '     */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, reverts on overflow.\n', '     */\n', '    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns(uint256);\n', '\n', '    function balanceOf(address _who) public view returns(uint256);\n', '\n', '    function transfer(address _to, uint256 _value) public returns(bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address _owner, address _spender) public view returns(uint256);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '\n', '    function approve(address _spender, uint256 _value) public returns(bool);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath\n', '    for uint256;\n', '\n', '    mapping(address => uint256) internal balances;\n', '\n', '    uint256 internal totalSupply_;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns(uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified address\n', '     * @param _to The address to transfer to.\n', '     * @param _value The amount to be transferred.\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns(bool) {\n', '        require(_value <= balances[msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param _owner The address to query the the balance of.\n', '     * @return An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address _owner) public view returns(uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param _from address The address which you want to send tokens from\n', '     * @param _to address The address which you want to transfer to\n', '     * @param _value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public\n', '    returns(bool) {\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_to != address(0));\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _value The amount of tokens to be spent.\n', '     */\n', '    function approve(address _spender, uint256 _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param _owner address The address which owns the funds.\n', '     * @param _spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '    public\n', '    view\n', '    returns(uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        allowed[msg.sender][_spender] = (\n', '            allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * @param _spender The address which will spend the funds.\n', '     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '    public\n', '    returns(bool) {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'interface IcaelumVoting {\n', '    function getTokenProposalDetails() external view returns(address, uint, uint, uint);\n', '    function getExpiry() external view returns (uint);\n', '    function getContractType () external view returns (uint);\n', '}\n', '\n', 'contract abstractCaelum {\n', '    function isMasternodeOwner(address _candidate) public view returns(bool);\n', '    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\n', '    function addMasternode(address _candidate) internal returns(uint);\n', '    function deleteMasternode(uint entityAddress) internal returns(bool success);\n', '    function getLastPerUser(address _candidate) public view returns (uint);\n', '    function getMiningReward() public view returns(uint);\n', '}\n', '\n', 'contract NewTokenProposal is IcaelumVoting {\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '\n', '    VOTE_TYPE public contractType = VOTE_TYPE.TOKEN;\n', '    address contractAddress;\n', '    uint requiredAmount;\n', '    uint validUntil;\n', '    uint votingDurationInDays;\n', '\n', '    /**\n', '     * @dev Create a new vote proposal for an ERC20 token.\n', '     * @param _contract ERC20 contract\n', '     * @param _amount How many tokens are required as collateral\n', '     * @param _valid How long do we accept these tokens on the contract (UNIX timestamp)\n', '     * @param _voteDuration How many days is this vote available\n', '     */\n', '    constructor(address _contract, uint _amount, uint _valid, uint _voteDuration) public {\n', '        require(_voteDuration >= 14 && _voteDuration <= 50, "Proposed voting duration does not meet requirements");\n', '\n', '        contractAddress = _contract;\n', '        requiredAmount = _amount;\n', '        validUntil = _valid;\n', '        votingDurationInDays = _voteDuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about this proposal\n', '     */\n', '    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\n', '        return (contractAddress, requiredAmount, validUntil, uint(contractType));\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the expiry date of contract\n', '     * @return uint Days valid\n', '     */\n', '    function getExpiry() external view returns (uint) {\n', '        return votingDurationInDays;\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the type of contract\n', '     * @return uint Enum value {TOKEN, TEAM}\n', '     */\n', '    function getContractType () external view returns (uint){\n', '        return uint(contractType);\n', '    }\n', '}\n', '\n', 'contract NewMemberProposal is IcaelumVoting {\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '    VOTE_TYPE public contractType = VOTE_TYPE.TEAM;\n', '\n', '    address memberAddress;\n', '    uint totalMasternodes;\n', '    uint votingDurationInDays;\n', '\n', '    /**\n', '     * @dev Create a new vote proposal for a team member.\n', "     * @param _contract Future team member's address\n", '     * @param _total How many masternodes do we want to give\n', '     * @param _voteDuration How many days is this vote available\n', '     */\n', '    constructor(address _contract, uint _total, uint _voteDuration) public {\n', '        require(_voteDuration >= 14 && _voteDuration <= 50, "Proposed voting duration does not meet requirements");\n', '        memberAddress = _contract;\n', '        totalMasternodes = _total;\n', '        votingDurationInDays = _voteDuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about this proposal\n', '     */\n', '    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\n', '        return (memberAddress, totalMasternodes, 0, uint(contractType));\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the expiry date of contract\n', '     * @return uint Days valid\n', '     */\n', '    function getExpiry() external view returns (uint) {\n', '        return votingDurationInDays;\n', '    }\n', '\n', '    /**\n', '     * @dev Displays the type of contract\n', '     * @return uint Enum value {TOKEN, TEAM}\n', '     */\n', '    function getContractType () external view returns (uint){\n', '        return uint(contractType);\n', '    }\n', '}\n', '\n', 'contract CaelumVotings is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    enum VOTE_TYPE {TOKEN, TEAM}\n', '\n', '    struct Proposals {\n', '        address tokenContract;\n', '        uint totalVotes;\n', '        uint proposedOn;\n', '        uint acceptedOn;\n', '        VOTE_TYPE proposalType;\n', '    }\n', '\n', '    struct Voters {\n', '        bool isVoter;\n', '        address owner;\n', '        uint[] votedFor;\n', '    }\n', '\n', '    uint MAJORITY_PERCENTAGE_NEEDED = 60;\n', '    uint MINIMUM_VOTERS_NEEDED = 10;\n', '    bool public proposalPending;\n', '\n', '    mapping(uint => Proposals) public proposalList;\n', '    mapping (address => Voters) public voterMap;\n', '    mapping(uint => address) public voterProposals;\n', '    uint public proposalCounter;\n', '    uint public votersCount;\n', '    uint public votersCountTeam;\n', '\n', '    /**\n', '     * @notice Define abstract functions for later user\n', '     */\n', '    function isMasternodeOwner(address _candidate) public view returns(bool);\n', '    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\n', '    function addMasternode(address _candidate) internal returns(uint);\n', '    function updateMasternodeAsTeamMember(address _member) internal returns (bool);\n', '    function isTeamMember (address _candidate) public view returns (bool);\n', '    \n', '    event NewProposal(uint ProposalID);\n', '    event ProposalAccepted(uint ProposalID);\n', '\n', '    /**\n', '     * @dev Create a new proposal.\n', '     * @param _contract Proposal contract address\n', '     * @return uint ProposalID\n', '     */\n', '    function pushProposal(address _contract) onlyOwner public returns (uint) {\n', '        if(proposalCounter != 0)\n', '        require (pastProposalTimeRules (), "You need to wait 90 days before submitting a new proposal.");\n', '        require (!proposalPending, "Another proposal is pending.");\n', '\n', '        uint _contractType = IcaelumVoting(_contract).getContractType();\n', '        proposalList[proposalCounter] = Proposals(_contract, 0, now, 0, VOTE_TYPE(_contractType));\n', '\n', '        emit NewProposal(proposalCounter);\n', '        \n', '        proposalCounter++;\n', '        proposalPending = true;\n', '\n', '        return proposalCounter.sub(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that handles the proposal after it got accepted.\n', '     * This function determines if the proposal is a token or team member proposal and executes the corresponding functions.\n', '     * @return uint Returns the proposal ID.\n', '     */\n', '    function handleLastProposal () internal returns (uint) {\n', '        uint _ID = proposalCounter.sub(1);\n', '\n', '        proposalList[_ID].acceptedOn = now;\n', '        proposalPending = false;\n', '\n', '        address _address;\n', '        uint _required;\n', '        uint _valid;\n', '        uint _type;\n', '        (_address, _required, _valid, _type) = getTokenProposalDetails(_ID);\n', '\n', '        if(_type == uint(VOTE_TYPE.TOKEN)) {\n', '            addToWhitelist(_address,_required,_valid);\n', '        }\n', '\n', '        if(_type == uint(VOTE_TYPE.TEAM)) {\n', '            if(_required != 0) {\n', '                for (uint i = 0; i < _required; i++) {\n', '                    addMasternode(_address);\n', '                }\n', '            } else {\n', '                addMasternode(_address);\n', '            }\n', '            updateMasternodeAsTeamMember(_address);\n', '        }\n', '        \n', '        emit ProposalAccepted(_ID);\n', '        \n', '        return _ID;\n', '    }\n', '\n', '    /**\n', "     * @dev Rejects the last proposal after the allowed voting time has expired and it's not accepted.\n", '     */\n', '    function discardRejectedProposal() onlyOwner public returns (bool) {\n', '        require(proposalPending);\n', '        require (LastProposalCanDiscard());\n', '        proposalPending = false;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', "     * @dev Checks if the last proposal allowed voting time has expired and it's not accepted.\n", '     * @return bool\n', '     */\n', '    function LastProposalCanDiscard () public view returns (bool) {\n', '        \n', '        uint daysBeforeDiscard = IcaelumVoting(proposalList[proposalCounter - 1].tokenContract).getExpiry();\n', '        uint entryDate = proposalList[proposalCounter - 1].proposedOn;\n', '        uint expiryDate = entryDate + (daysBeforeDiscard * 1 days);\n', '\n', '        if (now >= expiryDate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns all details about a proposal\n', '     */\n', '    function getTokenProposalDetails(uint proposalID) public view returns(address, uint, uint, uint) {\n', '        return IcaelumVoting(proposalList[proposalID].tokenContract).getTokenProposalDetails();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if our 90 day cooldown has passed\n', '     * @return bool\n', '     */\n', '    function pastProposalTimeRules() public view returns (bool) {\n', '        uint lastProposal = proposalList[proposalCounter - 1].proposedOn;\n', '        if (now >= lastProposal + 90 days)\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allow any masternode user to become a voter.\n', '     */\n', '    function becomeVoter() public  {\n', '        require (isMasternodeOwner(msg.sender), "User has no masternodes");\n', '        require (!voterMap[msg.sender].isVoter, "User Already voted for this proposal");\n', '\n', '        voterMap[msg.sender].owner = msg.sender;\n', '        voterMap[msg.sender].isVoter = true;\n', '        votersCount = votersCount + 1;\n', '\n', '        if (isTeamMember(msg.sender))\n', '        votersCountTeam = votersCountTeam + 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow voters to submit their vote on a proposal. Voters can only cast 1 vote per proposal.\n', '     * If the proposed vote is about adding Team members, only Team members are able to vote.\n', '     * A proposal can only be published if the total of votes is greater then MINIMUM_VOTERS_NEEDED.\n', '     * @param proposalID proposalID\n', '     */\n', '    function voteProposal(uint proposalID) public returns (bool success) {\n', '        require(voterMap[msg.sender].isVoter, "Sender not listed as voter");\n', '        require(proposalID >= 0, "No proposal was selected.");\n', '        require(proposalID <= proposalCounter, "Proposal out of limits.");\n', '        require(voterProposals[proposalID] != msg.sender, "Already voted.");\n', '\n', '\n', '        if(proposalList[proposalID].proposalType == VOTE_TYPE.TEAM) {\n', '            require (isTeamMember(msg.sender), "Restricted for team members");\n', '            voterProposals[proposalID] = msg.sender;\n', '            proposalList[proposalID].totalVotes++;\n', '\n', '            if(reachedMajorityForTeam(proposalID)) {\n', '                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\n', '                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\n', '                handleLastProposal();\n', '                return true;\n', '            }\n', '        } else {\n', '            require(votersCount >= MINIMUM_VOTERS_NEEDED, "Not enough voters in existence to push a proposal");\n', '            voterProposals[proposalID] = msg.sender;\n', '            proposalList[proposalID].totalVotes++;\n', '\n', '            if(reachedMajority(proposalID)) {\n', '                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\n', '                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\n', '                handleLastProposal();\n', '                return true;\n', '            }\n', '        }\n', '\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajority (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majority())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majority () internal view returns (uint) {\n', '        uint a = (votersCount * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a proposal has reached the majority vote for a team member\n', '     * @param proposalID Token ID\n', '     * @return bool\n', '     */\n', '    function reachedMajorityForTeam (uint proposalID) public view returns (bool) {\n', '        uint getProposalVotes = proposalList[proposalID].totalVotes;\n', '        if (getProposalVotes >= majorityForTeam())\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that calculates the majority\n', '     * @return uint Total of votes needed for majority\n', '     */\n', '    function majorityForTeam () internal view returns (uint) {\n', '        uint a = (votersCountTeam * MAJORITY_PERCENTAGE_NEEDED );\n', '        return a / 100;\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumFundraise is Ownable, BasicToken, abstractCaelum {\n', '\n', '    /**\n', '     * In no way is Caelum intended to raise funds. We leave this code to demonstrate the potential and functionality.\n', '     * Should you decide to buy a masternode instead of mining, you can by using this function. Feel free to consider this a tipping jar for our dev team.\n', '     * We strongly advice to use the `buyMasternode`function, but simply sending Ether to the contract should work as well.\n', '     */\n', '\n', '    uint AMOUNT_FOR_MASTERNODE = 50 ether;\n', '    uint SPOTS_RESERVED = 10;\n', '    uint COUNTER;\n', '    bool fundraiseClosed = false;\n', '\n', '    /**\n', '     * @dev Not recommended way to accept Ether. Can be safely used if no storage operations are called\n', '     * The contract may revert all the gas because of the gas limitions on the fallback operator.\n', '     * We leave it in as template for other projects, however, for Caelum the function deposit should be adviced.\n', '     */\n', '    function() payable public {\n', '        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\n', '        receivedFunds();\n', '    }\n', '\n', '    /** @dev This is the recommended way for users to deposit Ether in return of a masternode.\n', '     * Users should be encouraged to use this approach as there is not gas risk involved.\n', '     */\n', '    function buyMasternode () payable public {\n', '        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\n', '        receivedFunds();\n', '    }\n', '\n', '    /**\n', '     * @dev Forward funds to owner before making any action. owner.transfer will revert if fail.\n', '     */\n', '    function receivedFunds() internal {\n', '        require(!fundraiseClosed);\n', '        require (COUNTER <= SPOTS_RESERVED);\n', '        owner.transfer(msg.value);\n', '        addMasternode(msg.sender);\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumAcceptERC20 is Ownable, CaelumVotings, abstractCaelum { \n', '    using SafeMath for uint;\n', '\n', '    address[] public tokensList;\n', '    bool setOwnContract = true;\n', '\n', '    struct _whitelistTokens {\n', '        address tokenAddress;\n', '        bool active;\n', '        uint requiredAmount;\n', '        uint validUntil;\n', '        uint timestamp;\n', '    }\n', '\n', '    mapping(address => mapping(address => uint)) public tokens;\n', '    mapping(address => _whitelistTokens) acceptedTokens;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    /**\n', '     * @dev Return the base rewards. This should be overrided by the miner contract.\n', '     * Return a base value for standalone usage ONLY.\n', '     */\n', '    function getMiningReward() public view returns(uint) {\n', '        return 50 * 1e8;\n', '    }\n', '\n', '\n', '    /**\n', "     * @notice Allow the dev to set it's own token as accepted payment.\n", '     * @dev Can be hardcoded in the constructor. Given the contract size, we decided to separate it.\n', '     * @return bool\n', '     */\n', '    function addOwnToken() onlyOwner public returns (bool) {\n', '        require(setOwnContract);\n', '        addToWhitelist(this, 5000 * 1e8, 36500);\n', '        setOwnContract = false;\n', '        return true;\n', '    }\n', '\n', '    // TODO: Set visibility\n', '    /**\n', '     * @notice Add a new token as accepted payment method.\n', '     * @param _token Token contract address.\n', '     * @param _amount Required amount of this Token as collateral\n', '     * @param daysAllowed How many days will we accept this token?\n', '     */\n', '    function addToWhitelist(address _token, uint _amount, uint daysAllowed) internal {\n', '        _whitelistTokens storage newToken = acceptedTokens[_token];\n', '        newToken.tokenAddress = _token;\n', '        newToken.requiredAmount = _amount;\n', '        newToken.timestamp = now;\n', '        newToken.validUntil = now + (daysAllowed * 1 days);\n', '        newToken.active = true;\n', '\n', '        tokensList.push(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if we accept this token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isAcceptedToken(address _ad) internal view returns(bool) {\n', '        return acceptedTokens[_ad].active;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine the requiredAmount for a specific token.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function getAcceptedTokenAmount(address _ad) internal view returns(uint) {\n', '        return acceptedTokens[_ad].requiredAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to determine if the token is still accepted timewise.\n', '     * @param _ad Token contract address\n', '     * @return bool\n', '     */\n', '    function isValid(address _ad) internal view returns(bool) {\n', '        uint endTime = acceptedTokens[_ad].validUntil;\n', '        if (block.timestamp < endTime) return true;\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns an array of all accepted token. You can get more details by calling getTokenDetails function with this address.\n', '     * @return array Address\n', '     */\n', '    function listAcceptedTokens() public view returns(address[]) {\n', '        return tokensList;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns a full list of the token details\n', '     * @param token Token contract address\n', '     */\n', '    function getTokenDetails(address token) public view returns(address ad,uint required, bool active, uint valid) {\n', '        return (acceptedTokens[token].tokenAddress, acceptedTokens[token].requiredAmount,acceptedTokens[token].active, acceptedTokens[token].validUntil);\n', '    }\n', '\n', '    /**\n', '     * @notice Public function that allows any user to deposit accepted tokens as collateral to become a masternode.\n', '     * @param token Token contract address\n', '     * @param amount Amount to deposit\n', '     */\n', '    function depositCollateral(address token, uint amount) public {\n', '        require(isAcceptedToken(token), "ERC20 not authorised");  // Should be a token from our list\n', '        require(amount == getAcceptedTokenAmount(token));         // The amount needs to match our set amount\n', '        require(isValid(token));                                  // It should be called within the setup timeframe\n', '\n', '        tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '\n', '        require(StandardToken(token).transferFrom(msg.sender, this, amount), "error with token");\n', '        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n', '\n', '        addMasternode(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Public function that allows any user to withdraw deposited tokens and stop as masternode\n', '     * @param token Token contract address\n', '     * @param amount Amount to withdraw\n', '     */\n', '    function withdrawCollateral(address token, uint amount) public {\n', '        require(token != 0); // token should be an actual address\n', '        require(isAcceptedToken(token), "ERC20 not authorised"); // Should be a token from our list\n', '        require(isMasternodeOwner(msg.sender)); // The sender must be a masternode prior to withdraw\n', '        require(tokens[token][msg.sender] == amount); // The amount must be exactly whatever is deposited\n', '\n', '        uint amountToWithdraw = tokens[token][msg.sender];\n', '        tokens[token][msg.sender] = 0;\n', '\n', '        deleteMasternode(getLastPerUser(msg.sender));\n', '\n', '        if (!StandardToken(token).transfer(msg.sender, amountToWithdraw)) revert();\n', '        emit Withdraw(token, msg.sender, amountToWithdraw, amountToWithdraw);\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumMasternode is CaelumFundraise, CaelumAcceptERC20{\n', '    using SafeMath for uint;\n', '\n', '    bool onTestnet = false;\n', '    bool genesisAdded = false;\n', '\n', '    uint  masternodeRound;\n', '    uint  masternodeCandidate;\n', '    uint  masternodeCounter;\n', '    uint  masternodeEpoch;\n', '    uint  miningEpoch;\n', '\n', '    uint rewardsProofOfWork;\n', '    uint rewardsMasternode;\n', '    uint rewardsGlobal = 50 * 1e8;\n', '\n', '    uint MINING_PHASE_DURATION_BLOCKS = 4500;\n', '\n', '    struct MasterNode {\n', '        address accountOwner;\n', '        bool isActive;\n', '        bool isTeamMember;\n', '        uint storedIndex;\n', '        uint startingRound;\n', '        uint[] indexcounter;\n', '    }\n', '\n', '    uint[] userArray;\n', '    address[] userAddressArray;\n', '\n', '    mapping(uint => MasterNode) userByIndex; // UINT masterMapping\n', '    mapping(address => MasterNode) userByAddress; //masterMapping\n', '    mapping(address => uint) userAddressIndex;\n', '\n', '    event Deposit(address token, address user, uint amount, uint balance);\n', '    event Withdraw(address token, address user, uint amount, uint balance);\n', '\n', '    event NewMasternode(address candidateAddress, uint timeStamp);\n', '    event RemovedMasternode(address candidateAddress, uint timeStamp);\n', '\n', '    /**\n', '     * @dev Add the genesis accounts\n', '     */\n', '    function addGenesis(address _genesis, bool _team) onlyOwner public {\n', '        require(!genesisAdded);\n', '\n', '        addMasternode(_genesis);\n', '\n', '        if (_team) {\n', '            updateMasternodeAsTeamMember(msg.sender);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Close the genesis accounts\n', '     */\n', '    function closeGenesis() onlyOwner public {\n', '        genesisAdded = true; // Forever lock this.\n', '    }\n', '\n', '    /**\n', '     * @dev Add a user as masternode. Called as internal since we only add masternodes by depositing collateral or by voting.\n', '     * @param _candidate Candidate address\n', '     * @return uint Masternode index\n', '     */\n', '    function addMasternode(address _candidate) internal returns(uint) {\n', '        userByIndex[masternodeCounter].accountOwner = _candidate;\n', '        userByIndex[masternodeCounter].isActive = true;\n', '        userByIndex[masternodeCounter].startingRound = masternodeRound + 1;\n', '        userByIndex[masternodeCounter].storedIndex = masternodeCounter;\n', '\n', '        userByAddress[_candidate].accountOwner = _candidate;\n', '        userByAddress[_candidate].indexcounter.push(masternodeCounter);\n', '\n', '        userArray.push(userArray.length);\n', '        masternodeCounter++;\n', '\n', '        emit NewMasternode(_candidate, now);\n', '        return masternodeCounter - 1; //\n', '    }\n', '\n', '    /**\n', "     * @dev Allow us to update a masternode's round to keep progress\n", '     * @param _candidate ID of masternode\n', '     */\n', '    function updateMasternode(uint _candidate) internal returns(bool) {\n', '        userByIndex[_candidate].startingRound++;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow us to update a masternode to team member status\n', '     * @param _member address\n', '     */\n', '    function updateMasternodeAsTeamMember(address _member) internal returns (bool) {\n', '        userByAddress[_member].isTeamMember = true;\n', '        return (true);\n', '    }\n', '\n', '    /**\n', '     * @dev Let us know if an address is part of the team.\n', '     * @param _member address\n', '     */\n', '    function isTeamMember (address _member) public view returns (bool) {\n', '        if (userByAddress[_member].isTeamMember)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a specific masternode\n', '     * @param _masternodeID ID of the masternode to remove\n', '     */\n', '    function deleteMasternode(uint _masternodeID) internal returns(bool success) {\n', '\n', '        uint rowToDelete = userByIndex[_masternodeID].storedIndex;\n', '        uint keyToMove = userArray[userArray.length - 1];\n', '\n', '        userByIndex[_masternodeID].isActive = userByIndex[_masternodeID].isActive = (false);\n', '        userArray[rowToDelete] = keyToMove;\n', '        userByIndex[keyToMove].storedIndex = rowToDelete;\n', '        userArray.length = userArray.length - 1;\n', '\n', '        removeFromUserCounter(_masternodeID);\n', '\n', '        emit RemovedMasternode(userByIndex[_masternodeID].accountOwner, now);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev returns what account belongs to a masternode\n', '     */\n', '    function isPartOf(uint mnid) public view returns (address) {\n', '        return userByIndex[mnid].accountOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to remove a masternode from a user address if this address holds multpile masternodes\n', '     * @param index MasternodeID\n', '     */\n', '    function removeFromUserCounter(uint index)  internal returns(uint[]) {\n', '        address belong = isPartOf(index);\n', '\n', '        if (index >= userByAddress[belong].indexcounter.length) return;\n', '\n', '        for (uint i = index; i<userByAddress[belong].indexcounter.length-1; i++){\n', '            userByAddress[belong].indexcounter[i] = userByAddress[belong].indexcounter[i+1];\n', '        }\n', '\n', '        delete userByAddress[belong].indexcounter[userByAddress[belong].indexcounter.length-1];\n', '        userByAddress[belong].indexcounter.length--;\n', '        return userByAddress[belong].indexcounter;\n', '    }\n', '\n', '    /**\n', '     * @dev Primary contract function to update the current user and prepare the next one.\n', '     * A number of steps have been token to ensure the contract can never run out of gas when looping over our masternodes.\n', '     */\n', '    function setMasternodeCandidate() internal returns(address) {\n', '\n', '        uint hardlimitCounter = 0;\n', '\n', '        while (getFollowingCandidate() == 0x0) {\n', '            // We must return a value not to break the contract. Require is a secondary killswitch now.\n', '            require(hardlimitCounter < 6, "Failsafe switched on");\n', '            // Choose if loop over revert/require to terminate the loop and return a 0 address.\n', '            if (hardlimitCounter == 5) return (0);\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '            hardlimitCounter++;\n', '        }\n', '\n', '        if (masternodeCandidate == masternodeCounter - 1) {\n', '            masternodeRound = masternodeRound + 1;\n', '            masternodeCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == masternodeRound) {\n', '                    updateMasternode(i);\n', '                    masternodeCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        masternodeRound = masternodeRound + 1;\n', '        return (0);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to loop through our masternodes at start and return the correct round\n', '     */\n', '    function getFollowingCandidate() internal view returns(address _address) {\n', '        uint tmpRound = masternodeRound;\n', '        uint tmpCandidate = masternodeCandidate;\n', '\n', '        if (tmpCandidate == masternodeCounter - 1) {\n', '            tmpRound = tmpRound + 1;\n', '            tmpCandidate = 0;\n', '        }\n', '\n', '        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\n', '            if (userByIndex[i].isActive) {\n', '                if (userByIndex[i].startingRound == tmpRound) {\n', '                    tmpCandidate = i;\n', '                    return (userByIndex[i].accountOwner);\n', '                }\n', '            }\n', '        }\n', '\n', '        tmpRound = tmpRound + 1;\n', '        return (0);\n', '    }\n', '\n', '    /**\n', '     * @dev Displays all masternodes belonging to a user address.\n', '     */\n', '    function belongsToUser(address userAddress) public view returns(uint[]) {\n', '        return (userByAddress[userAddress].indexcounter);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to know if an address owns masternodes\n', '     */\n', '    function isMasternodeOwner(address _candidate) public view returns(bool) {\n', '        if(userByAddress[_candidate].indexcounter.length <= 0) return false;\n', '        if (userByAddress[_candidate].accountOwner == _candidate)\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to get the last masternode belonging to a user\n', '     */\n', '    function getLastPerUser(address _candidate) public view returns (uint) {\n', '        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Calculate and set the reward schema for Caelum.\n', '     * Each mining phase is decided by multiplying the MINING_PHASE_DURATION_BLOCKS with factor 10.\n', '     * Depending on the outcome (solidity always rounds), we can detect the current stage of mining.\n', '     * First stage we cut the rewards to 5% to prevent instamining.\n', '     * Last stage we leave 2% for miners to incentivize keeping miners running.\n', '     */\n', '    function calculateRewardStructures() internal {\n', '        //ToDo: Set\n', '        uint _global_reward_amount = getMiningReward();\n', '        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\n', '\n', '        if (getStageOfMining < 10) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 5;\n', '            rewardsMasternode = 0;\n', '            return;\n', '        }\n', '\n', '        if (getStageOfMining > 90) {\n', '            rewardsProofOfWork = _global_reward_amount / 100 * 2;\n', '            rewardsMasternode = _global_reward_amount / 100 * 98;\n', '            return;\n', '        }\n', '\n', '        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\n', '        uint _powreward = (_global_reward_amount - _mnreward);\n', '\n', '        setBaseRewards(_powreward, _mnreward);\n', '    }\n', '\n', '    function setBaseRewards(uint _pow, uint _mn) internal {\n', '        rewardsMasternode = _mn;\n', '        rewardsProofOfWork = _pow;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     */\n', '    function _arrangeMasternodeFlow() internal {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    /**\n', '     * @dev Executes the masternode flow. Should be called after mining a block.\n', '     * This is an emergency manual loop method.\n', '     */\n', '    function _emergencyLoop() onlyOwner public {\n', '        calculateRewardStructures();\n', '        setMasternodeCandidate();\n', '        miningEpoch++;\n', '    }\n', '\n', '    function masternodeInfo(uint index) public view returns\n', '    (\n', '        address,\n', '        bool,\n', '        uint,\n', '        uint\n', '    )\n', '    {\n', '        return (\n', '            userByIndex[index].accountOwner,\n', '            userByIndex[index].isActive,\n', '            userByIndex[index].storedIndex,\n', '            userByIndex[index].startingRound\n', '        );\n', '    }\n', '\n', '    function contractProgress() public view returns\n', '    (\n', '        uint epoch,\n', '        uint candidate,\n', '        uint round,\n', '        uint miningepoch,\n', '        uint globalreward,\n', '        uint powreward,\n', '        uint masternodereward,\n', '        uint usercounter\n', '    )\n', '    {\n', '        return (\n', '            masternodeEpoch,\n', '            masternodeCandidate,\n', '            masternodeRound,\n', '            miningEpoch,\n', '            getMiningReward(),\n', '            rewardsProofOfWork,\n', '            rewardsMasternode,\n', '            masternodeCounter\n', '        );\n', '    }\n', '\n', '}\n', '\n', 'contract CaelumMiner is StandardToken, CaelumMasternode {\n', '    using SafeMath for uint;\n', '    using ExtendedMath for uint;\n', '\n', '    string public symbol = "CLM";\n', '    string public name = "Caelum Token";\n', '    uint8 public decimals = 8;\n', '    uint256 public totalSupply = 2100000000000000;\n', '\n', '    uint public latestDifficultyPeriodStarted;\n', '    uint public epochCount;\n', '    uint public baseMiningReward = 50;\n', '    uint public blocksPerReadjustment = 512;\n', '    uint public _MINIMUM_TARGET = 2 ** 16;\n', '    uint public _MAXIMUM_TARGET = 2 ** 234;\n', '    uint public rewardEra = 0;\n', '\n', '    uint public maxSupplyForEra;\n', '    uint public MAX_REWARD_ERA = 39;\n', '    uint public MINING_RATE_FACTOR = 60; //mint the token 60 times less often than ether\n', '    //difficulty adjustment parameters- be careful modifying these\n', '    uint public MAX_ADJUSTMENT_PERCENT = 100;\n', '    uint public TARGET_DIVISOR = 2000;\n', '    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    bytes32 public challengeNumber;\n', '    uint public difficulty;\n', '    uint public tokensMinted;\n', '\n', '\n', '    struct Statistics {\n', '        address lastRewardTo;\n', '        uint lastRewardAmount;\n', '        uint lastRewardEthBlockNumber;\n', '        uint lastRewardTimestamp;\n', '    }\n', '\n', '    Statistics public statistics;\n', '    \n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '    event RewardMasternode(address candidate, uint amount);\n', '\n', '    constructor() public {\n', '        tokensMinted = 0;\n', '        maxSupplyForEra = totalSupply.div(2);\n', '        difficulty = _MAXIMUM_TARGET;\n', '        latestDifficultyPeriodStarted = block.number;\n', '        _newEpoch(0);\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(420000 * 1e8); // 2% Premine as determined by the community meeting.\n', '        emit Transfer(this, msg.sender, 420000 * 1e8);\n', '    }\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\n', '        // perform the hash function validation\n', '        _hash(nonce, challenge_digest);\n', '\n', '        _arrangeMasternodeFlow();\n', '\n', '        uint rewardAmount = _reward();\n', '        uint rewardMasternode = _reward_masternode();\n', '\n', '        tokensMinted += rewardAmount.add(rewardMasternode);\n', '\n', '        uint epochCounter = _newEpoch(nonce);\n', '\n', '        _adjustDifficulty();\n', '\n', '        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\n', '\n', '        emit Mint(msg.sender, rewardAmount, epochCounter, challengeNumber);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _newEpoch(uint256 nonce) internal returns(uint) {\n', '\n', '        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < MAX_REWARD_ERA) {\n', '            rewardEra = rewardEra + 1;\n', '        }\n', '        maxSupplyForEra = totalSupply - totalSupply.div(2 ** (rewardEra + 1));\n', '        epochCount = epochCount.add(1);\n', '        challengeNumber = blockhash(block.number - 1);\n', '        return (epochCount);\n', '    }\n', '\n', '    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns(bytes32 digest) {\n', '        digest = keccak256(challengeNumber, msg.sender, nonce);\n', '        if (digest != challenge_digest) revert();\n', '        if (uint256(digest) > difficulty) revert();\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        solutionForChallenge[challengeNumber] = digest;\n', '        if (solution != 0x0) revert(); //prevent the same answer from awarding twice\n', '    }\n', '\n', '    function _reward() internal returns(uint) {\n', '\n', '        uint _pow = rewardsProofOfWork;\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(_pow);\n', '        emit Transfer(this, msg.sender, _pow);\n', '\n', '        return _pow;\n', '    }\n', '\n', '    function _reward_masternode() internal returns(uint) {\n', '\n', '        uint _mnReward = rewardsMasternode;\n', '        if (masternodeCounter == 0) return 0;\n', '\n', '        address _mnCandidate = userByIndex[masternodeCandidate].accountOwner;\n', '        if (_mnCandidate == 0x0) return 0;\n', '\n', '        balances[_mnCandidate] = balances[_mnCandidate].add(_mnReward);\n', '        emit Transfer(this, _mnCandidate, _mnReward);\n', '\n', '        emit RewardMasternode(_mnCandidate, _mnReward);\n', '\n', '        return _mnReward;\n', '    }\n', '\n', '\n', '    //DO NOT manually edit this method unless you know EXACTLY what you are doing\n', '    function _adjustDifficulty() internal returns(uint) {\n', '        //every so often, readjust difficulty. Dont readjust when deploying\n', '        if (epochCount % blocksPerReadjustment != 0) {\n', '            return difficulty;\n', '        }\n', '\n', '        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n', '        //assume 360 ethereum blocks per hour\n', "        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xbitcoin epoch\n", '        uint epochsMined = blocksPerReadjustment;\n', '        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\n', '        //if there were less eth blocks passed in time than expected\n', '        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\n', '            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\n', '            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\n', '            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\n', '            //make it harder\n', '            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra)); //by up to 50 %\n', '        } else {\n', '            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\n', '            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\n', '            //make it easier\n', '            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra)); //by up to 50 %\n', '        }\n', '        latestDifficultyPeriodStarted = block.number;\n', '        if (difficulty < _MINIMUM_TARGET) //very difficult\n', '        {\n', '            difficulty = _MINIMUM_TARGET;\n', '        }\n', '        if (difficulty > _MAXIMUM_TARGET) //very easy\n', '        {\n', '            difficulty = _MAXIMUM_TARGET;\n', '        }\n', '    }\n', '    //this is a recent ethereum block hash, used to prevent pre-mining future blocks\n', '    function getChallengeNumber() public view returns(bytes32) {\n', '        return challengeNumber;\n', '    }\n', '    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts\n', '    function getMiningDifficulty() public view returns(uint) {\n', '        return _MAXIMUM_TARGET.div(difficulty);\n', '    }\n', '\n', '    function getMiningTarget() public view returns(uint) {\n', '        return difficulty;\n', '    }\n', '\n', '    function getMiningReward() public view returns(uint) {\n', '        return (baseMiningReward * 1e8).div(2 ** rewardEra);\n', '    }\n', '\n', '    //help debug mining software\n', '    function getMintDigest(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number\n', '    )\n', '    public view returns(bytes32 digesttest) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        return digest;\n', '    }\n', '    //help debug mining software\n', '    function checkMintSolution(\n', '        uint256 nonce,\n', '        bytes32 challenge_digest,\n', '        bytes32 challenge_number,\n', '        uint testTarget\n', '    )\n', '    public view returns(bool success) {\n', '        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\n', '        if (uint256(digest) > testTarget) revert();\n', '        return (digest == challenge_digest);\n', '    }\n', '}']
