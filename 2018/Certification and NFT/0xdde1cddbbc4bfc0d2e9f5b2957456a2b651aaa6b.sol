['pragma solidity ^0.4.20;\n', '\n', '// File: contracts/ERC20Token.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address newOwner;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) only(owner) public {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() only(newOwner) public {\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '}\n', '\n', 'contract ERC20 is Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public totalSupply;\n', '    bool public isStarted = false;\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    modifier isStartedOnly() {\n', '        require(isStarted);\n', '        _;\n', '    }\n', '\n', '    modifier isNotStartedOnly() {\n', '        require(!isStarted);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract Token is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function start() public only(owner) isNotStartedOnly {\n', '        isStarted = true;\n', '    }\n', '\n', '    //================= Crowdsale Only =================\n', '    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '}\n', '\n', 'contract TokenWithoutStart is Owned {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint _amount) public only(owner) returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/CycleSet.sol\n', '\n', '// DEPLOYED BY JURY.ONLINE\n', 'contract ICO {\n', '    // GENERAL ICO PARAMS ------------------------------------------------------\n', '\n', '    string public name;\n', '\n', '    address public operator; // the ICO operator\n', '    address public projectWallet; // the wallet that receives ICO Funds\n', '    Token public token; // ICO token\n', '    address public juryOnlineWallet; // JuryOnline Wallet for commission\n', '    address public arbitrationAddress; // Address of Arbitration Contract\n', '    uint public currentCycle; // current cycle\n', '\n', '    struct Cycle {\n', '        bool exists;\n', '        bool approved;\n', '        address icoRoundAddress;\n', '    }\n', '\n', '    mapping(uint => Cycle) public cycles; // stores the approved Cycles\n', '\n', '    // DEPLOYED BY JURY.ONLINE\n', '    // PARAMS:\n', '    // address _operator\n', '    // address _projectWallet\n', '    // address _tokenAddress\n', '    // address _arbitrationAddress\n', '    // address _juryOnlineWallet\n', '    constructor(string _name, address _operator, address _projectWallet, address _tokenAddress, address _arbitrationAddress, address _juryOnlineWallet) public {\n', '        name = _name;\n', '        operator = _operator;\n', '        projectWallet = _projectWallet;\n', '        token = Token(_tokenAddress);\n', '        arbitrationAddress = _arbitrationAddress;\n', '        juryOnlineWallet = _juryOnlineWallet;\n', '    }\n', '\n', '    // CALLED BY CYCLE CONTRACT\n', '    function addRound() public {\n', '        cycles[currentCycle].exists = true;\n', '        cycles[currentCycle].icoRoundAddress = msg.sender;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR, approves CYCLE Contract and adds it to cycles\n', '    function approveRound(address _icoRoundAddress) public {\n', '        require(msg.sender == operator);\n', '        require(cycles[currentCycle].icoRoundAddress == _icoRoundAddress);\n', '        currentCycle +=1;\n', '    }\n', '\n', '}\n', '// DEPLOYED BY JURY.ONLINE\n', 'contract Cycle {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // GENERAL CYCLE VARIABLES -------------------------------------------------\n', '\n', '    address public juryOperator; // assists in operation\n', '    address public operator; // cycle operator, same as ICO operator\n', '    address public icoAddress; // to associate Cycle with ICO\n', '    address public juryOnlineWallet; // juryOnlineWallet for commission\n', '    address public projectWallet; // taken from ICO contract\n', '    address public arbitrationAddress; // taken from ICO contract\n', '    Token public token; // taken from ICO contract\n', '\n', '    address public jotter; // address for JOT commission\n', '\n', '    bool public saveMe; // if true, gives Jury.Online control of contract\n', '\n', '    struct Milestone {\n', '        uint etherAmount; //how many Ether is needed for this milestone\n', '        uint tokenAmount; //how many tokens releases this milestone\n', '        uint startTime; //real time when milestone has started, set upon start\n', '        uint finishTime; //real time when milestone has finished, set upon finish\n', '        uint duration; //assumed duration for milestone implementation, set upon milestone creation\n', '        string description;\n', '        string result;\n', '    }\n', '\n', '    Milestone[] public milestones; // List of Milestones\n', '    uint public currentMilestone;\n', '\n', '    uint public sealTimestamp; // the moment the Cycle is Sealed by operator\n', '\n', '    uint public ethForMilestone; // Amount to be withdraw by operator for each milestone\n', '    uint public postDisputeEth; // in case of dispute in favor of ico project\n', '\n', '    // INVESTOR struct stores information about each Investor\n', '    // Investor can have more than one deals, but only one right to dispute\n', '    struct Investor {\n', '        bool disputing;\n', '        uint tokenAllowance;\n', '        uint etherUsed;\n', '        uint sumEther;\n', '        uint sumToken;\n', '        bool verdictForProject;\n', '        bool verdictForInvestor;\n', '        uint numberOfDeals;\n', '    }\n', '\n', '    struct Deal {\n', '        address investor;\n', '        uint etherAmount;\n', '        uint tokenAmount;\n', '        bool accepted;\n', '    }\n', '\n', '    mapping(address => Investor) public deals; // map of information of investors with deals\n', '    address[] public dealsList; // list of investors with deals\n', '    mapping(address => mapping(uint => Deal)) public offers; // pending offers\n', '\n', '    // COMMISSION ARRAYS\n', '    // amounts stored as percentage\n', '    // If commissionOnInvestmentEth/Jot > 0, commission paid when investment is accepted\n', '    // If elements on commissionEth/Jot, each element is commission to corresponding milestone\n', '    // ETH commission is transferred to Jury.Online wallet\n', '    // JOT commission is transferred to a Jotter contract that swaps eth for jot\n', '    uint[] public commissionEth;\n', '    uint[] public commissionJot;\n', '    uint public commissionOnInvestmentEth;\n', '    uint public commissionOnInvestmentJot;\n', '    uint public etherAllowance; // Amount that Jury.Online can withdraw as commission in ETH\n', '    uint public jotAllowance; // Amount that Jury.Online can withdraw as commission in JOT\n', '\n', '    uint public totalEther; // Sum of ether in milestones\n', '    uint public totalToken; // Sum of tokens in milestones\n', '\n', '    uint public promisedTokens; // Sum of tokens promised by accepting offer\n', '    uint public raisedEther; // Sum of ether raised by accepting offer\n', '\n', '    uint public rate; // eth to token rate in current Funding Round\n', '    bool public tokenReleaseAtStart; // whether to release tokens at start or by each milestone\n', '    uint public currentFundingRound;\n', '\n', '    bool public roundFailedToStart;\n', '\n', '    // Stores amount of ether and tokens per milestone for each investor\n', '    mapping(address => uint[]) public etherPartition;\n', '    mapping(address => uint[]) public tokenPartition;\n', '\n', '    // Funding Rounds can be added with start, end time, rate, and whitelist\n', '    struct FundingRound {\n', '        uint startTime;\n', '        uint endTime;\n', '        uint rate;\n', '        bool hasWhitelist;\n', '    }\n', '\n', '    FundingRound[] public roundPrices;  // stores list of funding rounds\n', '    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists\n', '\n', '    // -------------------------------------------------------------------------\n', '    // MODIFIERS\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    modifier sealed() {\n', '        require(sealTimestamp != 0);\n', '        /* require(now > sealTimestamp); */\n', '        _;\n', '    }\n', '\n', '    modifier notSealed() {\n', '        require(sealTimestamp == 0);\n', '        /* require(now <= sealTimestamp); */\n', '        _;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // DEPLOYED BY JURY.ONLINE\n', '    // PARAMS:\n', '    // address _icoAddress\n', '    // address _operator\n', '    // uint _rate\n', '    // address _jotter\n', '    // uint[] _commissionEth\n', '    // uint[] _commissionJot\n', '    constructor( address _icoAddress,\n', '                 address _operator,\n', '                 uint _rate,\n', '                 address _jotter,\n', '                 uint[] _commissionEth,\n', '                 uint[] _commissionJot,\n', '                 uint _commissionOnInvestmentEth,\n', '                 uint _commissionOnInvestmentJot\n', '                 ) public {\n', '        require(_commissionEth.length == _commissionJot.length);\n', '        juryOperator = msg.sender;\n', '        icoAddress = _icoAddress;\n', '        operator = _operator;\n', '        rate = _rate;\n', '        jotter = _jotter;\n', '        commissionEth = _commissionEth;\n', '        commissionJot = _commissionJot;\n', '        roundPrices.push(FundingRound(0,0,0,false));\n', '        tokenReleaseAtStart = true;\n', '        commissionOnInvestmentEth = _commissionOnInvestmentEth;\n', '        commissionOnInvestmentJot = _commissionOnInvestmentJot;\n', '    }\n', '\n', '    // CALLED BY JURY.ONLINE TO SET JOTTER ADDRESS FOR JOT COMMISSION\n', '    function setJotter(address _jotter) public {\n', '        require(msg.sender == juryOperator);\n', '        jotter = _jotter;\n', '    }\n', '\n', '    // CALLED BY ADMIN TO RETRIEVE INFORMATION FROM ICOADDRESS AND ADD ITSELF\n', '    // TO LIST OF CYCLES IN ICO\n', '    function activate() onlyAdmin notSealed public {\n', '        ICO icoContract = ICO(icoAddress);\n', '        require(icoContract.operator() == operator);\n', '        juryOnlineWallet = icoContract.juryOnlineWallet();\n', '        projectWallet = icoContract.projectWallet();\n', '        arbitrationAddress = icoContract.arbitrationAddress();\n', '        token = icoContract.token();\n', '        icoContract.addRound();\n', '    }\n', '\n', '    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\n', '    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\n', '    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\n', '    function withdrawEther() public {\n', '        if (roundFailedToStart == true) {\n', '            require(msg.sender.send(deals[msg.sender].sumEther));\n', '        }\n', '        if (msg.sender == operator) {\n', '            require(projectWallet.send(ethForMilestone+postDisputeEth));\n', '            ethForMilestone = 0;\n', '            postDisputeEth = 0;\n', '        }\n', '        if (msg.sender == juryOnlineWallet) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '        if (deals[msg.sender].verdictForInvestor == true) {\n', '            require(msg.sender.send(deals[msg.sender].sumEther - deals[msg.sender].etherUsed));\n', '        }\n', '    }\n', '\n', '    // CALLED BY INVESTOR TO RETRIEVE TOKENS\n', '    function withdrawToken() public {\n', '        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\n', '        deals[msg.sender].tokenAllowance = 0;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO ADD FUNDING ROUNDS WITH _startTime,_endTime,_price,_whitelist\n', '    function addRoundPrice(uint _startTime,uint _endTime, uint _price, address[] _whitelist) public onlyOperator {\n', '        if (_whitelist.length == 0) {\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_price,false));\n', '        } else {\n', '            for (uint i=0 ; i < _whitelist.length ; i++ ) {\n', '                whitelist[roundPrices.length][_whitelist[i]] = true;\n', '            }\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_price,true));\n', '        }\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO SET RATE WITHOUT SETTING FUNDING ROUND\n', '    function setRate(uint _rate) onlyOperator public {\n', '        rate = _rate;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO APPLY WHITELIST AND PRICE OF FUNDING ROUND\n', '    function setCurrentFundingRound(uint _fundingRound) public onlyOperator {\n', '        require(roundPrices.length > _fundingRound);\n', '        currentFundingRound = _fundingRound;\n', '        rate = roundPrices[_fundingRound].rate;\n', '    }\n', '\n', '    // RECEIVES FUNDS AND CREATES OFFER\n', '    function () public payable {\n', '        require(msg.value > 0);\n', '        if (roundPrices[currentFundingRound].hasWhitelist == true) {\n', '            require(whitelist[currentFundingRound][msg.sender] == true);\n', '        }\n', '        uint dealNumber = deals[msg.sender].numberOfDeals;\n', '        offers[msg.sender][dealNumber].investor = msg.sender;\n', '        offers[msg.sender][dealNumber].etherAmount = msg.value;\n', '        deals[msg.sender].numberOfDeals += 1;\n', '    }\n', '\n', '    // IF OFFER NOT ACCEPTED, CAN BE WITHDRAWN\n', '    function withdrawOffer(uint _offerNumber) public {\n', '        require(offers[msg.sender][_offerNumber].accepted == false);\n', '        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\n', '        offers[msg.sender][_offerNumber].etherAmount = 0;\n', '        /* offers[msg.sender][_offerNumber].tokenAmount = 0; */\n', '    }\n', '\n', '    // ARBITRATION\n', '    // CALLED BY ARBITRATION ADDRESS\n', '    function disputeOpened(address _investor) public {\n', '        require(msg.sender == arbitrationAddress);\n', '        deals[_investor].disputing = true;\n', '    }\n', '\n', '    // CALLED BY ARBITRATION ADDRESS\n', '    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public {\n', '        require(msg.sender == arbitrationAddress);\n', '        require(deals[_investor].disputing == true);\n', '        if (_verdictForInvestor) {\n', '            deals[_investor].verdictForInvestor = true;\n', '        } else {\n', '            deals[_investor].verdictForProject = true;\n', '            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\n', '                postDisputeEth += etherPartition[_investor][i];\n', '                deals[_investor].etherUsed += etherPartition[_investor][i];\n', '            }\n', '        }\n', '        deals[_investor].disputing = false;\n', '    }\n', '\n', '    // OPERATOR\n', '    // TO ADD MILESTONES\n', '    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyOperator returns(uint) {\n', '        totalEther = totalEther.add(_etherAmount);\n', '        totalToken = totalToken.add(_tokenAmount);\n', '        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, ""));\n', '    }\n', '\n', '    // TO EDIT MILESTONES\n', '    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyOperator {\n', '        assert(_id < milestones.length);\n', '        totalEther = (totalEther - milestones[_id].etherAmount).add(_etherAmount); //previous addition\n', '        totalToken = (totalToken - milestones[_id].tokenAmount).add(_tokenAmount);\n', '        milestones[_id].etherAmount = _etherAmount;\n', '        milestones[_id].tokenAmount = _tokenAmount;\n', '        milestones[_id].startTime = _startTime;\n', '        milestones[_id].duration = _duration;\n', '        milestones[_id].description = _description;\n', '    }\n', '\n', '    // TO SEAL\n', '    function seal() public notSealed onlyOperator {\n', '        require(milestones.length > 0);\n', '        require(token.balanceOf(address(this)) >= totalToken);\n', '        sealTimestamp = now;\n', '    }\n', '\n', '    // TO ACCEPT OFFER\n', '    function acceptOffer(address _investor, uint _offerNumber) public sealed onlyOperator {\n', '        // REQUIRE THAT OFFER HAS NOT BEEN APPROVED\n', '        require(offers[_investor][_offerNumber].etherAmount > 0);\n', '        require(offers[_investor][_offerNumber].accepted != true);\n', '        // APPROVE OFFER\n', '        offers[_investor][_offerNumber].accepted = true;\n', '        // CALCULATE TOKENS\n', '        uint  _etherAmount = offers[_investor][_offerNumber].etherAmount;\n', '        uint _tokenAmount = offers[_investor][_offerNumber].tokenAmount;\n', '        require(token.balanceOf(address(this)) >= promisedTokens + _tokenAmount);\n', '        // CALCULATE COMMISSION\n', '        if (commissionOnInvestmentEth > 0 || commissionOnInvestmentJot > 0) {\n', '            uint etherCommission = _etherAmount.mul(commissionOnInvestmentEth).div(100);\n', '            uint jotCommission = _etherAmount.mul(commissionOnInvestmentJot).div(100);\n', '            _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\n', '            offers[_investor][_offerNumber].etherAmount = _etherAmount;\n', '\n', '            etherAllowance += etherCommission;\n', '            jotAllowance += jotCommission;\n', '        }\n', '        assignPartition(_investor, _etherAmount, _tokenAmount);\n', '        if (!(deals[_investor].sumEther > 0)) dealsList.push(_investor);\n', '        if (tokenReleaseAtStart == true) {\n', '            deals[_investor].tokenAllowance = _tokenAmount;\n', '        }\n', '\n', '        deals[_investor].sumEther += _etherAmount;\n', '        deals[_investor].sumToken += _tokenAmount;\n', '    \t// ADDS TO TOTALS\n', '    \tpromisedTokens += _tokenAmount;\n', '    \traisedEther += _etherAmount;\n', '    }\n', '\n', '    // TO START MILESTONE\n', '    function startMilestone() public sealed onlyOperator {\n', '        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\n', '        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\n', '        // require(!roundFailedToStart);\n', '        if (currentMilestone != 0 ) {require(milestones[currentMilestone-1].finishTime > 0);}\n', '        for (uint i=0; i < dealsList.length ; i++) {\n', '            address investor = dealsList[i];\n', '            if (deals[investor].disputing == false) {\n', '                if (deals[investor].verdictForInvestor != true) {\n', '                    ethForMilestone += etherPartition[investor][currentMilestone];\n', '                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\n', '                    if (tokenReleaseAtStart == false) {\n', '                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        milestones[currentMilestone].startTime = now;\n', '        currentMilestone +=1;\n', '        ethForMilestone = payCommission();\n', '\t//ethForMilestone = ethForMilestone.sub(ethAfterCommission);\n', '    }\n', '\n', '    // CALCULATES COMMISSION\n', '    function payCommission() internal returns(uint) {\n', '        if (commissionEth.length >= currentMilestone) {\n', '            uint ethCommission = raisedEther.mul(commissionEth[currentMilestone-1]).div(100);\n', '            uint jotCommission = raisedEther.mul(commissionJot[currentMilestone-1]).div(100);\n', '            etherAllowance += ethCommission;\n', '            jotAllowance += jotCommission;\n', '            return ethForMilestone.sub(ethCommission).sub(jotCommission);\n', '        } else {\n', '            return ethForMilestone;\n', '        }\n', '    }\n', '\n', '    // TO FINISH MILESTONE\n', '    function finishMilestone(string _result) public onlyOperator {\n', '        require(milestones[currentMilestone-1].finishTime == 0);\n', '        uint interval = now - milestones[currentMilestone-1].startTime;\n', '        require(interval > 1 weeks);\n', '        milestones[currentMilestone-1].finishTime = now;\n', '        milestones[currentMilestone-1].result = _result;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    //\n', '    // HELPERS -----------------------------------------------------------------\n', '    function failSafe() public onlyAdmin {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '\n', '    function milestonesLength() public view returns(uint) {\n', '        return milestones.length;\n', '    }\n', '\n', '    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\n', '        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\n', '\t\tuint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\n', '\t\tuint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\n', '\t\tuint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\n', '\t\tuint totalEtherInvestment;\n', '\t\tuint totalTokenInvestment;\n', '        for(uint i=currentMilestone; i<milestones.length; i++) {\n', '\t\t\tmilestoneEtherTarget = milestones[i].etherAmount;\n', '            milestoneTokenTarget = milestones[i].tokenAmount;\n', '\t\t\tmilestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\n', '\t\t\tmilestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\n', '\t\t\ttotalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\n', '\t\t\ttotalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\n', '            if (deals[_investor].sumEther > 0) {\n', '                etherPartition[_investor][i] += milestoneEtherAmount;\n', '    \t\t\ttokenPartition[_investor][i] += milestoneTokenAmount;\n', '            } else {\n', '                etherPartition[_investor].push(milestoneEtherAmount);\n', '    \t\t\ttokenPartition[_investor].push(milestoneTokenAmount);\n', '            }\n', '\n', '\t\t}\n', '        /* roundingErrors += _etherAmount - totalEtherInvestment; */\n', '\t\tetherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\n', '\t\ttokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\n', '    }\n', '\n', '    // VIEWS\n', '    function isDisputing(address _investor) public view returns(bool) {\n', '        return deals[_investor].disputing;\n', '    }\n', '\n', '    function investorExists(address _investor) public view returns(bool) {\n', '        if (deals[_investor].sumEther > 0) return true;\n', '        else return false;\n', '    }\n', '\n', '}\n', '\n', 'contract Arbitration is Owned {\n', '\n', '    address public operator;\n', '\n', '    uint public quorum = 3;\n', '\n', '    struct Dispute {\n', '        address icoRoundAddress;\n', '        address investorAddress;\n', '        bool pending;\n', '        uint timestamp;\n', '        uint milestone;\n', '        string reason;\n', '        uint votesForProject;\n', '        uint votesForInvestor;\n', '        // bool verdictForProject;\n', '        // bool verdictForInvestor;\n', '        mapping(address => bool) voters;\n', '    }\n', '    mapping(uint => Dispute) public disputes;\n', '\n', '    uint public disputeLength;\n', '\n', '    mapping(address => mapping(address => bool)) public arbiterPool;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        operator = msg.sender;\n', '    }\n', '\n', '    // OPERATOR\n', '    function setArbiters(address _icoRoundAddress, address[] _arbiters) only(owner) public {\n', '        for (uint i = 0; i < _arbiters.length ; i++) {\n', '            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\n', '        }\n', '    }\n', '\n', '    // ARBITER\n', '    function vote(uint _disputeId, bool _voteForInvestor) public {\n', '        require(disputes[_disputeId].pending == true);\n', '        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);\n', '        require(disputes[_disputeId].voters[msg.sender] != true);\n', '        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\n', '        else { disputes[_disputeId].votesForProject += 1; }\n', '        if (disputes[_disputeId].votesForInvestor == quorum) {\n', '            executeVerdict(_disputeId,true);\n', '        }\n', '        if (disputes[_disputeId].votesForProject == quorum) {\n', '            executeVerdict(_disputeId,false);\n', '        }\n', '        disputes[_disputeId].voters[msg.sender] == true;\n', '    }\n', '\n', '    // INVESTOR\n', '    function openDispute(address _icoRoundAddress, string _reason) public {\n', '        Cycle icoRound = Cycle(_icoRoundAddress);\n', '        uint milestoneDispute = icoRound.currentMilestone();\n', '        require(milestoneDispute > 0);\n', '        require(icoRound.investorExists(msg.sender) == true);\n', '        disputes[disputeLength].milestone = milestoneDispute;\n', '\n', '        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\n', '        disputes[disputeLength].investorAddress = msg.sender;\n', '        disputes[disputeLength].timestamp = now;\n', '        disputes[disputeLength].reason = _reason;\n', '        disputes[disputeLength].pending = true;\n', '\n', '        icoRound.disputeOpened(msg.sender);\n', '        disputeLength +=1;\n', '    }\n', '\n', '    // INTERNAL\n', '    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\n', '        disputes[_disputeId].pending = false;\n', '        uint milestoneDispute = disputes[_disputeId].milestone;\n', '        Cycle icoRound = Cycle(disputes[_disputeId].icoRoundAddress);\n', '        icoRound.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\n', '        //counter +=1;\n', '    }\n', '\n', '    function isPending(uint _disputedId) public view returns(bool) {\n', '        return disputes[_disputedId].pending;\n', '    }\n', '\n', '}\n', '\n', 'contract Jotter {\n', '    // for an ethToJot of 2,443.0336457941, Aug 21, 2018\n', '    Token public token;\n', '    uint public ethToJot = 2443;\n', '    address public owner;\n', '\n', '    constructor(address _jotAddress) public {\n', '        owner = msg.sender;\n', '        token = Token(_jotAddress);\n', '    }\n', '\n', '    function swapMe() public payable {\n', '        uint jot = msg.value * ethToJot;\n', '        require(token.transfer(owner,jot));\n', '    }\n', '    // In the future, this contract would call a trusted Oracle\n', '    // instead of being set by its owner\n', '    function setEth(uint _newEth) public {\n', '        require(msg.sender == owner);\n', '        ethToJot = _newEth;\n', '    }\n', '\n', '}\n', '\n', 'contract SwapperX {\n', '\n', '    // used to swap proxy token for real token\n', '    // must have real token balance in order to recieve swap\n', '\n', '    Token public proxyToken;\n', '    Token public token;\n', '\n', '    address public owner;\n', '\n', '    struct Swap {\n', '        address _from;\n', '        uint _amount;\n', '    }\n', '\n', '    Swap[] public swaps;\n', '\n', '    constructor(address _tokenAddress, address _proxyTokenAddress) public {\n', '        owner = msg.sender;\n', '        token = Token(_tokenAddress);\n', '        proxyToken = Token(_proxyTokenAddress);\n', '    }\n', '\n', '    // SWAPS PROXY TOKENS FOR ICO TOKENS\n', '    function swapMe() public {\n', '        uint allowance = proxyToken.allowance(msg.sender,address(this));\n', '        require(token.balanceOf(address(this)) >= allowance);\n', '        require(token.transfer(msg.sender, allowance));\n', '        require(proxyToken.transferFrom(msg.sender,address(this),allowance));\n', '        swaps.push(Swap(msg.sender,allowance));\n', '    }\n', '\n', '    // REFUNDS TOKEN HOLDERS ALLOWANCE\n', '    function returnMe() public {\n', '        uint allowance = proxyToken.allowance(msg.sender,address(this));\n', '        require(proxyToken.transferFrom(msg.sender,address(this),allowance));\n', '        require(proxyToken.transfer(msg.sender, allowance));\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '// File: contracts/ERC20Token.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address newOwner;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) only(owner) public {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() only(newOwner) public {\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '}\n', '\n', 'contract ERC20 is Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public totalSupply;\n', '    bool public isStarted = false;\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    modifier isStartedOnly() {\n', '        require(isStarted);\n', '        _;\n', '    }\n', '\n', '    modifier isNotStartedOnly() {\n', '        require(!isStarted);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract Token is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function start() public only(owner) isNotStartedOnly {\n', '        isStarted = true;\n', '    }\n', '\n', '    //================= Crowdsale Only =================\n', '    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '}\n', '\n', 'contract TokenWithoutStart is Owned {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint _amount) public only(owner) returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/CycleSet.sol\n', '\n', '// DEPLOYED BY JURY.ONLINE\n', 'contract ICO {\n', '    // GENERAL ICO PARAMS ------------------------------------------------------\n', '\n', '    string public name;\n', '\n', '    address public operator; // the ICO operator\n', '    address public projectWallet; // the wallet that receives ICO Funds\n', '    Token public token; // ICO token\n', '    address public juryOnlineWallet; // JuryOnline Wallet for commission\n', '    address public arbitrationAddress; // Address of Arbitration Contract\n', '    uint public currentCycle; // current cycle\n', '\n', '    struct Cycle {\n', '        bool exists;\n', '        bool approved;\n', '        address icoRoundAddress;\n', '    }\n', '\n', '    mapping(uint => Cycle) public cycles; // stores the approved Cycles\n', '\n', '    // DEPLOYED BY JURY.ONLINE\n', '    // PARAMS:\n', '    // address _operator\n', '    // address _projectWallet\n', '    // address _tokenAddress\n', '    // address _arbitrationAddress\n', '    // address _juryOnlineWallet\n', '    constructor(string _name, address _operator, address _projectWallet, address _tokenAddress, address _arbitrationAddress, address _juryOnlineWallet) public {\n', '        name = _name;\n', '        operator = _operator;\n', '        projectWallet = _projectWallet;\n', '        token = Token(_tokenAddress);\n', '        arbitrationAddress = _arbitrationAddress;\n', '        juryOnlineWallet = _juryOnlineWallet;\n', '    }\n', '\n', '    // CALLED BY CYCLE CONTRACT\n', '    function addRound() public {\n', '        cycles[currentCycle].exists = true;\n', '        cycles[currentCycle].icoRoundAddress = msg.sender;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR, approves CYCLE Contract and adds it to cycles\n', '    function approveRound(address _icoRoundAddress) public {\n', '        require(msg.sender == operator);\n', '        require(cycles[currentCycle].icoRoundAddress == _icoRoundAddress);\n', '        currentCycle +=1;\n', '    }\n', '\n', '}\n', '// DEPLOYED BY JURY.ONLINE\n', 'contract Cycle {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // GENERAL CYCLE VARIABLES -------------------------------------------------\n', '\n', '    address public juryOperator; // assists in operation\n', '    address public operator; // cycle operator, same as ICO operator\n', '    address public icoAddress; // to associate Cycle with ICO\n', '    address public juryOnlineWallet; // juryOnlineWallet for commission\n', '    address public projectWallet; // taken from ICO contract\n', '    address public arbitrationAddress; // taken from ICO contract\n', '    Token public token; // taken from ICO contract\n', '\n', '    address public jotter; // address for JOT commission\n', '\n', '    bool public saveMe; // if true, gives Jury.Online control of contract\n', '\n', '    struct Milestone {\n', '        uint etherAmount; //how many Ether is needed for this milestone\n', '        uint tokenAmount; //how many tokens releases this milestone\n', '        uint startTime; //real time when milestone has started, set upon start\n', '        uint finishTime; //real time when milestone has finished, set upon finish\n', '        uint duration; //assumed duration for milestone implementation, set upon milestone creation\n', '        string description;\n', '        string result;\n', '    }\n', '\n', '    Milestone[] public milestones; // List of Milestones\n', '    uint public currentMilestone;\n', '\n', '    uint public sealTimestamp; // the moment the Cycle is Sealed by operator\n', '\n', '    uint public ethForMilestone; // Amount to be withdraw by operator for each milestone\n', '    uint public postDisputeEth; // in case of dispute in favor of ico project\n', '\n', '    // INVESTOR struct stores information about each Investor\n', '    // Investor can have more than one deals, but only one right to dispute\n', '    struct Investor {\n', '        bool disputing;\n', '        uint tokenAllowance;\n', '        uint etherUsed;\n', '        uint sumEther;\n', '        uint sumToken;\n', '        bool verdictForProject;\n', '        bool verdictForInvestor;\n', '        uint numberOfDeals;\n', '    }\n', '\n', '    struct Deal {\n', '        address investor;\n', '        uint etherAmount;\n', '        uint tokenAmount;\n', '        bool accepted;\n', '    }\n', '\n', '    mapping(address => Investor) public deals; // map of information of investors with deals\n', '    address[] public dealsList; // list of investors with deals\n', '    mapping(address => mapping(uint => Deal)) public offers; // pending offers\n', '\n', '    // COMMISSION ARRAYS\n', '    // amounts stored as percentage\n', '    // If commissionOnInvestmentEth/Jot > 0, commission paid when investment is accepted\n', '    // If elements on commissionEth/Jot, each element is commission to corresponding milestone\n', '    // ETH commission is transferred to Jury.Online wallet\n', '    // JOT commission is transferred to a Jotter contract that swaps eth for jot\n', '    uint[] public commissionEth;\n', '    uint[] public commissionJot;\n', '    uint public commissionOnInvestmentEth;\n', '    uint public commissionOnInvestmentJot;\n', '    uint public etherAllowance; // Amount that Jury.Online can withdraw as commission in ETH\n', '    uint public jotAllowance; // Amount that Jury.Online can withdraw as commission in JOT\n', '\n', '    uint public totalEther; // Sum of ether in milestones\n', '    uint public totalToken; // Sum of tokens in milestones\n', '\n', '    uint public promisedTokens; // Sum of tokens promised by accepting offer\n', '    uint public raisedEther; // Sum of ether raised by accepting offer\n', '\n', '    uint public rate; // eth to token rate in current Funding Round\n', '    bool public tokenReleaseAtStart; // whether to release tokens at start or by each milestone\n', '    uint public currentFundingRound;\n', '\n', '    bool public roundFailedToStart;\n', '\n', '    // Stores amount of ether and tokens per milestone for each investor\n', '    mapping(address => uint[]) public etherPartition;\n', '    mapping(address => uint[]) public tokenPartition;\n', '\n', '    // Funding Rounds can be added with start, end time, rate, and whitelist\n', '    struct FundingRound {\n', '        uint startTime;\n', '        uint endTime;\n', '        uint rate;\n', '        bool hasWhitelist;\n', '    }\n', '\n', '    FundingRound[] public roundPrices;  // stores list of funding rounds\n', '    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists\n', '\n', '    // -------------------------------------------------------------------------\n', '    // MODIFIERS\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    modifier sealed() {\n', '        require(sealTimestamp != 0);\n', '        /* require(now > sealTimestamp); */\n', '        _;\n', '    }\n', '\n', '    modifier notSealed() {\n', '        require(sealTimestamp == 0);\n', '        /* require(now <= sealTimestamp); */\n', '        _;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // DEPLOYED BY JURY.ONLINE\n', '    // PARAMS:\n', '    // address _icoAddress\n', '    // address _operator\n', '    // uint _rate\n', '    // address _jotter\n', '    // uint[] _commissionEth\n', '    // uint[] _commissionJot\n', '    constructor( address _icoAddress,\n', '                 address _operator,\n', '                 uint _rate,\n', '                 address _jotter,\n', '                 uint[] _commissionEth,\n', '                 uint[] _commissionJot,\n', '                 uint _commissionOnInvestmentEth,\n', '                 uint _commissionOnInvestmentJot\n', '                 ) public {\n', '        require(_commissionEth.length == _commissionJot.length);\n', '        juryOperator = msg.sender;\n', '        icoAddress = _icoAddress;\n', '        operator = _operator;\n', '        rate = _rate;\n', '        jotter = _jotter;\n', '        commissionEth = _commissionEth;\n', '        commissionJot = _commissionJot;\n', '        roundPrices.push(FundingRound(0,0,0,false));\n', '        tokenReleaseAtStart = true;\n', '        commissionOnInvestmentEth = _commissionOnInvestmentEth;\n', '        commissionOnInvestmentJot = _commissionOnInvestmentJot;\n', '    }\n', '\n', '    // CALLED BY JURY.ONLINE TO SET JOTTER ADDRESS FOR JOT COMMISSION\n', '    function setJotter(address _jotter) public {\n', '        require(msg.sender == juryOperator);\n', '        jotter = _jotter;\n', '    }\n', '\n', '    // CALLED BY ADMIN TO RETRIEVE INFORMATION FROM ICOADDRESS AND ADD ITSELF\n', '    // TO LIST OF CYCLES IN ICO\n', '    function activate() onlyAdmin notSealed public {\n', '        ICO icoContract = ICO(icoAddress);\n', '        require(icoContract.operator() == operator);\n', '        juryOnlineWallet = icoContract.juryOnlineWallet();\n', '        projectWallet = icoContract.projectWallet();\n', '        arbitrationAddress = icoContract.arbitrationAddress();\n', '        token = icoContract.token();\n', '        icoContract.addRound();\n', '    }\n', '\n', '    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\n', '    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\n', '    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\n', '    function withdrawEther() public {\n', '        if (roundFailedToStart == true) {\n', '            require(msg.sender.send(deals[msg.sender].sumEther));\n', '        }\n', '        if (msg.sender == operator) {\n', '            require(projectWallet.send(ethForMilestone+postDisputeEth));\n', '            ethForMilestone = 0;\n', '            postDisputeEth = 0;\n', '        }\n', '        if (msg.sender == juryOnlineWallet) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '        if (deals[msg.sender].verdictForInvestor == true) {\n', '            require(msg.sender.send(deals[msg.sender].sumEther - deals[msg.sender].etherUsed));\n', '        }\n', '    }\n', '\n', '    // CALLED BY INVESTOR TO RETRIEVE TOKENS\n', '    function withdrawToken() public {\n', '        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\n', '        deals[msg.sender].tokenAllowance = 0;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO ADD FUNDING ROUNDS WITH _startTime,_endTime,_price,_whitelist\n', '    function addRoundPrice(uint _startTime,uint _endTime, uint _price, address[] _whitelist) public onlyOperator {\n', '        if (_whitelist.length == 0) {\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_price,false));\n', '        } else {\n', '            for (uint i=0 ; i < _whitelist.length ; i++ ) {\n', '                whitelist[roundPrices.length][_whitelist[i]] = true;\n', '            }\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_price,true));\n', '        }\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO SET RATE WITHOUT SETTING FUNDING ROUND\n', '    function setRate(uint _rate) onlyOperator public {\n', '        rate = _rate;\n', '    }\n', '\n', '    // CALLED BY ICO OPERATOR TO APPLY WHITELIST AND PRICE OF FUNDING ROUND\n', '    function setCurrentFundingRound(uint _fundingRound) public onlyOperator {\n', '        require(roundPrices.length > _fundingRound);\n', '        currentFundingRound = _fundingRound;\n', '        rate = roundPrices[_fundingRound].rate;\n', '    }\n', '\n', '    // RECEIVES FUNDS AND CREATES OFFER\n', '    function () public payable {\n', '        require(msg.value > 0);\n', '        if (roundPrices[currentFundingRound].hasWhitelist == true) {\n', '            require(whitelist[currentFundingRound][msg.sender] == true);\n', '        }\n', '        uint dealNumber = deals[msg.sender].numberOfDeals;\n', '        offers[msg.sender][dealNumber].investor = msg.sender;\n', '        offers[msg.sender][dealNumber].etherAmount = msg.value;\n', '        deals[msg.sender].numberOfDeals += 1;\n', '    }\n', '\n', '    // IF OFFER NOT ACCEPTED, CAN BE WITHDRAWN\n', '    function withdrawOffer(uint _offerNumber) public {\n', '        require(offers[msg.sender][_offerNumber].accepted == false);\n', '        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\n', '        offers[msg.sender][_offerNumber].etherAmount = 0;\n', '        /* offers[msg.sender][_offerNumber].tokenAmount = 0; */\n', '    }\n', '\n', '    // ARBITRATION\n', '    // CALLED BY ARBITRATION ADDRESS\n', '    function disputeOpened(address _investor) public {\n', '        require(msg.sender == arbitrationAddress);\n', '        deals[_investor].disputing = true;\n', '    }\n', '\n', '    // CALLED BY ARBITRATION ADDRESS\n', '    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public {\n', '        require(msg.sender == arbitrationAddress);\n', '        require(deals[_investor].disputing == true);\n', '        if (_verdictForInvestor) {\n', '            deals[_investor].verdictForInvestor = true;\n', '        } else {\n', '            deals[_investor].verdictForProject = true;\n', '            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\n', '                postDisputeEth += etherPartition[_investor][i];\n', '                deals[_investor].etherUsed += etherPartition[_investor][i];\n', '            }\n', '        }\n', '        deals[_investor].disputing = false;\n', '    }\n', '\n', '    // OPERATOR\n', '    // TO ADD MILESTONES\n', '    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyOperator returns(uint) {\n', '        totalEther = totalEther.add(_etherAmount);\n', '        totalToken = totalToken.add(_tokenAmount);\n', '        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, ""));\n', '    }\n', '\n', '    // TO EDIT MILESTONES\n', '    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyOperator {\n', '        assert(_id < milestones.length);\n', '        totalEther = (totalEther - milestones[_id].etherAmount).add(_etherAmount); //previous addition\n', '        totalToken = (totalToken - milestones[_id].tokenAmount).add(_tokenAmount);\n', '        milestones[_id].etherAmount = _etherAmount;\n', '        milestones[_id].tokenAmount = _tokenAmount;\n', '        milestones[_id].startTime = _startTime;\n', '        milestones[_id].duration = _duration;\n', '        milestones[_id].description = _description;\n', '    }\n', '\n', '    // TO SEAL\n', '    function seal() public notSealed onlyOperator {\n', '        require(milestones.length > 0);\n', '        require(token.balanceOf(address(this)) >= totalToken);\n', '        sealTimestamp = now;\n', '    }\n', '\n', '    // TO ACCEPT OFFER\n', '    function acceptOffer(address _investor, uint _offerNumber) public sealed onlyOperator {\n', '        // REQUIRE THAT OFFER HAS NOT BEEN APPROVED\n', '        require(offers[_investor][_offerNumber].etherAmount > 0);\n', '        require(offers[_investor][_offerNumber].accepted != true);\n', '        // APPROVE OFFER\n', '        offers[_investor][_offerNumber].accepted = true;\n', '        // CALCULATE TOKENS\n', '        uint  _etherAmount = offers[_investor][_offerNumber].etherAmount;\n', '        uint _tokenAmount = offers[_investor][_offerNumber].tokenAmount;\n', '        require(token.balanceOf(address(this)) >= promisedTokens + _tokenAmount);\n', '        // CALCULATE COMMISSION\n', '        if (commissionOnInvestmentEth > 0 || commissionOnInvestmentJot > 0) {\n', '            uint etherCommission = _etherAmount.mul(commissionOnInvestmentEth).div(100);\n', '            uint jotCommission = _etherAmount.mul(commissionOnInvestmentJot).div(100);\n', '            _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\n', '            offers[_investor][_offerNumber].etherAmount = _etherAmount;\n', '\n', '            etherAllowance += etherCommission;\n', '            jotAllowance += jotCommission;\n', '        }\n', '        assignPartition(_investor, _etherAmount, _tokenAmount);\n', '        if (!(deals[_investor].sumEther > 0)) dealsList.push(_investor);\n', '        if (tokenReleaseAtStart == true) {\n', '            deals[_investor].tokenAllowance = _tokenAmount;\n', '        }\n', '\n', '        deals[_investor].sumEther += _etherAmount;\n', '        deals[_investor].sumToken += _tokenAmount;\n', '    \t// ADDS TO TOTALS\n', '    \tpromisedTokens += _tokenAmount;\n', '    \traisedEther += _etherAmount;\n', '    }\n', '\n', '    // TO START MILESTONE\n', '    function startMilestone() public sealed onlyOperator {\n', '        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\n', '        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\n', '        // require(!roundFailedToStart);\n', '        if (currentMilestone != 0 ) {require(milestones[currentMilestone-1].finishTime > 0);}\n', '        for (uint i=0; i < dealsList.length ; i++) {\n', '            address investor = dealsList[i];\n', '            if (deals[investor].disputing == false) {\n', '                if (deals[investor].verdictForInvestor != true) {\n', '                    ethForMilestone += etherPartition[investor][currentMilestone];\n', '                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\n', '                    if (tokenReleaseAtStart == false) {\n', '                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        milestones[currentMilestone].startTime = now;\n', '        currentMilestone +=1;\n', '        ethForMilestone = payCommission();\n', '\t//ethForMilestone = ethForMilestone.sub(ethAfterCommission);\n', '    }\n', '\n', '    // CALCULATES COMMISSION\n', '    function payCommission() internal returns(uint) {\n', '        if (commissionEth.length >= currentMilestone) {\n', '            uint ethCommission = raisedEther.mul(commissionEth[currentMilestone-1]).div(100);\n', '            uint jotCommission = raisedEther.mul(commissionJot[currentMilestone-1]).div(100);\n', '            etherAllowance += ethCommission;\n', '            jotAllowance += jotCommission;\n', '            return ethForMilestone.sub(ethCommission).sub(jotCommission);\n', '        } else {\n', '            return ethForMilestone;\n', '        }\n', '    }\n', '\n', '    // TO FINISH MILESTONE\n', '    function finishMilestone(string _result) public onlyOperator {\n', '        require(milestones[currentMilestone-1].finishTime == 0);\n', '        uint interval = now - milestones[currentMilestone-1].startTime;\n', '        require(interval > 1 weeks);\n', '        milestones[currentMilestone-1].finishTime = now;\n', '        milestones[currentMilestone-1].result = _result;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    //\n', '    // HELPERS -----------------------------------------------------------------\n', '    function failSafe() public onlyAdmin {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '\n', '    function milestonesLength() public view returns(uint) {\n', '        return milestones.length;\n', '    }\n', '\n', '    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\n', '        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\n', '\t\tuint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\n', '\t\tuint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\n', '\t\tuint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\n', '\t\tuint totalEtherInvestment;\n', '\t\tuint totalTokenInvestment;\n', '        for(uint i=currentMilestone; i<milestones.length; i++) {\n', '\t\t\tmilestoneEtherTarget = milestones[i].etherAmount;\n', '            milestoneTokenTarget = milestones[i].tokenAmount;\n', '\t\t\tmilestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\n', '\t\t\tmilestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\n', '\t\t\ttotalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\n', '\t\t\ttotalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\n', '            if (deals[_investor].sumEther > 0) {\n', '                etherPartition[_investor][i] += milestoneEtherAmount;\n', '    \t\t\ttokenPartition[_investor][i] += milestoneTokenAmount;\n', '            } else {\n', '                etherPartition[_investor].push(milestoneEtherAmount);\n', '    \t\t\ttokenPartition[_investor].push(milestoneTokenAmount);\n', '            }\n', '\n', '\t\t}\n', '        /* roundingErrors += _etherAmount - totalEtherInvestment; */\n', '\t\tetherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\n', '\t\ttokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\n', '    }\n', '\n', '    // VIEWS\n', '    function isDisputing(address _investor) public view returns(bool) {\n', '        return deals[_investor].disputing;\n', '    }\n', '\n', '    function investorExists(address _investor) public view returns(bool) {\n', '        if (deals[_investor].sumEther > 0) return true;\n', '        else return false;\n', '    }\n', '\n', '}\n', '\n', 'contract Arbitration is Owned {\n', '\n', '    address public operator;\n', '\n', '    uint public quorum = 3;\n', '\n', '    struct Dispute {\n', '        address icoRoundAddress;\n', '        address investorAddress;\n', '        bool pending;\n', '        uint timestamp;\n', '        uint milestone;\n', '        string reason;\n', '        uint votesForProject;\n', '        uint votesForInvestor;\n', '        // bool verdictForProject;\n', '        // bool verdictForInvestor;\n', '        mapping(address => bool) voters;\n', '    }\n', '    mapping(uint => Dispute) public disputes;\n', '\n', '    uint public disputeLength;\n', '\n', '    mapping(address => mapping(address => bool)) public arbiterPool;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        operator = msg.sender;\n', '    }\n', '\n', '    // OPERATOR\n', '    function setArbiters(address _icoRoundAddress, address[] _arbiters) only(owner) public {\n', '        for (uint i = 0; i < _arbiters.length ; i++) {\n', '            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\n', '        }\n', '    }\n', '\n', '    // ARBITER\n', '    function vote(uint _disputeId, bool _voteForInvestor) public {\n', '        require(disputes[_disputeId].pending == true);\n', '        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);\n', '        require(disputes[_disputeId].voters[msg.sender] != true);\n', '        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\n', '        else { disputes[_disputeId].votesForProject += 1; }\n', '        if (disputes[_disputeId].votesForInvestor == quorum) {\n', '            executeVerdict(_disputeId,true);\n', '        }\n', '        if (disputes[_disputeId].votesForProject == quorum) {\n', '            executeVerdict(_disputeId,false);\n', '        }\n', '        disputes[_disputeId].voters[msg.sender] == true;\n', '    }\n', '\n', '    // INVESTOR\n', '    function openDispute(address _icoRoundAddress, string _reason) public {\n', '        Cycle icoRound = Cycle(_icoRoundAddress);\n', '        uint milestoneDispute = icoRound.currentMilestone();\n', '        require(milestoneDispute > 0);\n', '        require(icoRound.investorExists(msg.sender) == true);\n', '        disputes[disputeLength].milestone = milestoneDispute;\n', '\n', '        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\n', '        disputes[disputeLength].investorAddress = msg.sender;\n', '        disputes[disputeLength].timestamp = now;\n', '        disputes[disputeLength].reason = _reason;\n', '        disputes[disputeLength].pending = true;\n', '\n', '        icoRound.disputeOpened(msg.sender);\n', '        disputeLength +=1;\n', '    }\n', '\n', '    // INTERNAL\n', '    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\n', '        disputes[_disputeId].pending = false;\n', '        uint milestoneDispute = disputes[_disputeId].milestone;\n', '        Cycle icoRound = Cycle(disputes[_disputeId].icoRoundAddress);\n', '        icoRound.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\n', '        //counter +=1;\n', '    }\n', '\n', '    function isPending(uint _disputedId) public view returns(bool) {\n', '        return disputes[_disputedId].pending;\n', '    }\n', '\n', '}\n', '\n', 'contract Jotter {\n', '    // for an ethToJot of 2,443.0336457941, Aug 21, 2018\n', '    Token public token;\n', '    uint public ethToJot = 2443;\n', '    address public owner;\n', '\n', '    constructor(address _jotAddress) public {\n', '        owner = msg.sender;\n', '        token = Token(_jotAddress);\n', '    }\n', '\n', '    function swapMe() public payable {\n', '        uint jot = msg.value * ethToJot;\n', '        require(token.transfer(owner,jot));\n', '    }\n', '    // In the future, this contract would call a trusted Oracle\n', '    // instead of being set by its owner\n', '    function setEth(uint _newEth) public {\n', '        require(msg.sender == owner);\n', '        ethToJot = _newEth;\n', '    }\n', '\n', '}\n', '\n', 'contract SwapperX {\n', '\n', '    // used to swap proxy token for real token\n', '    // must have real token balance in order to recieve swap\n', '\n', '    Token public proxyToken;\n', '    Token public token;\n', '\n', '    address public owner;\n', '\n', '    struct Swap {\n', '        address _from;\n', '        uint _amount;\n', '    }\n', '\n', '    Swap[] public swaps;\n', '\n', '    constructor(address _tokenAddress, address _proxyTokenAddress) public {\n', '        owner = msg.sender;\n', '        token = Token(_tokenAddress);\n', '        proxyToken = Token(_proxyTokenAddress);\n', '    }\n', '\n', '    // SWAPS PROXY TOKENS FOR ICO TOKENS\n', '    function swapMe() public {\n', '        uint allowance = proxyToken.allowance(msg.sender,address(this));\n', '        require(token.balanceOf(address(this)) >= allowance);\n', '        require(token.transfer(msg.sender, allowance));\n', '        require(proxyToken.transferFrom(msg.sender,address(this),allowance));\n', '        swaps.push(Swap(msg.sender,allowance));\n', '    }\n', '\n', '    // REFUNDS TOKEN HOLDERS ALLOWANCE\n', '    function returnMe() public {\n', '        uint allowance = proxyToken.allowance(msg.sender,address(this));\n', '        require(proxyToken.transferFrom(msg.sender,address(this),allowance));\n', '        require(proxyToken.transfer(msg.sender, allowance));\n', '    }\n', '\n', '}']
