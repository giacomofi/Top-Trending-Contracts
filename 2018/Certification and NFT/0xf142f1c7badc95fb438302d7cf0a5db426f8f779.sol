['pragma solidity ^0.4.21;\n', 'contract TripioToken {\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '}\n', '/**\n', ' * Owned contract\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Only the owner of contract\n', '     */ \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * transfer the ownership to other\n', '     * - Only the owner can operate\n', '     */ \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /** \n', '     * Accept the ownership from last owner\n', '     */ \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'contract TPTData {\n', '    address public trioContract;\n', '\n', '    struct Contributor {\n', '        uint256 next;\n', '        uint256 prev;\n', '        uint256 cid;\n', '        address contributor;\n', '        bytes32 name;\n', '    }\n', '    \n', '    struct ContributorChain {\n', '        uint256 balance;\n', '        uint256 head;\n', '        uint256 tail;\n', '        uint256 index;\n', '        mapping(uint256 => Contributor) nodes; // cid -> Contributor\n', '    }\n', '\n', '    struct Schedule {\n', '        uint256 next;\n', '        uint256 prev;\n', '        uint256 sid;\n', '        uint32 timestamp;\n', '        uint256 trio;\n', '    }\n', '\n', '    struct ScheduleChain {\n', '        uint256 balance;\n', '        uint256 head;\n', '        uint256 tail;\n', '        uint256 index;\n', '        mapping (uint256 => Schedule) nodes;\n', '    }\n', '\n', '    // The contributors chain\n', '    ContributorChain contributorChain;\n', '\n', '    // The schedules chains\n', '    mapping (uint256 => ScheduleChain) scheduleChains;\n', '\n', '    /**\n', '     * The contributor is valid\n', '     */\n', '    modifier contributorValid(uint256 _cid) {\n', '        require(contributorChain.nodes[_cid].cid == _cid);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * The schedule is valid\n', '     */\n', '    modifier scheduleValid(uint256 _cid, uint256 _sid) {\n', '        require(scheduleChains[_cid].nodes[_sid].sid == _sid);\n', '        _;\n', '    }\n', '}\n', 'contract TPTContributors is TPTData, Owned {\n', '    function TPTContributors() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when contributors are added\n', '     */\n', '    event ContributorsAdded(address[] indexed _contributors);\n', '\n', '    /**\n', '     * This emits when contributors are removed\n', '     */\n', '    event ContributorsRemoved(uint256[] indexed _cids);\n', '\n', '\n', '    /**\n', '     * Record `_contributor`\n', '     */\n', '    function _pushContributor(address _contributor, bytes32 _name) internal {\n', '        require(_contributor != address(0));\n', '        uint256 prev = 0;\n', '        uint256 cid = contributorChain.index + 1;\n', '        if (contributorChain.balance == 0) {\n', '            contributorChain = ContributorChain(1, cid, cid, cid);\n', '            contributorChain.nodes[cid] = Contributor(0, 0, cid, _contributor, _name);\n', '        } else {\n', '            contributorChain.index = cid;\n', '            prev = contributorChain.tail;\n', '            contributorChain.balance++;\n', '\n', '            contributorChain.nodes[cid] = Contributor(0, prev, cid, _contributor, _name);\n', '            contributorChain.nodes[prev].next = cid;\n', '            contributorChain.tail = cid;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Remove contributor by `_cid`\n', '     */\n', '    function _removeContributor(uint _cid) internal contributorValid(_cid) {\n', '        require(_cid != 0);\n', '        uint256 next = 0;\n', '        uint256 prev = 0;\n', '        require(contributorChain.nodes[_cid].cid == _cid);\n', '        next = contributorChain.nodes[_cid].next;\n', '        prev = contributorChain.nodes[_cid].prev;\n', '        if (next == 0) {\n', '            if(prev != 0) {\n', '                contributorChain.nodes[prev].next = 0;\n', '                delete contributorChain.nodes[_cid];\n', '                contributorChain.tail = prev;\n', '            }else {\n', '                delete contributorChain.nodes[_cid];\n', '                delete contributorChain;\n', '            }\n', '        } else {\n', '            if (prev == 0) {\n', '                contributorChain.head = next;\n', '                contributorChain.nodes[next].prev = 0;\n', '                delete contributorChain.nodes[_cid];\n', '            } else {\n', '                contributorChain.nodes[prev].next = next;\n', '                contributorChain.nodes[next].prev = prev;\n', '                delete contributorChain.nodes[_cid];\n', '            }\n', '        }\n', '        if(contributorChain.balance > 0) {\n', '            contributorChain.balance--;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Record `_contributors`\n', '     * @param _contributors The contributor\n', '     */\n', '    function addContributors(address[] _contributors, bytes32[] _names) external onlyOwner {\n', '        require(_contributors.length == _names.length && _contributors.length > 0);\n', '        for(uint256 i = 0; i < _contributors.length; i++) {\n', '            _pushContributor(_contributors[i], _names[i]);\n', '        }\n', '\n', '        // Event\n', '        emit ContributorsAdded(_contributors);\n', '    }\n', '\n', '    /**\n', '     * Remove contributor by `_cids`\n', '     * @param _cids The contributor&#39;s ids\n', '     */\n', '    function removeContributors(uint256[] _cids) external onlyOwner {\n', '        for(uint256 i = 0; i < _cids.length; i++) {\n', '            _removeContributor(_cids[i]);\n', '        }\n', '\n', '        // Event\n', '        emit ContributorsRemoved(_cids);\n', '    }\n', '\n', '    /**\n', '     * Returns all the contributors\n', '     * @return All the contributors\n', '     */\n', '    function contributors() public view returns(uint256[]) {\n', '        uint256 count;\n', '        uint256 index;\n', '        uint256 next;\n', '        index = 0;\n', '        next = contributorChain.head;\n', '        count = contributorChain.balance;\n', '        if (count > 0) {\n', '            uint256[] memory result = new uint256[](count);\n', '            while(next != 0 && index < count) {\n', '                result[index] = contributorChain.nodes[next].cid;\n', '                next = contributorChain.nodes[next].next;\n', '                index++;\n', '            }\n', '            return result;\n', '        } else {\n', '            return new uint256[](0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the contributor by `_cid`\n', '     * @return The contributor\n', '     */\n', '    function contributor(uint _cid) external view returns(address, bytes32) {\n', '        return (contributorChain.nodes[_cid].contributor, contributorChain.nodes[_cid].name);\n', '    }  \n', '}\n', 'contract TPTSchedules is TPTData, Owned {\n', '    function TPTSchedules() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when schedules are inserted\n', '     */\n', '    event SchedulesInserted(uint256 _cid);\n', '\n', '    /**\n', '     * This emits when schedules are removed\n', '     */\n', '    event SchedulesRemoved(uint _cid, uint256[] _sids);\n', '\n', '    /**\n', '     * Record TRIO transfer schedule to  `_contributor`\n', '     * @param _cid The contributor\n', '     * @param _timestamps The transfer timestamps\n', '     * @param _trios The transfer trios\n', '     */\n', '    function insertSchedules(uint256 _cid, uint32[] _timestamps, uint256[] _trios) \n', '        external \n', '        onlyOwner \n', '        contributorValid(_cid) {\n', '        require(_timestamps.length > 0 && _timestamps.length == _trios.length);\n', '        for (uint256 i = 0; i < _timestamps.length; i++) {\n', '            uint256 prev = 0;\n', '            uint256 next = 0;\n', '            uint256 sid = scheduleChains[_cid].index + 1;\n', '            if (scheduleChains[_cid].balance == 0) {\n', '                scheduleChains[_cid] = ScheduleChain(1, sid, sid, sid);\n', '                scheduleChains[_cid].nodes[sid] = Schedule(0, 0, sid, _timestamps[i], _trios[i]);\n', '            } else {\n', '                scheduleChains[_cid].index = sid;\n', '                scheduleChains[_cid].balance++;\n', '                prev = scheduleChains[_cid].tail;\n', '                while(scheduleChains[_cid].nodes[prev].timestamp > _timestamps[i] && prev != 0) {\n', '                    prev = scheduleChains[_cid].nodes[prev].prev;\n', '                }\n', '                if (prev == 0) {\n', '                    next = scheduleChains[_cid].head;\n', '                    scheduleChains[_cid].nodes[sid] = Schedule(next, 0, sid, _timestamps[i], _trios[i]);\n', '                    scheduleChains[_cid].nodes[next].prev = sid;\n', '                    scheduleChains[_cid].head = sid;\n', '                } else {\n', '                    next = scheduleChains[_cid].nodes[prev].next;\n', '                    scheduleChains[_cid].nodes[sid] = Schedule(next, prev, sid, _timestamps[i], _trios[i]);\n', '                    scheduleChains[_cid].nodes[prev].next = sid;\n', '                    if (next == 0) {\n', '                        scheduleChains[_cid].tail = sid;\n', '                    }else {\n', '                        scheduleChains[_cid].nodes[next].prev = sid;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Event\n', '        emit SchedulesInserted(_cid);\n', '    }\n', '\n', '    /**\n', '     * Remove schedule by `_cid` and `_sids`\n', '     * @param _cid The contributor&#39;s id\n', '     * @param _sids The schedule&#39;s ids\n', '     */\n', '    function removeSchedules(uint _cid, uint256[] _sids) \n', '        public \n', '        onlyOwner \n', '        contributorValid(_cid) {\n', '        uint256 next = 0;\n', '        uint256 prev = 0;\n', '        uint256 sid;\n', '        for (uint256 i = 0; i < _sids.length; i++) {\n', '            sid = _sids[i];\n', '            require(scheduleChains[_cid].nodes[sid].sid == sid);\n', '            next = scheduleChains[_cid].nodes[sid].next;\n', '            prev = scheduleChains[_cid].nodes[sid].prev;\n', '            if (next == 0) {\n', '                if(prev != 0) {\n', '                    scheduleChains[_cid].nodes[prev].next = 0;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                    scheduleChains[_cid].tail = prev;\n', '                }else {\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                    delete scheduleChains[_cid];\n', '                }\n', '            } else {\n', '                if (prev == 0) {\n', '                    scheduleChains[_cid].head = next;\n', '                    scheduleChains[_cid].nodes[next].prev = 0;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                } else {\n', '                    scheduleChains[_cid].nodes[prev].next = next;\n', '                    scheduleChains[_cid].nodes[next].prev = prev;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                }\n', '            }\n', '            if(scheduleChains[_cid].balance > 0) {\n', '                scheduleChains[_cid].balance--;\n', '            }   \n', '        }\n', '\n', '        // Event\n', '        emit SchedulesRemoved(_cid, _sids);\n', '    }\n', '\n', '    /**\n', '     * Return all the schedules of `_cid`\n', '     * @param _cid The contributor&#39;s id \n', '     * @return All the schedules of `_cid`\n', '     */\n', '    function schedules(uint256 _cid) \n', '        public \n', '        contributorValid(_cid) \n', '        view \n', '        returns(uint256[]) {\n', '        uint256 count;\n', '        uint256 index;\n', '        uint256 next;\n', '        index = 0;\n', '        next = scheduleChains[_cid].head;\n', '        count = scheduleChains[_cid].balance;\n', '        if (count > 0) {\n', '            uint256[] memory result = new uint256[](count);\n', '            while(next != 0 && index < count) {\n', '                result[index] = scheduleChains[_cid].nodes[next].sid;\n', '                next = scheduleChains[_cid].nodes[next].next;\n', '                index++;\n', '            }\n', '            return result;\n', '        } else {\n', '            return new uint256[](0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the schedule by `_cid` and `_sid`\n', '     * @param _cid The contributor&#39;s id\n', '     * @param _sid The schedule&#39;s id\n', '     * @return The schedule\n', '     */\n', '    function schedule(uint256 _cid, uint256 _sid) \n', '        public\n', '        scheduleValid(_cid, _sid) \n', '        view \n', '        returns(uint32, uint256) {\n', '        return (scheduleChains[_cid].nodes[_sid].timestamp, scheduleChains[_cid].nodes[_sid].trio);\n', '    }\n', '}\n', 'contract TPTTransfer is TPTContributors, TPTSchedules {\n', '    function TPTTransfer() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when transfer \n', '     */\n', '    event AutoTransfer(address indexed _to, uint256 _trio);\n', '\n', '    /**\n', '     * This emits when \n', '     */\n', '    event AutoTransferCompleted();\n', '\n', '    /**\n', '     * Withdraw TRIO TOKEN balance from contract account, the balance will transfer to the contract owner\n', '     */\n', '    function withdrawToken() external onlyOwner {\n', '        TripioToken tripio = TripioToken(trioContract);\n', '        uint256 tokens = tripio.balanceOf(address(this));\n', '        tripio.transfer(owner, tokens);\n', '    }\n', '\n', '    /**\n', '     * Auto Transfer All Schedules\n', '     */\n', '    function autoTransfer() external onlyOwner {\n', '        // TRIO contract\n', '        TripioToken tripio = TripioToken(trioContract);\n', '        \n', '        // All contributors\n', '        uint256[] memory _contributors = contributors();\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            // cid and contributor address\n', '            uint256 _cid = _contributors[i];\n', '            address _contributor = contributorChain.nodes[_cid].contributor;\n', '            \n', '            // All schedules\n', '            uint256[] memory _schedules = schedules(_cid);\n', '            for (uint256 j = 0; j < _schedules.length; j++) {\n', '                // sid, trio and timestamp\n', '                uint256 _sid = _schedules[j];\n', '                uint256 _trio = scheduleChains[_cid].nodes[_sid].trio;\n', '                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\n', '\n', '                // hasn&#39;t arrived\n', '                if(_timestamp > now) {\n', '                    break;\n', '                }\n', '                // Transfer TRIO to contributor\n', '                tripio.transfer(_contributor, _trio);\n', '\n', '                // Remove schedule of contributor\n', '                uint256[] memory _sids = new uint256[](1);\n', '                _sids[0] = _sid;\n', '                removeSchedules(_cid, _sids);\n', '                emit AutoTransfer(_contributor, _trio);\n', '            }\n', '        }\n', '\n', '        emit AutoTransferCompleted();\n', '    }\n', '\n', '    /**\n', '     * Is there any transfer in schedule\n', '     */\n', '    function totalTransfersInSchedule() external view returns(uint256,uint256) {\n', '        // All contributors\n', '        uint256[] memory _contributors = contributors();\n', '        uint256 total = 0;\n', '        uint256 amount = 0;\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            // cid and contributor address\n', '            uint256 _cid = _contributors[i];            \n', '            // All schedules\n', '            uint256[] memory _schedules = schedules(_cid);\n', '            for (uint256 j = 0; j < _schedules.length; j++) {\n', '                // sid, trio and timestamp\n', '                uint256 _sid = _schedules[j];\n', '                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\n', '                if(_timestamp < now) {\n', '                    total++;\n', '                    amount += scheduleChains[_cid].nodes[_sid].trio;\n', '                }\n', '            }\n', '        }\n', '        return (total,amount);\n', '    }\n', '}\n', '\n', 'contract TrioPeriodicTransfer is TPTTransfer {\n', '    function TrioPeriodicTransfer(address _trio) public {\n', '        trioContract = _trio;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', 'contract TripioToken {\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '}\n', '/**\n', ' * Owned contract\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Only the owner of contract\n', '     */ \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * transfer the ownership to other\n', '     * - Only the owner can operate\n', '     */ \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /** \n', '     * Accept the ownership from last owner\n', '     */ \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', 'contract TPTData {\n', '    address public trioContract;\n', '\n', '    struct Contributor {\n', '        uint256 next;\n', '        uint256 prev;\n', '        uint256 cid;\n', '        address contributor;\n', '        bytes32 name;\n', '    }\n', '    \n', '    struct ContributorChain {\n', '        uint256 balance;\n', '        uint256 head;\n', '        uint256 tail;\n', '        uint256 index;\n', '        mapping(uint256 => Contributor) nodes; // cid -> Contributor\n', '    }\n', '\n', '    struct Schedule {\n', '        uint256 next;\n', '        uint256 prev;\n', '        uint256 sid;\n', '        uint32 timestamp;\n', '        uint256 trio;\n', '    }\n', '\n', '    struct ScheduleChain {\n', '        uint256 balance;\n', '        uint256 head;\n', '        uint256 tail;\n', '        uint256 index;\n', '        mapping (uint256 => Schedule) nodes;\n', '    }\n', '\n', '    // The contributors chain\n', '    ContributorChain contributorChain;\n', '\n', '    // The schedules chains\n', '    mapping (uint256 => ScheduleChain) scheduleChains;\n', '\n', '    /**\n', '     * The contributor is valid\n', '     */\n', '    modifier contributorValid(uint256 _cid) {\n', '        require(contributorChain.nodes[_cid].cid == _cid);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * The schedule is valid\n', '     */\n', '    modifier scheduleValid(uint256 _cid, uint256 _sid) {\n', '        require(scheduleChains[_cid].nodes[_sid].sid == _sid);\n', '        _;\n', '    }\n', '}\n', 'contract TPTContributors is TPTData, Owned {\n', '    function TPTContributors() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when contributors are added\n', '     */\n', '    event ContributorsAdded(address[] indexed _contributors);\n', '\n', '    /**\n', '     * This emits when contributors are removed\n', '     */\n', '    event ContributorsRemoved(uint256[] indexed _cids);\n', '\n', '\n', '    /**\n', '     * Record `_contributor`\n', '     */\n', '    function _pushContributor(address _contributor, bytes32 _name) internal {\n', '        require(_contributor != address(0));\n', '        uint256 prev = 0;\n', '        uint256 cid = contributorChain.index + 1;\n', '        if (contributorChain.balance == 0) {\n', '            contributorChain = ContributorChain(1, cid, cid, cid);\n', '            contributorChain.nodes[cid] = Contributor(0, 0, cid, _contributor, _name);\n', '        } else {\n', '            contributorChain.index = cid;\n', '            prev = contributorChain.tail;\n', '            contributorChain.balance++;\n', '\n', '            contributorChain.nodes[cid] = Contributor(0, prev, cid, _contributor, _name);\n', '            contributorChain.nodes[prev].next = cid;\n', '            contributorChain.tail = cid;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Remove contributor by `_cid`\n', '     */\n', '    function _removeContributor(uint _cid) internal contributorValid(_cid) {\n', '        require(_cid != 0);\n', '        uint256 next = 0;\n', '        uint256 prev = 0;\n', '        require(contributorChain.nodes[_cid].cid == _cid);\n', '        next = contributorChain.nodes[_cid].next;\n', '        prev = contributorChain.nodes[_cid].prev;\n', '        if (next == 0) {\n', '            if(prev != 0) {\n', '                contributorChain.nodes[prev].next = 0;\n', '                delete contributorChain.nodes[_cid];\n', '                contributorChain.tail = prev;\n', '            }else {\n', '                delete contributorChain.nodes[_cid];\n', '                delete contributorChain;\n', '            }\n', '        } else {\n', '            if (prev == 0) {\n', '                contributorChain.head = next;\n', '                contributorChain.nodes[next].prev = 0;\n', '                delete contributorChain.nodes[_cid];\n', '            } else {\n', '                contributorChain.nodes[prev].next = next;\n', '                contributorChain.nodes[next].prev = prev;\n', '                delete contributorChain.nodes[_cid];\n', '            }\n', '        }\n', '        if(contributorChain.balance > 0) {\n', '            contributorChain.balance--;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Record `_contributors`\n', '     * @param _contributors The contributor\n', '     */\n', '    function addContributors(address[] _contributors, bytes32[] _names) external onlyOwner {\n', '        require(_contributors.length == _names.length && _contributors.length > 0);\n', '        for(uint256 i = 0; i < _contributors.length; i++) {\n', '            _pushContributor(_contributors[i], _names[i]);\n', '        }\n', '\n', '        // Event\n', '        emit ContributorsAdded(_contributors);\n', '    }\n', '\n', '    /**\n', '     * Remove contributor by `_cids`\n', "     * @param _cids The contributor's ids\n", '     */\n', '    function removeContributors(uint256[] _cids) external onlyOwner {\n', '        for(uint256 i = 0; i < _cids.length; i++) {\n', '            _removeContributor(_cids[i]);\n', '        }\n', '\n', '        // Event\n', '        emit ContributorsRemoved(_cids);\n', '    }\n', '\n', '    /**\n', '     * Returns all the contributors\n', '     * @return All the contributors\n', '     */\n', '    function contributors() public view returns(uint256[]) {\n', '        uint256 count;\n', '        uint256 index;\n', '        uint256 next;\n', '        index = 0;\n', '        next = contributorChain.head;\n', '        count = contributorChain.balance;\n', '        if (count > 0) {\n', '            uint256[] memory result = new uint256[](count);\n', '            while(next != 0 && index < count) {\n', '                result[index] = contributorChain.nodes[next].cid;\n', '                next = contributorChain.nodes[next].next;\n', '                index++;\n', '            }\n', '            return result;\n', '        } else {\n', '            return new uint256[](0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the contributor by `_cid`\n', '     * @return The contributor\n', '     */\n', '    function contributor(uint _cid) external view returns(address, bytes32) {\n', '        return (contributorChain.nodes[_cid].contributor, contributorChain.nodes[_cid].name);\n', '    }  \n', '}\n', 'contract TPTSchedules is TPTData, Owned {\n', '    function TPTSchedules() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when schedules are inserted\n', '     */\n', '    event SchedulesInserted(uint256 _cid);\n', '\n', '    /**\n', '     * This emits when schedules are removed\n', '     */\n', '    event SchedulesRemoved(uint _cid, uint256[] _sids);\n', '\n', '    /**\n', '     * Record TRIO transfer schedule to  `_contributor`\n', '     * @param _cid The contributor\n', '     * @param _timestamps The transfer timestamps\n', '     * @param _trios The transfer trios\n', '     */\n', '    function insertSchedules(uint256 _cid, uint32[] _timestamps, uint256[] _trios) \n', '        external \n', '        onlyOwner \n', '        contributorValid(_cid) {\n', '        require(_timestamps.length > 0 && _timestamps.length == _trios.length);\n', '        for (uint256 i = 0; i < _timestamps.length; i++) {\n', '            uint256 prev = 0;\n', '            uint256 next = 0;\n', '            uint256 sid = scheduleChains[_cid].index + 1;\n', '            if (scheduleChains[_cid].balance == 0) {\n', '                scheduleChains[_cid] = ScheduleChain(1, sid, sid, sid);\n', '                scheduleChains[_cid].nodes[sid] = Schedule(0, 0, sid, _timestamps[i], _trios[i]);\n', '            } else {\n', '                scheduleChains[_cid].index = sid;\n', '                scheduleChains[_cid].balance++;\n', '                prev = scheduleChains[_cid].tail;\n', '                while(scheduleChains[_cid].nodes[prev].timestamp > _timestamps[i] && prev != 0) {\n', '                    prev = scheduleChains[_cid].nodes[prev].prev;\n', '                }\n', '                if (prev == 0) {\n', '                    next = scheduleChains[_cid].head;\n', '                    scheduleChains[_cid].nodes[sid] = Schedule(next, 0, sid, _timestamps[i], _trios[i]);\n', '                    scheduleChains[_cid].nodes[next].prev = sid;\n', '                    scheduleChains[_cid].head = sid;\n', '                } else {\n', '                    next = scheduleChains[_cid].nodes[prev].next;\n', '                    scheduleChains[_cid].nodes[sid] = Schedule(next, prev, sid, _timestamps[i], _trios[i]);\n', '                    scheduleChains[_cid].nodes[prev].next = sid;\n', '                    if (next == 0) {\n', '                        scheduleChains[_cid].tail = sid;\n', '                    }else {\n', '                        scheduleChains[_cid].nodes[next].prev = sid;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        // Event\n', '        emit SchedulesInserted(_cid);\n', '    }\n', '\n', '    /**\n', '     * Remove schedule by `_cid` and `_sids`\n', "     * @param _cid The contributor's id\n", "     * @param _sids The schedule's ids\n", '     */\n', '    function removeSchedules(uint _cid, uint256[] _sids) \n', '        public \n', '        onlyOwner \n', '        contributorValid(_cid) {\n', '        uint256 next = 0;\n', '        uint256 prev = 0;\n', '        uint256 sid;\n', '        for (uint256 i = 0; i < _sids.length; i++) {\n', '            sid = _sids[i];\n', '            require(scheduleChains[_cid].nodes[sid].sid == sid);\n', '            next = scheduleChains[_cid].nodes[sid].next;\n', '            prev = scheduleChains[_cid].nodes[sid].prev;\n', '            if (next == 0) {\n', '                if(prev != 0) {\n', '                    scheduleChains[_cid].nodes[prev].next = 0;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                    scheduleChains[_cid].tail = prev;\n', '                }else {\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                    delete scheduleChains[_cid];\n', '                }\n', '            } else {\n', '                if (prev == 0) {\n', '                    scheduleChains[_cid].head = next;\n', '                    scheduleChains[_cid].nodes[next].prev = 0;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                } else {\n', '                    scheduleChains[_cid].nodes[prev].next = next;\n', '                    scheduleChains[_cid].nodes[next].prev = prev;\n', '                    delete scheduleChains[_cid].nodes[sid];\n', '                }\n', '            }\n', '            if(scheduleChains[_cid].balance > 0) {\n', '                scheduleChains[_cid].balance--;\n', '            }   \n', '        }\n', '\n', '        // Event\n', '        emit SchedulesRemoved(_cid, _sids);\n', '    }\n', '\n', '    /**\n', '     * Return all the schedules of `_cid`\n', "     * @param _cid The contributor's id \n", '     * @return All the schedules of `_cid`\n', '     */\n', '    function schedules(uint256 _cid) \n', '        public \n', '        contributorValid(_cid) \n', '        view \n', '        returns(uint256[]) {\n', '        uint256 count;\n', '        uint256 index;\n', '        uint256 next;\n', '        index = 0;\n', '        next = scheduleChains[_cid].head;\n', '        count = scheduleChains[_cid].balance;\n', '        if (count > 0) {\n', '            uint256[] memory result = new uint256[](count);\n', '            while(next != 0 && index < count) {\n', '                result[index] = scheduleChains[_cid].nodes[next].sid;\n', '                next = scheduleChains[_cid].nodes[next].next;\n', '                index++;\n', '            }\n', '            return result;\n', '        } else {\n', '            return new uint256[](0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the schedule by `_cid` and `_sid`\n', "     * @param _cid The contributor's id\n", "     * @param _sid The schedule's id\n", '     * @return The schedule\n', '     */\n', '    function schedule(uint256 _cid, uint256 _sid) \n', '        public\n', '        scheduleValid(_cid, _sid) \n', '        view \n', '        returns(uint32, uint256) {\n', '        return (scheduleChains[_cid].nodes[_sid].timestamp, scheduleChains[_cid].nodes[_sid].trio);\n', '    }\n', '}\n', 'contract TPTTransfer is TPTContributors, TPTSchedules {\n', '    function TPTTransfer() public {\n', '        \n', '    }\n', '\n', '    /**\n', '     * This emits when transfer \n', '     */\n', '    event AutoTransfer(address indexed _to, uint256 _trio);\n', '\n', '    /**\n', '     * This emits when \n', '     */\n', '    event AutoTransferCompleted();\n', '\n', '    /**\n', '     * Withdraw TRIO TOKEN balance from contract account, the balance will transfer to the contract owner\n', '     */\n', '    function withdrawToken() external onlyOwner {\n', '        TripioToken tripio = TripioToken(trioContract);\n', '        uint256 tokens = tripio.balanceOf(address(this));\n', '        tripio.transfer(owner, tokens);\n', '    }\n', '\n', '    /**\n', '     * Auto Transfer All Schedules\n', '     */\n', '    function autoTransfer() external onlyOwner {\n', '        // TRIO contract\n', '        TripioToken tripio = TripioToken(trioContract);\n', '        \n', '        // All contributors\n', '        uint256[] memory _contributors = contributors();\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            // cid and contributor address\n', '            uint256 _cid = _contributors[i];\n', '            address _contributor = contributorChain.nodes[_cid].contributor;\n', '            \n', '            // All schedules\n', '            uint256[] memory _schedules = schedules(_cid);\n', '            for (uint256 j = 0; j < _schedules.length; j++) {\n', '                // sid, trio and timestamp\n', '                uint256 _sid = _schedules[j];\n', '                uint256 _trio = scheduleChains[_cid].nodes[_sid].trio;\n', '                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\n', '\n', "                // hasn't arrived\n", '                if(_timestamp > now) {\n', '                    break;\n', '                }\n', '                // Transfer TRIO to contributor\n', '                tripio.transfer(_contributor, _trio);\n', '\n', '                // Remove schedule of contributor\n', '                uint256[] memory _sids = new uint256[](1);\n', '                _sids[0] = _sid;\n', '                removeSchedules(_cid, _sids);\n', '                emit AutoTransfer(_contributor, _trio);\n', '            }\n', '        }\n', '\n', '        emit AutoTransferCompleted();\n', '    }\n', '\n', '    /**\n', '     * Is there any transfer in schedule\n', '     */\n', '    function totalTransfersInSchedule() external view returns(uint256,uint256) {\n', '        // All contributors\n', '        uint256[] memory _contributors = contributors();\n', '        uint256 total = 0;\n', '        uint256 amount = 0;\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            // cid and contributor address\n', '            uint256 _cid = _contributors[i];            \n', '            // All schedules\n', '            uint256[] memory _schedules = schedules(_cid);\n', '            for (uint256 j = 0; j < _schedules.length; j++) {\n', '                // sid, trio and timestamp\n', '                uint256 _sid = _schedules[j];\n', '                uint256 _timestamp = scheduleChains[_cid].nodes[_sid].timestamp;\n', '                if(_timestamp < now) {\n', '                    total++;\n', '                    amount += scheduleChains[_cid].nodes[_sid].trio;\n', '                }\n', '            }\n', '        }\n', '        return (total,amount);\n', '    }\n', '}\n', '\n', 'contract TrioPeriodicTransfer is TPTTransfer {\n', '    function TrioPeriodicTransfer(address _trio) public {\n', '        trioContract = _trio;\n', '    }\n', '}']
