['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '     emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) external  returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function decimals()external view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner once sale ends\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '   \n', '    event Withdrawn(address _wallet);\n', '         \n', '    constructor (address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '    \n', '    function withdrawToWallet() onlyOwner public{\n', '    \n', '    wallet.transfer(address(this).balance);\n', '     emit Withdrawn(wallet);\n', '  }\n', '}\n', '\n', '\n', 'contract ESTTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '\n', '     // This mapping stores the addresses of whitelisted users\n', '      mapping(address => bool) public whitelisted;\n', '  \n', '      //rate of token :  1 EST = 0.00005804 ETH\n', '      uint256 public rate = 58040000000000;\n', '      /*\n', '      *There will be 4 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      * 3. ICO Phase 2\n', '      * 4. ICO Phase 3\n', '      */\n', '      struct PhaseInfo{\n', '          uint256 cummulativeHardCap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8 bonusPercentages;\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '      \n', '      //total tokens available for sale\n', '      uint256 tokensAvailableForSale = 45050000000000000; //considering 8 decimal places\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event SaleEnded(address _owner, uint256 time);\n', '      \n', '      //Event to add user to the whitelist\n', '      event LogUserAdded(address user);\n', '\n', '      //Event to remove user to the whitelist\n', '      event LogUserRemoved(address user);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '        \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '  \n', '    \n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough EST credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency/Hard stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _saleNotEnded{\n', '    \n', '      saleEnded = true;    \n', '        \n', '      emit SaleStopped(msg.sender, now);\n', '    }\n', '    \n', '    /**\n', '   * @dev Must be called to end the sale\n', '   */\n', '\n', '   function endSale() public onlyOwner _contractUp _saleNotEnded {\n', '\n', '       require(saleTimeOver());\n', '\n', '       saleEnded = true;\n', '       emit SaleEnded(msg.sender, now);\n', '   }\n', '    \n', '\n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return now > phases[noOfPhases-1].endTime;\n', '  }\n', '\n', '  \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _cummulativeHardCaps The array containing cumulative hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _cummulativeHardCaps, uint8[4] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases == 4);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length == _noOfPhases);\n', '    require(_endTimes.length ==_noOfPhases);\n', '    require(_cummulativeHardCaps.length ==_noOfPhases);\n', '    require(_bonusPercentages.length ==_noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i = 0; i < _noOfPhases; i++){\n', '        require(_cummulativeHardCaps[i] > 0);\n', '        require(_endTimes[i] > _startTimes[i]);\n', '        if(i > 0){\n', '            \n', '            //start time of this tier should be greater than previous tier\n', '            require(_startTimes[i] > _endTimes[i-1]);\n', '            \n', '            phases.push(PhaseInfo({\n', '                cummulativeHardCap:_cummulativeHardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i] > now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                cummulativeHardCap:_cummulativeHardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    constructor (address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](4);\n', '        uint256[] memory endTimes = new uint256[](4);\n', '        uint256[] memory cummulativeHardCaps = new uint256[](4);\n', '        uint8 [4] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1532044800; //JULY 20, 2018 12:00:00 AM GMT\n', '        endTimes[0] = 1535759999; //AUGUST 31, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[0] = 2107040600000000000000 wei;\n', '        bonusPercentages[0] = 67;\n', '        \n', '        //phase-1\n', '        startTimes[1] = 1535846400; //SEPTEMBER 02, 2018 12:00:00 AM GMT \n', '        endTimes[1] = 1539647999; //OCTOBER 15, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[1] = 7766345900000000000000 wei;\n', '        bonusPercentages[1] = 33;\n', '        \n', '        \n', '        //phase-2\n', '        startTimes[2] = 1539648000; //OCTOBER 16, 2018 12:00:00 AM GMT\n', '        endTimes[2] = 1543622399; //NOVEMBER 30, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[2] = 14180545900000000000000 wei;\n', '        bonusPercentages[2] = 18;\n', '        \n', '        //phase-3\n', '        startTimes[3] = 1543622400; //DECEMBER 01, 2018 12:00:00 AM GMT\n', '        endTimes[3] = 1546300799; //DECEMBER 31, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[3] = 21197987200000000000000 wei;\n', '        bonusPercentages[3] = 8;\n', '\n', '        setTiersInfo(4, startTimes, endTimes, cummulativeHardCaps, bonusPercentages);\n', '        \n', '    }\n', '    \n', '\n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '   \n', '   function getFundingInfoOfPhase(uint8 phase) public view returns (uint256){\n', '       \n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(phase)];\n', '       \n', '       return currentlyRunningPhase.weiRaised;\n', '       \n', '   } \n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       require(whitelisted[beneficiary]);\n', '\n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex >= 0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check cummulative Hard Cap for this phase has not been reached\n', '       require(weiAmount.add(totalFunding) <= currentlyRunningPhase.cummulativeHardCap);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.div(rate).mul(100000000);//considering decimal places to be 8 for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages);\n', '             \n', '       totalFunding = totalFunding.add(weiAmount);\n', '       \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentage  of bonus  for the phase \n', '    */\n', '     function applyBonus(uint256 tokens, uint8 percentage) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         tokensToAdd = tokens.mul(percentage).div(100);\n', '         return tokens.add(tokensToAdd);\n', '    } \n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i = 0; i < noOfPhases; i++){\n', '          if(now >= phases[i].startTime && now <= phases[i].endTime){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   // Add a user to the whitelist\n', '   function addUser(address user) public nonZeroAddress(user) onlyOwner returns (bool) {\n', '\n', '       require(whitelisted[user] == false);\n', '       \n', '       whitelisted[user] = true;\n', '\n', '       emit LogUserAdded(user);\n', '       \n', '       return true;\n', '\n', '    }\n', '\n', '    // Remove an user from the whitelist\n', '    function removeUser(address user) public nonZeroAddress(user) onlyOwner returns(bool){\n', '      \n', '        require(whitelisted[user] = true);\n', '\n', '        whitelisted[user] = false;\n', '        \n', '        emit LogUserRemoved(user);\n', '        \n', '        return true;\n', '\n', '\n', '    }\n', '\n', '    // Add many users in one go to the whitelist\n', '    function addManyUsers(address[] users)public onlyOwner {\n', '        \n', '        require(users.length < 100);\n', '\n', '        for (uint8 index = 0; index < users.length; index++) {\n', '\n', '             whitelisted[users[index]] = true;\n', '\n', '             emit LogUserAdded(users[index]);\n', '\n', '        }\n', '    }\n', '\n', '     //Method to check whether a user is there in the whitelist or not\n', '    function checkUser(address user) onlyOwner public view  returns (bool){\n', '        return whitelisted[user];\n', '    }\n', '   \n', '   /**\n', '   * @dev Get funding info of user/address. It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '   \n', '   \n', '   /**\n', '   *@dev Method to transfer all remanining tokens left to owner left with the sales contract after the sale has ended\n', '   */\n', '   function transferRemainingTokens()public onlyOwner _contractUp _saleEnded {\n', '       \n', '       token.transfer(msg.sender,address(this).balance);\n', '      \n', '   }\n', '   \n', '   //method to check how many tokens are left\n', '   function tokensLeftForSale() public view returns (uint256){\n', '       return token.balanceOf(address(this));\n', '   }\n', '   \n', '   //method to check the user balance\n', '   function checkUserTokenBalance(address _user) public view returns(uint256) {\n', '       return token.balanceOf(_user);\n', '   }\n', '   \n', '   //method to check how many tokens have been sold out till now out of 450.5 Million\n', '   function tokensSold() public view returns (uint256) {\n', '       return tokensAvailableForSale.sub(token.balanceOf(address(this)));\n', '   }\n', '   \n', '   //Allowing owner to transfer the  money rasied to the wallet address\n', '   function withDrawFunds()public onlyOwner _contractUp {\n', '      \n', '       vault.withdrawToWallet();\n', '    }\n', '      \n', '}']
['pragma solidity 0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor () public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '     emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) external  returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function decimals()external view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Funds will be transferred to owner once sale ends\n', ' */\n', 'contract Vault is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) public deposited;\n', '    address public wallet;\n', '   \n', '    event Withdrawn(address _wallet);\n', '         \n', '    constructor (address _wallet) public {\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '    }\n', '\n', '    function deposit(address investor) public onlyOwner  payable{\n', '        \n', '        deposited[investor] = deposited[investor].add(msg.value);\n', '        \n', '    }\n', '    \n', '    function withdrawToWallet() onlyOwner public{\n', '    \n', '    wallet.transfer(address(this).balance);\n', '     emit Withdrawn(wallet);\n', '  }\n', '}\n', '\n', '\n', 'contract ESTTokenSale is Ownable{\n', '      using SafeMath for uint256;\n', '      \n', '      //Token to be used for this sale\n', '      Token public token;\n', '      \n', '      //All funds will go into this vault\n', '      Vault public vault;\n', '\n', '     // This mapping stores the addresses of whitelisted users\n', '      mapping(address => bool) public whitelisted;\n', '  \n', '      //rate of token :  1 EST = 0.00005804 ETH\n', '      uint256 public rate = 58040000000000;\n', '      /*\n', '      *There will be 4 phases\n', '      * 1. Pre-sale\n', '      * 2. ICO Phase 1\n', '      * 3. ICO Phase 2\n', '      * 4. ICO Phase 3\n', '      */\n', '      struct PhaseInfo{\n', '          uint256 cummulativeHardCap;\n', '          uint256 startTime;\n', '          uint256 endTime;\n', '          uint8 bonusPercentages;\n', '          uint256 weiRaised;\n', '      }\n', '      \n', '      //info of each phase\n', '      PhaseInfo[] public phases;\n', '      \n', '      //Total funding\n', '      uint256 public totalFunding;\n', '      \n', '      //total tokens available for sale\n', '      uint256 tokensAvailableForSale = 45050000000000000; //considering 8 decimal places\n', '      \n', '      \n', '      uint8 public noOfPhases;\n', '      \n', '      \n', '      //Keep track of whether contract is up or not\n', '      bool public contractUp;\n', '      \n', '      //Keep track of whether the sale has ended or not\n', '      bool public saleEnded;\n', '      \n', '      //Event to trigger Sale stop\n', '      event SaleStopped(address _owner, uint256 time);\n', '      \n', '      //Event to trigger normal flow of sale end\n', '      event SaleEnded(address _owner, uint256 time);\n', '      \n', '      //Event to add user to the whitelist\n', '      event LogUserAdded(address user);\n', '\n', '      //Event to remove user to the whitelist\n', '      event LogUserRemoved(address user);\n', '    \n', '     /**\n', '     * event for token purchase logging\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '     event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    \n', '    //modifiers    \n', '    modifier _contractUp(){\n', '        require(contractUp);\n', '        _;\n', '    }\n', '  \n', '     modifier nonZeroAddress(address _to) {\n', '        require(_to != address(0));\n', '        _;\n', '    }\n', '    \n', '        \n', '    modifier _saleEnded() {\n', '        require(saleEnded);\n', '        _;\n', '    }\n', '    \n', '    modifier _saleNotEnded() {\n', '        require(!saleEnded);\n', '        _;\n', '    }\n', '  \n', '    \n', '    /**\n', '    *     @dev Check if sale contract has enough tokens on its account balance \n', '    *     to reward all possible participations within sale period\n', '    */\n', '    function powerUpContract() external onlyOwner {\n', '        // Contract should not be powered up previously\n', '        require(!contractUp);\n', '\n', '        // Contract should have enough EST credits\n', '        require(token.balanceOf(this) >= tokensAvailableForSale);\n', '        \n', '        //activate the sale process\n', '        contractUp = true;\n', '    }\n', '    \n', '    //for Emergency/Hard stop of the sale\n', '    function emergencyStop() external onlyOwner _contractUp _saleNotEnded{\n', '    \n', '      saleEnded = true;    \n', '        \n', '      emit SaleStopped(msg.sender, now);\n', '    }\n', '    \n', '    /**\n', '   * @dev Must be called to end the sale\n', '   */\n', '\n', '   function endSale() public onlyOwner _contractUp _saleNotEnded {\n', '\n', '       require(saleTimeOver());\n', '\n', '       saleEnded = true;\n', '       emit SaleEnded(msg.sender, now);\n', '   }\n', '    \n', '\n', '      // @return true if all the tiers has been ended\n', '  function saleTimeOver() public view returns (bool) {\n', '    \n', '    return now > phases[noOfPhases-1].endTime;\n', '  }\n', '\n', '  \n', '  /**\n', '  * @dev Can be called only once. The method to allow owner to set tier information\n', '  * @param _noOfPhases The integer to set number of tiers\n', '  * @param _startTimes The array containing start time of each tier\n', '  * @param _endTimes The array containing end time of each tier\n', '  * @param _cummulativeHardCaps The array containing cumulative hard cap for each tier\n', '  * @param _bonusPercentages The array containing bonus percentage for each tier\n', '  * The arrays should be in sync with each other. For each index 0 for each of the array should contain info about Tier 1, similarly for Tier2, 3 and 4 .\n', '  * Sales hard cap will be the hard cap of last tier\n', '  */\n', '  function setTiersInfo(uint8 _noOfPhases, uint256[] _startTimes, uint256[] _endTimes, uint256[] _cummulativeHardCaps, uint8[4] _bonusPercentages)private {\n', '    \n', '    \n', '    require(_noOfPhases == 4);\n', '    \n', '    //Each array should contain info about each tier\n', '    require(_startTimes.length == _noOfPhases);\n', '    require(_endTimes.length ==_noOfPhases);\n', '    require(_cummulativeHardCaps.length ==_noOfPhases);\n', '    require(_bonusPercentages.length ==_noOfPhases);\n', '    \n', '    noOfPhases = _noOfPhases;\n', '    \n', '    for(uint8 i = 0; i < _noOfPhases; i++){\n', '        require(_cummulativeHardCaps[i] > 0);\n', '        require(_endTimes[i] > _startTimes[i]);\n', '        if(i > 0){\n', '            \n', '            //start time of this tier should be greater than previous tier\n', '            require(_startTimes[i] > _endTimes[i-1]);\n', '            \n', '            phases.push(PhaseInfo({\n', '                cummulativeHardCap:_cummulativeHardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '        else{\n', '            //start time of tier1 should be greater than current time\n', '            require(_startTimes[i] > now);\n', '          \n', '            phases.push(PhaseInfo({\n', '                cummulativeHardCap:_cummulativeHardCaps[i],\n', '                startTime:_startTimes[i],\n', '                endTime:_endTimes[i],\n', '                bonusPercentages:_bonusPercentages[i],\n', '                weiRaised:0\n', '            }));\n', '        }\n', '    }\n', '  }\n', '  \n', '  \n', '    /**\n', '    * @dev Constructor method\n', '    * @param _tokenToBeUsed Address of the token to be used for Sales\n', '    * @param _wallet Address of the wallet which will receive the collected funds\n', '    */  \n', '    constructor (address _tokenToBeUsed, address _wallet)public nonZeroAddress(_tokenToBeUsed) nonZeroAddress(_wallet){\n', '        \n', '        token = Token(_tokenToBeUsed);\n', '        vault = new Vault(_wallet);\n', '        \n', '        uint256[] memory startTimes = new uint256[](4);\n', '        uint256[] memory endTimes = new uint256[](4);\n', '        uint256[] memory cummulativeHardCaps = new uint256[](4);\n', '        uint8 [4] memory bonusPercentages;\n', '        \n', '        //pre-sales\n', '        startTimes[0] = 1532044800; //JULY 20, 2018 12:00:00 AM GMT\n', '        endTimes[0] = 1535759999; //AUGUST 31, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[0] = 2107040600000000000000 wei;\n', '        bonusPercentages[0] = 67;\n', '        \n', '        //phase-1\n', '        startTimes[1] = 1535846400; //SEPTEMBER 02, 2018 12:00:00 AM GMT \n', '        endTimes[1] = 1539647999; //OCTOBER 15, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[1] = 7766345900000000000000 wei;\n', '        bonusPercentages[1] = 33;\n', '        \n', '        \n', '        //phase-2\n', '        startTimes[2] = 1539648000; //OCTOBER 16, 2018 12:00:00 AM GMT\n', '        endTimes[2] = 1543622399; //NOVEMBER 30, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[2] = 14180545900000000000000 wei;\n', '        bonusPercentages[2] = 18;\n', '        \n', '        //phase-3\n', '        startTimes[3] = 1543622400; //DECEMBER 01, 2018 12:00:00 AM GMT\n', '        endTimes[3] = 1546300799; //DECEMBER 31, 2018 11:59:59 PM GMT\n', '        cummulativeHardCaps[3] = 21197987200000000000000 wei;\n', '        bonusPercentages[3] = 8;\n', '\n', '        setTiersInfo(4, startTimes, endTimes, cummulativeHardCaps, bonusPercentages);\n', '        \n', '    }\n', '    \n', '\n', '   //Fallback function used to buytokens\n', '   function()public payable{\n', '       buyTokens(msg.sender);\n', '   }\n', '   \n', '   function getFundingInfoOfPhase(uint8 phase) public view returns (uint256){\n', '       \n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(phase)];\n', '       \n', '       return currentlyRunningPhase.weiRaised;\n', '       \n', '   } \n', '   \n', '   /**\n', '   * @dev Low level token purchase function\n', '   * @param beneficiary The address who will receive the tokens for this transaction\n', '   */\n', '   function buyTokens(address beneficiary)public _contractUp _saleNotEnded nonZeroAddress(beneficiary) payable returns(bool){\n', '       \n', '       require(whitelisted[beneficiary]);\n', '\n', '       int8 currentPhaseIndex = getCurrentlyRunningPhase();\n', '       assert(currentPhaseIndex >= 0);\n', '       \n', '        // recheck this for storage and memory\n', '       PhaseInfo storage currentlyRunningPhase = phases[uint256(currentPhaseIndex)];\n', '       \n', '       \n', '       uint256 weiAmount = msg.value;\n', '\n', '       //Check cummulative Hard Cap for this phase has not been reached\n', '       require(weiAmount.add(totalFunding) <= currentlyRunningPhase.cummulativeHardCap);\n', '       \n', '       \n', '       uint256 tokens = weiAmount.div(rate).mul(100000000);//considering decimal places to be 8 for token\n', '       \n', '       uint256 bonusedTokens = applyBonus(tokens, currentlyRunningPhase.bonusPercentages);\n', '             \n', '       totalFunding = totalFunding.add(weiAmount);\n', '       \n', '       currentlyRunningPhase.weiRaised = currentlyRunningPhase.weiRaised.add(weiAmount);\n', '       \n', '       vault.deposit.value(msg.value)(msg.sender);\n', '       \n', '       token.transfer(beneficiary, bonusedTokens);\n', '       \n', '       emit TokenPurchase(msg.sender, beneficiary, weiAmount, bonusedTokens);\n', '\n', '       return true;\n', '       \n', '   }\n', '   \n', '    /**\n', '    *@dev Method to calculate bonus for the user as per currently running phase and contribution by the user\n', '    * @param tokens Total tokens purchased by the user\n', '    * @param percentage  of bonus  for the phase \n', '    */\n', '     function applyBonus(uint256 tokens, uint8 percentage) private pure returns  (uint256) {\n', '         \n', '         uint256 tokensToAdd = 0;\n', '         tokensToAdd = tokens.mul(percentage).div(100);\n', '         return tokens.add(tokensToAdd);\n', '    } \n', '    \n', '   /**\n', '    * @dev returns the currently running tier index as per time\n', '    * Return -1 if no tier is running currently\n', '    * */\n', '   function getCurrentlyRunningPhase()public view returns(int8){\n', '      for(uint8 i = 0; i < noOfPhases; i++){\n', '          if(now >= phases[i].startTime && now <= phases[i].endTime){\n', '              return int8(i);\n', '          }\n', '      }   \n', '      return -1;\n', '   }\n', '   \n', '   // Add a user to the whitelist\n', '   function addUser(address user) public nonZeroAddress(user) onlyOwner returns (bool) {\n', '\n', '       require(whitelisted[user] == false);\n', '       \n', '       whitelisted[user] = true;\n', '\n', '       emit LogUserAdded(user);\n', '       \n', '       return true;\n', '\n', '    }\n', '\n', '    // Remove an user from the whitelist\n', '    function removeUser(address user) public nonZeroAddress(user) onlyOwner returns(bool){\n', '      \n', '        require(whitelisted[user] = true);\n', '\n', '        whitelisted[user] = false;\n', '        \n', '        emit LogUserRemoved(user);\n', '        \n', '        return true;\n', '\n', '\n', '    }\n', '\n', '    // Add many users in one go to the whitelist\n', '    function addManyUsers(address[] users)public onlyOwner {\n', '        \n', '        require(users.length < 100);\n', '\n', '        for (uint8 index = 0; index < users.length; index++) {\n', '\n', '             whitelisted[users[index]] = true;\n', '\n', '             emit LogUserAdded(users[index]);\n', '\n', '        }\n', '    }\n', '\n', '     //Method to check whether a user is there in the whitelist or not\n', '    function checkUser(address user) onlyOwner public view  returns (bool){\n', '        return whitelisted[user];\n', '    }\n', '   \n', '   /**\n', '   * @dev Get funding info of user/address. It will return how much funding the user has made in terms of wei\n', '   */\n', '   function getFundingInfoForUser(address _user)public view nonZeroAddress(_user) returns(uint256){\n', '       return vault.deposited(_user);\n', '   }\n', '   \n', '   \n', '   /**\n', '   *@dev Method to transfer all remanining tokens left to owner left with the sales contract after the sale has ended\n', '   */\n', '   function transferRemainingTokens()public onlyOwner _contractUp _saleEnded {\n', '       \n', '       token.transfer(msg.sender,address(this).balance);\n', '      \n', '   }\n', '   \n', '   //method to check how many tokens are left\n', '   function tokensLeftForSale() public view returns (uint256){\n', '       return token.balanceOf(address(this));\n', '   }\n', '   \n', '   //method to check the user balance\n', '   function checkUserTokenBalance(address _user) public view returns(uint256) {\n', '       return token.balanceOf(_user);\n', '   }\n', '   \n', '   //method to check how many tokens have been sold out till now out of 450.5 Million\n', '   function tokensSold() public view returns (uint256) {\n', '       return tokensAvailableForSale.sub(token.balanceOf(address(this)));\n', '   }\n', '   \n', '   //Allowing owner to transfer the  money rasied to the wallet address\n', '   function withDrawFunds()public onlyOwner _contractUp {\n', '      \n', '       vault.withdrawToWallet();\n', '    }\n', '      \n', '}']
