['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.19;\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership() onlyPendingOwner public {\n', '        OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="791216171e151018171e39151616090b10171e57160b1e">[email&#160;protected]</a>>,\n', '/// @author Daniel Wang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e480858a8d8188a4888b8b94968d8a83ca8b9683">[email&#160;protected]</a>>.\n', 'contract TokenRegistry is Claimable {\n', '    address[] public addresses;\n', '    mapping (address => TokenInfo) addressMap;\n', '    mapping (string => address) symbolMap;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct TokenInfo {\n', '        uint   pos;      // 0 mens unregistered; if > 0, pos + 1 is the\n', '                         // token&#39;s position in `addresses`.\n', '        string symbol;   // Symbol of the token\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event TokenRegistered(address addr, string symbol);\n', '    event TokenUnregistered(address addr, string symbol);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(0x0 != addr);\n', '        require(bytes(symbol).length > 0);\n', '        require(0x0 == symbolMap[symbol]);\n', '        require(0 == addressMap[addr].pos);\n', '        addresses.push(addr);\n', '        symbolMap[symbol] = addr;\n', '        addressMap[addr] = TokenInfo(addresses.length, symbol);\n', '        TokenRegistered(addr, symbol);\n', '    }\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(addr != 0x0);\n', '        require(symbolMap[symbol] == addr);\n', '        delete symbolMap[symbol];\n', '        uint pos = addressMap[addr].pos;\n', '        require(pos != 0);\n', '        delete addressMap[addr];\n', '        // We will replace the token we need to unregister with the last token\n', '        // Only the pos of the last token will need to be updated\n', '        address lastToken = addresses[addresses.length - 1];\n', '        // Don&#39;t do anything if the last token is the one we want to delete\n', '        if (addr != lastToken) {\n', '            // Swap with the last token and update the pos\n', '            addresses[pos - 1] = lastToken;\n', '            addressMap[lastToken].pos = pos;\n', '        }\n', '        addresses.length--;\n', '        TokenUnregistered(addr, symbol);\n', '    }\n', '    function areAllTokensRegistered(address[] addressList)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            if (addressMap[addressList[i]].pos == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    function getAddressBySymbol(string symbol)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return symbolMap[symbol];\n', '    }\n', '    function isTokenRegisteredBySymbol(string symbol)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return symbolMap[symbol] != 0x0;\n', '    }\n', '    function isTokenRegistered(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressMap[addr].pos != 0;\n', '    }\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList)\n', '    {\n', '        uint num = addresses.length;\n', '        if (start >= num) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > num) {\n', '            end = num;\n', '        }\n', '        if (start == num) {\n', '            return;\n', '        }\n', '        addressList = new address[](end - start);\n', '        for (uint i = start; i < end; i++) {\n', '            addressList[i - start] = addresses[i];\n', '        }\n', '    }\n', '}']
['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.19;\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership() onlyPendingOwner public {\n', '        OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/// @title Token Register Contract\n', '/// @dev This contract maintains a list of tokens the Protocol supports.\n', '/// @author Kongliang Zhong - <kongliang@loopring.org>,\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenRegistry is Claimable {\n', '    address[] public addresses;\n', '    mapping (address => TokenInfo) addressMap;\n', '    mapping (string => address) symbolMap;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct TokenInfo {\n', '        uint   pos;      // 0 mens unregistered; if > 0, pos + 1 is the\n', "                         // token's position in `addresses`.\n", '        string symbol;   // Symbol of the token\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event TokenRegistered(address addr, string symbol);\n', '    event TokenUnregistered(address addr, string symbol);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Disable default function.\n', '    function () payable public {\n', '        revert();\n', '    }\n', '    function registerToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(0x0 != addr);\n', '        require(bytes(symbol).length > 0);\n', '        require(0x0 == symbolMap[symbol]);\n', '        require(0 == addressMap[addr].pos);\n', '        addresses.push(addr);\n', '        symbolMap[symbol] = addr;\n', '        addressMap[addr] = TokenInfo(addresses.length, symbol);\n', '        TokenRegistered(addr, symbol);\n', '    }\n', '    function unregisterToken(\n', '        address addr,\n', '        string  symbol\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(addr != 0x0);\n', '        require(symbolMap[symbol] == addr);\n', '        delete symbolMap[symbol];\n', '        uint pos = addressMap[addr].pos;\n', '        require(pos != 0);\n', '        delete addressMap[addr];\n', '        // We will replace the token we need to unregister with the last token\n', '        // Only the pos of the last token will need to be updated\n', '        address lastToken = addresses[addresses.length - 1];\n', "        // Don't do anything if the last token is the one we want to delete\n", '        if (addr != lastToken) {\n', '            // Swap with the last token and update the pos\n', '            addresses[pos - 1] = lastToken;\n', '            addressMap[lastToken].pos = pos;\n', '        }\n', '        addresses.length--;\n', '        TokenUnregistered(addr, symbol);\n', '    }\n', '    function areAllTokensRegistered(address[] addressList)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint i = 0; i < addressList.length; i++) {\n', '            if (addressMap[addressList[i]].pos == 0) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    function getAddressBySymbol(string symbol)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return symbolMap[symbol];\n', '    }\n', '    function isTokenRegisteredBySymbol(string symbol)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return symbolMap[symbol] != 0x0;\n', '    }\n', '    function isTokenRegistered(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressMap[addr].pos != 0;\n', '    }\n', '    function getTokens(\n', '        uint start,\n', '        uint count\n', '        )\n', '        public\n', '        view\n', '        returns (address[] addressList)\n', '    {\n', '        uint num = addresses.length;\n', '        if (start >= num) {\n', '            return;\n', '        }\n', '        uint end = start + count;\n', '        if (end > num) {\n', '            end = num;\n', '        }\n', '        if (start == num) {\n', '            return;\n', '        }\n', '        addressList = new address[](end - start);\n', '        for (uint i = start; i < end; i++) {\n', '            addressList[i - start] = addresses[i];\n', '        }\n', '    }\n', '}']
