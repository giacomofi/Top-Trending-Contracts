['pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\tfunction mul(uint a, uint b) internal pure returns (uint c) {\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tc = a * b;\n', '\t\trequire(c / a == b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction div(uint a, uint b) internal pure returns (uint c) {\n', '\t\treturn a / b;\n', '\t}\n', '}\n', '\n', 'contract DrupeCoin {\n', '\tfunction transfer(address to, uint tokens) public returns (bool success);\n', '\tfunction balanceOf(address tokenOwner) public constant returns (uint balance);\n', '}\n', '\n', '// Contract that forwards token purchases to the main ico contract\n', '// and references the referrer in order to sent a referral bonus:\n', 'contract DrupeICORef {\n', '\taddress _referrer;\n', '\tDrupeICO _ico;\n', '\n', '\tconstructor(address referrer, DrupeICO ico) public {\n', '\t\t_referrer = referrer;\n', '\t\t_ico = ico;\n', '\t}\n', '\n', '\tfunction() public payable {\n', '\t\t_ico.purchase.value(msg.value)(msg.sender, _referrer);\n', '\t}\n', '}\n', '\n', '// The main contract that holds all tokens for sale and accepts Ether:\n', 'contract DrupeICO {\n', '\tusing SafeMath for uint;\n', '\n', '\t// Representation of a fraction: n(numerator)/d(denominator)\n', '\tstruct Fraction { uint n; uint d; }\n', '\n', '\t// Representation of an ico phases:\n', '\tstruct Presale {\n', '\t\t// Start timestamp in seconds since unix epoch:\n', '\t\tuint start;\n', '\t\t// Bonus that applies to token purchases during this phase:\n', '\t\tFraction bonus;\n', '\t}\n', '\tstruct Mainsale {\n', '\t\t// Start timestamp in seconds since unix epoch:\n', '\t\tuint start;\n', '\t\t// End timestamp in seconds since unix epoch:\n', '\t\tuint end;\n', '\t}\n', '\n', '\t// Event that is emitted for each referral contract creation:\n', '\tevent Referrer(address indexed referrer, address indexed refContract);\n', '\n', '\taddress _owner;\n', '\taddress _newOwner;\n', '\tDrupeCoin _drupe;\n', '\tFraction _basePrice; // in: ETH per DPC\n', '\tFraction _refBonus;\n', '\tPresale _presale1;\n', '\tPresale _presale2;\n', '\tMainsale _mainsale;\n', '\n', '\tconstructor(\n', '\t\taddress drupe,\n', '\t\tuint basePriceN, uint basePriceD,\n', '\t\tuint refBonusN, uint refBonusD,\n', '\t\tuint presale1Start, uint presale1BonusN, uint presale1BonusD,\n', '\t\tuint presale2Start, uint presale2BonusN, uint presale2BonusD,\n', '\t\tuint mainsaleStart, uint mainsaleEnd\n', '\t) public {\n', '\t\trequire(drupe != address(0));\n', '\t\trequire(basePriceN > 0 && basePriceD > 0);\n', '\t\trequire(refBonusN > 0 && basePriceD > 0);\n', '\t\trequire(presale1Start > now);\n', '\t\trequire(presale1BonusN > 0 && presale1BonusD > 0);\n', '\t\trequire(presale2Start > presale1Start);\n', '\t\trequire(presale2BonusN > 0 && presale2BonusD > 0);\n', '\t\trequire(mainsaleStart > presale2Start);\n', '\t\trequire(mainsaleEnd > mainsaleStart);\n', '\n', '\t\t_owner = msg.sender;\n', '\t\t_newOwner = address(0);\n', '\t\t_drupe = DrupeCoin(drupe);\n', '\t\t_basePrice = Fraction({n: basePriceN, d: basePriceD});\n', '\t\t_refBonus = Fraction({n: refBonusN, d: refBonusD});\n', '\t\t_presale1 = Presale({\n', '\t\t\tstart: presale1Start,\n', '\t\t\tbonus: Fraction({n: presale1BonusN, d: presale1BonusD})\n', '\t\t});\n', '\t\t_presale2 = Presale({\n', '\t\t\tstart: presale2Start,\n', '\t\t\tbonus: Fraction({n: presale2BonusN, d: presale2BonusD})\n', '\t\t});\n', '\t\t_mainsale = Mainsale({\n', '\t\t\tstart: mainsaleStart,\n', '\t\t\tend: mainsaleEnd\n', '\t\t});\n', '\t}\n', '\n', '\t// Modifier to ensure that a function is only called during the ico:\n', '\tmodifier icoOnly() {\n', '\t\trequire(now >= _presale1.start && now < _mainsale.end);\n', '\t\t_;\n', '\t}\n', '\n', '\t// Modifier to ensure that a function is only called by the owner:\n', '\tmodifier ownerOnly() {\n', '\t\trequire(msg.sender == _owner);\n', '\t\t_;\n', '\t}\n', '\n', '\n', '\n', '\t// Internal function for determining the current bonus:\n', '\t// (It is assumed that this function is only called during the ico)\n', '\tfunction _getBonus() internal view returns (Fraction memory bonus) {\n', '\t\tif (now < _presale2.start) {\n', '\t\t\tbonus = _presale1.bonus;\n', '\t\t} else if (now < _mainsale.start) {\n', '\t\t\tbonus = _presale2.bonus;\n', '\t\t} else {\n', '\t\t\tbonus = Fraction({n: 0, d: 1});\n', '\t\t}\n', '\t}\n', '\n', '\n', '\n', '\t// Exchange Ether for tokens:\n', '\tfunction() public payable icoOnly {\n', '\t\tFraction memory bonus = _getBonus();\n', '\n', '\t\t// Calculate the raw amount of tokens:\n', '\t\tuint rawTokens = msg.value.mul(_basePrice.d).div(_basePrice.n);\n', '\t\t// Calculate the amount of tokens including bonus:\n', '\t\tuint tokens = rawTokens + rawTokens.mul(bonus.n).div(bonus.d);\n', '\n', '\t\t// Transfer tokens to the sender:\n', '\t\t_drupe.transfer(msg.sender, tokens);\n', '\t\t// (Sent Ether will remain on this contract)\n', '\n', '\t\t// Create referral contract for the sender:\n', '\t\taddress refContract = new DrupeICORef(msg.sender, this);\n', '\t\temit Referrer(msg.sender, refContract);\n', '\t}\n', '\n', '\t// Extended function for exchanging Ether for tokens.\n', '\t//  - aquired tokens will be send to the payout address.\n', '\t//  - ref bonus tokens will be send to the referrer.\n', '\tfunction purchase(address payout, address referrer) public payable icoOnly returns (uint tokens) {\n', '\t\tFraction memory bonus = _getBonus();\n', '\n', '\t\t// Calculate the raw amount of tokens:\n', '\t\tuint rawTokens = msg.value.mul(_basePrice.d).div(_basePrice.n);\n', '\t\t// Calculate the amount of tokens including bonus:\n', '\t\ttokens = rawTokens + rawTokens.mul(bonus.n).div(bonus.d);\n', '\t\t// Calculate the amount of tokens for the referrer:\n', '\t\tuint refTokens = rawTokens.mul(_refBonus.n).div(_refBonus.d);\n', '\n', '\t\t// Transfer tokens to the payout address:\n', '\t\t_drupe.transfer(payout, tokens);\n', '\t\t// Transfer ref bonus tokens to the referrer:\n', '\t\t_drupe.transfer(referrer, refTokens);\n', '\t\t// (Sent Ether will remain on this contract)\n', '\n', '\t\t// Create referral contract for the sender:\n', '\t\taddress refContract = new DrupeICORef(payout, this);\n', '\t\temit Referrer(payout, refContract);\n', '\t}\n', '\n', '\n', '\n', '\t// Function that can be used to burn unsold tokens after the ico has ended:\n', '\tfunction burnUnsoldTokens() public ownerOnly {\n', '\t\trequire(now >= _mainsale.end);\n', '\t\tuint unsoldTokens = _drupe.balanceOf(this);\n', '\t\t_drupe.transfer(address(0), unsoldTokens);\n', '\t}\n', '\n', '\t// Function that the owner can withdraw funds:\n', '\tfunction withdrawFunds(uint value) public ownerOnly {\n', '\t\tmsg.sender.transfer(value);\n', '\t}\n', '\n', '\n', '\n', '\tfunction getOwner() public view returns (address) {\n', '\t\treturn _owner;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) public ownerOnly {\n', '\t\t_newOwner = newOwner;\n', '\t}\n', '\n', '\tfunction acceptOwnership() public {\n', '\t\trequire(msg.sender == _newOwner);\n', '\t\t_owner = _newOwner;\n', '\t\t_newOwner = address(0);\n', '\t}\n', '\n', '\n', '\n', '\tfunction getDrupeCoin() public view returns (address) {\n', '\t\treturn _drupe;\n', '\t}\n', '\n', '\tfunction getBasePrice() public view returns (uint n, uint d) {\n', '\t\tn = _basePrice.n;\n', '\t\td = _basePrice.d;\n', '\t}\n', '\n', '\tfunction getRefBonus() public view returns (uint n, uint d) {\n', '\t\tn = _refBonus.n;\n', '\t\td = _refBonus.d;\n', '\t}\n', '\n', '\tfunction getPresale1() public view returns (uint start, uint bonusN, uint bonusD) {\n', '\t\tstart = _presale1.start;\n', '\t\tbonusN = _presale1.bonus.n;\n', '\t\tbonusD = _presale1.bonus.d;\n', '\t}\n', '\n', '\tfunction getPresale2() public view returns (uint start, uint bonusN, uint bonusD) {\n', '\t\tstart = _presale2.start;\n', '\t\tbonusN = _presale2.bonus.n;\n', '\t\tbonusD = _presale2.bonus.d;\n', '\t}\n', '\n', '\tfunction getMainsale() public view returns (uint start, uint end) {\n', '\t\tstart = _mainsale.start;\n', '\t\tend = _mainsale.end;\n', '\t}\n', '}']