['pragma solidity ^0.4.12;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '      \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract UBetCoin is Ownable, StandardToken {\n', '\n', '    string public name = "UBetCoin";               // name of the token\n', '    string public symbol = "UBET";                 // ERC20 compliant 4 digit token code\n', '    uint public decimals = 2;                      // token has 2 digit precision\n', '\n', '    uint256 public totalSupply =  400000000000;      // 4 BILLION INITIAL SUPPLY\n', '    uint256 public tokenSupplyFromCheck = 0;             // Total from check!\n', '    uint256 public tokenSupplyBackedByGold = 4000000000; // Supply Backed By Gold\n', '    \n', '    string public constant YOU_BET_MINE_DOCUMENT_PATH = "https://s3.amazonaws.com/s3-ubetcoin-user-signatures/document/GOLD-MINES-assigned+TO-SAINT-NICOLAS-SNADCO-03-22-2016.pdf";\n', '    string public constant YOU_BET_MINE_DOCUMENT_SHA512 = "7e9dc6362c5bf85ff19d75df9140b033c4121ba8aaef7e5837b276d657becf0a0d68fcf26b95e76023a33251ac94f35492f2f0af882af4b87b1b1b626b325cf8";\n', '    string public constant UBETCOIN_LEDGER_TO_LEDGER_ENTRY_DOCUMENT_PATH = "https://s3.amazonaws.com/s3-ubetcoin-user-signatures/document/LEDGER-TO-LEDGER+ENTRY-FOR-UBETCOIN+03-20-2018.pdf";\n', '    string public constant UBETCOIN_LEDGER_TO_LEDGER_ENTRY_DOCUMENT_SHA512 = "c8f0ae2602005dd88ef908624cf59f3956107d0890d67d3baf9c885b64544a8140e282366cae6a3af7bfbc96d17f856b55fc4960e2287d4a03d67e646e0e88c6";\n', '    \n', '    /// Base exchange rate is set\n', '    uint256 public ratePerOneEther = 962;\n', '    uint256 public totalUBetCheckAmounts = 0;\n', '\n', '    /// Issue event index starting from 0.\n', '    uint64 public issueIndex = 0;\n', '\n', '    /// Emitted for each sucuessful token purchase.\n', '    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n', '    \n', '    // All funds will be transferred in this wallet.\n', '    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n', '\n', '    /// Emitted for each UBETCHECKS register.\n', '    event UbetCheckIssue(string chequeIndex);\n', '      \n', '    struct UBetCheck {\n', '      string accountId;\n', '      string accountNumber;\n', '      string fullName;\n', '      string routingNumber;\n', '      string institution;\n', '      uint256 amount;\n', '      uint256 tokens;\n', '      string checkFilePath;\n', '      string digitalCheckFingerPrint;\n', '    }\n', '    \n', '    mapping (address => UBetCheck) UBetChecks;\n', '    address[] public uBetCheckAccts;\n', '    \n', '    \n', '    /// @dev Initializes the contract and allocates all initial tokens to the owner\n', '    function UBetCoin() {\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '  \n', '    //////////////// owner only functions below\n', '\n', '    /// @dev To transfer token contract ownership\n', '    /// @param _newOwner The address of the new owner of this contract\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        Ownable.transferOwnership(_newOwner);\n', '    }\n', '    \n', '    /// check functionality\n', '    \n', '    /// @dev Register UBetCheck to the chain\n', '    /// @param _beneficiary recipient ether address\n', '    /// @param _accountId the id generated from the db\n', '    /// @param _accountNumber the account number stated in the check\n', '    /// @param _routingNumber the routing number stated in the check\n', '    /// @param _institution the name of the institution / bank in the check\n', '    /// @param _fullname the name printed on the check\n', '    /// @param _amount the amount in currency in the chek\n', '    /// @param _checkFilePath the url path where the cheque has been uploaded\n', '    /// @param _digitalCheckFingerPrint the hash of the file\n', '    /// @param _tokens number of tokens issued to the beneficiary\n', '    function registerUBetCheck(address _beneficiary, string _accountId,  string _accountNumber, string _routingNumber, string _institution, string _fullname,  uint256 _amount, string _checkFilePath, string _digitalCheckFingerPrint, uint256 _tokens) public payable onlyOwner {\n', '      \n', '      require(_beneficiary != address(0));\n', '      require(bytes(_accountId).length != 0);\n', '      require(bytes(_accountNumber).length != 0);\n', '      require(bytes(_routingNumber).length != 0);\n', '      require(bytes(_institution).length != 0);\n', '      require(bytes(_fullname).length != 0);\n', '      require(_amount > 0);\n', '      require(_tokens > 0);\n', '      require(bytes(_checkFilePath).length != 0);\n', '      require(bytes(_digitalCheckFingerPrint).length != 0);\n', '      \n', '      var __conToken = _tokens * (10**(decimals));\n', '      \n', '      var uBetCheck = UBetChecks[_beneficiary];\n', '      \n', '      uBetCheck.accountId = _accountId;\n', '      uBetCheck.accountNumber = _accountNumber;\n', '      uBetCheck.routingNumber = _routingNumber;\n', '      uBetCheck.institution = _institution;\n', '      uBetCheck.fullName = _fullname;\n', '      uBetCheck.amount = _amount;\n', '      uBetCheck.tokens = _tokens;\n', '      \n', '      uBetCheck.checkFilePath = _checkFilePath;\n', '      uBetCheck.digitalCheckFingerPrint = _digitalCheckFingerPrint;\n', '      \n', '      totalUBetCheckAmounts = safeAdd(totalUBetCheckAmounts, _amount);\n', '      tokenSupplyFromCheck = safeAdd(tokenSupplyFromCheck, _tokens);\n', '      \n', '      uBetCheckAccts.push(_beneficiary) -1;\n', '      \n', '      // Issue token when registered UBetCheck is complete to the _beneficiary\n', '      doIssueTokens(_beneficiary, __conToken);\n', '      \n', '      // Fire Event UbetCheckIssue\n', '      UbetCheckIssue(_accountId);\n', '    }\n', '    \n', '    /// @dev List all the checks in the\n', '    function getUBetChecks() public returns (address[]) {\n', '      return uBetCheckAccts;\n', '    }\n', '    \n', '    /// @dev Return UBetCheck information by supplying beneficiary adddress\n', '    function getUBetCheck(address _address) public returns(string, string, string, string, uint256, string, string) {\n', '            \n', '      return (UBetChecks[_address].accountNumber,\n', '              UBetChecks[_address].routingNumber,\n', '              UBetChecks[_address].institution,\n', '              UBetChecks[_address].fullName,\n', '              UBetChecks[_address].amount,\n', '              UBetChecks[_address].checkFilePath,\n', '              UBetChecks[_address].digitalCheckFingerPrint);\n', '    }\n', '    \n', '    /// @dev This default function allows token to be purchased by directly\n', '    /// sending ether to this smart contract.\n', '    function () public payable {\n', '      purchaseTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev return total count of registered UBet Checks\n', '    function countUBetChecks() public returns (uint) {\n', '        return uBetCheckAccts.length;\n', '    }\n', '    \n', '\n', '    /// @dev issue tokens for a single buyer\n', '    /// @param _beneficiary addresses that the tokens will be sent to.\n', '    /// @param _tokens the amount of tokens, with decimals expanded (full).\n', '    function doIssueTokens(address _beneficiary, uint256 _tokens) internal {\n', '      require(_beneficiary != address(0));    \n', '\n', '      // compute without actually increasing it\n', '      uint256 increasedTotalSupply = safeAdd(totalSupply, _tokens);\n', '      \n', '      // increase token total supply\n', '      totalSupply = increasedTotalSupply;\n', '      // update the beneficiary balance to number of tokens sent\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _tokens);\n', '      \n', '      Transfer(msg.sender, _beneficiary, _tokens);\n', '    \n', '      // event is fired when tokens issued\n', '      Issue(\n', '          issueIndex++,\n', '          _beneficiary,\n', '          _tokens\n', '      );\n', '    }\n', '    \n', '    /// @dev Issue token based on Ether received.\n', '    /// @param _beneficiary Address that newly issued token will be sent to.\n', '    function purchaseTokens(address _beneficiary) public payable {\n', '      // only accept a minimum amount of ETH?\n', '      require(msg.value >= 0.00104 ether);\n', '     \n', '      uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals)));\n', '      doIssueTokens(_beneficiary, _tokens);\n', '\n', '      /// forward the money to the money wallet\n', '      moneyWallet.transfer(this.balance);\n', '    }\n', '    \n', '    \n', '    /// @dev Change money wallet owner\n', '    /// @param _address new address to received the ether\n', '    function setMoneyWallet(address _address) public onlyOwner {\n', '        moneyWallet = _address;\n', '    }\n', '    \n', '    /// @dev Change Rate per token in one ether\n', '    /// @param _value the amount of tokens, with decimals expanded (full).\n', '    function setRatePerOneEther(uint256 _value) public onlyOwner {\n', '      require(_value >= 1);\n', '      ratePerOneEther = _value;\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.12;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '      \n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '      \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract UBetCoin is Ownable, StandardToken {\n', '\n', '    string public name = "UBetCoin";               // name of the token\n', '    string public symbol = "UBET";                 // ERC20 compliant 4 digit token code\n', '    uint public decimals = 2;                      // token has 2 digit precision\n', '\n', '    uint256 public totalSupply =  400000000000;      // 4 BILLION INITIAL SUPPLY\n', '    uint256 public tokenSupplyFromCheck = 0;             // Total from check!\n', '    uint256 public tokenSupplyBackedByGold = 4000000000; // Supply Backed By Gold\n', '    \n', '    string public constant YOU_BET_MINE_DOCUMENT_PATH = "https://s3.amazonaws.com/s3-ubetcoin-user-signatures/document/GOLD-MINES-assigned+TO-SAINT-NICOLAS-SNADCO-03-22-2016.pdf";\n', '    string public constant YOU_BET_MINE_DOCUMENT_SHA512 = "7e9dc6362c5bf85ff19d75df9140b033c4121ba8aaef7e5837b276d657becf0a0d68fcf26b95e76023a33251ac94f35492f2f0af882af4b87b1b1b626b325cf8";\n', '    string public constant UBETCOIN_LEDGER_TO_LEDGER_ENTRY_DOCUMENT_PATH = "https://s3.amazonaws.com/s3-ubetcoin-user-signatures/document/LEDGER-TO-LEDGER+ENTRY-FOR-UBETCOIN+03-20-2018.pdf";\n', '    string public constant UBETCOIN_LEDGER_TO_LEDGER_ENTRY_DOCUMENT_SHA512 = "c8f0ae2602005dd88ef908624cf59f3956107d0890d67d3baf9c885b64544a8140e282366cae6a3af7bfbc96d17f856b55fc4960e2287d4a03d67e646e0e88c6";\n', '    \n', '    /// Base exchange rate is set\n', '    uint256 public ratePerOneEther = 962;\n', '    uint256 public totalUBetCheckAmounts = 0;\n', '\n', '    /// Issue event index starting from 0.\n', '    uint64 public issueIndex = 0;\n', '\n', '    /// Emitted for each sucuessful token purchase.\n', '    event Issue(uint64 issueIndex, address addr, uint256 tokenAmount);\n', '    \n', '    // All funds will be transferred in this wallet.\n', '    address public moneyWallet = 0xe5688167Cb7aBcE4355F63943aAaC8bb269dc953;\n', '\n', '    /// Emitted for each UBETCHECKS register.\n', '    event UbetCheckIssue(string chequeIndex);\n', '      \n', '    struct UBetCheck {\n', '      string accountId;\n', '      string accountNumber;\n', '      string fullName;\n', '      string routingNumber;\n', '      string institution;\n', '      uint256 amount;\n', '      uint256 tokens;\n', '      string checkFilePath;\n', '      string digitalCheckFingerPrint;\n', '    }\n', '    \n', '    mapping (address => UBetCheck) UBetChecks;\n', '    address[] public uBetCheckAccts;\n', '    \n', '    \n', '    /// @dev Initializes the contract and allocates all initial tokens to the owner\n', '    function UBetCoin() {\n', '        balances[msg.sender] = totalSupply;\n', '    }\n', '  \n', '    //////////////// owner only functions below\n', '\n', '    /// @dev To transfer token contract ownership\n', '    /// @param _newOwner The address of the new owner of this contract\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        Ownable.transferOwnership(_newOwner);\n', '    }\n', '    \n', '    /// check functionality\n', '    \n', '    /// @dev Register UBetCheck to the chain\n', '    /// @param _beneficiary recipient ether address\n', '    /// @param _accountId the id generated from the db\n', '    /// @param _accountNumber the account number stated in the check\n', '    /// @param _routingNumber the routing number stated in the check\n', '    /// @param _institution the name of the institution / bank in the check\n', '    /// @param _fullname the name printed on the check\n', '    /// @param _amount the amount in currency in the chek\n', '    /// @param _checkFilePath the url path where the cheque has been uploaded\n', '    /// @param _digitalCheckFingerPrint the hash of the file\n', '    /// @param _tokens number of tokens issued to the beneficiary\n', '    function registerUBetCheck(address _beneficiary, string _accountId,  string _accountNumber, string _routingNumber, string _institution, string _fullname,  uint256 _amount, string _checkFilePath, string _digitalCheckFingerPrint, uint256 _tokens) public payable onlyOwner {\n', '      \n', '      require(_beneficiary != address(0));\n', '      require(bytes(_accountId).length != 0);\n', '      require(bytes(_accountNumber).length != 0);\n', '      require(bytes(_routingNumber).length != 0);\n', '      require(bytes(_institution).length != 0);\n', '      require(bytes(_fullname).length != 0);\n', '      require(_amount > 0);\n', '      require(_tokens > 0);\n', '      require(bytes(_checkFilePath).length != 0);\n', '      require(bytes(_digitalCheckFingerPrint).length != 0);\n', '      \n', '      var __conToken = _tokens * (10**(decimals));\n', '      \n', '      var uBetCheck = UBetChecks[_beneficiary];\n', '      \n', '      uBetCheck.accountId = _accountId;\n', '      uBetCheck.accountNumber = _accountNumber;\n', '      uBetCheck.routingNumber = _routingNumber;\n', '      uBetCheck.institution = _institution;\n', '      uBetCheck.fullName = _fullname;\n', '      uBetCheck.amount = _amount;\n', '      uBetCheck.tokens = _tokens;\n', '      \n', '      uBetCheck.checkFilePath = _checkFilePath;\n', '      uBetCheck.digitalCheckFingerPrint = _digitalCheckFingerPrint;\n', '      \n', '      totalUBetCheckAmounts = safeAdd(totalUBetCheckAmounts, _amount);\n', '      tokenSupplyFromCheck = safeAdd(tokenSupplyFromCheck, _tokens);\n', '      \n', '      uBetCheckAccts.push(_beneficiary) -1;\n', '      \n', '      // Issue token when registered UBetCheck is complete to the _beneficiary\n', '      doIssueTokens(_beneficiary, __conToken);\n', '      \n', '      // Fire Event UbetCheckIssue\n', '      UbetCheckIssue(_accountId);\n', '    }\n', '    \n', '    /// @dev List all the checks in the\n', '    function getUBetChecks() public returns (address[]) {\n', '      return uBetCheckAccts;\n', '    }\n', '    \n', '    /// @dev Return UBetCheck information by supplying beneficiary adddress\n', '    function getUBetCheck(address _address) public returns(string, string, string, string, uint256, string, string) {\n', '            \n', '      return (UBetChecks[_address].accountNumber,\n', '              UBetChecks[_address].routingNumber,\n', '              UBetChecks[_address].institution,\n', '              UBetChecks[_address].fullName,\n', '              UBetChecks[_address].amount,\n', '              UBetChecks[_address].checkFilePath,\n', '              UBetChecks[_address].digitalCheckFingerPrint);\n', '    }\n', '    \n', '    /// @dev This default function allows token to be purchased by directly\n', '    /// sending ether to this smart contract.\n', '    function () public payable {\n', '      purchaseTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev return total count of registered UBet Checks\n', '    function countUBetChecks() public returns (uint) {\n', '        return uBetCheckAccts.length;\n', '    }\n', '    \n', '\n', '    /// @dev issue tokens for a single buyer\n', '    /// @param _beneficiary addresses that the tokens will be sent to.\n', '    /// @param _tokens the amount of tokens, with decimals expanded (full).\n', '    function doIssueTokens(address _beneficiary, uint256 _tokens) internal {\n', '      require(_beneficiary != address(0));    \n', '\n', '      // compute without actually increasing it\n', '      uint256 increasedTotalSupply = safeAdd(totalSupply, _tokens);\n', '      \n', '      // increase token total supply\n', '      totalSupply = increasedTotalSupply;\n', '      // update the beneficiary balance to number of tokens sent\n', '      balances[_beneficiary] = safeAdd(balances[_beneficiary], _tokens);\n', '      \n', '      Transfer(msg.sender, _beneficiary, _tokens);\n', '    \n', '      // event is fired when tokens issued\n', '      Issue(\n', '          issueIndex++,\n', '          _beneficiary,\n', '          _tokens\n', '      );\n', '    }\n', '    \n', '    /// @dev Issue token based on Ether received.\n', '    /// @param _beneficiary Address that newly issued token will be sent to.\n', '    function purchaseTokens(address _beneficiary) public payable {\n', '      // only accept a minimum amount of ETH?\n', '      require(msg.value >= 0.00104 ether);\n', '     \n', '      uint _tokens = safeDiv(safeMul(msg.value, ratePerOneEther), (10**(18-decimals)));\n', '      doIssueTokens(_beneficiary, _tokens);\n', '\n', '      /// forward the money to the money wallet\n', '      moneyWallet.transfer(this.balance);\n', '    }\n', '    \n', '    \n', '    /// @dev Change money wallet owner\n', '    /// @param _address new address to received the ether\n', '    function setMoneyWallet(address _address) public onlyOwner {\n', '        moneyWallet = _address;\n', '    }\n', '    \n', '    /// @dev Change Rate per token in one ether\n', '    /// @param _value the amount of tokens, with decimals expanded (full).\n', '    function setRatePerOneEther(uint256 _value) public onlyOwner {\n', '      require(_value >= 1);\n', '      ratePerOneEther = _value;\n', '    }\n', '    \n', '}']
