['pragma solidity 0.4.24;\n', 'pragma experimental "v0.5.0";\n', '\n', '/*\n', '\n', '    Copyright 2018 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/external/0x/v1/ZeroExExchangeInterfaceV1.sol\n', '\n', '/// @title Exchange - Facilitates exchange of ERC20 tokens.\n', '/// @author Amir Bandeali - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f6e62667d4f3f775f7d60656a6c7b216c6062">[email&#160;protected]</a>>, Will Warren - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6c1b0500002c5c143c1e0306090f18420f0301">[email&#160;protected]</a>>\n', 'contract ZeroExExchangeInterfaceV1 {\n', '    // Error Codes\n', '    enum Errors {\n', '        ORDER_EXPIRED,                    // Order has already expired\n', '        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\n', '        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\n', '        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\n', '    }\n', '\n', '    string constant public VERSION = "1.0.0";\n', '    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\n', '\n', '    address public ZRX_TOKEN_CONTRACT;\n', '    address public TOKEN_TRANSFER_PROXY_CONTRACT;\n', '\n', '    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\n', '    mapping (bytes32 => uint256) public filled;\n', '    mapping (bytes32 => uint256) public cancelled;\n', '\n', '    /*\n', '    * Core exchange functions\n', '    */\n', '\n', '    /// @dev Fills the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Total amount of takerToken filled in trade.\n', '    function fillOrder(\n', '        address[5] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        returns (uint256 filledTakerTokenAmount);\n', '\n', '    /// @dev Cancels the input order.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\n', '    /// @return Amount of takerToken cancelled.\n', '    function cancelOrder(\n', '        address[5] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 cancelTakerTokenAmount)\n', '        public\n', '        returns (uint256);\n', '\n', '    /*\n', '    * Wrapper functions\n', '    */\n', '\n', '    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    function fillOrKillOrder(\n', '        address[5] orderAddresses,\n', '        uint256[6] orderValues,\n', '        uint256 fillTakerTokenAmount,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public;\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint256 arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrders(\n', '        address[5][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256[] fillTakerTokenAmounts,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public;\n', '\n', '    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint256 arrays containing individual order values.\n', '    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    function batchFillOrKillOrders(\n', '        address[5][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256[] fillTakerTokenAmounts,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public;\n', '\n', '    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint256 arrays containing individual order values.\n', '    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\n', '    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\n', '    /// @param v Array ECDSA signature v parameters.\n', '    /// @param r Array of ECDSA signature r parameters.\n', '    /// @param s Array of ECDSA signature s parameters.\n', '    /// @return Total amount of fillTakerTokenAmount filled in orders.\n', '    function fillOrdersUpTo(\n', '        address[5][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256 fillTakerTokenAmount,\n', '        bool shouldThrowOnInsufficientBalanceOrAllowance,\n', '        uint8[] v,\n', '        bytes32[] r,\n', '        bytes32[] s)\n', '        public\n', '        returns (uint256);\n', '\n', '    /// @dev Synchronously cancels multiple orders in a single transaction.\n', '    /// @param orderAddresses Array of address arrays containing individual order addresses.\n', '    /// @param orderValues Array of uint256 arrays containing individual order values.\n', '    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\n', '    function batchCancelOrders(\n', '        address[5][] orderAddresses,\n', '        uint256[6][] orderValues,\n', '        uint256[] cancelTakerTokenAmounts)\n', '        public;\n', '\n', '    /*\n', '    * Constant public functions\n', '    */\n', '\n', '    /// @dev Calculates Keccak-256 hash of order with specified parameters.\n', '    /// @param orderAddresses Array of order&#39;s maker, taker, makerToken, takerToken, and feeRecipient.\n', '    /// @param orderValues Array of order&#39;s makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\n', '    /// @return Keccak-256 hash of order.\n', '    function getOrderHash(address[5] orderAddresses, uint256[6] orderValues)\n', '        public\n', '        view\n', '        returns (bytes32);\n', '\n', '    /// @dev Verifies that an order signature is valid.\n', '    /// @param signer address of signer.\n', '    /// @param hash Signed Keccak-256 hash.\n', '    /// @param v ECDSA signature parameter v.\n', '    /// @param r ECDSA signature parameters r.\n', '    /// @param s ECDSA signature parameters s.\n', '    /// @return Validity of order signature.\n', '    function isValidSignature(\n', '        address signer,\n', '        bytes32 hash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '        pure\n', '        returns (bool);\n', '\n', '    /// @dev Checks if rounding error > 0.1%.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to multiply with numerator/denominator.\n', '    /// @return Rounding error is present.\n', '    function isRoundingError(uint256 numerator, uint256 denominator, uint256 target)\n', '        public\n', '        pure\n', '        returns (bool);\n', '\n', '    /// @dev Calculates partial value given a numerator and denominator.\n', '    /// @param numerator Numerator.\n', '    /// @param denominator Denominator.\n', '    /// @param target Value to calculate partial of.\n', '    /// @return Partial value of target.\n', '    function getPartialAmount(uint256 numerator, uint256 denominator, uint256 target)\n', '        public\n', '        pure\n', '        returns (uint256);\n', '\n', '    /// @dev Calculates the sum of values already filled and cancelled for a given order.\n', '    /// @param orderHash The Keccak-256 hash of the given order.\n', '    /// @return Sum of values already filled and cancelled.\n', '    function getUnavailableTakerTokenAmount(bytes32 orderHash)\n', '        public\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/lib/MathHelpers.sol\n', '\n', '/**\n', ' * @title MathHelpers\n', ' * @author dYdX\n', ' *\n', ' * This library helps with common math functions in Solidity\n', ' */\n', 'library MathHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              target * numerator / denominator\n', '     */\n', '    function getPartialAmount(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return numerator.mul(target).div(denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates partial value given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator\n', '     * @param  denominator  Denominator\n', '     * @param  target       Value to calculate partial of\n', '     * @return              Rounded-up result of target * numerator / denominator\n', '     */\n', '    function getPartialAmountRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator,\n', '        uint256 target\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return divisionRoundedUp(numerator.mul(target), denominator);\n', '    }\n', '\n', '    /**\n', '     * Calculates division given a numerator and denominator, rounded up.\n', '     *\n', '     * @param  numerator    Numerator.\n', '     * @param  denominator  Denominator.\n', '     * @return              Rounded-up result of numerator / denominator\n', '     */\n', '    function divisionRoundedUp(\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(denominator != 0); // coverage-enable-line\n', '        if (numerator == 0) {\n', '            return 0;\n', '        }\n', '        return numerator.sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint256(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 2 ** 256 - 1;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256 in solidity\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUint32(\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        return 2 ** 32 - 1;\n', '    }\n', '\n', '    /**\n', '     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n', '     *\n', '     * @param  n  The uint256 to get the number of bits in\n', '     * @return    The number of bits in n\n', '     */\n', '    function getNumBits(\n', '        uint256 n\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 first = 0;\n', '        uint256 last = 256;\n', '        while (first < last) {\n', '            uint256 check = (first + last) / 2;\n', '            if ((n >> check) == 0) {\n', '                last = check;\n', '            } else {\n', '                first = check + 1;\n', '            }\n', '        }\n', '        assert(first <= 256);\n', '        return first;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/GeneralERC20.sol\n', '\n', '/**\n', ' * @title GeneralERC20\n', ' * @author dYdX\n', ' *\n', ' * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n', ' * that we dont automatically revert when calling non-compliant tokens that have no return value for\n', ' * transfer(), transferFrom(), or approve().\n', ' */\n', 'interface GeneralERC20 {\n', '    function totalSupply(\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(\n', '        address who\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address spender,\n', '        uint256 value\n', '    )\n', '        external;\n', '}\n', '\n', '// File: contracts/lib/TokenInteract.sol\n', '\n', '/**\n', ' * @title TokenInteract\n', ' * @author dYdX\n', ' *\n', ' * This library contains functions for interacting with ERC20 tokens\n', ' */\n', 'library TokenInteract {\n', '    function balanceOf(\n', '        address token,\n', '        address owner\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).balanceOf(owner);\n', '    }\n', '\n', '    function allowance(\n', '        address token,\n', '        address owner,\n', '        address spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return GeneralERC20(token).allowance(owner, spender);\n', '    }\n', '\n', '    function approve(\n', '        address token,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        GeneralERC20(token).approve(spender, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#approve: Approval failed"\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        address from = address(this);\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transfer(to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transfer: Transfer failed"\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        internal\n', '    {\n', '        if (\n', '            amount == 0\n', '            || from == to\n', '        ) {\n', '            return;\n', '        }\n', '\n', '        GeneralERC20(token).transferFrom(from, to, amount);\n', '\n', '        require(\n', '            checkSuccess(),\n', '            "TokenInteract#transferFrom: TransferFrom failed"\n', '        );\n', '    }\n', '\n', '    // ============ Private Helper-Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 32 bytes that are not all-zero.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        uint256 returnValue = 0;\n', '\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned: check if non-zero\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        return returnValue != 0;\n', '    }\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeReader.sol\n', '\n', '/**\n', ' * @title ExchangeReader\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that wraps an exchange and provides information about the current state of the\n', ' * exchange or particular orders\n', ' */\n', 'interface ExchangeReader {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Get the maxmimum amount of makerToken for some order\n', '     *\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      Maximum amount of makerToken\n', '     */\n', '    function getMaxMakerAmount(\n', '        address makerToken,\n', '        address takerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/interfaces/ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n', ' * with other smart contracts through a common interface.\n', ' */\n', 'interface ExchangeWrapper {\n', '\n', '    // ============ Public Functions ============\n', '\n', '    /**\n', '     * Exchange some amount of takerToken for makerToken.\n', '     *\n', '     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n', '     *                              cannot always be trusted as it is set at the discretion of the\n', '     *                              msg.sender)\n', '     * @param  receiver             Address to set allowance on once the trade has completed\n', '     * @param  makerToken           Address of makerToken, the token to receive\n', '     * @param  takerToken           Address of takerToken, the token to pay\n', '     * @param  requestedFillAmount  Amount of takerToken being paid\n', '     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                      The amount of makerToken received\n', '     */\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256);\n', '\n', '    /**\n', '     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n', '     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n', '     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n', '     * than desiredMakerToken\n', '     *\n', '     * @param  makerToken         Address of makerToken, the token to receive\n', '     * @param  takerToken         Address of takerToken, the token to pay\n', '     * @param  desiredMakerToken  Amount of makerToken requested\n', '     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n', '     * @return                    Amount of takerToken the needed to complete the transaction\n', '     */\n', '    function getExchangeCost(\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts/margin/external/exchangewrappers/ZeroExV1ExchangeWrapper.sol\n', '\n', '/**\n', ' * @title ZeroExV1ExchangeWrapper\n', ' * @author dYdX\n', ' *\n', ' * dYdX ExchangeWrapper to interface with 0x Version 1\n', ' */\n', 'contract ZeroExV1ExchangeWrapper is\n', '    ExchangeWrapper,\n', '    ExchangeReader\n', '{\n', '    using SafeMath for uint256;\n', '    using TokenInteract for address;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Order {\n', '        address maker;\n', '        address taker;\n', '        address feeRecipient;\n', '        uint256 makerTokenAmount;\n', '        uint256 takerTokenAmount;\n', '        uint256 makerFee;\n', '        uint256 takerFee;\n', '        uint256 expirationUnixTimestampSec;\n', '        uint256 salt;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    // ============ State Variables ============\n', '\n', '    // msg.senders that will put the correct tradeOriginator in callerData when doing an exchange\n', '    mapping (address => bool) public TRUSTED_MSG_SENDER;\n', '\n', '    // address of the ZeroEx V1 Exchange\n', '    address public ZERO_EX_EXCHANGE;\n', '\n', '    // address of the ZeroEx V1 TokenTransferProxy\n', '    address public ZERO_EX_TOKEN_PROXY;\n', '\n', '    // address of the ZRX token\n', '    address public ZRX;\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address zeroExExchange,\n', '        address zeroExProxy,\n', '        address zrxToken,\n', '        address[] trustedMsgSenders\n', '    )\n', '        public\n', '    {\n', '        ZERO_EX_EXCHANGE = zeroExExchange;\n', '        ZERO_EX_TOKEN_PROXY = zeroExProxy;\n', '        ZRX = zrxToken;\n', '\n', '        for (uint256 i = 0; i < trustedMsgSenders.length; i++) {\n', '            TRUSTED_MSG_SENDER[trustedMsgSenders[i]] = true;\n', '        }\n', '\n', '        // The ZRX token does not decrement allowance if set to MAX_UINT\n', '        // therefore setting it once to the maximum amount is sufficient\n', '        // NOTE: this is *not* standard behavior for an ERC20, so do not rely on it for other tokens\n', '        ZRX.approve(ZERO_EX_TOKEN_PROXY, MathHelpers.maxUint256());\n', '    }\n', '\n', '    // ============ Public Functions ============\n', '\n', '    function exchange(\n', '        address tradeOriginator,\n', '        address receiver,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount,\n', '        bytes orderData\n', '    )\n', '        external\n', '        returns (uint256)\n', '    {\n', '        Order memory order = parseOrder(orderData);\n', '\n', '        require(\n', '            requestedFillAmount <= order.takerTokenAmount,\n', '            "ZeroExV1ExchangeWrapper#exchange: Requested fill amount larger than order size"\n', '        );\n', '\n', '        require(\n', '            requestedFillAmount <= takerToken.balanceOf(address(this)),\n', '            "ZeroExV1ExchangeWrapper#exchange: Requested fill amount larger than tokens held"\n', '        );\n', '\n', '        transferTakerFee(\n', '            order,\n', '            tradeOriginator,\n', '            requestedFillAmount\n', '        );\n', '\n', '        ensureAllowance(\n', '            takerToken,\n', '            ZERO_EX_TOKEN_PROXY,\n', '            requestedFillAmount\n', '        );\n', '\n', '        uint256 receivedMakerTokenAmount = doTrade(\n', '            order,\n', '            makerToken,\n', '            takerToken,\n', '            requestedFillAmount\n', '        );\n', '\n', '        ensureAllowance(\n', '            makerToken,\n', '            receiver,\n', '            receivedMakerTokenAmount\n', '        );\n', '\n', '        return receivedMakerTokenAmount;\n', '    }\n', '\n', '    function getExchangeCost(\n', '        address /* makerToken */,\n', '        address /* takerToken */,\n', '        uint256 desiredMakerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Order memory order = parseOrder(orderData);\n', '\n', '        return MathHelpers.getPartialAmountRoundedUp(\n', '            order.takerTokenAmount,\n', '            order.makerTokenAmount,\n', '            desiredMakerToken\n', '        );\n', '    }\n', '\n', '    function getMaxMakerAmount(\n', '        address makerToken,\n', '        address takerToken,\n', '        bytes orderData\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address zeroExExchange = ZERO_EX_EXCHANGE;\n', '        Order memory order = parseOrder(orderData);\n', '\n', '        // order cannot be taken if expired\n', '        if (block.timestamp >= order.expirationUnixTimestampSec) {\n', '            return 0;\n', '        }\n', '\n', '        bytes32 orderHash = getOrderHash(\n', '            zeroExExchange,\n', '            makerToken,\n', '            takerToken,\n', '            order\n', '        );\n', '\n', '        uint256 unavailableTakerAmount =\n', '            ZeroExExchangeInterfaceV1(zeroExExchange).getUnavailableTakerTokenAmount(orderHash);\n', '        uint256 takerAmount = order.takerTokenAmount.sub(unavailableTakerAmount);\n', '        uint256 makerAmount = MathHelpers.getPartialAmount(\n', '            takerAmount,\n', '            order.takerTokenAmount,\n', '            order.makerTokenAmount\n', '        );\n', '\n', '        return makerAmount;\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function transferTakerFee(\n', '        Order memory order,\n', '        address tradeOriginator,\n', '        uint256 requestedFillAmount\n', '    )\n', '        private\n', '    {\n', '        if (order.feeRecipient == address(0)) {\n', '            return;\n', '        }\n', '\n', '        uint256 takerFee = MathHelpers.getPartialAmount(\n', '            requestedFillAmount,\n', '            order.takerTokenAmount,\n', '            order.takerFee\n', '        );\n', '\n', '        if (takerFee == 0) {\n', '            return;\n', '        }\n', '\n', '        require(\n', '            TRUSTED_MSG_SENDER[msg.sender],\n', '            "ZeroExV1ExchangeWrapper#transferTakerFee: Only trusted senders can dictate the fee payer"\n', '        );\n', '\n', '        ZRX.transferFrom(\n', '            tradeOriginator,\n', '            address(this),\n', '            takerFee\n', '        );\n', '    }\n', '\n', '    function doTrade(\n', '        Order memory order,\n', '        address makerToken,\n', '        address takerToken,\n', '        uint256 requestedFillAmount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        uint256 filledTakerTokenAmount = ZeroExExchangeInterfaceV1(ZERO_EX_EXCHANGE).fillOrder(\n', '            [\n', '                order.maker,\n', '                order.taker,\n', '                makerToken,\n', '                takerToken,\n', '                order.feeRecipient\n', '            ],\n', '            [\n', '                order.makerTokenAmount,\n', '                order.takerTokenAmount,\n', '                order.makerFee,\n', '                order.takerFee,\n', '                order.expirationUnixTimestampSec,\n', '                order.salt\n', '            ],\n', '            requestedFillAmount,\n', '            true,\n', '            order.v,\n', '            order.r,\n', '            order.s\n', '        );\n', '\n', '        require(\n', '            filledTakerTokenAmount == requestedFillAmount,\n', '            "ZeroExV1ExchangeWrapper#doTrade: Could not fill requested amount"\n', '        );\n', '\n', '        uint256 receivedMakerTokenAmount = MathHelpers.getPartialAmount(\n', '            filledTakerTokenAmount,\n', '            order.takerTokenAmount,\n', '            order.makerTokenAmount\n', '        );\n', '\n', '        return receivedMakerTokenAmount;\n', '    }\n', '\n', '    function ensureAllowance(\n', '        address token,\n', '        address spender,\n', '        uint256 requiredAmount\n', '    )\n', '        private\n', '    {\n', '        if (token.allowance(address(this), spender) >= requiredAmount) {\n', '            return;\n', '        }\n', '\n', '        token.approve(\n', '            spender,\n', '            MathHelpers.maxUint256()\n', '        );\n', '    }\n', '\n', '    function getOrderHash(\n', '        address exchangeAddress,\n', '        address makerToken,\n', '        address takerToken,\n', '        Order memory order\n', '    )\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                exchangeAddress,\n', '                order.maker,\n', '                order.taker,\n', '                makerToken,\n', '                takerToken,\n', '                order.feeRecipient,\n', '                order.makerTokenAmount,\n', '                order.takerTokenAmount,\n', '                order.makerFee,\n', '                order.takerFee,\n', '                order.expirationUnixTimestampSec,\n', '                order.salt\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Accepts a byte array with each variable padded to 32 bytes\n', '     */\n', '    function parseOrder(\n', '        bytes orderData\n', '    )\n', '        private\n', '        pure\n', '        returns (Order memory)\n', '    {\n', '        Order memory order;\n', '\n', '        /**\n', '         * Total: 384 bytes\n', '         * mstore stores 32 bytes at a time, so go in increments of 32 bytes\n', '         *\n', '         * NOTE: The first 32 bytes in an array stores the length, so we start reading from 32\n', '         */\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            mstore(order,           mload(add(orderData, 32)))  // maker\n', '            mstore(add(order, 32),  mload(add(orderData, 64)))  // taker\n', '            mstore(add(order, 64),  mload(add(orderData, 96)))  // feeRecipient\n', '            mstore(add(order, 96),  mload(add(orderData, 128))) // makerTokenAmount\n', '            mstore(add(order, 128), mload(add(orderData, 160))) // takerTokenAmount\n', '            mstore(add(order, 160), mload(add(orderData, 192))) // makerFee\n', '            mstore(add(order, 192), mload(add(orderData, 224))) // takerFee\n', '            mstore(add(order, 224), mload(add(orderData, 256))) // expirationUnixTimestampSec\n', '            mstore(add(order, 256), mload(add(orderData, 288))) // salt\n', '            mstore(add(order, 288), mload(add(orderData, 320))) // v\n', '            mstore(add(order, 320), mload(add(orderData, 352))) // r\n', '            mstore(add(order, 352), mload(add(orderData, 384))) // s\n', '        }\n', '\n', '        return order;\n', '    }\n', '}']