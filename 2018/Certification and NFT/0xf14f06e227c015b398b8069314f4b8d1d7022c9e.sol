['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library ArrayUtils {\n', '\n', '    /**\n', '     * Replace bytes in an array with bytes in another array, guarded by a "bytemask"\n', '     * \n', '     * @dev Mask must be 1/8th the size of the byte array. A 1-bit means the byte array can be changed.\n', '     * @param array The original array\n', '     * @param desired The target array\n', '     * @param mask The mask specifying which bytes can be changed\n', '     * @return The updated byte array (the parameter will be modified inplace)\n', '     */\n', '    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)\n', '        pure\n', '        internal\n', '    {\n', '        byte[8] memory bitmasks = [byte(2 ** 7), byte(2 ** 6), byte(2 ** 5), byte(2 ** 4), byte(2 ** 3), byte(2 ** 2), byte(2 ** 1), byte(2 ** 0)];\n', '        require(array.length == desired.length);\n', '        require(mask.length >= array.length / 8);\n', '        for (uint i = 0; i < array.length; i++ ) {\n', '            /* 1-bit means value can be changed. */\n', '            bool masked = (mask[i / 8] & bitmasks[i % 8]) == 0;\n', '            if (!masked) {\n', '                array[i] = desired[i];\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Test if two arrays are equal\n', '     * \n', '     * @dev Arrays must be of equal length, otherwise will return false\n', '     * @param a First array\n', '     * @param b Second array\n', '     * @return Whether or not all bytes in the arrays are equal\n', '     */\n', '    function arrayEq(bytes memory a, bytes memory b)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (a.length != b.length) {\n', '            return false;\n', '        }\n', '        for (uint i = 0; i < a.length; i++) {\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract ReentrancyGuarded {\n', '\n', '    bool reentrancyLock = false;\n', '\n', '    /* Prevent a contract function from being reentrant-called. */\n', '    modifier reentrancyGuard {\n', '        if (reentrancyLock) {\n', '            revert();\n', '        }\n', '        reentrancyLock = true;\n', '        _;\n', '        reentrancyLock = false;\n', '    }\n', '\n', '}\n', '\n', 'contract TokenRecipient {\n', '    event ReceivedEther(address indexed sender, uint amount);\n', '    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\n', '\n', '    /**\n', '     * @dev Receive tokens and generate a log event\n', '     * @param from Address from which to transfer tokens\n', '     * @param value Amount of tokens to transfer\n', '     * @param token Address of token\n', '     * @param extraData Additional data to log\n', '     */\n', '    function receiveApproval(address from, uint256 value, address token, bytes extraData) public {\n', '        ERC20 t = ERC20(token);\n', '        require(t.transferFrom(from, this, value));\n', '        ReceivedTokens(from, value, token, extraData);\n', '    }\n', '\n', '    /**\n', '     * @dev Receive Ether and generate a log event\n', '     */\n', '    function () payable public {\n', '        ReceivedEther(msg.sender, msg.value);\n', '    }\n', '}\n', '\n', 'contract ExchangeCore is ReentrancyGuarded {\n', '\n', '    /* The token used to pay exchange fees. */\n', '    ERC20 public exchangeToken;\n', '\n', '    /* User registry. */\n', '    ProxyRegistry public registry;\n', '\n', '    /* Cancelled / finalized orders, by hash. */\n', '    mapping(bytes32 => bool) public cancelledOrFinalized;\n', '\n', '    /* Orders verified by on-chain approval (alternative to ECDSA signatures so that smart contracts can place orders directly). */\n', '    mapping(bytes32 => bool) public approvedOrders;\n', '\n', '    /* An ECDSA signature. */ \n', '    struct Sig {\n', '        /* v parameter */\n', '        uint8 v;\n', '        /* r parameter */\n', '        bytes32 r;\n', '        /* s parameter */\n', '        bytes32 s;\n', '    }\n', '\n', '    /* An order on the exchange. */\n', '    struct Order {\n', '        /* Exchange address, intended as a versioning mechanism. */\n', '        address exchange;\n', '        /* Order maker address. */\n', '        address maker;\n', '        /* Order taker address, if specified. */\n', '        address taker;\n', '        /* Maker fee of the order (in Exchange fee tokens), unused for taker order. */\n', '        uint makerFee;\n', '        /* Taker fee of the order (in Exchange fee tokens), or maximum taker fee for a taker order. */\n', '        uint takerFee;\n', '        /* Order fee recipient or zero address for taker order. */\n', '        address feeRecipient;\n', '        /* Side (buy/sell). */\n', '        SaleKindInterface.Side side;\n', '        /* Kind of sale. */\n', '        SaleKindInterface.SaleKind saleKind;\n', '        /* Target. */\n', '        address target;\n', '        /* HowToCall. */\n', '        AuthenticatedProxy.HowToCall howToCall;\n', '        /* Calldata. */\n', '        bytes calldata;\n', '        /* Calldata replacement pattern. */\n', '        bytes replacementPattern;\n', '        /* Static call target, zero-address for no static call. */\n', '        address staticTarget;\n', '        /* Static call extra data. */\n', '        bytes staticExtradata;\n', '        /* Token used to pay for the order. */\n', '        ERC20 paymentToken;\n', '        /* Base price of the order (in paymentTokens). */\n', '        uint basePrice;\n', '        /* Auction extra parameter - minimum bid increment for English auctions, starting/ending price difference. */\n', '        uint extra;\n', '        /* Listing timestamp. */\n', '        uint listingTime;\n', '        /* Expiration timestamp - 0 for no expiry. */\n', '        uint expirationTime;\n', '        /* Order salt, used to prevent duplicate hashes. */\n', '        uint salt;\n', '    }\n', '    \n', '    event OrderApprovedPartOne    (bytes32 indexed hash, address exchange, address indexed maker, address taker, uint makerFee, uint takerFee, address indexed feeRecipient, SaleKindInterface.Side side, SaleKindInterface.SaleKind saleKind, address target, AuthenticatedProxy.HowToCall howToCall, bytes calldata);\n', '    event OrderApprovedPartTwo    (bytes32 indexed hash, bytes replacementPattern, address staticTarget, bytes staticExtradata, ERC20 paymentToken, uint basePrice, uint extra, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired);\n', '    event OrderCancelled          (bytes32 indexed hash);\n', '    event OrdersMatched           (bytes32 buyHash, bytes32 sellHash, address indexed maker, address indexed taker, uint price, bytes32 indexed metadata);\n', '\n', '    /**\n', '     * @dev Charge an address fees in protocol tokens\n', '     * @param from Address to charge fees\n', '     * @param to Address to receive fees\n', '     * @param amount Amount of protocol tokens to charge\n', '     */\n', '    function chargeFee(address from, address to, uint amount)\n', '        internal\n', '    {\n', '        if (amount > 0) {\n', '            require(exchangeToken.transferFrom(from, to, amount));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Execute a STATICCALL (introduced with Ethereum Metropolis, non-state-modifying external call)\n', '     * @param target Contract to call\n', '     * @param calldata Calldata (appended to extradata)\n', '     * @param extradata Base data for STATICCALL (probably function selector and argument encoding)\n', '     * @return The result of the call (success or failure)\n', '     */\n', '    function staticCall(address target, bytes memory calldata, bytes memory extradata)\n', '        public\n', '        view\n', '        returns (bool result)\n', '    {\n', '        bytes memory combined = new bytes(SafeMath.add(calldata.length, extradata.length));\n', '        for (uint i = 0; i < extradata.length; i++) {\n', '            combined[i] = extradata[i];\n', '        }\n', '        for (uint j = 0; j < calldata.length; j++) {\n', '            combined[j + extradata.length] = calldata[j];\n', '        }\n', '        assembly {\n', '            result := staticcall(gas, target, add(combined, 0x20), mload(combined), mload(0x40), 0)\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @dev Keccak256 order hash, part one\n', '     * @param order Order to hash\n', '     * @return Part one of the order hash \n', '     */\n', '    function hashOrderPartOne(Order memory order)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(order.exchange, order.maker, order.taker, order.makerFee, order.takerFee, order.feeRecipient, order.side, order.saleKind, order.target, order.howToCall, order.calldata, order.replacementPattern);\n', '    }\n', '\n', '    /**\n', '     * @dev Keccak256 order hash, part two\n', '     * @param order Order to hash\n', '     * @return Part two of the order hash\n', '     */\n', '    function hashOrderPartTwo(Order memory order)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt);\n', '    }\n', '\n', '    /**\n', '     * @dev Hash an order, returning the hash that a client must sign, including the standard message prefix\n', '     * @param order Order to hash\n', '     * @return Hash of message prefix, order hash part one, and order hash part two concatenated\n', '     */\n', '    function hashToSign(Order memory order)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 hash = keccak256(prefix, hashOrderPartOne(order), hashOrderPartTwo(order));\n', '        return hash;\n', '    }\n', '\n', '    /**\n', '     * @dev Assert an order is valid and return its hash\n', '     * @param order Order to validate\n', '     * @param sig ECDSA signature\n', '     */\n', '    function requireValidOrder(Order memory order, Sig memory sig)\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        bytes32 hash = hashToSign(order);\n', '        require(validateOrder(hash, order, sig));\n', '        return hash;\n', '    }\n', '\n', '    /**\n', '     * @dev Validate a provided order, hash, and signature\n', '     * @param hash Order hash (already calculated, passed to avoid recalculation)\n', '     * @param order Order to validate\n', '     * @param sig ECDSA signature\n', '     */\n', '    function validateOrder(bytes32 hash, Order memory order, Sig memory sig) \n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        /* Not done in an if-conditional to prevent unnecessary ecrecover evaluation, which seems to happen even though it should short-circuit. */\n', '\n', '        /* Order must be targeted at this protocol version (this Exchange contract). */\n', '        if (order.exchange != address(this)) {\n', '            return false;\n', '        }\n', '\n', '        /* Order must have not been canceled or already filled. */\n', '        if (cancelledOrFinalized[hash]) {\n', '            return false;\n', '        }\n', '        \n', '        /* Order must possess valid sale kind parameter combination. */\n', '        if (!SaleKindInterface.validateParameters(order.saleKind, order.expirationTime)) {\n', '            return false;\n', '        }\n', '\n', '        /* Order authentication. Order must be either:\n', '           (a) sent by maker */\n', '        if (msg.sender == order.maker) {\n', '            return true;\n', '        }\n', '  \n', '        /* (b) previously approved */\n', '        if (approvedOrders[hash]) {\n', '            return true;\n', '        }\n', '\n', '        /* or (c) ECDSA-signed by maker. */\n', '        if (ecrecover(hash, sig.v, sig.r, sig.s) == order.maker) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve an order and optionally mark it for orderbook inclusion. Must be called by the maker of the order\n', '     * @param order Order to approve\n', '     * @param orderbookInclusionDesired Whether orderbook providers should include the order in their orderbooks\n', '     */\n', '    function approveOrder(Order memory order, bool orderbookInclusionDesired)\n', '        internal\n', '    {\n', '        /* CHECKS */\n', '\n', '        /* Assert sender is authorized to approve order. */\n', '        require(msg.sender == order.maker);\n', '\n', '        /* Calculate order hash. */\n', '        bytes32 hash = hashToSign(order);\n', '\n', '        /* Assert order has not already been approved. */\n', '        require(!approvedOrders[hash]);\n', '\n', '        /* EFFECTS */\n', '    \n', '        /* Mark order as approved. */\n', '        approvedOrders[hash] = true;\n', '  \n', '        /* Log approval event. Must be split in two due to Solidity stack size limitations. */\n', '        {\n', '            OrderApprovedPartOne(hash, order.exchange, order.maker, order.taker, order.makerFee, order.takerFee, order.feeRecipient, order.side, order.saleKind, order.target, order.howToCall, order.calldata);\n', '        }\n', '        {   \n', '            OrderApprovedPartTwo(hash, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel an order, preventing it from being matched. Must be called by the maker of the order\n', '     * @param order Order to cancel\n', '     * @param sig ECDSA signature\n', '     */\n', '    function cancelOrder(Order memory order, Sig memory sig) \n', '        internal\n', '    {\n', '        /* CHECKS */\n', '\n', '        /* Calculate order hash. */\n', '        bytes32 hash = requireValidOrder(order, sig);\n', '\n', '        /* Assert sender is authorized to cancel order. */\n', '        require(msg.sender == order.maker);\n', '  \n', '        /* EFFECTS */\n', '      \n', '        /* Mark order as cancelled, preventing it from being matched. */\n', '        cancelledOrFinalized[hash] = true;\n', '\n', '        /* Log cancel event. */\n', '        OrderCancelled(hash);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the current price of an order (convenience function)\n', '     * @param order Order to calculate the price of\n', '     * @return The current price of the order\n', '     */\n', '    function calculateCurrentPrice (Order memory order)\n', '        internal  \n', '        view\n', '        returns (uint)\n', '    {\n', '        return SaleKindInterface.calculateFinalPrice(order.side, order.saleKind, order.basePrice, order.extra, order.listingTime, order.expirationTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the price two orders would match at, if in fact they would match (otherwise fail)\n', '     * @param buy Buy-side order\n', '     * @param sell Sell-side order\n', '     * @return Match price\n', '     */\n', '    function calculateMatchPrice(Order memory buy, Order memory sell)\n', '        view\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Calculate sell price. */\n', '        uint sellPrice = SaleKindInterface.calculateFinalPrice(sell.side, sell.saleKind, sell.basePrice, sell.extra, sell.listingTime, sell.expirationTime);\n', '\n', '        /* Calculate buy price. */\n', '        uint buyPrice = SaleKindInterface.calculateFinalPrice(buy.side, buy.saleKind, buy.basePrice, buy.extra, buy.listingTime, buy.expirationTime);\n', '\n', '        /* Require price cross. */\n', '        require(buyPrice >= sellPrice);\n', '        \n', '        /* Maker/taker priority. */\n', '        return sell.feeRecipient != address(0) ? sellPrice : buyPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Execute all ERC20 token transfers associated with an order match (fees and buyer => seller transfer)\n', '     * @param buy Buy-side order\n', '     * @param sell Sell-side order\n', '     */\n', '    function executeFundsTransfer(Order memory buy, Order memory sell)\n', '        internal\n', '        returns (uint)\n', '    {\n', '        /* Calculate match price. */\n', '        uint price = calculateMatchPrice(buy, sell);\n', '\n', '        /* Determine maker/taker and charge fees accordingly. */\n', '        if (sell.feeRecipient != address(0)) {\n', '            /* Sell-side order is maker. */\n', '      \n', '            /* Assert taker fee is less than or equal to maximum fee specified by buyer. */\n', '            require(sell.takerFee <= buy.takerFee);\n', '            \n', '            /* Charge maker fee to seller. */\n', '            chargeFee(sell.maker, sell.feeRecipient, sell.makerFee);\n', '\n', '            /* Charge taker fee to buyer. */\n', '            chargeFee(buy.maker, sell.feeRecipient, sell.takerFee);\n', '        } else {\n', '            /* Buy-side order is maker. */\n', '\n', '            /* Assert taker fee is less than or equal to maximum fee specified by seller. */\n', '            require(buy.takerFee <= sell.takerFee);\n', '\n', '            /* Charge maker fee to buyer. */\n', '            chargeFee(buy.maker, buy.feeRecipient, buy.makerFee);\n', '      \n', '            /* Charge taker fee to seller. */\n', '            chargeFee(sell.maker, buy.feeRecipient, buy.takerFee);\n', '        }\n', '\n', '        if (price > 0) {\n', '            /* Debit buyer and credit seller. */\n', '            require(sell.paymentToken.transferFrom(buy.maker, sell.maker, price));\n', '        }\n', '\n', '        return price;\n', '    }\n', '\n', '    /**\n', '     * @dev Return whether or not two orders can be matched with each other by basic parameters (does not check order signatures / calldata or perform static calls)\n', '     * @param buy Buy-side order\n', '     * @param sell Sell-side order\n', '     * @return Whether or not the two orders can be matched\n', '     */\n', '    function ordersCanMatch(Order memory buy, Order memory sell)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return (\n', '            /* Must be opposite-side. */\n', '            (buy.side == SaleKindInterface.Side.Buy && sell.side == SaleKindInterface.Side.Sell) &&     \n', '            /* Must use same payment token. */\n', '            (buy.paymentToken == sell.paymentToken) &&\n', '            /* Must match maker/taker addresses. */\n', '            (sell.taker == address(0) || sell.taker == buy.maker) &&\n', '            (buy.taker == address(0) || buy.taker == sell.maker) &&\n', '            /* One must be maker and the other must be taker (no bool XOR in Solidity). */\n', '            ((sell.feeRecipient == address(0) && buy.feeRecipient != address(0)) || (sell.feeRecipient != address(0) && buy.feeRecipient == address(0))) &&\n', '            /* Must match target. */\n', '            (buy.target == sell.target) &&\n', '            /* Must match howToCall. */\n', '            (buy.howToCall == sell.howToCall) &&\n', '            /* Buy-side order must be settleable. */\n', '            SaleKindInterface.canSettleOrder(buy.listingTime, buy.expirationTime) &&\n', '            /* Sell-side order must be settleable. */\n', '            SaleKindInterface.canSettleOrder(sell.listingTime, sell.expirationTime)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock.\n', '     * @param buy Buy-side order\n', '     * @param buySig Buy-side order signature\n', '     * @param sell Sell-side order\n', '     * @param sellSig Sell-side order signature\n', '     */\n', '    function atomicMatch(Order memory buy, Sig memory buySig, Order memory sell, Sig memory sellSig, bytes32 metadata)\n', '        internal\n', '        reentrancyGuard\n', '    {\n', '        /* CHECKS */\n', '      \n', '        /* Ensure buy order validity and calculate hash. */\n', '        bytes32 buyHash = requireValidOrder(buy, buySig);\n', '\n', '        /* Ensure sell order validity and calculate hash. */\n', '        bytes32 sellHash = requireValidOrder(sell, sellSig); \n', '        \n', '        /* Must be matchable. */\n', '        require(ordersCanMatch(buy, sell));\n', '\n', '        /* Target must exist (prevent malicious selfdestructs just prior to order settlement). */\n', '        uint size;\n', '        address target = sell.target;\n', '        assembly {\n', '            size := extcodesize(target)\n', '        }\n', '        require(size > 0);\n', '      \n', '        /* Must match calldata after replacement, if specified. */ \n', '        if (buy.replacementPattern.length > 0) {\n', '          ArrayUtils.guardedArrayReplace(buy.calldata, sell.calldata, buy.replacementPattern);\n', '        }\n', '        if (sell.replacementPattern.length > 0) {\n', '          ArrayUtils.guardedArrayReplace(sell.calldata, buy.calldata, sell.replacementPattern);\n', '        }\n', '        require(ArrayUtils.arrayEq(buy.calldata, sell.calldata));\n', '\n', '        /* Retrieve proxy (the registry contract is trusted). */\n', '        AuthenticatedProxy proxy = registry.proxies(sell.maker);\n', '\n', '        /* Proxy must exist. */\n', '        require(proxy != address(0));\n', '\n', '        /* EFFECTS */\n', '\n', '        /* Mark orders as finalized. */\n', '        cancelledOrFinalized[buyHash] = true;\n', '        cancelledOrFinalized[sellHash] = true;\n', '\n', '        /* INTERACTIONS */\n', '\n', '        /* Execute funds transfer and pay fees. */\n', '        uint price = executeFundsTransfer(buy, sell);\n', '\n', '        /* Execute specified call through proxy. */\n', '        require(proxy.proxy(sell.target, sell.howToCall, sell.calldata));\n', '\n', '        /* Static calls are intentionally done after the effectful call so they can check resulting state. */\n', '\n', '        /* Handle buy-side static call if specified. */\n', '        if (buy.staticTarget != address(0)) {\n', '            require(staticCall(buy.staticTarget, sell.calldata, buy.staticExtradata));\n', '        }\n', '\n', '        /* Handle sell-side static call if specified. */\n', '        if (sell.staticTarget != address(0)) {\n', '            require(staticCall(sell.staticTarget, sell.calldata, sell.staticExtradata));\n', '        }\n', '\n', '        /* Log match event. */\n', '        OrdersMatched(buyHash, sellHash, sell.feeRecipient != address(0) ? sell.maker : buy.maker, sell.feeRecipient != address(0) ? buy.maker : sell.maker, price, metadata);\n', '    }\n', '\n', '}\n', '\n', 'contract Exchange is ExchangeCore {\n', '\n', '    /**\n', '     * @dev Call guardedArrayReplace - library function exposed for testing.\n', '     */\n', '    function guardedArrayReplace(bytes array, bytes desired, bytes mask)\n', '        public\n', '        pure\n', '        returns (bytes)\n', '    {\n', '        ArrayUtils.guardedArrayReplace(array, desired, mask);\n', '        return array;\n', '    }\n', '\n', '    /**\n', '     * @dev Call calculateFinalPrice - library function exposed for testing.\n', '     */\n', '    function calculateFinalPrice(SaleKindInterface.Side side, SaleKindInterface.SaleKind saleKind, uint basePrice, uint extra, uint listingTime, uint expirationTime)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return SaleKindInterface.calculateFinalPrice(side, saleKind, basePrice, extra, listingTime, expirationTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Call hashOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function hashOrder_(\n', '        address[7] addrs,\n', '        uint[7] uints,\n', '        SaleKindInterface.Side side,\n', '        SaleKindInterface.SaleKind saleKind,\n', '        AuthenticatedProxy.HowToCall howToCall,\n', '        bytes calldata,\n', '        bytes replacementPattern,\n', '        bytes staticExtradata)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    { \n', '        return hashToSign(\n', '          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6])\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Call validateOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function validateOrder_ (\n', '        address[7] addrs,\n', '        uint[7] uints,\n', '        SaleKindInterface.Side side,\n', '        SaleKindInterface.SaleKind saleKind,\n', '        AuthenticatedProxy.HowToCall howToCall,\n', '        bytes calldata,\n', '        bytes replacementPattern,\n', '        bytes staticExtradata,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        view\n', '        public\n', '        returns (bool)\n', '    {\n', '        Order memory order = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\n', '        return validateOrder(\n', '          hashToSign(order),\n', '          order,\n', '          Sig(v, r, s)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Call approveOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function approveOrder_ (\n', '        address[7] addrs,\n', '        uint[7] uints,\n', '        SaleKindInterface.Side side,\n', '        SaleKindInterface.SaleKind saleKind,\n', '        AuthenticatedProxy.HowToCall howToCall,\n', '        bytes calldata,\n', '        bytes replacementPattern,\n', '        bytes staticExtradata,\n', '        bool orderbookInclusionDesired) \n', '        public\n', '    {\n', '        Order memory order = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\n', '        return approveOrder(order, orderbookInclusionDesired);\n', '    }\n', '\n', '    /**\n', '     * @dev Call cancelOrder - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function cancelOrder_(\n', '        address[7] addrs,\n', '        uint[7] uints,\n', '        SaleKindInterface.Side side,\n', '        SaleKindInterface.SaleKind saleKind,\n', '        AuthenticatedProxy.HowToCall howToCall,\n', '        bytes calldata,\n', '        bytes replacementPattern,\n', '        bytes staticExtradata,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s)\n', '        public\n', '    {\n', '\n', '        return cancelOrder(\n', '          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]),\n', '          Sig(v, r, s)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Call calculateCurrentPrice - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function calculateCurrentPrice_(\n', '        address[7] addrs,\n', '        uint[7] uints,\n', '        SaleKindInterface.Side side,\n', '        SaleKindInterface.SaleKind saleKind,\n', '        AuthenticatedProxy.HowToCall howToCall,\n', '        bytes calldata,\n', '        bytes replacementPattern,\n', '        bytes staticExtradata)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return calculateCurrentPrice(\n', '          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], side, saleKind, addrs[4], howToCall, calldata, replacementPattern, addrs[5], staticExtradata, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6])\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Call ordersCanMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function ordersCanMatch_(\n', '        address[14] addrs,\n', '        uint[14] uints,\n', '        uint8[6] sidesKindsHowToCalls,\n', '        bytes calldataBuy,\n', '        bytes calldataSell,\n', '        bytes replacementPatternBuy,\n', '        bytes replacementPatternSell,\n', '        bytes staticExtradataBuy,\n', '        bytes staticExtradataSell)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        Order memory buy = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\n', '        Order memory sell = Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]);\n', '        return ordersCanMatch(\n', '          buy,\n', '          sell\n', '        );\n', '    }\n', '\n', '    /**\n', "     * @dev Return whether or not two orders' calldata specifications can match\n", '     * @param buyCalldata Buy-side order calldata\n', '     * @param buyReplacementPattern Buy-side order calldata replacement mask\n', '     * @param sellCalldata Sell-side order calldata\n', '     * @param sellReplacementPattern Sell-side order calldata replacement mask\n', "     * @return Whether the orders' calldata can be matched\n", '     */\n', '    function orderCalldataCanMatch(bytes buyCalldata, bytes buyReplacementPattern, bytes sellCalldata, bytes sellReplacementPattern)\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        ArrayUtils.guardedArrayReplace(buyCalldata, sellCalldata, buyReplacementPattern);\n', '        ArrayUtils.guardedArrayReplace(sellCalldata, buyCalldata, sellReplacementPattern);\n', '        return ArrayUtils.arrayEq(buyCalldata, sellCalldata);\n', '    }\n', '\n', '    /**\n', '     * @dev Call calculateMatchPrice - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function calculateMatchPrice_(\n', '        address[14] addrs,\n', '        uint[14] uints,\n', '        uint8[6] sidesKindsHowToCalls,\n', '        bytes calldataBuy,\n', '        bytes calldataSell,\n', '        bytes replacementPatternBuy,\n', '        bytes replacementPatternSell,\n', '        bytes staticExtradataBuy,\n', '        bytes staticExtradataSell)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        Order memory buy = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]);\n', '        Order memory sell = Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]);\n', '        return calculateMatchPrice(\n', '          buy,\n', '          sell\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Call atomicMatch - Solidity ABI encoding limitation workaround, hopefully temporary.\n', '     */\n', '    function atomicMatch_(\n', '        address[14] addrs,\n', '        uint[14] uints,\n', '        uint8[6] sidesKindsHowToCalls,\n', '        bytes calldataBuy,\n', '        bytes calldataSell,\n', '        bytes replacementPatternBuy,\n', '        bytes replacementPatternSell,\n', '        bytes staticExtradataBuy,\n', '        bytes staticExtradataSell,\n', '        uint8[2] vs,\n', '        bytes32[5] rssMetadata)\n', '        public\n', '    {\n', '        return atomicMatch(\n', '          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], addrs[3], SaleKindInterface.Side(sidesKindsHowToCalls[0]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[1]), addrs[4], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[2]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, ERC20(addrs[6]), uints[2], uints[3], uints[4], uints[5], uints[6]),\n', '          Sig(vs[0], rssMetadata[0], rssMetadata[1]),\n', '          Order(addrs[7], addrs[8], addrs[9], uints[7], uints[8], addrs[10], SaleKindInterface.Side(sidesKindsHowToCalls[3]), SaleKindInterface.SaleKind(sidesKindsHowToCalls[4]), addrs[11], AuthenticatedProxy.HowToCall(sidesKindsHowToCalls[5]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, ERC20(addrs[13]), uints[9], uints[10], uints[11], uints[12], uints[13]),\n', '          Sig(vs[1], rssMetadata[2], rssMetadata[3]),\n', '          rssMetadata[4]\n', '        );\n', '    }\n', '\n', '}\n', '\n', 'contract WyvernExchange is Exchange {\n', '\n', '    string public constant name = "Project Wyvern Exchange";\n', '\n', '    /**\n', '     * @dev Initialize a WyvernExchange instance\n', '     * @param registryAddress Address of the registry instance which this Exchange instance will use\n', '     * @param tokenAddress Address of the token used for protocol fees\n', '     */\n', '    function WyvernExchange (ProxyRegistry registryAddress, ERC20 tokenAddress) public {\n', '        exchangeToken = tokenAddress;\n', '        registry = registryAddress;\n', '    }\n', '\n', '}\n', '\n', 'library SaleKindInterface {\n', '\n', '    /**\n', '     * Side: buy or sell.\n', '     */\n', '    enum Side { Buy, Sell }\n', '\n', '    /**\n', '     * Currently supported kinds of sale: fixed price, Dutch auction. \n', '     * English auctions cannot be supported without stronger escrow guarantees.\n', '     * Future interesting options: Vickrey auction, nonlinear Dutch auctions.\n', '     */\n', '    enum SaleKind { FixedPrice, DutchAuction }\n', '\n', '    /**\n', '     * @dev Check whether the parameters of a sale are valid\n', '     * @param saleKind Kind of sale\n', '     * @param expirationTime Order expiration time\n', '     * @return Whether the parameters were valid\n', '     */\n', '    function validateParameters(SaleKind saleKind, uint expirationTime)\n', '        pure\n', '        internal\n', '        returns (bool)\n', '    {\n', '        /* Auctions must have a set expiration date. */\n', '        return (saleKind == SaleKind.FixedPrice || expirationTime > 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Return whether or not an order can be settled\n', '     * @dev Precondition: parameters have passed validateParameters\n', '     * @param listingTime Order listing time\n', '     * @param expirationTime Order expiration time\n', '     */\n', '    function canSettleOrder(uint listingTime, uint expirationTime)\n', '        view\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return (listingTime < now) && (expirationTime == 0 || now < expirationTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the settlement price of an order\n', '     * @dev Precondition: parameters have passed validateParameters.\n', '     * @param side Order side\n', '     * @param saleKind Method of sale\n', '     * @param basePrice Order base price\n', '     * @param extra Order extra price data\n', '     * @param listingTime Order listing time\n', '     * @param expirationTime Order expiration time\n', '     */\n', '    function calculateFinalPrice(Side side, SaleKind saleKind, uint basePrice, uint extra, uint listingTime, uint expirationTime)\n', '        view\n', '        internal\n', '        returns (uint finalPrice)\n', '    {\n', '        if (saleKind == SaleKind.FixedPrice) {\n', '            return basePrice;\n', '        } else if (saleKind == SaleKind.DutchAuction) {\n', '            uint diff = SafeMath.div(SafeMath.mul(extra, SafeMath.sub(now, listingTime)), SafeMath.sub(expirationTime, listingTime));\n', '            if (side == Side.Sell) {\n', '                /* Sell-side - start price: basePrice. End price: basePrice - extra. */\n', '                return SafeMath.sub(basePrice, diff);\n', '            } else {\n', '                /* Buy-side - start price: basePrice. End price: basePrice + extra. */\n', '                return SafeMath.add(basePrice, diff);\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract AuthenticatedProxy is TokenRecipient {\n', '\n', '    /* Address which owns this proxy. */\n', '    address public user;\n', '\n', '    /* Associated registry with contract authentication information. */\n', '    ProxyRegistry public registry;\n', '\n', '    /* Whether access has been revoked. */\n', '    bool public revoked;\n', '\n', '    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\n', '    enum HowToCall { Call, DelegateCall }\n', '\n', '    /* Event fired when the proxy access is revoked or unrevoked. */\n', '    event Revoked(bool revoked);\n', '\n', '    /**\n', '     * Create an AuthenticatedProxy\n', '     *\n', '     * @param addrUser Address of user on whose behalf this proxy will act\n', '     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\n', '     */\n', '    function AuthenticatedProxy(address addrUser, ProxyRegistry addrRegistry) public {\n', '        user = addrUser;\n', '        registry = addrRegistry;\n', '    }\n', '\n', '    /**\n', '     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\n', '     *\n', '     * @dev Can be called by the user only\n', '     * @param revoke Whether or not to revoke access\n', '     */\n', '    function setRevoke(bool revoke)\n', '        public\n', '    {\n', '        require(msg.sender == user);\n', '        revoked = revoke;\n', '        Revoked(revoke);\n', '    }\n', '\n', '    /**\n', '     * Execute a message call from the proxy contract\n', '     *\n', '     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\n', '     * @param dest Address to which the call will be sent\n', '     * @param howToCall Which kind of call to make\n', '     * @param calldata Calldata to send\n', '     * @return Result of the call (success or failure)\n', '     */\n', '    function proxy(address dest, HowToCall howToCall, bytes calldata)\n', '        public\n', '        returns (bool result)\n', '    {\n', '        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)));\n', '        if (howToCall == HowToCall.Call) {\n', '            result = dest.call(calldata);\n', '        } else if (howToCall == HowToCall.DelegateCall) {\n', '            result = dest.delegatecall(calldata);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Execute a message call and assert success\n', '     * \n', '     * @dev Same functionality as `proxy`, just asserts the return value\n', '     * @param dest Address to which the call will be sent\n', '     * @param howToCall What kind of call to make\n', '     * @param calldata Calldata to send\n', '     */\n', '    function proxyAssert(address dest, HowToCall howToCall, bytes calldata)\n', '        public\n', '    {\n', '        require(proxy(dest, howToCall, calldata));\n', '    }\n', '\n', '}\n', '\n', 'contract ProxyRegistry is Ownable {\n', '\n', '    /* Authenticated proxies by user. */\n', '    mapping(address => AuthenticatedProxy) public proxies;\n', '\n', '    /* Contracts pending access. */\n', '    mapping(address => uint) public pending;\n', '\n', '    /* Contracts allowed to call those proxies. */\n', '    mapping(address => bool) public contracts;\n', '\n', '    /* Delay period for adding an authenticated contract.\n', '       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\n', '       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\n', '       plenty of time to notice and transfer their assets.\n', '    */\n', '    uint public DELAY_PERIOD = 2 weeks;\n', '\n', '    /**\n', '     * Start the process to enable access for specified contract. Subject to delay period.\n', '     *\n', '     * @dev ProxyRegistry owner only\n', '     * @param addr Address to which to grant permissions\n', '     */\n', '    function startGrantAuthentication (address addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(!contracts[addr] && pending[addr] == 0);\n', '        pending[addr] = now;\n', '    }\n', '\n', '    /**\n', '     * End the process to nable access for specified contract after delay period has passed.\n', '     *\n', '     * @dev ProxyRegistry owner only\n', '     * @param addr Address to which to grant permissions\n', '     */\n', '    function endGrantAuthentication (address addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < now));\n', '        pending[addr] = 0;\n', '        contracts[addr] = true;\n', '    }\n', '\n', '    /**\n', '     * Revoke access for specified contract. Can be done instantly.\n', '     *\n', '     * @dev ProxyRegistry owner only\n', '     * @param addr Address of which to revoke permissions\n', '     */    \n', '    function revokeAuthentication (address addr)\n', '        public\n', '        onlyOwner\n', '    {\n', '        contracts[addr] = false;\n', '    }\n', '\n', '    /**\n', '     * Register a proxy contract with this registry\n', '     *\n', '     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\n', '     * @return New AuthenticatedProxy contract\n', '     */\n', '    function registerProxy()\n', '        public\n', '        returns (AuthenticatedProxy proxy)\n', '    {\n', '        require(proxies[msg.sender] == address(0));\n', '        proxy = new AuthenticatedProxy(msg.sender, this);\n', '        proxies[msg.sender] = proxy;\n', '        return proxy;\n', '    }\n', '\n', '}']