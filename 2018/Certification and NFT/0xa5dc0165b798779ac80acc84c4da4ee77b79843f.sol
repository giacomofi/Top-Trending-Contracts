['pragma solidity ^0.4.18;\n', '\n', '/**\n', '*\n', '*    I  N    P  I  Z  Z  A     W  E     C  R  U  S  T\n', '*  \n', '*    ______ ____   _____       _____ _\n', '*   |  ____/ __ \\ / ____|     |  __ (_)\n', '*   | |__ | |  | | (___       | |__) | __________ _\n', '*   |  __|| |  | |\\___ \\      |  ___/ |_  /_  / _` |\n', '*   | |___| |__| |____) |  _  | |   | |/ / / / (_| |\n', '*   |______\\____/|_____/  (_) |_|   |_/___/___\\__,_|\n', '*\n', '*\n', '*\n', '*   CHECK HTTPS://EOS.PIZZA ON HOW TO GET YOUR SLICE\n', '*   END: 18 MAY 2018\n', '*\n', '*   This is for the fun. Thank you token factory for your smart contract inspiration.\n', '*   Jummy & crusty. Get your &#127829;EPS while it&#39;s hot. \n', '*\n', '*   https://eos.pizza\n', '*\n', '*\n', '**/\n', '\n', '// File: contracts\\configs\\EosPizzaSliceConfig.sol\n', '\n', '\n', '/**\n', ' * @title EosPizzaSliceConfig\n', ' *\n', ' * @dev The static configuration for the EOS Pizza Slice.\n', ' */\n', 'contract EosPizzaSliceConfig {\n', '    // The name of the token.\n', '    string constant NAME = "EOS.Pizza";\n', '\n', '    // The symbol of the token.\n', '    string constant SYMBOL = "EPS";\n', '\n', '    // The number of decimals for the token.\n', '    uint8 constant DECIMALS = 18;  // Same as ethers.\n', '\n', '    // Decimal factor for multiplication purposes.\n', '    uint constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\n', '}\n', '\n', '// File: contracts\\interfaces\\ERC20TokenInterface.sol\n', '\n', '/**\n', ' * @dev The standard ERC20 Token interface.\n', ' */\n', 'contract ERC20TokenInterface {\n', '    uint public totalSupply;  /* shorthand for public function and a property */\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '}\n', '\n', '// File: contracts\\libraries\\SafeMath.sol\n', '\n', '/**\n', ' * @dev Library that helps prevent integer overflows and underflows,\n', ' * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\n', ' */\n', 'library SafeMath {\n', '    function plus(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function minus(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\ERC20Token.sol\n', '\n', '/**\n', ' * @title ERC20Token\n', ' *\n', ' * @dev Implements the operations declared in the `ERC20TokenInterface`.\n', ' */\n', 'contract ERC20Token is ERC20TokenInterface {\n', '    using SafeMath for uint;\n', '\n', '    // Token account balances.\n', '    mapping (address => uint) balances;\n', '\n', '    // Delegated number of tokens to transfer.\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '\n', '    /**\n', '     * @dev Checks the balance of a certain address.\n', '     *\n', '     * @param _account The address which&#39;s balance will be checked.\n', '     *\n', '     * @return Returns the balance of the `_account` address.\n', '     */\n', '    function balanceOf(address _account) public constant returns (uint balance) {\n', '        return balances[_account];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers tokens from one address to another.\n', '     *\n', '     * @param _to The target address to which the `_value` number of tokens will be sent.\n', '     * @param _value The number of tokens to send.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        if (balances[msg.sender] < _value || _value == 0) {\n', '\n', '            return false;\n', '        }\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] = balances[_to].plus(_value);\n', '\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\n', '     *\n', '     * @param _from The address of the sender.\n', '     * @param _to The address of the recipient.\n', '     * @param _value The number of tokens to be transferred.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {\n', '            return false;\n', '        }\n', '\n', '        balances[_to] = balances[_to].plus(_value);\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows another contract to spend some tokens on your behalf.\n', '     *\n', '     * @param _spender The address of the account which will be approved for transfer of tokens.\n', '     * @param _value The number of tokens to be approved for transfer.\n', '     *\n', '     * @return Whether the approval was successful or not.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\n', '     *\n', '     * @param _owner The account which allowed the transfer.\n', '     * @param _spender The account which will spend the tokens.\n', '     *\n', '     * @return The number of tokens to be transferred.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\HasOwner.sol\n', '\n', '/**\n', ' * @title HasOwner\n', ' *\n', ' * @dev Allows for exclusive access to certain functionality.\n', ' */\n', 'contract HasOwner {\n', '    // Current owner.\n', '    address public owner;\n', '\n', '    // Conditionally the new owner.\n', '    address public newOwner;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _owner The address of the owner.\n', '     */\n', '    function HasOwner(address _owner) internal {\n', '        owner = _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Access control modifier that allows only the current owner to call the function.\n', '     */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev The event is fired when the current owner is changed.\n', '     *\n', '     * @param _oldOwner The address of the previous owner.\n', '     * @param _newOwner The address of the new owner.\n', '     */\n', '    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\n', '\n', '    /**\n', '     * @dev Transfering the ownership is a two-step process, as we prepare\n', '     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\n', '     * the transfer. This prevents accidental lock-out if something goes wrong\n', '     * when passing the `newOwner` address.\n', '     *\n', '     * @param _newOwner The address of the proposed new owner.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev The `newOwner` finishes the ownership transfer process by accepting the\n', '     * ownership.\n', '     */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '\n', '        OwnershipTransfer(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\Freezable.sol\n', '\n', '/**\n', ' * @title Freezable\n', ' * @dev This trait allows to freeze the transactions in a Token\n', ' */\n', 'contract Freezable is HasOwner {\n', '  bool public frozen = false;\n', '\n', '  /**\n', '   * @dev Modifier makes methods callable only when the contract is not frozen.\n', '   */\n', '  modifier requireNotFrozen() {\n', '    require(!frozen);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to "freeze" the contract.\n', '   */\n', '  function freeze() onlyOwner public {\n', '    frozen = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to "unfreeze" the contract.\n', '   */\n', '  function unfreeze() onlyOwner public {\n', '    frozen = false;\n', '  }\n', '}\n', '\n', '// File: contracts\\traits\\FreezableERC20Token.sol\n', '\n', '/**\n', ' * @title FreezableERC20Token\n', ' *\n', ' * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\n', ' */\n', 'contract FreezableERC20Token is ERC20Token, Freezable {\n', '    /**\n', '     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\n', '     *\n', '     * @param _to The target address to which the `_value` number of tokens will be sent.\n', '     * @param _value The number of tokens to send.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\n', '     *\n', '     * @param _from The address of the sender.\n', '     * @param _to The address of the recipient.\n', '     * @param _value The number of tokens to be transferred.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows another contract to spend some tokens on your behalf.\n', '     *\n', '     * @param _spender The address of the account which will be approved for transfer of tokens.\n', '     * @param _value The number of tokens to be approved for transfer.\n', '     *\n', '     * @return Whether the approval was successful or not.\n', '     */\n', '    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts\\EosPizzaSlice.sol\n', '\n', '/**\n', ' * @title EOS Pizza Slice\n', ' *\n', ' * @dev A standard token implementation of the ERC20 token standard with added\n', ' *      HasOwner trait and initialized using the configuration constants.\n', ' */\n', 'contract EosPizzaSlice is EosPizzaSliceConfig, HasOwner, FreezableERC20Token {\n', '    // The name of the token.\n', '    string public name;\n', '\n', '    // The symbol for the token.\n', '    string public symbol;\n', '\n', '    // The decimals of the token.\n', '    uint8 public decimals;\n', '\n', '    /**\n', '     * @dev The constructor. Initially sets `totalSupply` and the balance of the\n', '     *      `owner` address according to the initialization parameter.\n', '     */\n', '    function EosPizzaSlice(uint _totalSupply) public\n', '        HasOwner(msg.sender)\n', '    {\n', '        name = NAME;\n', '        symbol = SYMBOL;\n', '        decimals = DECIMALS;\n', '        totalSupply = _totalSupply;\n', '        balances[owner] = _totalSupply;\n', '    }\n', '}\n', '\n', '// File: contracts\\configs\\EosPizzaSliceDonationraiserConfig.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceDonationraiserConfig\n', ' *\n', ' * @dev The static configuration for the EOS Pizza Slice donationraiser.\n', ' */\n', 'contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig {\n', '    // The number of &#127829; per 1 ETH.\n', '    uint constant CONVERSION_RATE = 100000;\n', '\n', '    // The public sale hard cap of the donationraiser.\n', '    uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR;\n', '\n', '    // The start date of the donationraiser: Friday, 9 March 2018 21:22:22 UTC.\n', '    uint constant START_DATE = 1520630542;\n', '\n', '    // The end date of the donationraiser:  May 18, 2018, 12:35:20 AM UTC - Bitcoin Pizza 8th year celebration moment.\n', '    uint constant END_DATE =  1526603720;\n', '\n', '\n', '    // Total number of tokens locked for the &#127829; core team.\n', '    uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR;\n', '\n', '    // Total number of tokens locked for &#127829; advisors.\n', '    uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR;\n', '\n', '    // The release date for tokens locked for the &#127829; core team.\n', '    uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days;\n', '\n', '    // The release date for tokens locked for &#127829; advisors.\n', '    uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days;\n', '\n', '    // Total number of tokens locked for bounty program.\n', '    uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR;\n', '\n', '    // Maximum gas price limit\n', '    uint constant MAX_GAS_PRICE = 90000000000 wei; // 90 gwei/shanon\n', '\n', '    // Minimum individual contribution\n', '    uint constant MIN_CONTRIBUTION =  0.05 ether;\n', '\n', '    // Individual limit in ether\n', '    uint constant INDIVIDUAL_ETHER_LIMIT =  4999 ether;\n', '}\n', '\n', '// File: contracts\\traits\\TokenSafe.sol\n', '\n', '/**\n', ' * @title TokenSafe\n', ' *\n', ' * @dev A multi-bundle token safe contract that contains locked tokens released after a date for the specific bundle type.\n', ' */\n', 'contract TokenSafe {\n', '    using SafeMath for uint;\n', '\n', '    struct AccountsBundle {\n', '        // The total number of tokens locked.\n', '        uint lockedTokens;\n', '        // The release date for the locked tokens\n', '        // Note: Unix timestamp fits uint32, however block.timestamp is uint\n', '        uint releaseDate;\n', '        // The balances for the &#127829; locked token accounts.\n', '        mapping (address => uint) balances;\n', '    }\n', '\n', '    // The account bundles of locked tokens grouped by release date\n', '    mapping (uint8 => AccountsBundle) public bundles;\n', '\n', '    // The `ERC20TokenInterface` contract.\n', '    ERC20TokenInterface token;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _token The address of the EOS Pizza Slices (donation) contract.\n', '     */\n', '    function TokenSafe(address _token) public {\n', '        token = ERC20TokenInterface(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev The function initializes the bundle of accounts with a release date.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _releaseDate Unix timestamp of the time after which the tokens can be released\n', '     */\n', '    function initBundle(uint8 _type, uint _releaseDate) internal {\n', '        bundles[_type].releaseDate = _releaseDate;\n', '    }\n', '\n', '    /**\n', '     * @dev Add new account with locked token balance to the specified bundle type.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _account The address of the account to be added.\n', '     * @param _balance The number of tokens to be locked.\n', '     */\n', '    function addLockedAccount(uint8 _type, address _account, uint _balance) internal {\n', '        var bundle = bundles[_type];\n', '        bundle.balances[_account] = bundle.balances[_account].plus(_balance);\n', '        bundle.lockedTokens = bundle.lockedTokens.plus(_balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows an account to be released if it meets the time constraints.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _account The address of the account to be released.\n', '     */\n', '    function releaseAccount(uint8 _type, address _account) internal {\n', '        var bundle = bundles[_type];\n', '        require(now >= bundle.releaseDate);\n', '        uint tokens = bundle.balances[_account];\n', '        require(tokens > 0);\n', '        bundle.balances[_account] = 0;\n', '        bundle.lockedTokens = bundle.lockedTokens.minus(tokens);\n', '        if (!token.transfer(_account, tokens)) {\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\EosPizzaSliceSafe.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceSafe\n', ' *\n', ' * @dev The EOS Pizza Slice safe containing all details about locked tokens.\n', ' */\n', 'contract EosPizzaSliceSafe is TokenSafe, EosPizzaSliceDonationraiserConfig {\n', '    // Bundle type constants\n', '    uint8 constant CORE_TEAM = 0;\n', '    uint8 constant ADVISORS = 1;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _token The address of the EOS Pizza (donation) contract.\n', '     */\n', '    function EosPizzaSliceSafe(address _token) public\n', '        TokenSafe(_token)\n', '    {\n', '        token = ERC20TokenInterface(_token);\n', '\n', '        /// Core team.\n', '        initBundle(CORE_TEAM,\n', '            TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE\n', '        );\n', '\n', '        // Accounts with tokens locked for the &#127829; core team.\n', '        addLockedAccount(CORE_TEAM, 0x3ce215b2e4dC9D2ba0e2fC5099315E4Fa05d8AA2, 35 * (10**6) * DECIMALS_FACTOR);\n', '\n', '\n', '        // Verify that the tokens add up to the constant in the configuration.\n', '        assert(bundles[CORE_TEAM].lockedTokens == TOKENS_LOCKED_CORE_TEAM);\n', '\n', '        /// Advisors.\n', '        initBundle(ADVISORS,\n', '            TOKENS_LOCKED_ADVISORS_RELEASE_DATE\n', '        );\n', '\n', '        // Accounts with &#127829; tokens locked for advisors.\n', '        addLockedAccount(ADVISORS, 0xC0e321E9305c21b72F5Ee752A9E8D9eCD0f2e2b1, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x55798CF234FEa760b0591537517C976FDb0c53Ba, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0xbc732e73B94A5C4a8f60d0D98C4026dF21D500f5, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x088EEEe7C4c26041FBb4e83C10CB0784C81c86f9, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x52d640c9c417D9b7E3770d960946Dd5Bd2EB63db, 25 * (10**5) * DECIMALS_FACTOR);\n', '\n', '\n', '        // Verify that the tokens add up to the constant in the configuration.\n', '        assert(bundles[ADVISORS].lockedTokens == TOKENS_LOCKED_ADVISORS);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total locked tokens. This function is called by the donationraiser to determine number of tokens to create upon finalization.\n', '     *\n', '     * @return The current total number of locked EOS Pizza Slices.\n', '     */\n', '    function totalTokensLocked() public constant returns (uint) {\n', '        return bundles[CORE_TEAM].lockedTokens.plus(bundles[ADVISORS].lockedTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows core team account &#127829; tokens to be released.\n', '     */\n', '    function releaseCoreTeamAccount() public {\n', '        releaseAccount(CORE_TEAM, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows advisors account &#127829; tokens to be released.\n', '     */\n', '    function releaseAdvisorsAccount() public {\n', '        releaseAccount(ADVISORS, msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\Whitelist.sol\n', '\n', 'contract Whitelist is HasOwner\n', '{\n', '    // Whitelist mapping\n', '    mapping(address => bool) public whitelist;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     */\n', '    function Whitelist(address _owner) public\n', '        HasOwner(_owner)\n', '    {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Access control modifier that allows only whitelisted address to call the method.\n', '     */\n', '    modifier onlyWhitelisted {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that sets whitelist status in batch.\n', '     *\n', '     * @param _entries An array with the entries to be updated\n', '     * @param _status The new status to apply\n', '     */\n', '    function setWhitelistEntries(address[] _entries, bool _status) internal {\n', '        for (uint32 i = 0; i < _entries.length; ++i) {\n', '            whitelist[_entries[i]] = _status;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that allows the owner to whitelist multiple entries\n', '     *\n', '     * @param _entries An array with the entries to be whitelisted\n', '     */\n', '    function whitelistAddresses(address[] _entries) public onlyOwner {\n', '        setWhitelistEntries(_entries, true);\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that allows the owner to blacklist multiple entries\n', '     *\n', '     * @param _entries An array with the entries to be blacklist\n', '     */\n', '    function blacklistAddresses(address[] _entries) public onlyOwner {\n', '        setWhitelistEntries(_entries, false);\n', '    }\n', '}\n', '\n', '// File: contracts\\EosPizzaSliceDonationraiser.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceDonationraiser\n', ' *\n', ' * @dev The EOS Pizza Slice donationraiser contract.\n', ' */\n', 'contract EosPizzaSliceDonationraiser is EosPizzaSlice, EosPizzaSliceDonationraiserConfig, Whitelist {\n', '    // Indicates whether the donationraiser has ended or not.\n', '    bool public finalized = false;\n', '\n', '    // The address of the account which will receive the funds gathered by the donationraiser.\n', '    address public beneficiary;\n', '\n', '    // The number of &#127829; participants will receive per 1 ETH.\n', '    uint public conversionRate;\n', '\n', '    // Donationraiser start date.\n', '    uint public startDate;\n', '\n', '    // Donationraiser end date.\n', '    uint public endDate;\n', '\n', '    // Donationraiser tokens hard cap.\n', '    uint public hardCap;\n', '\n', '    // The `EosPizzaSliceSafe` contract.\n', '    EosPizzaSliceSafe public eosPizzaSliceSafe;\n', '\n', '    // The minimum amount of ether allowed in the public sale\n', '    uint internal minimumContribution;\n', '\n', '    // The maximum amount of ether allowed per address\n', '    uint internal individualLimit;\n', '\n', '    // Number of tokens sold during the donationraiser.\n', '    uint private tokensSold;\n', '\n', '\n', '\n', '    /**\n', '     * @dev The event fires every time a new buyer enters the donationraiser.\n', '     *\n', '     * @param _address The address of the buyer.\n', '     * @param _ethers The number of ethers sent.\n', '     * @param _tokens The number of tokens received by the buyer.\n', '     * @param _newTotalSupply The updated total number of tokens currently in circulation.\n', '     * @param _conversionRate The conversion rate at which the tokens were bought.\n', '     */\n', '    event FundsReceived(address indexed _address, uint _ethers, uint _tokens, uint _newTotalSupply, uint _conversionRate);\n', '\n', '    /**\n', '     * @dev The event fires when the beneficiary of the donationraiser is changed.\n', '     *\n', '     * @param _beneficiary The address of the new beneficiary.\n', '     */\n', '    event BeneficiaryChange(address _beneficiary);\n', '\n', '    /**\n', '     * @dev The event fires when the number of &#127829;EPS per 1 ETH is changed.\n', '     *\n', '     * @param _conversionRate The new number of &#127829;EPS per 1 ETH.\n', '     */\n', '    event ConversionRateChange(uint _conversionRate);\n', '\n', '    /**\n', '     * @dev The event fires when the donationraiser is successfully finalized.\n', '     *\n', '     * @param _beneficiary The address of the beneficiary.\n', '     * @param _ethers The number of ethers transfered to the beneficiary.\n', '     * @param _totalSupply The total number of tokens in circulation.\n', '     */\n', '    event Finalized(address _beneficiary, uint _ethers, uint _totalSupply);\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _beneficiary The address which will receive the funds gathered by the donationraiser.\n', '     */\n', '    function EosPizzaSliceDonationraiser(address _beneficiary) public\n', '        EosPizzaSlice(0)\n', '        Whitelist(msg.sender)\n', '    {\n', '        require(_beneficiary != 0);\n', '\n', '        beneficiary = _beneficiary;\n', '        conversionRate = CONVERSION_RATE;\n', '        startDate = START_DATE;\n', '        endDate = END_DATE;\n', '        hardCap = TOKENS_HARD_CAP;\n', '        tokensSold = 0;\n', '        minimumContribution = MIN_CONTRIBUTION;\n', '        individualLimit = INDIVIDUAL_ETHER_LIMIT * CONVERSION_RATE;\n', '\n', '        eosPizzaSliceSafe = new EosPizzaSliceSafe(this);\n', '\n', '        // Freeze the transfers for the duration of the donationraiser. Removed this, you can immediately transfer your &#127829;EPS to any ether address you like!\n', '        // freeze();\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the beneficiary of the donationraiser.\n', '     *\n', '     * @param _beneficiary The address of the new beneficiary.\n', '     */\n', '    function setBeneficiary(address _beneficiary) public onlyOwner {\n', '        require(_beneficiary != 0);\n', '\n', '        beneficiary = _beneficiary;\n', '\n', '        BeneficiaryChange(_beneficiary);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets converstion rate of 1 ETH to &#127829;EPS. Can only be changed before the donationraiser starts.\n', '     *\n', '     * @param _conversionRate The new number of EOS Pizza Slices per 1 ETH.\n', '     */\n', '    function setConversionRate(uint _conversionRate) public onlyOwner {\n', '        require(now < startDate);\n', '        require(_conversionRate > 0);\n', '\n', '        conversionRate = _conversionRate;\n', '        individualLimit = INDIVIDUAL_ETHER_LIMIT * _conversionRate;\n', '\n', '        ConversionRateChange(_conversionRate);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev The default function which will fire every time someone sends ethers to this contract&#39;s address.\n', '     */\n', '    function() public payable {\n', '        buyTokens();\n', '    }\n', '\n', '    /**\n', '     * @dev Creates new tokens based on the number of ethers sent and the conversion rate.\n', '     */\n', '    //function buyTokens() public payable onlyWhitelisted {\n', '    function buyTokens() public payable {\n', '        require(!finalized);\n', '        require(now >= startDate);\n', '        require(now <= endDate);\n', '        require(tx.gasprice <= MAX_GAS_PRICE);  // gas price limit\n', '        require(msg.value >= minimumContribution);  // required minimum contribution\n', '        require(tokensSold <= hardCap);\n', '\n', '        // Calculate the number of tokens the buyer will receive.\n', '        uint tokens = msg.value.mul(conversionRate);\n', '        balances[msg.sender] = balances[msg.sender].plus(tokens);\n', '\n', '        // Ensure that the individual contribution limit has not been reached\n', '        require(balances[msg.sender] <= individualLimit);\n', '\n', '\n', '\n', '        tokensSold = tokensSold.plus(tokens);\n', '        totalSupply = totalSupply.plus(tokens);\n', '\n', '        Transfer(0x0, msg.sender, tokens);\n', '\n', '        FundsReceived(\n', '            msg.sender,\n', '            msg.value,\n', '            tokens,\n', '            totalSupply,\n', '            conversionRate\n', '        );\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev Finalize the donationraiser if `endDate` has passed or if `hardCap` is reached.\n', '     */\n', '    function finalize() public onlyOwner {\n', '        require((totalSupply >= hardCap) || (now >= endDate));\n', '        require(!finalized);\n', '\n', '        address contractAddress = this;\n', '        Finalized(beneficiary, contractAddress.balance, totalSupply);\n', '\n', '        /// Send the total number of ETH gathered to the beneficiary.\n', '        beneficiary.transfer(contractAddress.balance);\n', '\n', '        /// Allocate locked tokens to the `EosPizzaSliceSafe` contract.\n', '        uint totalTokensLocked = eosPizzaSliceSafe.totalTokensLocked();\n', '        balances[address(eosPizzaSliceSafe)] = balances[address(eosPizzaSliceSafe)].plus(totalTokensLocked);\n', '        totalSupply = totalSupply.plus(totalTokensLocked);\n', '\n', '        // Transfer the funds for the bounty program.\n', '        balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);\n', '        totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);\n', '\n', '        /// Finalize the donationraiser. Keep in mind that this cannot be undone.\n', '        finalized = true;\n', '\n', '        // Unfreeze transfers\n', '        unfreeze();\n', '    }\n', '\n', '    /**\n', '     * @dev allow owner to collect balance of contract during donation period\n', '     */\n', '\n', '    function collect() public onlyOwner {\n', '\n', '        address contractAddress = this;\n', '        /// Send the total number of ETH gathered to the beneficiary.\n', '        beneficiary.transfer(contractAddress.balance);\n', '\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', '*\n', '*    I  N    P  I  Z  Z  A     W  E     C  R  U  S  T\n', '*  \n', '*    ______ ____   _____       _____ _\n', '*   |  ____/ __ \\ / ____|     |  __ (_)\n', '*   | |__ | |  | | (___       | |__) | __________ _\n', '*   |  __|| |  | |\\___ \\      |  ___/ |_  /_  / _` |\n', '*   | |___| |__| |____) |  _  | |   | |/ / / / (_| |\n', '*   |______\\____/|_____/  (_) |_|   |_/___/___\\__,_|\n', '*\n', '*\n', '*\n', '*   CHECK HTTPS://EOS.PIZZA ON HOW TO GET YOUR SLICE\n', '*   END: 18 MAY 2018\n', '*\n', '*   This is for the fun. Thank you token factory for your smart contract inspiration.\n', "*   Jummy & crusty. Get your ?EPS while it's hot. \n", '*\n', '*   https://eos.pizza\n', '*\n', '*\n', '**/\n', '\n', '// File: contracts\\configs\\EosPizzaSliceConfig.sol\n', '\n', '\n', '/**\n', ' * @title EosPizzaSliceConfig\n', ' *\n', ' * @dev The static configuration for the EOS Pizza Slice.\n', ' */\n', 'contract EosPizzaSliceConfig {\n', '    // The name of the token.\n', '    string constant NAME = "EOS.Pizza";\n', '\n', '    // The symbol of the token.\n', '    string constant SYMBOL = "EPS";\n', '\n', '    // The number of decimals for the token.\n', '    uint8 constant DECIMALS = 18;  // Same as ethers.\n', '\n', '    // Decimal factor for multiplication purposes.\n', '    uint constant DECIMALS_FACTOR = 10 ** uint(DECIMALS);\n', '}\n', '\n', '// File: contracts\\interfaces\\ERC20TokenInterface.sol\n', '\n', '/**\n', ' * @dev The standard ERC20 Token interface.\n', ' */\n', 'contract ERC20TokenInterface {\n', '    uint public totalSupply;  /* shorthand for public function and a property */\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\n', '}\n', '\n', '// File: contracts\\libraries\\SafeMath.sol\n', '\n', '/**\n', ' * @dev Library that helps prevent integer overflows and underflows,\n', ' * inspired by https://github.com/OpenZeppelin/zeppelin-solidity\n', ' */\n', 'library SafeMath {\n', '    function plus(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function minus(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\ERC20Token.sol\n', '\n', '/**\n', ' * @title ERC20Token\n', ' *\n', ' * @dev Implements the operations declared in the `ERC20TokenInterface`.\n', ' */\n', 'contract ERC20Token is ERC20TokenInterface {\n', '    using SafeMath for uint;\n', '\n', '    // Token account balances.\n', '    mapping (address => uint) balances;\n', '\n', '    // Delegated number of tokens to transfer.\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '\n', '    /**\n', '     * @dev Checks the balance of a certain address.\n', '     *\n', "     * @param _account The address which's balance will be checked.\n", '     *\n', '     * @return Returns the balance of the `_account` address.\n', '     */\n', '    function balanceOf(address _account) public constant returns (uint balance) {\n', '        return balances[_account];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers tokens from one address to another.\n', '     *\n', '     * @param _to The target address to which the `_value` number of tokens will be sent.\n', '     * @param _value The number of tokens to send.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        if (balances[msg.sender] < _value || _value == 0) {\n', '\n', '            return false;\n', '        }\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] = balances[_to].plus(_value);\n', '\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\n', '     *\n', '     * @param _from The address of the sender.\n', '     * @param _to The address of the recipient.\n', '     * @param _value The number of tokens to be transferred.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        if (balances[_from] < _value || allowed[_from][msg.sender] < _value || _value == 0) {\n', '            return false;\n', '        }\n', '\n', '        balances[_to] = balances[_to].plus(_value);\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows another contract to spend some tokens on your behalf.\n', '     *\n', '     * @param _spender The address of the account which will be approved for transfer of tokens.\n', '     * @param _value The number of tokens to be approved for transfer.\n', '     *\n', '     * @return Whether the approval was successful or not.\n', '     */\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Shows the number of tokens approved by `_owner` that are allowed to be transferred by `_spender`.\n', '     *\n', '     * @param _owner The account which allowed the transfer.\n', '     * @param _spender The account which will spend the tokens.\n', '     *\n', '     * @return The number of tokens to be transferred.\n', '     */\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\HasOwner.sol\n', '\n', '/**\n', ' * @title HasOwner\n', ' *\n', ' * @dev Allows for exclusive access to certain functionality.\n', ' */\n', 'contract HasOwner {\n', '    // Current owner.\n', '    address public owner;\n', '\n', '    // Conditionally the new owner.\n', '    address public newOwner;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _owner The address of the owner.\n', '     */\n', '    function HasOwner(address _owner) internal {\n', '        owner = _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Access control modifier that allows only the current owner to call the function.\n', '     */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev The event is fired when the current owner is changed.\n', '     *\n', '     * @param _oldOwner The address of the previous owner.\n', '     * @param _newOwner The address of the new owner.\n', '     */\n', '    event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);\n', '\n', '    /**\n', '     * @dev Transfering the ownership is a two-step process, as we prepare\n', '     * for the transfer by setting `newOwner` and requiring `newOwner` to accept\n', '     * the transfer. This prevents accidental lock-out if something goes wrong\n', '     * when passing the `newOwner` address.\n', '     *\n', '     * @param _newOwner The address of the proposed new owner.\n', '     */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev The `newOwner` finishes the ownership transfer process by accepting the\n', '     * ownership.\n', '     */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '\n', '        OwnershipTransfer(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\Freezable.sol\n', '\n', '/**\n', ' * @title Freezable\n', ' * @dev This trait allows to freeze the transactions in a Token\n', ' */\n', 'contract Freezable is HasOwner {\n', '  bool public frozen = false;\n', '\n', '  /**\n', '   * @dev Modifier makes methods callable only when the contract is not frozen.\n', '   */\n', '  modifier requireNotFrozen() {\n', '    require(!frozen);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to "freeze" the contract.\n', '   */\n', '  function freeze() onlyOwner public {\n', '    frozen = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the owner to "unfreeze" the contract.\n', '   */\n', '  function unfreeze() onlyOwner public {\n', '    frozen = false;\n', '  }\n', '}\n', '\n', '// File: contracts\\traits\\FreezableERC20Token.sol\n', '\n', '/**\n', ' * @title FreezableERC20Token\n', ' *\n', ' * @dev Extends ERC20Token and adds ability to freeze all transfers of tokens.\n', ' */\n', 'contract FreezableERC20Token is ERC20Token, Freezable {\n', '    /**\n', '     * @dev Overrides the original ERC20Token implementation by adding whenNotFrozen modifier.\n', '     *\n', '     * @param _to The target address to which the `_value` number of tokens will be sent.\n', '     * @param _value The number of tokens to send.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transfer(address _to, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Send `_value` tokens to `_to` from `_from` if `_from` has approved the process.\n', '     *\n', '     * @param _from The address of the sender.\n', '     * @param _to The address of the recipient.\n', '     * @param _value The number of tokens to be transferred.\n', '     *\n', '     * @return Whether the transfer was successful or not.\n', '     */\n', '    function transferFrom(address _from, address _to, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows another contract to spend some tokens on your behalf.\n', '     *\n', '     * @param _spender The address of the account which will be approved for transfer of tokens.\n', '     * @param _value The number of tokens to be approved for transfer.\n', '     *\n', '     * @return Whether the approval was successful or not.\n', '     */\n', '    function approve(address _spender, uint _value) public requireNotFrozen returns (bool success) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts\\EosPizzaSlice.sol\n', '\n', '/**\n', ' * @title EOS Pizza Slice\n', ' *\n', ' * @dev A standard token implementation of the ERC20 token standard with added\n', ' *      HasOwner trait and initialized using the configuration constants.\n', ' */\n', 'contract EosPizzaSlice is EosPizzaSliceConfig, HasOwner, FreezableERC20Token {\n', '    // The name of the token.\n', '    string public name;\n', '\n', '    // The symbol for the token.\n', '    string public symbol;\n', '\n', '    // The decimals of the token.\n', '    uint8 public decimals;\n', '\n', '    /**\n', '     * @dev The constructor. Initially sets `totalSupply` and the balance of the\n', '     *      `owner` address according to the initialization parameter.\n', '     */\n', '    function EosPizzaSlice(uint _totalSupply) public\n', '        HasOwner(msg.sender)\n', '    {\n', '        name = NAME;\n', '        symbol = SYMBOL;\n', '        decimals = DECIMALS;\n', '        totalSupply = _totalSupply;\n', '        balances[owner] = _totalSupply;\n', '    }\n', '}\n', '\n', '// File: contracts\\configs\\EosPizzaSliceDonationraiserConfig.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceDonationraiserConfig\n', ' *\n', ' * @dev The static configuration for the EOS Pizza Slice donationraiser.\n', ' */\n', 'contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig {\n', '    // The number of ? per 1 ETH.\n', '    uint constant CONVERSION_RATE = 100000;\n', '\n', '    // The public sale hard cap of the donationraiser.\n', '    uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR;\n', '\n', '    // The start date of the donationraiser: Friday, 9 March 2018 21:22:22 UTC.\n', '    uint constant START_DATE = 1520630542;\n', '\n', '    // The end date of the donationraiser:  May 18, 2018, 12:35:20 AM UTC - Bitcoin Pizza 8th year celebration moment.\n', '    uint constant END_DATE =  1526603720;\n', '\n', '\n', '    // Total number of tokens locked for the ? core team.\n', '    uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR;\n', '\n', '    // Total number of tokens locked for ? advisors.\n', '    uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR;\n', '\n', '    // The release date for tokens locked for the ? core team.\n', '    uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days;\n', '\n', '    // The release date for tokens locked for ? advisors.\n', '    uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days;\n', '\n', '    // Total number of tokens locked for bounty program.\n', '    uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR;\n', '\n', '    // Maximum gas price limit\n', '    uint constant MAX_GAS_PRICE = 90000000000 wei; // 90 gwei/shanon\n', '\n', '    // Minimum individual contribution\n', '    uint constant MIN_CONTRIBUTION =  0.05 ether;\n', '\n', '    // Individual limit in ether\n', '    uint constant INDIVIDUAL_ETHER_LIMIT =  4999 ether;\n', '}\n', '\n', '// File: contracts\\traits\\TokenSafe.sol\n', '\n', '/**\n', ' * @title TokenSafe\n', ' *\n', ' * @dev A multi-bundle token safe contract that contains locked tokens released after a date for the specific bundle type.\n', ' */\n', 'contract TokenSafe {\n', '    using SafeMath for uint;\n', '\n', '    struct AccountsBundle {\n', '        // The total number of tokens locked.\n', '        uint lockedTokens;\n', '        // The release date for the locked tokens\n', '        // Note: Unix timestamp fits uint32, however block.timestamp is uint\n', '        uint releaseDate;\n', '        // The balances for the ? locked token accounts.\n', '        mapping (address => uint) balances;\n', '    }\n', '\n', '    // The account bundles of locked tokens grouped by release date\n', '    mapping (uint8 => AccountsBundle) public bundles;\n', '\n', '    // The `ERC20TokenInterface` contract.\n', '    ERC20TokenInterface token;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _token The address of the EOS Pizza Slices (donation) contract.\n', '     */\n', '    function TokenSafe(address _token) public {\n', '        token = ERC20TokenInterface(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev The function initializes the bundle of accounts with a release date.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _releaseDate Unix timestamp of the time after which the tokens can be released\n', '     */\n', '    function initBundle(uint8 _type, uint _releaseDate) internal {\n', '        bundles[_type].releaseDate = _releaseDate;\n', '    }\n', '\n', '    /**\n', '     * @dev Add new account with locked token balance to the specified bundle type.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _account The address of the account to be added.\n', '     * @param _balance The number of tokens to be locked.\n', '     */\n', '    function addLockedAccount(uint8 _type, address _account, uint _balance) internal {\n', '        var bundle = bundles[_type];\n', '        bundle.balances[_account] = bundle.balances[_account].plus(_balance);\n', '        bundle.lockedTokens = bundle.lockedTokens.plus(_balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows an account to be released if it meets the time constraints.\n', '     *\n', '     * @param _type Bundle type.\n', '     * @param _account The address of the account to be released.\n', '     */\n', '    function releaseAccount(uint8 _type, address _account) internal {\n', '        var bundle = bundles[_type];\n', '        require(now >= bundle.releaseDate);\n', '        uint tokens = bundle.balances[_account];\n', '        require(tokens > 0);\n', '        bundle.balances[_account] = 0;\n', '        bundle.lockedTokens = bundle.lockedTokens.minus(tokens);\n', '        if (!token.transfer(_account, tokens)) {\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\EosPizzaSliceSafe.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceSafe\n', ' *\n', ' * @dev The EOS Pizza Slice safe containing all details about locked tokens.\n', ' */\n', 'contract EosPizzaSliceSafe is TokenSafe, EosPizzaSliceDonationraiserConfig {\n', '    // Bundle type constants\n', '    uint8 constant CORE_TEAM = 0;\n', '    uint8 constant ADVISORS = 1;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _token The address of the EOS Pizza (donation) contract.\n', '     */\n', '    function EosPizzaSliceSafe(address _token) public\n', '        TokenSafe(_token)\n', '    {\n', '        token = ERC20TokenInterface(_token);\n', '\n', '        /// Core team.\n', '        initBundle(CORE_TEAM,\n', '            TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE\n', '        );\n', '\n', '        // Accounts with tokens locked for the ? core team.\n', '        addLockedAccount(CORE_TEAM, 0x3ce215b2e4dC9D2ba0e2fC5099315E4Fa05d8AA2, 35 * (10**6) * DECIMALS_FACTOR);\n', '\n', '\n', '        // Verify that the tokens add up to the constant in the configuration.\n', '        assert(bundles[CORE_TEAM].lockedTokens == TOKENS_LOCKED_CORE_TEAM);\n', '\n', '        /// Advisors.\n', '        initBundle(ADVISORS,\n', '            TOKENS_LOCKED_ADVISORS_RELEASE_DATE\n', '        );\n', '\n', '        // Accounts with ? tokens locked for advisors.\n', '        addLockedAccount(ADVISORS, 0xC0e321E9305c21b72F5Ee752A9E8D9eCD0f2e2b1, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x55798CF234FEa760b0591537517C976FDb0c53Ba, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0xbc732e73B94A5C4a8f60d0D98C4026dF21D500f5, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x088EEEe7C4c26041FBb4e83C10CB0784C81c86f9, 25 * (10**5) * DECIMALS_FACTOR);\n', '        addLockedAccount(ADVISORS, 0x52d640c9c417D9b7E3770d960946Dd5Bd2EB63db, 25 * (10**5) * DECIMALS_FACTOR);\n', '\n', '\n', '        // Verify that the tokens add up to the constant in the configuration.\n', '        assert(bundles[ADVISORS].lockedTokens == TOKENS_LOCKED_ADVISORS);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total locked tokens. This function is called by the donationraiser to determine number of tokens to create upon finalization.\n', '     *\n', '     * @return The current total number of locked EOS Pizza Slices.\n', '     */\n', '    function totalTokensLocked() public constant returns (uint) {\n', '        return bundles[CORE_TEAM].lockedTokens.plus(bundles[ADVISORS].lockedTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows core team account ? tokens to be released.\n', '     */\n', '    function releaseCoreTeamAccount() public {\n', '        releaseAccount(CORE_TEAM, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows advisors account ? tokens to be released.\n', '     */\n', '    function releaseAdvisorsAccount() public {\n', '        releaseAccount(ADVISORS, msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts\\traits\\Whitelist.sol\n', '\n', 'contract Whitelist is HasOwner\n', '{\n', '    // Whitelist mapping\n', '    mapping(address => bool) public whitelist;\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     */\n', '    function Whitelist(address _owner) public\n', '        HasOwner(_owner)\n', '    {\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Access control modifier that allows only whitelisted address to call the method.\n', '     */\n', '    modifier onlyWhitelisted {\n', '        require(whitelist[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that sets whitelist status in batch.\n', '     *\n', '     * @param _entries An array with the entries to be updated\n', '     * @param _status The new status to apply\n', '     */\n', '    function setWhitelistEntries(address[] _entries, bool _status) internal {\n', '        for (uint32 i = 0; i < _entries.length; ++i) {\n', '            whitelist[_entries[i]] = _status;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that allows the owner to whitelist multiple entries\n', '     *\n', '     * @param _entries An array with the entries to be whitelisted\n', '     */\n', '    function whitelistAddresses(address[] _entries) public onlyOwner {\n', '        setWhitelistEntries(_entries, true);\n', '    }\n', '\n', '    /**\n', '     * @dev Public function that allows the owner to blacklist multiple entries\n', '     *\n', '     * @param _entries An array with the entries to be blacklist\n', '     */\n', '    function blacklistAddresses(address[] _entries) public onlyOwner {\n', '        setWhitelistEntries(_entries, false);\n', '    }\n', '}\n', '\n', '// File: contracts\\EosPizzaSliceDonationraiser.sol\n', '\n', '/**\n', ' * @title EosPizzaSliceDonationraiser\n', ' *\n', ' * @dev The EOS Pizza Slice donationraiser contract.\n', ' */\n', 'contract EosPizzaSliceDonationraiser is EosPizzaSlice, EosPizzaSliceDonationraiserConfig, Whitelist {\n', '    // Indicates whether the donationraiser has ended or not.\n', '    bool public finalized = false;\n', '\n', '    // The address of the account which will receive the funds gathered by the donationraiser.\n', '    address public beneficiary;\n', '\n', '    // The number of ? participants will receive per 1 ETH.\n', '    uint public conversionRate;\n', '\n', '    // Donationraiser start date.\n', '    uint public startDate;\n', '\n', '    // Donationraiser end date.\n', '    uint public endDate;\n', '\n', '    // Donationraiser tokens hard cap.\n', '    uint public hardCap;\n', '\n', '    // The `EosPizzaSliceSafe` contract.\n', '    EosPizzaSliceSafe public eosPizzaSliceSafe;\n', '\n', '    // The minimum amount of ether allowed in the public sale\n', '    uint internal minimumContribution;\n', '\n', '    // The maximum amount of ether allowed per address\n', '    uint internal individualLimit;\n', '\n', '    // Number of tokens sold during the donationraiser.\n', '    uint private tokensSold;\n', '\n', '\n', '\n', '    /**\n', '     * @dev The event fires every time a new buyer enters the donationraiser.\n', '     *\n', '     * @param _address The address of the buyer.\n', '     * @param _ethers The number of ethers sent.\n', '     * @param _tokens The number of tokens received by the buyer.\n', '     * @param _newTotalSupply The updated total number of tokens currently in circulation.\n', '     * @param _conversionRate The conversion rate at which the tokens were bought.\n', '     */\n', '    event FundsReceived(address indexed _address, uint _ethers, uint _tokens, uint _newTotalSupply, uint _conversionRate);\n', '\n', '    /**\n', '     * @dev The event fires when the beneficiary of the donationraiser is changed.\n', '     *\n', '     * @param _beneficiary The address of the new beneficiary.\n', '     */\n', '    event BeneficiaryChange(address _beneficiary);\n', '\n', '    /**\n', '     * @dev The event fires when the number of ?EPS per 1 ETH is changed.\n', '     *\n', '     * @param _conversionRate The new number of ?EPS per 1 ETH.\n', '     */\n', '    event ConversionRateChange(uint _conversionRate);\n', '\n', '    /**\n', '     * @dev The event fires when the donationraiser is successfully finalized.\n', '     *\n', '     * @param _beneficiary The address of the beneficiary.\n', '     * @param _ethers The number of ethers transfered to the beneficiary.\n', '     * @param _totalSupply The total number of tokens in circulation.\n', '     */\n', '    event Finalized(address _beneficiary, uint _ethers, uint _totalSupply);\n', '\n', '    /**\n', '     * @dev The constructor.\n', '     *\n', '     * @param _beneficiary The address which will receive the funds gathered by the donationraiser.\n', '     */\n', '    function EosPizzaSliceDonationraiser(address _beneficiary) public\n', '        EosPizzaSlice(0)\n', '        Whitelist(msg.sender)\n', '    {\n', '        require(_beneficiary != 0);\n', '\n', '        beneficiary = _beneficiary;\n', '        conversionRate = CONVERSION_RATE;\n', '        startDate = START_DATE;\n', '        endDate = END_DATE;\n', '        hardCap = TOKENS_HARD_CAP;\n', '        tokensSold = 0;\n', '        minimumContribution = MIN_CONTRIBUTION;\n', '        individualLimit = INDIVIDUAL_ETHER_LIMIT * CONVERSION_RATE;\n', '\n', '        eosPizzaSliceSafe = new EosPizzaSliceSafe(this);\n', '\n', '        // Freeze the transfers for the duration of the donationraiser. Removed this, you can immediately transfer your ?EPS to any ether address you like!\n', '        // freeze();\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the beneficiary of the donationraiser.\n', '     *\n', '     * @param _beneficiary The address of the new beneficiary.\n', '     */\n', '    function setBeneficiary(address _beneficiary) public onlyOwner {\n', '        require(_beneficiary != 0);\n', '\n', '        beneficiary = _beneficiary;\n', '\n', '        BeneficiaryChange(_beneficiary);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets converstion rate of 1 ETH to ?EPS. Can only be changed before the donationraiser starts.\n', '     *\n', '     * @param _conversionRate The new number of EOS Pizza Slices per 1 ETH.\n', '     */\n', '    function setConversionRate(uint _conversionRate) public onlyOwner {\n', '        require(now < startDate);\n', '        require(_conversionRate > 0);\n', '\n', '        conversionRate = _conversionRate;\n', '        individualLimit = INDIVIDUAL_ETHER_LIMIT * _conversionRate;\n', '\n', '        ConversionRateChange(_conversionRate);\n', '    }\n', '\n', '\n', '\n', '    /**\n', "     * @dev The default function which will fire every time someone sends ethers to this contract's address.\n", '     */\n', '    function() public payable {\n', '        buyTokens();\n', '    }\n', '\n', '    /**\n', '     * @dev Creates new tokens based on the number of ethers sent and the conversion rate.\n', '     */\n', '    //function buyTokens() public payable onlyWhitelisted {\n', '    function buyTokens() public payable {\n', '        require(!finalized);\n', '        require(now >= startDate);\n', '        require(now <= endDate);\n', '        require(tx.gasprice <= MAX_GAS_PRICE);  // gas price limit\n', '        require(msg.value >= minimumContribution);  // required minimum contribution\n', '        require(tokensSold <= hardCap);\n', '\n', '        // Calculate the number of tokens the buyer will receive.\n', '        uint tokens = msg.value.mul(conversionRate);\n', '        balances[msg.sender] = balances[msg.sender].plus(tokens);\n', '\n', '        // Ensure that the individual contribution limit has not been reached\n', '        require(balances[msg.sender] <= individualLimit);\n', '\n', '\n', '\n', '        tokensSold = tokensSold.plus(tokens);\n', '        totalSupply = totalSupply.plus(tokens);\n', '\n', '        Transfer(0x0, msg.sender, tokens);\n', '\n', '        FundsReceived(\n', '            msg.sender,\n', '            msg.value,\n', '            tokens,\n', '            totalSupply,\n', '            conversionRate\n', '        );\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev Finalize the donationraiser if `endDate` has passed or if `hardCap` is reached.\n', '     */\n', '    function finalize() public onlyOwner {\n', '        require((totalSupply >= hardCap) || (now >= endDate));\n', '        require(!finalized);\n', '\n', '        address contractAddress = this;\n', '        Finalized(beneficiary, contractAddress.balance, totalSupply);\n', '\n', '        /// Send the total number of ETH gathered to the beneficiary.\n', '        beneficiary.transfer(contractAddress.balance);\n', '\n', '        /// Allocate locked tokens to the `EosPizzaSliceSafe` contract.\n', '        uint totalTokensLocked = eosPizzaSliceSafe.totalTokensLocked();\n', '        balances[address(eosPizzaSliceSafe)] = balances[address(eosPizzaSliceSafe)].plus(totalTokensLocked);\n', '        totalSupply = totalSupply.plus(totalTokensLocked);\n', '\n', '        // Transfer the funds for the bounty program.\n', '        balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);\n', '        totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);\n', '\n', '        /// Finalize the donationraiser. Keep in mind that this cannot be undone.\n', '        finalized = true;\n', '\n', '        // Unfreeze transfers\n', '        unfreeze();\n', '    }\n', '\n', '    /**\n', '     * @dev allow owner to collect balance of contract during donation period\n', '     */\n', '\n', '    function collect() public onlyOwner {\n', '\n', '        address contractAddress = this;\n', '        /// Send the total number of ETH gathered to the beneficiary.\n', '        beneficiary.transfer(contractAddress.balance);\n', '\n', '    }\n', '}']
