['pragma solidity ^0.4.16;\n', 'contract IcoData{\n', '/////////////////////////////////////////////////////////    \n', '///////(c)2017 tokenchanger.io -all rights reserved////// \n', ' \n', '/*SUPER ADMINS*/\n', 'address Mars = 0x1947f347B6ECf1C3D7e1A58E3CDB2A15639D48Be;\n', 'address Mercury = 0x00795263bdca13104309Db70c11E8404f81576BE;\n', 'address Europa = 0x00e4E3eac5b520BCa1030709a5f6f3dC8B9e1C37;\n', 'address Jupiter = 0x2C76F260707672e240DC639e5C9C62efAfB59867;\n', 'address Neptune = 0xEB04E1545a488A5018d2b5844F564135211d3696;\n', '\n', '/*CONTRACT ADDRESS*/\n', 'function GetContractAddr() public constant returns (address){\n', 'return this;\n', '}\t\n', 'address ContractAddr = GetContractAddr();\n', '\n', 'struct State{\n', 'bool PrivateSale;\n', 'bool PreSale;\n', 'bool MainSale; \n', 'bool End;\n', '}\n', '\n', 'struct Market{\n', 'uint256 EtherPrice;    \n', 'uint256 TocPrice;    \n', 'uint256 Commission;    \n', '} \n', '\n', 'struct Admin{\n', 'bool Authorised; \n', 'uint256 Level;\n', '}\n', '\n', '/*contract state*/\n', 'mapping (address => State) public state;\n', '/*market storage*/\n', 'mapping (address => Market) public market;\n', '/*authorised admins*/\n', 'mapping (address => Admin) public admin;\n', '\n', '/*AUTHORISE ADMIN*/\n', 'function AuthAdmin(address _admin, bool _authority, uint256 _level) external \n', 'returns(bool) {\n', 'if((msg.sender != Mars) && (msg.sender != Mercury) && (msg.sender != Europa)\n', '&& (msg.sender != Jupiter) && (msg.sender != Neptune)) revert();  \n', 'admin[_admin].Authorised = _authority; \n', 'admin[_admin].Level = _level;\n', 'return true;\n', '} \n', '\n', '/*GENERAL PRICE UPDATE*/\n', 'function GeneralUpdate(uint256 _etherprice, uint256 _tocprice, uint256 _commission) \n', 'external returns(bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();\n', '/*update market record*/\n', 'market[ContractAddr].EtherPrice = _etherprice; \n', 'market[ContractAddr].TocPrice = _tocprice;\n', 'market[ContractAddr].Commission = _commission;\n', 'return true;\n', '}\n', '\n', '/*UPDATE ETHER PRICE*/\n', 'function EtherPriceUpdate(uint256 _etherprice)external returns(bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();\n', '/*update market record*/\n', 'market[ContractAddr].EtherPrice = _etherprice; \n', 'return true;\n', '}\n', '\n', '/*UPDATE STATE*/\n', 'function UpdateState(uint256 _state) external returns(bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();\n', '/*private sale state*/\n', 'if(_state == 1){\n', 'state[ContractAddr].PrivateSale = true; \n', 'state[ContractAddr].PreSale = false;\n', 'state[ContractAddr].MainSale = false;\n', 'state[ContractAddr].End = false;\n', '}\n', '/*presale state*/\n', 'if(_state == 2){\n', 'state[ContractAddr].PrivateSale = false; \n', 'state[ContractAddr].PreSale = true;\n', 'state[ContractAddr].MainSale = false;\n', 'state[ContractAddr].End = false;\n', '}\n', '/*main sale state*/\n', 'if(_state == 3){\n', 'state[ContractAddr].PrivateSale = false; \n', 'state[ContractAddr].PreSale = false;\n', 'state[ContractAddr].MainSale = true;\n', 'state[ContractAddr].End = false;\n', '}\n', '/*end state*/\n', 'if(_state == 4){\n', 'state[ContractAddr].PrivateSale = false; \n', 'state[ContractAddr].PreSale = false;\n', 'state[ContractAddr].MainSale = false;\n', 'state[ContractAddr].End = true;\n', '}\n', 'return true;\n', '}\n', '\n', '/*GETTERS*/\n', '\n', '/*get private sale state*/\n', 'function GetPrivateSale() public view returns (bool){\n', 'return state[ContractAddr].PrivateSale;\n', '}\n', '/*get pre sale state*/\n', 'function GetPreSale() public view returns (bool){\n', 'return state[ContractAddr].PreSale;\n', '}\n', '/*get main sale state*/\n', 'function GetMainSale() public view returns (bool){\n', 'return state[ContractAddr].MainSale;\n', '}\n', '/*get end state*/\n', 'function GetEnd() public view returns (bool){\n', 'return state[ContractAddr].End;\n', '}\n', '/*get ether price*/\n', 'function GetEtherPrice() public view returns (uint256){\n', 'return market[ContractAddr].EtherPrice;\n', '}\n', '/*get toc price*/\n', 'function GetTocPrice() public view returns (uint256){\n', 'return market[ContractAddr].TocPrice;\n', '}\n', '/*get commission*/\n', 'function GetCommission() public view returns (uint256){\n', 'return market[ContractAddr].Commission;\n', '}\n', '\n', '}///////////////////////////////////end of icodata contract\n', '\n', '\n', '\n', 'pragma solidity ^0.4.16;\n', 'contract IcoDapp{\n', '/////////////////////////////////////////////////////////    \n', '///////(c)2017 tokenchanger.io -all rights reserved////// \n', ' \n', '/*SUPER ADMINS*/\n', 'address Mars = 0x1947f347B6ECf1C3D7e1A58E3CDB2A15639D48Be;\n', 'address Mercury = 0x00795263bdca13104309Db70c11E8404f81576BE;\n', 'address Europa = 0x00e4E3eac5b520BCa1030709a5f6f3dC8B9e1C37;\n', 'address Jupiter = 0x2C76F260707672e240DC639e5C9C62efAfB59867;\n', 'address Neptune = 0xEB04E1545a488A5018d2b5844F564135211d3696;\n', '\n', '/*GLOBAL VARIABLES*/\n', 'uint256 Converter = 10000;\n', '\n', '/*CONTRACT ADDRESS*/\n', 'function GetContractAddr() public constant returns (address){\n', 'return this;\n', '}\t\n', 'address ContractAddr = GetContractAddr();\n', '\n', 'struct Buyer{\n', 'bool Withdrawn;    \n', 'uint256 TocBalance;\n', 'uint256 WithdrawalBlock;\n', 'uint256 Num;\n', '}\n', '\n', 'struct Transaction{\n', 'uint256 Amount;\n', 'uint256 EtherPrice;\n', 'uint256 TocPrice;\n', 'uint256 Block;\n', '}    \n', '\n', 'struct AddressBook{\n', 'address TOCAddr;\n', 'address DataAddr;\n', 'address Banker;\n', '}\n', '\n', 'struct Admin{\n', 'bool Authorised; \n', 'uint256 Level;\n', '}\n', '\n', 'struct OrderBooks{\n', 'uint256 PrivateSupply;\n', 'uint256 PreSupply;\n', 'uint256 MainSupply;\n', '}\n', '\n', 'struct Promoters{\n', 'bool Registered;    \n', 'uint256 TotalCommission; \n', '}\n', '\n', 'struct PromoAdmin{\n', 'uint256 CurrentNum;\n', 'uint256 Max;    \n', '}\n', '\n', '\n', '/*buyer account*/\n', 'mapping (address => Buyer) public buyer;\n', '/*buyer transactions*/\n', 'mapping(address => mapping(uint256 => Transaction)) public transaction;\n', '/*order books store*/\n', 'mapping (address => OrderBooks) public orderbooks;\n', '/*promoter store*/\n', 'mapping (address => Promoters) public promoters;\n', '/*server address book*/\n', 'mapping (address => AddressBook) public addressbook;\n', '/*administration of promoters*/\n', 'mapping (address => PromoAdmin) public promoadmin;\n', '/*authorised admins*/\n', 'mapping (address => Admin) public admin;\n', '\n', 'struct TA{\n', 'uint256 n1;\n', 'uint256 n2;\n', 'uint256 n3;\n', 'uint256 n4;\n', 'uint256 n5;\n', 'uint256 n6;\n', 'uint256 n7;\n', 'uint256 n8;\n', 'uint256 n9;\n', 'uint256 n10;\n', 'uint256 n11;\n', '}\n', '\n', 'struct LA{\n', 'bool l1;\n', 'bool l2;\n', 'bool l3;\n', '}\n', '\n', '/*initialise process variables*/\n', 'TA ta;\n', 'LA la;\n', '\n', '/*AUTHORISE ADMIN*/\n', 'function AuthAdmin(address _admin, bool _authority, uint256 _level) external \n', 'returns(bool) {\n', 'if((msg.sender != Mars) && (msg.sender != Mercury) && (msg.sender != Europa)\n', '&& (msg.sender != Jupiter) && (msg.sender != Neptune)) revert();  \n', 'admin[_admin].Authorised = _authority; \n', 'admin[_admin].Level = _level;\n', 'return true;\n', '} \n', '\n', '/*ADD ADDRESSES TO ADDRESS BOOK*/\n', 'function AuthAddr(address _tocaddr, address _dataddr, address _banker) \n', 'external returns(bool){\n', '/*integrity checks*/      \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();\n', '/*update address record*/\n', 'addressbook[ContractAddr].TOCAddr = _tocaddr;\n', 'addressbook[ContractAddr].DataAddr = _dataddr;\n', 'addressbook[ContractAddr].Banker = _banker;\n', 'return true;\n', '}\n', '\n', '/*CONFIGURE PROMOTERS*/\n', 'function ConfigPromoter(uint256 _max) external returns (bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();    \n', '/*create promoter record*/    \n', 'promoadmin[ContractAddr].Max = _max; \n', 'return true;\n', '}\n', '\n', '/*ADD PROMOTER*/\n', 'function AddPromoter(address _addpromoter) external returns (bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert(); \n', '/*create promoter records*/    \n', 'promoters[_addpromoter].Registered = true;\n', 'promoters[_addpromoter].TotalCommission = 0;\n', 'promoadmin[ContractAddr].CurrentNum += 1;\n', 'return true;\n', '}\n', '\n', '/*REGISTER AS A PROMOTER*/\n', 'function Register(address _referrer) external returns (bool){\n', '/*integrity checks*/ \n', 'if(promoters[_referrer].Registered == false) revert();\n', 'if(promoters[msg.sender].Registered == true) revert();\n', 'if(promoadmin[ContractAddr].CurrentNum >= promoadmin[ContractAddr].Max) revert();\n', '/*create promoter records*/    \n', 'promoters[msg.sender].Registered = true;\n', 'promoters[msg.sender].TotalCommission = 0; \n', 'promoadmin[ContractAddr].CurrentNum += 1;\n', 'return true;\n', '}\n', '\n', '/*INCREASE PRIVATE SALE SUPPLY*/\n', 'function IncPrivateSupply(uint256 _privatesupply) external returns (bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();    \n', '/*update private supply record*/    \n', 'orderbooks[ContractAddr].PrivateSupply += _privatesupply; \n', 'return true;\n', '}\n', '\n', '/*INCREASE PRESALE SUPPLY*/\n', 'function IncPreSupply(uint256 _presupply) external returns (bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();    \n', '/*update presale supply record*/    \n', 'orderbooks[ContractAddr].PreSupply += _presupply;\n', 'return true;\n', '}\n', '\n', '/*INCREASE MAINSALE SUPPLY*/\n', 'function IncMainSupply(uint256 _mainsupply) external returns (bool){\n', '/*integrity checks*/    \n', 'if(admin[msg.sender].Authorised == false) revert();\n', 'if(admin[msg.sender].Level < 5 ) revert();    \n', '/*update main sale supply record*/    \n', 'orderbooks[ContractAddr].MainSupply += _mainsupply;\n', 'return true;\n', '}\n', '\n', '/*CALCULATE COMMISSION*/\n', 'function RefCommission(uint256 _amount, uint256 _com) internal returns (uint256){\n', 'ta.n1 = mul(_amount, _com);\n', 'ta.n2 = div(ta.n1,Converter);\n', 'return ta.n2;\n', '}\n', '\n', '/*CALCULATE TOC PURCHASED*/\n', 'function CalcToc(uint256 _etherprice, uint256 _tocprice, uint256 _deposit) \n', 'internal returns (uint256){    \n', 'ta.n3 = mul(_etherprice, _deposit);\n', 'ta.n4 = div(ta.n3,_tocprice);\n', 'return ta.n4;\n', '}\n', '\n', '/*PRIVATE SALE*/\n', 'function PrivateSaleBuy(address _referrer) payable external returns (bool){\n', '/*integrity checks*/    \n', 'if(promoters[_referrer].Registered == false) revert();\n', 'if(msg.value <= 0) revert();\n', '/*connect to ico data contract*/\n', 'IcoData\n', 'DataCall = IcoData(addressbook[ContractAddr].DataAddr);\n', '/*get transaction information*/\n', 'la.l1 = DataCall.GetEnd();\n', 'la.l2 = DataCall.GetPrivateSale();\n', 'ta.n5 = DataCall.GetEtherPrice();    \n', 'ta.n6 = DataCall.GetTocPrice();    \n', 'ta.n7 = DataCall.GetCommission();    \n', '/*intergrity checks*/    \n', 'if(la.l1 == true) revert();\n', 'if(la.l2 == false) revert();\n', '/*calculate toc purchased & determine supply avaliability*/\n', 'ta.n8 = CalcToc(ta.n5, ta.n6, msg.value);\n', 'if(ta.n8 > orderbooks[ContractAddr].PrivateSupply) revert();\n', '/*calculate referrer commission*/\n', 'ta.n9 = RefCommission(msg.value, ta.n7);\n', '/*calculate net revenue*/\n', 'ta.n10 = sub(msg.value, ta.n9);\n', '/*payments and delivery*/\n', 'addressbook[ContractAddr].Banker.transfer(ta.n10);\n', '_referrer.transfer(ta.n9);\n', '/*update transaction records*/\n', 'orderbooks[ContractAddr].PrivateSupply -= ta.n8;\n', 'buyer[msg.sender].TocBalance += ta.n8;\n', 'buyer[msg.sender].Num += 1;\n', 'ta.n11 = buyer[msg.sender].Num; \n', 'transaction[msg.sender][ta.n11].Amount = ta.n8;\n', 'transaction[msg.sender][ta.n11].EtherPrice = ta.n5;\n', 'transaction[msg.sender][ta.n11].TocPrice = ta.n6;\n', 'transaction[msg.sender][ta.n11].Block = block.number;\n', 'promoters[_referrer].TotalCommission += ta.n9;\n', 'return true;\n', '}    \n', '\n', '/*PRESALE*/\n', 'function PreSaleBuy(address _referrer) payable external returns (bool){\n', '/*integrity checks*/    \n', 'if(promoters[_referrer].Registered == false) revert();\n', 'if(msg.value <= 0) revert();\n', '/*connect to ico data contract*/\n', 'IcoData\n', 'DataCall = IcoData(addressbook[ContractAddr].DataAddr);\n', '/*get transaction information*/\n', 'la.l1 = DataCall.GetEnd();\n', 'la.l2 = DataCall.GetPreSale();\n', 'ta.n5 = DataCall.GetEtherPrice();    \n', 'ta.n6 = DataCall.GetTocPrice();    \n', 'ta.n7 = DataCall.GetCommission();    \n', '/*intergrity checks*/    \n', 'if(la.l1 == true) revert();\n', 'if(la.l2 == false) revert();\n', '/*calculate toc purchased & determine supply avaliability*/\n', 'ta.n8 = CalcToc(ta.n5, ta.n6, msg.value);\n', 'if(ta.n8 > orderbooks[ContractAddr].PreSupply) revert();\n', '/*calculate referrer commission*/\n', 'ta.n9 = RefCommission(msg.value, ta.n7);\n', '/*calculate net revenue*/\n', 'ta.n10 = sub(msg.value, ta.n9);\n', '/*payments and delivery*/\n', 'addressbook[ContractAddr].Banker.transfer(ta.n10);\n', '_referrer.transfer(ta.n9);\n', '/*update transaction records*/\n', 'orderbooks[ContractAddr].PreSupply -= ta.n8;\n', 'buyer[msg.sender].TocBalance += ta.n8;\n', 'buyer[msg.sender].Num += 1;\n', 'ta.n11 = buyer[msg.sender].Num; \n', 'transaction[msg.sender][ta.n11].Amount = ta.n8;\n', 'transaction[msg.sender][ta.n11].EtherPrice = ta.n5;\n', 'transaction[msg.sender][ta.n11].TocPrice = ta.n6;\n', 'transaction[msg.sender][ta.n11].Block = block.number;\n', 'promoters[_referrer].TotalCommission += ta.n9;\n', 'return true;\n', '}    \n', '\n', '\n', '/*MAIN SALE*/\n', 'function MainSaleBuy() payable external returns (bool){\n', '/*integrity checks*/    \n', 'if(msg.value <= 0) revert();\n', '/*connect to ico data contract*/\n', 'IcoData\n', 'DataCall = IcoData(addressbook[ContractAddr].DataAddr);\n', '/*get transaction information*/\n', 'la.l1 = DataCall.GetEnd();\n', 'la.l2 = DataCall.GetMainSale();\n', 'ta.n5 = DataCall.GetEtherPrice();    \n', 'ta.n6 = DataCall.GetTocPrice();    \n', 'ta.n7 = DataCall.GetCommission();    \n', '/*intergrity checks*/    \n', 'if(la.l1 == true) revert();\n', 'if(la.l2 == false) revert();\n', '/*calculate toc purchased & determine supply avaliability*/\n', 'ta.n8 = CalcToc(ta.n5, ta.n6, msg.value);\n', 'if(ta.n8 > orderbooks[ContractAddr].MainSupply) revert();\n', '/*payments and delivery*/\n', 'addressbook[ContractAddr].Banker.transfer(msg.value);\n', '/*update transaction records*/\n', 'orderbooks[ContractAddr].MainSupply -= ta.n8;\n', 'buyer[msg.sender].TocBalance += ta.n8;\n', 'buyer[msg.sender].Num += 1;\n', 'ta.n9 = buyer[msg.sender].Num; \n', 'transaction[msg.sender][ta.n9].Amount = ta.n8;\n', 'transaction[msg.sender][ta.n11].EtherPrice = ta.n5;\n', 'transaction[msg.sender][ta.n11].TocPrice = ta.n6;\n', 'transaction[msg.sender][ta.n9].Block = block.number;\n', 'return true;\n', '}    \n', '\n', '/*WITHDRAW TOC TOKENS*/\n', 'function Withdraw() external returns (bool){\n', '/*connect to ico data contract*/\n', 'IcoData\n', 'DataCall = IcoData(addressbook[ContractAddr].DataAddr);\n', '/*get ico cycle information*/\n', 'la.l3 = DataCall.GetEnd();\n', '/*integrity checks*/ \n', 'if(la.l3 == false) revert();\n', 'if(buyer[msg.sender].TocBalance <= 0) revert();\n', 'if(buyer[msg.sender].Withdrawn == true) revert();\n', '/*update buyer record*/\n', 'buyer[msg.sender].Withdrawn = true;\n', 'buyer[msg.sender].WithdrawalBlock = block.number;\n', '/*connect to toc contract*/\n', 'TOC\n', 'TOCCall = TOC(addressbook[ContractAddr].TOCAddr);\n', '/*check integrity before sending tokens*/\n', 'assert(buyer[msg.sender].Withdrawn == true);\n', '/*send toc to message sender*/\n', 'TOCCall.transfer(msg.sender,buyer[msg.sender].TocBalance);\n', '/*check integrity after sending tokens*/\n', 'assert(buyer[msg.sender].Withdrawn == true);\n', 'return true;\n', '}  \n', '\n', '/*RECEIVE APPROVAL & WITHDRAW TOC TOKENS*/\n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external returns(bool){ \n', 'TOC\n', 'TOCCall = TOC(_token);\n', 'TOCCall.transferFrom(_from,this,_value);\n', 'return true;\n', '}\n', '\n', '/*INVALID TRANSACTIONS*/\n', 'function () payable external{\n', 'revert();  \n', '}\n', '\n', '/*SAFE MATHS*/\n', 'function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', 'function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }  \n', 'function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', 'function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}///////////////////////////////////end of icodapp contract\n', '\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', '/*SPEND APPROVAL ALERT INTERFACE*/\n', 'interface tokenRecipient { \n', 'function receiveApproval(address _from, uint256 _value, \n', 'address _token, bytes _extraData) external; \n', '}\n', '\n', 'contract TOC {\n', '/*tokenchanger.io*/\n', '\n', '/*TOC TOKEN*/\n', 'string public name;\n', 'string public symbol;\n', 'uint8 public decimals;\n', 'uint256 public totalSupply;\n', '\n', '/*user coin balance*/\n', 'mapping (address => uint256) public balances;\n', '/*user coin allowances*/\n', 'mapping(address => mapping (address => uint256)) public allowed;\n', '\n', '/*EVENTS*/\t\t\n', '/*broadcast token transfers on the blockchain*/\n', 'event Transfer(address indexed from, address indexed to, uint256 value);\n', '/*broadcast token spend approvals on the blockchain*/\n', 'event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '/*MINT TOKEN*/\n', 'constructor() public {\n', 'name = "TokenChanger";\n', 'symbol = "TOC";\n', 'decimals = 18;\n', '/*one billion base units*/\n', 'totalSupply = 10**27;\n', 'balances[msg.sender] = totalSupply; \n', '}\n', '\n', '/*INTERNAL TRANSFER*/\n', 'function _transfer(address _from, address _to, uint _value) internal {    \n', '/*prevent transfer to invalid address*/    \n', 'if(_to == 0x0) revert();\n', '/*check if the sender has enough value to send*/\n', 'if(balances[_from] < _value) revert(); \n', '/*check for overflows*/\n', 'if(balances[_to] + _value < balances[_to]) revert();\n', '/*compute sending and receiving balances before transfer*/\n', 'uint PreviousBalances = balances[_from] + balances[_to];\n', '/*substract from sender*/\n', 'balances[_from] -= _value;\n', '/*add to the recipient*/\n', 'balances[_to] += _value; \n', '/*check integrity of transfer operation*/\n', 'assert(balances[_from] + balances[_to] == PreviousBalances);\n', '/*broadcast transaction*/\n', 'emit Transfer(_from, _to, _value); \n', '}\n', '\n', '/*PUBLIC TRANSFERS*/\n', 'function transfer(address _to, uint256 _value) external returns (bool){\n', '_transfer(msg.sender, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE THIRD PARTY SPENDING*/\n', 'function approve(address _spender, uint256 _value) public returns (bool success){\n', '/*update allowance record*/    \n', 'allowed[msg.sender][_spender] = _value;\n', '/*broadcast approval*/\n', 'emit Approval(msg.sender, _spender, _value); \n', 'return true;                                        \n', '}\n', '\n', '/*THIRD PARTY TRANSFER*/\n', 'function transferFrom(address _from, address _to, uint256 _value) \n', 'external returns (bool success) {\n', '/*check if the message sender can spend*/\n', 'require(_value <= allowed[_from][msg.sender]); \n', '/*substract from message sender&#39;s spend allowance*/\n', 'allowed[_from][msg.sender] -= _value;\n', '/*transfer tokens*/\n', '_transfer(_from, _to, _value);\n', 'return true;\n', '}\n', '\n', '/*APPROVE SPEND ALLOWANCE AND CALL SPENDER*/\n', 'function approveAndCall(address _spender, uint256 _value, \n', ' bytes _extraData) external returns (bool success) {\n', 'tokenRecipient \n', 'spender = tokenRecipient(_spender);\n', 'if(approve(_spender, _value)) {\n', 'spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '}\n', 'return true;\n', '}\n', '\n', '/*INVALID TRANSACTIONS*/\n', 'function () payable external{\n', 'revert();  \n', '}\n', '}/////////////////////////////////end of toc token contract']