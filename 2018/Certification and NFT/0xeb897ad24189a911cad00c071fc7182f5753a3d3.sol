['pragma solidity ^0.4.24;\n', '\n', '// File: libs/EC.sol\n', '\n', 'contract EC {\n', '\n', '    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n', '    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n', '    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '    uint256 constant public a = 0;\n', '    uint256 constant public b = 7;\n', '\n', '    function _jAdd(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jSub(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(n - x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jMul(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, x2, n),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jDiv(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, z2, n),\n', '            mulmod(z1, x2, n)\n', '        );\n', '    }\n', '\n', '    function _inverse(uint256 val) public pure\n', '        returns(uint256 invVal)\n', '    {\n', '        uint256 t = 0;\n', '        uint256 newT = 1;\n', '        uint256 r = n;\n', '        uint256 newR = val;\n', '        uint256 q;\n', '        while (newR != 0) {\n', '            q = r / newR;\n', '\n', '            (t, newT) = (newT, addmod(t, (n - mulmod(q, newT, n)), n));\n', '            (r, newR) = (newR, r - q * newR );\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '    function _ecAdd(\n', '        uint256 x1, uint256 y1, uint256 z1,\n', '        uint256 x2, uint256 y2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 lx;\n', '        uint256 lz;\n', '        uint256 da;\n', '        uint256 db;\n', '\n', '        if (x1 == 0 && y1 == 0) {\n', '            return (x2, y2, z2);\n', '        }\n', '\n', '        if (x2 == 0 && y2 == 0) {\n', '            return (x1, y1, z1);\n', '        }\n', '\n', '        if (x1 == x2 && y1 == y2) {\n', '            (lx, lz) = _jMul(x1, z1, x1, z1);\n', '            (lx, lz) = _jMul(lx, lz, 3, 1);\n', '            (lx, lz) = _jAdd(lx, lz, a, 1);\n', '\n', '            (da,db) = _jMul(y1, z1, 2, 1);\n', '        } else {\n', '            (lx, lz) = _jSub(y2, z2, y1, z1);\n', '            (da, db) = _jSub(x2, z2, x1, z1);\n', '        }\n', '\n', '        (lx, lz) = _jDiv(lx, lz, da, db);\n', '\n', '        (x3, da) = _jMul(lx, lz, lx, lz);\n', '        (x3, da) = _jSub(x3, da, x1, z1);\n', '        (x3, da) = _jSub(x3, da, x2, z2);\n', '\n', '        (y3, db) = _jSub(x1, z1, x3, da);\n', '        (y3, db) = _jMul(y3, db, lx, lz);\n', '        (y3, db) = _jSub(y3, db, y1, z1);\n', '\n', '        if (da != db) {\n', '            x3 = mulmod(x3, db, n);\n', '            y3 = mulmod(y3, da, n);\n', '            z3 = mulmod(da, db, n);\n', '        } else {\n', '            z3 = da;\n', '        }\n', '    }\n', '\n', '    function _ecDouble(uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        (x3, y3, z3) = _ecAdd(x1, y1, z1, x1, y1, z1);\n', '    }\n', '\n', '    function _ecMul(uint256 d, uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 remaining = d;\n', '        uint256 px = x1;\n', '        uint256 py = y1;\n', '        uint256 pz = z1;\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (d == 0) {\n', '            return (0, 0, 1);\n', '        }\n', '\n', '        while (remaining != 0) {\n', '            if ((remaining & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx, acy, acz, px, py, pz);\n', '            }\n', '            remaining = remaining / 2;\n', '            (px, py, pz) = _ecDouble(px, py, pz);\n', '        }\n', '\n', '        (x3, y3, z3) = (acx, acy, acz);\n', '    }\n', '\n', '    function ecadd(\n', '        uint256 x1, uint256 y1,\n', '        uint256 x2, uint256 y2)\n', '        public\n', '        pure\n', '        returns(uint256 x3, uint256 y3)\n', '    {\n', '        uint256 z;\n', '        (x3, y3, z) = _ecAdd(x1, y1, 1, x2, y2, 1);\n', '        z = _inverse(z);\n', '        x3 = mulmod(x3, z, n);\n', '        y3 = mulmod(y3, z, n);\n', '    }\n', '\n', '    function ecmul(uint256 x1, uint256 y1, uint256 scalar) public pure\n', '        returns(uint256 x2, uint256 y2)\n', '    {\n', '        uint256 z;\n', '        (x2, y2, z) = _ecMul(scalar, x1, y1, 1);\n', '        z = _inverse(z);\n', '        x2 = mulmod(x2, z, n);\n', '        y2 = mulmod(y2, z, n);\n', '    }\n', '\n', '    function ecmulVerify(uint256 x1, uint256 y1, uint256 scalar, uint256 qx, uint256 qy) public pure\n', '        returns(bool)\n', '    {\n', '        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n', '        address signer = ecrecover(0, y1 % 2 != 0 ? 28 : 27, bytes32(x1), bytes32(mulmod(scalar, x1, m)));\n', '        address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '        return xyAddress == signer;\n', '    }\n', '\n', '    function publicKey(uint256 privKey) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        return ecmul(gx, gy, privKey);\n', '    }\n', '\n', '    function publicKeyVerify(uint256 privKey, uint256 x, uint256 y) public pure\n', '        returns(bool)\n', '    {\n', '        return ecmulVerify(gx, gy, privKey, x, y);\n', '    }\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 z;\n', '        (qx, qy, z) = _ecMul(privKey, pubX, pubY, 1);\n', '        z = _inverse(z);\n', '        qx = mulmod(qx, z, n);\n', '        qy = mulmod(qy, z, n);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Upgradable.sol\n', '\n', 'contract IUpgradable {\n', '    function startUpgrade() public;\n', '    function endUpgrade() public;\n', '}\n', '\n', 'contract Upgradable is Ownable {\n', '    struct UpgradableState {\n', '        bool isUpgrading;\n', '        address prevVersion;\n', '        address nextVersion;\n', '    }\n', '\n', '    UpgradableState public upgradableState;\n', '\n', '    event Initialized(address indexed prevVersion);\n', '    event Upgrading(address indexed nextVersion);\n', '    event Upgraded(address indexed nextVersion);\n', '\n', '    modifier isLastestVersion {\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrigin {\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    constructor(address _prevVersion) public {\n', '        if (_prevVersion != address(0)) {\n', '            require(msg.sender == Ownable(_prevVersion).owner());\n', '            upgradableState.isUpgrading = true;\n', '            upgradableState.prevVersion = _prevVersion;\n', '            IUpgradable(_prevVersion).startUpgrade();\n', '        } else {\n', '            emit Initialized(_prevVersion);\n', '        }\n', '    }\n', '\n', '    function startUpgrade() public onlyOwnerOrigin {\n', '        require(msg.sender != owner);\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == 0);\n', '        upgradableState.isUpgrading = true;\n', '        upgradableState.nextVersion = msg.sender;\n', '        emit Upgrading(msg.sender);\n', '    }\n', '\n', '    //function upgrade(uint index, uint size) public onlyOwner {}\n', '\n', '    function endUpgrade() public onlyOwnerOrigin {\n', '        require(upgradableState.isUpgrading);\n', '        upgradableState.isUpgrading = false;\n', '        if (msg.sender != owner) {\n', '            require(upgradableState.nextVersion == msg.sender);\n', '            emit Upgraded(upgradableState.nextVersion);\n', '        } \n', '        else  {\n', '            if (upgradableState.prevVersion != address(0)) {\n', '                Upgradable(upgradableState.prevVersion).endUpgrade();\n', '            }\n', '            emit Initialized(upgradableState.prevVersion);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/VanityLib.sol\n', '\n', 'contract VanityLib {\n', '    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\n', '\n', '    function haveCommonPrefixUntilZero(bytes32 a, bytes32 b) public pure returns(bool) {\n', '        for (uint i = 0; i < 32; i++) {\n', '            if (a[i] == 0 || b[i] == 0) {\n', '                return true;\n', '            }\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    /* Converts given number to base58, limited by 32 symbols */\n', '    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\n', '        string memory letters = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";\n', '        bytes memory alphabet = bytes(letters);\n', '        uint8 base = 58;\n', '        uint8 len = 0;\n', '        uint256 remainder = 0;\n', '        bool needBreak = false;\n', '        bytes memory bytesReversed = bytes(new string(32));\n', '        \n', '        for (uint8 i = 0; true; i++) {\n', '            if (_value < base) {\n', '                needBreak = true;\n', '            }\n', '            remainder = _value % base;\n', '            _value = uint256(_value / base);\n', '            if (len == 32) {\n', '                for (uint j = 0; j < len - 1; j++) {\n', '                    bytesReversed[j] = bytesReversed[j + 1];\n', '                }\n', '                len--;\n', '            }\n', '            bytesReversed[len] = alphabet[remainder];\n', '            len++;\n', '            if (needBreak) {\n', '                break;\n', '            }\n', '        }\n', '        \n', '        // Reverse\n', '        bytes memory result = bytes(new string(32));\n', '        result[0] = appCode;\n', '        for (i = 0; i < 31; i++) {\n', '            result[i + 1] = bytesReversed[len - 1 - i];\n', '        }\n', '        \n', '        return bytesToBytes32(result);\n', '    }\n', '\n', '    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\n', '    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\n', '        bytes20 publicKeyPart = ripemd160(abi.encodePacked(sha256(abi.encodePacked(byte(0x04), publicXPoint, publicYPoint))));\n', '        bytes32 publicKeyCheckCode = sha256(abi.encodePacked(sha256(abi.encodePacked(byte(0x00), publicKeyPart))));\n', '        \n', '        bytes memory publicKey = new bytes(32);\n', '        for (uint i = 0; i < 7; i++) {\n', '            publicKey[i] = 0x00;\n', '        }\n', '        publicKey[7] = 0x00; // Main Network\n', '        for (uint j = 0; j < 20; j++) {\n', '            publicKey[j + 8] = publicKeyPart[j];\n', '        }\n', '        publicKey[28] = publicKeyCheckCode[0];\n', '        publicKey[29] = publicKeyCheckCode[1];\n', '        publicKey[30] = publicKeyCheckCode[2];\n', '        publicKey[31] = publicKeyCheckCode[3];\n', '        \n', '        return uint256(bytesToBytes32(publicKey));\n', '    }\n', '    \n', '    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\n', '        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), "1");\n', '    }\n', '\n', '    // function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\n', '    //     return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\n', '    // }\n', '\n', '    // // https://bitcoin.stackexchange.com/questions/48586\n', '    // function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\n', '    //     require(prefix.length >= length);\n', '        \n', '    //     uint8[128] memory unbase58 = [\n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '    //         255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \n', '    //         255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \n', '    //         22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\n', '    //         255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\n', '    //         47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\n', '    //     ];\n', '\n', '    //     uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\n', '\n', '    //     uint256 prefixValue = 0;\n', '    //     uint256 prefix1 = 1;\n', '    //     for (uint i = 0; i < length; i++) {\n', '    //         uint index = uint(prefix[i]);\n', '    //         require(index != 255);\n', '    //         prefixValue = prefixValue * 58 + unbase58[index];\n', '    //         prefix1 *= 58;\n', '    //     }\n', '\n', '    //     uint256 top = (uint256(1) << (200 - 8*leadingOnes));\n', '    //     uint256 total = 0;\n', '    //     uint256 prefixMin = prefixValue;\n', '    //     uint256 diff = 0;\n', '    //     for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\n', '    //         prefix1 *= 58;\n', '    //         prefixMin *= 58;\n', '    //         prefixValue = prefixValue * 58 + 57;\n', '\n', '    //         diff = 0;\n', '    //         if (prefixValue >= top) {\n', '    //             diff += prefixValue - top;\n', '    //         }\n', '    //         if (prefixMin < (top >> 8)) {\n', '    //             diff += (top >> 8) - prefixMin;\n', '    //         }\n', '            \n', '    //         if ((58 ** digits) >= diff) {\n', '    //             total += (58 ** digits) - diff;\n', '    //         }\n', '    //     }\n', '\n', '    //     if (prefixMin == 0) { // if prefix is contains only ones: 111111\n', '    //         total = (58 ** (digits - 1)) - diff;\n', '    //     }\n', '\n', '    //     return (1 << 192) / total;\n', '    // }\n', '\n', '    // function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\n', '    //     uint leadingOnes = 1;\n', '    //     for (uint j = 0; j < length && prefix[j] == 49; j++) {\n', '    //         leadingOnes = j + 1;\n', '    //     }\n', '    //     return leadingOnes;\n', '    // }\n', '\n', '    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\n', '        if (prefixArg.length < 5) {\n', '            return false;\n', '        }\n', '        if (prefixArg[0] != "1" && prefixArg[0] != "3") {\n', '            return false;\n', '        }\n', '        \n', '        for (uint i = 0; i < prefixArg.length; i++) {\n', '            byte ch = prefixArg[i];\n', '            if (ch == "0" || ch == "O" || ch == "I" || ch == "l") {\n', '                return false;\n', '            }\n', '            if (!((ch >= "1" && ch <= "9") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z"))) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\n', '        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\n', '    }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/TaskRegister.sol\n', '\n', 'contract TaskRegister is Upgradable, VanityLib {\n', '    using SafeMath for uint256;\n', '\n', '    enum TaskType {\n', '        BITCOIN_ADDRESS_PREFIX\n', '    }\n', '\n', '    struct Task {\n', '        TaskType taskType;\n', '        uint256 taskId;\n', '        address creator;\n', '        address referrer;\n', '        uint256 reward;\n', '        bytes32 data;\n', '        uint256 requestPublicXPoint;\n', '        uint256 requestPublicYPoint;\n', '        uint256 answerPrivateKey;\n', '    }\n', '\n', '    EC public ec;\n', '    uint256 public nextTaskId = 1;\n', '    uint256 public totalReward;\n', '    uint256 constant public MAX_PERCENT = 1000000;\n', '    uint256 public serviceFee; // 1% == 10000, 100% == 1000000\n', '    uint256 public referrerFee; // Calculated from service fee, 50% == 500000\n', '\n', '    Task[] public allTasks;\n', '    uint256[] public taskIds;\n', '    uint256[] public completedTaskIds;\n', '    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\n', '    mapping(uint256 => uint) public indexOfActiveTaskId; // Starting from 1\n', '    mapping(uint256 => uint) public indexOfCompletedTaskId; // Starting from 1\n', '\n', '    event TaskCreated(uint256 indexed taskId);\n', '    event TaskSolved(uint256 indexed taskId, uint256 reward);\n', '    event TaskPayed(uint256 indexed taskId, uint256 value);\n', '\n', '    constructor(address _ec, address _prevVersion) public Upgradable(_prevVersion) {\n', '        ec = EC(_ec);\n', '    }\n', '\n', '    function allTasksCount() public view returns(uint) {\n', '        return allTasks.length;\n', '    }\n', '\n', '    function tasksCount() public view returns(uint) {\n', '        return taskIds.length;\n', '    }\n', '\n', '    // function tasks(uint i) public view returns(Task) {\n', '    //     return allTasks[indexOfTaskId[taskIds[i]].sub(1)];\n', '    // }\n', '\n', '    function completedTasksCount() public view returns(uint) {\n', '        return completedTaskIds.length;\n', '    }\n', '\n', '    // function completedTasks(uint i) public view returns(Task) {\n', '    //     return allTasks[indexOfTaskId[completedTaskIds[i]].sub(1)];\n', '    // }\n', '\n', '    function getActiveTasks()\n', '        external\n', '        view\n', '        returns (\n', '            //TaskType[] t_taskTypes,\n', '            uint256[] t_taskIds, // + t_taskTypes\n', '            address[] t_creators,\n', '            //address[] t_referrers,\n', '            uint256[] t_rewards,\n', '            bytes32[] t_datas,\n', '            uint256[] t_requestPublicXPoints,\n', '            uint256[] t_requestPublicYPoints,\n', '            uint256[] t_answerPrivateKeys\n', '        )\n', '    {\n', '        //t_taskTypes = new TaskType[](allTasks.length);\n', '        t_taskIds = new uint256[](allTasks.length);\n', '        t_creators = new address[](allTasks.length);\n', '        //t_referrers = new address[](allTasks.length);\n', '        t_rewards = new uint256[](allTasks.length);\n', '        t_datas = new bytes32[](allTasks.length);\n', '        t_requestPublicXPoints = new uint256[](allTasks.length);\n', '        t_requestPublicYPoints = new uint256[](allTasks.length);\n', '        t_answerPrivateKeys = new uint256[](allTasks.length);\n', '\n', '        for (uint i = 0; i < taskIds.length; i++) {\n', '            uint index = indexOfActiveTaskId[taskIds[i]];\n', '            (\n', '                //t_taskTypes[i],\n', '                t_taskIds[i],\n', '                t_creators[i],\n', '                //t_referrers[i],\n', '                t_rewards[i],\n', '                t_datas[i],\n', '                t_requestPublicXPoints[i],\n', '                t_requestPublicYPoints[i],\n', '                t_answerPrivateKeys[i]\n', '            ) = (\n', '                //allTasks[i].taskType,\n', '                (uint(allTasks[index].taskType) << 128) | allTasks[index].taskId,\n', '                allTasks[index].creator,\n', '                //allTasks[index].referrer,\n', '                allTasks[index].reward,\n', '                allTasks[index].data,\n', '                allTasks[index].requestPublicXPoint,\n', '                allTasks[index].requestPublicYPoint,\n', '                allTasks[index].answerPrivateKey\n', '            );\n', '        }\n', '    }\n', '\n', '    function getCompletedTasks()\n', '        external\n', '        view\n', '        returns (\n', '            //TaskType[] t_taskTypes,\n', '            uint256[] t_taskIds, // + t_taskTypes\n', '            address[] t_creators,\n', '            //address[] t_referrers,\n', '            uint256[] t_rewards,\n', '            bytes32[] t_datas,\n', '            uint256[] t_requestPublicXPoints,\n', '            uint256[] t_requestPublicYPoints,\n', '            uint256[] t_answerPrivateKeys\n', '        )\n', '    {\n', '        //t_taskTypes = new TaskType[](allTasks.length);\n', '        t_taskIds = new uint256[](allTasks.length);\n', '        t_creators = new address[](allTasks.length);\n', '        //t_referrers = new address[](allTasks.length);\n', '        t_rewards = new uint256[](allTasks.length);\n', '        t_datas = new bytes32[](allTasks.length);\n', '        t_requestPublicXPoints = new uint256[](allTasks.length);\n', '        t_requestPublicYPoints = new uint256[](allTasks.length);\n', '        t_answerPrivateKeys = new uint256[](allTasks.length);\n', '\n', '        for (uint i = 0; i < completedTaskIds.length; i++) {\n', '            uint index = indexOfCompletedTaskId[completedTaskIds[i]];\n', '            (\n', '                //t_taskTypes[i],\n', '                t_taskIds[i],\n', '                t_creators[i],\n', '                //t_referrers[i],\n', '                t_rewards[i],\n', '                t_datas[i],\n', '                t_requestPublicXPoints[i],\n', '                t_requestPublicYPoints[i],\n', '                t_answerPrivateKeys[i]\n', '            ) = (\n', '                //allTasks[i].taskType,\n', '                (uint(allTasks[index].taskType) << 128) | allTasks[index].taskId,\n', '                allTasks[index].creator,\n', '                //allTasks[index].referrer,\n', '                allTasks[index].reward,\n', '                allTasks[index].data,\n', '                allTasks[index].requestPublicXPoint,\n', '                allTasks[index].requestPublicYPoint,\n', '                allTasks[index].answerPrivateKey\n', '            );\n', '        }\n', '    }\n', '\n', '    function setServiceFee(uint256 _serviceFee) public onlyOwner {\n', '        require(_serviceFee <= 20000, "setServiceFee: value should be less than 20000, which means 2% of miner reward");\n', '        serviceFee = _serviceFee;\n', '    }\n', '\n', '    function setReferrerFee(uint256 _referrerFee) public onlyOwner {\n', '        require(_referrerFee <= 500000, "setReferrerFee: value should be less than 500000, which means 50% of service fee");\n', '        referrerFee = _referrerFee;\n', '    }\n', '\n', '    function upgrade(uint _size) public onlyOwner {\n', '        require(upgradableState.isUpgrading);\n', '        require(upgradableState.prevVersion != 0);\n', '\n', '        // Migrate some vars\n', '        TaskRegister prev = TaskRegister(upgradableState.prevVersion);\n', '        nextTaskId = prev.nextTaskId();\n', '        totalReward = prev.totalReward();\n', '        serviceFee = prev.serviceFee();\n', '        referrerFee = prev.referrerFee();\n', '\n', '        uint index = allTasks.length;\n', '        uint tasksLength = prev.tasksCount();\n', '        \n', '        // Migrate tasks\n', '\n', '        for (uint i = index; i < index + _size && i < tasksLength; i++) {\n', '            allTasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,0,bytes32(0),0,0,0));\n', '            uint j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                allTasks[i].taskType,\n', '                allTasks[i].taskId,\n', '                allTasks[i].creator,\n', '                ,//allTasks[i].referrer,\n', '                ,//allTasks[i].reward,\n', '                ,//allTasks[i].data,\n', '                ,//allTasks[i].requestPublicXPoint,\n', '                ,//allTasks[i].requestPublicYPoint,\n', '                 //allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '            indexOfTaskId[allTasks[i].taskId] = i + 1;\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                ,//allTasks[i].taskType,\n', '                ,//allTasks[i].taskId,\n', '                ,//allTasks[i].creator,\n', '                allTasks[i].referrer,\n', '                allTasks[i].reward,\n', '                allTasks[i].data,\n', '                ,//allTasks[i].requestPublicXPoint,\n', '                ,//allTasks[i].requestPublicYPoint,\n', '                 //allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                ,//allTasks[i].taskType,\n', '                ,//allTasks[i].taskId,\n', '                ,//allTasks[i].creator,\n', '                ,//allTasks[i].referrer,\n', '                ,//allTasks[i].reward,\n', '                ,//allTasks[i].data,\n', '                allTasks[i].requestPublicXPoint,\n', '                allTasks[i].requestPublicYPoint,\n', '                allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            taskIds.push(prev.taskIds(i));\n', '        }\n', '\n', '        _removeAllActiveTasksWithHoles(index, index + _size);\n', '    }\n', '\n', '    function endUpgrade() public {\n', '        super.endUpgrade();\n', '\n', '        if (upgradableState.nextVersion != 0) {\n', '            upgradableState.nextVersion.transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '    function payForTask(uint256 _taskId) public payable isLastestVersion {\n', '        if (msg.value > 0) {\n', '            Task storage task = allTasks[indexOfTaskId[_taskId].sub(1)];\n', '            require(task.answerPrivateKey == 0, "payForTask: you can&#39;t pay for the solved task");\n', '            task.reward = task.reward.add(msg.value);\n', '            totalReward = totalReward.add(msg.value);\n', '            emit TaskPayed(_taskId, msg.value);\n', '        }\n', '    }\n', '\n', '    function createBitcoinAddressPrefixTask(\n', '        bytes prefix,\n', '        uint256 requestPublicXPoint,\n', '        uint256 requestPublicYPoint,\n', '        address referrer\n', '    )\n', '        public\n', '        payable\n', '        isLastestVersion\n', '    {\n', '        require(prefix.length > 5);\n', '        require(prefix[0] == "1");\n', '        require(prefix[1] != "1"); // Do not support multiple 1s yet\n', '        require(isValidBicoinAddressPrefix(prefix));\n', '        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\n', '\n', '        bytes32 data;\n', '        assembly {\n', '            data := mload(add(prefix, 32))\n', '        }\n', '\n', '        uint256 taskId = nextTaskId++;\n', '        Task memory task = Task({\n', '            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\n', '            taskId: taskId,\n', '            creator: msg.sender,\n', '            referrer: referrer,\n', '            reward: 0,\n', '            data: data,\n', '            requestPublicXPoint: requestPublicXPoint,\n', '            requestPublicYPoint: requestPublicYPoint,\n', '            answerPrivateKey: 0\n', '        });\n', '\n', '        indexOfTaskId[taskId] = allTasks.push(task); // incremented to avoid 0 index\n', '        indexOfActiveTaskId[taskId] = taskIds.push(taskId);\n', '        emit TaskCreated(taskId);\n', '        payForTask(taskId);\n', '    }\n', '\n', '    function solveTask(uint _taskId, uint256 _answerPrivateKey, uint256 publicXPoint, uint256 publicYPoint) public isLastestVersion {\n', '        uint activeTaskIndex = indexOfTaskId[_taskId].sub(1);\n', '        Task storage task = allTasks[activeTaskIndex];\n', '        require(task.answerPrivateKey == 0, "solveTask: task is already solved");\n', '        \n', '        // Require private key to be part of address to prevent front-running attack\n', '        require(_answerPrivateKey >> 128 == uint256(msg.sender) >> 32, "solveTask: this solution does not match miner address");\n', '\n', '        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\n', '            ///(publicXPoint, publicYPoint) = ec.publicKey(_answerPrivateKey);\n', '            require(ec.publicKeyVerify(_answerPrivateKey, publicXPoint, publicYPoint));\n', '            (publicXPoint, publicYPoint) = ec.ecadd(\n', '                task.requestPublicXPoint,\n', '                task.requestPublicYPoint,\n', '                publicXPoint,\n', '                publicYPoint\n', '            );\n', '\n', '            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\n', '            require(haveCommonPrefixUntilZero(task.data, btcAddress), "solveTask: found prefix is not enough");\n', '\n', '            task.answerPrivateKey = _answerPrivateKey;\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        uint256 taskReard = task.reward;\n', '        uint256 serviceReward = taskReard.mul(serviceFee).div(MAX_PERCENT); // 1%\n', '        uint256 minerReward = taskReard - serviceReward; // 99%\n', '        if (serviceReward != 0 && task.referrer != 0) {\n', '            uint256 referrerReward = serviceReward.mul(referrerFee).div(MAX_PERCENT); // 50% of service reward\n', '            task.referrer.transfer(referrerReward);\n', '        }\n', '        msg.sender.transfer(minerReward);\n', '        totalReward -= taskReard;\n', '        \n', '        _completeTask(_taskId, activeTaskIndex);\n', '        emit TaskSolved(_taskId, minerReward);\n', '    }\n', '\n', '    function _completeTask(uint _taskId, uint _activeTaskIndex) internal {\n', '        indexOfCompletedTaskId[_taskId] = completedTaskIds.push(_taskId);\n', '        delete indexOfActiveTaskId[_taskId];\n', '\n', '        if (_activeTaskIndex + 1 < taskIds.length) { // if not latest\n', '            uint256 lastTaskId = taskIds[taskIds.length - 1];\n', '            taskIds[_activeTaskIndex] = lastTaskId;\n', '            indexOfActiveTaskId[lastTaskId] = _activeTaskIndex + 1;\n', '        }\n', '        taskIds.length -= 1;\n', '    }\n', '\n', '    function _removeAllActiveTasksWithHoles(uint _from, uint _to) internal {\n', '        for (uint i = _from; i < _to && i < taskIds.length; i++) {\n', '            uint taskId = taskIds[i];\n', '            uint index = indexOfTaskId[taskId].sub(1);\n', '            delete allTasks[index];\n', '            delete indexOfTaskId[taskId];\n', '            delete indexOfActiveTaskId[taskId];\n', '        }\n', '        if (_to >= taskIds.length) {\n', '            taskIds.length = 0;\n', '        }\n', '    }\n', '\n', '    function claim(ERC20Basic _token, address _to) public onlyOwner {\n', '        if (_token == address(0)) {\n', '            _to.transfer(address(this).balance - totalReward);\n', '        } else {\n', '            _token.transfer(_to, _token.balanceOf(this));\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: libs/EC.sol\n', '\n', 'contract EC {\n', '\n', '    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n', '    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n', '    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '    uint256 constant public a = 0;\n', '    uint256 constant public b = 7;\n', '\n', '    function _jAdd(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jSub(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            addmod(\n', '                mulmod(z2, x1, n),\n', '                mulmod(n - x2, z1, n),\n', '                n\n', '            ),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jMul(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2)\n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, x2, n),\n', '            mulmod(z1, z2, n)\n', '        );\n', '    }\n', '\n', '    function _jDiv(\n', '        uint256 x1, uint256 z1,\n', '        uint256 x2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 z3)\n', '    {\n', '        (x3, z3) = (\n', '            mulmod(x1, z2, n),\n', '            mulmod(z1, x2, n)\n', '        );\n', '    }\n', '\n', '    function _inverse(uint256 val) public pure\n', '        returns(uint256 invVal)\n', '    {\n', '        uint256 t = 0;\n', '        uint256 newT = 1;\n', '        uint256 r = n;\n', '        uint256 newR = val;\n', '        uint256 q;\n', '        while (newR != 0) {\n', '            q = r / newR;\n', '\n', '            (t, newT) = (newT, addmod(t, (n - mulmod(q, newT, n)), n));\n', '            (r, newR) = (newR, r - q * newR );\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '    function _ecAdd(\n', '        uint256 x1, uint256 y1, uint256 z1,\n', '        uint256 x2, uint256 y2, uint256 z2) \n', '        public \n', '        pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 lx;\n', '        uint256 lz;\n', '        uint256 da;\n', '        uint256 db;\n', '\n', '        if (x1 == 0 && y1 == 0) {\n', '            return (x2, y2, z2);\n', '        }\n', '\n', '        if (x2 == 0 && y2 == 0) {\n', '            return (x1, y1, z1);\n', '        }\n', '\n', '        if (x1 == x2 && y1 == y2) {\n', '            (lx, lz) = _jMul(x1, z1, x1, z1);\n', '            (lx, lz) = _jMul(lx, lz, 3, 1);\n', '            (lx, lz) = _jAdd(lx, lz, a, 1);\n', '\n', '            (da,db) = _jMul(y1, z1, 2, 1);\n', '        } else {\n', '            (lx, lz) = _jSub(y2, z2, y1, z1);\n', '            (da, db) = _jSub(x2, z2, x1, z1);\n', '        }\n', '\n', '        (lx, lz) = _jDiv(lx, lz, da, db);\n', '\n', '        (x3, da) = _jMul(lx, lz, lx, lz);\n', '        (x3, da) = _jSub(x3, da, x1, z1);\n', '        (x3, da) = _jSub(x3, da, x2, z2);\n', '\n', '        (y3, db) = _jSub(x1, z1, x3, da);\n', '        (y3, db) = _jMul(y3, db, lx, lz);\n', '        (y3, db) = _jSub(y3, db, y1, z1);\n', '\n', '        if (da != db) {\n', '            x3 = mulmod(x3, db, n);\n', '            y3 = mulmod(y3, da, n);\n', '            z3 = mulmod(da, db, n);\n', '        } else {\n', '            z3 = da;\n', '        }\n', '    }\n', '\n', '    function _ecDouble(uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        (x3, y3, z3) = _ecAdd(x1, y1, z1, x1, y1, z1);\n', '    }\n', '\n', '    function _ecMul(uint256 d, uint256 x1, uint256 y1, uint256 z1) public pure\n', '        returns(uint256 x3, uint256 y3, uint256 z3)\n', '    {\n', '        uint256 remaining = d;\n', '        uint256 px = x1;\n', '        uint256 py = y1;\n', '        uint256 pz = z1;\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (d == 0) {\n', '            return (0, 0, 1);\n', '        }\n', '\n', '        while (remaining != 0) {\n', '            if ((remaining & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx, acy, acz, px, py, pz);\n', '            }\n', '            remaining = remaining / 2;\n', '            (px, py, pz) = _ecDouble(px, py, pz);\n', '        }\n', '\n', '        (x3, y3, z3) = (acx, acy, acz);\n', '    }\n', '\n', '    function ecadd(\n', '        uint256 x1, uint256 y1,\n', '        uint256 x2, uint256 y2)\n', '        public\n', '        pure\n', '        returns(uint256 x3, uint256 y3)\n', '    {\n', '        uint256 z;\n', '        (x3, y3, z) = _ecAdd(x1, y1, 1, x2, y2, 1);\n', '        z = _inverse(z);\n', '        x3 = mulmod(x3, z, n);\n', '        y3 = mulmod(y3, z, n);\n', '    }\n', '\n', '    function ecmul(uint256 x1, uint256 y1, uint256 scalar) public pure\n', '        returns(uint256 x2, uint256 y2)\n', '    {\n', '        uint256 z;\n', '        (x2, y2, z) = _ecMul(scalar, x1, y1, 1);\n', '        z = _inverse(z);\n', '        x2 = mulmod(x2, z, n);\n', '        y2 = mulmod(y2, z, n);\n', '    }\n', '\n', '    function ecmulVerify(uint256 x1, uint256 y1, uint256 scalar, uint256 qx, uint256 qy) public pure\n', '        returns(bool)\n', '    {\n', '        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n', '        address signer = ecrecover(0, y1 % 2 != 0 ? 28 : 27, bytes32(x1), bytes32(mulmod(scalar, x1, m)));\n', '        address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '        return xyAddress == signer;\n', '    }\n', '\n', '    function publicKey(uint256 privKey) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        return ecmul(gx, gy, privKey);\n', '    }\n', '\n', '    function publicKeyVerify(uint256 privKey, uint256 x, uint256 y) public pure\n', '        returns(bool)\n', '    {\n', '        return ecmulVerify(gx, gy, privKey, x, y);\n', '    }\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 z;\n', '        (qx, qy, z) = _ecMul(privKey, pubX, pubY, 1);\n', '        z = _inverse(z);\n', '        qx = mulmod(qx, z, n);\n', '        qy = mulmod(qy, z, n);\n', '    }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/Upgradable.sol\n', '\n', 'contract IUpgradable {\n', '    function startUpgrade() public;\n', '    function endUpgrade() public;\n', '}\n', '\n', 'contract Upgradable is Ownable {\n', '    struct UpgradableState {\n', '        bool isUpgrading;\n', '        address prevVersion;\n', '        address nextVersion;\n', '    }\n', '\n', '    UpgradableState public upgradableState;\n', '\n', '    event Initialized(address indexed prevVersion);\n', '    event Upgrading(address indexed nextVersion);\n', '    event Upgraded(address indexed nextVersion);\n', '\n', '    modifier isLastestVersion {\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrigin {\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    constructor(address _prevVersion) public {\n', '        if (_prevVersion != address(0)) {\n', '            require(msg.sender == Ownable(_prevVersion).owner());\n', '            upgradableState.isUpgrading = true;\n', '            upgradableState.prevVersion = _prevVersion;\n', '            IUpgradable(_prevVersion).startUpgrade();\n', '        } else {\n', '            emit Initialized(_prevVersion);\n', '        }\n', '    }\n', '\n', '    function startUpgrade() public onlyOwnerOrigin {\n', '        require(msg.sender != owner);\n', '        require(!upgradableState.isUpgrading);\n', '        require(upgradableState.nextVersion == 0);\n', '        upgradableState.isUpgrading = true;\n', '        upgradableState.nextVersion = msg.sender;\n', '        emit Upgrading(msg.sender);\n', '    }\n', '\n', '    //function upgrade(uint index, uint size) public onlyOwner {}\n', '\n', '    function endUpgrade() public onlyOwnerOrigin {\n', '        require(upgradableState.isUpgrading);\n', '        upgradableState.isUpgrading = false;\n', '        if (msg.sender != owner) {\n', '            require(upgradableState.nextVersion == msg.sender);\n', '            emit Upgraded(upgradableState.nextVersion);\n', '        } \n', '        else  {\n', '            if (upgradableState.prevVersion != address(0)) {\n', '                Upgradable(upgradableState.prevVersion).endUpgrade();\n', '            }\n', '            emit Initialized(upgradableState.prevVersion);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/VanityLib.sol\n', '\n', 'contract VanityLib {\n', '    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\n', '\n', '    function haveCommonPrefixUntilZero(bytes32 a, bytes32 b) public pure returns(bool) {\n', '        for (uint i = 0; i < 32; i++) {\n', '            if (a[i] == 0 || b[i] == 0) {\n', '                return true;\n', '            }\n', '            if (a[i] != b[i]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '\n', '    /* Converts given number to base58, limited by 32 symbols */\n', '    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\n', '        string memory letters = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";\n', '        bytes memory alphabet = bytes(letters);\n', '        uint8 base = 58;\n', '        uint8 len = 0;\n', '        uint256 remainder = 0;\n', '        bool needBreak = false;\n', '        bytes memory bytesReversed = bytes(new string(32));\n', '        \n', '        for (uint8 i = 0; true; i++) {\n', '            if (_value < base) {\n', '                needBreak = true;\n', '            }\n', '            remainder = _value % base;\n', '            _value = uint256(_value / base);\n', '            if (len == 32) {\n', '                for (uint j = 0; j < len - 1; j++) {\n', '                    bytesReversed[j] = bytesReversed[j + 1];\n', '                }\n', '                len--;\n', '            }\n', '            bytesReversed[len] = alphabet[remainder];\n', '            len++;\n', '            if (needBreak) {\n', '                break;\n', '            }\n', '        }\n', '        \n', '        // Reverse\n', '        bytes memory result = bytes(new string(32));\n', '        result[0] = appCode;\n', '        for (i = 0; i < 31; i++) {\n', '            result[i + 1] = bytesReversed[len - 1 - i];\n', '        }\n', '        \n', '        return bytesToBytes32(result);\n', '    }\n', '\n', '    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\n', '    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\n', '        bytes20 publicKeyPart = ripemd160(abi.encodePacked(sha256(abi.encodePacked(byte(0x04), publicXPoint, publicYPoint))));\n', '        bytes32 publicKeyCheckCode = sha256(abi.encodePacked(sha256(abi.encodePacked(byte(0x00), publicKeyPart))));\n', '        \n', '        bytes memory publicKey = new bytes(32);\n', '        for (uint i = 0; i < 7; i++) {\n', '            publicKey[i] = 0x00;\n', '        }\n', '        publicKey[7] = 0x00; // Main Network\n', '        for (uint j = 0; j < 20; j++) {\n', '            publicKey[j + 8] = publicKeyPart[j];\n', '        }\n', '        publicKey[28] = publicKeyCheckCode[0];\n', '        publicKey[29] = publicKeyCheckCode[1];\n', '        publicKey[30] = publicKeyCheckCode[2];\n', '        publicKey[31] = publicKeyCheckCode[3];\n', '        \n', '        return uint256(bytesToBytes32(publicKey));\n', '    }\n', '    \n', '    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\n', '        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), "1");\n', '    }\n', '\n', '    // function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\n', '    //     return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\n', '    // }\n', '\n', '    // // https://bitcoin.stackexchange.com/questions/48586\n', '    // function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\n', '    //     require(prefix.length >= length);\n', '        \n', '    //     uint8[128] memory unbase58 = [\n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n', '    //         255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \n', '    //         255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \n', '    //         255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \n', '    //         22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\n', '    //         255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\n', '    //         47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\n', '    //     ];\n', '\n', '    //     uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\n', '\n', '    //     uint256 prefixValue = 0;\n', '    //     uint256 prefix1 = 1;\n', '    //     for (uint i = 0; i < length; i++) {\n', '    //         uint index = uint(prefix[i]);\n', '    //         require(index != 255);\n', '    //         prefixValue = prefixValue * 58 + unbase58[index];\n', '    //         prefix1 *= 58;\n', '    //     }\n', '\n', '    //     uint256 top = (uint256(1) << (200 - 8*leadingOnes));\n', '    //     uint256 total = 0;\n', '    //     uint256 prefixMin = prefixValue;\n', '    //     uint256 diff = 0;\n', '    //     for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\n', '    //         prefix1 *= 58;\n', '    //         prefixMin *= 58;\n', '    //         prefixValue = prefixValue * 58 + 57;\n', '\n', '    //         diff = 0;\n', '    //         if (prefixValue >= top) {\n', '    //             diff += prefixValue - top;\n', '    //         }\n', '    //         if (prefixMin < (top >> 8)) {\n', '    //             diff += (top >> 8) - prefixMin;\n', '    //         }\n', '            \n', '    //         if ((58 ** digits) >= diff) {\n', '    //             total += (58 ** digits) - diff;\n', '    //         }\n', '    //     }\n', '\n', '    //     if (prefixMin == 0) { // if prefix is contains only ones: 111111\n', '    //         total = (58 ** (digits - 1)) - diff;\n', '    //     }\n', '\n', '    //     return (1 << 192) / total;\n', '    // }\n', '\n', '    // function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\n', '    //     uint leadingOnes = 1;\n', '    //     for (uint j = 0; j < length && prefix[j] == 49; j++) {\n', '    //         leadingOnes = j + 1;\n', '    //     }\n', '    //     return leadingOnes;\n', '    // }\n', '\n', '    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\n', '        if (prefixArg.length < 5) {\n', '            return false;\n', '        }\n', '        if (prefixArg[0] != "1" && prefixArg[0] != "3") {\n', '            return false;\n', '        }\n', '        \n', '        for (uint i = 0; i < prefixArg.length; i++) {\n', '            byte ch = prefixArg[i];\n', '            if (ch == "0" || ch == "O" || ch == "I" || ch == "l") {\n', '                return false;\n', '            }\n', '            if (!((ch >= "1" && ch <= "9") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z"))) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\n', '        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\n', '    }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/TaskRegister.sol\n', '\n', 'contract TaskRegister is Upgradable, VanityLib {\n', '    using SafeMath for uint256;\n', '\n', '    enum TaskType {\n', '        BITCOIN_ADDRESS_PREFIX\n', '    }\n', '\n', '    struct Task {\n', '        TaskType taskType;\n', '        uint256 taskId;\n', '        address creator;\n', '        address referrer;\n', '        uint256 reward;\n', '        bytes32 data;\n', '        uint256 requestPublicXPoint;\n', '        uint256 requestPublicYPoint;\n', '        uint256 answerPrivateKey;\n', '    }\n', '\n', '    EC public ec;\n', '    uint256 public nextTaskId = 1;\n', '    uint256 public totalReward;\n', '    uint256 constant public MAX_PERCENT = 1000000;\n', '    uint256 public serviceFee; // 1% == 10000, 100% == 1000000\n', '    uint256 public referrerFee; // Calculated from service fee, 50% == 500000\n', '\n', '    Task[] public allTasks;\n', '    uint256[] public taskIds;\n', '    uint256[] public completedTaskIds;\n', '    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\n', '    mapping(uint256 => uint) public indexOfActiveTaskId; // Starting from 1\n', '    mapping(uint256 => uint) public indexOfCompletedTaskId; // Starting from 1\n', '\n', '    event TaskCreated(uint256 indexed taskId);\n', '    event TaskSolved(uint256 indexed taskId, uint256 reward);\n', '    event TaskPayed(uint256 indexed taskId, uint256 value);\n', '\n', '    constructor(address _ec, address _prevVersion) public Upgradable(_prevVersion) {\n', '        ec = EC(_ec);\n', '    }\n', '\n', '    function allTasksCount() public view returns(uint) {\n', '        return allTasks.length;\n', '    }\n', '\n', '    function tasksCount() public view returns(uint) {\n', '        return taskIds.length;\n', '    }\n', '\n', '    // function tasks(uint i) public view returns(Task) {\n', '    //     return allTasks[indexOfTaskId[taskIds[i]].sub(1)];\n', '    // }\n', '\n', '    function completedTasksCount() public view returns(uint) {\n', '        return completedTaskIds.length;\n', '    }\n', '\n', '    // function completedTasks(uint i) public view returns(Task) {\n', '    //     return allTasks[indexOfTaskId[completedTaskIds[i]].sub(1)];\n', '    // }\n', '\n', '    function getActiveTasks()\n', '        external\n', '        view\n', '        returns (\n', '            //TaskType[] t_taskTypes,\n', '            uint256[] t_taskIds, // + t_taskTypes\n', '            address[] t_creators,\n', '            //address[] t_referrers,\n', '            uint256[] t_rewards,\n', '            bytes32[] t_datas,\n', '            uint256[] t_requestPublicXPoints,\n', '            uint256[] t_requestPublicYPoints,\n', '            uint256[] t_answerPrivateKeys\n', '        )\n', '    {\n', '        //t_taskTypes = new TaskType[](allTasks.length);\n', '        t_taskIds = new uint256[](allTasks.length);\n', '        t_creators = new address[](allTasks.length);\n', '        //t_referrers = new address[](allTasks.length);\n', '        t_rewards = new uint256[](allTasks.length);\n', '        t_datas = new bytes32[](allTasks.length);\n', '        t_requestPublicXPoints = new uint256[](allTasks.length);\n', '        t_requestPublicYPoints = new uint256[](allTasks.length);\n', '        t_answerPrivateKeys = new uint256[](allTasks.length);\n', '\n', '        for (uint i = 0; i < taskIds.length; i++) {\n', '            uint index = indexOfActiveTaskId[taskIds[i]];\n', '            (\n', '                //t_taskTypes[i],\n', '                t_taskIds[i],\n', '                t_creators[i],\n', '                //t_referrers[i],\n', '                t_rewards[i],\n', '                t_datas[i],\n', '                t_requestPublicXPoints[i],\n', '                t_requestPublicYPoints[i],\n', '                t_answerPrivateKeys[i]\n', '            ) = (\n', '                //allTasks[i].taskType,\n', '                (uint(allTasks[index].taskType) << 128) | allTasks[index].taskId,\n', '                allTasks[index].creator,\n', '                //allTasks[index].referrer,\n', '                allTasks[index].reward,\n', '                allTasks[index].data,\n', '                allTasks[index].requestPublicXPoint,\n', '                allTasks[index].requestPublicYPoint,\n', '                allTasks[index].answerPrivateKey\n', '            );\n', '        }\n', '    }\n', '\n', '    function getCompletedTasks()\n', '        external\n', '        view\n', '        returns (\n', '            //TaskType[] t_taskTypes,\n', '            uint256[] t_taskIds, // + t_taskTypes\n', '            address[] t_creators,\n', '            //address[] t_referrers,\n', '            uint256[] t_rewards,\n', '            bytes32[] t_datas,\n', '            uint256[] t_requestPublicXPoints,\n', '            uint256[] t_requestPublicYPoints,\n', '            uint256[] t_answerPrivateKeys\n', '        )\n', '    {\n', '        //t_taskTypes = new TaskType[](allTasks.length);\n', '        t_taskIds = new uint256[](allTasks.length);\n', '        t_creators = new address[](allTasks.length);\n', '        //t_referrers = new address[](allTasks.length);\n', '        t_rewards = new uint256[](allTasks.length);\n', '        t_datas = new bytes32[](allTasks.length);\n', '        t_requestPublicXPoints = new uint256[](allTasks.length);\n', '        t_requestPublicYPoints = new uint256[](allTasks.length);\n', '        t_answerPrivateKeys = new uint256[](allTasks.length);\n', '\n', '        for (uint i = 0; i < completedTaskIds.length; i++) {\n', '            uint index = indexOfCompletedTaskId[completedTaskIds[i]];\n', '            (\n', '                //t_taskTypes[i],\n', '                t_taskIds[i],\n', '                t_creators[i],\n', '                //t_referrers[i],\n', '                t_rewards[i],\n', '                t_datas[i],\n', '                t_requestPublicXPoints[i],\n', '                t_requestPublicYPoints[i],\n', '                t_answerPrivateKeys[i]\n', '            ) = (\n', '                //allTasks[i].taskType,\n', '                (uint(allTasks[index].taskType) << 128) | allTasks[index].taskId,\n', '                allTasks[index].creator,\n', '                //allTasks[index].referrer,\n', '                allTasks[index].reward,\n', '                allTasks[index].data,\n', '                allTasks[index].requestPublicXPoint,\n', '                allTasks[index].requestPublicYPoint,\n', '                allTasks[index].answerPrivateKey\n', '            );\n', '        }\n', '    }\n', '\n', '    function setServiceFee(uint256 _serviceFee) public onlyOwner {\n', '        require(_serviceFee <= 20000, "setServiceFee: value should be less than 20000, which means 2% of miner reward");\n', '        serviceFee = _serviceFee;\n', '    }\n', '\n', '    function setReferrerFee(uint256 _referrerFee) public onlyOwner {\n', '        require(_referrerFee <= 500000, "setReferrerFee: value should be less than 500000, which means 50% of service fee");\n', '        referrerFee = _referrerFee;\n', '    }\n', '\n', '    function upgrade(uint _size) public onlyOwner {\n', '        require(upgradableState.isUpgrading);\n', '        require(upgradableState.prevVersion != 0);\n', '\n', '        // Migrate some vars\n', '        TaskRegister prev = TaskRegister(upgradableState.prevVersion);\n', '        nextTaskId = prev.nextTaskId();\n', '        totalReward = prev.totalReward();\n', '        serviceFee = prev.serviceFee();\n', '        referrerFee = prev.referrerFee();\n', '\n', '        uint index = allTasks.length;\n', '        uint tasksLength = prev.tasksCount();\n', '        \n', '        // Migrate tasks\n', '\n', '        for (uint i = index; i < index + _size && i < tasksLength; i++) {\n', '            allTasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,0,bytes32(0),0,0,0));\n', '            uint j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                allTasks[i].taskType,\n', '                allTasks[i].taskId,\n', '                allTasks[i].creator,\n', '                ,//allTasks[i].referrer,\n', '                ,//allTasks[i].reward,\n', '                ,//allTasks[i].data,\n', '                ,//allTasks[i].requestPublicXPoint,\n', '                ,//allTasks[i].requestPublicYPoint,\n', '                 //allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '            indexOfTaskId[allTasks[i].taskId] = i + 1;\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                ,//allTasks[i].taskType,\n', '                ,//allTasks[i].taskId,\n', '                ,//allTasks[i].creator,\n', '                allTasks[i].referrer,\n', '                allTasks[i].reward,\n', '                allTasks[i].data,\n', '                ,//allTasks[i].requestPublicXPoint,\n', '                ,//allTasks[i].requestPublicYPoint,\n', '                 //allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            j = prev.indexOfActiveTaskId(prev.taskIds(i));\n', '            (\n', '                ,//allTasks[i].taskType,\n', '                ,//allTasks[i].taskId,\n', '                ,//allTasks[i].creator,\n', '                ,//allTasks[i].referrer,\n', '                ,//allTasks[i].reward,\n', '                ,//allTasks[i].data,\n', '                allTasks[i].requestPublicXPoint,\n', '                allTasks[i].requestPublicYPoint,\n', '                allTasks[i].answerPrivateKey\n', '            ) = prev.allTasks(j);\n', '        }\n', '\n', '        for (i = index; i < index + _size && i < tasksLength; i++) {\n', '            taskIds.push(prev.taskIds(i));\n', '        }\n', '\n', '        _removeAllActiveTasksWithHoles(index, index + _size);\n', '    }\n', '\n', '    function endUpgrade() public {\n', '        super.endUpgrade();\n', '\n', '        if (upgradableState.nextVersion != 0) {\n', '            upgradableState.nextVersion.transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '    function payForTask(uint256 _taskId) public payable isLastestVersion {\n', '        if (msg.value > 0) {\n', '            Task storage task = allTasks[indexOfTaskId[_taskId].sub(1)];\n', '            require(task.answerPrivateKey == 0, "payForTask: you can\'t pay for the solved task");\n', '            task.reward = task.reward.add(msg.value);\n', '            totalReward = totalReward.add(msg.value);\n', '            emit TaskPayed(_taskId, msg.value);\n', '        }\n', '    }\n', '\n', '    function createBitcoinAddressPrefixTask(\n', '        bytes prefix,\n', '        uint256 requestPublicXPoint,\n', '        uint256 requestPublicYPoint,\n', '        address referrer\n', '    )\n', '        public\n', '        payable\n', '        isLastestVersion\n', '    {\n', '        require(prefix.length > 5);\n', '        require(prefix[0] == "1");\n', '        require(prefix[1] != "1"); // Do not support multiple 1s yet\n', '        require(isValidBicoinAddressPrefix(prefix));\n', '        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\n', '\n', '        bytes32 data;\n', '        assembly {\n', '            data := mload(add(prefix, 32))\n', '        }\n', '\n', '        uint256 taskId = nextTaskId++;\n', '        Task memory task = Task({\n', '            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\n', '            taskId: taskId,\n', '            creator: msg.sender,\n', '            referrer: referrer,\n', '            reward: 0,\n', '            data: data,\n', '            requestPublicXPoint: requestPublicXPoint,\n', '            requestPublicYPoint: requestPublicYPoint,\n', '            answerPrivateKey: 0\n', '        });\n', '\n', '        indexOfTaskId[taskId] = allTasks.push(task); // incremented to avoid 0 index\n', '        indexOfActiveTaskId[taskId] = taskIds.push(taskId);\n', '        emit TaskCreated(taskId);\n', '        payForTask(taskId);\n', '    }\n', '\n', '    function solveTask(uint _taskId, uint256 _answerPrivateKey, uint256 publicXPoint, uint256 publicYPoint) public isLastestVersion {\n', '        uint activeTaskIndex = indexOfTaskId[_taskId].sub(1);\n', '        Task storage task = allTasks[activeTaskIndex];\n', '        require(task.answerPrivateKey == 0, "solveTask: task is already solved");\n', '        \n', '        // Require private key to be part of address to prevent front-running attack\n', '        require(_answerPrivateKey >> 128 == uint256(msg.sender) >> 32, "solveTask: this solution does not match miner address");\n', '\n', '        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\n', '            ///(publicXPoint, publicYPoint) = ec.publicKey(_answerPrivateKey);\n', '            require(ec.publicKeyVerify(_answerPrivateKey, publicXPoint, publicYPoint));\n', '            (publicXPoint, publicYPoint) = ec.ecadd(\n', '                task.requestPublicXPoint,\n', '                task.requestPublicYPoint,\n', '                publicXPoint,\n', '                publicYPoint\n', '            );\n', '\n', '            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\n', '            require(haveCommonPrefixUntilZero(task.data, btcAddress), "solveTask: found prefix is not enough");\n', '\n', '            task.answerPrivateKey = _answerPrivateKey;\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        uint256 taskReard = task.reward;\n', '        uint256 serviceReward = taskReard.mul(serviceFee).div(MAX_PERCENT); // 1%\n', '        uint256 minerReward = taskReard - serviceReward; // 99%\n', '        if (serviceReward != 0 && task.referrer != 0) {\n', '            uint256 referrerReward = serviceReward.mul(referrerFee).div(MAX_PERCENT); // 50% of service reward\n', '            task.referrer.transfer(referrerReward);\n', '        }\n', '        msg.sender.transfer(minerReward);\n', '        totalReward -= taskReard;\n', '        \n', '        _completeTask(_taskId, activeTaskIndex);\n', '        emit TaskSolved(_taskId, minerReward);\n', '    }\n', '\n', '    function _completeTask(uint _taskId, uint _activeTaskIndex) internal {\n', '        indexOfCompletedTaskId[_taskId] = completedTaskIds.push(_taskId);\n', '        delete indexOfActiveTaskId[_taskId];\n', '\n', '        if (_activeTaskIndex + 1 < taskIds.length) { // if not latest\n', '            uint256 lastTaskId = taskIds[taskIds.length - 1];\n', '            taskIds[_activeTaskIndex] = lastTaskId;\n', '            indexOfActiveTaskId[lastTaskId] = _activeTaskIndex + 1;\n', '        }\n', '        taskIds.length -= 1;\n', '    }\n', '\n', '    function _removeAllActiveTasksWithHoles(uint _from, uint _to) internal {\n', '        for (uint i = _from; i < _to && i < taskIds.length; i++) {\n', '            uint taskId = taskIds[i];\n', '            uint index = indexOfTaskId[taskId].sub(1);\n', '            delete allTasks[index];\n', '            delete indexOfTaskId[taskId];\n', '            delete indexOfActiveTaskId[taskId];\n', '        }\n', '        if (_to >= taskIds.length) {\n', '            taskIds.length = 0;\n', '        }\n', '    }\n', '\n', '    function claim(ERC20Basic _token, address _to) public onlyOwner {\n', '        if (_token == address(0)) {\n', '            _to.transfer(address(this).balance - totalReward);\n', '        } else {\n', '            _token.transfer(_to, _token.balanceOf(this));\n', '        }\n', '    }\n', '\n', '}']
