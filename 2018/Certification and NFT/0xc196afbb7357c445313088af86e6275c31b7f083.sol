['pragma solidity ^0.4.23;\n', '\n', '/*********************************************************************************\n', ' *********************************************************************************\n', ' *\n', ' * Name of the project: JeiCoin Swapper\n', ' * Ethernity.live \n', ' *\n', ' *********************************************************************************\n', ' ********************************************************************************/\n', '\n', ' /* ERC20 contract interface */\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract TokenWithDates {\n', '    function getBatch(address _address , uint _batch) public constant returns(uint _quant,uint _age);\n', '    function getFirstBatch(address _address) public constant returns(uint _quant,uint _age);\n', '    function resetBatches(address _address);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\n', '    mapping(address => uint) public maxIndex; \n', '    mapping(address => uint) public minIndex;\n', '    uint8 public decimals;\n', '}\n', '\n', '// JeiCoin Swapper\n', '\n', 'contract JeiCoinSwapper {\n', '\n', '    string public version = "v1.5";\n', '    address public rootAddress;\n', '    address public Owner;\n', '    bool public locked;\n', '    address public tokenAdd;\n', '    address public tokenSpender;\n', '    TokenWithDates public token;\n', '    uint fortNight = 15;\n', '    mapping(address => uint) public lastFortnightPayed;\n', '    uint public initialDate;\n', '    uint[] public yearlyInterest;\n', '\n', '    // Modifiers\n', '\n', '    modifier onlyOwner() {\n', '        if ( msg.sender != rootAddress && msg.sender != Owner ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoot() {\n', '        if ( msg.sender != rootAddress ) revert();\n', '        _;\n', '    }\n', '\n', '    modifier isUnlocked() {\n', '    \trequire(!locked);\n', '\t\t_;    \t\n', '    }\n', '\n', '    // Events\n', '\n', '    event Batch(uint batchAmount , uint batchAge , uint totalAmount);\n', '    event Message(string message);\n', '\n', '\n', '    // Contract constructor\n', '    constructor() public {  \n', '        rootAddress = msg.sender;        \n', '        Owner = msg.sender;\n', '\n', '        // Addresses\n', '        tokenAdd = address(0x9da0D98c9d051c594038eb3267fBd0FAf3Da9e48);\n', '        tokenSpender = address(0xAd50cACa8cD726600840E745D0AE6B6E78861dBc);\n', '        token = TokenWithDates(tokenAdd);  \n', '\n', '        initialDate = now;\n', '\n', '        yearlyInterest.push(70); // Yearly interest for first year: 70%\n', '        yearlyInterest.push(50); // For second year: 50%\n', '        yearlyInterest.push(20); // And so on: 20%\n', '        yearlyInterest.push(10); // 10%\n', '    }\n', '\n', '\n', '    // Main function to pay interests\n', '    function payInterests() isUnlocked public {\n', '        if (fortnightsFromLast() == 0) { // Check for a fortnight passed\n', '            emit Message("0 fortnights passed");\n', '            return;\n', '        }\n', '        uint amountToPay = calculateInterest(msg.sender);\n', '        if (amountToPay == 0) {\n', '            emit Message("There are not 150 tokens with interests to pay");\n', '            return;\n', '            }\n', '        // Success\n', '        lastFortnightPayed[msg.sender] = now;\n', '        require(token.transferFrom(tokenSpender,msg.sender,amountToPay));\n', '    }\n', '\n', '    // Getters from token\n', '\n', '    function getBatch(address _address , uint _index) public view returns (uint _quant , uint _age) {\n', '        return (token.getBatch(_address,_index));\n', '    }\n', '\n', '    function getFirstBatch(address _address) public view returns (uint _quant , uint _age) {\n', '        return (token.getFirstBatch(_address));\n', '    }\n', '\n', '    // Private functions\n', '\n', '    // Calculates total interest to pay, by checking all batches. Called by main function\n', '    function calculateInterest(address _address) private returns (uint _amount) {\n', '        uint totalAmount = 0; // Total amount to pay\n', '        uint tokenCounted; // Valid tokens counted\n', '        uint intBatch; // interest for each batch in percentage\n', '        uint batchInterest; // Interests for each batch in absolute value\n', '        uint batchAmount;\n', '        uint batchDate;\n', '        for (uint i = token.minIndex(_address); i < token.maxIndex(_address); i++) {\n', '            ( batchAmount , batchDate) = token.getBatch(_address,i); // Get batch data\n', '            intBatch = interest(batchDate); // Calculate interest of this batch\n', '            batchInterest = batchAmount * intBatch / 1 ether / 100; // Apply interest to the batch amount\n', '            if (intBatch > 0) tokenCounted += batchAmount; // Count valid tokens (those with interests)\n', '            totalAmount += batchInterest; // Count total to pay\n', '            emit Batch(\n', '                batchAmount,\n', '                secToDays(softSub(now,batchDate)),\n', '                batchInterest\n', '                );\n', '        }\n', '        // Only pays if there are 150 valid tokens or more\n', '        if ( tokenCounted >= 150 ether ) return totalAmount; else return 0;\n', '    }\n', '\n', '    // Sub-function to calculate interest of each batch. Called by calculateInterest for each batch found\n', '    function interest(uint _batchDate) private view returns (uint _interest) {\n', '        uint _age = secToDays(softSub(now,_batchDate)); // Calculate age in days\n', '        while ( _age >= 106 ) { // If it has more than 3 months + 12 days + 3 (eligible to be paid again)\n', '            _age = _age - 103; // Rest every cycle of 91 + 12\n', '        }\n', '        if (_age < 3 ) return 0;\n', '        if (_age > 91) return 0;\n', '        // uint _months = _age / 30; \n', '        uint _tokenFortnights = _age / fortNight;\n', '        uint _fortnightsFromLast = fortnightsFromLast();\n', '        if ( _tokenFortnights > _fortnightsFromLast ) _tokenFortnights = _fortnightsFromLast;\n', '        uint yearsNow = secToDays(now - initialDate) / 365; // years from initial date\n', '        if (yearsNow > 3) yearsNow = 3;\n', '        _interest = 1 ether * yearlyInterest[yearsNow] * _tokenFortnights / 24 ; // Prorated interest to a fortnight, per each fortnight of token\n', '    }\n', '\n', '    function secToDays(uint _time) private pure returns(uint _days) {\n', '        return _time / 60 / 60 / 24; // Days\n', '        // return (_time / 60); // Minutes\n', '    }\n', '\n', '    function fortnightsFromLast() public view returns(uint _fortnights) {\n', '        // Fortnights from launching\n', '        _fortnights = secToDays(softSub(now,initialDate)) / fortNight;\n', '        // Fortnights since last payment (now from launching - last payment from launching)\n', '        _fortnights = softSub(_fortnights, secToDays(softSub(lastFortnightPayed[msg.sender],initialDate)) / fortNight);\n', '    }\n', '\n', '    // Safe math\n', '    function safeAdd(uint x, uint y) private pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    // Returns 0 if operation overflows\n', '    function softSub(uint x, uint y) private pure returns (uint z) {\n', '        z = x - y;\n', '        if (z > x ) z = 0;\n', '    }\n', '\n', '}']