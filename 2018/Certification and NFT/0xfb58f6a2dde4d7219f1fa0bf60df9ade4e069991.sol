['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/MintableERC20.sol\n', '\n', 'interface MintableERC20 {\n', '\n', '    function mint(address _to, uint256 _value) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' * See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * Supports unlimited numbers of roles and addresses.\n', ' * See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' * for you to write your own implementation of this interface using Enums or similar.\n', ' * It&#39;s also recommended that you define constants in the contract, like ROLE_ADMIN below,\n', ' * to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address indexed operator, string role);\n', '  event RoleRemoved(address indexed operator, string role);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address _operator, string _role)\n', '    view\n', '    public\n', '  {\n', '    roles[_role].check(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address _operator, string _role)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[_role].has(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function addRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].add(_operator);\n', '    emit RoleAdded(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function removeRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].remove(_operator);\n', '    emit RoleRemoved(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string _role)\n', '  {\n', '    checkRole(msg.sender, _role);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param _roles the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] _roles) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < _roles.length; i++) {\n', '  //         if (hasRole(msg.sender, _roles[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Whitelist.sol\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', '   * @dev Throws if operator is not whitelisted.\n', '   * @param _operator address\n', '   */\n', '  modifier onlyIfWhitelisted(address _operator) {\n', '    checkRole(_operator, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address _operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      addAddressToWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was removed from the whitelist,\n', '   * false if the address wasn&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressFromWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', '   * false if all addresses weren&#39;t in the whitelist in the first place\n', '   */\n', '  function removeAddressesFromWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      removeAddressFromWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/FanCrowdsale.sol\n', '\n', 'contract FanCrowdsale is Pausable {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // helper with wei\n', '  uint256 constant COIN = 1 ether;\n', '\n', '  // token\n', '  MintableERC20 public mintableToken;\n', '\n', '  // wallet to hold funds\n', '  address public wallet;\n', '\n', '  Whitelist public whitelist;\n', '\n', '  // Stage\n', '  // ============\n', '  struct Stage {\n', '    uint tokenAllocated;\n', '    uint rate;\n', '  }\n', '\n', '  uint8 public currentStage;\n', '  mapping (uint8 => Stage) public stages;\n', '  uint8 public totalStages; //stages count\n', '\n', '  // Amount raised\n', '  // ==================\n', '  uint256 public totalTokensSold;\n', '  uint256 public totalWeiRaised;\n', '\n', '  // timed\n', '  // ======\n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '\n', '  /**\n', '   * @dev Reverts if not in crowdsale time range.\n', '   */\n', '  modifier onlyWhileOpen {\n', '    require(block.timestamp >= openingTime && !hasClosed());\n', '    _;\n', '  }\n', '\n', '  // Token Cap\n', '  // =============================\n', '  uint256 public totalTokensForSale; // = 424000000 * COIN; // tokens be sold in Crowdsale\n', '\n', '  // Finalize\n', '  // =============================\n', '  bool public isFinalized = false;\n', '\n', '\n', '  // Constructor\n', '  // ============\n', '  /**\n', '   * @dev constructor\n', '   * @param _token token contract address\n', '   * @param _startTime start time of crowdscale\n', '   * @param _endTime end time of crowdsale\n', '   * @param _wallet foundation/multi-sig wallet to store raised eth\n', '   * @param _cap max eth to raise in wei\n', '   */\n', '  constructor(\n', '    address _token,\n', '    uint256 _startTime,\n', '    uint256 _endTime,\n', '    address _wallet,\n', '    uint256 _cap) public\n', '  {\n', '    require(_wallet != address(0), "need a good wallet to store fund");\n', '    require(_token != address(0), "token is not deployed?");\n', '    // require(_startTime > block.timestamp, "startTime must be in future");\n', '    require(_endTime > _startTime, "endTime must be greater than startTime");\n', '\n', '    // make sure this crowdsale contract has ability to mint or make sure token&#39;s mint authority has me\n', '    // yet fan token contract doesn&#39;t expose a public check func must manually make sure crowdsale contract address is added to authorities of token contract\n', '    mintableToken  = MintableERC20(_token);\n', '    wallet = _wallet;\n', '\n', '    openingTime = _startTime;\n', '    closingTime = _endTime;\n', '\n', '    totalTokensForSale  = _cap;\n', '\n', '    _initStages();\n', '    _setCrowdsaleStage(0);\n', '\n', '    // require that the sum of the stages is equal to the totalTokensForSale, _cap is for double check\n', '    require(stages[totalStages - 1].tokenAllocated == totalTokensForSale);\n', '    \n', '  }\n', '  // =============\n', '\n', '  // fallback\n', '  function () external payable {\n', '    purchase(msg.sender);\n', '  }\n', '\n', '  function purchase(address _buyer) public payable whenNotPaused onlyWhileOpen {\n', '    contribute(_buyer, msg.value);\n', '  }\n', '  \n', '  // Token Purchase\n', '  // =========================\n', '\n', '  /**\n', '   * @dev crowdsale must be open and we do not accept contribution sent from contract\n', '   * because we credit tokens back it might trigger problem, eg, from exchange withdraw contract\n', '   */\n', '  function contribute(address _buyer, uint256 _weiAmount) internal {\n', '    require(_buyer != address(0));\n', '    require(!_buyer.isContract());\n', '    require(whitelist.whitelist(_buyer));\n', '\n', '    if (_weiAmount == 0) {\n', '      return;\n', '    }\n', '\n', '    // double check not to over sell\n', '    require(totalTokensSold < totalTokensForSale);\n', '\n', '    uint currentRate = stages[currentStage].rate;\n', '    uint256 tokensToMint = _weiAmount.mul(currentRate);\n', '\n', '    // refund excess\n', '    uint256 saleableTokens;\n', '    uint256 acceptedWei;\n', '    if (currentStage == (totalStages - 1) && totalTokensSold.add(tokensToMint) > totalTokensForSale) {\n', '      saleableTokens = totalTokensForSale - totalTokensSold;\n', '      acceptedWei = saleableTokens.div(currentRate);\n', '\n', '      _buyTokensInCurrentStage(_buyer, acceptedWei, saleableTokens);\n', '\n', '      // return the excess\n', '      uint256 weiToRefund = _weiAmount.sub(acceptedWei);\n', '      _buyer.transfer(weiToRefund);\n', '      emit EthRefunded(_buyer, weiToRefund);\n', '    } else if (totalTokensSold.add(tokensToMint) < stages[currentStage].tokenAllocated) {\n', '      _buyTokensInCurrentStage(_buyer, _weiAmount, tokensToMint);\n', '    } else {\n', '      // cross stage yet within cap\n', '      saleableTokens = stages[currentStage].tokenAllocated.sub(totalTokensSold);\n', '      acceptedWei = saleableTokens.div(currentRate);\n', '\n', '      // buy first stage partial\n', '      _buyTokensInCurrentStage(_buyer, acceptedWei, saleableTokens);\n', '\n', '      // update stage\n', '      if (totalTokensSold >= stages[currentStage].tokenAllocated && currentStage + 1 < totalStages) {\n', '        _setCrowdsaleStage(currentStage + 1);\n', '      }\n', '\n', '      // buy next stage for the rest\n', '      if ( _weiAmount.sub(acceptedWei) > 0)\n', '      {\n', '        contribute(_buyer, _weiAmount.sub(acceptedWei));\n', '      }\n', '    }\n', '  }\n', '\n', '  function changeWhitelist(address _newWhitelist) public onlyOwner {\n', '    require(_newWhitelist != address(0));\n', '    emit WhitelistTransferred(whitelist, _newWhitelist);\n', '    whitelist = Whitelist(_newWhitelist);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n', '   * @return Whether crowdsale period has elapsed\n', '   */\n', '  function hasClosed() public view returns (bool) {\n', '    // solium-disable-next-line security/no-block-members\n', '    return block.timestamp > closingTime || totalTokensSold >= totalTokensForSale;\n', '  }\n', '\n', '  /**\n', '   * @dev extend closing time to a future time\n', '   */\n', '  function extendClosingTime(uint256 _extendToTime) public onlyOwner onlyWhileOpen {\n', '    closingTime = _extendToTime;\n', '  }\n', '\n', '  // ===========================\n', '\n', '  // Finalize Crowdsale\n', '  // ====================================================================\n', '\n', '  function finalize() public onlyOwner {\n', '    require(!isFinalized);\n', '    require(hasClosed());\n', '\n', '    emit Finalized();\n', '\n', '    isFinalized = true;\n', '  }\n', '\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  // Crowdsale Stage Management\n', '  // =========================================================\n', '  // Change Crowdsale Stage. Available Options: 0..4\n', '  function _setCrowdsaleStage(uint8 _stageId) internal {\n', '    require(_stageId >= 0 && _stageId < totalStages);\n', '\n', '    currentStage = _stageId;\n', '\n', '    emit StageUp(_stageId);\n', '  }\n', '\n', '  function _initStages() internal {\n', '    // production setting\n', '    stages[0] = Stage(25000000 * COIN, 12500);\n', '    stages[1] = Stage(stages[0].tokenAllocated + 46000000 * COIN, 11500);\n', '    stages[2] = Stage(stages[1].tokenAllocated + 88000000 * COIN, 11000);\n', '    stages[3] = Stage(stages[2].tokenAllocated + 105000000 * COIN, 10500);\n', '    stages[4] = Stage(stages[3].tokenAllocated + 160000000 * COIN, 10000);\n', '\n', '    // development setting\n', '    // 0.1 ETH allocation per stage for faster forward test\n', '    // stages[0] = Stage(1250 * COIN,                            12500);    // 1 Ether(wei) = 12500 Coin(wei)\n', '    // stages[1] = Stage(stages[0].tokenAllocated + 1150 * COIN, 11500);\n', '    // stages[2] = Stage(stages[1].tokenAllocated + 1100 * COIN, 11000);\n', '    // stages[3] = Stage(stages[2].tokenAllocated + 1050 * COIN, 10500);\n', '    // stages[4] = Stage(stages[3].tokenAllocated + 1000 * COIN, 10000);\n', '\n', '    totalStages = 5;\n', '  }\n', '\n', '  /**\n', '   * @dev perform buyTokens action for buyer\n', '   * @param _buyer Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _buyTokensInCurrentStage(address _buyer, uint _weiAmount, uint _tokenAmount) internal {\n', '    totalWeiRaised = totalWeiRaised.add(_weiAmount);\n', '    totalTokensSold = totalTokensSold.add(_tokenAmount);\n', '\n', '    // mint tokens to buyer&#39;s account\n', '    mintableToken.mint(_buyer, _tokenAmount);\n', '    wallet.transfer(_weiAmount);\n', '\n', '    emit TokenPurchase(_buyer, _weiAmount, _tokenAmount);\n', '  }\n', '\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) onlyOwner public {\n', '      if (_token == 0x0) {\n', '          owner.transfer(address(this).balance);\n', '          return;\n', '      }\n', '\n', '      ERC20 token = ERC20(_token);\n', '      uint balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '\n', '      emit ClaimedTokens(_token, owner, balance);\n', '  }\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '  event StageUp(uint8 stageId);\n', '\n', '  event EthRefunded(address indexed buyer, uint256 value);\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '\n', '  event WhitelistTransferred(address indexed previousWhitelist, address indexed newWhitelist);\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\n', '\n', '  event Finalized();\n', '\n', '  // debug log event\n', '  event DLog(uint num, string msg);\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: contracts/MintableERC20.sol\n', '\n', 'interface MintableERC20 {\n', '\n', '    function mint(address _to, uint256 _value) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/AddressUtils.sol\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library AddressUtils {\n', '\n', '  /**\n', '   * Returns whether the target address is a contract\n', '   * @dev This function will return false if invoked during the constructor of a contract,\n', '   * as the code is not actually created until after the constructor finishes.\n', '   * @param addr address to check\n', '   * @return whether the target address is a contract\n', '   */\n', '  function isContract(address addr) internal view returns (bool) {\n', '    uint256 size;\n', '    // XXX Currently there is no better way to check if there is a contract in an address\n', '    // than to check the size of the code at that address.\n', '    // See https://ethereum.stackexchange.com/a/14016/36603\n', '    // for more details about how this works.\n', '    // TODO Check this again before the Serenity release, because all addresses will be\n', '    // contracts then.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { size := extcodesize(addr) }\n', '    return size > 0;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @author Francisco Giordano (@frangio)\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' * See RBAC.sol for example usage.\n', ' */\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol\n', '\n', '/**\n', ' * @title RBAC (Role-Based Access Control)\n', ' * @author Matt Condon (@Shrugs)\n', ' * @dev Stores and provides setters and getters for roles and addresses.\n', ' * Supports unlimited numbers of roles and addresses.\n', ' * See //contracts/mocks/RBACMock.sol for an example of usage.\n', ' * This RBAC method uses strings to key roles. It may be beneficial\n', ' * for you to write your own implementation of this interface using Enums or similar.\n', " * It's also recommended that you define constants in the contract, like ROLE_ADMIN below,\n", ' * to avoid typos.\n', ' */\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address indexed operator, string role);\n', '  event RoleRemoved(address indexed operator, string role);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address _operator, string _role)\n', '    view\n', '    public\n', '  {\n', '    roles[_role].check(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address _operator, string _role)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[_role].has(_operator);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function addRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].add(_operator);\n', '    emit RoleAdded(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param _operator address\n', '   * @param _role the name of the role\n', '   */\n', '  function removeRole(address _operator, string _role)\n', '    internal\n', '  {\n', '    roles[_role].remove(_operator);\n', '    emit RoleRemoved(_operator, _role);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param _role the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string _role)\n', '  {\n', '    checkRole(msg.sender, _role);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param _roles the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] _roles) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < _roles.length; i++) {\n', '  //         if (hasRole(msg.sender, _roles[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Whitelist.sol\n', '\n', '/**\n', ' * @title Whitelist\n', ' * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n', ' * This simplifies the implementation of "user permissions".\n', ' */\n', 'contract Whitelist is Ownable, RBAC {\n', '  string public constant ROLE_WHITELISTED = "whitelist";\n', '\n', '  /**\n', '   * @dev Throws if operator is not whitelisted.\n', '   * @param _operator address\n', '   */\n', '  modifier onlyIfWhitelisted(address _operator) {\n', '    checkRole(_operator, ROLE_WHITELISTED);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n', '   */\n', '  function addAddressToWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    addRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in whitelist\n', '   */\n', '  function whitelist(address _operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev add addresses to the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was added to the whitelist,\n', '   * false if all addresses were already in the whitelist\n', '   */\n', '  function addAddressesToWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      addAddressToWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param _operator address\n', '   * @return true if the address was removed from the whitelist,\n', "   * false if the address wasn't in the whitelist in the first place\n", '   */\n', '  function removeAddressFromWhitelist(address _operator)\n', '    onlyOwner\n', '    public\n', '  {\n', '    removeRole(_operator, ROLE_WHITELISTED);\n', '  }\n', '\n', '  /**\n', '   * @dev remove addresses from the whitelist\n', '   * @param _operators addresses\n', '   * @return true if at least one address was removed from the whitelist,\n', "   * false if all addresses weren't in the whitelist in the first place\n", '   */\n', '  function removeAddressesFromWhitelist(address[] _operators)\n', '    onlyOwner\n', '    public\n', '  {\n', '    for (uint256 i = 0; i < _operators.length; i++) {\n', '      removeAddressFromWhitelist(_operators[i]);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/FanCrowdsale.sol\n', '\n', 'contract FanCrowdsale is Pausable {\n', '  using SafeMath for uint256;\n', '  using AddressUtils for address;\n', '\n', '  // helper with wei\n', '  uint256 constant COIN = 1 ether;\n', '\n', '  // token\n', '  MintableERC20 public mintableToken;\n', '\n', '  // wallet to hold funds\n', '  address public wallet;\n', '\n', '  Whitelist public whitelist;\n', '\n', '  // Stage\n', '  // ============\n', '  struct Stage {\n', '    uint tokenAllocated;\n', '    uint rate;\n', '  }\n', '\n', '  uint8 public currentStage;\n', '  mapping (uint8 => Stage) public stages;\n', '  uint8 public totalStages; //stages count\n', '\n', '  // Amount raised\n', '  // ==================\n', '  uint256 public totalTokensSold;\n', '  uint256 public totalWeiRaised;\n', '\n', '  // timed\n', '  // ======\n', '  uint256 public openingTime;\n', '  uint256 public closingTime;\n', '\n', '  /**\n', '   * @dev Reverts if not in crowdsale time range.\n', '   */\n', '  modifier onlyWhileOpen {\n', '    require(block.timestamp >= openingTime && !hasClosed());\n', '    _;\n', '  }\n', '\n', '  // Token Cap\n', '  // =============================\n', '  uint256 public totalTokensForSale; // = 424000000 * COIN; // tokens be sold in Crowdsale\n', '\n', '  // Finalize\n', '  // =============================\n', '  bool public isFinalized = false;\n', '\n', '\n', '  // Constructor\n', '  // ============\n', '  /**\n', '   * @dev constructor\n', '   * @param _token token contract address\n', '   * @param _startTime start time of crowdscale\n', '   * @param _endTime end time of crowdsale\n', '   * @param _wallet foundation/multi-sig wallet to store raised eth\n', '   * @param _cap max eth to raise in wei\n', '   */\n', '  constructor(\n', '    address _token,\n', '    uint256 _startTime,\n', '    uint256 _endTime,\n', '    address _wallet,\n', '    uint256 _cap) public\n', '  {\n', '    require(_wallet != address(0), "need a good wallet to store fund");\n', '    require(_token != address(0), "token is not deployed?");\n', '    // require(_startTime > block.timestamp, "startTime must be in future");\n', '    require(_endTime > _startTime, "endTime must be greater than startTime");\n', '\n', "    // make sure this crowdsale contract has ability to mint or make sure token's mint authority has me\n", "    // yet fan token contract doesn't expose a public check func must manually make sure crowdsale contract address is added to authorities of token contract\n", '    mintableToken  = MintableERC20(_token);\n', '    wallet = _wallet;\n', '\n', '    openingTime = _startTime;\n', '    closingTime = _endTime;\n', '\n', '    totalTokensForSale  = _cap;\n', '\n', '    _initStages();\n', '    _setCrowdsaleStage(0);\n', '\n', '    // require that the sum of the stages is equal to the totalTokensForSale, _cap is for double check\n', '    require(stages[totalStages - 1].tokenAllocated == totalTokensForSale);\n', '    \n', '  }\n', '  // =============\n', '\n', '  // fallback\n', '  function () external payable {\n', '    purchase(msg.sender);\n', '  }\n', '\n', '  function purchase(address _buyer) public payable whenNotPaused onlyWhileOpen {\n', '    contribute(_buyer, msg.value);\n', '  }\n', '  \n', '  // Token Purchase\n', '  // =========================\n', '\n', '  /**\n', '   * @dev crowdsale must be open and we do not accept contribution sent from contract\n', '   * because we credit tokens back it might trigger problem, eg, from exchange withdraw contract\n', '   */\n', '  function contribute(address _buyer, uint256 _weiAmount) internal {\n', '    require(_buyer != address(0));\n', '    require(!_buyer.isContract());\n', '    require(whitelist.whitelist(_buyer));\n', '\n', '    if (_weiAmount == 0) {\n', '      return;\n', '    }\n', '\n', '    // double check not to over sell\n', '    require(totalTokensSold < totalTokensForSale);\n', '\n', '    uint currentRate = stages[currentStage].rate;\n', '    uint256 tokensToMint = _weiAmount.mul(currentRate);\n', '\n', '    // refund excess\n', '    uint256 saleableTokens;\n', '    uint256 acceptedWei;\n', '    if (currentStage == (totalStages - 1) && totalTokensSold.add(tokensToMint) > totalTokensForSale) {\n', '      saleableTokens = totalTokensForSale - totalTokensSold;\n', '      acceptedWei = saleableTokens.div(currentRate);\n', '\n', '      _buyTokensInCurrentStage(_buyer, acceptedWei, saleableTokens);\n', '\n', '      // return the excess\n', '      uint256 weiToRefund = _weiAmount.sub(acceptedWei);\n', '      _buyer.transfer(weiToRefund);\n', '      emit EthRefunded(_buyer, weiToRefund);\n', '    } else if (totalTokensSold.add(tokensToMint) < stages[currentStage].tokenAllocated) {\n', '      _buyTokensInCurrentStage(_buyer, _weiAmount, tokensToMint);\n', '    } else {\n', '      // cross stage yet within cap\n', '      saleableTokens = stages[currentStage].tokenAllocated.sub(totalTokensSold);\n', '      acceptedWei = saleableTokens.div(currentRate);\n', '\n', '      // buy first stage partial\n', '      _buyTokensInCurrentStage(_buyer, acceptedWei, saleableTokens);\n', '\n', '      // update stage\n', '      if (totalTokensSold >= stages[currentStage].tokenAllocated && currentStage + 1 < totalStages) {\n', '        _setCrowdsaleStage(currentStage + 1);\n', '      }\n', '\n', '      // buy next stage for the rest\n', '      if ( _weiAmount.sub(acceptedWei) > 0)\n', '      {\n', '        contribute(_buyer, _weiAmount.sub(acceptedWei));\n', '      }\n', '    }\n', '  }\n', '\n', '  function changeWhitelist(address _newWhitelist) public onlyOwner {\n', '    require(_newWhitelist != address(0));\n', '    emit WhitelistTransferred(whitelist, _newWhitelist);\n', '    whitelist = Whitelist(_newWhitelist);\n', '  }\n', '\n', '  /**\n', '   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\n', '   * @return Whether crowdsale period has elapsed\n', '   */\n', '  function hasClosed() public view returns (bool) {\n', '    // solium-disable-next-line security/no-block-members\n', '    return block.timestamp > closingTime || totalTokensSold >= totalTokensForSale;\n', '  }\n', '\n', '  /**\n', '   * @dev extend closing time to a future time\n', '   */\n', '  function extendClosingTime(uint256 _extendToTime) public onlyOwner onlyWhileOpen {\n', '    closingTime = _extendToTime;\n', '  }\n', '\n', '  // ===========================\n', '\n', '  // Finalize Crowdsale\n', '  // ====================================================================\n', '\n', '  function finalize() public onlyOwner {\n', '    require(!isFinalized);\n', '    require(hasClosed());\n', '\n', '    emit Finalized();\n', '\n', '    isFinalized = true;\n', '  }\n', '\n', '\n', '  // -----------------------------------------\n', '  // Internal interface (extensible)\n', '  // -----------------------------------------\n', '\n', '  // Crowdsale Stage Management\n', '  // =========================================================\n', '  // Change Crowdsale Stage. Available Options: 0..4\n', '  function _setCrowdsaleStage(uint8 _stageId) internal {\n', '    require(_stageId >= 0 && _stageId < totalStages);\n', '\n', '    currentStage = _stageId;\n', '\n', '    emit StageUp(_stageId);\n', '  }\n', '\n', '  function _initStages() internal {\n', '    // production setting\n', '    stages[0] = Stage(25000000 * COIN, 12500);\n', '    stages[1] = Stage(stages[0].tokenAllocated + 46000000 * COIN, 11500);\n', '    stages[2] = Stage(stages[1].tokenAllocated + 88000000 * COIN, 11000);\n', '    stages[3] = Stage(stages[2].tokenAllocated + 105000000 * COIN, 10500);\n', '    stages[4] = Stage(stages[3].tokenAllocated + 160000000 * COIN, 10000);\n', '\n', '    // development setting\n', '    // 0.1 ETH allocation per stage for faster forward test\n', '    // stages[0] = Stage(1250 * COIN,                            12500);    // 1 Ether(wei) = 12500 Coin(wei)\n', '    // stages[1] = Stage(stages[0].tokenAllocated + 1150 * COIN, 11500);\n', '    // stages[2] = Stage(stages[1].tokenAllocated + 1100 * COIN, 11000);\n', '    // stages[3] = Stage(stages[2].tokenAllocated + 1050 * COIN, 10500);\n', '    // stages[4] = Stage(stages[3].tokenAllocated + 1000 * COIN, 10000);\n', '\n', '    totalStages = 5;\n', '  }\n', '\n', '  /**\n', '   * @dev perform buyTokens action for buyer\n', '   * @param _buyer Address performing the token purchase\n', '   * @param _weiAmount Value in wei involved in the purchase\n', '   */\n', '  function _buyTokensInCurrentStage(address _buyer, uint _weiAmount, uint _tokenAmount) internal {\n', '    totalWeiRaised = totalWeiRaised.add(_weiAmount);\n', '    totalTokensSold = totalTokensSold.add(_tokenAmount);\n', '\n', "    // mint tokens to buyer's account\n", '    mintableToken.mint(_buyer, _tokenAmount);\n', '    wallet.transfer(_weiAmount);\n', '\n', '    emit TokenPurchase(_buyer, _weiAmount, _tokenAmount);\n', '  }\n', '\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) onlyOwner public {\n', '      if (_token == 0x0) {\n', '          owner.transfer(address(this).balance);\n', '          return;\n', '      }\n', '\n', '      ERC20 token = ERC20(_token);\n', '      uint balance = token.balanceOf(this);\n', '      token.transfer(owner, balance);\n', '\n', '      emit ClaimedTokens(_token, owner, balance);\n', '  }\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '  event StageUp(uint8 stageId);\n', '\n', '  event EthRefunded(address indexed buyer, uint256 value);\n', '\n', '  event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n', '\n', '  event WhitelistTransferred(address indexed previousWhitelist, address indexed newWhitelist);\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\n', '\n', '  event Finalized();\n', '\n', '  // debug log event\n', '  event DLog(uint num, string msg);\n', '}']
