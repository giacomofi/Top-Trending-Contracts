['pragma solidity ^0.4.24;\n', '\n', 'interface itoken {\n', '    function freezeAccount(address _target, bool _freeze) external;\n', '    function freezeAccountPartialy(address _target, uint256 _value) external;\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    // function totalSupply() external view returns (uint256);\n', '    // function transferOwnership(address newOwner) external;\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function initialCongress(address _congress) external;\n', '    function mint(address _to, uint256 _amount) external returns (bool);\n', '    function finishMinting() external returns (bool);\n', '    function pause() external;\n', '    function unpause() external;\n', '}\n', '\n', 'library StringUtils {\n', '  /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n', '  /// @return a negative number if `_a` is smaller, zero if they are equal\n', '  /// and a positive numbe if `_b` is smaller.\n', '  function compare(string _a, string _b) public pure returns (int) {\n', '    bytes memory a = bytes(_a);\n', '    bytes memory b = bytes(_b);\n', '    uint minLength = a.length;\n', '    if (b.length < minLength) minLength = b.length;\n', '    //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n', '    for (uint i = 0; i < minLength; i ++)\n', '      if (a[i] < b[i])\n', '        return -1;\n', '      else if (a[i] > b[i])\n', '        return 1;\n', '    if (a.length < b.length)\n', '      return -1;\n', '    else if (a.length > b.length)\n', '      return 1;\n', '    else\n', '      return 0;\n', '  }\n', '  /// @dev Compares two strings and returns true iff they are equal.\n', '  function equal(string _a, string _b) public pure returns (bool) {\n', '    return compare(_a, _b) == 0;\n', '  }\n', '  /// @dev Finds the index of the first occurrence of _needle in _haystack\n', '  function indexOf(string _haystack, string _needle) public pure returns (int) {\n', '        bytes memory h = bytes(_haystack);\n', '        bytes memory n = bytes(_needle);\n', '        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n', '      return -1;\n', '    else if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn&#39;t found or input error), this function must return an "int" type with a max length of (2^128 - 1)\n', '      return -1;\n', '    else {\n', '      uint subindex = 0;\n', '      for (uint i = 0; i < h.length; i ++) {\n', '        if (h[i] == n[0]) { // found the first char of b\n', '          subindex = 1;\n', '          while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {// search until the chars don&#39;t match or until we reach the end of a or b\n', '                subindex++;\n', '          }\n', '          if(subindex == n.length)\n', '                return int(i);\n', '        }\n', '      }\n', '      return -1;\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract DelayedClaimable is Claimable {\n', '\n', '  uint256 public end;\n', '  uint256 public start;\n', '\n', '  /**\n', '   * @dev Used to specify the time period during which a pending\n', '   * owner can claim ownership.\n', '   * @param _start The earliest time ownership can be claimed.\n', '   * @param _end The latest time ownership can be claimed.\n', '   */\n', '  function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n', '    require(_start <= _end);\n', '    end = _end;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\n', '   * the specified start and end time.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    require((block.number <= end) && (block.number >= start));\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '    end = 0;\n', '  }\n', '\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract MultiOwners is DelayedClaimable, RBAC {\n', '  using SafeMath for uint256;\n', '  using StringUtils for string;\n', '\n', '  mapping (string => uint256) private authorizations;\n', '  mapping (address => string) private ownerOfSides;\n', '//   mapping (string => mapping (string => bool)) private voteResults;\n', '  mapping (string => uint256) private sideExist;\n', '  mapping (string => mapping (string => address[])) private sideVoters;\n', '  address[] public owners;\n', '  string[] private authTypes;\n', '//   string[] private ownerSides;\n', '  uint256 public multiOwnerSides;\n', '  uint256 ownerSidesLimit = 5;\n', '//   uint256 authRate = 75;\n', '  bool initAdd = true;\n', '\n', '  event OwnerAdded(address addr, string side);\n', '  event OwnerRemoved(address addr);\n', '  event InitialFinished();\n', '\n', '  string public constant ROLE_MULTIOWNER = "multiOwner";\n', '  string public constant AUTH_ADDOWNER = "addOwner";\n', '  string public constant AUTH_REMOVEOWNER = "removeOwner";\n', '//   string public constant AUTH_SETAUTHRATE = "setAuthRate";\n', '\n', '  /**\n', '   * @dev Throws if called by any account that&#39;s not multiOwners.\n', '   */\n', '  modifier onlyMultiOwners() {\n', '    checkRole(msg.sender, ROLE_MULTIOWNER);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if not in initializing stage.\n', '   */\n', '  modifier canInitial() {\n', '    require(initAdd);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev the msg.sender will authorize a type of event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function authorize(string _authType) onlyMultiOwners public {\n', '    string memory side = ownerOfSides[msg.sender];\n', '    address[] storage voters = sideVoters[side][_authType];\n', '\n', '    if (voters.length == 0) {\n', '      // if the first time to authorize this type of event\n', '      authorizations[_authType] = authorizations[_authType].add(1);\n', '    //   voteResults[side][_authType] = true;\n', '    }\n', '\n', '    // add voters of one side\n', '    uint j = 0;\n', '    for (; j < voters.length; j = j.add(1)) {\n', '      if (voters[j] == msg.sender) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (j >= voters.length) {\n', '      voters.push(msg.sender);\n', '    }\n', '\n', '    // add the authType for clearing auth\n', '    uint i = 0;\n', '    for (; i < authTypes.length; i = i.add(1)) {\n', '      if (authTypes[i].equal(_authType)) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (i >= authTypes.length) {\n', '      authTypes.push(_authType);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev the msg.sender will clear the authorization he has given for the event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function deAuthorize(string _authType) onlyMultiOwners public {\n', '    string memory side = ownerOfSides[msg.sender];\n', '    address[] storage voters = sideVoters[side][_authType];\n', '\n', '    for (uint j = 0; j < voters.length; j = j.add(1)) {\n', '      if (voters[j] == msg.sender) {\n', '        delete voters[j];\n', '        break;\n', '      }\n', '    }\n', '\n', '    // if the sender has authorized this type of event, will remove its vote\n', '    if (j < voters.length) {\n', '      for (uint jj = j; jj < voters.length.sub(1); jj = jj.add(1)) {\n', '        voters[jj] = voters[jj.add(1)];\n', '      }\n', '\n', '      delete voters[voters.length.sub(1)];\n', '      voters.length = voters.length.sub(1);\n', '\n', '      // if there is no votes of one side, the authorization need to be decreased\n', '      if (voters.length == 0) {\n', '        authorizations[_authType] = authorizations[_authType].sub(1);\n', '      //   voteResults[side][_authType] = true;\n', '      }\n', '\n', '      // if there is no authorization on this type of event,\n', '      // this event need to be removed from the list\n', '      if (authorizations[_authType] == 0) {\n', '        for (uint i = 0; i < authTypes.length; i = i.add(1)) {\n', '          if (authTypes[i].equal(_authType)) {\n', '            delete authTypes[i];\n', '            break;\n', '          }\n', '        }\n', '        for (uint ii = i; ii < authTypes.length.sub(1); ii = ii.add(1)) {\n', '          authTypes[ii] = authTypes[ii.add(1)];\n', '        }\n', '\n', '        delete authTypes[authTypes.length.sub(1)];\n', '        authTypes.length = authTypes.length.sub(1);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev judge if the event has already been authorized.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function hasAuth(string _authType) public view returns (bool) {\n', '    require(multiOwnerSides > 1); // at least 2 sides have authorized\n', '\n', '    // uint256 rate = authorizations[_authType].mul(100).div(multiOwnerNumber)\n', '    return (authorizations[_authType] == multiOwnerSides);\n', '  }\n', '\n', '  /**\n', '   * @dev clear all the authorizations that have been given for a type of event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function clearAuth(string _authType) internal {\n', '    authorizations[_authType] = 0; // clear authorizations\n', '    for (uint i = 0; i < owners.length; i = i.add(1)) {\n', '      string memory side = ownerOfSides[owners[i]];\n', '      address[] storage voters = sideVoters[side][_authType];\n', '      for (uint j = 0; j < voters.length; j = j.add(1)) {\n', '        delete voters[j]; // clear votes of one side\n', '      }\n', '      voters.length = 0;\n', '    }\n', '\n', '    // clear this type of event\n', '    for (uint k = 0; k < authTypes.length; k = k.add(1)) {\n', '      if (authTypes[k].equal(_authType)) {\n', '        delete authTypes[k];\n', '        break;\n', '      }\n', '    }\n', '    for (uint kk = k; kk < authTypes.length.sub(1); kk = kk.add(1)) {\n', '      authTypes[kk] = authTypes[kk.add(1)];\n', '    }\n', '\n', '    delete authTypes[authTypes.length.sub(1)];\n', '    authTypes.length = authTypes.length.sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev add an address as one of the multiOwners.\n', '   * @param _addr the account address used as a multiOwner\n', '   */\n', '  function addAddress(address _addr, string _side) internal {\n', '    require(multiOwnerSides < ownerSidesLimit);\n', '    require(_addr != address(0));\n', '    require(ownerOfSides[_addr].equal("")); // not allow duplicated adding\n', '\n', '    // uint i = 0;\n', '    // for (; i < owners.length; i = i.add(1)) {\n', '    //   if (owners[i] == _addr) {\n', '    //     break;\n', '    //   }\n', '    // }\n', '\n', '    // if (i >= owners.length) {\n', '    owners.push(_addr); // for not allowing duplicated adding, so each addr should be new\n', '\n', '    addRole(_addr, ROLE_MULTIOWNER);\n', '    ownerOfSides[_addr] = _side;\n', '    // }\n', '\n', '    if (sideExist[_side] == 0) {\n', '      multiOwnerSides = multiOwnerSides.add(1);\n', '    }\n', '\n', '    sideExist[_side] = sideExist[_side].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _addr address will be one of the multiOwner\n', '   * @param _side the side name of the multiOwner\n', '   * @return true if the address was added to the multiOwners list,\n', '   *         false if the address was already in the multiOwners list\n', '   */\n', '  function initAddressAsMultiOwner(address _addr, string _side)\n', '    onlyOwner\n', '    canInitial\n', '    public\n', '  {\n', '    // require(initAdd);\n', '    addAddress(_addr, _side);\n', '\n', '    // initAdd = false;\n', '    emit OwnerAdded(_addr, _side);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop initial stage.\n', '   */\n', '  function finishInitOwners() onlyOwner canInitial public {\n', '    initAdd = false;\n', '    emit InitialFinished();\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _addr address\n', '   * @param _side the side name of the multiOwner\n', '   * @return true if the address was added to the multiOwners list,\n', '   *         false if the address was already in the multiOwners list\n', '   */\n', '  function addAddressAsMultiOwner(address _addr, string _side)\n', '    onlyMultiOwners\n', '    public\n', '  {\n', '    require(hasAuth(AUTH_ADDOWNER));\n', '\n', '    addAddress(_addr, _side);\n', '\n', '    clearAuth(AUTH_ADDOWNER);\n', '    emit OwnerAdded(_addr, _side);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in multiOwner list\n', '   */\n', '  function isMultiOwner(address _addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(_addr, ROLE_MULTIOWNER);\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param _addr address\n', '   * @return true if the address was removed from the multiOwner list,\n', '   *         false if the address wasn&#39;t in the multiOwner list\n', '   */\n', '  function removeAddressFromOwners(address _addr)\n', '    onlyMultiOwners\n', '    public\n', '  {\n', '    require(hasAuth(AUTH_REMOVEOWNER));\n', '\n', '    removeRole(_addr, ROLE_MULTIOWNER);\n', '\n', '    // first remove the owner\n', '    uint j = 0;\n', '    for (; j < owners.length; j = j.add(1)) {\n', '      if (owners[j] == _addr) {\n', '        delete owners[j];\n', '        break;\n', '      }\n', '    }\n', '    if (j < owners.length) {\n', '      for (uint jj = j; jj < owners.length.sub(1); jj = jj.add(1)) {\n', '        owners[jj] = owners[jj.add(1)];\n', '      }\n', '\n', '      delete owners[owners.length.sub(1)];\n', '      owners.length = owners.length.sub(1);\n', '    }\n', '\n', '    string memory side = ownerOfSides[_addr];\n', '    // if (sideExist[side] > 0) {\n', '    sideExist[side] = sideExist[side].sub(1);\n', '    if (sideExist[side] == 0) {\n', '      require(multiOwnerSides > 2); // not allow only left 1 side\n', '      multiOwnerSides = multiOwnerSides.sub(1); // this side has been removed\n', '    }\n', '\n', '    // for every event type, if this owner has voted the event, then need to remove\n', '    for (uint i = 0; i < authTypes.length; ) {\n', '      address[] storage voters = sideVoters[side][authTypes[i]];\n', '      for (uint m = 0; m < voters.length; m = m.add(1)) {\n', '        if (voters[m] == _addr) {\n', '          delete voters[m];\n', '          break;\n', '        }\n', '      }\n', '      if (m < voters.length) {\n', '        for (uint n = m; n < voters.length.sub(1); n = n.add(1)) {\n', '          voters[n] = voters[n.add(1)];\n', '        }\n', '\n', '        delete voters[voters.length.sub(1)];\n', '        voters.length = voters.length.sub(1);\n', '\n', '        // if this side only have this 1 voter, the authorization of this event need to be decreased\n', '        if (voters.length == 0) {\n', '          authorizations[authTypes[i]] = authorizations[authTypes[i]].sub(1);\n', '        }\n', '\n', '        // if there is no authorization of this event, the event need to be removed\n', '        if (authorizations[authTypes[i]] == 0) {\n', '          delete authTypes[i];\n', '\n', '          for (uint kk = i; kk < authTypes.length.sub(1); kk = kk.add(1)) {\n', '            authTypes[kk] = authTypes[kk.add(1)];\n', '          }\n', '\n', '          delete authTypes[authTypes.length.sub(1)];\n', '          authTypes.length = authTypes.length.sub(1);\n', '        } else {\n', '          i = i.add(1);\n', '        }\n', '      } else {\n', '        i = i.add(1);\n', '      }\n', '    }\n', '//   }\n', '\n', '    delete ownerOfSides[_addr];\n', '\n', '    clearAuth(AUTH_REMOVEOWNER);\n', '    emit OwnerRemoved(_addr);\n', '  }\n', '\n', '}\n', '\n', 'contract MultiOwnerContract is MultiOwners {\n', '    Claimable public ownedContract;\n', '    address public pendingOwnedOwner;\n', '    // address internal origOwner;\n', '\n', '    string public constant AUTH_CHANGEOWNEDOWNER = "transferOwnerOfOwnedContract";\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingOwner.\n', '     */\n', '    // modifier onlyPendingOwnedOwner() {\n', '    //     require(msg.sender == pendingOwnedOwner);\n', '    //     _;\n', '    // }\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        // origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        ownedContract.claimOwnership();\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one.\n', '     *\n', '     */\n', '    // function transferOwnershipBack() onlyOwner public {\n', '    //     ownedContract.transferOwnership(origOwner);\n', '    //     ownedContract = Claimable(address(0));\n', '    //     origOwner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnedOwnershipto(address _nextOwner) onlyMultiOwners public {\n', '        require(ownedContract != address(0));\n', '        require(hasAuth(AUTH_CHANGEOWNEDOWNER));\n', '\n', '        if (ownedContract.owner() != pendingOwnedOwner) {\n', '            ownedContract.transferOwnership(_nextOwner);\n', '            pendingOwnedOwner = _nextOwner;\n', '            // ownedContract = Claimable(address(0));\n', '            // origOwner = address(0);\n', '        } else {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '        }\n', '\n', '        clearAuth(AUTH_CHANGEOWNEDOWNER);\n', '    }\n', '\n', '    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\n', '        require(ownedContract != address(0));\n', '        if (ownedContract.owner() == pendingOwnedOwner) {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract DRCTOwner is MultiOwnerContract {\n', '    string public constant AUTH_INITCONGRESS = "initCongress";\n', '    string public constant AUTH_CANMINT = "canMint";\n', '    string public constant AUTH_SETMINTAMOUNT = "setMintAmount";\n', '    string public constant AUTH_FREEZEACCOUNT = "freezeAccount";\n', '\n', '    bool congressInit = false;\n', '    // bool paramsInit = false;\n', '    // iParams public params;\n', '    uint256 onceMintAmount;\n', '\n', '\n', '    // function initParams(address _params) onlyOwner public {\n', '    //     require(!paramsInit);\n', '    //     require(_params != address(0));\n', '\n', '    //     params = _params;\n', '    //     paramsInit = false;\n', '    // }\n', '\n', '    /**\n', '     * @dev Function to set mint token amount\n', '     * @param _value The mint value.\n', '     */\n', '    function setOnceMintAmount(uint256 _value) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_SETMINTAMOUNT));\n', '        require(_value > 0);\n', '        onceMintAmount = _value;\n', '\n', '        clearAuth(AUTH_SETMINTAMOUNT);\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _congress the contract address that will be next Owner of the original Contract\n', '     */\n', '    function initCongress(address _congress) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_INITCONGRESS));\n', '        require(!congressInit);\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.initialCongress(_congress);\n', '\n', '        clearAuth(AUTH_INITCONGRESS);\n', '        congressInit = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to) onlyMultiOwners public returns (bool) {\n', '        require(hasAuth(AUTH_CANMINT));\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        bool res = tk.mint(_to, onceMintAmount);\n', '\n', '        clearAuth(AUTH_CANMINT);\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() onlyMultiOwners public returns (bool) {\n', '        require(hasAuth(AUTH_CANMINT));\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        bool res = tk.finishMinting();\n', '\n', '        clearAuth(AUTH_CANMINT);\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev freeze the account&#39;s balance under urgent situation\n', '     *\n', '     * by default all the accounts will not be frozen until set freeze value as true.\n', '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _freeze bool if true, the account will be frozen\n', '     */\n', '    function freezeAccountDirect(address _target, bool _freeze) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_FREEZEACCOUNT));\n', '\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.freezeAccount(_target, _freeze);\n', '\n', '        clearAuth(AUTH_FREEZEACCOUNT);\n', '    }\n', '\n', '    /**\n', '     * @dev freeze the account&#39;s balance\n', '     *\n', '     * by default all the accounts will not be frozen until set freeze value as true.\n', '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _freeze bool if true, the account will be frozen\n', '     */\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        if (_freeze) {\n', '            require(tk.allowance(_target, this) == tk.balanceOf(_target));\n', '        }\n', '\n', '        tk.freezeAccount(_target, _freeze);\n', '    }\n', '\n', '    /**\n', '     * @dev freeze the account&#39;s balance\n', '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _value uint256 the amount of tokens that will be frozen\n', '     */\n', '    function freezeAccountPartialy(address _target, uint256 _value) onlyOwner public {\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        require(tk.allowance(_target, this) == _value);\n', '\n', '        tk.freezeAccountPartialy(_target, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner public {\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner public {\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.unpause();\n', '    }\n', '\n', '}\n', '\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address&#39; access to this role\n', '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'interface itoken {\n', '    function freezeAccount(address _target, bool _freeze) external;\n', '    function freezeAccountPartialy(address _target, uint256 _value) external;\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    // function totalSupply() external view returns (uint256);\n', '    // function transferOwnership(address newOwner) external;\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function initialCongress(address _congress) external;\n', '    function mint(address _to, uint256 _amount) external returns (bool);\n', '    function finishMinting() external returns (bool);\n', '    function pause() external;\n', '    function unpause() external;\n', '}\n', '\n', 'library StringUtils {\n', '  /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n', '  /// @return a negative number if `_a` is smaller, zero if they are equal\n', '  /// and a positive numbe if `_b` is smaller.\n', '  function compare(string _a, string _b) public pure returns (int) {\n', '    bytes memory a = bytes(_a);\n', '    bytes memory b = bytes(_b);\n', '    uint minLength = a.length;\n', '    if (b.length < minLength) minLength = b.length;\n', '    //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n', '    for (uint i = 0; i < minLength; i ++)\n', '      if (a[i] < b[i])\n', '        return -1;\n', '      else if (a[i] > b[i])\n', '        return 1;\n', '    if (a.length < b.length)\n', '      return -1;\n', '    else if (a.length > b.length)\n', '      return 1;\n', '    else\n', '      return 0;\n', '  }\n', '  /// @dev Compares two strings and returns true iff they are equal.\n', '  function equal(string _a, string _b) public pure returns (bool) {\n', '    return compare(_a, _b) == 0;\n', '  }\n', '  /// @dev Finds the index of the first occurrence of _needle in _haystack\n', '  function indexOf(string _haystack, string _needle) public pure returns (int) {\n', '        bytes memory h = bytes(_haystack);\n', '        bytes memory n = bytes(_needle);\n', '        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n', '      return -1;\n', '    else if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn\'t found or input error), this function must return an "int" type with a max length of (2^128 - 1)\n', '      return -1;\n', '    else {\n', '      uint subindex = 0;\n', '      for (uint i = 0; i < h.length; i ++) {\n', '        if (h[i] == n[0]) { // found the first char of b\n', '          subindex = 1;\n', "          while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {// search until the chars don't match or until we reach the end of a or b\n", '                subindex++;\n', '          }\n', '          if(subindex == n.length)\n', '                return int(i);\n', '        }\n', '      }\n', '      return -1;\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract DelayedClaimable is Claimable {\n', '\n', '  uint256 public end;\n', '  uint256 public start;\n', '\n', '  /**\n', '   * @dev Used to specify the time period during which a pending\n', '   * owner can claim ownership.\n', '   * @param _start The earliest time ownership can be claimed.\n', '   * @param _end The latest time ownership can be claimed.\n', '   */\n', '  function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n', '    require(_start <= _end);\n', '    end = _end;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\n', '   * the specified start and end time.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    require((block.number <= end) && (block.number >= start));\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '    end = 0;\n', '  }\n', '\n', '}\n', '\n', 'contract RBAC {\n', '  using Roles for Roles.Role;\n', '\n', '  mapping (string => Roles.Role) private roles;\n', '\n', '  event RoleAdded(address addr, string roleName);\n', '  event RoleRemoved(address addr, string roleName);\n', '\n', '  /**\n', '   * @dev reverts if addr does not have role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  function checkRole(address addr, string roleName)\n', '    view\n', '    public\n', '  {\n', '    roles[roleName].check(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev determine if addr has role\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   * @return bool\n', '   */\n', '  function hasRole(address addr, string roleName)\n', '    view\n', '    public\n', '    returns (bool)\n', '  {\n', '    return roles[roleName].has(addr);\n', '  }\n', '\n', '  /**\n', '   * @dev add a role to an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function addRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].add(addr);\n', '    emit RoleAdded(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev remove a role from an address\n', '   * @param addr address\n', '   * @param roleName the name of the role\n', '   */\n', '  function removeRole(address addr, string roleName)\n', '    internal\n', '  {\n', '    roles[roleName].remove(addr);\n', '    emit RoleRemoved(addr, roleName);\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n', '   * @param roleName the name of the role\n', '   * // reverts\n', '   */\n', '  modifier onlyRole(string roleName)\n', '  {\n', '    checkRole(msg.sender, roleName);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\n', '   * @param roleNames the names of the roles to scope access to\n', '   * // reverts\n', '   *\n', '   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\n', '   *  see: https://github.com/ethereum/solidity/issues/2467\n', '   */\n', '  // modifier onlyRoles(string[] roleNames) {\n', '  //     bool hasAnyRole = false;\n', '  //     for (uint8 i = 0; i < roleNames.length; i++) {\n', '  //         if (hasRole(msg.sender, roleNames[i])) {\n', '  //             hasAnyRole = true;\n', '  //             break;\n', '  //         }\n', '  //     }\n', '\n', '  //     require(hasAnyRole);\n', '\n', '  //     _;\n', '  // }\n', '}\n', '\n', 'contract MultiOwners is DelayedClaimable, RBAC {\n', '  using SafeMath for uint256;\n', '  using StringUtils for string;\n', '\n', '  mapping (string => uint256) private authorizations;\n', '  mapping (address => string) private ownerOfSides;\n', '//   mapping (string => mapping (string => bool)) private voteResults;\n', '  mapping (string => uint256) private sideExist;\n', '  mapping (string => mapping (string => address[])) private sideVoters;\n', '  address[] public owners;\n', '  string[] private authTypes;\n', '//   string[] private ownerSides;\n', '  uint256 public multiOwnerSides;\n', '  uint256 ownerSidesLimit = 5;\n', '//   uint256 authRate = 75;\n', '  bool initAdd = true;\n', '\n', '  event OwnerAdded(address addr, string side);\n', '  event OwnerRemoved(address addr);\n', '  event InitialFinished();\n', '\n', '  string public constant ROLE_MULTIOWNER = "multiOwner";\n', '  string public constant AUTH_ADDOWNER = "addOwner";\n', '  string public constant AUTH_REMOVEOWNER = "removeOwner";\n', '//   string public constant AUTH_SETAUTHRATE = "setAuthRate";\n', '\n', '  /**\n', "   * @dev Throws if called by any account that's not multiOwners.\n", '   */\n', '  modifier onlyMultiOwners() {\n', '    checkRole(msg.sender, ROLE_MULTIOWNER);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if not in initializing stage.\n', '   */\n', '  modifier canInitial() {\n', '    require(initAdd);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev the msg.sender will authorize a type of event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function authorize(string _authType) onlyMultiOwners public {\n', '    string memory side = ownerOfSides[msg.sender];\n', '    address[] storage voters = sideVoters[side][_authType];\n', '\n', '    if (voters.length == 0) {\n', '      // if the first time to authorize this type of event\n', '      authorizations[_authType] = authorizations[_authType].add(1);\n', '    //   voteResults[side][_authType] = true;\n', '    }\n', '\n', '    // add voters of one side\n', '    uint j = 0;\n', '    for (; j < voters.length; j = j.add(1)) {\n', '      if (voters[j] == msg.sender) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (j >= voters.length) {\n', '      voters.push(msg.sender);\n', '    }\n', '\n', '    // add the authType for clearing auth\n', '    uint i = 0;\n', '    for (; i < authTypes.length; i = i.add(1)) {\n', '      if (authTypes[i].equal(_authType)) {\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (i >= authTypes.length) {\n', '      authTypes.push(_authType);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev the msg.sender will clear the authorization he has given for the event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function deAuthorize(string _authType) onlyMultiOwners public {\n', '    string memory side = ownerOfSides[msg.sender];\n', '    address[] storage voters = sideVoters[side][_authType];\n', '\n', '    for (uint j = 0; j < voters.length; j = j.add(1)) {\n', '      if (voters[j] == msg.sender) {\n', '        delete voters[j];\n', '        break;\n', '      }\n', '    }\n', '\n', '    // if the sender has authorized this type of event, will remove its vote\n', '    if (j < voters.length) {\n', '      for (uint jj = j; jj < voters.length.sub(1); jj = jj.add(1)) {\n', '        voters[jj] = voters[jj.add(1)];\n', '      }\n', '\n', '      delete voters[voters.length.sub(1)];\n', '      voters.length = voters.length.sub(1);\n', '\n', '      // if there is no votes of one side, the authorization need to be decreased\n', '      if (voters.length == 0) {\n', '        authorizations[_authType] = authorizations[_authType].sub(1);\n', '      //   voteResults[side][_authType] = true;\n', '      }\n', '\n', '      // if there is no authorization on this type of event,\n', '      // this event need to be removed from the list\n', '      if (authorizations[_authType] == 0) {\n', '        for (uint i = 0; i < authTypes.length; i = i.add(1)) {\n', '          if (authTypes[i].equal(_authType)) {\n', '            delete authTypes[i];\n', '            break;\n', '          }\n', '        }\n', '        for (uint ii = i; ii < authTypes.length.sub(1); ii = ii.add(1)) {\n', '          authTypes[ii] = authTypes[ii.add(1)];\n', '        }\n', '\n', '        delete authTypes[authTypes.length.sub(1)];\n', '        authTypes.length = authTypes.length.sub(1);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev judge if the event has already been authorized.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function hasAuth(string _authType) public view returns (bool) {\n', '    require(multiOwnerSides > 1); // at least 2 sides have authorized\n', '\n', '    // uint256 rate = authorizations[_authType].mul(100).div(multiOwnerNumber)\n', '    return (authorizations[_authType] == multiOwnerSides);\n', '  }\n', '\n', '  /**\n', '   * @dev clear all the authorizations that have been given for a type of event.\n', '   * @param _authType the event type need to be authorized\n', '   */\n', '  function clearAuth(string _authType) internal {\n', '    authorizations[_authType] = 0; // clear authorizations\n', '    for (uint i = 0; i < owners.length; i = i.add(1)) {\n', '      string memory side = ownerOfSides[owners[i]];\n', '      address[] storage voters = sideVoters[side][_authType];\n', '      for (uint j = 0; j < voters.length; j = j.add(1)) {\n', '        delete voters[j]; // clear votes of one side\n', '      }\n', '      voters.length = 0;\n', '    }\n', '\n', '    // clear this type of event\n', '    for (uint k = 0; k < authTypes.length; k = k.add(1)) {\n', '      if (authTypes[k].equal(_authType)) {\n', '        delete authTypes[k];\n', '        break;\n', '      }\n', '    }\n', '    for (uint kk = k; kk < authTypes.length.sub(1); kk = kk.add(1)) {\n', '      authTypes[kk] = authTypes[kk.add(1)];\n', '    }\n', '\n', '    delete authTypes[authTypes.length.sub(1)];\n', '    authTypes.length = authTypes.length.sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev add an address as one of the multiOwners.\n', '   * @param _addr the account address used as a multiOwner\n', '   */\n', '  function addAddress(address _addr, string _side) internal {\n', '    require(multiOwnerSides < ownerSidesLimit);\n', '    require(_addr != address(0));\n', '    require(ownerOfSides[_addr].equal("")); // not allow duplicated adding\n', '\n', '    // uint i = 0;\n', '    // for (; i < owners.length; i = i.add(1)) {\n', '    //   if (owners[i] == _addr) {\n', '    //     break;\n', '    //   }\n', '    // }\n', '\n', '    // if (i >= owners.length) {\n', '    owners.push(_addr); // for not allowing duplicated adding, so each addr should be new\n', '\n', '    addRole(_addr, ROLE_MULTIOWNER);\n', '    ownerOfSides[_addr] = _side;\n', '    // }\n', '\n', '    if (sideExist[_side] == 0) {\n', '      multiOwnerSides = multiOwnerSides.add(1);\n', '    }\n', '\n', '    sideExist[_side] = sideExist[_side].add(1);\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _addr address will be one of the multiOwner\n', '   * @param _side the side name of the multiOwner\n', '   * @return true if the address was added to the multiOwners list,\n', '   *         false if the address was already in the multiOwners list\n', '   */\n', '  function initAddressAsMultiOwner(address _addr, string _side)\n', '    onlyOwner\n', '    canInitial\n', '    public\n', '  {\n', '    // require(initAdd);\n', '    addAddress(_addr, _side);\n', '\n', '    // initAdd = false;\n', '    emit OwnerAdded(_addr, _side);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop initial stage.\n', '   */\n', '  function finishInitOwners() onlyOwner canInitial public {\n', '    initAdd = false;\n', '    emit InitialFinished();\n', '  }\n', '\n', '  /**\n', '   * @dev add an address to the whitelist\n', '   * @param _addr address\n', '   * @param _side the side name of the multiOwner\n', '   * @return true if the address was added to the multiOwners list,\n', '   *         false if the address was already in the multiOwners list\n', '   */\n', '  function addAddressAsMultiOwner(address _addr, string _side)\n', '    onlyMultiOwners\n', '    public\n', '  {\n', '    require(hasAuth(AUTH_ADDOWNER));\n', '\n', '    addAddress(_addr, _side);\n', '\n', '    clearAuth(AUTH_ADDOWNER);\n', '    emit OwnerAdded(_addr, _side);\n', '  }\n', '\n', '  /**\n', '   * @dev getter to determine if address is in multiOwner list\n', '   */\n', '  function isMultiOwner(address _addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return hasRole(_addr, ROLE_MULTIOWNER);\n', '  }\n', '\n', '  /**\n', '   * @dev remove an address from the whitelist\n', '   * @param _addr address\n', '   * @return true if the address was removed from the multiOwner list,\n', "   *         false if the address wasn't in the multiOwner list\n", '   */\n', '  function removeAddressFromOwners(address _addr)\n', '    onlyMultiOwners\n', '    public\n', '  {\n', '    require(hasAuth(AUTH_REMOVEOWNER));\n', '\n', '    removeRole(_addr, ROLE_MULTIOWNER);\n', '\n', '    // first remove the owner\n', '    uint j = 0;\n', '    for (; j < owners.length; j = j.add(1)) {\n', '      if (owners[j] == _addr) {\n', '        delete owners[j];\n', '        break;\n', '      }\n', '    }\n', '    if (j < owners.length) {\n', '      for (uint jj = j; jj < owners.length.sub(1); jj = jj.add(1)) {\n', '        owners[jj] = owners[jj.add(1)];\n', '      }\n', '\n', '      delete owners[owners.length.sub(1)];\n', '      owners.length = owners.length.sub(1);\n', '    }\n', '\n', '    string memory side = ownerOfSides[_addr];\n', '    // if (sideExist[side] > 0) {\n', '    sideExist[side] = sideExist[side].sub(1);\n', '    if (sideExist[side] == 0) {\n', '      require(multiOwnerSides > 2); // not allow only left 1 side\n', '      multiOwnerSides = multiOwnerSides.sub(1); // this side has been removed\n', '    }\n', '\n', '    // for every event type, if this owner has voted the event, then need to remove\n', '    for (uint i = 0; i < authTypes.length; ) {\n', '      address[] storage voters = sideVoters[side][authTypes[i]];\n', '      for (uint m = 0; m < voters.length; m = m.add(1)) {\n', '        if (voters[m] == _addr) {\n', '          delete voters[m];\n', '          break;\n', '        }\n', '      }\n', '      if (m < voters.length) {\n', '        for (uint n = m; n < voters.length.sub(1); n = n.add(1)) {\n', '          voters[n] = voters[n.add(1)];\n', '        }\n', '\n', '        delete voters[voters.length.sub(1)];\n', '        voters.length = voters.length.sub(1);\n', '\n', '        // if this side only have this 1 voter, the authorization of this event need to be decreased\n', '        if (voters.length == 0) {\n', '          authorizations[authTypes[i]] = authorizations[authTypes[i]].sub(1);\n', '        }\n', '\n', '        // if there is no authorization of this event, the event need to be removed\n', '        if (authorizations[authTypes[i]] == 0) {\n', '          delete authTypes[i];\n', '\n', '          for (uint kk = i; kk < authTypes.length.sub(1); kk = kk.add(1)) {\n', '            authTypes[kk] = authTypes[kk.add(1)];\n', '          }\n', '\n', '          delete authTypes[authTypes.length.sub(1)];\n', '          authTypes.length = authTypes.length.sub(1);\n', '        } else {\n', '          i = i.add(1);\n', '        }\n', '      } else {\n', '        i = i.add(1);\n', '      }\n', '    }\n', '//   }\n', '\n', '    delete ownerOfSides[_addr];\n', '\n', '    clearAuth(AUTH_REMOVEOWNER);\n', '    emit OwnerRemoved(_addr);\n', '  }\n', '\n', '}\n', '\n', 'contract MultiOwnerContract is MultiOwners {\n', '    Claimable public ownedContract;\n', '    address public pendingOwnedOwner;\n', '    // address internal origOwner;\n', '\n', '    string public constant AUTH_CHANGEOWNEDOWNER = "transferOwnerOfOwnedContract";\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingOwner.\n', '     */\n', '    // modifier onlyPendingOwnedOwner() {\n', '    //     require(msg.sender == pendingOwnedOwner);\n', '    //     _;\n', '    // }\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        // origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        ownedContract.claimOwnership();\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one.\n', '     *\n', '     */\n', '    // function transferOwnershipBack() onlyOwner public {\n', '    //     ownedContract.transferOwnership(origOwner);\n', '    //     ownedContract = Claimable(address(0));\n', '    //     origOwner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnedOwnershipto(address _nextOwner) onlyMultiOwners public {\n', '        require(ownedContract != address(0));\n', '        require(hasAuth(AUTH_CHANGEOWNEDOWNER));\n', '\n', '        if (ownedContract.owner() != pendingOwnedOwner) {\n', '            ownedContract.transferOwnership(_nextOwner);\n', '            pendingOwnedOwner = _nextOwner;\n', '            // ownedContract = Claimable(address(0));\n', '            // origOwner = address(0);\n', '        } else {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '        }\n', '\n', '        clearAuth(AUTH_CHANGEOWNEDOWNER);\n', '    }\n', '\n', '    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\n', '        require(ownedContract != address(0));\n', '        if (ownedContract.owner() == pendingOwnedOwner) {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract DRCTOwner is MultiOwnerContract {\n', '    string public constant AUTH_INITCONGRESS = "initCongress";\n', '    string public constant AUTH_CANMINT = "canMint";\n', '    string public constant AUTH_SETMINTAMOUNT = "setMintAmount";\n', '    string public constant AUTH_FREEZEACCOUNT = "freezeAccount";\n', '\n', '    bool congressInit = false;\n', '    // bool paramsInit = false;\n', '    // iParams public params;\n', '    uint256 onceMintAmount;\n', '\n', '\n', '    // function initParams(address _params) onlyOwner public {\n', '    //     require(!paramsInit);\n', '    //     require(_params != address(0));\n', '\n', '    //     params = _params;\n', '    //     paramsInit = false;\n', '    // }\n', '\n', '    /**\n', '     * @dev Function to set mint token amount\n', '     * @param _value The mint value.\n', '     */\n', '    function setOnceMintAmount(uint256 _value) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_SETMINTAMOUNT));\n', '        require(_value > 0);\n', '        onceMintAmount = _value;\n', '\n', '        clearAuth(AUTH_SETMINTAMOUNT);\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _congress the contract address that will be next Owner of the original Contract\n', '     */\n', '    function initCongress(address _congress) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_INITCONGRESS));\n', '        require(!congressInit);\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.initialCongress(_congress);\n', '\n', '        clearAuth(AUTH_INITCONGRESS);\n', '        congressInit = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address _to) onlyMultiOwners public returns (bool) {\n', '        require(hasAuth(AUTH_CANMINT));\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        bool res = tk.mint(_to, onceMintAmount);\n', '\n', '        clearAuth(AUTH_CANMINT);\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to stop minting new tokens.\n', '     * @return True if the operation was successful.\n', '     */\n', '    function finishMinting() onlyMultiOwners public returns (bool) {\n', '        require(hasAuth(AUTH_CANMINT));\n', '\n', '        itoken tk = itoken(address(ownedContract));\n', '        bool res = tk.finishMinting();\n', '\n', '        clearAuth(AUTH_CANMINT);\n', '        return res;\n', '    }\n', '\n', '    /**\n', "     * @dev freeze the account's balance under urgent situation\n", '     *\n', '     * by default all the accounts will not be frozen until set freeze value as true.\n', '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _freeze bool if true, the account will be frozen\n', '     */\n', '    function freezeAccountDirect(address _target, bool _freeze) onlyMultiOwners public {\n', '        require(hasAuth(AUTH_FREEZEACCOUNT));\n', '\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.freezeAccount(_target, _freeze);\n', '\n', '        clearAuth(AUTH_FREEZEACCOUNT);\n', '    }\n', '\n', '    /**\n', "     * @dev freeze the account's balance\n", '     *\n', '     * by default all the accounts will not be frozen until set freeze value as true.\n', '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _freeze bool if true, the account will be frozen\n', '     */\n', '    function freezeAccount(address _target, bool _freeze) onlyOwner public {\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        if (_freeze) {\n', '            require(tk.allowance(_target, this) == tk.balanceOf(_target));\n', '        }\n', '\n', '        tk.freezeAccount(_target, _freeze);\n', '    }\n', '\n', '    /**\n', "     * @dev freeze the account's balance\n", '     *\n', '     * @param _target address the account should be frozen\n', '     * @param _value uint256 the amount of tokens that will be frozen\n', '     */\n', '    function freezeAccountPartialy(address _target, uint256 _value) onlyOwner public {\n', '        require(_target != address(0));\n', '        itoken tk = itoken(address(ownedContract));\n', '        require(tk.allowance(_target, this) == _value);\n', '\n', '        tk.freezeAccountPartialy(_target, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() onlyOwner public {\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() onlyOwner public {\n', '        itoken tk = itoken(address(ownedContract));\n', '        tk.unpause();\n', '    }\n', '\n', '}\n', '\n', 'library Roles {\n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '\n', '  /**\n', '   * @dev give an address access to this role\n', '   */\n', '  function add(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = true;\n', '  }\n', '\n', '  /**\n', "   * @dev remove an address' access to this role\n", '   */\n', '  function remove(Role storage role, address addr)\n', '    internal\n', '  {\n', '    role.bearer[addr] = false;\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * // reverts\n', '   */\n', '  function check(Role storage role, address addr)\n', '    view\n', '    internal\n', '  {\n', '    require(has(role, addr));\n', '  }\n', '\n', '  /**\n', '   * @dev check if an address has this role\n', '   * @return bool\n', '   */\n', '  function has(Role storage role, address addr)\n', '    view\n', '    internal\n', '    returns (bool)\n', '  {\n', '    return role.bearer[addr];\n', '  }\n', '}']
