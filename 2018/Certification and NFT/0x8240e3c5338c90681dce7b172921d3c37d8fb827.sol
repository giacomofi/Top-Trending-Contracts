['pragma solidity ^0.4.19;\n', '\n', '// A 2/3 multisig contract which is compatible with Trezor-signed messages.\n', '//\n', '// To authorize a spend, two signtures must be provided by 2 of the 3 owners.\n', '// To generate the message to be signed, provide the destination address and\n', '// spend amount (in wei) to the generateMessageToSignmethod.\n', '// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\n', '// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\n', '// See the test file for example inputs.\n', '//\n', '// If you use other software than the provided dApp or scripts to sign the message,\n', '// verify that the message shown by the trezor device matches the generated message in hex.\n', '//\n', '// WARNING: The generated message is only valid until the next spend is executed.\n', '//          after that, a new message will need to be calculated.\n', '//\n', '// WARNING: The signing algorithm Trezor uses is different than that\n', '// of Ledger, Geth, Etc. This contract is for Trezor managed private\n', '// keys ONLY.\n', '//\n', '// ADDITIONAL WARNING: This contract is **NOT** ERC20 compatible.\n', '// Tokens sent to this contract will be lost forever.\n', '//\n', 'contract TrezorMultiSig2of3 {\n', '\n', '  // The 3 addresses which control the funds in this contract.  The\n', '  // owners of 2 of these addresses will need to both sign a message\n', '  // allowing the funds in this contract to be spent.\n', '  mapping(address => bool) private owners;\n', '\n', '  // The contract nonce is not accessible to the contract so we\n', '  // implement a nonce-like variable for replay protection.\n', '  uint256 public spendNonce = 0;\n', '\n', '  // Contract Versioning\n', '  uint256 public unchainedMultisigVersionMajor = 1;\n', '  uint256 public unchainedMultisigVersionMinor = 0;   \n', '  \n', '  // An event sent when funds are received.\n', '  event Funded(uint new_balance);\n', '  \n', '  // An event sent when a spend is triggered to the given address.\n', '  event Spent(address to, uint transfer);\n', '\n', '  // Instantiate a new Trezor Multisig 2 of 3 contract owned by the\n', '  // three given addresses\n', '  function TrezorMultiSig2of3(address owner1, address owner2, address owner3) public {\n', '    address zeroAddress = 0x0;\n', '    \n', '    require(owner1 != zeroAddress);\n', '    require(owner2 != zeroAddress);\n', '    require(owner3 != zeroAddress);\n', '\n', '    require(owner1 != owner2);\n', '    require(owner2 != owner3);\n', '    require(owner1 != owner3);\n', '    \n', '    owners[owner1] = true;\n', '    owners[owner2] = true;\n', '    owners[owner3] = true;\n', '  }\n', '\n', '  // The fallback function for this contract.\n', '  function() public payable {\n', '    Funded(this.balance);\n', '  }\n', '\n', '  // Generates the message to sign given the output destination address and amount.\n', '  // includes this contract&#39;s address and a nonce for replay protection.\n', '  // One option to  independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\n', '  function generateMessageToSign(address destination, uint256 value) public constant returns (bytes32) {\n', '    require(destination != address(this));\n', '    bytes32 message = keccak256(spendNonce, this, value, destination);\n', '    return message;\n', '  }\n', '  \n', '  // Send the given amount of ETH to the given destination using\n', '  // the two triplets (v1, r1, s1) and (v2, r2, s2) as signatures.\n', '  // s1 and s2 should be 0x00 or 0x01 corresponding to 0x1b and 0x1c respectively.\n', '  function spend(address destination, uint256 value, uint8 v1, bytes32 r1, bytes32 s1, uint8 v2, bytes32 r2, bytes32 s2) public {\n', '    // This require is handled by generateMessageToSign()\n', '    // require(destination != address(this));\n', '    require(this.balance >= value);\n', '    require(_validSignature(destination, value, v1, r1, s1, v2, r2, s2));\n', '    spendNonce = spendNonce + 1;\n', '    destination.transfer(value);\n', '    Spent(destination, value);\n', '  }\n', '\n', '  // Confirm that the two signature triplets (v1, r1, s1) and (v2, r2, s2)\n', '  // both authorize a spend of this contract&#39;s funds to the given\n', '  // destination address.\n', '  function _validSignature(address destination, uint256 value, uint8 v1, bytes32 r1, bytes32 s1, uint8 v2, bytes32 r2, bytes32 s2) private constant returns (bool) {\n', '    bytes32 message = _messageToRecover(destination, value);\n', '    address addr1   = ecrecover(message, v1+27, r1, s1);\n', '    address addr2   = ecrecover(message, v2+27, r2, s2);\n', '    require(_distinctOwners(addr1, addr2));\n', '    return true;\n', '  }\n', '\n', '  // Generate the the unsigned message (in bytes32) that each owner&#39;s\n', '  // Trezor would have signed for the given destination and amount.\n', '  //\n', '  // The generated message from generateMessageToSign is converted to\n', '  // ascii when signed by a trezor.\n', '  //\n', '  // The required Trezor signing prefix, the length of this\n', '  // unsigned message, and the unsigned ascii message itself are\n', '  // then concatenated and hashed with keccak256.\n', '  function _messageToRecover(address destination, uint256 value) private constant returns (bytes32) {\n', '    bytes32 hashedUnsignedMessage = generateMessageToSign(destination, value);\n', '    bytes memory unsignedMessageBytes = _hashToAscii(hashedUnsignedMessage);\n', '    bytes memory prefix = "\\x19Ethereum Signed Message:\\n";\n', '    return keccak256(prefix,bytes1(unsignedMessageBytes.length),unsignedMessageBytes);\n', '  }\n', '\n', '  \n', '  // Confirm the pair of addresses as two distinct owners of this contract.\n', '  function _distinctOwners(address addr1, address addr2) private constant returns (bool) {\n', '    // Check that both addresses are different\n', '    require(addr1 != addr2);\n', '    // Check that both addresses are owners\n', '    require(owners[addr1]);\n', '    require(owners[addr2]);\n', '    return true;\n', '  }\n', '\n', '\n', '  // Construct the byte representation of the ascii-encoded\n', '  // hashed message written in hex.\n', '   function _hashToAscii(bytes32 hash) private pure returns (bytes) {\n', '    bytes memory s = new bytes(64);\n', '    for (uint i = 0; i < 32; i++) {\n', '      byte b  = hash[i];\n', '      byte hi = byte(uint8(b) / 16);\n', '      byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '      s[2*i]   = _char(hi);\n', '      s[2*i+1] = _char(lo);            \n', '    }\n', '    return s;    \n', '  }\n', '  \n', '  // Convert from byte to ASCII of 0-f\n', '  // http://www.unicode.org/charts/PDF/U0000.pdf\n', '  function _char(byte b) private pure returns (byte c) {\n', '    if (b < 10) return byte(uint8(b) + 0x30);\n', '    else return byte(uint8(b) + 0x57);\n', '  }\n', '}']