['/*\n', ' * Just Price Protocol Smart Contract.\n', ' * Copyright &#169; 2018 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="d3bebab8bbb2babffda5bfb2b7babebaa1bca593b4beb2babffdb0bcbe">[email&#160;protected]</span>>\n', ' */\n', 'pragma solidity ^0.4.20;\n', '\n', '//import "./SafeMath.sol";\n', '//import "./OrgonToken.sol";\n', '//import "./OrisSpace.sol";\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x <= MAX_UINT256 - y);\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x >= y);\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    assert (x <= MAX_UINT256 / y);\n', '    return x * y;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public view returns (uint256 supply);\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public view returns (uint256 balance);\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender)\n', '  public view returns (uint256 remaining);\n', '\n', '  /**\n', '   * Logged when tokens were transferred from one owner to another.\n', '   *\n', '   * @param _from address of the owner, tokens were transferred from\n', '   * @param _to address of the owner, tokens were transferred to\n', '   * @param _value number of tokens transferred\n', '   */\n', '  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * Logged when owner approved his tokens to be transferred by some spender.\n', '   *\n', '   * @param _owner owner who approved his tokens to be transferred\n', '   * @param _spender spender who were allowed to transfer the tokens belonging\n', '   *        to the owner\n', '   * @param _value number of tokens belonging to the owner, approved to be\n', '   *        transferred by the spender\n', '   */\n', '  event Approval (\n', '    address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract OrisSpace {\n', '  /**\n', '   * Start Oris Space smart contract.\n', '   *\n', '   * @param _returnAmount amount of tokens to return to message sender.\n', '   */\n', '  function start (uint256 _returnAmount) public;\n', '}\n', '\n', 'contract OrgonToken is Token {\n', '  /**\n', '   * Create _value new tokens and give new created tokens to msg.sender.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _value number of tokens to create\n', '   * @return true if tokens were created successfully, false otherwise\n', '   */\n', '  function createTokens (uint256 _value) public returns (bool);\n', '\n', '  /**\n', '   * Burn given number of tokens belonging to message sender.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _value number of tokens to burn\n', '   * @return true on success, false on error\n', '   */\n', '  function burnTokens (uint256 _value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * Just Price Protocol Smart Contract that serves as market maker for Orgon\n', ' * tokens.\n', ' */\n', 'contract JustPriceProtocol is SafeMath {\n', '  /**\n', '   * 2^128.\n', '   */\n', '  uint256 internal constant TWO_128 = 0x100000000000000000000000000000000;\n', '\n', '  /**\n', '   * Sale start time (2018-04-19 06:00:00 UTC)\n', '   */\n', '  uint256 internal constant SALE_START_TIME = 1524117600;\n', '\n', '  /**\n', '   * "Reserve" stage deadline (2018-07-08 00:00:00 UTC)\n', '   */\n', '  uint256 internal constant RESERVE_DEADLINE = 1531008000;\n', '\n', '  /**\n', '   * Maximum amount to be collected during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MAX_AMOUNT = 72500 ether;\n', '\n', '  /**\n', '   * Minimum amount to be collected during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MIN_AMOUNT = 30000 ether;\n', '\n', '  /**\n', '   * Maximum number of tokens to be sold during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MAX_TOKENS = 82881476.72e9;\n', '\n', '  /**\n', '   * ORNG/ETH ratio after "reserve" stage in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_RATIO = 72500 ether / 725000000e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 1.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_1 = 10000 ether;\n', '\n', '  /**\n', '   * Price 1 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_1 = 0.00080 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 2.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_2 = 20000 ether;\n', '\n', '  /**\n', '   * Price 2 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_2 = 0.00082 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 3.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_3 = 30000 ether;\n', '\n', '  /**\n', '   * Price 3 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_3 = 0.00085 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 4.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_4 = 40000 ether;\n', '\n', '  /**\n', '   * Price 4 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_4 = 0.00088 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 5.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_5 = 50000 ether;\n', '\n', '  /**\n', '   * Price 5 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_5 = 0.00090 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 6.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_6 = 60000 ether;\n', '\n', '  /**\n', '   * Price 6 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_6 = 0.00092 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 7.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_7 = 70000 ether;\n', '\n', '  /**\n', '   * Price 7 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_7 = 0.00095 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 8.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_8 = 72500 ether;\n', '\n', '  /**\n', '   * Price 8 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_8 = 0.00098 ether / 1e9;\n', '\n', '  /**\n', '   * "Growth" stage ends once this many tokens were issued.\n', '   */\n', '  uint256 internal constant GROWTH_MAX_TOKENS = 1000000000e9;\n', '\n', '  /**\n', '   * Maximum duration of "growth" stage.\n', '   */\n', '  uint256 internal constant GROWTH_MAX_DURATION = 285 days;\n', '\n', '  /**\n', '   * Numerator of fraction of tokens bought at "reserve" stage to be delivered\n', '   * before "growth" stage start.\n', '   */\n', '  uint256 internal constant GROWTH_MIN_DELIVERED_NUMERATOR = 75;\n', '\n', '  /**\n', '   * Denominator of fraction of tokens bought at "reserve" stage to be delivered\n', '   * before "growth" stage start.\n', '   */\n', '  uint256 internal constant GROWTH_MIN_DELIVERED_DENOMINATIOR = 100;\n', '\n', '  /**\n', '   * Numerator of fraction of total votes to be given to a new K1 address for\n', '   * vote to succeed.\n', '   */\n', '  uint256 internal constant REQUIRED_VOTES_NUMERATIOR = 51;\n', '\n', '  /**\n', '   * Denominator of fraction of total votes to be given to a new K1 address for\n', '   * vote to succeed.\n', '   */\n', '  uint256 internal constant REQUIRED_VOTES_DENOMINATOR = 100;\n', '\n', '  /**\n', '   * Fee denominator (1 / 20000 = 0.00005).\n', '   */\n', '  uint256 internal constant FEE_DENOMINATOR = 20000;\n', '\n', '  /**\n', '   * Delay after start of "growth" stage before fee may be changed.\n', '   */\n', '  uint256 internal constant FEE_CHANGE_DELAY = 650 days;\n', '\n', '  /**\n', '   * Minimum fee (1 / 20000 = 0.0005).\n', '   */\n', '  uint256 internal constant MIN_FEE = 1;\n', '\n', '  /**\n', '   * Maximum fee (2000 / 20000 = 0.1).\n', '   */\n', '  uint256 internal constant MAX_FEE = 2000;\n', '\n', '  /**\n', '   * Deploy Just Price Protocol smart contract with given Orgon Token,\n', '   * Oris Space, and K1 wallet.\n', '   *\n', '   * @param _orgonToken Orgon Token to use\n', '   * @param _orisSpace Oris Space to use\n', '   * @param _k1 address of K1 wallet\n', '   */\n', '  function JustPriceProtocol (\n', '    OrgonToken _orgonToken, OrisSpace _orisSpace, address _k1)\n', '  public {\n', '    orgonToken = _orgonToken;\n', '    orisSpace = _orisSpace;\n', '    k1 = _k1;\n', '  }\n', '\n', '  /**\n', '   * When called with no data does the same as buyTokens ().\n', '   */\n', '  function () public payable {\n', '    require (msg.data.length == 0);\n', '\n', '    buyTokens ();\n', '  }\n', '\n', '  /**\n', '   * Buy tokens.\n', '   */\n', '  function buyTokens () public payable {\n', '    require (msg.value > 0);\n', '\n', '    updateStage ();\n', '\n', '    if (stage == Stage.RESERVE)\n', '      buyTokensReserve ();\n', '    else if (stage == Stage.GROWTH || stage == Stage.LIFE)\n', '      buyTokensGrowthLife ();\n', '    else revert (); // No buying in current stage\n', '  }\n', '\n', '  /**\n', '   * Sell tokens.\n', '   *\n', '   * @param _value number of tokens to sell\n', '   */\n', '  function sellTokens (uint256 _value) public {\n', '    require (_value > 0);\n', '    require (_value < TWO_128);\n', '\n', '    updateStage ();\n', '    require (stage == Stage.LIFE);\n', '\n', '    assert (reserveAmount < TWO_128);\n', '    uint256 totalSupply = orgonToken.totalSupply ();\n', '    require (totalSupply < TWO_128);\n', '\n', '    require (_value <= totalSupply);\n', '\n', '    uint256 toPay = safeMul (\n', '      reserveAmount,\n', '      safeSub (\n', '        TWO_128,\n', '        pow_10 (safeSub (TWO_128, (_value << 128) / totalSupply)))) >> 128;\n', '\n', '    require (orgonToken.transferFrom (msg.sender, this, _value));\n', '    require (orgonToken.burnTokens (_value));\n', '\n', '    reserveAmount = safeSub (reserveAmount, toPay);\n', '\n', '    msg.sender.transfer (toPay);\n', '  }\n', '\n', '  /**\n', '   * Deliver tokens sold during "reserve" stage to corresponding investors.\n', '   *\n', '   * @param _investors addresses of investors to deliver tokens to\n', '   */\n', '  function deliver (address [] _investors) public {\n', '    updateStage ();\n', '    require (\n', '      stage == Stage.BEFORE_GROWTH ||\n', '      stage == Stage.GROWTH ||\n', '      stage == Stage.LIFE);\n', '\n', '    for (uint256 i = 0; i < _investors.length; i++) {\n', '      address investorAddress = _investors [i];\n', '      Investor storage investor = investors [investorAddress];\n', '\n', '      uint256 toDeliver = investor.tokensBought;\n', '      investor.tokensBought = 0;\n', '      investor.etherInvested = 0;\n', '\n', '      if (toDeliver > 0) {\n', '        require (orgonToken.transfer (investorAddress, toDeliver));\n', '        reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver);\n', '\n', '        Delivery (investorAddress, toDeliver);\n', '      }\n', '    }\n', '\n', '    if (stage == Stage.BEFORE_GROWTH &&\n', '      safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) >=\n', '        safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) {\n', '      stage = Stage.GROWTH;\n', '      growthDeadline = currentTime () + GROWTH_MAX_DURATION;\n', '      feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Refund investors who bought tokens during "reserve" stage.\n', '   *\n', '   * @param _investors addresses of investors to refund\n', '   */\n', '  function refund (address [] _investors) public {\n', '    updateStage ();\n', '    require (stage == Stage.REFUND);\n', '\n', '    for (uint256 i = 0; i < _investors.length; i++) {\n', '      address investorAddress = _investors [i];\n', '      Investor storage investor = investors [investorAddress];\n', '\n', '      uint256 toBurn = investor.tokensBought;\n', '      uint256 toRefund = investor.etherInvested;\n', '\n', '      investor.tokensBought = 0;\n', '      investor.etherInvested = 0;\n', '\n', '      if (toBurn > 0)\n', '        require (orgonToken.burnTokens (toBurn));\n', '\n', '      if (toRefund > 0) {\n', '        investorAddress.transfer (toRefund);\n', '\n', '        Refund (investorAddress, toRefund);\n', '      }\n', '    }\n', '  }\n', '\n', '  function vote (address _newK1) public {\n', '    updateStage ();\n', '\n', '    require (stage == Stage.LIFE);\n', '    require (!k1Changed);\n', '\n', '    uint256 votesCount = voteNumbers [msg.sender];\n', '    if (votesCount > 0) {\n', '      address oldK1 = votes [msg.sender];\n', '      if (_newK1 != oldK1) {\n', '        if (oldK1 != address (0)) {\n', '          voteResults [oldK1] = safeSub (voteResults [oldK1], votesCount);\n', '\n', '          VoteRevocation (msg.sender, oldK1, votesCount);\n', '        }\n', '\n', '        votes [msg.sender] = _newK1;\n', '\n', '        if (_newK1 != address (0)) {\n', '          voteResults [_newK1] = safeAdd (voteResults [_newK1], votesCount);\n', '          Vote (msg.sender, _newK1, votesCount);\n', '\n', '          if (safeMul (voteResults [_newK1], REQUIRED_VOTES_DENOMINATOR) >=\n', '            safeMul (totalVotesNumber, REQUIRED_VOTES_NUMERATIOR)) {\n', '            k1 = _newK1;\n', '            k1Changed = true;\n', '\n', '            K1Change (_newK1);\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Set new fee numerator.\n', '   *\n', '   * @param _fee new fee numerator.\n', '   */\n', '  function setFee (uint256 _fee) public {\n', '    require (msg.sender == k1);\n', '\n', '    require (_fee >= MIN_FEE);\n', '    require (_fee <= MAX_FEE);\n', '\n', '    updateStage ();\n', '\n', '    require (stage == Stage.GROWTH || stage == Stage.LIFE);\n', '    require (currentTime () >= feeChangeEnableTime);\n', '\n', '    require (safeSub (_fee, 1) <= fee);\n', '    require (safeAdd (_fee, 1) >= fee);\n', '\n', '    if (fee != _fee) {\n', '      fee = _fee;\n', '\n', '      FeeChange (_fee);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens bought by given investor during reserve stage that are\n', '   * not yet delivered to him.\n', '   *\n', '   * @param _investor address of investor to get number of outstanding tokens\n', '   *       for\n', '   * @return number of non-delivered tokens given investor bought during reserve\n', '   *         stage\n', '   */\n', '  function outstandingTokens (address _investor) public view returns (uint256) {\n', '    return investors [_investor].tokensBought;\n', '  }\n', '\n', '  /**\n', '   * Get current stage of Just Price Protocol.\n', '   *\n', '   * @param _currentTime current time in seconds since epoch\n', '   * @return current stage of Just Price Protocol\n', '   */\n', '  function getStage (uint256 _currentTime) public view returns (Stage) {\n', '    Stage currentStage = stage;\n', '\n', '    if (currentStage == Stage.BEFORE_RESERVE) {\n', '      if (_currentTime >= SALE_START_TIME)\n', '        currentStage = Stage.RESERVE;\n', '      else return currentStage;\n', '    }\n', '\n', '    if (currentStage == Stage.RESERVE) {\n', '      if (_currentTime >= RESERVE_DEADLINE) {\n', '        if (reserveAmount >= RESERVE_MIN_AMOUNT)\n', '          currentStage = Stage.BEFORE_GROWTH;\n', '        else currentStage = Stage.REFUND;\n', '      }\n', '\n', '      return currentStage;\n', '    }\n', '\n', '    if (currentStage == Stage.GROWTH) {\n', '      if (_currentTime >= growthDeadline) {\n', '        currentStage = Stage.LIFE;\n', '      }\n', '    }\n', '\n', '    return currentStage;\n', '  }\n', '\n', '  /**\n', '   * Return total number of votes eligible for choosing new K1 address.\n', '   *\n', '   * @return total number of votes eligible for choosing new K1 address\n', '   */\n', '  function totalEligibleVotes () public view returns (uint256) {\n', '    return totalVotesNumber;\n', '  }\n', '\n', '  /**\n', '   * Return number of votes eligible for choosing new K1 address given investor\n', '   * has.\n', '   *\n', '   * @param _investor address of investor to get number of eligible votes of\n', '   * @return Number of eligible votes given investor has\n', '   */\n', '  function eligibleVotes (address _investor) public view returns (uint256) {\n', '    return voteNumbers [_investor];\n', '  }\n', '\n', '  /**\n', '   * Get number of votes for the given new K1 address.\n', '   *\n', '   * @param _newK1 new K1 address to get number of votes for\n', '   * @return number of votes for the given new K1 address\n', '   */\n', '  function votesFor (address _newK1) public view returns (uint256) {\n', '    return voteResults [_newK1];\n', '  }\n', '\n', '  /**\n', '   * Buy tokens during "reserve" stage.\n', '   */\n', '  function buyTokensReserve () internal {\n', '    require (stage == Stage.RESERVE);\n', '\n', '    uint256 toBuy = 0;\n', '    uint256 toRefund = msg.value;\n', '    uint256 etherInvested = 0;\n', '    uint256 tokens;\n', '    uint256 tokensValue;\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_1) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_1, reserveAmount)) /\n', '        RESERVE_PRICE_1;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_1);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_2) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_2, reserveAmount)) /\n', '        RESERVE_PRICE_2;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_2);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_3) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_3, reserveAmount)) /\n', '        RESERVE_PRICE_3;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_3);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_4) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_4, reserveAmount)) /\n', '        RESERVE_PRICE_4;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_4);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_5) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_5, reserveAmount)) /\n', '        RESERVE_PRICE_5;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_5);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_6) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_6, reserveAmount)) /\n', '        RESERVE_PRICE_6;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_6);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_7) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_7, reserveAmount)) /\n', '        RESERVE_PRICE_7;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_7);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_8) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_8, reserveAmount)) /\n', '        RESERVE_PRICE_8;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_8);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (toBuy > 0) {\n', '      Investor storage investor = investors [msg.sender];\n', '\n', '      investor.tokensBought = safeAdd (\n', '        investor.tokensBought, toBuy);\n', '\n', '      investor.etherInvested = safeAdd (\n', '        investor.etherInvested, etherInvested);\n', '\n', '      reserveTokensSold = safeAdd (reserveTokensSold, toBuy);\n', '\n', '      require (orgonToken.createTokens (toBuy));\n', '\n', '      voteNumbers [msg.sender] = safeAdd (voteNumbers [msg.sender], toBuy);\n', '      totalVotesNumber = safeAdd (totalVotesNumber, toBuy);\n', '\n', '      Investment (msg.sender, etherInvested, toBuy);\n', '\n', '      if (safeSub (RESERVE_THRESHOLD_8, reserveAmount) <\n', '        RESERVE_PRICE_8) {\n', '\n', '        orisSpace.start (0);\n', '\n', '        stage = Stage.BEFORE_GROWTH;\n', '      }\n', '    }\n', '\n', '    if (toRefund > 0)\n', '      msg.sender.transfer (toRefund);\n', '  }\n', '\n', '  /**\n', '   * Buy tokens during "growth" or "life" stage.\n', '   */\n', '  function buyTokensGrowthLife () internal {\n', '    require (stage == Stage.GROWTH || stage == Stage.LIFE);\n', '\n', '    require (msg.value < TWO_128);\n', '\n', '    uint256 totalSupply = orgonToken.totalSupply ();\n', '    assert (totalSupply < TWO_128);\n', '\n', '    uint256 toBuy = safeMul (\n', '      totalSupply,\n', '      safeSub (\n', '        root_10 (safeAdd (TWO_128, (msg.value << 128) / reserveAmount)),\n', '        TWO_128)) >> 128;\n', '\n', '    reserveAmount = safeAdd (reserveAmount, msg.value);\n', '    require (reserveAmount < TWO_128);\n', '\n', '    if (toBuy > 0) {\n', '      require (orgonToken.createTokens (toBuy));\n', '      require (orgonToken.totalSupply () < TWO_128);\n', '\n', '      uint256 feeAmount = safeMul (toBuy, fee) / FEE_DENOMINATOR;\n', '\n', '      require (orgonToken.transfer (msg.sender, safeSub (toBuy, feeAmount)));\n', '\n', '      if (feeAmount > 0)\n', '        require (orgonToken.transfer (k1, feeAmount));\n', '\n', '      if (stage == Stage.GROWTH) {\n', '        uint256 votesCount = toBuy;\n', '\n', '        totalSupply = orgonToken.totalSupply ();\n', '        if (totalSupply >= GROWTH_MAX_TOKENS) {\n', '          stage = Stage.LIFE;\n', '          votesCount = safeSub (\n', '            votesCount,\n', '            safeSub (totalSupply, GROWTH_MAX_TOKENS));\n', '        }\n', '\n', '        voteNumbers [msg.sender] =\n', '          safeAdd (voteNumbers [msg.sender], votesCount);\n', '        totalVotesNumber = safeAdd (totalVotesNumber, votesCount);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Update stage of Just Price Protocol and return updated stage.\n', '   *\n', '   * @return updated stage of Just Price Protocol\n', '   */\n', '  function updateStage () internal returns (Stage) {\n', '    Stage currentStage = getStage (currentTime ());\n', '    if (stage != currentStage) {\n', '      if (currentStage == Stage.BEFORE_GROWTH) {\n', '        // "Reserve" stage deadline reached and minimum amount collected\n', '        uint256 tokensToBurn =\n', '          safeSub (\n', '            safeAdd (\n', '              safeAdd (\n', '                safeSub (RESERVE_MAX_AMOUNT, reserveAmount),\n', '                safeSub (RESERVE_RATIO, 1)) /\n', '                RESERVE_RATIO,\n', '              reserveTokensSold),\n', '            RESERVE_MAX_TOKENS);\n', '\n', '        orisSpace.start (tokensToBurn);\n', '        if (tokensToBurn > 0)\n', '          require (orgonToken.burnTokens (tokensToBurn));\n', '      }\n', '\n', '      stage = currentStage;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get minimum of two values.\n', '   *\n', '   * @param x first value\n', '   * @param y second value\n', '   * @return minimum of two values\n', '   */\n', '  function min (uint256 x, uint256 y) internal pure returns (uint256) {\n', '    return x < y ? x : y;\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^128 * (x / 2^128)^(1/10).\n', '   *\n', '   * @param x parameter x\n', '   * @return 2^128 * (x / 2^128)^(1/10)\n', '   */\n', '  function root_10 (uint256 x) internal pure returns (uint256 y) {\n', '    uint256 shift = 0;\n', '\n', '    while (x > TWO_128) {\n', '      x >>= 10;\n', '      shift += 1;\n', '    }\n', '\n', '    if (x == TWO_128 || x == 0) y = x;\n', '    else {\n', '      uint256 x128 = x << 128;\n', '      y = TWO_128;\n', '\n', '      uint256 t = x;\n', '      while (true) {\n', '        t <<= 10;\n', '        if (t < TWO_128) y >>= 1;\n', '        else break;\n', '      }\n', '\n', '      for (uint256 i = 0; i < 16; i++) {\n', '        uint256 y9;\n', '\n', '        if (y == TWO_128) y9 = y;\n', '        else {\n', '          uint256 y2 = (y * y) >> 128;\n', '          uint256 y4 = (y2 * y2) >> 128;\n', '          uint256 y8 = (y4 * y4) >> 128;\n', '          y9 = (y * y8) >> 128;\n', '        }\n', '\n', '        y = (9 * y + x128 / y9) / 10;\n', '\n', '        assert (y <= TWO_128);\n', '      }\n', '    }\n', '\n', '    y <<= shift;\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^128 * (x / 2^128)^10.\n', '   *\n', '   * @param x parameter x\n', '   * @return 2^128 * (x / 2^128)^10\n', '   */\n', '  function pow_10 (uint256 x) internal pure returns (uint256) {\n', '    require (x <= TWO_128);\n', '\n', '    if (x == TWO_128) return x;\n', '    else {\n', '      uint256 x2 = (x * x) >> 128;\n', '      uint256 x4 = (x2 * x2) >> 128;\n', '      uint256 x8 = (x4 * x4) >> 128;\n', '      return (x2 * x8) >> 128;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get current time in seconds since epoch.\n', '   *\n', '   * @return current time in seconds since epoch\n', '   */\n', '  function currentTime () internal view returns (uint256) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  /**\n', '   * Just Price Protocol stages.\n', '   * +----------------+\n', '   * | BEFORE_RESERVE |\n', '   * +----------------+\n', '   *         |\n', '   *         | Sale start time reached\n', '   *         V\n', '   *    +---------+   Reserve deadline reached\n', '   *    | RESERVE |-------------------------------+\n', '   *    +---------+                               |\n', '   *         |                                    |\n', '   *         | 72500 ETH collected                |\n', '   *         V                                    |\n', '   * +---------------+ 39013,174672 ETH collected |\n', '   * | BEFORE_GROWTH |<---------------------------O\n', '   * +---------------+                            |\n', '   *         |                                    | 39013,174672 ETH not collected\n', '   *         | 80% of tokens delivered            |\n', '   *         V                                    V\n', '   *  +------------+                         +--------+\n', '   *  |   GROWTH   |                         | REFUND |\n', '   *  +------------+                         +--------+\n', '   *         |\n', '   *         | 1,500,000,000 tokens issued or 365 days passed since start of "GROWTH" stage\n', '   *         V\n', '   *     +------+\n', '   *     | LIFE |\n', '   *     +------+\n', '   */\n', '  enum Stage {\n', '    BEFORE_RESERVE, // Before start of "Reserve" stage\n', '    RESERVE, // "Reserve" stage\n', '    BEFORE_GROWTH, // Between "Reserve" and "Growth" stages\n', '    GROWTH, // "Grows" stage\n', '    LIFE, // "Life" stage\n', '    REFUND // "Refund" stage\n', '  }\n', '\n', '  /**\n', '   * Orgon Token smart contract.\n', '   */\n', '  OrgonToken internal orgonToken;\n', '\n', '  /**\n', '   * Oris Space spart contract.\n', '   */\n', '  OrisSpace internal orisSpace;\n', '\n', '  /**\n', '   * Address of K1 smart contract.\n', '   */\n', '  address internal k1;\n', '\n', '  /**\n', '   * Last known stage of Just Price Protocol\n', '   */\n', '  Stage internal stage = Stage.BEFORE_RESERVE;\n', '\n', '  /**\n', '   * Amount of ether in reserve.\n', '   */\n', '  uint256 internal reserveAmount;\n', '\n', '  /**\n', '   * Number of tokens sold during "reserve" stage.\n', '   */\n', '  uint256 internal reserveTokensSold;\n', '\n', '  /**\n', '   * Number of tokens sold during "reserve" stage that were already delivered to\n', '   * investors.\n', '   */\n', '  uint256 internal reserveTokensDelivered;\n', '\n', '  /**\n', '   * "Growth" stage deadline.\n', '   */\n', '  uint256 internal growthDeadline;\n', '\n', '  /**\n', '   * Mapping from address of a person who bought some tokens during "reserve"\n', '   * stage to information about how many tokens he bought to how much ether\n', '   * invested.\n', '   */\n', '  mapping (address => Investor) internal investors;\n', '\n', '  /**\n', '   * Mapping from address of an investor to the number of votes this investor\n', '   * has.\n', '   */\n', '  mapping (address => uint256) internal voteNumbers;\n', '\n', '  /**\n', '   * Mapping from address of an investor to the new K1 address this investor\n', '   * voted for.\n', '   */\n', '  mapping (address => address) internal votes;\n', '\n', '  /**\n', '   * Mapping from suggested new K1 address to the number of votes for this\n', '   * address.\n', '   */\n', '  mapping (address => uint256) internal voteResults;\n', '\n', '  /**\n', '   * Total number of eligible votes.\n', '   */\n', '  uint256 internal totalVotesNumber;\n', '\n', '  /**\n', '   * Whether K1 address was already changed via voting.\n', '   */\n', '  bool internal k1Changed = false;\n', '\n', '  /**\n', '   * Fee enumerator.  (2 / 20000 = 0.0001);\n', '   */\n', '  uint256 internal fee = 2;\n', '\n', '  /**\n', '   * Time when fee changing is enabled.\n', '   */\n', '  uint256 internal feeChangeEnableTime;\n', '\n', '  /**\n', '   * Encapsulates information about a person who bought some tokens during\n', '   * "reserve" stage.\n', '   */\n', '  struct Investor {\n', '    /**\n', '     * Number of tokens bought during reserve stage.\n', '     */\n', '    uint256 tokensBought;\n', '\n', '    /**\n', '     * Ether invested during reserve stage.\n', '     */\n', '    uint256 etherInvested;\n', '  }\n', '\n', '  /**\n', '   * Logged when investor invested some ether during "reserve" stage.\n', '   *\n', '   * @param investor address of investor\n', '   * @param value amount of ether invested\n', '   * @param amount number of tokens issued for investor\n', '   */\n', '  event Investment (address indexed investor, uint256 value, uint256 amount);\n', '\n', '  /**\n', '   * Logged when tokens bought at "reserve" stage were delivered to investor.\n', '   *\n', '   * @param investor address of investor whom tokens were delivered to\n', '   * @param amount number of tokens delivered\n', '   */\n', '  event Delivery (address indexed investor, uint256 amount);\n', '\n', '  /**\n', '   * Logged when investment was refunded.\n', '   *\n', '   * @param investor address of investor whose investment was refunded\n', '   * @param value amount of ether refunded\n', '   */\n', '  event Refund (address indexed investor, uint256 value);\n', '\n', '  /**\n', '   * Logged when K1 address was changed.\n', '   *\n', '   * @param k1 new K1 address\n', '   */\n', '  event K1Change (address k1);\n', '\n', '  /**\n', '   * Logged when investor voted for new K1 address.\n', '   * \n', '   * @param investor investor who voted for new K1 address\n', '   * @param newK1 new K1 address investor voted for\n', '   * @param votes number of votes investor has\n', '   */\n', '  event Vote (address indexed investor, address indexed newK1, uint256 votes);\n', '\n', '  /**\n', '   * Logged when investor revoked vote for new K1 address.\n', '   * \n', '   * @param investor investor who revoked vote for new K1 address\n', '   * @param newK1 new K1 address investor revoked vote for\n', '   * @param votes number of votes investor has\n', '   */\n', '  event VoteRevocation (\n', '    address indexed investor, address indexed newK1, uint256 votes);\n', '\n', '  /**\n', '   * Logged when fee was changed.\n', '   *\n', '   * @param fee new fee numerator\n', '   */\n', '  event FeeChange (uint256 fee);\n', '}']
['/*\n', ' * Just Price Protocol Smart Contract.\n', ' * Copyright © 2018 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', 'pragma solidity ^0.4.20;\n', '\n', '//import "./SafeMath.sol";\n', '//import "./OrgonToken.sol";\n', '//import "./OrisSpace.sol";\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x <= MAX_UINT256 - y);\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    assert (x >= y);\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  pure internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    assert (x <= MAX_UINT256 / y);\n', '    return x * y;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '  /**\n', '   * Get total number of tokens in circulation.\n', '   *\n', '   * @return total number of tokens in circulation\n', '   */\n', '  function totalSupply () public view returns (uint256 supply);\n', '\n', '  /**\n', '   * Get number of tokens currently belonging to given owner.\n', '   *\n', '   * @param _owner address to get number of tokens currently belonging to the\n', '   *        owner of\n', '   * @return number of tokens currently belonging to the owner of given address\n', '   */\n', '  function balanceOf (address _owner) public view returns (uint256 balance);\n', '\n', '  /**\n', '   * Transfer given number of tokens from message sender to given recipient.\n', '   *\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer to the owner of given address\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transfer (address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Transfer given number of tokens from given owner to given recipient.\n', '   *\n', '   * @param _from address to transfer tokens from the owner of\n', '   * @param _to address to transfer tokens to the owner of\n', '   * @param _value number of tokens to transfer from given owner to given\n', '   *        recipient\n', '   * @return true if tokens were transferred successfully, false otherwise\n', '   */\n', '  function transferFrom (address _from, address _to, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Allow given spender to transfer given number of tokens from message sender.\n', '   *\n', '   * @param _spender address to allow the owner of to transfer tokens from\n', '   *        message sender\n', '   * @param _value number of tokens to allow to transfer\n', '   * @return true if token transfer was successfully approved, false otherwise\n', '   */\n', '  function approve (address _spender, uint256 _value)\n', '  public returns (bool success);\n', '\n', '  /**\n', '   * Tell how many tokens given spender is currently allowed to transfer from\n', '   * given owner.\n', '   *\n', '   * @param _owner address to get number of tokens allowed to be transferred\n', '   *        from the owner of\n', '   * @param _spender address to get number of tokens allowed to be transferred\n', '   *        by the owner of\n', '   * @return number of tokens given spender is currently allowed to transfer\n', '   *         from given owner\n', '   */\n', '  function allowance (address _owner, address _spender)\n', '  public view returns (uint256 remaining);\n', '\n', '  /**\n', '   * Logged when tokens were transferred from one owner to another.\n', '   *\n', '   * @param _from address of the owner, tokens were transferred from\n', '   * @param _to address of the owner, tokens were transferred to\n', '   * @param _value number of tokens transferred\n', '   */\n', '  event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * Logged when owner approved his tokens to be transferred by some spender.\n', '   *\n', '   * @param _owner owner who approved his tokens to be transferred\n', '   * @param _spender spender who were allowed to transfer the tokens belonging\n', '   *        to the owner\n', '   * @param _value number of tokens belonging to the owner, approved to be\n', '   *        transferred by the spender\n', '   */\n', '  event Approval (\n', '    address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract OrisSpace {\n', '  /**\n', '   * Start Oris Space smart contract.\n', '   *\n', '   * @param _returnAmount amount of tokens to return to message sender.\n', '   */\n', '  function start (uint256 _returnAmount) public;\n', '}\n', '\n', 'contract OrgonToken is Token {\n', '  /**\n', '   * Create _value new tokens and give new created tokens to msg.sender.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _value number of tokens to create\n', '   * @return true if tokens were created successfully, false otherwise\n', '   */\n', '  function createTokens (uint256 _value) public returns (bool);\n', '\n', '  /**\n', '   * Burn given number of tokens belonging to message sender.\n', '   * May only be called by smart contract owner.\n', '   *\n', '   * @param _value number of tokens to burn\n', '   * @return true on success, false on error\n', '   */\n', '  function burnTokens (uint256 _value) public returns (bool);\n', '}\n', '\n', '/**\n', ' * Just Price Protocol Smart Contract that serves as market maker for Orgon\n', ' * tokens.\n', ' */\n', 'contract JustPriceProtocol is SafeMath {\n', '  /**\n', '   * 2^128.\n', '   */\n', '  uint256 internal constant TWO_128 = 0x100000000000000000000000000000000;\n', '\n', '  /**\n', '   * Sale start time (2018-04-19 06:00:00 UTC)\n', '   */\n', '  uint256 internal constant SALE_START_TIME = 1524117600;\n', '\n', '  /**\n', '   * "Reserve" stage deadline (2018-07-08 00:00:00 UTC)\n', '   */\n', '  uint256 internal constant RESERVE_DEADLINE = 1531008000;\n', '\n', '  /**\n', '   * Maximum amount to be collected during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MAX_AMOUNT = 72500 ether;\n', '\n', '  /**\n', '   * Minimum amount to be collected during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MIN_AMOUNT = 30000 ether;\n', '\n', '  /**\n', '   * Maximum number of tokens to be sold during "reserve" stage.\n', '   */\n', '  uint256 internal constant RESERVE_MAX_TOKENS = 82881476.72e9;\n', '\n', '  /**\n', '   * ORNG/ETH ratio after "reserve" stage in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_RATIO = 72500 ether / 725000000e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 1.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_1 = 10000 ether;\n', '\n', '  /**\n', '   * Price 1 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_1 = 0.00080 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 2.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_2 = 20000 ether;\n', '\n', '  /**\n', '   * Price 2 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_2 = 0.00082 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 3.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_3 = 30000 ether;\n', '\n', '  /**\n', '   * Price 3 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_3 = 0.00085 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 4.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_4 = 40000 ether;\n', '\n', '  /**\n', '   * Price 4 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_4 = 0.00088 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 5.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_5 = 50000 ether;\n', '\n', '  /**\n', '   * Price 5 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_5 = 0.00090 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 6.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_6 = 60000 ether;\n', '\n', '  /**\n', '   * Price 6 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_6 = 0.00092 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 7.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_7 = 70000 ether;\n', '\n', '  /**\n', '   * Price 7 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_7 = 0.00095 ether / 1e9;\n', '\n', '  /**\n', '   * Maximum amount of ETH to collect at price 8.\n', '   */\n', '  uint256 internal constant RESERVE_THRESHOLD_8 = 72500 ether;\n', '\n', '  /**\n', '   * Price 8 in Wei per ORGN unit.\n', '   */\n', '  uint256 internal constant RESERVE_PRICE_8 = 0.00098 ether / 1e9;\n', '\n', '  /**\n', '   * "Growth" stage ends once this many tokens were issued.\n', '   */\n', '  uint256 internal constant GROWTH_MAX_TOKENS = 1000000000e9;\n', '\n', '  /**\n', '   * Maximum duration of "growth" stage.\n', '   */\n', '  uint256 internal constant GROWTH_MAX_DURATION = 285 days;\n', '\n', '  /**\n', '   * Numerator of fraction of tokens bought at "reserve" stage to be delivered\n', '   * before "growth" stage start.\n', '   */\n', '  uint256 internal constant GROWTH_MIN_DELIVERED_NUMERATOR = 75;\n', '\n', '  /**\n', '   * Denominator of fraction of tokens bought at "reserve" stage to be delivered\n', '   * before "growth" stage start.\n', '   */\n', '  uint256 internal constant GROWTH_MIN_DELIVERED_DENOMINATIOR = 100;\n', '\n', '  /**\n', '   * Numerator of fraction of total votes to be given to a new K1 address for\n', '   * vote to succeed.\n', '   */\n', '  uint256 internal constant REQUIRED_VOTES_NUMERATIOR = 51;\n', '\n', '  /**\n', '   * Denominator of fraction of total votes to be given to a new K1 address for\n', '   * vote to succeed.\n', '   */\n', '  uint256 internal constant REQUIRED_VOTES_DENOMINATOR = 100;\n', '\n', '  /**\n', '   * Fee denominator (1 / 20000 = 0.00005).\n', '   */\n', '  uint256 internal constant FEE_DENOMINATOR = 20000;\n', '\n', '  /**\n', '   * Delay after start of "growth" stage before fee may be changed.\n', '   */\n', '  uint256 internal constant FEE_CHANGE_DELAY = 650 days;\n', '\n', '  /**\n', '   * Minimum fee (1 / 20000 = 0.0005).\n', '   */\n', '  uint256 internal constant MIN_FEE = 1;\n', '\n', '  /**\n', '   * Maximum fee (2000 / 20000 = 0.1).\n', '   */\n', '  uint256 internal constant MAX_FEE = 2000;\n', '\n', '  /**\n', '   * Deploy Just Price Protocol smart contract with given Orgon Token,\n', '   * Oris Space, and K1 wallet.\n', '   *\n', '   * @param _orgonToken Orgon Token to use\n', '   * @param _orisSpace Oris Space to use\n', '   * @param _k1 address of K1 wallet\n', '   */\n', '  function JustPriceProtocol (\n', '    OrgonToken _orgonToken, OrisSpace _orisSpace, address _k1)\n', '  public {\n', '    orgonToken = _orgonToken;\n', '    orisSpace = _orisSpace;\n', '    k1 = _k1;\n', '  }\n', '\n', '  /**\n', '   * When called with no data does the same as buyTokens ().\n', '   */\n', '  function () public payable {\n', '    require (msg.data.length == 0);\n', '\n', '    buyTokens ();\n', '  }\n', '\n', '  /**\n', '   * Buy tokens.\n', '   */\n', '  function buyTokens () public payable {\n', '    require (msg.value > 0);\n', '\n', '    updateStage ();\n', '\n', '    if (stage == Stage.RESERVE)\n', '      buyTokensReserve ();\n', '    else if (stage == Stage.GROWTH || stage == Stage.LIFE)\n', '      buyTokensGrowthLife ();\n', '    else revert (); // No buying in current stage\n', '  }\n', '\n', '  /**\n', '   * Sell tokens.\n', '   *\n', '   * @param _value number of tokens to sell\n', '   */\n', '  function sellTokens (uint256 _value) public {\n', '    require (_value > 0);\n', '    require (_value < TWO_128);\n', '\n', '    updateStage ();\n', '    require (stage == Stage.LIFE);\n', '\n', '    assert (reserveAmount < TWO_128);\n', '    uint256 totalSupply = orgonToken.totalSupply ();\n', '    require (totalSupply < TWO_128);\n', '\n', '    require (_value <= totalSupply);\n', '\n', '    uint256 toPay = safeMul (\n', '      reserveAmount,\n', '      safeSub (\n', '        TWO_128,\n', '        pow_10 (safeSub (TWO_128, (_value << 128) / totalSupply)))) >> 128;\n', '\n', '    require (orgonToken.transferFrom (msg.sender, this, _value));\n', '    require (orgonToken.burnTokens (_value));\n', '\n', '    reserveAmount = safeSub (reserveAmount, toPay);\n', '\n', '    msg.sender.transfer (toPay);\n', '  }\n', '\n', '  /**\n', '   * Deliver tokens sold during "reserve" stage to corresponding investors.\n', '   *\n', '   * @param _investors addresses of investors to deliver tokens to\n', '   */\n', '  function deliver (address [] _investors) public {\n', '    updateStage ();\n', '    require (\n', '      stage == Stage.BEFORE_GROWTH ||\n', '      stage == Stage.GROWTH ||\n', '      stage == Stage.LIFE);\n', '\n', '    for (uint256 i = 0; i < _investors.length; i++) {\n', '      address investorAddress = _investors [i];\n', '      Investor storage investor = investors [investorAddress];\n', '\n', '      uint256 toDeliver = investor.tokensBought;\n', '      investor.tokensBought = 0;\n', '      investor.etherInvested = 0;\n', '\n', '      if (toDeliver > 0) {\n', '        require (orgonToken.transfer (investorAddress, toDeliver));\n', '        reserveTokensDelivered = safeAdd (reserveTokensDelivered, toDeliver);\n', '\n', '        Delivery (investorAddress, toDeliver);\n', '      }\n', '    }\n', '\n', '    if (stage == Stage.BEFORE_GROWTH &&\n', '      safeMul (reserveTokensDelivered, GROWTH_MIN_DELIVERED_DENOMINATIOR) >=\n', '        safeMul (reserveTokensSold, GROWTH_MIN_DELIVERED_NUMERATOR)) {\n', '      stage = Stage.GROWTH;\n', '      growthDeadline = currentTime () + GROWTH_MAX_DURATION;\n', '      feeChangeEnableTime = currentTime () + FEE_CHANGE_DELAY;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Refund investors who bought tokens during "reserve" stage.\n', '   *\n', '   * @param _investors addresses of investors to refund\n', '   */\n', '  function refund (address [] _investors) public {\n', '    updateStage ();\n', '    require (stage == Stage.REFUND);\n', '\n', '    for (uint256 i = 0; i < _investors.length; i++) {\n', '      address investorAddress = _investors [i];\n', '      Investor storage investor = investors [investorAddress];\n', '\n', '      uint256 toBurn = investor.tokensBought;\n', '      uint256 toRefund = investor.etherInvested;\n', '\n', '      investor.tokensBought = 0;\n', '      investor.etherInvested = 0;\n', '\n', '      if (toBurn > 0)\n', '        require (orgonToken.burnTokens (toBurn));\n', '\n', '      if (toRefund > 0) {\n', '        investorAddress.transfer (toRefund);\n', '\n', '        Refund (investorAddress, toRefund);\n', '      }\n', '    }\n', '  }\n', '\n', '  function vote (address _newK1) public {\n', '    updateStage ();\n', '\n', '    require (stage == Stage.LIFE);\n', '    require (!k1Changed);\n', '\n', '    uint256 votesCount = voteNumbers [msg.sender];\n', '    if (votesCount > 0) {\n', '      address oldK1 = votes [msg.sender];\n', '      if (_newK1 != oldK1) {\n', '        if (oldK1 != address (0)) {\n', '          voteResults [oldK1] = safeSub (voteResults [oldK1], votesCount);\n', '\n', '          VoteRevocation (msg.sender, oldK1, votesCount);\n', '        }\n', '\n', '        votes [msg.sender] = _newK1;\n', '\n', '        if (_newK1 != address (0)) {\n', '          voteResults [_newK1] = safeAdd (voteResults [_newK1], votesCount);\n', '          Vote (msg.sender, _newK1, votesCount);\n', '\n', '          if (safeMul (voteResults [_newK1], REQUIRED_VOTES_DENOMINATOR) >=\n', '            safeMul (totalVotesNumber, REQUIRED_VOTES_NUMERATIOR)) {\n', '            k1 = _newK1;\n', '            k1Changed = true;\n', '\n', '            K1Change (_newK1);\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Set new fee numerator.\n', '   *\n', '   * @param _fee new fee numerator.\n', '   */\n', '  function setFee (uint256 _fee) public {\n', '    require (msg.sender == k1);\n', '\n', '    require (_fee >= MIN_FEE);\n', '    require (_fee <= MAX_FEE);\n', '\n', '    updateStage ();\n', '\n', '    require (stage == Stage.GROWTH || stage == Stage.LIFE);\n', '    require (currentTime () >= feeChangeEnableTime);\n', '\n', '    require (safeSub (_fee, 1) <= fee);\n', '    require (safeAdd (_fee, 1) >= fee);\n', '\n', '    if (fee != _fee) {\n', '      fee = _fee;\n', '\n', '      FeeChange (_fee);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get number of tokens bought by given investor during reserve stage that are\n', '   * not yet delivered to him.\n', '   *\n', '   * @param _investor address of investor to get number of outstanding tokens\n', '   *       for\n', '   * @return number of non-delivered tokens given investor bought during reserve\n', '   *         stage\n', '   */\n', '  function outstandingTokens (address _investor) public view returns (uint256) {\n', '    return investors [_investor].tokensBought;\n', '  }\n', '\n', '  /**\n', '   * Get current stage of Just Price Protocol.\n', '   *\n', '   * @param _currentTime current time in seconds since epoch\n', '   * @return current stage of Just Price Protocol\n', '   */\n', '  function getStage (uint256 _currentTime) public view returns (Stage) {\n', '    Stage currentStage = stage;\n', '\n', '    if (currentStage == Stage.BEFORE_RESERVE) {\n', '      if (_currentTime >= SALE_START_TIME)\n', '        currentStage = Stage.RESERVE;\n', '      else return currentStage;\n', '    }\n', '\n', '    if (currentStage == Stage.RESERVE) {\n', '      if (_currentTime >= RESERVE_DEADLINE) {\n', '        if (reserveAmount >= RESERVE_MIN_AMOUNT)\n', '          currentStage = Stage.BEFORE_GROWTH;\n', '        else currentStage = Stage.REFUND;\n', '      }\n', '\n', '      return currentStage;\n', '    }\n', '\n', '    if (currentStage == Stage.GROWTH) {\n', '      if (_currentTime >= growthDeadline) {\n', '        currentStage = Stage.LIFE;\n', '      }\n', '    }\n', '\n', '    return currentStage;\n', '  }\n', '\n', '  /**\n', '   * Return total number of votes eligible for choosing new K1 address.\n', '   *\n', '   * @return total number of votes eligible for choosing new K1 address\n', '   */\n', '  function totalEligibleVotes () public view returns (uint256) {\n', '    return totalVotesNumber;\n', '  }\n', '\n', '  /**\n', '   * Return number of votes eligible for choosing new K1 address given investor\n', '   * has.\n', '   *\n', '   * @param _investor address of investor to get number of eligible votes of\n', '   * @return Number of eligible votes given investor has\n', '   */\n', '  function eligibleVotes (address _investor) public view returns (uint256) {\n', '    return voteNumbers [_investor];\n', '  }\n', '\n', '  /**\n', '   * Get number of votes for the given new K1 address.\n', '   *\n', '   * @param _newK1 new K1 address to get number of votes for\n', '   * @return number of votes for the given new K1 address\n', '   */\n', '  function votesFor (address _newK1) public view returns (uint256) {\n', '    return voteResults [_newK1];\n', '  }\n', '\n', '  /**\n', '   * Buy tokens during "reserve" stage.\n', '   */\n', '  function buyTokensReserve () internal {\n', '    require (stage == Stage.RESERVE);\n', '\n', '    uint256 toBuy = 0;\n', '    uint256 toRefund = msg.value;\n', '    uint256 etherInvested = 0;\n', '    uint256 tokens;\n', '    uint256 tokensValue;\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_1) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_1, reserveAmount)) /\n', '        RESERVE_PRICE_1;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_1);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_2) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_2, reserveAmount)) /\n', '        RESERVE_PRICE_2;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_2);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_3) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_3, reserveAmount)) /\n', '        RESERVE_PRICE_3;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_3);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_4) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_4, reserveAmount)) /\n', '        RESERVE_PRICE_4;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_4);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_5) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_5, reserveAmount)) /\n', '        RESERVE_PRICE_5;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_5);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_6) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_6, reserveAmount)) /\n', '        RESERVE_PRICE_6;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_6);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_7) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_7, reserveAmount)) /\n', '        RESERVE_PRICE_7;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_7);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (reserveAmount < RESERVE_THRESHOLD_8) {\n', '      tokens = min (\n', '        toRefund,\n', '        safeSub (RESERVE_THRESHOLD_8, reserveAmount)) /\n', '        RESERVE_PRICE_8;\n', '\n', '      if (tokens > 0) {\n', '        tokensValue = safeMul (tokens, RESERVE_PRICE_8);\n', '\n', '        toBuy = safeAdd (toBuy, tokens);\n', '        toRefund = safeSub (toRefund, tokensValue);\n', '        etherInvested = safeAdd (etherInvested, tokensValue);\n', '        reserveAmount = safeAdd (reserveAmount, tokensValue);\n', '      }\n', '    }\n', '\n', '    if (toBuy > 0) {\n', '      Investor storage investor = investors [msg.sender];\n', '\n', '      investor.tokensBought = safeAdd (\n', '        investor.tokensBought, toBuy);\n', '\n', '      investor.etherInvested = safeAdd (\n', '        investor.etherInvested, etherInvested);\n', '\n', '      reserveTokensSold = safeAdd (reserveTokensSold, toBuy);\n', '\n', '      require (orgonToken.createTokens (toBuy));\n', '\n', '      voteNumbers [msg.sender] = safeAdd (voteNumbers [msg.sender], toBuy);\n', '      totalVotesNumber = safeAdd (totalVotesNumber, toBuy);\n', '\n', '      Investment (msg.sender, etherInvested, toBuy);\n', '\n', '      if (safeSub (RESERVE_THRESHOLD_8, reserveAmount) <\n', '        RESERVE_PRICE_8) {\n', '\n', '        orisSpace.start (0);\n', '\n', '        stage = Stage.BEFORE_GROWTH;\n', '      }\n', '    }\n', '\n', '    if (toRefund > 0)\n', '      msg.sender.transfer (toRefund);\n', '  }\n', '\n', '  /**\n', '   * Buy tokens during "growth" or "life" stage.\n', '   */\n', '  function buyTokensGrowthLife () internal {\n', '    require (stage == Stage.GROWTH || stage == Stage.LIFE);\n', '\n', '    require (msg.value < TWO_128);\n', '\n', '    uint256 totalSupply = orgonToken.totalSupply ();\n', '    assert (totalSupply < TWO_128);\n', '\n', '    uint256 toBuy = safeMul (\n', '      totalSupply,\n', '      safeSub (\n', '        root_10 (safeAdd (TWO_128, (msg.value << 128) / reserveAmount)),\n', '        TWO_128)) >> 128;\n', '\n', '    reserveAmount = safeAdd (reserveAmount, msg.value);\n', '    require (reserveAmount < TWO_128);\n', '\n', '    if (toBuy > 0) {\n', '      require (orgonToken.createTokens (toBuy));\n', '      require (orgonToken.totalSupply () < TWO_128);\n', '\n', '      uint256 feeAmount = safeMul (toBuy, fee) / FEE_DENOMINATOR;\n', '\n', '      require (orgonToken.transfer (msg.sender, safeSub (toBuy, feeAmount)));\n', '\n', '      if (feeAmount > 0)\n', '        require (orgonToken.transfer (k1, feeAmount));\n', '\n', '      if (stage == Stage.GROWTH) {\n', '        uint256 votesCount = toBuy;\n', '\n', '        totalSupply = orgonToken.totalSupply ();\n', '        if (totalSupply >= GROWTH_MAX_TOKENS) {\n', '          stage = Stage.LIFE;\n', '          votesCount = safeSub (\n', '            votesCount,\n', '            safeSub (totalSupply, GROWTH_MAX_TOKENS));\n', '        }\n', '\n', '        voteNumbers [msg.sender] =\n', '          safeAdd (voteNumbers [msg.sender], votesCount);\n', '        totalVotesNumber = safeAdd (totalVotesNumber, votesCount);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Update stage of Just Price Protocol and return updated stage.\n', '   *\n', '   * @return updated stage of Just Price Protocol\n', '   */\n', '  function updateStage () internal returns (Stage) {\n', '    Stage currentStage = getStage (currentTime ());\n', '    if (stage != currentStage) {\n', '      if (currentStage == Stage.BEFORE_GROWTH) {\n', '        // "Reserve" stage deadline reached and minimum amount collected\n', '        uint256 tokensToBurn =\n', '          safeSub (\n', '            safeAdd (\n', '              safeAdd (\n', '                safeSub (RESERVE_MAX_AMOUNT, reserveAmount),\n', '                safeSub (RESERVE_RATIO, 1)) /\n', '                RESERVE_RATIO,\n', '              reserveTokensSold),\n', '            RESERVE_MAX_TOKENS);\n', '\n', '        orisSpace.start (tokensToBurn);\n', '        if (tokensToBurn > 0)\n', '          require (orgonToken.burnTokens (tokensToBurn));\n', '      }\n', '\n', '      stage = currentStage;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get minimum of two values.\n', '   *\n', '   * @param x first value\n', '   * @param y second value\n', '   * @return minimum of two values\n', '   */\n', '  function min (uint256 x, uint256 y) internal pure returns (uint256) {\n', '    return x < y ? x : y;\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^128 * (x / 2^128)^(1/10).\n', '   *\n', '   * @param x parameter x\n', '   * @return 2^128 * (x / 2^128)^(1/10)\n', '   */\n', '  function root_10 (uint256 x) internal pure returns (uint256 y) {\n', '    uint256 shift = 0;\n', '\n', '    while (x > TWO_128) {\n', '      x >>= 10;\n', '      shift += 1;\n', '    }\n', '\n', '    if (x == TWO_128 || x == 0) y = x;\n', '    else {\n', '      uint256 x128 = x << 128;\n', '      y = TWO_128;\n', '\n', '      uint256 t = x;\n', '      while (true) {\n', '        t <<= 10;\n', '        if (t < TWO_128) y >>= 1;\n', '        else break;\n', '      }\n', '\n', '      for (uint256 i = 0; i < 16; i++) {\n', '        uint256 y9;\n', '\n', '        if (y == TWO_128) y9 = y;\n', '        else {\n', '          uint256 y2 = (y * y) >> 128;\n', '          uint256 y4 = (y2 * y2) >> 128;\n', '          uint256 y8 = (y4 * y4) >> 128;\n', '          y9 = (y * y8) >> 128;\n', '        }\n', '\n', '        y = (9 * y + x128 / y9) / 10;\n', '\n', '        assert (y <= TWO_128);\n', '      }\n', '    }\n', '\n', '    y <<= shift;\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^128 * (x / 2^128)^10.\n', '   *\n', '   * @param x parameter x\n', '   * @return 2^128 * (x / 2^128)^10\n', '   */\n', '  function pow_10 (uint256 x) internal pure returns (uint256) {\n', '    require (x <= TWO_128);\n', '\n', '    if (x == TWO_128) return x;\n', '    else {\n', '      uint256 x2 = (x * x) >> 128;\n', '      uint256 x4 = (x2 * x2) >> 128;\n', '      uint256 x8 = (x4 * x4) >> 128;\n', '      return (x2 * x8) >> 128;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Get current time in seconds since epoch.\n', '   *\n', '   * @return current time in seconds since epoch\n', '   */\n', '  function currentTime () internal view returns (uint256) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  /**\n', '   * Just Price Protocol stages.\n', '   * +----------------+\n', '   * | BEFORE_RESERVE |\n', '   * +----------------+\n', '   *         |\n', '   *         | Sale start time reached\n', '   *         V\n', '   *    +---------+   Reserve deadline reached\n', '   *    | RESERVE |-------------------------------+\n', '   *    +---------+                               |\n', '   *         |                                    |\n', '   *         | 72500 ETH collected                |\n', '   *         V                                    |\n', '   * +---------------+ 39013,174672 ETH collected |\n', '   * | BEFORE_GROWTH |<---------------------------O\n', '   * +---------------+                            |\n', '   *         |                                    | 39013,174672 ETH not collected\n', '   *         | 80% of tokens delivered            |\n', '   *         V                                    V\n', '   *  +------------+                         +--------+\n', '   *  |   GROWTH   |                         | REFUND |\n', '   *  +------------+                         +--------+\n', '   *         |\n', '   *         | 1,500,000,000 tokens issued or 365 days passed since start of "GROWTH" stage\n', '   *         V\n', '   *     +------+\n', '   *     | LIFE |\n', '   *     +------+\n', '   */\n', '  enum Stage {\n', '    BEFORE_RESERVE, // Before start of "Reserve" stage\n', '    RESERVE, // "Reserve" stage\n', '    BEFORE_GROWTH, // Between "Reserve" and "Growth" stages\n', '    GROWTH, // "Grows" stage\n', '    LIFE, // "Life" stage\n', '    REFUND // "Refund" stage\n', '  }\n', '\n', '  /**\n', '   * Orgon Token smart contract.\n', '   */\n', '  OrgonToken internal orgonToken;\n', '\n', '  /**\n', '   * Oris Space spart contract.\n', '   */\n', '  OrisSpace internal orisSpace;\n', '\n', '  /**\n', '   * Address of K1 smart contract.\n', '   */\n', '  address internal k1;\n', '\n', '  /**\n', '   * Last known stage of Just Price Protocol\n', '   */\n', '  Stage internal stage = Stage.BEFORE_RESERVE;\n', '\n', '  /**\n', '   * Amount of ether in reserve.\n', '   */\n', '  uint256 internal reserveAmount;\n', '\n', '  /**\n', '   * Number of tokens sold during "reserve" stage.\n', '   */\n', '  uint256 internal reserveTokensSold;\n', '\n', '  /**\n', '   * Number of tokens sold during "reserve" stage that were already delivered to\n', '   * investors.\n', '   */\n', '  uint256 internal reserveTokensDelivered;\n', '\n', '  /**\n', '   * "Growth" stage deadline.\n', '   */\n', '  uint256 internal growthDeadline;\n', '\n', '  /**\n', '   * Mapping from address of a person who bought some tokens during "reserve"\n', '   * stage to information about how many tokens he bought to how much ether\n', '   * invested.\n', '   */\n', '  mapping (address => Investor) internal investors;\n', '\n', '  /**\n', '   * Mapping from address of an investor to the number of votes this investor\n', '   * has.\n', '   */\n', '  mapping (address => uint256) internal voteNumbers;\n', '\n', '  /**\n', '   * Mapping from address of an investor to the new K1 address this investor\n', '   * voted for.\n', '   */\n', '  mapping (address => address) internal votes;\n', '\n', '  /**\n', '   * Mapping from suggested new K1 address to the number of votes for this\n', '   * address.\n', '   */\n', '  mapping (address => uint256) internal voteResults;\n', '\n', '  /**\n', '   * Total number of eligible votes.\n', '   */\n', '  uint256 internal totalVotesNumber;\n', '\n', '  /**\n', '   * Whether K1 address was already changed via voting.\n', '   */\n', '  bool internal k1Changed = false;\n', '\n', '  /**\n', '   * Fee enumerator.  (2 / 20000 = 0.0001);\n', '   */\n', '  uint256 internal fee = 2;\n', '\n', '  /**\n', '   * Time when fee changing is enabled.\n', '   */\n', '  uint256 internal feeChangeEnableTime;\n', '\n', '  /**\n', '   * Encapsulates information about a person who bought some tokens during\n', '   * "reserve" stage.\n', '   */\n', '  struct Investor {\n', '    /**\n', '     * Number of tokens bought during reserve stage.\n', '     */\n', '    uint256 tokensBought;\n', '\n', '    /**\n', '     * Ether invested during reserve stage.\n', '     */\n', '    uint256 etherInvested;\n', '  }\n', '\n', '  /**\n', '   * Logged when investor invested some ether during "reserve" stage.\n', '   *\n', '   * @param investor address of investor\n', '   * @param value amount of ether invested\n', '   * @param amount number of tokens issued for investor\n', '   */\n', '  event Investment (address indexed investor, uint256 value, uint256 amount);\n', '\n', '  /**\n', '   * Logged when tokens bought at "reserve" stage were delivered to investor.\n', '   *\n', '   * @param investor address of investor whom tokens were delivered to\n', '   * @param amount number of tokens delivered\n', '   */\n', '  event Delivery (address indexed investor, uint256 amount);\n', '\n', '  /**\n', '   * Logged when investment was refunded.\n', '   *\n', '   * @param investor address of investor whose investment was refunded\n', '   * @param value amount of ether refunded\n', '   */\n', '  event Refund (address indexed investor, uint256 value);\n', '\n', '  /**\n', '   * Logged when K1 address was changed.\n', '   *\n', '   * @param k1 new K1 address\n', '   */\n', '  event K1Change (address k1);\n', '\n', '  /**\n', '   * Logged when investor voted for new K1 address.\n', '   * \n', '   * @param investor investor who voted for new K1 address\n', '   * @param newK1 new K1 address investor voted for\n', '   * @param votes number of votes investor has\n', '   */\n', '  event Vote (address indexed investor, address indexed newK1, uint256 votes);\n', '\n', '  /**\n', '   * Logged when investor revoked vote for new K1 address.\n', '   * \n', '   * @param investor investor who revoked vote for new K1 address\n', '   * @param newK1 new K1 address investor revoked vote for\n', '   * @param votes number of votes investor has\n', '   */\n', '  event VoteRevocation (\n', '    address indexed investor, address indexed newK1, uint256 votes);\n', '\n', '  /**\n', '   * Logged when fee was changed.\n', '   *\n', '   * @param fee new fee numerator\n', '   */\n', '  event FeeChange (uint256 fee);\n', '}']
