['pragma solidity 0.4.20;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        assert(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        assert(b > 0);\n', '        c = a / b;\n', '        assert(a == b * c + a % b);\n', '    }\n', '}\n', '\n', 'contract AcreConfig {\n', '    using SafeMath for uint;\n', '    \n', '    uint internal constant TIME_FACTOR = 1 minutes;\n', '\n', '    // Ownable\n', '    uint internal constant OWNERSHIP_DURATION_TIME = 7; // 7 days\n', '    \n', '    // MultiOwnable\n', '    uint8 internal constant MULTI_OWNER_COUNT = 5; // 5 accounts, exclude master\n', '    \n', '    // Lockable\n', '    uint internal constant LOCKUP_DURATION_TIME = 365; // 365 days\n', '    \n', '    // AcreToken\n', '    string internal constant TOKEN_NAME            = "TAA";\n', '    string internal constant TOKEN_SYMBOL          = "TAA";\n', '    uint8  internal constant TOKEN_DECIMALS        = 18;\n', '    \n', '    uint   internal constant INITIAL_SUPPLY        =   1*1e8 * 10 ** uint(TOKEN_DECIMALS); // supply\n', '    uint   internal constant CAPITAL_SUPPLY        =  31*1e6 * 10 ** uint(TOKEN_DECIMALS); // supply\n', '    uint   internal constant PRE_PAYMENT_SUPPLY    =  19*1e6 * 10 ** uint(TOKEN_DECIMALS); // supply\n', '    uint   internal constant MAX_MINING_SUPPLY     =   4*1e8 * 10 ** uint(TOKEN_DECIMALS); // supply\n', '    \n', '    // Sale\n', '    uint internal constant MIN_ETHER               = 1*1e17; // 0.1 ether\n', '    uint internal constant EXCHANGE_RATE           = 1000;   // 1 eth = 1000 acre\n', '    uint internal constant PRESALE_DURATION_TIME   = 15;     // 15 days \n', '    uint internal constant CROWDSALE_DURATION_TIME = 21;     // 21 days\n', '    \n', '    // helper\n', '    function getDays(uint _time) internal pure returns(uint) {\n', '        return SafeMath.div(_time, 1 days);\n', '    }\n', '    \n', '    function getHours(uint _time) internal pure returns(uint) {\n', '        return SafeMath.div(_time, 1 hours);\n', '    }\n', '    \n', '    function getMinutes(uint _time) internal pure returns(uint) {\n', '        return SafeMath.div(_time, 1 minutes);\n', '    }\n', '}\n', '\n', 'contract Ownable is AcreConfig {\n', '    address public owner;\n', '    address public reservedOwner;\n', '    uint public ownershipDeadline;\n', '    \n', '    event ReserveOwnership(address indexed oldOwner, address indexed newOwner);\n', '    event ConfirmOwnership(address indexed oldOwner, address indexed newOwner);\n', '    event CancelOwnership(address indexed oldOwner, address indexed newOwner);\n', '    \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function reserveOwnership(address newOwner) onlyOwner public returns (bool success) {\n', '        require(newOwner != address(0));\n', '        ReserveOwnership(owner, newOwner);\n', '        reservedOwner = newOwner;\n', '\t\townershipDeadline = SafeMath.add(now, SafeMath.mul(OWNERSHIP_DURATION_TIME, TIME_FACTOR));\n', '        return true;\n', '    }\n', '    \n', '    function confirmOwnership() onlyOwner public returns (bool success) {\n', '        require(reservedOwner != address(0));\n', '        require(now > ownershipDeadline);\n', '        ConfirmOwnership(owner, reservedOwner);\n', '        owner = reservedOwner;\n', '        reservedOwner = address(0);\n', '        return true;\n', '    }\n', '    \n', '    function cancelOwnership() onlyOwner public returns (bool success) {\n', '        require(reservedOwner != address(0));\n', '        CancelOwnership(owner, reservedOwner);\n', '        reservedOwner = address(0);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract MultiOwnable is Ownable {\n', '    address[] public owners;\n', '    \n', '    event GrantOwners(address indexed owner);\n', '    event RevokeOwners(address indexed owner);\n', '    \n', '    modifier onlyMutiOwners {\n', '        require(isExistedOwner(msg.sender));\n', '        _;\n', '    }\n', '    \n', '    modifier onlyManagers {\n', '        require(isManageable(msg.sender));\n', '        _;\n', '    }\n', '    \n', '    function MultiOwnable() public {\n', '        owners.length = MULTI_OWNER_COUNT;\n', '    }\n', '    \n', '    function grantOwners(address _owner) onlyOwner public returns (bool success) {\n', '        require(!isExistedOwner(_owner));\n', '        require(isEmptyOwner());\n', '        owners[getEmptyIndex()] = _owner;\n', '        GrantOwners(_owner);\n', '        return true;\n', '    }\n', '\n', '    function revokeOwners(address _owner) onlyOwner public returns (bool success) {\n', '        require(isExistedOwner(_owner));\n', '        owners[getOwnerIndex(_owner)] = address(0);\n', '        RevokeOwners(_owner);\n', '        return true;\n', '    }\n', '    \n', '    // helper\n', '    function isManageable(address _owner) internal constant returns (bool) {\n', '        return isExistedOwner(_owner) || owner == _owner;\n', '    }\n', '    \n', '    function isExistedOwner(address _owner) internal constant returns (bool) {\n', '        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\n', '            if(owners[i] == _owner) {\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getOwnerIndex(address _owner) internal constant returns (uint) {\n', '        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\n', '            if(owners[i] == _owner) {\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function isEmptyOwner() internal constant returns (bool) {\n', '        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\n', '            if(owners[i] == address(0)) {\n', '                return true;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getEmptyIndex() internal constant returns (uint) {\n', '        for(uint8 i = 0; i < MULTI_OWNER_COUNT; ++i) {\n', '            if(owners[i] == address(0)) {\n', '                return i;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Pausable is MultiOwnable {\n', '    bool public paused = false;\n', '    \n', '    event Pause();\n', '    event Unpause();\n', '    \n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '    \n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '    \n', '    modifier whenConditionalPassing() {\n', '        if(!isManageable(msg.sender)) {\n', '            require(!paused);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function pause() onlyManagers whenNotPaused public returns (bool success) {\n', '        paused = true;\n', '        Pause();\n', '        return true;\n', '    }\n', '  \n', '    function unpause() onlyManagers whenPaused public returns (bool success) {\n', '        paused = false;\n', '        Unpause();\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Lockable is Pausable {\n', '    mapping (address => uint) public locked;\n', '    \n', '    event Lockup(address indexed target, uint startTime, uint deadline);\n', '    \n', '    function lockup(address _target) onlyOwner public returns (bool success) {\n', '\t    require(!isManageable(_target));\n', '        locked[_target] = SafeMath.add(now, SafeMath.mul(LOCKUP_DURATION_TIME, TIME_FACTOR));\n', '        Lockup(_target, now, locked[_target]);\n', '        return true;\n', '    }\n', '    \n', '    // helper\n', '    function isLockup(address _target) internal constant returns (bool) {\n', '        if(now <= locked[_target])\n', '            return true;\n', '    }\n', '}\n', '\n', 'interface tokenRecipient { \n', '    function receiveApproval(address _from, uint _value, address _token, bytes _extraData) external; \n', '}\n', '\n', 'contract TokenERC20 {\n', '    using SafeMath for uint;\n', '    \n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    \n', '    uint public totalSupply;\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '\n', '    event ERC20Token(address indexed owner, string name, string symbol, uint8 decimals, uint supply);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event TransferFrom(address indexed from, address indexed to, address indexed spender, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    \n', '    function TokenERC20(\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals,\n', '        uint _initialSupply\n', '    ) public {\n', '        name = _tokenName;\n', '        symbol = _tokenSymbol;\n', '        decimals = _tokenDecimals;\n', '        \n', '        totalSupply = _initialSupply;\n', '        balanceOf[msg.sender] = totalSupply;\n', '        \n', '        ERC20Token(msg.sender, name, symbol, decimals, totalSupply);\n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balanceOf[_from] >= _value);\n', '        require(SafeMath.add(balanceOf[_to], _value) > balanceOf[_to]);\n', '        uint previousBalances = SafeMath.add(balanceOf[_from], balanceOf[_to]);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        Transfer(_from, _to, _value);\n', '        assert(SafeMath.add(balanceOf[_from], balanceOf[_to]) == previousBalances);\n', '        return true;\n', '    }\n', '    \n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        TransferFrom(_from, _to, msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract AcreToken is Lockable, TokenERC20 {\n', '    string public version = &#39;1.0&#39;;\n', '    \n', '    address public companyCapital;\n', '    address public prePayment;\n', '    \n', '    uint public totalMineSupply;\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    event FrozenAccount(address indexed target, bool frozen);\n', '    event Burn(address indexed owner, uint value);\n', '    event Mining(address indexed recipient, uint value);\n', '    event WithdrawContractToken(address indexed owner, uint value);\n', '    \n', '    function AcreToken(address _companyCapital, address _prePayment) TokenERC20(TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, INITIAL_SUPPLY) public {\n', '        require(_companyCapital != address(0));\n', '        require(_prePayment != address(0));\n', '        companyCapital = _companyCapital;\n', '        prePayment = _prePayment;\n', '        transfer(companyCapital, CAPITAL_SUPPLY);\n', '        transfer(prePayment, PRE_PAYMENT_SUPPLY);\n', '        lockup(prePayment);\n', '        pause(); \n', '    }\n', '\n', '    function _transfer(address _from, address _to, uint _value) whenConditionalPassing internal returns (bool success) {\n', '        require(!frozenAccount[_from]); // freeze                     \n', '        require(!frozenAccount[_to]);\n', '        require(!isLockup(_from));      // lockup\n', '        require(!isLockup(_to));\n', '        return super._transfer(_from, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(!frozenAccount[msg.sender]); // freeze\n', '        require(!isLockup(msg.sender));      // lockup\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    function freezeAccount(address _target) onlyManagers public returns (bool success) {\n', '        require(!isManageable(_target));\n', '        require(!frozenAccount[_target]);\n', '        frozenAccount[_target] = true;\n', '        FrozenAccount(_target, true);\n', '        return true;\n', '    }\n', '    \n', '    function unfreezeAccount(address _target) onlyManagers public returns (bool success) {\n', '        require(frozenAccount[_target]);\n', '        frozenAccount[_target] = false;\n', '        FrozenAccount(_target, false);\n', '        return true;\n', '    }\n', '    \n', '    function burn(uint _value) onlyManagers public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);   \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            \n', '        totalSupply = totalSupply.sub(_value);                      \n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function mining(address _recipient, uint _value) onlyManagers public returns (bool success) {\n', '        require(_recipient != address(0));\n', '        require(!frozenAccount[_recipient]); // freeze\n', '        require(!isLockup(_recipient));      // lockup\n', '        require(SafeMath.add(totalMineSupply, _value) <= MAX_MINING_SUPPLY);\n', '        balanceOf[_recipient] = balanceOf[_recipient].add(_value);\n', '        totalSupply = totalSupply.add(_value);\n', '        totalMineSupply = totalMineSupply.add(_value);\n', '        Mining(_recipient, _value);\n', '        return true;\n', '    }\n', '    \n', '    function withdrawContractToken(uint _value) onlyManagers public returns (bool success) {\n', '        _transfer(this, msg.sender, _value);\n', '        WithdrawContractToken(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function getContractBalanceOf() public constant returns(uint blance) {\n', '        blance = balanceOf[this];\n', '    }\n', '    \n', '    function getRemainingMineSupply() public constant returns(uint supply) {\n', '        supply = MAX_MINING_SUPPLY - totalMineSupply;\n', '    }\n', '    \n', '    function () public { revert(); }\n', '}\n', '\n', 'contract AcreSale is MultiOwnable {\n', '    uint public saleDeadline;\n', '    uint public startSaleTime;\n', '    uint public softCapToken;\n', '    uint public hardCapToken;\n', '    uint public soldToken;\n', '    uint public receivedEther;\n', '    address public sendEther;\n', '    AcreToken public tokenReward;\n', '    bool public fundingGoalReached = false;\n', '    bool public saleOpened = false;\n', '    \n', '    Payment public kyc;\n', '    Payment public refund;\n', '    Payment public withdrawal;\n', '\n', '    mapping(uint=>address) public indexedFunders;\n', '    mapping(address => Order) public orders;\n', '    uint public funderCount;\n', '    \n', '    event StartSale(uint softCapToken, uint hardCapToken, uint minEther, uint exchangeRate, uint startTime, uint deadline);\n', '    event ReservedToken(address indexed funder, uint amount, uint token, uint bonusRate);\n', '    event WithdrawFunder(address indexed funder, uint value);\n', '    event WithdrawContractToken(address indexed owner, uint value);\n', '    event CheckGoalReached(uint raisedAmount, uint raisedToken, bool reached);\n', '    event CheckOrderstate(address indexed funder, eOrderstate oldState, eOrderstate newState);\n', '    \n', '    enum eOrderstate { NONE, KYC, REFUND }\n', '    \n', '    struct Order {\n', '        eOrderstate state;\n', '        uint paymentEther;\n', '        uint reservedToken;\n', '        bool withdrawn;\n', '    }\n', '    \n', '    struct Payment {\n', '        uint token;\n', '        uint eth;\n', '        uint count;\n', '    }\n', '\n', '    modifier afterSaleDeadline { \n', '        require(now > saleDeadline); \n', '        _; \n', '    }\n', '    \n', '    function AcreSale(\n', '        address _sendEther,\n', '        uint _softCapToken,\n', '        uint _hardCapToken,\n', '        AcreToken _addressOfTokenUsedAsReward\n', '    ) public {\n', '        require(_sendEther != address(0));\n', '        require(_addressOfTokenUsedAsReward != address(0));\n', '        require(_softCapToken > 0 && _softCapToken <= _hardCapToken);\n', '        sendEther = _sendEther;\n', '        softCapToken = _softCapToken * 10 ** uint(TOKEN_DECIMALS);\n', '        hardCapToken = _hardCapToken * 10 ** uint(TOKEN_DECIMALS);\n', '        tokenReward = AcreToken(_addressOfTokenUsedAsReward);\n', '    }\n', '    \n', '    function startSale(uint _durationTime) onlyManagers internal {\n', '        require(softCapToken > 0 && softCapToken <= hardCapToken);\n', '        require(hardCapToken > 0 && hardCapToken <= tokenReward.balanceOf(this));\n', '        require(_durationTime > 0);\n', '        require(startSaleTime == 0);\n', '\n', '        startSaleTime = now;\n', '        saleDeadline = SafeMath.add(startSaleTime, SafeMath.mul(_durationTime, TIME_FACTOR));\n', '        saleOpened = true;\n', '        \n', '        StartSale(softCapToken, hardCapToken, MIN_ETHER, EXCHANGE_RATE, startSaleTime, saleDeadline);\n', '    }\n', '    \n', '    // get\n', '    function getRemainingSellingTime() public constant returns(uint remainingTime) {\n', '        if(now <= saleDeadline) {\n', '            remainingTime = getMinutes(SafeMath.sub(saleDeadline, now));\n', '        }\n', '    }\n', '    \n', '    function getRemainingSellingToken() public constant returns(uint remainingToken) {\n', '        remainingToken = SafeMath.sub(hardCapToken, soldToken);\n', '    }\n', '    \n', '    function getSoftcapReached() public constant returns(bool reachedSoftcap) {\n', '        reachedSoftcap = soldToken >= softCapToken;\n', '    }\n', '    \n', '    function getContractBalanceOf() public constant returns(uint blance) {\n', '        blance = tokenReward.balanceOf(this);\n', '    }\n', '    \n', '    function getCurrentBonusRate() public constant returns(uint8 bonusRate);\n', '    \n', '    // check\n', '    function checkGoalReached() onlyManagers afterSaleDeadline public {\n', '        if(saleOpened) {\n', '            if(getSoftcapReached()) {\n', '                fundingGoalReached = true;\n', '            }\n', '            saleOpened = false;\n', '            CheckGoalReached(receivedEther, soldToken, fundingGoalReached);\n', '        }\n', '    }\n', '    \n', '    function checkKYC(address _funder) onlyManagers afterSaleDeadline public {\n', '        require(!saleOpened);\n', '        require(orders[_funder].reservedToken > 0);\n', '        require(orders[_funder].state != eOrderstate.KYC);\n', '        require(!orders[_funder].withdrawn);\n', '        \n', '        eOrderstate oldState = orders[_funder].state;\n', '        \n', '        // old, decrease\n', '        if(oldState == eOrderstate.REFUND) {\n', '            refund.token = refund.token.sub(orders[_funder].reservedToken);\n', '            refund.eth   = refund.eth.sub(orders[_funder].paymentEther);\n', '            refund.count = refund.count.sub(1);\n', '        }\n', '        \n', '        // state\n', '        orders[_funder].state = eOrderstate.KYC;\n', '        kyc.token = kyc.token.add(orders[_funder].reservedToken);\n', '        kyc.eth   = kyc.eth.add(orders[_funder].paymentEther);\n', '        kyc.count = kyc.count.add(1);\n', '        CheckOrderstate(_funder, oldState, eOrderstate.KYC);\n', '    }\n', '    \n', '    function checkRefund(address _funder) onlyManagers afterSaleDeadline public {\n', '        require(!saleOpened);\n', '        require(orders[_funder].reservedToken > 0);\n', '        require(orders[_funder].state != eOrderstate.REFUND);\n', '        require(!orders[_funder].withdrawn);\n', '        \n', '        eOrderstate oldState = orders[_funder].state;\n', '        \n', '        // old, decrease\n', '        if(oldState == eOrderstate.KYC) {\n', '            kyc.token = kyc.token.sub(orders[_funder].reservedToken);\n', '            kyc.eth   = kyc.eth.sub(orders[_funder].paymentEther);\n', '            kyc.count = kyc.count.sub(1);\n', '        }\n', '        \n', '        // state\n', '        orders[_funder].state = eOrderstate.REFUND;\n', '        refund.token = refund.token.add(orders[_funder].reservedToken);\n', '        refund.eth   = refund.eth.add(orders[_funder].paymentEther);\n', '        refund.count = refund.count.add(1);\n', '        CheckOrderstate(_funder, oldState, eOrderstate.REFUND);\n', '    }\n', '    \n', '    // withdraw\n', '    function withdrawFunder(address _funder) onlyManagers afterSaleDeadline public {\n', '        require(!saleOpened);\n', '        require(fundingGoalReached);\n', '        require(orders[_funder].reservedToken > 0);\n', '        require(orders[_funder].state == eOrderstate.KYC);\n', '        require(!orders[_funder].withdrawn);\n', '        \n', '        // token\n', '        tokenReward.transfer(_funder, orders[_funder].reservedToken);\n', '        withdrawal.token = withdrawal.token.add(orders[_funder].reservedToken);\n', '        withdrawal.eth   = withdrawal.eth.add(orders[_funder].paymentEther);\n', '        withdrawal.count = withdrawal.count.add(1);\n', '        orders[_funder].withdrawn = true;\n', '        WithdrawFunder(_funder, orders[_funder].reservedToken);\n', '    }\n', '    \n', '    function withdrawContractToken(uint _value) onlyManagers public {\n', '        tokenReward.transfer(msg.sender, _value);\n', '        WithdrawContractToken(msg.sender, _value);\n', '    }\n', '    \n', '    // payable\n', '    function () payable public {\n', '        require(saleOpened);\n', '        require(now <= saleDeadline);\n', '        require(MIN_ETHER <= msg.value);\n', '        \n', '        uint amount = msg.value;\n', '        uint curBonusRate = getCurrentBonusRate();\n', '        uint token = (amount.mul(curBonusRate.add(100)).div(100)).mul(EXCHANGE_RATE);\n', '        \n', '        require(token > 0);\n', '        require(SafeMath.add(soldToken, token) <= hardCapToken);\n', '        \n', '        sendEther.transfer(amount);\n', '        \n', '        // funder info\n', '        if(orders[msg.sender].paymentEther == 0) {\n', '            indexedFunders[funderCount] = msg.sender;\n', '            funderCount = funderCount.add(1);\n', '            orders[msg.sender].state = eOrderstate.NONE;\n', '        }\n', '        \n', '        orders[msg.sender].paymentEther = orders[msg.sender].paymentEther.add(amount);\n', '        orders[msg.sender].reservedToken = orders[msg.sender].reservedToken.add(token);\n', '        receivedEther = receivedEther.add(amount);\n', '        soldToken = soldToken.add(token);\n', '        \n', '        ReservedToken(msg.sender, amount, token, curBonusRate);\n', '    }\n', '}\n', '\n', 'contract AcrePresale is AcreSale {\n', '    function AcrePresale(\n', '        address _sendEther,\n', '        uint _softCapToken,\n', '        uint _hardCapToken,\n', '        AcreToken _addressOfTokenUsedAsReward\n', '    ) AcreSale(\n', '        _sendEther,\n', '        _softCapToken, \n', '        _hardCapToken, \n', '        _addressOfTokenUsedAsReward) public {\n', '    }\n', '    \n', '    function startPresale() onlyManagers public {\n', '        startSale(PRESALE_DURATION_TIME);\n', '    }\n', '    \n', '    function getCurrentBonusRate() public constant returns(uint8 bonusRate) {\n', '        if      (now <= SafeMath.add(startSaleTime, SafeMath.mul( 7, TIME_FACTOR))) { bonusRate = 30; } // 7days  \n', '        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(15, TIME_FACTOR))) { bonusRate = 25; } // 8days\n', '        else                                                                        { bonusRate = 0; }  // \n', '    } \n', '}\n', '\n', 'contract AcreCrowdsale is AcreSale {\n', '    function AcreCrowdsale(\n', '        address _sendEther,\n', '        uint _softCapToken,\n', '        uint _hardCapToken,\n', '        AcreToken _addressOfTokenUsedAsReward\n', '    ) AcreSale(\n', '        _sendEther,\n', '        _softCapToken, \n', '        _hardCapToken, \n', '        _addressOfTokenUsedAsReward) public {\n', '    }\n', '    \n', '    function startCrowdsale() onlyManagers public {\n', '        startSale(CROWDSALE_DURATION_TIME);\n', '    }\n', '    \n', '    function getCurrentBonusRate() public constant returns(uint8 bonusRate) {\n', '        if      (now <= SafeMath.add(startSaleTime, SafeMath.mul( 7, TIME_FACTOR))) { bonusRate = 20; } // 7days\n', '        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(14, TIME_FACTOR))) { bonusRate = 15; } // 7days\n', '        else if (now <= SafeMath.add(startSaleTime, SafeMath.mul(21, TIME_FACTOR))) { bonusRate = 10; } // 7days\n', '        else                                                                        { bonusRate = 0; }  // \n', '    }\n', '}']