['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '// Custom smart contracts developed or adapted for OrcaCrowdsale\n', '// -------------------------------------------------------------\n', '\n', 'contract TokenRecoverable is Ownable {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    function recoverTokens(ERC20Basic token, address to, uint256 amount) public onlyOwner {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(balance >= amount);\n', '        token.safeTransfer(to, amount);\n', '    }\n', '}\n', '\n', 'contract ERC820Registry {\n', '    function getManager(address addr) public view returns(address);\n', '    function setManager(address addr, address newManager) public;\n', '    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);\n', '    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\n', '}\n', '\n', 'contract ERC820Implementer {\n', '    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\n', '\n', '    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\n', '        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\n', '        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\n', '    }\n', '\n', '    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\n', '        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\n', '        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\n', '    }\n', '\n', '    function delegateManagement(address newManager) internal {\n', '        erc820Registry.setManager(this, newManager);\n', '    }\n', '}\n', '\n', 'contract ERC777Token {\n', '    function name() public view returns (string);\n', '    function symbol() public view returns (string);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address owner) public view returns (uint256);\n', '    function granularity() public view returns (uint256);\n', '\n', '    function defaultOperators() public view returns (address[]);\n', '    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\n', '    function authorizeOperator(address operator) public;\n', '    function revokeOperator(address operator) public;\n', '\n', '    function send(address to, uint256 amount, bytes holderData) public;\n', '    function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) public;\n', '\n', '    function burn(uint256 amount, bytes holderData) public;\n', '    function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) public;\n', '\n', '    event Sent(\n', '        address indexed operator,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        bytes holderData,\n', '        bytes operatorData\n', '    ); // solhint-disable-next-line separate-by-one-line-in-contract\n', '    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\n', '    event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);\n', '    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n', '    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n', '}\n', '\n', 'contract ERC777TokensRecipient {\n', '    function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint amount,\n', '        bytes userData,\n', '        bytes operatorData\n', '    ) public;\n', '}\n', '\n', 'contract CommunityLock is ERC777TokensRecipient, ERC820Implementer, TokenRecoverable {\n', '\n', '    ERC777Token public token;\n', '\n', '    constructor(address _token) public {\n', '        setInterfaceImplementation("ERC777TokensRecipient", this);\n', '        address tokenAddress = interfaceAddr(_token, "ERC777Token");\n', '        require(tokenAddress != address(0));\n', '        token = ERC777Token(tokenAddress);\n', '    }\n', '\n', '    function burn(uint256 _amount) public onlyOwner {\n', '        require(_amount > 0);\n', '        token.burn(_amount, &#39;&#39;);\n', '    }\n', '\n', '    function tokensReceived(address, address, address, uint256, bytes, bytes) public {\n', '        require(msg.sender == address(token));\n', '    }\n', '}\n', '\n', 'contract Debuggable {\n', '    event LogUI(string message, uint256 value);\n', '\n', '    function logUI(string message, uint256 value) internal {\n', '        emit LogUI(message, value);\n', '    }\n', '}\n', '\n', 'contract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    ERC777Token public token;\n', '    uint256 public totalVested;\n', '\n', '    struct Timelock {\n', '        uint256 till;\n', '        uint256 amount;\n', '    }\n', '\n', '    mapping(address => Timelock[]) public schedule;\n', '\n', '    event Released(address to, uint256 amount);\n', '\n', '    constructor(address _token) public {\n', '        setInterfaceImplementation("ERC777TokensRecipient", this);\n', '        address tokenAddress = interfaceAddr(_token, "ERC777Token");\n', '        require(tokenAddress != address(0));\n', '        token = ERC777Token(tokenAddress);\n', '    }\n', '\n', '    function scheduleTimelock(address _beneficiary, uint256 _lockTokenAmount, uint256 _lockTill) public onlyOwner {\n', '        require(_beneficiary != address(0));\n', '        require(_lockTill > getNow());\n', '        require(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount));\n', '        totalVested = totalVested.add(_lockTokenAmount);\n', '\n', '        schedule[_beneficiary].push(Timelock({ till: _lockTill, amount: _lockTokenAmount }));\n', '    }\n', '\n', '    function release(address _to) public {\n', '        Timelock[] storage timelocks = schedule[_to];\n', '        uint256 tokens = 0;\n', '        uint256 till;\n', '        uint256 n = timelocks.length;\n', '        uint256 timestamp = getNow();\n', '        for (uint256 i = 0; i < n; i++) {\n', '            Timelock storage timelock = timelocks[i];\n', '            till = timelock.till;\n', '            if (till > 0 && till <= timestamp) {\n', '                tokens = tokens.add(timelock.amount);\n', '                timelock.amount = 0;\n', '                timelock.till = 0;\n', '            }\n', '        }\n', '        if (tokens > 0) {\n', '            totalVested = totalVested.sub(tokens);\n', '            token.send(_to, tokens, &#39;&#39;);\n', '            emit Released(_to, tokens);\n', '        }\n', '    }\n', '\n', '    function releaseBatch(address[] _to) public {\n', '        require(_to.length > 0 && _to.length < 100);\n', '\n', '        for (uint256 i = 0; i < _to.length; i++) {\n', '            release(_to[i]);\n', '        }\n', '    }\n', '\n', '    function tokensReceived(address, address, address, uint256, bytes, bytes) public {}\n', '\n', '    function getScheduledTimelockCount(address _beneficiary) public view returns (uint256) {\n', '        return schedule[_beneficiary].length;\n', '    }\n', '\n', '    function getNow() internal view returns (uint256) {\n', '        return now; // solhint-disable-line\n', '    }\n', '}\n', '\n', 'contract ExchangeRateConsumer is Ownable {\n', '\n', '    uint8 public constant EXCHANGE_RATE_DECIMALS = 3; // 3 digits precision for exchange rate\n', '\n', '    uint256 public exchangeRate = 600000; // by default exchange rate is $600 with EXCHANGE_RATE_DECIMALS precision\n', '\n', '    address public exchangeRateOracle;\n', '\n', '    function setExchangeRateOracle(address _exchangeRateOracle) public onlyOwner {\n', '        require(_exchangeRateOracle != address(0));\n', '        exchangeRateOracle = _exchangeRateOracle;\n', '    }\n', '\n', '    function setExchangeRate(uint256 _exchangeRate) public {\n', '        require(msg.sender == exchangeRateOracle || msg.sender == owner);\n', '        require(_exchangeRate > 0);\n', '        exchangeRate = _exchangeRate;\n', '    }\n', '}\n', '\n', 'contract OrcaToken is Ownable  {\n', '    using SafeMath for uint256;\n', '\n', '    string private constant name_ = "ORCA Token";\n', '    string private constant symbol_ = "ORCA";\n', '    uint256 private constant granularity_ = 1;\n', '\n', '    function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public;\n', '    function burn(uint256 _amount, bytes _holderData) public;\n', '    function finishMinting() public;\n', '}\n', '\n', 'contract Whitelist {\n', '    mapping(address => uint256) public whitelist;\n', '}\n', '\n', 'contract OrcaCrowdsale is TokenRecoverable, ExchangeRateConsumer, Debuggable {\n', '    using SafeMath for uint256;\n', '\n', '    // Wallet where all ether will be stored\n', '    address internal constant WALLET = 0x0909Fb46D48eea996197573415446A26c001994a;\n', '    // Partner wallet\n', '    address internal constant PARTNER_WALLET = 0x536ba70cA19DF9982487e555E335e7d91Da4A474;\n', '    // Team wallet\n', '    address internal constant TEAM_WALLET = 0x5d6aF05d440326AE861100962e861CFF09203556;\n', '    // Advisors wallet\n', '    address internal constant ADVISORS_WALLET = 0xf44e377F35998a6b7776954c64a84fAf420C467B;\n', '\n', '    uint256 internal constant TEAM_TOKENS = 58200000e18;      // 58 200 000 tokens\n', '    uint256 internal constant ADVISORS_TOKENS = 20000000e18;  // 20 000 000 tokens\n', '    uint256 internal constant PARTNER_TOKENS = 82800000e18;   // 82 800 000 tokens\n', '    uint256 internal constant COMMUNITY_TOKENS = 92000000e18; // 92 000 000 tokens\n', '\n', '    uint256 internal constant TOKEN_PRICE = 6; // Token costs 0.06 USD\n', '    uint256 internal constant TEAM_TOKEN_LOCK_DATE = 1565049600; // 2019/08/06 00:00 UTC\n', '\n', '    struct Stage {\n', '        uint256 startDate;\n', '        uint256 endDate;\n', '        uint256 priorityDate; // allow priority users to purchase tokens until this date\n', '        uint256 cap;\n', '        uint64 bonus;\n', '        uint64 maxPriorityId;\n', '    }\n', '\n', '    uint256 public icoTokensLeft = 193200000e18;   // 193 200 000 tokens for ICO\n', '    uint256 public bountyTokensLeft = 13800000e18; // 13 800 000 bounty tokens\n', '    uint256 public preSaleTokens = 0;\n', '\n', '    Stage[] public stages;\n', '\n', '    // The token being sold\n', '    OrcaToken public token;\n', '    Whitelist public whitelist;\n', '    ERC777TokenScheduledTimelock public timelock;\n', '    CommunityLock public communityLock;\n', '\n', '    mapping(address => uint256) public bountyBalances;\n', '\n', '    address public tokenMinter;\n', '\n', '    uint8 public currentStage = 0;\n', '    bool public initialized = false;\n', '    bool public isFinalized = false;\n', '    bool public isPreSaleTokenSet = false;\n', '\n', '    /**\n', '    * event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param weis paid for purchase\n', '    * @param usd paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 weis, uint256 usd, uint256 rate, uint256 amount);\n', '\n', '    event Finalized();\n', '    /**\n', '     * When there no tokens left to mint and token minter tries to manually mint tokens\n', '     * this event is raised to signal how many tokens we have to charge back to purchaser\n', '     */\n', '    event ManualTokenMintRequiresRefund(address indexed purchaser, uint256 value);\n', '\n', '    modifier onlyInitialized() {\n', '        require(initialized);\n', '        _;\n', '    }\n', '\n', '    constructor(address _token, address _whitelist) public {\n', '        require(_token != address(0));\n', '        require(_whitelist != address(0));\n', '\n', '        uint256 stageCap = 30000000e18; // 30 000 000 tokens\n', '\n', '        stages.push(Stage({\n', '            startDate: 1533546000, // 6th of August, 9:00 UTC\n', '            endDate: 1534150800, // 13th of August, 9:00 UTC\n', '            cap: stageCap,\n', '            bonus: 20,\n', '            maxPriorityId: 5000,\n', '            priorityDate: uint256(1533546000).add(48 hours) // 6th of August, 9:00 UTC + 48 hours\n', '        }));\n', '\n', '        icoTokensLeft = icoTokensLeft.sub(stageCap);\n', '\n', '        token = OrcaToken(_token);\n', '        whitelist = Whitelist(_whitelist);\n', '        timelock = new ERC777TokenScheduledTimelock(_token);\n', '    }\n', '\n', '    function initialize() public onlyOwner {\n', '        require(!initialized);\n', '\n', '        token.mint(timelock, TEAM_TOKENS, &#39;&#39;);\n', '        timelock.scheduleTimelock(TEAM_WALLET, TEAM_TOKENS, TEAM_TOKEN_LOCK_DATE);\n', '\n', '        token.mint(ADVISORS_WALLET, ADVISORS_TOKENS, &#39;&#39;);\n', '        token.mint(PARTNER_WALLET, PARTNER_TOKENS, &#39;&#39;);\n', '\n', '        communityLock = new CommunityLock(token);\n', '        token.mint(communityLock, COMMUNITY_TOKENS, &#39;&#39;);\n', '\n', '        initialized = true;\n', '    }\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function mintPreSaleTokens(address[] _receivers, uint256[] _amounts, uint256[] _lockPeroids) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(_receivers.length == _lockPeroids.length);\n', '        require(!isFinalized);\n', '        uint256 tokensInBatch = 0;\n', '        for (uint256 i = 0; i < _amounts.length; i++) {\n', '            tokensInBatch = tokensInBatch.add(_amounts[i]);\n', '        }\n', '        require(preSaleTokens >= tokensInBatch);\n', '\n', '        preSaleTokens = preSaleTokens.sub(tokensInBatch);\n', '        token.mint(timelock, tokensInBatch, &#39;&#39;);\n', '\n', '        address receiver;\n', '        uint256 lockTill;\n', '        uint256 timestamp = getNow();\n', '        for (i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            require(receiver != address(0));\n', '\n', '            lockTill = _lockPeroids[i];\n', '            require(lockTill > timestamp);\n', '\n', '            timelock.scheduleTimelock(receiver, _amounts[i], lockTill);\n', '        }\n', '    }\n', '\n', '    function mintToken(address _receiver, uint256 _amount) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(!isFinalized);\n', '        require(_receiver != address(0));\n', '        require(_amount > 0);\n', '\n', '        ensureCurrentStage();\n', '\n', '        uint256 excessTokens = updateStageCap(_amount);\n', '\n', '        token.mint(_receiver, _amount.sub(excessTokens), &#39;&#39;);\n', '\n', '        if (excessTokens > 0) {\n', '            emit ManualTokenMintRequiresRefund(_receiver, excessTokens); // solhint-disable-line\n', '        }\n', '    }\n', '\n', '    function mintTokens(address[] _receivers, uint256[] _amounts) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(!isFinalized);\n', '\n', '        ensureCurrentStage();\n', '\n', '        address receiver;\n', '        uint256 amount;\n', '        uint256 excessTokens;\n', '\n', '        for (uint256 i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            amount = _amounts[i];\n', '\n', '            require(receiver != address(0));\n', '            require(amount > 0);\n', '\n', '            excessTokens = updateStageCap(amount);\n', '\n', '            uint256 tokens = amount.sub(excessTokens);\n', '\n', '            token.mint(receiver, tokens, &#39;&#39;);\n', '\n', '            if (excessTokens > 0) {\n', '                emit ManualTokenMintRequiresRefund(receiver, excessTokens); // solhint-disable-line\n', '            }\n', '        }\n', '    }\n', '\n', '    function mintBounty(address[] _receivers, uint256[] _amounts) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(!isFinalized);\n', '        require(bountyTokensLeft > 0);\n', '\n', '        uint256 tokensLeft = bountyTokensLeft;\n', '        address receiver;\n', '        uint256 amount;\n', '        for (uint256 i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            amount = _amounts[i];\n', '\n', '            require(receiver != address(0));\n', '            require(amount > 0);\n', '\n', '            tokensLeft = tokensLeft.sub(amount);\n', '            bountyBalances[receiver] = bountyBalances[receiver].add(amount);\n', '        }\n', '\n', '        bountyTokensLeft = tokensLeft;\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable onlyInitialized {\n', '        require(_beneficiary != address(0));\n', '        ensureCurrentStage();\n', '        validatePurchase();\n', '        uint256 weiReceived = msg.value;\n', '        uint256 usdReceived = weiToUsd(weiReceived);\n', '\n', '        uint8 stageIndex = currentStage;\n', '\n', '        uint256 tokens = usdToTokens(usdReceived, stageIndex);\n', '        uint256 weiToReturn = 0;\n', '\n', '        uint256 excessTokens = updateStageCap(tokens);\n', '\n', '        if (excessTokens > 0) {\n', '            uint256 usdToReturn = tokensToUsd(excessTokens, stageIndex);\n', '            usdReceived = usdReceived.sub(usdToReturn);\n', '            weiToReturn = weiToReturn.add(usdToWei(usdToReturn));\n', '            weiReceived = weiReceived.sub(weiToReturn);\n', '            tokens = tokens.sub(excessTokens);\n', '        }\n', '\n', '        token.mint(_beneficiary, tokens, &#39;&#39;);\n', '\n', '        WALLET.transfer(weiReceived);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiReceived, usdReceived, exchangeRate, tokens); // solhint-disable-line\n', '        if (weiToReturn > 0) {\n', '            msg.sender.transfer(weiToReturn);\n', '        }\n', '    }\n', '\n', '    function ensureCurrentStage() internal {\n', '        uint256 currentTime = getNow();\n', '        uint256 stageCount = stages.length;\n', '\n', '        uint8 curStage = currentStage;\n', '        uint8 nextStage = curStage + 1;\n', '\n', '        while (nextStage < stageCount && stages[nextStage].startDate <= currentTime) {\n', '            stages[nextStage].cap = stages[nextStage].cap.add(stages[curStage].cap);\n', '            curStage = nextStage;\n', '            nextStage = nextStage + 1;\n', '        }\n', '        if (currentStage != curStage) {\n', '            currentStage = curStage;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Must be called after crowdsale ends, to do some extra finalization\n', '    * work. Calls the contract&#39;s finalization function.\n', '    */\n', '    function finalize() public onlyOwner onlyInitialized {\n', '        require(!isFinalized);\n', '        require(preSaleTokens == 0);\n', '        Stage storage lastStage = stages[stages.length - 1];\n', '        require(getNow() >= lastStage.endDate || (lastStage.cap == 0 && icoTokensLeft == 0));\n', '\n', '        token.finishMinting();\n', '        token.transferOwnership(owner);\n', '        communityLock.transferOwnership(owner); // only in finalize just to be sure that it is the same owner as crowdsale\n', '\n', '        emit Finalized(); // solhint-disable-line\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    function setTokenMinter(address _tokenMinter) public onlyOwner onlyInitialized {\n', '        require(_tokenMinter != address(0));\n', '        tokenMinter = _tokenMinter;\n', '    }\n', '\n', '    function claimBounty(address beneficiary) public onlyInitialized {\n', '        uint256 balance = bountyBalances[beneficiary];\n', '        require(balance > 0);\n', '        bountyBalances[beneficiary] = 0;\n', '\n', '        token.mint(beneficiary, balance, &#39;&#39;);\n', '    }\n', '\n', '    /// @notice Updates current stage cap and returns amount of excess tokens if ICO does not have enough tokens\n', '    function updateStageCap(uint256 _tokens) internal returns (uint256) {\n', '        Stage storage stage = stages[currentStage];\n', '        uint256 cap = stage.cap;\n', '        // normal situation, early exit\n', '        if (cap >= _tokens) {\n', '            stage.cap = cap.sub(_tokens);\n', '            return 0;\n', '        }\n', '\n', '        stage.cap = 0;\n', '        uint256 excessTokens = _tokens.sub(cap);\n', '        if (icoTokensLeft >= excessTokens) {\n', '            icoTokensLeft = icoTokensLeft.sub(excessTokens);\n', '            return 0;\n', '        }\n', '        icoTokensLeft = 0;\n', '        return excessTokens.sub(icoTokensLeft);\n', '    }\n', '\n', '    function weiToUsd(uint256 _wei) internal view returns (uint256) {\n', '        return _wei.mul(exchangeRate).div(10 ** uint256(EXCHANGE_RATE_DECIMALS));\n', '    }\n', '\n', '    function usdToWei(uint256 _usd) internal view returns (uint256) {\n', '        return _usd.mul(10 ** uint256(EXCHANGE_RATE_DECIMALS)).div(exchangeRate);\n', '    }\n', '\n', '    function usdToTokens(uint256 _usd, uint8 _stage) internal view returns (uint256) {\n', '        return _usd.mul(stages[_stage].bonus + 100).div(TOKEN_PRICE);\n', '    }\n', '\n', '    function tokensToUsd(uint256 _tokens, uint8 _stage) internal view returns (uint256) {\n', '        return _tokens.mul(TOKEN_PRICE).div(stages[_stage].bonus + 100);\n', '    }\n', '\n', '    function addStage(uint256 startDate, uint256 endDate, uint256 cap, uint64 bonus, uint64 maxPriorityId, uint256 priorityTime) public onlyOwner onlyInitialized {\n', '        require(!isFinalized);\n', '        require(startDate > getNow());\n', '        require(endDate > startDate);\n', '        Stage storage lastStage = stages[stages.length - 1];\n', '        require(startDate > lastStage.endDate);\n', '        require(startDate.add(priorityTime) <= endDate);\n', '        require(icoTokensLeft >= cap);\n', '        require(maxPriorityId >= lastStage.maxPriorityId);\n', '\n', '        stages.push(Stage({\n', '            startDate: startDate,\n', '            endDate: endDate,\n', '            cap: cap,\n', '            bonus: bonus,\n', '            maxPriorityId: maxPriorityId,\n', '            priorityDate: startDate.add(priorityTime)\n', '        }));\n', '    }\n', '\n', '    function validatePurchase() internal view {\n', '        require(!isFinalized);\n', '        require(msg.value != 0);\n', '\n', '        require(currentStage < stages.length);\n', '        Stage storage stage = stages[currentStage];\n', '        require(stage.cap > 0);\n', '\n', '        uint256 currentTime = getNow();\n', '        require(stage.startDate <= currentTime && currentTime <= stage.endDate);\n', '\n', '        uint256 userId = whitelist.whitelist(msg.sender);\n', '        require(userId > 0);\n', '        if (stage.priorityDate > currentTime) {\n', '            require(userId < stage.maxPriorityId);\n', '        }\n', '    }\n', '\n', '    function setPreSaleTokens(uint256 amount) public onlyOwner onlyInitialized {\n', '        require(!isPreSaleTokenSet);\n', '        require(amount > 0);\n', '        preSaleTokens = amount;\n', '        isPreSaleTokenSet = true;\n', '    }\n', '\n', '    function getStageCount() public view returns (uint256) {\n', '        return stages.length;\n', '    }\n', '\n', '    function getNow() internal view returns (uint256) {\n', '        return now; // solhint-disable-line\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '// Custom smart contracts developed or adapted for OrcaCrowdsale\n', '// -------------------------------------------------------------\n', '\n', 'contract TokenRecoverable is Ownable {\n', '    using SafeERC20 for ERC20Basic;\n', '\n', '    function recoverTokens(ERC20Basic token, address to, uint256 amount) public onlyOwner {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(balance >= amount);\n', '        token.safeTransfer(to, amount);\n', '    }\n', '}\n', '\n', 'contract ERC820Registry {\n', '    function getManager(address addr) public view returns(address);\n', '    function setManager(address addr, address newManager) public;\n', '    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);\n', '    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\n', '}\n', '\n', 'contract ERC820Implementer {\n', '    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\n', '\n', '    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\n', '        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\n', '        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\n', '    }\n', '\n', '    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\n', '        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\n', '        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\n', '    }\n', '\n', '    function delegateManagement(address newManager) internal {\n', '        erc820Registry.setManager(this, newManager);\n', '    }\n', '}\n', '\n', 'contract ERC777Token {\n', '    function name() public view returns (string);\n', '    function symbol() public view returns (string);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address owner) public view returns (uint256);\n', '    function granularity() public view returns (uint256);\n', '\n', '    function defaultOperators() public view returns (address[]);\n', '    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\n', '    function authorizeOperator(address operator) public;\n', '    function revokeOperator(address operator) public;\n', '\n', '    function send(address to, uint256 amount, bytes holderData) public;\n', '    function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) public;\n', '\n', '    function burn(uint256 amount, bytes holderData) public;\n', '    function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) public;\n', '\n', '    event Sent(\n', '        address indexed operator,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        bytes holderData,\n', '        bytes operatorData\n', '    ); // solhint-disable-next-line separate-by-one-line-in-contract\n', '    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\n', '    event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);\n', '    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n', '    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n', '}\n', '\n', 'contract ERC777TokensRecipient {\n', '    function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint amount,\n', '        bytes userData,\n', '        bytes operatorData\n', '    ) public;\n', '}\n', '\n', 'contract CommunityLock is ERC777TokensRecipient, ERC820Implementer, TokenRecoverable {\n', '\n', '    ERC777Token public token;\n', '\n', '    constructor(address _token) public {\n', '        setInterfaceImplementation("ERC777TokensRecipient", this);\n', '        address tokenAddress = interfaceAddr(_token, "ERC777Token");\n', '        require(tokenAddress != address(0));\n', '        token = ERC777Token(tokenAddress);\n', '    }\n', '\n', '    function burn(uint256 _amount) public onlyOwner {\n', '        require(_amount > 0);\n', "        token.burn(_amount, '');\n", '    }\n', '\n', '    function tokensReceived(address, address, address, uint256, bytes, bytes) public {\n', '        require(msg.sender == address(token));\n', '    }\n', '}\n', '\n', 'contract Debuggable {\n', '    event LogUI(string message, uint256 value);\n', '\n', '    function logUI(string message, uint256 value) internal {\n', '        emit LogUI(message, value);\n', '    }\n', '}\n', '\n', 'contract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    ERC777Token public token;\n', '    uint256 public totalVested;\n', '\n', '    struct Timelock {\n', '        uint256 till;\n', '        uint256 amount;\n', '    }\n', '\n', '    mapping(address => Timelock[]) public schedule;\n', '\n', '    event Released(address to, uint256 amount);\n', '\n', '    constructor(address _token) public {\n', '        setInterfaceImplementation("ERC777TokensRecipient", this);\n', '        address tokenAddress = interfaceAddr(_token, "ERC777Token");\n', '        require(tokenAddress != address(0));\n', '        token = ERC777Token(tokenAddress);\n', '    }\n', '\n', '    function scheduleTimelock(address _beneficiary, uint256 _lockTokenAmount, uint256 _lockTill) public onlyOwner {\n', '        require(_beneficiary != address(0));\n', '        require(_lockTill > getNow());\n', '        require(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount));\n', '        totalVested = totalVested.add(_lockTokenAmount);\n', '\n', '        schedule[_beneficiary].push(Timelock({ till: _lockTill, amount: _lockTokenAmount }));\n', '    }\n', '\n', '    function release(address _to) public {\n', '        Timelock[] storage timelocks = schedule[_to];\n', '        uint256 tokens = 0;\n', '        uint256 till;\n', '        uint256 n = timelocks.length;\n', '        uint256 timestamp = getNow();\n', '        for (uint256 i = 0; i < n; i++) {\n', '            Timelock storage timelock = timelocks[i];\n', '            till = timelock.till;\n', '            if (till > 0 && till <= timestamp) {\n', '                tokens = tokens.add(timelock.amount);\n', '                timelock.amount = 0;\n', '                timelock.till = 0;\n', '            }\n', '        }\n', '        if (tokens > 0) {\n', '            totalVested = totalVested.sub(tokens);\n', "            token.send(_to, tokens, '');\n", '            emit Released(_to, tokens);\n', '        }\n', '    }\n', '\n', '    function releaseBatch(address[] _to) public {\n', '        require(_to.length > 0 && _to.length < 100);\n', '\n', '        for (uint256 i = 0; i < _to.length; i++) {\n', '            release(_to[i]);\n', '        }\n', '    }\n', '\n', '    function tokensReceived(address, address, address, uint256, bytes, bytes) public {}\n', '\n', '    function getScheduledTimelockCount(address _beneficiary) public view returns (uint256) {\n', '        return schedule[_beneficiary].length;\n', '    }\n', '\n', '    function getNow() internal view returns (uint256) {\n', '        return now; // solhint-disable-line\n', '    }\n', '}\n', '\n', 'contract ExchangeRateConsumer is Ownable {\n', '\n', '    uint8 public constant EXCHANGE_RATE_DECIMALS = 3; // 3 digits precision for exchange rate\n', '\n', '    uint256 public exchangeRate = 600000; // by default exchange rate is $600 with EXCHANGE_RATE_DECIMALS precision\n', '\n', '    address public exchangeRateOracle;\n', '\n', '    function setExchangeRateOracle(address _exchangeRateOracle) public onlyOwner {\n', '        require(_exchangeRateOracle != address(0));\n', '        exchangeRateOracle = _exchangeRateOracle;\n', '    }\n', '\n', '    function setExchangeRate(uint256 _exchangeRate) public {\n', '        require(msg.sender == exchangeRateOracle || msg.sender == owner);\n', '        require(_exchangeRate > 0);\n', '        exchangeRate = _exchangeRate;\n', '    }\n', '}\n', '\n', 'contract OrcaToken is Ownable  {\n', '    using SafeMath for uint256;\n', '\n', '    string private constant name_ = "ORCA Token";\n', '    string private constant symbol_ = "ORCA";\n', '    uint256 private constant granularity_ = 1;\n', '\n', '    function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public;\n', '    function burn(uint256 _amount, bytes _holderData) public;\n', '    function finishMinting() public;\n', '}\n', '\n', 'contract Whitelist {\n', '    mapping(address => uint256) public whitelist;\n', '}\n', '\n', 'contract OrcaCrowdsale is TokenRecoverable, ExchangeRateConsumer, Debuggable {\n', '    using SafeMath for uint256;\n', '\n', '    // Wallet where all ether will be stored\n', '    address internal constant WALLET = 0x0909Fb46D48eea996197573415446A26c001994a;\n', '    // Partner wallet\n', '    address internal constant PARTNER_WALLET = 0x536ba70cA19DF9982487e555E335e7d91Da4A474;\n', '    // Team wallet\n', '    address internal constant TEAM_WALLET = 0x5d6aF05d440326AE861100962e861CFF09203556;\n', '    // Advisors wallet\n', '    address internal constant ADVISORS_WALLET = 0xf44e377F35998a6b7776954c64a84fAf420C467B;\n', '\n', '    uint256 internal constant TEAM_TOKENS = 58200000e18;      // 58 200 000 tokens\n', '    uint256 internal constant ADVISORS_TOKENS = 20000000e18;  // 20 000 000 tokens\n', '    uint256 internal constant PARTNER_TOKENS = 82800000e18;   // 82 800 000 tokens\n', '    uint256 internal constant COMMUNITY_TOKENS = 92000000e18; // 92 000 000 tokens\n', '\n', '    uint256 internal constant TOKEN_PRICE = 6; // Token costs 0.06 USD\n', '    uint256 internal constant TEAM_TOKEN_LOCK_DATE = 1565049600; // 2019/08/06 00:00 UTC\n', '\n', '    struct Stage {\n', '        uint256 startDate;\n', '        uint256 endDate;\n', '        uint256 priorityDate; // allow priority users to purchase tokens until this date\n', '        uint256 cap;\n', '        uint64 bonus;\n', '        uint64 maxPriorityId;\n', '    }\n', '\n', '    uint256 public icoTokensLeft = 193200000e18;   // 193 200 000 tokens for ICO\n', '    uint256 public bountyTokensLeft = 13800000e18; // 13 800 000 bounty tokens\n', '    uint256 public preSaleTokens = 0;\n', '\n', '    Stage[] public stages;\n', '\n', '    // The token being sold\n', '    OrcaToken public token;\n', '    Whitelist public whitelist;\n', '    ERC777TokenScheduledTimelock public timelock;\n', '    CommunityLock public communityLock;\n', '\n', '    mapping(address => uint256) public bountyBalances;\n', '\n', '    address public tokenMinter;\n', '\n', '    uint8 public currentStage = 0;\n', '    bool public initialized = false;\n', '    bool public isFinalized = false;\n', '    bool public isPreSaleTokenSet = false;\n', '\n', '    /**\n', '    * event for token purchase logging\n', '    * @param purchaser who paid for the tokens\n', '    * @param beneficiary who got the tokens\n', '    * @param weis paid for purchase\n', '    * @param usd paid for purchase\n', '    * @param amount amount of tokens purchased\n', '    */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 weis, uint256 usd, uint256 rate, uint256 amount);\n', '\n', '    event Finalized();\n', '    /**\n', '     * When there no tokens left to mint and token minter tries to manually mint tokens\n', '     * this event is raised to signal how many tokens we have to charge back to purchaser\n', '     */\n', '    event ManualTokenMintRequiresRefund(address indexed purchaser, uint256 value);\n', '\n', '    modifier onlyInitialized() {\n', '        require(initialized);\n', '        _;\n', '    }\n', '\n', '    constructor(address _token, address _whitelist) public {\n', '        require(_token != address(0));\n', '        require(_whitelist != address(0));\n', '\n', '        uint256 stageCap = 30000000e18; // 30 000 000 tokens\n', '\n', '        stages.push(Stage({\n', '            startDate: 1533546000, // 6th of August, 9:00 UTC\n', '            endDate: 1534150800, // 13th of August, 9:00 UTC\n', '            cap: stageCap,\n', '            bonus: 20,\n', '            maxPriorityId: 5000,\n', '            priorityDate: uint256(1533546000).add(48 hours) // 6th of August, 9:00 UTC + 48 hours\n', '        }));\n', '\n', '        icoTokensLeft = icoTokensLeft.sub(stageCap);\n', '\n', '        token = OrcaToken(_token);\n', '        whitelist = Whitelist(_whitelist);\n', '        timelock = new ERC777TokenScheduledTimelock(_token);\n', '    }\n', '\n', '    function initialize() public onlyOwner {\n', '        require(!initialized);\n', '\n', "        token.mint(timelock, TEAM_TOKENS, '');\n", '        timelock.scheduleTimelock(TEAM_WALLET, TEAM_TOKENS, TEAM_TOKEN_LOCK_DATE);\n', '\n', "        token.mint(ADVISORS_WALLET, ADVISORS_TOKENS, '');\n", "        token.mint(PARTNER_WALLET, PARTNER_TOKENS, '');\n", '\n', '        communityLock = new CommunityLock(token);\n', "        token.mint(communityLock, COMMUNITY_TOKENS, '');\n", '\n', '        initialized = true;\n', '    }\n', '\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function mintPreSaleTokens(address[] _receivers, uint256[] _amounts, uint256[] _lockPeroids) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(_receivers.length == _lockPeroids.length);\n', '        require(!isFinalized);\n', '        uint256 tokensInBatch = 0;\n', '        for (uint256 i = 0; i < _amounts.length; i++) {\n', '            tokensInBatch = tokensInBatch.add(_amounts[i]);\n', '        }\n', '        require(preSaleTokens >= tokensInBatch);\n', '\n', '        preSaleTokens = preSaleTokens.sub(tokensInBatch);\n', "        token.mint(timelock, tokensInBatch, '');\n", '\n', '        address receiver;\n', '        uint256 lockTill;\n', '        uint256 timestamp = getNow();\n', '        for (i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            require(receiver != address(0));\n', '\n', '            lockTill = _lockPeroids[i];\n', '            require(lockTill > timestamp);\n', '\n', '            timelock.scheduleTimelock(receiver, _amounts[i], lockTill);\n', '        }\n', '    }\n', '\n', '    function mintToken(address _receiver, uint256 _amount) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(!isFinalized);\n', '        require(_receiver != address(0));\n', '        require(_amount > 0);\n', '\n', '        ensureCurrentStage();\n', '\n', '        uint256 excessTokens = updateStageCap(_amount);\n', '\n', "        token.mint(_receiver, _amount.sub(excessTokens), '');\n", '\n', '        if (excessTokens > 0) {\n', '            emit ManualTokenMintRequiresRefund(_receiver, excessTokens); // solhint-disable-line\n', '        }\n', '    }\n', '\n', '    function mintTokens(address[] _receivers, uint256[] _amounts) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(!isFinalized);\n', '\n', '        ensureCurrentStage();\n', '\n', '        address receiver;\n', '        uint256 amount;\n', '        uint256 excessTokens;\n', '\n', '        for (uint256 i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            amount = _amounts[i];\n', '\n', '            require(receiver != address(0));\n', '            require(amount > 0);\n', '\n', '            excessTokens = updateStageCap(amount);\n', '\n', '            uint256 tokens = amount.sub(excessTokens);\n', '\n', "            token.mint(receiver, tokens, '');\n", '\n', '            if (excessTokens > 0) {\n', '                emit ManualTokenMintRequiresRefund(receiver, excessTokens); // solhint-disable-line\n', '            }\n', '        }\n', '    }\n', '\n', '    function mintBounty(address[] _receivers, uint256[] _amounts) external onlyInitialized {\n', '        require(msg.sender == tokenMinter || msg.sender == owner);\n', '        require(_receivers.length > 0 && _receivers.length <= 100);\n', '        require(_receivers.length == _amounts.length);\n', '        require(!isFinalized);\n', '        require(bountyTokensLeft > 0);\n', '\n', '        uint256 tokensLeft = bountyTokensLeft;\n', '        address receiver;\n', '        uint256 amount;\n', '        for (uint256 i = 0; i < _receivers.length; i++) {\n', '            receiver = _receivers[i];\n', '            amount = _amounts[i];\n', '\n', '            require(receiver != address(0));\n', '            require(amount > 0);\n', '\n', '            tokensLeft = tokensLeft.sub(amount);\n', '            bountyBalances[receiver] = bountyBalances[receiver].add(amount);\n', '        }\n', '\n', '        bountyTokensLeft = tokensLeft;\n', '    }\n', '\n', '    function buyTokens(address _beneficiary) public payable onlyInitialized {\n', '        require(_beneficiary != address(0));\n', '        ensureCurrentStage();\n', '        validatePurchase();\n', '        uint256 weiReceived = msg.value;\n', '        uint256 usdReceived = weiToUsd(weiReceived);\n', '\n', '        uint8 stageIndex = currentStage;\n', '\n', '        uint256 tokens = usdToTokens(usdReceived, stageIndex);\n', '        uint256 weiToReturn = 0;\n', '\n', '        uint256 excessTokens = updateStageCap(tokens);\n', '\n', '        if (excessTokens > 0) {\n', '            uint256 usdToReturn = tokensToUsd(excessTokens, stageIndex);\n', '            usdReceived = usdReceived.sub(usdToReturn);\n', '            weiToReturn = weiToReturn.add(usdToWei(usdToReturn));\n', '            weiReceived = weiReceived.sub(weiToReturn);\n', '            tokens = tokens.sub(excessTokens);\n', '        }\n', '\n', "        token.mint(_beneficiary, tokens, '');\n", '\n', '        WALLET.transfer(weiReceived);\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiReceived, usdReceived, exchangeRate, tokens); // solhint-disable-line\n', '        if (weiToReturn > 0) {\n', '            msg.sender.transfer(weiToReturn);\n', '        }\n', '    }\n', '\n', '    function ensureCurrentStage() internal {\n', '        uint256 currentTime = getNow();\n', '        uint256 stageCount = stages.length;\n', '\n', '        uint8 curStage = currentStage;\n', '        uint8 nextStage = curStage + 1;\n', '\n', '        while (nextStage < stageCount && stages[nextStage].startDate <= currentTime) {\n', '            stages[nextStage].cap = stages[nextStage].cap.add(stages[curStage].cap);\n', '            curStage = nextStage;\n', '            nextStage = nextStage + 1;\n', '        }\n', '        if (currentStage != curStage) {\n', '            currentStage = curStage;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Must be called after crowdsale ends, to do some extra finalization\n', "    * work. Calls the contract's finalization function.\n", '    */\n', '    function finalize() public onlyOwner onlyInitialized {\n', '        require(!isFinalized);\n', '        require(preSaleTokens == 0);\n', '        Stage storage lastStage = stages[stages.length - 1];\n', '        require(getNow() >= lastStage.endDate || (lastStage.cap == 0 && icoTokensLeft == 0));\n', '\n', '        token.finishMinting();\n', '        token.transferOwnership(owner);\n', '        communityLock.transferOwnership(owner); // only in finalize just to be sure that it is the same owner as crowdsale\n', '\n', '        emit Finalized(); // solhint-disable-line\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    function setTokenMinter(address _tokenMinter) public onlyOwner onlyInitialized {\n', '        require(_tokenMinter != address(0));\n', '        tokenMinter = _tokenMinter;\n', '    }\n', '\n', '    function claimBounty(address beneficiary) public onlyInitialized {\n', '        uint256 balance = bountyBalances[beneficiary];\n', '        require(balance > 0);\n', '        bountyBalances[beneficiary] = 0;\n', '\n', "        token.mint(beneficiary, balance, '');\n", '    }\n', '\n', '    /// @notice Updates current stage cap and returns amount of excess tokens if ICO does not have enough tokens\n', '    function updateStageCap(uint256 _tokens) internal returns (uint256) {\n', '        Stage storage stage = stages[currentStage];\n', '        uint256 cap = stage.cap;\n', '        // normal situation, early exit\n', '        if (cap >= _tokens) {\n', '            stage.cap = cap.sub(_tokens);\n', '            return 0;\n', '        }\n', '\n', '        stage.cap = 0;\n', '        uint256 excessTokens = _tokens.sub(cap);\n', '        if (icoTokensLeft >= excessTokens) {\n', '            icoTokensLeft = icoTokensLeft.sub(excessTokens);\n', '            return 0;\n', '        }\n', '        icoTokensLeft = 0;\n', '        return excessTokens.sub(icoTokensLeft);\n', '    }\n', '\n', '    function weiToUsd(uint256 _wei) internal view returns (uint256) {\n', '        return _wei.mul(exchangeRate).div(10 ** uint256(EXCHANGE_RATE_DECIMALS));\n', '    }\n', '\n', '    function usdToWei(uint256 _usd) internal view returns (uint256) {\n', '        return _usd.mul(10 ** uint256(EXCHANGE_RATE_DECIMALS)).div(exchangeRate);\n', '    }\n', '\n', '    function usdToTokens(uint256 _usd, uint8 _stage) internal view returns (uint256) {\n', '        return _usd.mul(stages[_stage].bonus + 100).div(TOKEN_PRICE);\n', '    }\n', '\n', '    function tokensToUsd(uint256 _tokens, uint8 _stage) internal view returns (uint256) {\n', '        return _tokens.mul(TOKEN_PRICE).div(stages[_stage].bonus + 100);\n', '    }\n', '\n', '    function addStage(uint256 startDate, uint256 endDate, uint256 cap, uint64 bonus, uint64 maxPriorityId, uint256 priorityTime) public onlyOwner onlyInitialized {\n', '        require(!isFinalized);\n', '        require(startDate > getNow());\n', '        require(endDate > startDate);\n', '        Stage storage lastStage = stages[stages.length - 1];\n', '        require(startDate > lastStage.endDate);\n', '        require(startDate.add(priorityTime) <= endDate);\n', '        require(icoTokensLeft >= cap);\n', '        require(maxPriorityId >= lastStage.maxPriorityId);\n', '\n', '        stages.push(Stage({\n', '            startDate: startDate,\n', '            endDate: endDate,\n', '            cap: cap,\n', '            bonus: bonus,\n', '            maxPriorityId: maxPriorityId,\n', '            priorityDate: startDate.add(priorityTime)\n', '        }));\n', '    }\n', '\n', '    function validatePurchase() internal view {\n', '        require(!isFinalized);\n', '        require(msg.value != 0);\n', '\n', '        require(currentStage < stages.length);\n', '        Stage storage stage = stages[currentStage];\n', '        require(stage.cap > 0);\n', '\n', '        uint256 currentTime = getNow();\n', '        require(stage.startDate <= currentTime && currentTime <= stage.endDate);\n', '\n', '        uint256 userId = whitelist.whitelist(msg.sender);\n', '        require(userId > 0);\n', '        if (stage.priorityDate > currentTime) {\n', '            require(userId < stage.maxPriorityId);\n', '        }\n', '    }\n', '\n', '    function setPreSaleTokens(uint256 amount) public onlyOwner onlyInitialized {\n', '        require(!isPreSaleTokenSet);\n', '        require(amount > 0);\n', '        preSaleTokens = amount;\n', '        isPreSaleTokenSet = true;\n', '    }\n', '\n', '    function getStageCount() public view returns (uint256) {\n', '        return stages.length;\n', '    }\n', '\n', '    function getNow() internal view returns (uint256) {\n', '        return now; // solhint-disable-line\n', '    }\n', '}']
