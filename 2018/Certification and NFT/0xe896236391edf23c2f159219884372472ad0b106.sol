['/*\n', ' * Safe Math Smart Contract.  Copyright &#169; 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <<span class="__cf_email__" data-cfemail="660b0f0d0e070f0a48100a07020f0b0f14091026010b070f0a4805090b">[email&#160;protected]</span>>\n', ' */\n', 'pragma solidity ^0.4.16;\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () constant returns (uint256 supply);\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the\n', '     *        owner of\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value)\n', '    returns (bool success);\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred\n', '     *        from the owner of\n', '     * @param _spender address to get number of tokens allowed to be transferred\n', '     *        by the owner of\n', '     * @return number of tokens given spender is currently allowed to transfer\n', '     *         from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) constant\n', '    returns (uint256 remaining);\n', '\n', '    /**\n', '     * Logged when tokens were transferred from one owner to another.\n', '     *\n', '     * @param _from address of the owner, tokens were transferred from\n', '     * @param _to address of the owner, tokens were transferred to\n', '     * @param _value number of tokens transferred\n', '     */\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '     * Logged when owner approved his tokens to be transferred by some spender.\n', '     *\n', '     * @param _owner owner who approved his tokens to be transferred\n', '     * @param _spender spender who were allowed to transfer the tokens belonging\n', '     *        to the owner\n', '     * @param _value number of tokens belonging to the owner, approved to be\n', '     *        transferred by the spender\n', '     */\n', '    event Approval (\n', '        address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '    uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Add two uint256 values, throw in case of overflow.\n', '     *\n', '     * @param x first value to add\n', '     * @param y second value to add\n', '     * @return x + y\n', '     */\n', '    function safeAdd (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        assert (x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * Subtract one uint256 value from another, throw in case of underflow.\n', '     *\n', '     * @param x value to subtract from\n', '     * @param y value to subtract\n', '     * @return x - y\n', '     */\n', '    function safeSub (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        assert (x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    /**\n', '     * Multiply two uint256 values, throw in case of overflow.\n', '     *\n', '     * @param x first value to multiply\n', '     * @param y second value to multiply\n', '     * @return x * y\n', '     */\n', '    function safeMul (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        if (y == 0) return 0; // Prevent division by zero at the next line\n', '        assert (x <= MAX_UINT256 / y);\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/**\n', ' * Math Utilities smart contract.\n', ' */\n', 'contract Math is SafeMath {\n', '    /**\n', '     * 2^127.\n', '     */\n', '    uint128 internal constant TWO127 = 0x80000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^128 - 1.\n', '     */\n', '    uint128 internal constant TWO128_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * 2^128.\n', '     */\n', '    uint256 internal constant TWO128 = 0x100000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^256 - 1.\n', '     */\n', '    uint256 internal constant TWO256_1 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * 2^255.\n', '     */\n', '    uint256 internal constant TWO255 =\n', '    0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * -2^255.\n', '     */\n', '    int256 internal constant MINUS_TWO255 =\n', '    -0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^255 - 1.\n', '     */\n', '    int256 internal constant TWO255_1 =\n', '    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * ln(2) * 2^128.\n', '     */\n', '    uint128 internal constant LN2 = 0xb17217f7d1cf79abc9e3b39803f2f6af;\n', '\n', '    /**\n', '     * Return index of most significant non-zero bit in given non-zero 256-bit\n', '     * unsigned integer value.\n', '     *\n', '     * @param x value to get index of most significant non-zero bit in\n', '     * @return index of most significant non-zero bit in given number\n', '     */\n', '    function mostSignificantBit (uint256 x) pure internal returns (uint8) {\n', '        require (x > 0);\n', '\n', '        uint8 l = 0;\n', '        uint8 h = 255;\n', '\n', '        while (h > l) {\n', '            uint8 m = uint8 ((uint16 (l) + uint16 (h)) >> 1);\n', '            uint256 t = x >> m;\n', '            if (t == 0) h = m - 1;\n', '            else if (t > 1) l = m + 1;\n', '            else return m;\n', '        }\n', '\n', '        return h;\n', '    }\n', '\n', '    /**\n', '     * Calculate log_2 (x / 2^128) * 2^128.\n', '     *\n', '     * @param x parameter value\n', '     * @return log_2 (x / 2^128) * 2^128\n', '     */\n', '    function log_2 (uint256 x) pure internal returns (int256) {\n', '        require (x > 0);\n', '\n', '        uint8 msb = mostSignificantBit (x);\n', '\n', '        if (msb > 128) x >>= msb - 128;\n', '        else if (msb < 128) x <<= 128 - msb;\n', '\n', '        x &= TWO128_1;\n', '\n', '        int256 result = (int256 (msb) - 128) << 128; // Integer part of log_2\n', '\n', '        int256 bit = TWO127;\n', '        for (uint8 i = 0; i < 128 && x > 0; i++) {\n', '            x = (x << 1) + ((x * x + TWO127) >> 128);\n', '            if (x > TWO128_1) {\n', '                result |= bit;\n', '                x = (x >> 1) - TWO127;\n', '            }\n', '            bit >>= 1;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Calculate ln (x / 2^128) * 2^128.\n', '     *\n', '     * @param x parameter value\n', '     * @return ln (x / 2^128) * 2^128\n', '     */\n', '    function ln (uint256 x) pure internal returns (int256) {\n', '        require (x > 0);\n', '\n', '        int256 l2 = log_2 (x);\n', '        if (l2 == 0) return 0;\n', '        else {\n', '            uint256 al2 = uint256 (l2 > 0 ? l2 : -l2);\n', '            uint8 msb = mostSignificantBit (al2);\n', '            if (msb > 127) al2 >>= msb - 127;\n', '            al2 = (al2 * LN2 + TWO127) >> 128;\n', '            if (msb > 127) al2 <<= msb - 127;\n', '\n', '            return int256 (l2 >= 0 ? al2 : -al2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y / 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x * y / 2^128\n', '     */\n', '    function fpMul (uint256 x, uint256 y) pure internal returns (uint256) {\n', '        uint256 xh = x >> 128;\n', '        uint256 xl = x & TWO128_1;\n', '        uint256 yh = y >> 128;\n', '        uint256 yl = y & TWO128_1;\n', '\n', '        uint256 result = xh * yh;\n', '        require (result <= TWO128_1);\n', '        result <<= 128;\n', '\n', '        result = safeAdd (result, xh * yl);\n', '        result = safeAdd (result, xl * yh);\n', '        result = safeAdd (result, (xl * yl) >> 128);\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return high and low words of x * y\n', '     */\n', '    function longMul (uint256 x, uint256 y)\n', '    pure internal returns (uint256 h, uint256 l) {\n', '        uint256 xh = x >> 128;\n', '        uint256 xl = x & TWO128_1;\n', '        uint256 yh = y >> 128;\n', '        uint256 yl = y & TWO128_1;\n', '\n', '        h = xh * yh;\n', '        l = xl * yl;\n', '\n', '        uint256 m1 = xh * yl;\n', '        uint256 m2 = xl * yh;\n', '\n', '        h += m1 >> 128;\n', '        h += m2 >> 128;\n', '\n', '        m1 <<= 128;\n', '        m2 <<= 128;\n', '\n', '        if (l > TWO256_1 - m1) h += 1;\n', '        l += m1;\n', '\n', '        if (l > TWO256_1 - m2) h += 1;\n', '        l += m2;\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y / 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x * y / 2^128\n', '     */\n', '    function fpMulI (int256 x, int256 y) pure internal returns (int256) {\n', '        bool negative = (x ^ y) < 0; // Whether result is negative\n', '\n', '        uint256 result = fpMul (\n', '            x < 0 ? uint256 (-1 - x) + 1 : uint256 (x),\n', '            y < 0 ? uint256 (-1 - y) + 1 : uint256 (y));\n', '\n', '        if (negative) {\n', '            require (result <= TWO255);\n', '            return result == 0 ? 0 : -1 - int256 (result - 1);\n', '        } else {\n', '            require (result < TWO255);\n', '            return int256 (result);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate x + y, throw in case of over-/underflow.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x + y\n', '     */\n', '    function safeAddI (int256 x, int256 y) pure internal returns (int256) {\n', '        if (x < 0 && y < 0)\n', '            assert (x >= MINUS_TWO255 - y);\n', '\n', '        if (x > 0 && y > 0)\n', '            assert (x <= TWO255_1 - y);\n', '\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * Calculate x / y * 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return  x / y * 2^128\n', '     */\n', '    function fpDiv (uint256 x, uint256 y) pure internal returns (uint256) {\n', '        require (y > 0); // Division by zero is forbidden\n', '\n', '        uint8 maxShiftY = mostSignificantBit (y);\n', '        if (maxShiftY >= 128) maxShiftY -= 127;\n', '        else maxShiftY = 0;\n', '\n', '        uint256 result = 0;\n', '\n', '        while (true) {\n', '            uint256 rh = x >> 128;\n', '            uint256 rl = x << 128;\n', '\n', '            uint256 ph;\n', '            uint256 pl;\n', '\n', '            (ph, pl) = longMul (result, y);\n', '            if (rl < pl) {\n', '                ph = safeAdd (ph, 1);\n', '            }\n', '\n', '            rl -= pl;\n', '            rh -= ph;\n', '\n', '            if (rh == 0) {\n', '                result = safeAdd (result, rl / y);\n', '                break;\n', '            } else {\n', '                uint256 reminder = (rh << 128) + (rl >> 128);\n', '\n', '                // How many bits to shift reminder left\n', '                uint8 shiftReminder = 255 - mostSignificantBit (reminder);\n', '                if (shiftReminder > 128) shiftReminder = 128;\n', '\n', '                // How many bits to shift result left\n', '                uint8 shiftResult = 128 - shiftReminder;\n', '\n', '                // How many bits to shift Y right\n', '                uint8 shiftY = maxShiftY;\n', '                if (shiftY > shiftResult) shiftY = shiftResult;\n', '\n', '                shiftResult -= shiftY;\n', '\n', '                uint256 r = (reminder << shiftReminder) / (((y - 1) >> shiftY) + 1);\n', '\n', '                uint8 msbR = mostSignificantBit (r);\n', '                require (msbR <= 255 - shiftResult);\n', '\n', '                result = safeAdd (result, r << shiftResult);\n', '            }\n', '        }\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Continuous Sale Action for selling PAT tokens.\n', ' */\n', 'contract PATTokenSale is Math {\n', '    /**\n', '     * Time period when 15% bonus is in force.\n', '     */\n', '    uint256 private constant TRIPLE_BONUS = 1 hours;\n', '\n', '    /**\n', '     * Time period when 10% bonus is in force.\n', '     */\n', '    uint256 private constant DOUBLE_BONUS = 1 days;\n', '\n', '    /**\n', '     * Time period when 5% bonus is in force.\n', '     */\n', '    uint256 private constant SINGLE_BONUS = 1 weeks;\n', '\n', '    /**\n', '     * Create PAT Token Sale smart contract with given sale start time, token\n', '     * contract and central bank address.\n', '     *\n', '     * @param _saleStartTime sale start time\n', '     * @param _saleDuration sale duration\n', '     * @param _token ERC20 smart contract managing tokens to be sold\n', '     * @param _centralBank central bank address to transfer tokens from\n', '     * @param _saleCap maximum amount of ether to collect (in Wei)\n', '     * @param _minimumInvestment minimum investment amount (in Wei)\n', '     * @param _a parameter a of price formula\n', '     * @param _b parameter b of price formula\n', '     * @param _c parameter c of price formula\n', '     */\n', '    function PATTokenSale (\n', '        uint256 _saleStartTime, uint256 _saleDuration,\n', '        Token _token, address _centralBank,\n', '        uint256 _saleCap, uint256 _minimumInvestment,\n', '        int256 _a, int256 _b, int256 _c) {\n', '        saleStartTime = _saleStartTime;\n', '        saleDuration = _saleDuration;\n', '        token = _token;\n', '        centralBank = _centralBank;\n', '        saleCap = _saleCap;\n', '        minimumInvestment = _minimumInvestment;\n', '        a = _a;\n', '        b = _b;\n', '        c = _c;\n', '    }\n', '\n', '    /**\n', '     * Equivalent to buy().\n', '     */\n', '    function () payable public {\n', '        require (msg.data.length == 0);\n', '\n', '        buy ();\n', '    }\n', '\n', '    /**\n', '     * Buy tokens.\n', '     */\n', '    function buy () payable public {\n', '        require (!finished);\n', '        require (now >= saleStartTime);\n', '        require (now < safeAdd (saleStartTime, saleDuration));\n', '\n', '        require (msg.value >= minimumInvestment);\n', '\n', '        if (msg.value > 0) {\n', '            uint256 remainingCap = safeSub (saleCap, totalInvested);\n', '            uint256 toInvest;\n', '            uint256 toRefund;\n', '\n', '            if (msg.value <= remainingCap) {\n', '                toInvest = msg.value;\n', '                toRefund = 0;\n', '            } else {\n', '                toInvest = remainingCap;\n', '                toRefund = safeSub (msg.value, toInvest);\n', '            }\n', '\n', '            Investor storage investor = investors [msg.sender];\n', '            investor.amount = safeAdd (investor.amount, toInvest);\n', '            if (now < safeAdd (saleStartTime, TRIPLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 6));\n', '            else if (now < safeAdd (saleStartTime, DOUBLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 4));\n', '            else if (now < safeAdd (saleStartTime, SINGLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 2));\n', '\n', '            Investment (msg.sender, toInvest);\n', '\n', '            totalInvested = safeAdd (totalInvested, toInvest);\n', '            if (toInvest == remainingCap) {\n', '                finished = true;\n', '                finalPrice = price (now);\n', '\n', '                Finished (finalPrice);\n', '            }\n', '\n', '            if (toRefund > 0)\n', '                msg.sender.transfer (toRefund);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Buy tokens providing referral code.\n', '     *\n', '     * @param _referralCode referral code, actually address of referee\n', '     */\n', '    function buyReferral (address _referralCode) payable public {\n', '        require (msg.sender != _referralCode);\n', '\n', '        Investor storage referee = investors [_referralCode];\n', '\n', '        // Make sure referee actually did invest something\n', '        require (referee.amount > 0);\n', '\n', '        Investor storage referrer = investors [msg.sender];\n', '        uint256 oldAmount = referrer.amount;\n', '\n', '        buy ();\n', '\n', '        uint256 invested = safeSub (referrer.amount, oldAmount);\n', '\n', '        // Make sure referrer actually did invest something\n', '        require (invested > 0);\n', '\n', '        referee.investedByReferrers = safeAdd (\n', '            referee.investedByReferrers, invested);\n', '\n', '        referrer.bonusAmount = safeAdd (\n', '            referrer.bonusAmount,\n', '            min (referee.amount, invested));\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens to be delivered to given investor.\n', '     *\n', '     * @param _investor address of the investor to get number of tokens to be\n', '     *        delivered to\n', '     * @return number of tokens to be delivered to given investor\n', '     */\n', '    function outstandingTokens (address _investor)\n', '    constant public returns (uint256) {\n', '        require (finished);\n', '        assert (finalPrice > 0);\n', '\n', '        Investor storage investor = investors [_investor];\n', '        uint256 bonusAmount = investor.bonusAmount;\n', '        bonusAmount = safeAdd (\n', '            bonusAmount, min (investor.amount, investor.investedByReferrers));\n', '\n', '        uint256 effectiveAmount = safeAdd (\n', '            investor.amount,\n', '            bonusAmount / 40);\n', '\n', '        return fpDiv (effectiveAmount, finalPrice);\n', '    }\n', '\n', '    /**\n', '     * Deliver purchased tokens to given investor.\n', '     *\n', '     * @param _investor investor to deliver purchased tokens to\n', '     */\n', '    function deliver (address _investor) public returns (bool) {\n', '        require (finished);\n', '\n', '        Investor storage investor = investors [_investor];\n', '        require (investor.amount > 0);\n', '\n', '        uint256 value = outstandingTokens (_investor);\n', '        if (value > 0) {\n', '            if (!token.transferFrom (centralBank, _investor, value)) return false;\n', '        }\n', '\n', '        totalInvested = safeSub (totalInvested, investor.amount);\n', '        investor.amount = 0;\n', '        investor.bonusAmount = 0;\n', '        investor.investedByReferrers = 0;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Collect sale revenue.\n', '     */\n', '    function collectRevenue () public {\n', '        require (msg.sender == centralBank);\n', '\n', '        centralBank.transfer (this.balance);\n', '    }\n', '\n', '    /**\n', '     * Return token price at given time in Wei per token natural unit.\n', '     *\n', '     * @param _time time to return price at\n', '     * @return price at given time as 128.128 fixed point number\n', '     */\n', '    function price (uint256 _time) constant public returns (uint256) {\n', '        require (_time >= saleStartTime);\n', '        require (_time <= safeAdd (saleStartTime, saleDuration));\n', '\n', '        require (_time <= TWO128_1);\n', '        uint256 t = _time << 128;\n', '\n', '        uint256 cPlusT = (c >= 0) ?\n', '        safeAdd (t, uint256 (c)) :\n', '        safeSub (t, uint256 (-1 - c) + 1);\n', '        int256 lnCPlusT = ln (cPlusT);\n', '        int256 bLnCPlusT = fpMulI (b, lnCPlusT);\n', '        int256 aPlusBLnCPlusT = safeAddI (a, bLnCPlusT);\n', '\n', '        require (aPlusBLnCPlusT >= 0);\n', '        return uint256 (aPlusBLnCPlusT);\n', '    }\n', '\n', '    /**\n', '     * Finish sale after sale period ended.\n', '     */\n', '    function finishSale () public {\n', '        require (msg.sender == centralBank);\n', '        require (!finished);\n', '        uint256 saleEndTime = safeAdd (saleStartTime, saleDuration);\n', '        require (now >= saleEndTime);\n', '\n', '        finished = true;\n', '        finalPrice = price (saleEndTime);\n', '\n', '        Finished (finalPrice);\n', '    }\n', '\n', '    /**\n', '     * Destroy smart contract.\n', '     */\n', '    function destroy () public {\n', '        require (msg.sender == centralBank);\n', '        require (finished);\n', '        require (now >= safeAdd (saleStartTime, saleDuration));\n', '        require (totalInvested == 0);\n', '        require (this.balance == 0);\n', '\n', '        selfdestruct (centralBank);\n', '    }\n', '\n', '    /**\n', '     * Return minimum of two values.\n', '     *\n', '     * @param x first value\n', '     * @param y second value\n', '     * @return minimum of two values\n', '     */\n', '    function min (uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x < y ? x : y;\n', '    }\n', '\n', '    /**\n', '     * Sale start time.\n', '     */\n', '    uint256 internal saleStartTime;\n', '\n', '    /**\n', '     * Sale duration.\n', '     */\n', '    uint256 internal saleDuration;\n', '\n', '    /**\n', '     * ERC20 token smart contract managing tokens to be sold.\n', '     */\n', '    Token internal token;\n', '\n', '    /**\n', '     * Address of central bank to transfer tokens from.\n', '     */\n', '    address internal centralBank;\n', '\n', '    /**\n', '     * Maximum number of Wei to collect.\n', '     */\n', '    uint256 internal saleCap;\n', '\n', '    /**\n', '     * Minimum investment amount in Wei.\n', '     */\n', '    uint256 internal minimumInvestment;\n', '\n', '    /**\n', '     * Price formula parameters.  Price at given time t is calculated as\n', '     * a / 2^128 + b * ln ((c + t) / 2^128) / 2^128.\n', '     */\n', '    int256 internal a;\n', '    int256 internal b;\n', '    int256 internal c;\n', '\n', '    /**\n', '     * True is sale was finished successfully, false otherwise.\n', '     */\n', '    bool internal finished = false;\n', '\n', '    /**\n', '     * Final price for finished sale.\n', '     */\n', '    uint256 internal finalPrice;\n', '\n', '    /**\n', '     * Maps investor&#39;s address to corresponding Investor structure.\n', '     */\n', '    mapping (address => Investor) internal investors;\n', '\n', '    /**\n', '     * Total amount invested in Wei.\n', '     */\n', '    uint256 internal totalInvested = 0;\n', '\n', '    /**\n', '     * Encapsulates information about investor.\n', '     */\n', '    struct Investor {\n', '        /**\n', '         * Total amount invested in Wei.\n', '         */\n', '        uint256 amount;\n', '\n', '        /**\n', '         * Bonus amount in Wei multiplied by 40.\n', '         */\n', '        uint256 bonusAmount;\n', '\n', '        /**\n', '         * Total amount of ether invested by others while referring this address.\n', '         */\n', '        uint256 investedByReferrers;\n', '    }\n', '\n', '    /**\n', '     * Logged when an investment was made.\n', '     *\n', '     * @param investor address of the investor who made the investment\n', '     * @param amount investment amount\n', '     */\n', '    event Investment (address indexed investor, uint256 amount);\n', '\n', '    /**\n', '     * Logged when sale finished successfully.\n', '     *\n', '     * @param finalPrice final price of the sale in Wei per token natural unit as\n', '     *                   128.128 bit fixed point number.\n', '     */\n', '    event Finished (uint256 finalPrice);\n', '}']
['/*\n', ' * Safe Math Smart Contract.  Copyright Â© 2016â€“2017 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', 'pragma solidity ^0.4.16;\n', '\n', '/**\n', ' * ERC-20 standard token interface, as defined\n', ' * <a href="http://github.com/ethereum/EIPs/issues/20">here</a>.\n', ' */\n', 'contract Token {\n', '    /**\n', '     * Get total number of tokens in circulation.\n', '     *\n', '     * @return total number of tokens in circulation\n', '     */\n', '    function totalSupply () constant returns (uint256 supply);\n', '\n', '    /**\n', '     * Get number of tokens currently belonging to given owner.\n', '     *\n', '     * @param _owner address to get number of tokens currently belonging to the\n', '     *        owner of\n', '     * @return number of tokens currently belonging to the owner of given address\n', '     */\n', '    function balanceOf (address _owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfer given number of tokens from message sender to given recipient.\n', '     *\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer to the owner of given address\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transfer (address _to, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Transfer given number of tokens from given owner to given recipient.\n', '     *\n', '     * @param _from address to transfer tokens from the owner of\n', '     * @param _to address to transfer tokens to the owner of\n', '     * @param _value number of tokens to transfer from given owner to given\n', '     *        recipient\n', '     * @return true if tokens were transferred successfully, false otherwise\n', '     */\n', '    function transferFrom (address _from, address _to, uint256 _value)\n', '    returns (bool success);\n', '\n', '    /**\n', '     * Allow given spender to transfer given number of tokens from message sender.\n', '     *\n', '     * @param _spender address to allow the owner of to transfer tokens from\n', '     *        message sender\n', '     * @param _value number of tokens to allow to transfer\n', '     * @return true if token transfer was successfully approved, false otherwise\n', '     */\n', '    function approve (address _spender, uint256 _value) returns (bool success);\n', '\n', '    /**\n', '     * Tell how many tokens given spender is currently allowed to transfer from\n', '     * given owner.\n', '     *\n', '     * @param _owner address to get number of tokens allowed to be transferred\n', '     *        from the owner of\n', '     * @param _spender address to get number of tokens allowed to be transferred\n', '     *        by the owner of\n', '     * @return number of tokens given spender is currently allowed to transfer\n', '     *         from given owner\n', '     */\n', '    function allowance (address _owner, address _spender) constant\n', '    returns (uint256 remaining);\n', '\n', '    /**\n', '     * Logged when tokens were transferred from one owner to another.\n', '     *\n', '     * @param _from address of the owner, tokens were transferred from\n', '     * @param _to address of the owner, tokens were transferred to\n', '     * @param _value number of tokens transferred\n', '     */\n', '    event Transfer (address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '     * Logged when owner approved his tokens to be transferred by some spender.\n', '     *\n', '     * @param _owner owner who approved his tokens to be transferred\n', '     * @param _spender spender who were allowed to transfer the tokens belonging\n', '     *        to the owner\n', '     * @param _value number of tokens belonging to the owner, approved to be\n', '     *        transferred by the spender\n', '     */\n', '    event Approval (\n', '        address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '    uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * Add two uint256 values, throw in case of overflow.\n', '     *\n', '     * @param x first value to add\n', '     * @param y second value to add\n', '     * @return x + y\n', '     */\n', '    function safeAdd (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        assert (x <= MAX_UINT256 - y);\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * Subtract one uint256 value from another, throw in case of underflow.\n', '     *\n', '     * @param x value to subtract from\n', '     * @param y value to subtract\n', '     * @return x - y\n', '     */\n', '    function safeSub (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        assert (x >= y);\n', '        return x - y;\n', '    }\n', '\n', '    /**\n', '     * Multiply two uint256 values, throw in case of overflow.\n', '     *\n', '     * @param x first value to multiply\n', '     * @param y second value to multiply\n', '     * @return x * y\n', '     */\n', '    function safeMul (uint256 x, uint256 y)\n', '    constant internal\n', '    returns (uint256 z) {\n', '        if (y == 0) return 0; // Prevent division by zero at the next line\n', '        assert (x <= MAX_UINT256 / y);\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/**\n', ' * Math Utilities smart contract.\n', ' */\n', 'contract Math is SafeMath {\n', '    /**\n', '     * 2^127.\n', '     */\n', '    uint128 internal constant TWO127 = 0x80000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^128 - 1.\n', '     */\n', '    uint128 internal constant TWO128_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * 2^128.\n', '     */\n', '    uint256 internal constant TWO128 = 0x100000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^256 - 1.\n', '     */\n', '    uint256 internal constant TWO256_1 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * 2^255.\n', '     */\n', '    uint256 internal constant TWO255 =\n', '    0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * -2^255.\n', '     */\n', '    int256 internal constant MINUS_TWO255 =\n', '    -0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    /**\n', '     * 2^255 - 1.\n', '     */\n', '    int256 internal constant TWO255_1 =\n', '    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    /**\n', '     * ln(2) * 2^128.\n', '     */\n', '    uint128 internal constant LN2 = 0xb17217f7d1cf79abc9e3b39803f2f6af;\n', '\n', '    /**\n', '     * Return index of most significant non-zero bit in given non-zero 256-bit\n', '     * unsigned integer value.\n', '     *\n', '     * @param x value to get index of most significant non-zero bit in\n', '     * @return index of most significant non-zero bit in given number\n', '     */\n', '    function mostSignificantBit (uint256 x) pure internal returns (uint8) {\n', '        require (x > 0);\n', '\n', '        uint8 l = 0;\n', '        uint8 h = 255;\n', '\n', '        while (h > l) {\n', '            uint8 m = uint8 ((uint16 (l) + uint16 (h)) >> 1);\n', '            uint256 t = x >> m;\n', '            if (t == 0) h = m - 1;\n', '            else if (t > 1) l = m + 1;\n', '            else return m;\n', '        }\n', '\n', '        return h;\n', '    }\n', '\n', '    /**\n', '     * Calculate log_2 (x / 2^128) * 2^128.\n', '     *\n', '     * @param x parameter value\n', '     * @return log_2 (x / 2^128) * 2^128\n', '     */\n', '    function log_2 (uint256 x) pure internal returns (int256) {\n', '        require (x > 0);\n', '\n', '        uint8 msb = mostSignificantBit (x);\n', '\n', '        if (msb > 128) x >>= msb - 128;\n', '        else if (msb < 128) x <<= 128 - msb;\n', '\n', '        x &= TWO128_1;\n', '\n', '        int256 result = (int256 (msb) - 128) << 128; // Integer part of log_2\n', '\n', '        int256 bit = TWO127;\n', '        for (uint8 i = 0; i < 128 && x > 0; i++) {\n', '            x = (x << 1) + ((x * x + TWO127) >> 128);\n', '            if (x > TWO128_1) {\n', '                result |= bit;\n', '                x = (x >> 1) - TWO127;\n', '            }\n', '            bit >>= 1;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Calculate ln (x / 2^128) * 2^128.\n', '     *\n', '     * @param x parameter value\n', '     * @return ln (x / 2^128) * 2^128\n', '     */\n', '    function ln (uint256 x) pure internal returns (int256) {\n', '        require (x > 0);\n', '\n', '        int256 l2 = log_2 (x);\n', '        if (l2 == 0) return 0;\n', '        else {\n', '            uint256 al2 = uint256 (l2 > 0 ? l2 : -l2);\n', '            uint8 msb = mostSignificantBit (al2);\n', '            if (msb > 127) al2 >>= msb - 127;\n', '            al2 = (al2 * LN2 + TWO127) >> 128;\n', '            if (msb > 127) al2 <<= msb - 127;\n', '\n', '            return int256 (l2 >= 0 ? al2 : -al2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y / 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x * y / 2^128\n', '     */\n', '    function fpMul (uint256 x, uint256 y) pure internal returns (uint256) {\n', '        uint256 xh = x >> 128;\n', '        uint256 xl = x & TWO128_1;\n', '        uint256 yh = y >> 128;\n', '        uint256 yl = y & TWO128_1;\n', '\n', '        uint256 result = xh * yh;\n', '        require (result <= TWO128_1);\n', '        result <<= 128;\n', '\n', '        result = safeAdd (result, xh * yl);\n', '        result = safeAdd (result, xl * yh);\n', '        result = safeAdd (result, (xl * yl) >> 128);\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return high and low words of x * y\n', '     */\n', '    function longMul (uint256 x, uint256 y)\n', '    pure internal returns (uint256 h, uint256 l) {\n', '        uint256 xh = x >> 128;\n', '        uint256 xl = x & TWO128_1;\n', '        uint256 yh = y >> 128;\n', '        uint256 yl = y & TWO128_1;\n', '\n', '        h = xh * yh;\n', '        l = xl * yl;\n', '\n', '        uint256 m1 = xh * yl;\n', '        uint256 m2 = xl * yh;\n', '\n', '        h += m1 >> 128;\n', '        h += m2 >> 128;\n', '\n', '        m1 <<= 128;\n', '        m2 <<= 128;\n', '\n', '        if (l > TWO256_1 - m1) h += 1;\n', '        l += m1;\n', '\n', '        if (l > TWO256_1 - m2) h += 1;\n', '        l += m2;\n', '    }\n', '\n', '    /**\n', '     * Calculate x * y / 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x * y / 2^128\n', '     */\n', '    function fpMulI (int256 x, int256 y) pure internal returns (int256) {\n', '        bool negative = (x ^ y) < 0; // Whether result is negative\n', '\n', '        uint256 result = fpMul (\n', '            x < 0 ? uint256 (-1 - x) + 1 : uint256 (x),\n', '            y < 0 ? uint256 (-1 - y) + 1 : uint256 (y));\n', '\n', '        if (negative) {\n', '            require (result <= TWO255);\n', '            return result == 0 ? 0 : -1 - int256 (result - 1);\n', '        } else {\n', '            require (result < TWO255);\n', '            return int256 (result);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate x + y, throw in case of over-/underflow.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return x + y\n', '     */\n', '    function safeAddI (int256 x, int256 y) pure internal returns (int256) {\n', '        if (x < 0 && y < 0)\n', '            assert (x >= MINUS_TWO255 - y);\n', '\n', '        if (x > 0 && y > 0)\n', '            assert (x <= TWO255_1 - y);\n', '\n', '        return x + y;\n', '    }\n', '\n', '    /**\n', '     * Calculate x / y * 2^128.\n', '     *\n', '     * @param x parameter x\n', '     * @param y parameter y\n', '     * @return  x / y * 2^128\n', '     */\n', '    function fpDiv (uint256 x, uint256 y) pure internal returns (uint256) {\n', '        require (y > 0); // Division by zero is forbidden\n', '\n', '        uint8 maxShiftY = mostSignificantBit (y);\n', '        if (maxShiftY >= 128) maxShiftY -= 127;\n', '        else maxShiftY = 0;\n', '\n', '        uint256 result = 0;\n', '\n', '        while (true) {\n', '            uint256 rh = x >> 128;\n', '            uint256 rl = x << 128;\n', '\n', '            uint256 ph;\n', '            uint256 pl;\n', '\n', '            (ph, pl) = longMul (result, y);\n', '            if (rl < pl) {\n', '                ph = safeAdd (ph, 1);\n', '            }\n', '\n', '            rl -= pl;\n', '            rh -= ph;\n', '\n', '            if (rh == 0) {\n', '                result = safeAdd (result, rl / y);\n', '                break;\n', '            } else {\n', '                uint256 reminder = (rh << 128) + (rl >> 128);\n', '\n', '                // How many bits to shift reminder left\n', '                uint8 shiftReminder = 255 - mostSignificantBit (reminder);\n', '                if (shiftReminder > 128) shiftReminder = 128;\n', '\n', '                // How many bits to shift result left\n', '                uint8 shiftResult = 128 - shiftReminder;\n', '\n', '                // How many bits to shift Y right\n', '                uint8 shiftY = maxShiftY;\n', '                if (shiftY > shiftResult) shiftY = shiftResult;\n', '\n', '                shiftResult -= shiftY;\n', '\n', '                uint256 r = (reminder << shiftReminder) / (((y - 1) >> shiftY) + 1);\n', '\n', '                uint8 msbR = mostSignificantBit (r);\n', '                require (msbR <= 255 - shiftResult);\n', '\n', '                result = safeAdd (result, r << shiftResult);\n', '            }\n', '        }\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Continuous Sale Action for selling PAT tokens.\n', ' */\n', 'contract PATTokenSale is Math {\n', '    /**\n', '     * Time period when 15% bonus is in force.\n', '     */\n', '    uint256 private constant TRIPLE_BONUS = 1 hours;\n', '\n', '    /**\n', '     * Time period when 10% bonus is in force.\n', '     */\n', '    uint256 private constant DOUBLE_BONUS = 1 days;\n', '\n', '    /**\n', '     * Time period when 5% bonus is in force.\n', '     */\n', '    uint256 private constant SINGLE_BONUS = 1 weeks;\n', '\n', '    /**\n', '     * Create PAT Token Sale smart contract with given sale start time, token\n', '     * contract and central bank address.\n', '     *\n', '     * @param _saleStartTime sale start time\n', '     * @param _saleDuration sale duration\n', '     * @param _token ERC20 smart contract managing tokens to be sold\n', '     * @param _centralBank central bank address to transfer tokens from\n', '     * @param _saleCap maximum amount of ether to collect (in Wei)\n', '     * @param _minimumInvestment minimum investment amount (in Wei)\n', '     * @param _a parameter a of price formula\n', '     * @param _b parameter b of price formula\n', '     * @param _c parameter c of price formula\n', '     */\n', '    function PATTokenSale (\n', '        uint256 _saleStartTime, uint256 _saleDuration,\n', '        Token _token, address _centralBank,\n', '        uint256 _saleCap, uint256 _minimumInvestment,\n', '        int256 _a, int256 _b, int256 _c) {\n', '        saleStartTime = _saleStartTime;\n', '        saleDuration = _saleDuration;\n', '        token = _token;\n', '        centralBank = _centralBank;\n', '        saleCap = _saleCap;\n', '        minimumInvestment = _minimumInvestment;\n', '        a = _a;\n', '        b = _b;\n', '        c = _c;\n', '    }\n', '\n', '    /**\n', '     * Equivalent to buy().\n', '     */\n', '    function () payable public {\n', '        require (msg.data.length == 0);\n', '\n', '        buy ();\n', '    }\n', '\n', '    /**\n', '     * Buy tokens.\n', '     */\n', '    function buy () payable public {\n', '        require (!finished);\n', '        require (now >= saleStartTime);\n', '        require (now < safeAdd (saleStartTime, saleDuration));\n', '\n', '        require (msg.value >= minimumInvestment);\n', '\n', '        if (msg.value > 0) {\n', '            uint256 remainingCap = safeSub (saleCap, totalInvested);\n', '            uint256 toInvest;\n', '            uint256 toRefund;\n', '\n', '            if (msg.value <= remainingCap) {\n', '                toInvest = msg.value;\n', '                toRefund = 0;\n', '            } else {\n', '                toInvest = remainingCap;\n', '                toRefund = safeSub (msg.value, toInvest);\n', '            }\n', '\n', '            Investor storage investor = investors [msg.sender];\n', '            investor.amount = safeAdd (investor.amount, toInvest);\n', '            if (now < safeAdd (saleStartTime, TRIPLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 6));\n', '            else if (now < safeAdd (saleStartTime, DOUBLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 4));\n', '            else if (now < safeAdd (saleStartTime, SINGLE_BONUS))\n', '                investor.bonusAmount = safeAdd (\n', '                    investor.bonusAmount, safeMul (toInvest, 2));\n', '\n', '            Investment (msg.sender, toInvest);\n', '\n', '            totalInvested = safeAdd (totalInvested, toInvest);\n', '            if (toInvest == remainingCap) {\n', '                finished = true;\n', '                finalPrice = price (now);\n', '\n', '                Finished (finalPrice);\n', '            }\n', '\n', '            if (toRefund > 0)\n', '                msg.sender.transfer (toRefund);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Buy tokens providing referral code.\n', '     *\n', '     * @param _referralCode referral code, actually address of referee\n', '     */\n', '    function buyReferral (address _referralCode) payable public {\n', '        require (msg.sender != _referralCode);\n', '\n', '        Investor storage referee = investors [_referralCode];\n', '\n', '        // Make sure referee actually did invest something\n', '        require (referee.amount > 0);\n', '\n', '        Investor storage referrer = investors [msg.sender];\n', '        uint256 oldAmount = referrer.amount;\n', '\n', '        buy ();\n', '\n', '        uint256 invested = safeSub (referrer.amount, oldAmount);\n', '\n', '        // Make sure referrer actually did invest something\n', '        require (invested > 0);\n', '\n', '        referee.investedByReferrers = safeAdd (\n', '            referee.investedByReferrers, invested);\n', '\n', '        referrer.bonusAmount = safeAdd (\n', '            referrer.bonusAmount,\n', '            min (referee.amount, invested));\n', '    }\n', '\n', '    /**\n', '     * Get number of tokens to be delivered to given investor.\n', '     *\n', '     * @param _investor address of the investor to get number of tokens to be\n', '     *        delivered to\n', '     * @return number of tokens to be delivered to given investor\n', '     */\n', '    function outstandingTokens (address _investor)\n', '    constant public returns (uint256) {\n', '        require (finished);\n', '        assert (finalPrice > 0);\n', '\n', '        Investor storage investor = investors [_investor];\n', '        uint256 bonusAmount = investor.bonusAmount;\n', '        bonusAmount = safeAdd (\n', '            bonusAmount, min (investor.amount, investor.investedByReferrers));\n', '\n', '        uint256 effectiveAmount = safeAdd (\n', '            investor.amount,\n', '            bonusAmount / 40);\n', '\n', '        return fpDiv (effectiveAmount, finalPrice);\n', '    }\n', '\n', '    /**\n', '     * Deliver purchased tokens to given investor.\n', '     *\n', '     * @param _investor investor to deliver purchased tokens to\n', '     */\n', '    function deliver (address _investor) public returns (bool) {\n', '        require (finished);\n', '\n', '        Investor storage investor = investors [_investor];\n', '        require (investor.amount > 0);\n', '\n', '        uint256 value = outstandingTokens (_investor);\n', '        if (value > 0) {\n', '            if (!token.transferFrom (centralBank, _investor, value)) return false;\n', '        }\n', '\n', '        totalInvested = safeSub (totalInvested, investor.amount);\n', '        investor.amount = 0;\n', '        investor.bonusAmount = 0;\n', '        investor.investedByReferrers = 0;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Collect sale revenue.\n', '     */\n', '    function collectRevenue () public {\n', '        require (msg.sender == centralBank);\n', '\n', '        centralBank.transfer (this.balance);\n', '    }\n', '\n', '    /**\n', '     * Return token price at given time in Wei per token natural unit.\n', '     *\n', '     * @param _time time to return price at\n', '     * @return price at given time as 128.128 fixed point number\n', '     */\n', '    function price (uint256 _time) constant public returns (uint256) {\n', '        require (_time >= saleStartTime);\n', '        require (_time <= safeAdd (saleStartTime, saleDuration));\n', '\n', '        require (_time <= TWO128_1);\n', '        uint256 t = _time << 128;\n', '\n', '        uint256 cPlusT = (c >= 0) ?\n', '        safeAdd (t, uint256 (c)) :\n', '        safeSub (t, uint256 (-1 - c) + 1);\n', '        int256 lnCPlusT = ln (cPlusT);\n', '        int256 bLnCPlusT = fpMulI (b, lnCPlusT);\n', '        int256 aPlusBLnCPlusT = safeAddI (a, bLnCPlusT);\n', '\n', '        require (aPlusBLnCPlusT >= 0);\n', '        return uint256 (aPlusBLnCPlusT);\n', '    }\n', '\n', '    /**\n', '     * Finish sale after sale period ended.\n', '     */\n', '    function finishSale () public {\n', '        require (msg.sender == centralBank);\n', '        require (!finished);\n', '        uint256 saleEndTime = safeAdd (saleStartTime, saleDuration);\n', '        require (now >= saleEndTime);\n', '\n', '        finished = true;\n', '        finalPrice = price (saleEndTime);\n', '\n', '        Finished (finalPrice);\n', '    }\n', '\n', '    /**\n', '     * Destroy smart contract.\n', '     */\n', '    function destroy () public {\n', '        require (msg.sender == centralBank);\n', '        require (finished);\n', '        require (now >= safeAdd (saleStartTime, saleDuration));\n', '        require (totalInvested == 0);\n', '        require (this.balance == 0);\n', '\n', '        selfdestruct (centralBank);\n', '    }\n', '\n', '    /**\n', '     * Return minimum of two values.\n', '     *\n', '     * @param x first value\n', '     * @param y second value\n', '     * @return minimum of two values\n', '     */\n', '    function min (uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x < y ? x : y;\n', '    }\n', '\n', '    /**\n', '     * Sale start time.\n', '     */\n', '    uint256 internal saleStartTime;\n', '\n', '    /**\n', '     * Sale duration.\n', '     */\n', '    uint256 internal saleDuration;\n', '\n', '    /**\n', '     * ERC20 token smart contract managing tokens to be sold.\n', '     */\n', '    Token internal token;\n', '\n', '    /**\n', '     * Address of central bank to transfer tokens from.\n', '     */\n', '    address internal centralBank;\n', '\n', '    /**\n', '     * Maximum number of Wei to collect.\n', '     */\n', '    uint256 internal saleCap;\n', '\n', '    /**\n', '     * Minimum investment amount in Wei.\n', '     */\n', '    uint256 internal minimumInvestment;\n', '\n', '    /**\n', '     * Price formula parameters.  Price at given time t is calculated as\n', '     * a / 2^128 + b * ln ((c + t) / 2^128) / 2^128.\n', '     */\n', '    int256 internal a;\n', '    int256 internal b;\n', '    int256 internal c;\n', '\n', '    /**\n', '     * True is sale was finished successfully, false otherwise.\n', '     */\n', '    bool internal finished = false;\n', '\n', '    /**\n', '     * Final price for finished sale.\n', '     */\n', '    uint256 internal finalPrice;\n', '\n', '    /**\n', "     * Maps investor's address to corresponding Investor structure.\n", '     */\n', '    mapping (address => Investor) internal investors;\n', '\n', '    /**\n', '     * Total amount invested in Wei.\n', '     */\n', '    uint256 internal totalInvested = 0;\n', '\n', '    /**\n', '     * Encapsulates information about investor.\n', '     */\n', '    struct Investor {\n', '        /**\n', '         * Total amount invested in Wei.\n', '         */\n', '        uint256 amount;\n', '\n', '        /**\n', '         * Bonus amount in Wei multiplied by 40.\n', '         */\n', '        uint256 bonusAmount;\n', '\n', '        /**\n', '         * Total amount of ether invested by others while referring this address.\n', '         */\n', '        uint256 investedByReferrers;\n', '    }\n', '\n', '    /**\n', '     * Logged when an investment was made.\n', '     *\n', '     * @param investor address of the investor who made the investment\n', '     * @param amount investment amount\n', '     */\n', '    event Investment (address indexed investor, uint256 amount);\n', '\n', '    /**\n', '     * Logged when sale finished successfully.\n', '     *\n', '     * @param finalPrice final price of the sale in Wei per token natural unit as\n', '     *                   128.128 bit fixed point number.\n', '     */\n', '    event Finished (uint256 finalPrice);\n', '}']
