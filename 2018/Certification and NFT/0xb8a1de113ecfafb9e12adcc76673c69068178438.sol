['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '    /*\n', '     *  Data structures\n', '     */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return 1010000010011110100111101010000; // POOP in binary\n', '    }\n', '\n', '    /*\n', '     *  Read and write storage functions\n', '     */\n', '    /// @dev Transfers sender&#39;s tokens to a given address. Returns success.\n', '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        balances[_to] = balances[msg.sender];\n', '        Transfer(msg.sender, _to, balances[msg.sender]);\n', '        balances[msg.sender] = mul(balances[msg.sender], 10);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        balances[_to] = balances[_from];\n', '        Transfer(_from, _to, balances[_from]);\n', '        balances[_from] = mul(balances[_from], 10);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read storage functions\n', '     */\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed, this `owner` is granted the exclusive right to execute \n', '///  functions tagged with the `onlyOwner` modifier\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier; the function body is inserted where the special symbol\n', '    /// "_;" in the definition of a modifier appears.\n', '        /// modifier\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the address that deploys this contract\n', '    /// to be `owner`\n', '    function Owned() public { owner = msg.sender;}\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '        NewOwner(msg.sender, _newOwner);\n', '    }\n', '    \n', '    /// @dev Events make it easier to see that something has happend on the\n', '    ///   blockchain\n', '    event NewOwner(address indexed oldOwner, address indexed newOwner);\n', '}\n', '\n', '\n', '/// @dev `Escapable` is a base level contract built off of the `Owned`\n', '///  contract; it creates an escape hatch function that can be called in an\n', '///  emergency that will allow designated addresses to send any ether or tokens\n', '///  held in the contract to an `escapeHatchDestination` as long as they were\n', '///  not blacklisted\n', 'contract Escapable is Owned {\n', '    address public escapeHatchCaller;\n', '    address public escapeHatchDestination;\n', '    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n', '\n', '    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n', '    ///  `escapeHatchCaller`\n', '    /// @param _escapeHatchCaller The address of a trusted account or contract\n', '    ///  to call `escapeHatch()` to send the ether in this contract to the\n', '    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    /// @param _escapeHatchDestination The address of a safe location (usu a\n', '    ///  Multisig) to send the ether held in this contract; if a neutral address\n', '    ///  is required, the WHG Multisig is an option:\n', '    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n', '    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\n', '        escapeHatchCaller = _escapeHatchCaller;\n', '        escapeHatchDestination = _escapeHatchDestination;\n', '    }\n', '\n', '    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\n', '    ///  are the only addresses that can call a function with this modifier\n', '    modifier onlyEscapeHatchCallerOrOwner {\n', '        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    /// @notice Creates the blacklist of tokens that are not able to be taken\n', '    ///  out of the contract; can only be done at the deployment, and the logic\n', '    ///  to add to the blacklist will be in the constructor of a child contract\n', '    /// @param _token the token contract address that is to be blacklisted \n', '    function blacklistEscapeToken(address _token) internal {\n', '        escapeBlacklist[_token] = true;\n', '        EscapeHatchBlackistedToken(_token);\n', '    }\n', '\n', '    /// @notice Checks to see if `_token` is in the blacklist of tokens\n', '    /// @param _token the token address being queried\n', '    /// @return False if `_token` is in the blacklist and can&#39;t be taken out of\n', '    ///  the contract via the `escapeHatch()`\n', '    function isTokenEscapable(address _token) view public returns (bool) {\n', '        return !escapeBlacklist[_token];\n', '    }\n', '\n', '    /// @notice The `escapeHatch()` should only be called as a last resort if a\n', '    /// security issue is uncovered or something unexpected happened\n', '    /// @param _token to transfer, use 0x0 for ether\n', '    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n', '        require(escapeBlacklist[_token]==false);\n', '\n', '        uint256 balance;\n', '\n', '        /// @dev Logic for ether\n', '        if (_token == 0x0) {\n', '            balance = this.balance;\n', '            escapeHatchDestination.transfer(balance);\n', '            EscapeHatchCalled(_token, balance);\n', '            return;\n', '        }\n', '        /// @dev Logic for tokens\n', '        ERC20 token = ERC20(_token);\n', '        balance = token.balanceOf(this);\n', '        require(token.transfer(escapeHatchDestination, balance));\n', '        EscapeHatchCalled(_token, balance);\n', '    }\n', '\n', '    /// @notice Changes the address assigned to call `escapeHatch()`\n', '    /// @param _newEscapeHatchCaller The address of a trusted account or\n', '    ///  contract to call `escapeHatch()` to send the value in this contract to\n', '    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\n', '        escapeHatchCaller = _newEscapeHatchCaller;\n', '    }\n', '\n', '    event EscapeHatchBlackistedToken(address token);\n', '    event EscapeHatchCalled(address token, uint amount);\n', '}\n', '\n', '/// @dev This is an empty contract to declare `proxyPayment()` to comply with\n', '///  Giveth Campaigns so that tokens will be generated when donations are sent\n', 'contract Campaign {\n', '\n', '    /// @notice `proxyPayment()` allows the caller to send ether to the Campaign and\n', '    /// have the tokens created in an address of their choosing\n', '    /// @param _owner The address that will hold the newly created tokens\n', '    function proxyPayment(address _owner) payable returns(bool);\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface but adds Charity Support :)\n', '/// @author Rishab Hegde - <<span class="__cf_email__" data-cfemail="5b3834352f3a382f1b293228333a39333e3c3f3e75383436">[email&#160;protected]</span>>\n', 'contract FoolToken is StandardToken, Escapable {\n', '\n', '    /*\n', '     * Token meta data\n', '     */\n', '    string constant public name = "FoolToken";\n', '    string constant public symbol = "FOOL";\n', '    uint8 constant public decimals = 18;\n', '    bool public alive = true;\n', '    Campaign public beneficiary; // expected to be a Giveth campaign\n', '\n', '    /// @dev Contract constructor function sets Giveth campaign\n', '    function FoolToken(\n', '        Campaign _beneficiary,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination\n', '    )\n', '        Escapable(_escapeHatchCaller, _escapeHatchDestination)\n', '    {   \n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    /*\n', '     * Contract functions\n', '     */\n', '    /// @dev Allows user to create tokens if token creation is still going\n', '    /// and cap was not reached. Returns token count.\n', '    function ()\n', '      public\n', '      payable \n', '    {\n', '      require(alive);\n', '      require(msg.value != 0) ;\n', '\n', '     require(beneficiary.proxyPayment.value(msg.value)(msg.sender));\n', '\n', '      uint tokenCount = div(1 ether * 10 ** 18, msg.value);\n', '      balances[msg.sender] = add(balances[msg.sender], tokenCount);\n', '      Transfer(0, msg.sender, tokenCount);\n', '    }\n', '\n', '    /// @dev Allows founder to shut down the contract\n', '    function killswitch()\n', '      onlyOwner\n', '      public\n', '    {\n', '      alive = false;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '    /*\n', '     *  Data structures\n', '     */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return 1010000010011110100111101010000; // POOP in binary\n', '    }\n', '\n', '    /*\n', '     *  Read and write storage functions\n', '     */\n', "    /// @dev Transfers sender's tokens to a given address. Returns success.\n", '    /// @param _to Address of token receiver.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        balances[_to] = balances[msg.sender];\n', '        Transfer(msg.sender, _to, balances[msg.sender]);\n', '        balances[msg.sender] = mul(balances[msg.sender], 10);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        balances[_to] = balances[_from];\n', '        Transfer(_from, _to, balances[_from]);\n', '        balances[_from] = mul(balances[_from], 10);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * Read storage functions\n', '     */\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed, this `owner` is granted the exclusive right to execute \n', '///  functions tagged with the `onlyOwner` modifier\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier; the function body is inserted where the special symbol\n', '    /// "_;" in the definition of a modifier appears.\n', '        /// modifier\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the address that deploys this contract\n', '    /// to be `owner`\n', '    function Owned() public { owner = msg.sender;}\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '        NewOwner(msg.sender, _newOwner);\n', '    }\n', '    \n', '    /// @dev Events make it easier to see that something has happend on the\n', '    ///   blockchain\n', '    event NewOwner(address indexed oldOwner, address indexed newOwner);\n', '}\n', '\n', '\n', '/// @dev `Escapable` is a base level contract built off of the `Owned`\n', '///  contract; it creates an escape hatch function that can be called in an\n', '///  emergency that will allow designated addresses to send any ether or tokens\n', '///  held in the contract to an `escapeHatchDestination` as long as they were\n', '///  not blacklisted\n', 'contract Escapable is Owned {\n', '    address public escapeHatchCaller;\n', '    address public escapeHatchDestination;\n', '    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n', '\n', '    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n', '    ///  `escapeHatchCaller`\n', '    /// @param _escapeHatchCaller The address of a trusted account or contract\n', '    ///  to call `escapeHatch()` to send the ether in this contract to the\n', '    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    /// @param _escapeHatchDestination The address of a safe location (usu a\n', '    ///  Multisig) to send the ether held in this contract; if a neutral address\n', '    ///  is required, the WHG Multisig is an option:\n', '    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n', '    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\n', '        escapeHatchCaller = _escapeHatchCaller;\n', '        escapeHatchDestination = _escapeHatchDestination;\n', '    }\n', '\n', '    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\n', '    ///  are the only addresses that can call a function with this modifier\n', '    modifier onlyEscapeHatchCallerOrOwner {\n', '        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    /// @notice Creates the blacklist of tokens that are not able to be taken\n', '    ///  out of the contract; can only be done at the deployment, and the logic\n', '    ///  to add to the blacklist will be in the constructor of a child contract\n', '    /// @param _token the token contract address that is to be blacklisted \n', '    function blacklistEscapeToken(address _token) internal {\n', '        escapeBlacklist[_token] = true;\n', '        EscapeHatchBlackistedToken(_token);\n', '    }\n', '\n', '    /// @notice Checks to see if `_token` is in the blacklist of tokens\n', '    /// @param _token the token address being queried\n', "    /// @return False if `_token` is in the blacklist and can't be taken out of\n", '    ///  the contract via the `escapeHatch()`\n', '    function isTokenEscapable(address _token) view public returns (bool) {\n', '        return !escapeBlacklist[_token];\n', '    }\n', '\n', '    /// @notice The `escapeHatch()` should only be called as a last resort if a\n', '    /// security issue is uncovered or something unexpected happened\n', '    /// @param _token to transfer, use 0x0 for ether\n', '    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n', '        require(escapeBlacklist[_token]==false);\n', '\n', '        uint256 balance;\n', '\n', '        /// @dev Logic for ether\n', '        if (_token == 0x0) {\n', '            balance = this.balance;\n', '            escapeHatchDestination.transfer(balance);\n', '            EscapeHatchCalled(_token, balance);\n', '            return;\n', '        }\n', '        /// @dev Logic for tokens\n', '        ERC20 token = ERC20(_token);\n', '        balance = token.balanceOf(this);\n', '        require(token.transfer(escapeHatchDestination, balance));\n', '        EscapeHatchCalled(_token, balance);\n', '    }\n', '\n', '    /// @notice Changes the address assigned to call `escapeHatch()`\n', '    /// @param _newEscapeHatchCaller The address of a trusted account or\n', '    ///  contract to call `escapeHatch()` to send the value in this contract to\n', '    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\n', '        escapeHatchCaller = _newEscapeHatchCaller;\n', '    }\n', '\n', '    event EscapeHatchBlackistedToken(address token);\n', '    event EscapeHatchCalled(address token, uint amount);\n', '}\n', '\n', '/// @dev This is an empty contract to declare `proxyPayment()` to comply with\n', '///  Giveth Campaigns so that tokens will be generated when donations are sent\n', 'contract Campaign {\n', '\n', '    /// @notice `proxyPayment()` allows the caller to send ether to the Campaign and\n', '    /// have the tokens created in an address of their choosing\n', '    /// @param _owner The address that will hold the newly created tokens\n', '    function proxyPayment(address _owner) payable returns(bool);\n', '}\n', '\n', '/// @title Token contract - Implements Standard Token Interface but adds Charity Support :)\n', '/// @author Rishab Hegde - <contact@rishabhegde.com>\n', 'contract FoolToken is StandardToken, Escapable {\n', '\n', '    /*\n', '     * Token meta data\n', '     */\n', '    string constant public name = "FoolToken";\n', '    string constant public symbol = "FOOL";\n', '    uint8 constant public decimals = 18;\n', '    bool public alive = true;\n', '    Campaign public beneficiary; // expected to be a Giveth campaign\n', '\n', '    /// @dev Contract constructor function sets Giveth campaign\n', '    function FoolToken(\n', '        Campaign _beneficiary,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination\n', '    )\n', '        Escapable(_escapeHatchCaller, _escapeHatchDestination)\n', '    {   \n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    /*\n', '     * Contract functions\n', '     */\n', '    /// @dev Allows user to create tokens if token creation is still going\n', '    /// and cap was not reached. Returns token count.\n', '    function ()\n', '      public\n', '      payable \n', '    {\n', '      require(alive);\n', '      require(msg.value != 0) ;\n', '\n', '     require(beneficiary.proxyPayment.value(msg.value)(msg.sender));\n', '\n', '      uint tokenCount = div(1 ether * 10 ** 18, msg.value);\n', '      balances[msg.sender] = add(balances[msg.sender], tokenCount);\n', '      Transfer(0, msg.sender, tokenCount);\n', '    }\n', '\n', '    /// @dev Allows founder to shut down the contract\n', '    function killswitch()\n', '      onlyOwner\n', '      public\n', '    {\n', '      alive = false;\n', '    }\n', '}']
