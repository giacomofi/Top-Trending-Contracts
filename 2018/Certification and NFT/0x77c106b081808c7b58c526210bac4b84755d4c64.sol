['pragma solidity 0.4.24;\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/interfaces/DisbursementHandlerI.sol\n', '\n', 'interface DisbursementHandlerI {\n', '    function withdraw(address _beneficiary, uint256 _index) external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '\n', '  function safeTransferFrom(\n', '    ERC20 token,\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  )\n', '    internal\n', '  {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '\n', '  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '    require(token.approve(spender, value));\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/DisbursementHandler.sol\n', '\n', '/// @title Disbursement handler - Manages time locked disbursements of ERC20 tokens\n', 'contract DisbursementHandler is DisbursementHandlerI, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    struct Disbursement {\n', '        // Tokens cannot be withdrawn before this timestamp\n', '        uint256 timestamp;\n', '\n', '        // Amount of tokens to be disbursed\n', '        uint256 value;\n', '    }\n', '\n', '    event Setup(address indexed _beneficiary, uint256 _timestamp, uint256 _value);\n', '    event TokensWithdrawn(address indexed _to, uint256 _value);\n', '\n', '    ERC20 public token;\n', '    uint256 public totalAmount;\n', '    mapping(address => Disbursement[]) public disbursements;\n', '\n', '    bool public closed;\n', '\n', '    modifier isOpen {\n', '        require(!closed, "Disbursement Handler is closed");\n', '        _;\n', '    }\n', '\n', '    modifier isClosed {\n', '        require(closed, "Disbursement Handler is open");\n', '        _;\n', '    }\n', '\n', '\n', '    constructor(ERC20 _token) public {\n', '        require(_token != address(0), "Token cannot have address 0");\n', '        token = _token;\n', '    }\n', '\n', '    /// @dev Called to create disbursements.\n', '    /// @param _beneficiaries The addresses of the beneficiaries.\n', '    /// @param _values The number of tokens to be locked for each disbursement.\n', '    /// @param _timestamps Funds will be locked until this timestamp for each disbursement.\n', '    function setupDisbursements(\n', '        address[] _beneficiaries,\n', '        uint256[] _values,\n', '        uint256[] _timestamps\n', '    )\n', '        external\n', '        onlyOwner\n', '        isOpen\n', '    {\n', '        require((_beneficiaries.length == _values.length) && (_beneficiaries.length == _timestamps.length), "Arrays not of equal length");\n', '        require(_beneficiaries.length > 0, "Arrays must have length > 0");\n', '\n', '        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n', '            setupDisbursement(_beneficiaries[i], _values[i], _timestamps[i]);\n', '        }\n', '    }\n', '\n', '    function close() external onlyOwner isOpen {\n', '        closed = true;\n', '    }\n', '\n', '    /// @dev Called by the sale contract to create a disbursement.\n', '    /// @param _beneficiary The address of the beneficiary.\n', '    /// @param _value Amount of tokens to be locked.\n', '    /// @param _timestamp Funds will be locked until this timestamp.\n', '    function setupDisbursement(\n', '        address _beneficiary,\n', '        uint256 _value,\n', '        uint256 _timestamp\n', '    )\n', '        internal\n', '    {\n', '        require(block.timestamp < _timestamp, "Disbursement timestamp in the past");\n', '        disbursements[_beneficiary].push(Disbursement(_timestamp, _value));\n', '        totalAmount = totalAmount.add(_value);\n', '        emit Setup(_beneficiary, _timestamp, _value);\n', '    }\n', '\n', '    /// @dev Transfers tokens to a beneficiary\n', '    /// @param _beneficiary The address to transfer tokens to\n', '    /// @param _index The index of the disbursement\n', '    function withdraw(address _beneficiary, uint256 _index)\n', '        external\n', '        isClosed\n', '    {\n', '        Disbursement[] storage beneficiaryDisbursements = disbursements[_beneficiary];\n', '        require(_index < beneficiaryDisbursements.length, "Supplied index out of disbursement range");\n', '\n', '        Disbursement memory disbursement = beneficiaryDisbursements[_index];\n', '        require(disbursement.timestamp < now && disbursement.value > 0, "Disbursement timestamp not reached, or disbursement value of 0");\n', '\n', '        // Remove the withdrawn disbursement\n', '        delete beneficiaryDisbursements[_index];\n', '\n', '        token.safeTransfer(_beneficiary, disbursement.value);\n', '        emit TokensWithdrawn(_beneficiary, disbursement.value);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/interfaces/VaultI.sol\n', '\n', 'interface VaultI {\n', '    function deposit(address contributor) external payable;\n', '    function saleSuccessful() external;\n', '    function enableRefunds() external;\n', '    function refund(address contributor) external;\n', '    function close() external;\n', '    function sendFundsToWallet() external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Vault.sol\n', '\n', "// Adapted from Open Zeppelin's RefundVault\n", '\n', '/**\n', ' * @title Vault\n', ' * @dev This contract is used for storing funds while a crowdsale\n', ' * is in progress. Supports refunding the money if crowdsale fails,\n', ' * and forwarding it if crowdsale is successful.\n', ' */\n', 'contract Vault is VaultI, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    enum State { Active, Success, Refunding, Closed }\n', '\n', '    // The timestamp of the first deposit\n', '    uint256 public firstDepositTimestamp; \n', '\n', '    mapping (address => uint256) public deposited;\n', '\n', '    // The amount to be disbursed to the wallet every month\n', '    uint256 public disbursementWei;\n', '    uint256 public disbursementDuration;\n', '\n', '    // Wallet from the project team\n', '    address public trustedWallet;\n', '\n', '    // The eth amount the team will get initially if the sale is successful\n', '    uint256 public initialWei;\n', '\n', '    // Timestamp that has to pass before sending funds to the wallet\n', '    uint256 public nextDisbursement;\n', '    \n', '    // Total amount that was deposited\n', '    uint256 public totalDeposited;\n', '\n', '    // Amount that can be refunded\n', '    uint256 public refundable;\n', '\n', '    State public state;\n', '\n', '    event Closed();\n', '    event RefundsEnabled();\n', '    event Refunded(address indexed contributor, uint256 amount);\n', '\n', '    modifier atState(State _state) {\n', '        require(state == _state, "This function cannot be called in the current vault state.");\n', '        _;\n', '    }\n', '\n', '    constructor (\n', '        address _wallet,\n', '        uint256 _initialWei,\n', '        uint256 _disbursementWei,\n', '        uint256 _disbursementDuration\n', '    ) \n', '        public \n', '    {\n', '        require(_wallet != address(0), "Wallet address should not be 0.");\n', '        require(_disbursementWei != 0, "Disbursement Wei should be greater than 0.");\n', '        trustedWallet = _wallet;\n', '        initialWei = _initialWei;\n', '        disbursementWei = _disbursementWei;\n', '        disbursementDuration = _disbursementDuration;\n', '        state = State.Active;\n', '    }\n', '\n', '    /// @dev Called by the sale contract to deposit ether for a contributor.\n', '    function deposit(address _contributor) onlyOwner external payable {\n', '        require(state == State.Active || state == State.Success , "Vault state must be Active or Success.");\n', '        if (firstDepositTimestamp == 0) {\n', '            firstDepositTimestamp = now;\n', '        }\n', '        totalDeposited = totalDeposited.add(msg.value);\n', '        deposited[_contributor] = deposited[_contributor].add(msg.value);\n', '    }\n', '\n', '    /// @dev Sends initial funds to the wallet.\n', '    function saleSuccessful()\n', '        onlyOwner \n', '        external \n', '        atState(State.Active)\n', '    {\n', '        state = State.Success;\n', '        transferToWallet(initialWei);\n', '    }\n', '\n', "    /// @dev Called by the owner if the project didn't deliver the testnet contracts or if we need to stop disbursements for any reasone.\n", '    function enableRefunds() onlyOwner external {\n', '        require(state != State.Refunding, "Vault state is not Refunding");\n', '        state = State.Refunding;\n', '        uint256 currentBalance = address(this).balance;\n', '        refundable = currentBalance <= totalDeposited ? currentBalance : totalDeposited;\n', '        emit RefundsEnabled();\n', '    }\n', '\n', '    /// @dev Refunds ether to the contributors if in the Refunding state.\n', '    function refund(address _contributor) external atState(State.Refunding) {\n', '        require(deposited[_contributor] > 0, "Refund not allowed if contributor deposit is 0.");\n', '        uint256 refundAmount = deposited[_contributor].mul(refundable).div(totalDeposited);\n', '        deposited[_contributor] = 0;\n', '        _contributor.transfer(refundAmount);\n', '        emit Refunded(_contributor, refundAmount);\n', '    }\n', '\n', '    /// @dev Called by the owner if the sale has ended.\n', '    function close() external atState(State.Success) onlyOwner {\n', '        state = State.Closed;\n', '        nextDisbursement = now;\n', '        emit Closed();\n', '    }\n', '\n', '    /// @dev Sends the disbursement amount to the wallet after the disbursement period has passed. Can be called by anyone.\n', '    function sendFundsToWallet() external atState(State.Closed) {\n', '        require(firstDepositTimestamp.add(4 weeks) <= now, "First contributor\\Å„0027s deposit was less than 28 days ago");\n', '        require(nextDisbursement <= now, "Next disbursement period timestamp has not yet passed, too early to withdraw.");\n', '\n', '        if (disbursementDuration == 0) {\n', '            trustedWallet.transfer(address(this).balance);\n', '            return;\n', '        }\n', '\n', '        uint256 numberOfDisbursements = now.sub(nextDisbursement).div(disbursementDuration).add(1);\n', '\n', '        nextDisbursement = nextDisbursement.add(disbursementDuration.mul(numberOfDisbursements));\n', '\n', '        transferToWallet(disbursementWei.mul(numberOfDisbursements));\n', '    }\n', '\n', '    function transferToWallet(uint256 _amount) internal {\n', '        uint256 amountToSend = Math.min256(_amount, address(this).balance);\n', '        trustedWallet.transfer(amountToSend);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/interfaces/WhitelistableI.sol\n', '\n', 'interface WhitelistableI {\n', '    function changeAdmin(address _admin) external;\n', '    function invalidateHash(bytes32 _hash) external;\n', '    function invalidateHashes(bytes32[] _hashes) external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ECRecovery.sol\n', '\n', '/**\n', ' * @title Eliptic curve signature operations\n', ' *\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' *\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' */\n', '\n', 'library ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes sig)\n', '    internal\n', '    pure\n', '    returns (address)\n', '  {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    // Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * toEthSignedMessageHash\n', '   * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '   * @dev and hash the result\n', '   */\n', '  function toEthSignedMessageHash(bytes32 hash)\n', '    internal\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    // 32 is the length in bytes of hash,\n', '    // enforced by the type signature above\n', '    return keccak256(\n', '      "\\x19Ethereum Signed Message:\\n32",\n', '      hash\n', '    );\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Whitelistable.sol\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev This contract is used to implement a signature based whitelisting mechanism\n', ' */\n', 'contract Whitelistable is WhitelistableI, Ownable {\n', '    using ECRecovery for bytes32;\n', '\n', '    address public whitelistAdmin;\n', '\n', '    // True if the hash has been invalidated\n', '    mapping(bytes32 => bool) public invalidHash;\n', '\n', '    event AdminUpdated(address indexed newAdmin);\n', '\n', '    modifier validAdmin(address _admin) {\n', '        require(_admin != 0, "Admin address cannot be 0");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == whitelistAdmin, "Only the whitelist admin may call this function");\n', '        _;\n', '    }\n', '\n', '    modifier isWhitelisted(bytes32 _hash, bytes _sig) {\n', '        require(checkWhitelisted(_hash, _sig), "The provided hash is not whitelisted");\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor for Whitelistable contract\n', '    /// @param _admin the address of the admin that will generate the signatures\n', '    constructor(address _admin) public validAdmin(_admin) {\n', '        whitelistAdmin = _admin;        \n', '    }\n', '\n', '    /// @dev Updates whitelistAdmin address \n', '    /// @dev Can only be called by the current owner\n', '    /// @param _admin the new admin address\n', '    function changeAdmin(address _admin)\n', '        external\n', '        onlyOwner\n', '        validAdmin(_admin)\n', '    {\n', '        emit AdminUpdated(_admin);\n', '        whitelistAdmin = _admin;\n', '    }\n', '\n', '    // @dev blacklists the given address to ban them from contributing\n', '    // @param _contributor Address of the contributor to blacklist \n', '    function invalidateHash(bytes32 _hash) external onlyAdmin {\n', '        invalidHash[_hash] = true;\n', '    }\n', '\n', '    function invalidateHashes(bytes32[] _hashes) external onlyAdmin {\n', '        for (uint i = 0; i < _hashes.length; i++) {\n', '            invalidHash[_hashes[i]] = true;\n', '        }\n', '    }\n', '\n', '    /// @dev Checks if a hash has been signed by the whitelistAdmin\n', '    /// @param _rawHash The hash that was used to generate the signature\n', '    /// @param _sig The EC signature generated by the whitelistAdmin\n', '    /// @return Was the signature generated by the admin for the hash?\n', '    function checkWhitelisted(\n', '        bytes32 _rawHash,\n', '        bytes _sig\n', '    )\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        bytes32 hash = _rawHash.toEthSignedMessageHash();\n', '        return !invalidHash[_rawHash] && whitelistAdmin == hash.recover(_sig);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/interfaces/EthPriceFeedI.sol\n', '\n', 'interface EthPriceFeedI {\n', '    function getUnit() external view returns(string);\n', '    function getRate() external view returns(uint256);\n', '    function getLastTimeUpdated() external view returns(uint256); \n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/interfaces/SaleI.sol\n', '\n', 'interface SaleI {\n', '    function setup() external;  \n', '    function changeEthPriceFeed(EthPriceFeedI newPriceFeed) external;\n', '    function contribute(address _contributor, uint256 _limit, uint256 _expiration, bytes _sig) external payable; \n', '    function allocateExtraTokens(address _contributor) external;\n', '    function setEndTime(uint256 _endTime) external;\n', '    function endSale() external;\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/StateMachine.sol\n', '\n', 'contract StateMachine {\n', '\n', '    struct State { \n', '        bytes32 nextStateId;\n', '        mapping(bytes4 => bool) allowedFunctions;\n', '        function() internal[] transitionCallbacks;\n', '        function(bytes32) internal returns(bool)[] startConditions;\n', '    }\n', '\n', '    mapping(bytes32 => State) states;\n', '\n', '    // The current state id\n', '    bytes32 private currentStateId;\n', '\n', '    event Transition(bytes32 stateId, uint256 blockNumber);\n', '\n', '    /* This modifier performs the conditional transitions and checks that the function \n', '     * to be executed is allowed in the current State\n', '     */\n', '    modifier checkAllowed {\n', '        conditionalTransitions();\n', '        require(states[currentStateId].allowedFunctions[msg.sig]);\n', '        _;\n', '    }\n', '\n', '    ///@dev transitions the state machine into the state it should currently be in\n', '    ///@dev by taking into account the current conditions and how many further transitions can occur \n', '    function conditionalTransitions() public {\n', '        bool checkNextState; \n', '        do {\n', '            checkNextState = false;\n', '\n', '            bytes32 next = states[currentStateId].nextStateId;\n', "            // If one of the next state's conditions is met, go to this state and continue\n", '\n', '            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n', '                if (states[next].startConditions[i](next)) {\n', '                    goToNextState();\n', '                    checkNextState = true;\n', '                    break;\n', '                }\n', '            } \n', '        } while (checkNextState);\n', '    }\n', '\n', '    function getCurrentStateId() view public returns(bytes32) {\n', '        return currentStateId;\n', '    }\n', '\n', '    /// @dev Setup the state machine with the given states.\n', '    /// @param _stateIds Array of state ids.\n', '    function setStates(bytes32[] _stateIds) internal {\n', '        require(_stateIds.length > 0);\n', '        require(currentStateId == 0);\n', '\n', '        require(_stateIds[0] != 0);\n', '\n', '        currentStateId = _stateIds[0];\n', '\n', '        for (uint256 i = 1; i < _stateIds.length; i++) {\n', '            require(_stateIds[i] != 0);\n', '\n', '            states[_stateIds[i - 1]].nextStateId = _stateIds[i];\n', '\n', '            // Check that the state appears only once in the array\n', '            require(states[_stateIds[i]].nextStateId == 0);\n', '        }\n', '    }\n', '\n', '    /// @dev Allow a function in the given state.\n', '    /// @param _stateId The id of the state\n', '    /// @param _functionSelector A function selector (bytes4[keccak256(functionSignature)])\n', '    function allowFunction(bytes32 _stateId, bytes4 _functionSelector) \n', '        internal \n', '    {\n', '        states[_stateId].allowedFunctions[_functionSelector] = true;\n', '    }\n', '\n', '    /// @dev Goes to the next state if possible (if the next state is valid)\n', '    function goToNextState() internal {\n', '        bytes32 next = states[currentStateId].nextStateId;\n', '        require(next != 0);\n', '\n', '        currentStateId = next;\n', '        for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\n', '            states[next].transitionCallbacks[i]();\n', '        }\n', '\n', '        emit Transition(next, block.number);\n', '    }\n', '\n', '    ///@dev Add a function returning a boolean as a start condition for a state. \n', '    /// If any condition returns true, the StateMachine will transition to the next state.\n', '    /// If s.startConditions is empty, the StateMachine will need to enter state s through invoking\n', '    /// the goToNextState() function. \n', '    /// A start condition should never throw. (Otherwise, the StateMachine may fail to enter into the\n', '    /// correct state, and succeeding start conditions may return true.)\n', '    /// A start condition should be gas-inexpensive since every one of them is invoked in the same call to \n', '    /// transition the state. \n', '    ///@param _stateId The ID of the state to add the condition for\n', '    ///@param _condition Start condition function - returns true if a start condition (for a given state ID) is met\n', '    function addStartCondition(\n', '        bytes32 _stateId,\n', '        function(bytes32) internal returns(bool) _condition\n', '    ) \n', '        internal \n', '    {\n', '        states[_stateId].startConditions.push(_condition);\n', '    }\n', '\n', '    ///@dev Add a callback function for a state. All callbacks are invoked immediately after entering the state. \n', '    /// Callback functions should never throw. (Otherwise, the StateMachine may fail to enter a state.)\n', '    /// Callback functions should also be gas-inexpensive as all callbacks are invoked in the same call to enter the state.\n', '    ///@param _stateId The ID of the state to add a callback function for\n', '    ///@param _callback The callback function to add\n', '    function addCallback(bytes32 _stateId, function() internal _callback)\n', '        internal \n', '    {\n', '        states[_stateId].transitionCallbacks.push(_callback);\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/state-machine/contracts/TimedStateMachine.sol\n', '\n', '/// @title A contract that implements the state machine pattern and adds time dependant transitions.\n', 'contract TimedStateMachine is StateMachine {\n', '\n', '    event StateStartTimeSet(bytes32 indexed _stateId, uint256 _startTime);\n', '\n', "    // Stores the start timestamp for each state (the value is 0 if the state doesn't have a start timestamp).\n", '    mapping(bytes32 => uint256) private startTime;\n', '\n', '    /// @dev Returns the timestamp for the given state id.\n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\n', '        return startTime[_stateId];\n', '    }\n', '\n', '    /// @dev Sets the starting timestamp for a state as a startCondition. If other start conditions exist and are \n', '    /// met earlier, then the state may be entered into earlier than the specified start time. \n', '    /// @param _stateId The id of the state for which we want to set the start timestamp.\n', '    /// @param _timestamp The start timestamp for the given state. It should be bigger than the current one.\n', '    function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\n', '        require(block.timestamp < _timestamp);\n', '\n', '        if (startTime[_stateId] == 0) {\n', '            addStartCondition(_stateId, hasStartTimePassed);\n', '        }\n', '\n', '        startTime[_stateId] = _timestamp;\n', '\n', '        emit StateStartTimeSet(_stateId, _timestamp);\n', '    }\n', '\n', '    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n', '        return startTime[_stateId] <= block.timestamp;\n', '    }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/TokenControllerI.sol\n', '\n', '/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\n', 'contract TokenControllerI {\n', '\n', '    /// @dev Specifies whether a transfer is allowed or not.\n', '    /// @return True if the transfer is allowed\n', '    function transferAllowed(address _from, address _to)\n', '        external\n', '        view \n', '        returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(\n', '    address _owner,\n', '    address _spender\n', '   )\n', '    public\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(\n', '    address _spender,\n', '    uint _addedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    allowed[msg.sender][_spender] = (\n', '      allowed[msg.sender][_spender].add(_addedValue));\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(\n', '    address _spender,\n', '    uint _subtractedValue\n', '  )\n', '    public\n', '    returns (bool)\n', '  {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/ControllableToken.sol\n', '\n', '/**\n', ' * @title Controllable ERC20 token\n', ' *\n', ' * @dev Token that queries a token controller contract to check if a transfer is allowed.\n', ' * @dev controller state var is going to be set with the address of a TokenControllerI contract that has \n', ' * implemented transferAllowed() function.\n', ' */\n', 'contract ControllableToken is Ownable, StandardToken {\n', '    TokenControllerI public controller;\n', '\n', '    /// @dev Executes transferAllowed() function from the Controller. \n', '    modifier isAllowed(address _from, address _to) {\n', '        require(controller.transferAllowed(_from, _to), "Token Controller does not permit transfer.");\n', '        _;\n', '    }\n', '\n', '    /// @dev Sets the controller that is going to be used by isAllowed modifier\n', '    function setController(TokenControllerI _controller) onlyOwner public {\n', '        require(_controller != address(0), "Controller address should not be zero.");\n', '        controller = _controller;\n', '    }\n', '\n', '    /// @dev It calls parent BasicToken.transfer() function. It will transfer an amount of tokens to an specific address\n', '    /// @return True if the token is transfered with success\n', '    function transfer(address _to, uint256 _value) \n', '        isAllowed(msg.sender, _to)\n', '        public\n', '        returns (bool)\n', '    {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @dev It calls parent StandardToken.transferFrom() function. It will transfer from an address a certain amount of tokens to another address \n', '    /// @return True if the token is transfered with success \n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        isAllowed(_from, _to) \n', '        public \n', '        returns (bool)\n', '    {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\n', '\n', '/**\n', ' * @title DetailedERC20 token\n', ' * @dev The decimals are only for visualization purposes.\n', ' * All the operations are done using the smallest and indivisible token unit,\n', ' * just as on Ethereum all the operations are done in wei.\n', ' */\n', 'contract DetailedERC20 is ERC20 {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string _name, string _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: @tokenfoundry/token-contracts/contracts/Token.sol\n', '\n', '/**\n', ' * @title Token base contract - Defines basic structure for a token\n', ' *\n', ' * @dev ControllableToken is a StandardToken, an OpenZeppelin ERC20 implementation library. DetailedERC20 is also an OpenZeppelin contract.\n', ' * More info about them is available here: https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\n', ' */\n', 'contract Token is ControllableToken, DetailedERC20 {\n', '\n', '\t/**\n', '\t* @dev Transfer is an event inherited from ERC20Basic.sol interface (OpenZeppelin).\n', '\t* @param _supply Total supply of tokens.\n', '    * @param _name Is the long name by which the token contract should be known\n', '    * @param _symbol The set of capital letters used to represent the token e.g. DTH.\n', '    * @param _decimals The number of decimal places the tokens can be split up into. This should be between 0 and 18.\n', '\t*/\n', '    constructor(\n', '        uint256 _supply,\n', '        string _name,\n', '        string _symbol,\n', '        uint8 _decimals\n', '    ) DetailedERC20(_name, _symbol, _decimals) public {\n', '        require(_supply != 0, "Supply should be greater than 0.");\n', '        totalSupply_ = _supply;\n', '        balances[msg.sender] = _supply;\n', '        emit Transfer(address(0), msg.sender, _supply);  //event\n', '    }\n', '}\n', '\n', '// File: @tokenfoundry/sale-contracts/contracts/Sale.sol\n', '\n', '/// @title Sale base contract\n', 'contract Sale is SaleI, Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for Token;\n', '\n', '    // State machine states\n', '    bytes32 private constant SETUP = "setup";\n', '    bytes32 private constant FREEZE = "freeze";\n', '    bytes32 private constant SALE_IN_PROGRESS = "saleInProgress";\n', '    bytes32 private constant SALE_ENDED = "saleEnded";\n', '    // solium-disable-next-line arg-overflow\n', '    bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\n', '\n', '    // Stores the contribution for each user\n', '    mapping(address => uint256) public unitContributions;\n', '\n', '    // Records extra tokens were allocated\n', '    mapping(address => bool) public extraTokensAllocated;\n', '\n', '    DisbursementHandler public disbursementHandler;\n', '\n', '    uint256 public totalContributedUnits = 0; // Units\n', '    uint256 public totalSaleCapUnits; // Units\n', '    uint256 public minContributionUnits; // Units\n', '    uint256 public minThresholdUnits; // Units\n', '\n', '    // How many tokens a user will receive per each unit contributed\n', '    uint256 public saleTokensPerUnit;\n', '    // Rate that will be used to calculate extra tokens if Sale is not sold out\n', '    uint256 public extraTokensPerUnit;\n', '    // Total amount of tokens that the sale will distribute to contributors\n', '    uint256 public tokensForSale;\n', '\n', '    Token public trustedToken;\n', '    Vault public trustedVault;\n', '    EthPriceFeedI public ethPriceFeed; \n', '\n', '    event Contribution(\n', '        address indexed contributor,\n', '        address indexed sender,\n', '        uint256 valueUnit,\n', '        uint256 valueWei,\n', '        uint256 excessWei,\n', '        uint256 weiPerUnitRate\n', '    );\n', '\n', '    event EthPriceFeedChanged(address previousEthPriceFeed, address newEthPriceFeed);\n', '\n', '    event TokensAllocated(address indexed contributor, uint256 tokenAmount);\n', '\n', '    constructor (\n', '        uint256 _totalSaleCapUnits, // Units\n', '        uint256 _minContributionUnits, // Units\n', '        uint256 _minThresholdUnits, // Units\n', '        uint256 _maxTokens,\n', '        address _whitelistAdmin,\n', '        address _wallet,\n', '        uint256 _vaultInitialDisburseWei, // Wei\n', '        uint256 _vaultDisbursementWei, // Wei\n', '        uint256 _vaultDisbursementDuration,\n', '        uint256 _startTime,\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals, \n', '        EthPriceFeedI _ethPriceFeed\n', '    ) \n', '        Whitelistable(_whitelistAdmin)\n', '        public \n', '    {\n', '        require(_totalSaleCapUnits != 0, "Total sale cap units must be > 0");\n', '        require(_maxTokens != 0, "The maximum number of tokens must be > 0");\n', '        require(_wallet != 0, "The team\'s wallet address cannot be 0");\n', '        require(_minThresholdUnits <= _totalSaleCapUnits, "The minimum threshold (units) cannot be larger than the sale cap (units)");\n', '        require(_ethPriceFeed != address(0), "The ETH price feed cannot be the 0 address");\n', '        require(now < _startTime, "The start time must be in the future");\n', '\n', '        totalSaleCapUnits = _totalSaleCapUnits;\n', '        minContributionUnits = _minContributionUnits;\n', '        minThresholdUnits = _minThresholdUnits;\n', '\n', '        // Setup the necessary contracts\n', '        trustedToken = new Token(\n', '            _maxTokens,\n', '            _tokenName,\n', '            _tokenSymbol,\n', '            _tokenDecimals\n', '        );\n', '\n', '        disbursementHandler = new DisbursementHandler(trustedToken);\n', '\n', '        disbursementHandler.transferOwnership(owner);\n', '\n', '        ethPriceFeed = _ethPriceFeed; \n', '\n', '        // The token will query the isTransferAllowed function contained in this contract\n', '        trustedToken.setController(this);\n', '\n', '        trustedVault = new Vault(\n', '            _wallet,\n', '            _vaultInitialDisburseWei,\n', '            _vaultDisbursementWei, // disbursement amount\n', '            _vaultDisbursementDuration\n', '        );\n', '\n', '        // Set the states\n', '        setStates(states);\n', '\n', '        // Specify which functions are allowed in each state\n', '        allowFunction(SETUP, this.setup.selector);\n', '        allowFunction(FREEZE, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n', '        allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\n', '        allowFunction(SALE_ENDED, this.allocateExtraTokens.selector);\n', '\n', '        // End the sale when the cap is reached\n', '        addStartCondition(SALE_ENDED, wasCapReached);\n', '\n', '        // Set the start time for the sale\n', '        setStateStartTime(SALE_IN_PROGRESS, _startTime);\n', '\n', '        // Set the onSaleEnded callback (will be called when the sale ends)\n', '        addCallback(SALE_ENDED, onSaleEnded);\n', '\n', '    }\n', '\n', '    /// @dev Setup the disbursements and the number of tokens for sale.\n', '    /// @dev This needs to be outside the constructor because the token needs to query the sale for allowed transfers.\n', '    function setup() external onlyOwner checkAllowed {\n', '        require(disbursementHandler.closed(), "Disbursement handler not closed");\n', '        trustedToken.safeTransfer(disbursementHandler, disbursementHandler.totalAmount());\n', '\n', '        tokensForSale = trustedToken.balanceOf(this);     \n', '        require(tokensForSale >= totalSaleCapUnits, "Higher sale cap units than tokens for sale => tokens per unit would be 0");\n', '\n', '        // Set the worst rate of tokens per unit\n', "        // If sale doesn't sell out, extra tokens will be disbursed after the sale ends.\n", '        saleTokensPerUnit = tokensForSale.div(totalSaleCapUnits);\n', '\n', '        // Go to freeze state\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev To change the EthPriceFeed contract if needed \n', '    function changeEthPriceFeed(EthPriceFeedI _ethPriceFeed) external onlyOwner {\n', '        require(_ethPriceFeed != address(0), "ETH price feed address cannot be 0");\n', '        emit EthPriceFeedChanged(ethPriceFeed, _ethPriceFeed);\n', '        ethPriceFeed = _ethPriceFeed;\n', '    }\n', '\n', '    /// @dev Called by users to contribute ETH to the sale.\n', '    function contribute(\n', '        address _contributor,\n', '        uint256 _contributionLimitUnits, \n', '        uint256 _payloadExpiration,\n', '        bytes _sig\n', '    ) \n', '        external \n', '        payable\n', '        checkAllowed \n', '        isWhitelisted(keccak256(\n', '            abi.encodePacked(\n', '                _contributor,\n', '                _contributionLimitUnits, \n', '                _payloadExpiration\n', '            )\n', '        ), _sig)\n', '    {\n', '        require(msg.sender == _contributor, "Contributor address different from whitelisted address");\n', '        require(now < _payloadExpiration, "Payload has expired"); \n', '\n', '        uint256 weiPerUnitRate = ethPriceFeed.getRate(); \n', '        require(weiPerUnitRate != 0, "Wei per unit rate from feed is 0");\n', '\n', '        uint256 previouslyContributedUnits = unitContributions[_contributor];\n', '\n', "        // Check that the contribution amount doesn't go over the sale cap or personal contributionLimitUnits \n", '        uint256 currentContributionUnits = min256(\n', '            _contributionLimitUnits.sub(previouslyContributedUnits),\n', '            totalSaleCapUnits.sub(totalContributedUnits),\n', '            msg.value.div(weiPerUnitRate)\n', '        );\n', '\n', '        require(currentContributionUnits != 0, "No contribution permitted (contributor or sale has reached cap)");\n', '\n', '        // Check that it is higher than minContributionUnits\n', '        require(currentContributionUnits >= minContributionUnits || previouslyContributedUnits != 0, "Minimum contribution not reached");\n', '\n', '        // Update the state\n', '        unitContributions[_contributor] = previouslyContributedUnits.add(currentContributionUnits);\n', '        totalContributedUnits = totalContributedUnits.add(currentContributionUnits);\n', '\n', '        uint256 currentContributionWei = currentContributionUnits.mul(weiPerUnitRate);\n', '        trustedVault.deposit.value(currentContributionWei)(msg.sender);\n', '\n', '        // If the minThresholdUnits is reached for the first time, notify the vault\n', '        if (totalContributedUnits >= minThresholdUnits &&\n', '            trustedVault.state() != Vault.State.Success) {\n', '            trustedVault.saleSuccessful();\n', '        }\n', '\n', '        // If there is an excess, return it to the sender\n', '        uint256 excessWei = msg.value.sub(currentContributionWei);\n', '        if (excessWei > 0) {\n', '            msg.sender.transfer(excessWei);\n', '        }\n', '\n', '        emit Contribution(\n', '            _contributor, \n', '            msg.sender,\n', '            currentContributionUnits, \n', '            currentContributionWei, \n', '            excessWei,\n', '            weiPerUnitRate\n', '        );\n', '\n', '        // Allocate tokens     \n', '        uint256 tokenAmount = currentContributionUnits.mul(saleTokensPerUnit);\n', '        trustedToken.safeTransfer(_contributor, tokenAmount);\n', '        emit TokensAllocated(_contributor, tokenAmount);\n', '    }\n', '\n', '    /// @dev Called to allocate the tokens depending on amount contributed by the end of the sale.\n', '    /// @param _contributor The address of the contributor.\n', '    function allocateExtraTokens(address _contributor)\n', '        external \n', '        checkAllowed\n', '    {    \n', '        require(!extraTokensAllocated[_contributor], "Extra tokens already allocated to contributor");\n', '        require(unitContributions[_contributor] != 0, "Address didn\'t contribute to sale");\n', '        // Allocate extra tokens only if total sale cap is not reached\n', '        require(totalContributedUnits < totalSaleCapUnits, "The sale cap was reached, no extra tokens to allocate");\n', '\n', '        // Transfer the respective tokens to the contributor\n', '        extraTokensAllocated[_contributor] = true;\n', '        uint256 tokenAmount = unitContributions[_contributor].mul(extraTokensPerUnit);\n', '        trustedToken.safeTransfer(_contributor, tokenAmount);\n', '\n', '        emit TokensAllocated(_contributor, tokenAmount);\n', '    }\n', '\n', '    /// @dev Sets the end time for the sale\n', '    /// @param _endTime The timestamp at which the sale will end.\n', '    function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\n', '        require(now < _endTime, "Cannot set end time in the past");\n', '        require(getStateStartTime(SALE_ENDED) == 0, "End time already set");\n', '        setStateStartTime(SALE_ENDED, _endTime);\n', '    }\n', '\n', '    /// @dev Called to enable refunds by the owner. Can only be called in any state (without triggering conditional transitions)\n', "    /// @dev This is only meant to be used if there is an emergency and the endSale() function can't be called\n", '    function enableRefunds() external onlyOwner {\n', '        trustedVault.enableRefunds();\n', '    }\n', '\n', '    /// @dev Called to end the sale by the owner. Can only be called in SALE_IN_PROGRESS state\n', '    function endSale() external onlyOwner checkAllowed {\n', '        goToNextState();\n', '    }\n', '\n', '    /// @dev Since Sale is TokenControllerI, it has to implement transferAllowed() function\n', '    /// @notice only the Sale and DisbursementHandler can disburse the initial tokens to their future owners\n', '    function transferAllowed(address _from, address)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        return _from == address(this) || _from == address(disbursementHandler);\n', '    }\n', '   \n', '    /// @dev Returns true if the cap was reached.\n', '    function wasCapReached(bytes32) internal returns (bool) {\n', '        return totalSaleCapUnits <= totalContributedUnits;\n', '    }\n', '\n', '    /// @dev Callback that gets called when entering the SALE_ENDED state.\n', '    function onSaleEnded() internal {\n', '\n', '        trustedToken.transferOwnership(owner); \n', '\n', '        if (totalContributedUnits == 0) {\n', '\n', '            // If no tokens were sold, transfer them back to the project team\n', '            trustedToken.safeTransfer(trustedVault.trustedWallet(), tokensForSale);\n', '\n', '        } else if (totalContributedUnits < minThresholdUnits) {\n', '\n', "            // If the minimum threshold wasn't reached, enable refunds\n", '            trustedVault.enableRefunds();\n', '\n', '        } else {\n', '\n', '            // Calculate the rate for the extra tokens (if the sale was sold out, it will be 0)\n', '            extraTokensPerUnit = tokensForSale.div(totalContributedUnits).sub(saleTokensPerUnit);\n', '\n', '            // Close the vault and transfer ownership to the owner of the sale\n', '            trustedVault.close();\n', '            trustedVault.transferOwnership(owner);\n', '\n', '        }\n', '    }\n', '\n', '    /// @dev a function to return the minimum of 3 values\n', '    function min256(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n', '        return Math.min256(x, Math.min256(y, z));\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/GamerTokenSale.sol\n', '\n', 'contract GamerTokenSale is Sale {\n', '\n', '    constructor() \n', '        Sale(\n', '            18000000, // Total sale cap (usd)\n', '            5, // Min contribution (usd)\n', '            2000000, // Min threshold (usd)\n', '            1000000000 * (10 ** 18), // Max tokens\n', '            0x38a61BDEbAa1f312d6a7765165EF2c05d4957152, // Whitelist Admin\n', '            0xEE8A84b3B964AfB5433ecd55F517c4D3F43049B5, // Wallet\n', '            10000 ether, // Vault initial Wei\n', '            90000 ether, // Vault disbursement Wei\n', '            0, // Vault disbursement duration (0 means transfer everything right away)\n', '            now + 10 minutes, // Start time\n', '            "GamerToken", // Token name\n', '            "GTX", // Token symbol\n', '            18, // Token decimals\n', '            EthPriceFeedI(0x54bF24e1070784D7F0760095932b47CE55eb3A91) // Eth price feed\n', '        )\n', '        public \n', '    {\n', '    }\n', '}']