['pragma solidity ^0.4.23;\n', '\n', 'library SafeMathLib {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract DateTimeLib {\n', '\n', '    struct _DateTime {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 minute;\n', '        uint8 second;\n', '        uint8 weekday;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint constant HOUR_IN_SECONDS = 3600;\n', '    uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) internal pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '            return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '            return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) internal pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '            return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '            return 29;\n', '        }\n', '        else {\n', '            return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '        dt.hour = getHour(timestamp);\n', '        dt.minute = getMinute(timestamp);\n', '        dt.second = getSecond(timestamp);\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '\n', '    function getYear(uint timestamp) internal pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '            if (isLeapYear(uint16(year - 1))) {\n', '                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            }\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) internal pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) internal pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function getHour(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / 60 / 60) % 24);\n', '    }\n', '\n', '    function getMinute(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / 60) % 60);\n', '    }\n', '\n', '    function getSecond(uint timestamp) internal pure returns (uint8) {\n', '        return uint8(timestamp % 60);\n', '    }\n', '\n', '    function getWeekday(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\n', '        uint16 i;\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '            if (isLeapYear(i)) {\n', '                timestamp += LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                timestamp += YEAR_IN_SECONDS;\n', '            }\n', '        }\n', '\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '            monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '            monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '        timestamp += HOUR_IN_SECONDS * (hour);\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '        timestamp += second;\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    \n', '    function totalSupply() external constant returns (uint256);\n', '    function balanceOf(address _owner) external constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is IERC20,DateTimeLib {\n', '\n', '    using SafeMathLib for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    \n', '    string public constant symbol = "APB";\n', '    \n', '    string public constant name = "AmpereX Bank";\n', '    \n', '    uint _totalSupply = 10000000000 * 10 ** 6;\n', '    \n', '    uint8 public constant decimals = 6;\n', '    \n', '    function totalSupply() external constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return transferInternal(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        require(_value > 0 && balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value > 0 && allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract LockableToken is StandardToken {\n', '    \n', '    address internal developerReservedAddress = 0x80a1B223b944A86e517349CBB414965bC501d104;\n', '    \n', '    uint[8] internal developerReservedUnlockTimes;\n', '    \n', '    uint256[8] internal developerReservedBalanceLimits;\n', '    \n', '    function getDeveloperReservedBalanceLimit() internal returns (uint256 balanceLimit) {\n', '        uint time = now;\n', '        for (uint index = 0; index < developerReservedUnlockTimes.length; index++) {\n', '            if (developerReservedUnlockTimes[index] == 0x0) {\n', '                continue;\n', '            }\n', '            if (time > developerReservedUnlockTimes[index]) {\n', '                developerReservedUnlockTimes[index] = 0x0;\n', '            } else {\n', '                return developerReservedBalanceLimits[index];\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return transferInternal(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        require(_from != 0x0 && _to != 0x0 && _value > 0x0);\n', '        if (_from == developerReservedAddress) {\n', '            uint256 balanceLimit = getDeveloperReservedBalanceLimit();\n', '            require(balances[_from].sub(balanceLimit) >= _value);\n', '        }\n', '        return super.transferInternal(_from, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0 && _to != 0x0 && _value > 0x0);\n', '        if (_from == developerReservedAddress) {\n', '            uint256 balanceLimit = getDeveloperReservedBalanceLimit();\n', '            require(balances[_from].sub(balanceLimit) >= _value);\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    event UnlockTimeChanged(uint index, uint unlockTime, uint newUnlockTime);\n', '    event LockInfo(address indexed publicOfferingAddress, uint index, uint unlockTime, uint256 balanceLimit);\n', '}\n', '\n', 'contract TradeableToken is LockableToken {\n', '\n', '    address internal publicOfferingAddress = 0xdC23333Acb4dAAd88fcF66D2807DB7c8eCDFa6dc;\n', '\n', '    uint256 public exchangeRate = 100000;\n', '\n', '    function buy(address _beneficiary, uint256 _weiAmount) internal {\n', '        require(_beneficiary != 0x0);\n', '        require(publicOfferingAddress != 0x0);\n', '        require(exchangeRate > 0x0);\n', '        require(_weiAmount > 0x0);\n', '\n', '        uint256 exchangeToken = _weiAmount.mul(exchangeRate);\n', '        exchangeToken = exchangeToken.div(1 * 10 ** 12);\n', '\n', '        publicOfferingAddress.transfer(_weiAmount);\n', '        super.transferInternal(publicOfferingAddress, _beneficiary, exchangeToken);\n', '    }\n', '    \n', '    event ExchangeRateChanged(uint256 oldExchangeRate,uint256 newExchangeRate);\n', '}\n', '\n', 'contract OwnableToken is TradeableToken {\n', '    \n', '    address internal owner = 0x59923219FEC7dd1Bfc4C14076F4a216b90f3AEdC;\n', '    \n', '    mapping(address => uint) administrators;\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyAdministrator() {\n', '        require(msg.sender == owner || administrators[msg.sender] > 0x0);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        owner = _newOwner;\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '    }\n', '    \n', '    function addAdministrator(address _adminAddress) onlyOwner public {\n', '        require(_adminAddress != address(0));\n', '        require(administrators[_adminAddress] <= 0x0);\n', '        administrators[_adminAddress] = 0x1;\n', '        emit AddAdministrator(_adminAddress);\n', '    }\n', '    \n', '    function removeAdministrator(address _adminAddress) onlyOwner public {\n', '        require(_adminAddress != address(0));\n', '        require(administrators[_adminAddress] > 0x0);\n', '        administrators[_adminAddress] = 0x0;\n', '        emit RemoveAdministrator(_adminAddress);\n', '    }\n', '    \n', '    function setExchangeRate(uint256 _exchangeRate) public onlyAdministrator returns (bool success) {\n', '        require(_exchangeRate > 0x0);\n', '        uint256 oldExchangeRate = exchangeRate;\n', '        exchangeRate = _exchangeRate;\n', '        emit ExchangeRateChanged(oldExchangeRate, exchangeRate);\n', '        return true;\n', '    }\n', '    \n', '    function changeUnlockTime(uint _index, uint _unlockTime) public onlyAdministrator returns (bool success) {\n', '        require(_index >= 0x0 && _index < developerReservedUnlockTimes.length && _unlockTime > 0x0);\n', '        if(_index > 0x0) {\n', '            uint beforeUnlockTime = developerReservedUnlockTimes[_index - 1];\n', '            require(beforeUnlockTime == 0x0 || beforeUnlockTime < _unlockTime);\n', '        }\n', '        if(_index < developerReservedUnlockTimes.length - 1) {\n', '            uint afterUnlockTime = developerReservedUnlockTimes[_index + 1];\n', '            require(afterUnlockTime == 0x0 || _unlockTime < afterUnlockTime);\n', '        }\n', '        uint oldUnlockTime = developerReservedUnlockTimes[_index];\n', '        developerReservedUnlockTimes[_index] = _unlockTime;\n', '        emit UnlockTimeChanged(_index,oldUnlockTime,_unlockTime);\n', '        return true;\n', '    }\n', '    \n', '    function getDeveloperReservedLockInfo(uint _index) public onlyAdministrator returns (uint, uint256) {\n', '        require(_index >= 0x0 && _index < developerReservedUnlockTimes.length && _index < developerReservedBalanceLimits.length);\n', '        emit LockInfo(developerReservedAddress,_index,developerReservedUnlockTimes[_index],developerReservedBalanceLimits[_index]);\n', '        return (developerReservedUnlockTimes[_index], developerReservedBalanceLimits[_index]);\n', '    }\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AddAdministrator(address indexed adminAddress);\n', '    event RemoveAdministrator(address indexed adminAddress);\n', '}\n', '\n', 'contract APB is OwnableToken {\n', '    \n', '    function APB() public {\n', '        balances[owner] = 5000000000 * 10 ** 6;\n', '        balances[publicOfferingAddress] = 3000000000 * 10 ** 6;\n', '\n', '        uint256 developerReservedBalance = 2000000000 * 10 ** 6;\n', '        balances[developerReservedAddress] = developerReservedBalance;\n', '        developerReservedUnlockTimes =\n', '        [\n', '        DateTimeLib.toTimestamp(2018, 6, 1),\n', '        DateTimeLib.toTimestamp(2018, 9, 1),\n', '        DateTimeLib.toTimestamp(2018, 12, 1),\n', '        DateTimeLib.toTimestamp(2019, 3, 1),\n', '        DateTimeLib.toTimestamp(2019, 6, 1),\n', '        DateTimeLib.toTimestamp(2019, 9, 1),\n', '        DateTimeLib.toTimestamp(2019, 12, 1),\n', '        DateTimeLib.toTimestamp(2020, 3, 1)\n', '        ];\n', '        developerReservedBalanceLimits = \n', '        [\n', '            developerReservedBalance,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 1,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 2,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 3,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 4,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 5,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 6,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 7\n', '        ];\n', '    }\n', '    \n', '    function() public payable {\n', '        buy(msg.sender, msg.value);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'library SafeMathLib {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract DateTimeLib {\n', '\n', '    struct _DateTime {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '        uint8 hour;\n', '        uint8 minute;\n', '        uint8 second;\n', '        uint8 weekday;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint constant HOUR_IN_SECONDS = 3600;\n', '    uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) internal pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '            return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '            return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) internal pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '            return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '            return 29;\n', '        }\n', '        else {\n', '            return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '        dt.hour = getHour(timestamp);\n', '        dt.minute = getMinute(timestamp);\n', '        dt.second = getSecond(timestamp);\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '\n', '    function getYear(uint timestamp) internal pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '            if (isLeapYear(uint16(year - 1))) {\n', '                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            }\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) internal pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) internal pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function getHour(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / 60 / 60) % 24);\n', '    }\n', '\n', '    function getMinute(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / 60) % 60);\n', '    }\n', '\n', '    function getSecond(uint timestamp) internal pure returns (uint8) {\n', '        return uint8(timestamp % 60);\n', '    }\n', '\n', '    function getWeekday(uint timestamp) internal pure returns (uint8) {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal pure returns (uint timestamp) {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\n', '        uint16 i;\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '            if (isLeapYear(i)) {\n', '                timestamp += LEAP_YEAR_IN_SECONDS;\n', '            }\n', '            else {\n', '                timestamp += YEAR_IN_SECONDS;\n', '            }\n', '        }\n', '\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '            monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '            monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '        timestamp += HOUR_IN_SECONDS * (hour);\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '        timestamp += second;\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    \n', '    function totalSupply() external constant returns (uint256);\n', '    function balanceOf(address _owner) external constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is IERC20,DateTimeLib {\n', '\n', '    using SafeMathLib for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    \n', '    string public constant symbol = "APB";\n', '    \n', '    string public constant name = "AmpereX Bank";\n', '    \n', '    uint _totalSupply = 10000000000 * 10 ** 6;\n', '    \n', '    uint8 public constant decimals = 6;\n', '    \n', '    function totalSupply() external constant returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return transferInternal(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        require(_value > 0 && balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value > 0 && allowed[_from][msg.sender] >= _value && balances[_from] >= _value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract LockableToken is StandardToken {\n', '    \n', '    address internal developerReservedAddress = 0x80a1B223b944A86e517349CBB414965bC501d104;\n', '    \n', '    uint[8] internal developerReservedUnlockTimes;\n', '    \n', '    uint256[8] internal developerReservedBalanceLimits;\n', '    \n', '    function getDeveloperReservedBalanceLimit() internal returns (uint256 balanceLimit) {\n', '        uint time = now;\n', '        for (uint index = 0; index < developerReservedUnlockTimes.length; index++) {\n', '            if (developerReservedUnlockTimes[index] == 0x0) {\n', '                continue;\n', '            }\n', '            if (time > developerReservedUnlockTimes[index]) {\n', '                developerReservedUnlockTimes[index] = 0x0;\n', '            } else {\n', '                return developerReservedBalanceLimits[index];\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        return transferInternal(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\n', '        require(_from != 0x0 && _to != 0x0 && _value > 0x0);\n', '        if (_from == developerReservedAddress) {\n', '            uint256 balanceLimit = getDeveloperReservedBalanceLimit();\n', '            require(balances[_from].sub(balanceLimit) >= _value);\n', '        }\n', '        return super.transferInternal(_from, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_from != 0x0 && _to != 0x0 && _value > 0x0);\n', '        if (_from == developerReservedAddress) {\n', '            uint256 balanceLimit = getDeveloperReservedBalanceLimit();\n', '            require(balances[_from].sub(balanceLimit) >= _value);\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    event UnlockTimeChanged(uint index, uint unlockTime, uint newUnlockTime);\n', '    event LockInfo(address indexed publicOfferingAddress, uint index, uint unlockTime, uint256 balanceLimit);\n', '}\n', '\n', 'contract TradeableToken is LockableToken {\n', '\n', '    address internal publicOfferingAddress = 0xdC23333Acb4dAAd88fcF66D2807DB7c8eCDFa6dc;\n', '\n', '    uint256 public exchangeRate = 100000;\n', '\n', '    function buy(address _beneficiary, uint256 _weiAmount) internal {\n', '        require(_beneficiary != 0x0);\n', '        require(publicOfferingAddress != 0x0);\n', '        require(exchangeRate > 0x0);\n', '        require(_weiAmount > 0x0);\n', '\n', '        uint256 exchangeToken = _weiAmount.mul(exchangeRate);\n', '        exchangeToken = exchangeToken.div(1 * 10 ** 12);\n', '\n', '        publicOfferingAddress.transfer(_weiAmount);\n', '        super.transferInternal(publicOfferingAddress, _beneficiary, exchangeToken);\n', '    }\n', '    \n', '    event ExchangeRateChanged(uint256 oldExchangeRate,uint256 newExchangeRate);\n', '}\n', '\n', 'contract OwnableToken is TradeableToken {\n', '    \n', '    address internal owner = 0x59923219FEC7dd1Bfc4C14076F4a216b90f3AEdC;\n', '    \n', '    mapping(address => uint) administrators;\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyAdministrator() {\n', '        require(msg.sender == owner || administrators[msg.sender] > 0x0);\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address _newOwner) onlyOwner public {\n', '        require(_newOwner != address(0));\n', '        owner = _newOwner;\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '    }\n', '    \n', '    function addAdministrator(address _adminAddress) onlyOwner public {\n', '        require(_adminAddress != address(0));\n', '        require(administrators[_adminAddress] <= 0x0);\n', '        administrators[_adminAddress] = 0x1;\n', '        emit AddAdministrator(_adminAddress);\n', '    }\n', '    \n', '    function removeAdministrator(address _adminAddress) onlyOwner public {\n', '        require(_adminAddress != address(0));\n', '        require(administrators[_adminAddress] > 0x0);\n', '        administrators[_adminAddress] = 0x0;\n', '        emit RemoveAdministrator(_adminAddress);\n', '    }\n', '    \n', '    function setExchangeRate(uint256 _exchangeRate) public onlyAdministrator returns (bool success) {\n', '        require(_exchangeRate > 0x0);\n', '        uint256 oldExchangeRate = exchangeRate;\n', '        exchangeRate = _exchangeRate;\n', '        emit ExchangeRateChanged(oldExchangeRate, exchangeRate);\n', '        return true;\n', '    }\n', '    \n', '    function changeUnlockTime(uint _index, uint _unlockTime) public onlyAdministrator returns (bool success) {\n', '        require(_index >= 0x0 && _index < developerReservedUnlockTimes.length && _unlockTime > 0x0);\n', '        if(_index > 0x0) {\n', '            uint beforeUnlockTime = developerReservedUnlockTimes[_index - 1];\n', '            require(beforeUnlockTime == 0x0 || beforeUnlockTime < _unlockTime);\n', '        }\n', '        if(_index < developerReservedUnlockTimes.length - 1) {\n', '            uint afterUnlockTime = developerReservedUnlockTimes[_index + 1];\n', '            require(afterUnlockTime == 0x0 || _unlockTime < afterUnlockTime);\n', '        }\n', '        uint oldUnlockTime = developerReservedUnlockTimes[_index];\n', '        developerReservedUnlockTimes[_index] = _unlockTime;\n', '        emit UnlockTimeChanged(_index,oldUnlockTime,_unlockTime);\n', '        return true;\n', '    }\n', '    \n', '    function getDeveloperReservedLockInfo(uint _index) public onlyAdministrator returns (uint, uint256) {\n', '        require(_index >= 0x0 && _index < developerReservedUnlockTimes.length && _index < developerReservedBalanceLimits.length);\n', '        emit LockInfo(developerReservedAddress,_index,developerReservedUnlockTimes[_index],developerReservedBalanceLimits[_index]);\n', '        return (developerReservedUnlockTimes[_index], developerReservedBalanceLimits[_index]);\n', '    }\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AddAdministrator(address indexed adminAddress);\n', '    event RemoveAdministrator(address indexed adminAddress);\n', '}\n', '\n', 'contract APB is OwnableToken {\n', '    \n', '    function APB() public {\n', '        balances[owner] = 5000000000 * 10 ** 6;\n', '        balances[publicOfferingAddress] = 3000000000 * 10 ** 6;\n', '\n', '        uint256 developerReservedBalance = 2000000000 * 10 ** 6;\n', '        balances[developerReservedAddress] = developerReservedBalance;\n', '        developerReservedUnlockTimes =\n', '        [\n', '        DateTimeLib.toTimestamp(2018, 6, 1),\n', '        DateTimeLib.toTimestamp(2018, 9, 1),\n', '        DateTimeLib.toTimestamp(2018, 12, 1),\n', '        DateTimeLib.toTimestamp(2019, 3, 1),\n', '        DateTimeLib.toTimestamp(2019, 6, 1),\n', '        DateTimeLib.toTimestamp(2019, 9, 1),\n', '        DateTimeLib.toTimestamp(2019, 12, 1),\n', '        DateTimeLib.toTimestamp(2020, 3, 1)\n', '        ];\n', '        developerReservedBalanceLimits = \n', '        [\n', '            developerReservedBalance,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 1,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 2,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 3,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 4,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 5,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 6,\n', '            developerReservedBalance - (developerReservedBalance / 8) * 7\n', '        ];\n', '    }\n', '    \n', '    function() public payable {\n', '        buy(msg.sender, msg.value);\n', '    }\n', '}']
