['pragma solidity ^ 0.4 .18;\n', '\n', 'contract Etherumble {\n', '\n', '    struct PlayerBets {\n', '        address addPlayer;\n', '        uint amount;\n', '    }\n', '\n', '    PlayerBets[] users;\n', '    \n', '    address[] players = new address[](20);\n', '    uint[] bets = new uint[](20);\n', '\n', '    uint nbUsers = 0;\n', '    uint totalBets = 0;\n', '    uint fees = 0;\n', '    uint endBlock = 0;\n', '\n', '    address owner;\n', '    \n', '    address lastWinner;\n', '    uint lastWinnerTicket=0;\n', '    uint totalGames = 0;\n', '    \n', '    modifier isOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier hasValue() {\n', '        require(msg.value >= 10000000000000000 && nbUsers < 19); //0.01 ether min\n', '        _;\n', '    }\n', '\n', '    modifier onlyIf(bool _condition) {\n', '        require(_condition);\n', '        _;\n', '    }\n', '\n', '    function Etherumble() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function getActivePlayers() public constant returns(uint) {\n', '        return nbUsers;\n', '    }\n', '    \n', '    function getPlayerAddress(uint index) public constant returns(address) {\n', '        return players[index];\n', '    }\n', '    \n', '    function getPlayerBet(uint index) public constant returns(uint) {\n', '        return bets[index];\n', '    }\n', '    function getEndBlock() public constant returns(uint) {\n', '        return endBlock;\n', '    }\n', '    function getLastWinner() public constant returns(address) {\n', '        return lastWinner;\n', '    }\n', '    function getLastWinnerTicket() public constant returns(uint) {\n', '        return lastWinnerTicket;\n', '    }\n', '    function getTotalGames() public constant returns(uint) {\n', '        return totalGames;\n', '    }\n', '    \n', '\n', '    function() public payable hasValue {\n', '        checkinter();//first check if it&#39;s a good block for ending a game. this way there is no new user after the winner block hash is calculated\n', '        players[nbUsers] = msg.sender;\n', '        bets[nbUsers] = msg.value;\n', '        \n', '        users.push(PlayerBets(msg.sender, msg.value));\n', '        nbUsers++;\n', '        totalBets += msg.value;\n', '        if (nbUsers == 2) { //at the 2nd player it start counting blocks...\n', '            endBlock = block.number + 15;\n', '        }\n', '    }\n', '\n', '    function endLottery() internal {\n', '        uint sum = 0;\n', '        uint winningNumber = uint(block.blockhash(block.number - 1)) % totalBets;\n', '\n', '        for (uint i = 0; i < nbUsers; i++) {\n', '            sum += users[i].amount;\n', '\n', '            if (sum >= winningNumber) {\n', '                // destroy this contract and send the balance to users[i]\n', '                withrawWin(users[i].addPlayer,winningNumber);\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    function withrawWin(address winner,uint winticket) internal {\n', '        uint tempTot = totalBets;\n', '        lastWinnerTicket = winticket;\n', '        totalGames++;\n', '        \n', '        //reset all values\n', '        nbUsers = 0;\n', '        totalBets = 0;\n', '        endBlock = 0;\n', '        delete users;\n', '        \n', '        fees += tempTot * 5 / 100;\n', '        winner.transfer(tempTot * 95 / 100);\n', '        lastWinner = winner;\n', '    }\n', '    \n', '    function withrawFee() public isOwner {\n', '        owner.transfer(fees);\n', '        fees = 0;\n', '    }\n', '    function destroykill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function checkinter() internal{ //this can be called by anyone if the timmer freez\n', '        //check block time\n', '        if (endBlock <= block.number && endBlock != 0) {\n', '            endLottery();\n', '        }\n', '    }\n', '    \n', '    function callback() public isOwner{ //this can be called by anyone if the timmer freez\n', '        //check block time\n', '        if (endBlock <= block.number && endBlock != 0) {\n', '            endLottery();\n', '        }\n', '    }\n', '}']
['pragma solidity ^ 0.4 .18;\n', '\n', 'contract Etherumble {\n', '\n', '    struct PlayerBets {\n', '        address addPlayer;\n', '        uint amount;\n', '    }\n', '\n', '    PlayerBets[] users;\n', '    \n', '    address[] players = new address[](20);\n', '    uint[] bets = new uint[](20);\n', '\n', '    uint nbUsers = 0;\n', '    uint totalBets = 0;\n', '    uint fees = 0;\n', '    uint endBlock = 0;\n', '\n', '    address owner;\n', '    \n', '    address lastWinner;\n', '    uint lastWinnerTicket=0;\n', '    uint totalGames = 0;\n', '    \n', '    modifier isOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier hasValue() {\n', '        require(msg.value >= 10000000000000000 && nbUsers < 19); //0.01 ether min\n', '        _;\n', '    }\n', '\n', '    modifier onlyIf(bool _condition) {\n', '        require(_condition);\n', '        _;\n', '    }\n', '\n', '    function Etherumble() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function getActivePlayers() public constant returns(uint) {\n', '        return nbUsers;\n', '    }\n', '    \n', '    function getPlayerAddress(uint index) public constant returns(address) {\n', '        return players[index];\n', '    }\n', '    \n', '    function getPlayerBet(uint index) public constant returns(uint) {\n', '        return bets[index];\n', '    }\n', '    function getEndBlock() public constant returns(uint) {\n', '        return endBlock;\n', '    }\n', '    function getLastWinner() public constant returns(address) {\n', '        return lastWinner;\n', '    }\n', '    function getLastWinnerTicket() public constant returns(uint) {\n', '        return lastWinnerTicket;\n', '    }\n', '    function getTotalGames() public constant returns(uint) {\n', '        return totalGames;\n', '    }\n', '    \n', '\n', '    function() public payable hasValue {\n', "        checkinter();//first check if it's a good block for ending a game. this way there is no new user after the winner block hash is calculated\n", '        players[nbUsers] = msg.sender;\n', '        bets[nbUsers] = msg.value;\n', '        \n', '        users.push(PlayerBets(msg.sender, msg.value));\n', '        nbUsers++;\n', '        totalBets += msg.value;\n', '        if (nbUsers == 2) { //at the 2nd player it start counting blocks...\n', '            endBlock = block.number + 15;\n', '        }\n', '    }\n', '\n', '    function endLottery() internal {\n', '        uint sum = 0;\n', '        uint winningNumber = uint(block.blockhash(block.number - 1)) % totalBets;\n', '\n', '        for (uint i = 0; i < nbUsers; i++) {\n', '            sum += users[i].amount;\n', '\n', '            if (sum >= winningNumber) {\n', '                // destroy this contract and send the balance to users[i]\n', '                withrawWin(users[i].addPlayer,winningNumber);\n', '                return;\n', '            }\n', '        }\n', '    }\n', '\n', '    function withrawWin(address winner,uint winticket) internal {\n', '        uint tempTot = totalBets;\n', '        lastWinnerTicket = winticket;\n', '        totalGames++;\n', '        \n', '        //reset all values\n', '        nbUsers = 0;\n', '        totalBets = 0;\n', '        endBlock = 0;\n', '        delete users;\n', '        \n', '        fees += tempTot * 5 / 100;\n', '        winner.transfer(tempTot * 95 / 100);\n', '        lastWinner = winner;\n', '    }\n', '    \n', '    function withrawFee() public isOwner {\n', '        owner.transfer(fees);\n', '        fees = 0;\n', '    }\n', '    function destroykill() public isOwner {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    function checkinter() internal{ //this can be called by anyone if the timmer freez\n', '        //check block time\n', '        if (endBlock <= block.number && endBlock != 0) {\n', '            endLottery();\n', '        }\n', '    }\n', '    \n', '    function callback() public isOwner{ //this can be called by anyone if the timmer freez\n', '        //check block time\n', '        if (endBlock <= block.number && endBlock != 0) {\n', '            endLottery();\n', '        }\n', '    }\n', '}']
