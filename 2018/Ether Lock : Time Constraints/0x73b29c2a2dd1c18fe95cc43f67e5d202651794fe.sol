['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/erc20/Token.sol\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/vesting/VestingWallet.sol\n', '\n', 'contract VestingWallet is Ownable, SafeMath {\n', '\n', '    mapping(address => VestingSchedule) public schedules;        // vesting schedules for given addresses\n', '    mapping(address => address) public addressChangeRequests;    // requested address changes\n', '\n', '    Token public vestingToken;\n', '\n', '    address public approvedWallet;\n', '\n', '    event VestingScheduleRegistered(\n', '        address indexed registeredAddress,\n', '        address depositor,\n', '        uint startTimeInSec,\n', '        uint cliffTimeInSec,\n', '        uint endTimeInSec,\n', '        uint totalAmount\n', '    );\n', '\n', '\n', '    event Withdrawal(address indexed registeredAddress, uint amountWithdrawn);\n', '\n', '    event VestingEndedByOwner(address indexed registeredAddress, uint amountWithdrawn, uint amountRefunded);\n', '\n', '    event AddressChangeRequested(address indexed oldRegisteredAddress, address indexed newRegisteredAddress);\n', '\n', '    event AddressChangeConfirmed(address indexed oldRegisteredAddress, address indexed newRegisteredAddress);\n', '\n', '    struct VestingSchedule {\n', '        uint startTimeInSec;\n', '        uint cliffTimeInSec;\n', '        uint endTimeInSec;\n', '        uint totalAmount;\n', '        uint totalAmountWithdrawn;\n', '        address depositor;\n', '    }\n', '\n', '    modifier addressRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier addressNotRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier pendingAddressChangeRequest(address target) {\n', '        require(addressChangeRequests[target] != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier pastCliffTime(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(getTime() > vestingSchedule.cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier validVestingScheduleTimes(uint startTimeInSec, uint cliffTimeInSec, uint endTimeInSec) {\n', '        require(cliffTimeInSec >= startTimeInSec);\n', '        require(endTimeInSec >= cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier addressNotNull(address target) {\n', '        require(target != address(0));\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a vesting token to the wallet.\n', '    /// @param _vestingToken Token that will be vested.\n', '    function VestingWallet(address _vestingToken) {\n', '        vestingToken = Token(_vestingToken);\n', '        approvedWallet = msg.sender;\n', '    }\n', '\n', '    function registerVestingScheduleWithPercentage(\n', '        address _addressToRegister,\n', '        address _depositor,\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount,\n', '        uint _percentage\n', '    )\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_depositor)\n', '    validVestingScheduleTimes(_startTimeInSec, _cliffTimeInSec, _endTimeInSec)\n', '    {\n', '        require(_percentage <= 100);\n', '        uint vestedAmount = safeDiv(safeMul(\n', '                _totalAmount, _percentage\n', '            ), 100);\n', '        registerVestingSchedule(_addressToRegister, _depositor, _startTimeInSec, _cliffTimeInSec, _endTimeInSec, vestedAmount);\n', '    }\n', '\n', '    /// @dev Registers a vesting schedule to an address.\n', '    /// @param _addressToRegister The address that is allowed to withdraw vested tokens for this schedule.\n', '    /// @param _depositor Address that will be depositing vesting token.\n', '    /// @param _startTimeInSec The time in seconds that vesting began.\n', '    /// @param _cliffTimeInSec The time in seconds that tokens become withdrawable.\n', '    /// @param _endTimeInSec The time in seconds that vesting ends.\n', '    /// @param _totalAmount The total amount of tokens that the registered address can withdraw by the end of the vesting period.\n', '    function registerVestingSchedule(\n', '        address _addressToRegister,\n', '        address _depositor,\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount\n', '    )\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_depositor)\n', '    validVestingScheduleTimes(_startTimeInSec, _cliffTimeInSec, _endTimeInSec)\n', '    {\n', '\n', '        require(vestingToken.transferFrom(approvedWallet, address(this), _totalAmount));\n', '        require(vestingToken.balanceOf(address(this)) >= _totalAmount);\n', '\n', '        schedules[_addressToRegister] = VestingSchedule({\n', '            startTimeInSec : _startTimeInSec,\n', '            cliffTimeInSec : _cliffTimeInSec,\n', '            endTimeInSec : _endTimeInSec,\n', '            totalAmount : _totalAmount,\n', '            totalAmountWithdrawn : 0,\n', '            depositor : _depositor\n', '            });\n', '\n', '        VestingScheduleRegistered(\n', '            _addressToRegister,\n', '            _depositor,\n', '            _startTimeInSec,\n', '            _cliffTimeInSec,\n', '            _endTimeInSec,\n', '            _totalAmount\n', '        );\n', '    }\n', '\n', '    /// @dev Allows a registered address to withdraw tokens that have already been vested.\n', '    function withdraw()\n', '    public\n', '    pastCliffTime(msg.sender)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[msg.sender];\n', '        uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '        uint amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '        vestingSchedule.totalAmountWithdrawn = totalAmountVested;\n', '\n', '        if (amountWithdrawable > 0) {\n', '            require(vestingToken.transfer(msg.sender, amountWithdrawable));\n', '            Withdrawal(msg.sender, amountWithdrawable);\n', '        }\n', '    }\n', '\n', '    /// @dev Allows contract owner to terminate a vesting schedule, transfering remaining vested tokens to the registered address and refunding owner with remaining tokens.\n', '    /// @param _addressToEnd Address that is currently registered to the vesting schedule that will be closed.\n', '    /// @param _addressToRefund Address that will receive unvested tokens.\n', '    function endVesting(address _addressToEnd, address _addressToRefund)\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_addressToRefund)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[_addressToEnd];\n', '\n', '        uint amountWithdrawable = 0;\n', '        uint amountRefundable = 0;\n', '\n', '        if (getTime() < vestingSchedule.cliffTimeInSec) {\n', '            amountRefundable = vestingSchedule.totalAmount;\n', '        }\n', '        else {\n', '            uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '            amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '            amountRefundable = safeSub(vestingSchedule.totalAmount, totalAmountVested);\n', '        }\n', '\n', '        delete schedules[_addressToEnd];\n', '        require(amountWithdrawable == 0 || vestingToken.transfer(_addressToEnd, amountWithdrawable));\n', '        require(amountRefundable == 0 || vestingToken.transfer(_addressToRefund, amountRefundable));\n', '\n', '        VestingEndedByOwner(_addressToEnd, amountWithdrawable, amountRefundable);\n', '    }\n', '\n', '    /// @dev Allows a registered address to request an address change.\n', '    /// @param _newRegisteredAddress Desired address to update to.\n', '    function requestAddressChange(address _newRegisteredAddress)\n', '    public\n', '    addressNotRegistered(_newRegisteredAddress)\n', '    addressNotNull(_newRegisteredAddress)\n', '    {\n', '        addressChangeRequests[msg.sender] = _newRegisteredAddress;\n', '        AddressChangeRequested(msg.sender, _newRegisteredAddress);\n', '    }\n', '\n', '    /// @dev Confirm an address change and migrate vesting schedule to new address.\n', '    /// @param _oldRegisteredAddress Current registered address.\n', '    /// @param _newRegisteredAddress Address to migrate vesting schedule to.\n', '    function confirmAddressChange(address _oldRegisteredAddress, address _newRegisteredAddress)\n', '    public\n', '    onlyOwner\n', '    pendingAddressChangeRequest(_oldRegisteredAddress)\n', '    addressNotRegistered(_newRegisteredAddress)\n', '    {\n', '        address newRegisteredAddress = addressChangeRequests[_oldRegisteredAddress];\n', '        require(newRegisteredAddress == _newRegisteredAddress);\n', '        // prevents race condition\n', '\n', '        VestingSchedule memory vestingSchedule = schedules[_oldRegisteredAddress];\n', '        schedules[newRegisteredAddress] = vestingSchedule;\n', '\n', '        delete schedules[_oldRegisteredAddress];\n', '        delete addressChangeRequests[_oldRegisteredAddress];\n', '\n', '        AddressChangeConfirmed(_oldRegisteredAddress, _newRegisteredAddress);\n', '    }\n', '\n', '    function setApprovedWallet(address _approvedWallet)\n', '    public\n', '    addressNotNull(_approvedWallet)\n', '    onlyOwner {\n', '        approvedWallet = _approvedWallet;\n', '    }\n', '\n', '    function getTime() internal view returns (uint) {\n', '        return now;\n', '    }\n', '\n', '    function allowance(address _target) public view returns (uint) {\n', '        VestingSchedule storage vestingSchedule = schedules[_target];\n', '        uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '        uint amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '        return amountWithdrawable;\n', '    }\n', '\n', '    /// @dev Calculates the total tokens that have been vested for a vesting schedule, assuming the schedule is past the cliff.\n', '    /// @param vestingSchedule Vesting schedule used to calculate vested tokens.\n', '    /// @return Total tokens vested for a vesting schedule.\n', '    function getTotalAmountVested(VestingSchedule vestingSchedule)\n', '    internal\n', '    view\n', '    returns (uint)\n', '    {\n', '        if (getTime() >= vestingSchedule.endTimeInSec) {\n', '            return vestingSchedule.totalAmount;\n', '        }\n', '\n', '        uint timeSinceStartInSec = safeSub(getTime(), vestingSchedule.startTimeInSec);\n', '        uint totalVestingTimeInSec = safeSub(vestingSchedule.endTimeInSec, vestingSchedule.startTimeInSec);\n', '        uint totalAmountVested = safeDiv(\n', '            safeMul(timeSinceStartInSec, vestingSchedule.totalAmount), totalVestingTimeInSec\n', '        );\n', '\n', '        return totalAmountVested;\n', '    }\n', '}']
['pragma solidity ^0.4.19;\n', '\n', '// File: contracts/erc20/Token.sol\n', '\n', 'contract Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal constant returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal constant returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/vesting/VestingWallet.sol\n', '\n', 'contract VestingWallet is Ownable, SafeMath {\n', '\n', '    mapping(address => VestingSchedule) public schedules;        // vesting schedules for given addresses\n', '    mapping(address => address) public addressChangeRequests;    // requested address changes\n', '\n', '    Token public vestingToken;\n', '\n', '    address public approvedWallet;\n', '\n', '    event VestingScheduleRegistered(\n', '        address indexed registeredAddress,\n', '        address depositor,\n', '        uint startTimeInSec,\n', '        uint cliffTimeInSec,\n', '        uint endTimeInSec,\n', '        uint totalAmount\n', '    );\n', '\n', '\n', '    event Withdrawal(address indexed registeredAddress, uint amountWithdrawn);\n', '\n', '    event VestingEndedByOwner(address indexed registeredAddress, uint amountWithdrawn, uint amountRefunded);\n', '\n', '    event AddressChangeRequested(address indexed oldRegisteredAddress, address indexed newRegisteredAddress);\n', '\n', '    event AddressChangeConfirmed(address indexed oldRegisteredAddress, address indexed newRegisteredAddress);\n', '\n', '    struct VestingSchedule {\n', '        uint startTimeInSec;\n', '        uint cliffTimeInSec;\n', '        uint endTimeInSec;\n', '        uint totalAmount;\n', '        uint totalAmountWithdrawn;\n', '        address depositor;\n', '    }\n', '\n', '    modifier addressRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier addressNotRegistered(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(vestingSchedule.depositor == address(0));\n', '        _;\n', '    }\n', '\n', '    modifier pendingAddressChangeRequest(address target) {\n', '        require(addressChangeRequests[target] != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier pastCliffTime(address target) {\n', '        VestingSchedule storage vestingSchedule = schedules[target];\n', '        require(getTime() > vestingSchedule.cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier validVestingScheduleTimes(uint startTimeInSec, uint cliffTimeInSec, uint endTimeInSec) {\n', '        require(cliffTimeInSec >= startTimeInSec);\n', '        require(endTimeInSec >= cliffTimeInSec);\n', '        _;\n', '    }\n', '\n', '    modifier addressNotNull(address target) {\n', '        require(target != address(0));\n', '        _;\n', '    }\n', '\n', '    /// @dev Assigns a vesting token to the wallet.\n', '    /// @param _vestingToken Token that will be vested.\n', '    function VestingWallet(address _vestingToken) {\n', '        vestingToken = Token(_vestingToken);\n', '        approvedWallet = msg.sender;\n', '    }\n', '\n', '    function registerVestingScheduleWithPercentage(\n', '        address _addressToRegister,\n', '        address _depositor,\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount,\n', '        uint _percentage\n', '    )\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_depositor)\n', '    validVestingScheduleTimes(_startTimeInSec, _cliffTimeInSec, _endTimeInSec)\n', '    {\n', '        require(_percentage <= 100);\n', '        uint vestedAmount = safeDiv(safeMul(\n', '                _totalAmount, _percentage\n', '            ), 100);\n', '        registerVestingSchedule(_addressToRegister, _depositor, _startTimeInSec, _cliffTimeInSec, _endTimeInSec, vestedAmount);\n', '    }\n', '\n', '    /// @dev Registers a vesting schedule to an address.\n', '    /// @param _addressToRegister The address that is allowed to withdraw vested tokens for this schedule.\n', '    /// @param _depositor Address that will be depositing vesting token.\n', '    /// @param _startTimeInSec The time in seconds that vesting began.\n', '    /// @param _cliffTimeInSec The time in seconds that tokens become withdrawable.\n', '    /// @param _endTimeInSec The time in seconds that vesting ends.\n', '    /// @param _totalAmount The total amount of tokens that the registered address can withdraw by the end of the vesting period.\n', '    function registerVestingSchedule(\n', '        address _addressToRegister,\n', '        address _depositor,\n', '        uint _startTimeInSec,\n', '        uint _cliffTimeInSec,\n', '        uint _endTimeInSec,\n', '        uint _totalAmount\n', '    )\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_depositor)\n', '    validVestingScheduleTimes(_startTimeInSec, _cliffTimeInSec, _endTimeInSec)\n', '    {\n', '\n', '        require(vestingToken.transferFrom(approvedWallet, address(this), _totalAmount));\n', '        require(vestingToken.balanceOf(address(this)) >= _totalAmount);\n', '\n', '        schedules[_addressToRegister] = VestingSchedule({\n', '            startTimeInSec : _startTimeInSec,\n', '            cliffTimeInSec : _cliffTimeInSec,\n', '            endTimeInSec : _endTimeInSec,\n', '            totalAmount : _totalAmount,\n', '            totalAmountWithdrawn : 0,\n', '            depositor : _depositor\n', '            });\n', '\n', '        VestingScheduleRegistered(\n', '            _addressToRegister,\n', '            _depositor,\n', '            _startTimeInSec,\n', '            _cliffTimeInSec,\n', '            _endTimeInSec,\n', '            _totalAmount\n', '        );\n', '    }\n', '\n', '    /// @dev Allows a registered address to withdraw tokens that have already been vested.\n', '    function withdraw()\n', '    public\n', '    pastCliffTime(msg.sender)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[msg.sender];\n', '        uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '        uint amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '        vestingSchedule.totalAmountWithdrawn = totalAmountVested;\n', '\n', '        if (amountWithdrawable > 0) {\n', '            require(vestingToken.transfer(msg.sender, amountWithdrawable));\n', '            Withdrawal(msg.sender, amountWithdrawable);\n', '        }\n', '    }\n', '\n', '    /// @dev Allows contract owner to terminate a vesting schedule, transfering remaining vested tokens to the registered address and refunding owner with remaining tokens.\n', '    /// @param _addressToEnd Address that is currently registered to the vesting schedule that will be closed.\n', '    /// @param _addressToRefund Address that will receive unvested tokens.\n', '    function endVesting(address _addressToEnd, address _addressToRefund)\n', '    public\n', '    onlyOwner\n', '    addressNotNull(_addressToRefund)\n', '    {\n', '        VestingSchedule storage vestingSchedule = schedules[_addressToEnd];\n', '\n', '        uint amountWithdrawable = 0;\n', '        uint amountRefundable = 0;\n', '\n', '        if (getTime() < vestingSchedule.cliffTimeInSec) {\n', '            amountRefundable = vestingSchedule.totalAmount;\n', '        }\n', '        else {\n', '            uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '            amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '            amountRefundable = safeSub(vestingSchedule.totalAmount, totalAmountVested);\n', '        }\n', '\n', '        delete schedules[_addressToEnd];\n', '        require(amountWithdrawable == 0 || vestingToken.transfer(_addressToEnd, amountWithdrawable));\n', '        require(amountRefundable == 0 || vestingToken.transfer(_addressToRefund, amountRefundable));\n', '\n', '        VestingEndedByOwner(_addressToEnd, amountWithdrawable, amountRefundable);\n', '    }\n', '\n', '    /// @dev Allows a registered address to request an address change.\n', '    /// @param _newRegisteredAddress Desired address to update to.\n', '    function requestAddressChange(address _newRegisteredAddress)\n', '    public\n', '    addressNotRegistered(_newRegisteredAddress)\n', '    addressNotNull(_newRegisteredAddress)\n', '    {\n', '        addressChangeRequests[msg.sender] = _newRegisteredAddress;\n', '        AddressChangeRequested(msg.sender, _newRegisteredAddress);\n', '    }\n', '\n', '    /// @dev Confirm an address change and migrate vesting schedule to new address.\n', '    /// @param _oldRegisteredAddress Current registered address.\n', '    /// @param _newRegisteredAddress Address to migrate vesting schedule to.\n', '    function confirmAddressChange(address _oldRegisteredAddress, address _newRegisteredAddress)\n', '    public\n', '    onlyOwner\n', '    pendingAddressChangeRequest(_oldRegisteredAddress)\n', '    addressNotRegistered(_newRegisteredAddress)\n', '    {\n', '        address newRegisteredAddress = addressChangeRequests[_oldRegisteredAddress];\n', '        require(newRegisteredAddress == _newRegisteredAddress);\n', '        // prevents race condition\n', '\n', '        VestingSchedule memory vestingSchedule = schedules[_oldRegisteredAddress];\n', '        schedules[newRegisteredAddress] = vestingSchedule;\n', '\n', '        delete schedules[_oldRegisteredAddress];\n', '        delete addressChangeRequests[_oldRegisteredAddress];\n', '\n', '        AddressChangeConfirmed(_oldRegisteredAddress, _newRegisteredAddress);\n', '    }\n', '\n', '    function setApprovedWallet(address _approvedWallet)\n', '    public\n', '    addressNotNull(_approvedWallet)\n', '    onlyOwner {\n', '        approvedWallet = _approvedWallet;\n', '    }\n', '\n', '    function getTime() internal view returns (uint) {\n', '        return now;\n', '    }\n', '\n', '    function allowance(address _target) public view returns (uint) {\n', '        VestingSchedule storage vestingSchedule = schedules[_target];\n', '        uint totalAmountVested = getTotalAmountVested(vestingSchedule);\n', '        uint amountWithdrawable = safeSub(totalAmountVested, vestingSchedule.totalAmountWithdrawn);\n', '        return amountWithdrawable;\n', '    }\n', '\n', '    /// @dev Calculates the total tokens that have been vested for a vesting schedule, assuming the schedule is past the cliff.\n', '    /// @param vestingSchedule Vesting schedule used to calculate vested tokens.\n', '    /// @return Total tokens vested for a vesting schedule.\n', '    function getTotalAmountVested(VestingSchedule vestingSchedule)\n', '    internal\n', '    view\n', '    returns (uint)\n', '    {\n', '        if (getTime() >= vestingSchedule.endTimeInSec) {\n', '            return vestingSchedule.totalAmount;\n', '        }\n', '\n', '        uint timeSinceStartInSec = safeSub(getTime(), vestingSchedule.startTimeInSec);\n', '        uint totalVestingTimeInSec = safeSub(vestingSchedule.endTimeInSec, vestingSchedule.startTimeInSec);\n', '        uint totalAmountVested = safeDiv(\n', '            safeMul(timeSinceStartInSec, vestingSchedule.totalAmount), totalVestingTimeInSec\n', '        );\n', '\n', '        return totalAmountVested;\n', '    }\n', '}']
