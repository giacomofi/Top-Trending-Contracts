['pragma solidity ^0.4.21;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract LuckyBaby is Ownable, SafeMath {\n', '\n', '    ERC20 public token;\n', '    bool public activityClosed = false;\n', '    uint public maxGasPrice = 30000000000;\n', '    struct LuckyItem {\n', '        address luckyMan;\n', '        uint amount;\n', '    }\n', '\n', '    LuckyItem[] public history;\n', '\n', '    uint public tokenRewardRate;\n', '\n', '    uint public minTicket;\n', '    uint public maxTicket;\n', '    \n', '    function () payable public {\n', '        if (msg.sender == owner) {\n', '            return;   \n', '        }\n', '        require(!activityClosed);\n', '        require(tx.gasprice <= maxGasPrice);\n', '        require(msg.value >= minTicket);\n', '        require(msg.value <= maxTicket);\n', '        award(msg.value, msg.sender);\n', '    }\n', '    \n', '    function award (uint amount, address add) private {\n', '        uint random_number = (uint(block.blockhash(block.number-1)) - uint(add)) % 100;\n', '        if (random_number == 0) {\n', '            uint reward = safeMult(amount, 100);\n', '            require(address(this).balance >= reward);\n', '            add.transfer(reward);\n', '            LuckyItem memory item = LuckyItem({luckyMan:add, amount:reward});\n', '            history.push(item);\n', '        }\n', '        if (token.balanceOf(this) >= tokenRewardRate) {\n', '            token.transfer(add, tokenRewardRate);\n', '        }\n', '    }\n', '    function LuckyBaby() public {\n', '        token = ERC20(address(0x00));\n', '        tokenRewardRate = 20*10**18;\n', '        minTicket = 10**16;\n', '        maxTicket = 10**17;\n', '    }\n', '    function setToken(ERC20 newToken) onlyOwner public {\n', '        token = newToken;\n', '    }\n', '    function setMaxGasPrice(uint max) onlyOwner public {\n', '        maxGasPrice = max;\n', '    }\n', '    function setActivityState(bool close) onlyOwner public {\n', '        activityClosed = close;\n', '    }\n', '    function setTokenRewardRate(uint rate) onlyOwner public {\n', '        tokenRewardRate = rate;\n', '    }\n', '    function setMaxTicket(uint max) onlyOwner public {\n', '        maxTicket = max;\n', '    }\n', '    function withdrawToken(uint amount) onlyOwner public {\n', '        uint256 leave = token.balanceOf(this);\n', '        if (leave >= amount) {\n', '            token.transfer(owner, amount);\n', '        }\n', '    }\n', '    function withdrawEther(uint amount) onlyOwner public {\n', '       owner.transfer(amount);\n', '    }\n', '    function clear() onlyOwner public {\n', '        uint leave = token.balanceOf(this);\n', '        if (leave > 0) {\n', '            token.transfer(owner, leave);\n', '        }\n', '        uint balance = address(this).balance;\n', '        if (balance > 0) {\n', '            owner.transfer(balance);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '}\n', '\n', 'contract LuckyBaby is Ownable, SafeMath {\n', '\n', '    ERC20 public token;\n', '    bool public activityClosed = false;\n', '    uint public maxGasPrice = 30000000000;\n', '    struct LuckyItem {\n', '        address luckyMan;\n', '        uint amount;\n', '    }\n', '\n', '    LuckyItem[] public history;\n', '\n', '    uint public tokenRewardRate;\n', '\n', '    uint public minTicket;\n', '    uint public maxTicket;\n', '    \n', '    function () payable public {\n', '        if (msg.sender == owner) {\n', '            return;   \n', '        }\n', '        require(!activityClosed);\n', '        require(tx.gasprice <= maxGasPrice);\n', '        require(msg.value >= minTicket);\n', '        require(msg.value <= maxTicket);\n', '        award(msg.value, msg.sender);\n', '    }\n', '    \n', '    function award (uint amount, address add) private {\n', '        uint random_number = (uint(block.blockhash(block.number-1)) - uint(add)) % 100;\n', '        if (random_number == 0) {\n', '            uint reward = safeMult(amount, 100);\n', '            require(address(this).balance >= reward);\n', '            add.transfer(reward);\n', '            LuckyItem memory item = LuckyItem({luckyMan:add, amount:reward});\n', '            history.push(item);\n', '        }\n', '        if (token.balanceOf(this) >= tokenRewardRate) {\n', '            token.transfer(add, tokenRewardRate);\n', '        }\n', '    }\n', '    function LuckyBaby() public {\n', '        token = ERC20(address(0x00));\n', '        tokenRewardRate = 20*10**18;\n', '        minTicket = 10**16;\n', '        maxTicket = 10**17;\n', '    }\n', '    function setToken(ERC20 newToken) onlyOwner public {\n', '        token = newToken;\n', '    }\n', '    function setMaxGasPrice(uint max) onlyOwner public {\n', '        maxGasPrice = max;\n', '    }\n', '    function setActivityState(bool close) onlyOwner public {\n', '        activityClosed = close;\n', '    }\n', '    function setTokenRewardRate(uint rate) onlyOwner public {\n', '        tokenRewardRate = rate;\n', '    }\n', '    function setMaxTicket(uint max) onlyOwner public {\n', '        maxTicket = max;\n', '    }\n', '    function withdrawToken(uint amount) onlyOwner public {\n', '        uint256 leave = token.balanceOf(this);\n', '        if (leave >= amount) {\n', '            token.transfer(owner, amount);\n', '        }\n', '    }\n', '    function withdrawEther(uint amount) onlyOwner public {\n', '       owner.transfer(amount);\n', '    }\n', '    function clear() onlyOwner public {\n', '        uint leave = token.balanceOf(this);\n', '        if (leave > 0) {\n', '            token.transfer(owner, leave);\n', '        }\n', '        uint balance = address(this).balance;\n', '        if (balance > 0) {\n', '            owner.transfer(balance);\n', '        }\n', '    }\n', '}']
