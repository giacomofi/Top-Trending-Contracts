['pragma solidity ^0.4.24;\n', '\n', 'contract ETHCOOLMain {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Deposit {\n', '        address user;\n', '        uint amount;\n', '    }\n', '\n', '    address public owner;\n', '    uint public main_balance;\n', '    uint public next;\n', '\n', '    mapping (address => uint) public user_balances;\n', '    mapping (address => address) public user_referrals;\n', '    \n', '    Deposit[] public deposits;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '        user_referrals[owner] = owner;\n', '        main_balance = 0;\n', '        next = 0;\n', '    }\n', '\n', '    function publicGetBalance(address user) view public returns (uint) {\n', '        return user_balances[user];\n', '    }\n', '\n', '    function publicGetStatus() view public returns (uint, uint, uint) {\n', '        return (main_balance, next, deposits.length);\n', '    }\n', '\n', '    function publicGetDeposit(uint index) view public returns (address, address, uint) {\n', '        return (deposits[index].user, user_referrals[deposits[index].user], deposits[index].amount);\n', '    }\n', '\n', '    function userWithdraw() public {\n', '        userPayout();\n', '        \n', '        if (user_balances[msg.sender] > 0) {\n', '            uint amount = user_balances[msg.sender];\n', '            user_balances[msg.sender] = 0;\n', '            msg.sender.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function userDeposit(address referral) public payable {\n', '        if (msg.value > 0) {\n', '            if(user_referrals[msg.sender] == address(0)) {\n', '                user_referrals[msg.sender] = (referral != address(0) && referral != msg.sender) ? referral : owner;\n', '            }\n', '\n', '            Deposit memory deposit = Deposit(msg.sender, msg.value);\n', '            deposits.push(deposit);\n', '\n', '            uint referral_cut = msg.value.div(100);\n', '            uint owner_cut = msg.value.mul(4).div(100);\n', '            user_balances[user_referrals[msg.sender]] = user_balances[user_referrals[msg.sender]].add(referral_cut);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(msg.value).sub(referral_cut).sub(owner_cut);\n', '        }\n', '\n', '        userPayout();\n', '    }\n', '\n', '    function userReinvest() public {\n', '        if (user_balances[msg.sender] > 0) {\n', '            Deposit memory deposit = Deposit(msg.sender, user_balances[msg.sender]);\n', '            deposits.push(deposit);\n', '\n', '            uint owner_cut = user_balances[msg.sender].mul(5).div(100);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(user_balances[msg.sender]).sub(owner_cut);\n', '            user_balances[msg.sender] = 0;\n', '        }\n', '\n', '        userPayout();\n', '    }\n', '\n', '    function userPayout() public {\n', '        if (next < deposits.length) {\n', '            uint next_payout = deposits[next].amount.mul(120).div(100);\n', '            if (main_balance >= next_payout) {\n', '                user_balances[deposits[next].user] = user_balances[deposits[next].user].add(next_payout);\n', '                main_balance = main_balance.sub(next_payout);\n', '                next = next.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    function contractBoost(uint share) public payable {\n', '        if (msg.value > 0) {\n', '            uint owner_cut = msg.value.mul(share).div(100);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(msg.value).sub(owner_cut);\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ETHCOOLMain {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Deposit {\n', '        address user;\n', '        uint amount;\n', '    }\n', '\n', '    address public owner;\n', '    uint public main_balance;\n', '    uint public next;\n', '\n', '    mapping (address => uint) public user_balances;\n', '    mapping (address => address) public user_referrals;\n', '    \n', '    Deposit[] public deposits;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '        user_referrals[owner] = owner;\n', '        main_balance = 0;\n', '        next = 0;\n', '    }\n', '\n', '    function publicGetBalance(address user) view public returns (uint) {\n', '        return user_balances[user];\n', '    }\n', '\n', '    function publicGetStatus() view public returns (uint, uint, uint) {\n', '        return (main_balance, next, deposits.length);\n', '    }\n', '\n', '    function publicGetDeposit(uint index) view public returns (address, address, uint) {\n', '        return (deposits[index].user, user_referrals[deposits[index].user], deposits[index].amount);\n', '    }\n', '\n', '    function userWithdraw() public {\n', '        userPayout();\n', '        \n', '        if (user_balances[msg.sender] > 0) {\n', '            uint amount = user_balances[msg.sender];\n', '            user_balances[msg.sender] = 0;\n', '            msg.sender.transfer(amount);\n', '        }\n', '    }\n', '\n', '    function userDeposit(address referral) public payable {\n', '        if (msg.value > 0) {\n', '            if(user_referrals[msg.sender] == address(0)) {\n', '                user_referrals[msg.sender] = (referral != address(0) && referral != msg.sender) ? referral : owner;\n', '            }\n', '\n', '            Deposit memory deposit = Deposit(msg.sender, msg.value);\n', '            deposits.push(deposit);\n', '\n', '            uint referral_cut = msg.value.div(100);\n', '            uint owner_cut = msg.value.mul(4).div(100);\n', '            user_balances[user_referrals[msg.sender]] = user_balances[user_referrals[msg.sender]].add(referral_cut);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(msg.value).sub(referral_cut).sub(owner_cut);\n', '        }\n', '\n', '        userPayout();\n', '    }\n', '\n', '    function userReinvest() public {\n', '        if (user_balances[msg.sender] > 0) {\n', '            Deposit memory deposit = Deposit(msg.sender, user_balances[msg.sender]);\n', '            deposits.push(deposit);\n', '\n', '            uint owner_cut = user_balances[msg.sender].mul(5).div(100);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(user_balances[msg.sender]).sub(owner_cut);\n', '            user_balances[msg.sender] = 0;\n', '        }\n', '\n', '        userPayout();\n', '    }\n', '\n', '    function userPayout() public {\n', '        if (next < deposits.length) {\n', '            uint next_payout = deposits[next].amount.mul(120).div(100);\n', '            if (main_balance >= next_payout) {\n', '                user_balances[deposits[next].user] = user_balances[deposits[next].user].add(next_payout);\n', '                main_balance = main_balance.sub(next_payout);\n', '                next = next.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    function contractBoost(uint share) public payable {\n', '        if (msg.value > 0) {\n', '            uint owner_cut = msg.value.mul(share).div(100);\n', '            user_balances[owner] = user_balances[owner].add(owner_cut);\n', '            main_balance = main_balance.add(msg.value).sub(owner_cut);\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']
