['pragma solidity 0.4.24;\n', '\n', 'contract ERC20TokenInterface {\n', '\n', '    function totalSupply () external constant returns (uint);\n', '    function balanceOf (address tokenOwner) external constant returns (uint balance);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam tokens vesting smart contract. \n', ' * This vesting smart contracts releases 25% of tokens 6 months after the smart contract was initialized,\n', ' * 50% of tokens after 1 year, 75% of tokens after 1 year 6 months and 100% tokens are available after 2 years.\n', ' * The withdrawal address is set during the initialization (initializeVestingFor function).\n', ' * To withdraw tokens, send an empty transaction to this smart contract address.\n', ' * Once vesting period (2 year) ends and after all tokens are withdrawn, this smart contract self-destructs.\n', ' */\n', 'contract TwoYearDreamTokensVesting {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Address of DREAM token.\n', '     */\n', '    ERC20TokenInterface public dreamToken;\n', '\n', '    /**\n', '     * Address which will receive tokens. This address is set during initialization.\n', '     */\n', '    address public withdrawalAddress = 0x0;\n', '\n', '    /**\n', '     * Tokens vesting stage structure with vesting date and tokens allowed to unlock.\n', '     */\n', '    struct VestingStage {\n', '        uint256 date;\n', '        uint256 tokensUnlockedPercentage;\n', '    }\n', '\n', '    /**\n', '     * Array for storing all vesting stages with structure defined above.\n', '     */\n', '    VestingStage[4] public stages;\n', '\n', '    /**\n', '     * Total amount of tokens to send.\n', '     */\n', '    uint256 public initialTokensBalance;\n', '\n', '    /**\n', '     * Amount of tokens already sent.\n', '     */\n', '    uint256 public tokensSent;\n', '\n', '    /**\n', '     * Unix timestamp at when the vesting has begun.\n', '     */\n', '    uint256 public vestingStartUnixTimestamp;\n', '\n', '    /**\n', '     * Account that deployed this smart contract, which is authorized to initialize vesting.\n', '     */\n', '    address public deployer;\n', '\n', '    modifier deployerOnly { require(msg.sender == deployer); _; }\n', '    modifier whenInitialized { require(withdrawalAddress != 0x0); _; }\n', '    modifier whenNotInitialized { require(withdrawalAddress == 0x0); _; }\n', '\n', '    /**\n', '     * Event raised on each successful withdraw.\n', '     */\n', '    event Withdraw(uint256 amount, uint256 timestamp);\n', '\n', '    /**\n', '     * Dedicate vesting smart contract for a particular token during deployment.\n', '     * @param token Address of DreamToken that will be locked on contract.\n', '     */\n', '    constructor (ERC20TokenInterface token) public {\n', '        dreamToken = token;\n', '        deployer = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Fallback: function that releases locked tokens within schedule. Send an empty transaction to this\n', '     * smart contract for withdrawalAddress to receive tokens.\n', '     */\n', '    function () external {\n', '        withdrawTokens();\n', '    }\n', '\n', '    /**\n', '     * Vesting initialization function. Contract deployer has to trigger this function after vesting amount\n', '     * was sent to this smart contract.\n', '     * @param account Account to initialize vesting for.\n', '     */\n', '    function initializeVestingFor (address account) external deployerOnly whenNotInitialized {\n', '        initialTokensBalance = dreamToken.balanceOf(this);\n', '        require(initialTokensBalance != 0);\n', '        withdrawalAddress = account;\n', '        vestingStartUnixTimestamp = block.timestamp;\n', '        vestingRules();\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens amount that is sent to withdrawalAddress.\n', '     * @return Amount of tokens that can be sent.\n', '     */\n', '    function getAvailableTokensToWithdraw () public view returns (uint256) {\n', '        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n', '        // withdrawalAddress will only be able to get all additional tokens sent to this smart contract\n', '        // at the end of the vesting period\n', '        if (tokensUnlockedPercentage >= 100) {\n', '            return dreamToken.balanceOf(this);\n', '        } else {\n', '            return getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Setup array with vesting stages dates and percentages.\n', '     */\n', '    function vestingRules () internal {\n', '\n', '        uint256 halfOfYear = 183 days;\n', '        uint256 year = halfOfYear * 2;\n', '\n', '        stages[0].date = vestingStartUnixTimestamp + halfOfYear;\n', '        stages[1].date = vestingStartUnixTimestamp + year;\n', '        stages[2].date = vestingStartUnixTimestamp + year + halfOfYear;\n', '        stages[3].date = vestingStartUnixTimestamp + (year * 2);\n', '\n', '        stages[0].tokensUnlockedPercentage = 25;\n', '        stages[1].tokensUnlockedPercentage = 50;\n', '        stages[2].tokensUnlockedPercentage = 75;\n', '        stages[3].tokensUnlockedPercentage = 100;\n', '\n', '    }\n', '\n', '    /**\n', '     * Function for tokens withdrawal from the vesting smart contract. Triggered from the fallback function.\n', '     */\n', '    function withdrawTokens () private whenInitialized {\n', '        uint256 tokensToSend = getAvailableTokensToWithdraw();\n', '        sendTokens(tokensToSend);\n', '        if (dreamToken.balanceOf(this) == 0) { // When all tokens were sent, destroy this smart contract\n', '            selfdestruct(withdrawalAddress);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Send tokens to withdrawalAddress.\n', '     * @param tokensToSend Amount of tokens will be sent.\n', '     */\n', '    function sendTokens (uint256 tokensToSend) private {\n', '        if (tokensToSend == 0) {\n', '            return;\n', '        }\n', '        tokensSent = tokensSent.add(tokensToSend); // Update tokensSent variable to send correct amount later\n', '        dreamToken.transfer(withdrawalAddress, tokensToSend); // Send allowed number of tokens\n', '        emit Withdraw(tokensToSend, now); // Emitting a notification that tokens were withdrawn\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens available for withdrawal.\n', '     * @param tokensUnlockedPercentage Percent of tokens that are allowed to be sent.\n', '     * @return Amount of tokens that can be sent according to provided percentage.\n', '     */\n', '    function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\n', '        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\n', '        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\n', '        return unsentTokensAmount;\n', '    }\n', '\n', '    /**\n', '     * Get tokens unlocked percentage on current stage.\n', '     * @return Percent of tokens allowed to be sent.\n', '     */\n', '    function getTokensUnlockedPercentage () private view returns (uint256) {\n', '\n', '        uint256 allowedPercent;\n', '\n', '        for (uint8 i = 0; i < stages.length; i++) {\n', '            if (now >= stages[i].date) {\n', '                allowedPercent = stages[i].tokensUnlockedPercentage;\n', '            }\n', '        }\n', '\n', '        return allowedPercent;\n', '\n', '    }\n', '\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract ERC20TokenInterface {\n', '\n', '    function totalSupply () external constant returns (uint);\n', '    function balanceOf (address tokenOwner) external constant returns (uint balance);\n', '    function transfer (address to, uint tokens) external returns (bool success);\n', '    function transferFrom (address from, address to, uint tokens) external returns (bool success);\n', '\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks that throw on overflows.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * DreamTeam tokens vesting smart contract. \n', ' * This vesting smart contracts releases 25% of tokens 6 months after the smart contract was initialized,\n', ' * 50% of tokens after 1 year, 75% of tokens after 1 year 6 months and 100% tokens are available after 2 years.\n', ' * The withdrawal address is set during the initialization (initializeVestingFor function).\n', ' * To withdraw tokens, send an empty transaction to this smart contract address.\n', ' * Once vesting period (2 year) ends and after all tokens are withdrawn, this smart contract self-destructs.\n', ' */\n', 'contract TwoYearDreamTokensVesting {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Address of DREAM token.\n', '     */\n', '    ERC20TokenInterface public dreamToken;\n', '\n', '    /**\n', '     * Address which will receive tokens. This address is set during initialization.\n', '     */\n', '    address public withdrawalAddress = 0x0;\n', '\n', '    /**\n', '     * Tokens vesting stage structure with vesting date and tokens allowed to unlock.\n', '     */\n', '    struct VestingStage {\n', '        uint256 date;\n', '        uint256 tokensUnlockedPercentage;\n', '    }\n', '\n', '    /**\n', '     * Array for storing all vesting stages with structure defined above.\n', '     */\n', '    VestingStage[4] public stages;\n', '\n', '    /**\n', '     * Total amount of tokens to send.\n', '     */\n', '    uint256 public initialTokensBalance;\n', '\n', '    /**\n', '     * Amount of tokens already sent.\n', '     */\n', '    uint256 public tokensSent;\n', '\n', '    /**\n', '     * Unix timestamp at when the vesting has begun.\n', '     */\n', '    uint256 public vestingStartUnixTimestamp;\n', '\n', '    /**\n', '     * Account that deployed this smart contract, which is authorized to initialize vesting.\n', '     */\n', '    address public deployer;\n', '\n', '    modifier deployerOnly { require(msg.sender == deployer); _; }\n', '    modifier whenInitialized { require(withdrawalAddress != 0x0); _; }\n', '    modifier whenNotInitialized { require(withdrawalAddress == 0x0); _; }\n', '\n', '    /**\n', '     * Event raised on each successful withdraw.\n', '     */\n', '    event Withdraw(uint256 amount, uint256 timestamp);\n', '\n', '    /**\n', '     * Dedicate vesting smart contract for a particular token during deployment.\n', '     * @param token Address of DreamToken that will be locked on contract.\n', '     */\n', '    constructor (ERC20TokenInterface token) public {\n', '        dreamToken = token;\n', '        deployer = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Fallback: function that releases locked tokens within schedule. Send an empty transaction to this\n', '     * smart contract for withdrawalAddress to receive tokens.\n', '     */\n', '    function () external {\n', '        withdrawTokens();\n', '    }\n', '\n', '    /**\n', '     * Vesting initialization function. Contract deployer has to trigger this function after vesting amount\n', '     * was sent to this smart contract.\n', '     * @param account Account to initialize vesting for.\n', '     */\n', '    function initializeVestingFor (address account) external deployerOnly whenNotInitialized {\n', '        initialTokensBalance = dreamToken.balanceOf(this);\n', '        require(initialTokensBalance != 0);\n', '        withdrawalAddress = account;\n', '        vestingStartUnixTimestamp = block.timestamp;\n', '        vestingRules();\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens amount that is sent to withdrawalAddress.\n', '     * @return Amount of tokens that can be sent.\n', '     */\n', '    function getAvailableTokensToWithdraw () public view returns (uint256) {\n', '        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n', '        // withdrawalAddress will only be able to get all additional tokens sent to this smart contract\n', '        // at the end of the vesting period\n', '        if (tokensUnlockedPercentage >= 100) {\n', '            return dreamToken.balanceOf(this);\n', '        } else {\n', '            return getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Setup array with vesting stages dates and percentages.\n', '     */\n', '    function vestingRules () internal {\n', '\n', '        uint256 halfOfYear = 183 days;\n', '        uint256 year = halfOfYear * 2;\n', '\n', '        stages[0].date = vestingStartUnixTimestamp + halfOfYear;\n', '        stages[1].date = vestingStartUnixTimestamp + year;\n', '        stages[2].date = vestingStartUnixTimestamp + year + halfOfYear;\n', '        stages[3].date = vestingStartUnixTimestamp + (year * 2);\n', '\n', '        stages[0].tokensUnlockedPercentage = 25;\n', '        stages[1].tokensUnlockedPercentage = 50;\n', '        stages[2].tokensUnlockedPercentage = 75;\n', '        stages[3].tokensUnlockedPercentage = 100;\n', '\n', '    }\n', '\n', '    /**\n', '     * Function for tokens withdrawal from the vesting smart contract. Triggered from the fallback function.\n', '     */\n', '    function withdrawTokens () private whenInitialized {\n', '        uint256 tokensToSend = getAvailableTokensToWithdraw();\n', '        sendTokens(tokensToSend);\n', '        if (dreamToken.balanceOf(this) == 0) { // When all tokens were sent, destroy this smart contract\n', '            selfdestruct(withdrawalAddress);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Send tokens to withdrawalAddress.\n', '     * @param tokensToSend Amount of tokens will be sent.\n', '     */\n', '    function sendTokens (uint256 tokensToSend) private {\n', '        if (tokensToSend == 0) {\n', '            return;\n', '        }\n', '        tokensSent = tokensSent.add(tokensToSend); // Update tokensSent variable to send correct amount later\n', '        dreamToken.transfer(withdrawalAddress, tokensToSend); // Send allowed number of tokens\n', '        emit Withdraw(tokensToSend, now); // Emitting a notification that tokens were withdrawn\n', '    }\n', '\n', '    /**\n', '     * Calculate tokens available for withdrawal.\n', '     * @param tokensUnlockedPercentage Percent of tokens that are allowed to be sent.\n', '     * @return Amount of tokens that can be sent according to provided percentage.\n', '     */\n', '    function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\n', '        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\n', '        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\n', '        return unsentTokensAmount;\n', '    }\n', '\n', '    /**\n', '     * Get tokens unlocked percentage on current stage.\n', '     * @return Percent of tokens allowed to be sent.\n', '     */\n', '    function getTokensUnlockedPercentage () private view returns (uint256) {\n', '\n', '        uint256 allowedPercent;\n', '\n', '        for (uint8 i = 0; i < stages.length; i++) {\n', '            if (now >= stages[i].date) {\n', '                allowedPercent = stages[i].tokensUnlockedPercentage;\n', '            }\n', '        }\n', '\n', '        return allowedPercent;\n', '\n', '    }\n', '\n', '}']
