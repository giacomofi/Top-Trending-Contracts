['pragma solidity ^0.4.18;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract BGXToken {\n', '    // 以下参数测试时会临时修改，在正式发布时需要修正为正式参数 ======>\n', '    string public name = "BIT GAME EXCHANGE";\n', '    string public symbol = "BGX";\n', '\n', '    address ethFundAddress = 0x7C235ac7b006d829990384018B0E98fDf0bA5EF7; // 以太坊轉存地址\n', '    address icoAddress = 0xC817a2afe8F6ba1a697dAaA1df834e18Be9403e7; // ICO地址\n', '    address[] foundationAddresses = [0xBc9d9A1EE11dC2803BA2daaAa892483052Ed97f5,\n', '                                     0x3CA55e25C110b175B6622586aC31a6682a916670,\n', '                                     0xF13b2d7c5d6d6E93f79D41FA72cFD33A75c0607d,\n', '                                     0xc321Cf1D0ab11743cB5dDB4d77F6Ede8a08D3281,\n', '                                     0xf7179c8A47F511E4fcAcA9b6187ED4052cBBB7BB,\n', '                                     0x516c06F2A390E62c2F6cB3C2E38c5c6dF5A17141,\n', '                                     0xE71a86f7FFa3E3aA92e5cA6b6df8B56d8600c7D9]; // 基金会地址，7个\n', '    address[] teamAddresses = [0x3CFdEC9041b04a7eEb07a732B964a5B33f9Ebe1F]; // 团队地址，1个\n', '    address[] miningAddresses = [0x710967a31D79BCFBF053292aB21Bbc559e288407,\n', '                                 0x7bF52Ef4b6e8bEeB24c4Dea4c8e94177739561a0]; // 挖矿地址，2个\n', '    address[] angelAddresses = [0x122399734D64d6c4aa46b85959A3304CA812161f]; // 天使地址，1个\n', '    address[] cornerstoneAddresses = [0x9d35F83982A479F611fa893452f6876972Ec6348,\n', '                                      0x1EAf530897EB1D93fF4373889d9cfd5a1E405D1B,\n', '                                      0x377221D5b7776C1Ba4B8e8d11a32CF9a7469A095,\n', '                                      0xc4381bc9dDFaa8A9954CF2615F80F8Fc145E024F,\n', '                                      0x699a3be17F729F3eB965fBb7d71Db185016B1215,\n', '                                      0x9F793B134E41Bb404142B598E05Ea6ed5477D392,\n', '                                      0xA7FF388DAfD240505f9a1d3ca37c15E058B9D4ea]; // 基石地址，7个\n', '    address[] preIcoAddresses = [0x4d1Ffd49d47552adcaf1729b9C4A2320419b81E1]; // PreICO地址，1个\n', '\n', '    uint256 startTime = 1525708800; // 开始时间戳，2018/5/8 0:0:0 UTC-0\n', '    uint256 endTime = 1528473600; // 结束时间戳，2018/6/9 0:0:0 UTC-0\n', '    uint256 lockEndTime = 1528473600; // 锁定结束时间戳，2018/6/9 0:0:0 UTC-0\n', '    // <====== 正式发布需要修正的参数\n', '\n', '    uint256 public decimals = 18;\n', '    uint256 DECIMALSFACTOR = 10 ** decimals;\n', '    uint256 constant weiDECIMALS = 18; // 以太币的小数位\n', '    uint256 weiFACTOR = 10 ** weiDECIMALS; // 以太币的单位换算值\n', '\n', '    uint256[] foundationAmounts = [5 * (10**8) * DECIMALSFACTOR,\n', '                                   5 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] teamAmounts = [15 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] miningAmounts = [15 * (10**8) * DECIMALSFACTOR,\n', '                               15 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] angelAmounts = [5 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] cornerstoneAmounts = [1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    2 * (10**8) * DECIMALSFACTOR,\n', '                                    3 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] preIcoAmounts = [5 * (10**8) * DECIMALSFACTOR];\n', '\n', '    address contractOwner;\n', '    uint256 ethRaised = 0; // 收到的ETH总数量，单位Wei\n', '    uint256 donationCount; // 参与的总次数\n', '\n', '    uint256 public totalSupply = 100 * (10**8) * DECIMALSFACTOR; // 总量100亿\n', '    uint256 public availableSupply = totalSupply; // 剩余的代币数量\n', '    uint256 hardCap = 30000 * weiFACTOR; // 硬顶3万ETH\n', '    uint256 minimumDonation = 1 * 10 ** (weiDECIMALS - 1); // 最低参与0.1ETH才能参与\n', '\n', '    bool public finalised = false;\n', '\n', '    // 存储所有用户的代币余额值\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function BGXToken() public {\n', '        contractOwner = msg.sender;\n', '\n', '        // 采用累加方式，防止有地址重复\n', '        uint i = 0;\n', '        for (i = 0; i < foundationAddresses.length; i++){\n', '            balanceOf[foundationAddresses[i]] += foundationAmounts[i];\n', '            availableSupply -= foundationAmounts[i];\n', '            emit Transfer(address(0), foundationAddresses[i], foundationAmounts[i]);\n', '        }\n', '        for (i = 0; i < teamAddresses.length; i++){\n', '            balanceOf[teamAddresses[i]] += teamAmounts[i];\n', '            availableSupply -= teamAmounts[i];\n', '            emit Transfer(address(0), teamAddresses[i], teamAmounts[i]);\n', '        }\n', '        for (i = 0; i < miningAddresses.length; i++){\n', '            balanceOf[miningAddresses[i]] += miningAmounts[i];\n', '            availableSupply -= miningAmounts[i];\n', '            emit Transfer(address(0), miningAddresses[i], miningAmounts[i]);\n', '        }\n', '        for (i = 0; i < angelAddresses.length; i++){\n', '            balanceOf[angelAddresses[i]] += angelAmounts[i];\n', '            availableSupply -= angelAmounts[i];\n', '            emit Transfer(address(0), angelAddresses[i], angelAmounts[i]);\n', '        }\n', '        for (i = 0; i < cornerstoneAddresses.length; i++){\n', '            balanceOf[cornerstoneAddresses[i]] += cornerstoneAmounts[i];\n', '            availableSupply -= cornerstoneAmounts[i];\n', '            emit Transfer(address(0), cornerstoneAddresses[i], cornerstoneAmounts[i]);\n', '        }\n', '        for (i = 0; i < preIcoAddresses.length; i++){\n', '            balanceOf[preIcoAddresses[i]] += preIcoAmounts[i];\n', '            availableSupply -= preIcoAmounts[i];\n', '            emit Transfer(address(0), preIcoAddresses[i], preIcoAmounts[i]);\n', '        }\n', '\n', '        // 剩下的代币初始都存在ICO的地址上\n', '        balanceOf[icoAddress] = availableSupply;\n', '        emit Transfer(address(0), icoAddress, availableSupply);\n', '    }\n', '\n', '    // fallback方法，如果用户未在转账data中添加数据，默认是走这个方法\n', '    function () payable public {\n', '        require(!finalised);\n', '\n', '        // 判断是否在项目规定的时间范围内\n', '        require(block.timestamp >= startTime);\n', '        require(block.timestamp <= endTime);\n', '\n', '        // 判断硬顶\n', '        require(ethRaised < hardCap);\n', '\n', '        // 达到最低捐赠额度才能继续，否则失败\n', '        require(msg.value >= minimumDonation);\n', '\n', '        uint256 etherValue = msg.value;\n', '\n', '        // 边界条件，未超过部分的ETH正常收纳，超过的部分退回给用户\n', '        if (ethRaised + etherValue > hardCap){\n', '            etherValue = hardCap - ethRaised;\n', '            // 超过的部分退回给用户\n', '            assert(msg.value > etherValue);\n', '            msg.sender.transfer(msg.value - etherValue);\n', '        }\n', '\n', '        // 转移ETH到指定ETH存币地址\n', '        ethFundAddress.transfer(etherValue);\n', '\n', '        donationCount += 1;\n', '        ethRaised += etherValue;\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function _isInWhiteAddresses(address _from) internal view returns (bool success) {\n', '        if (icoAddress == _from){\n', '            return true;\n', '        }\n', '        uint i = 0;\n', '        for (i = 0; i < foundationAddresses.length; i++){\n', '            if (foundationAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < teamAddresses.length; i++){\n', '            if (teamAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < miningAddresses.length; i++){\n', '            if (miningAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < angelAddresses.length; i++){\n', '            if (angelAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < cornerstoneAddresses.length; i++){\n', '            if (cornerstoneAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < preIcoAddresses.length; i++){\n', '            if (preIcoAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(block.timestamp > lockEndTime || _isInWhiteAddresses(msg.sender));\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime || _isInWhiteAddresses(_from));\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime);\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Update totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime);\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', '        allowance[_from][msg.sender] -= _value;             // Subtract from the sender&#39;s allowance\n', '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function finalise() public {\n', '        require(msg.sender == contractOwner);\n', '        require(!finalised);\n', '\n', '        finalised = true;\n', '    }\n', '\n', '    function setLockEndTime(uint256 t) public {\n', '        require(msg.sender == contractOwner);\n', '        lockEndTime = t;\n', '    }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract BGXToken {\n', '    // 以下参数测试时会临时修改，在正式发布时需要修正为正式参数 ======>\n', '    string public name = "BIT GAME EXCHANGE";\n', '    string public symbol = "BGX";\n', '\n', '    address ethFundAddress = 0x7C235ac7b006d829990384018B0E98fDf0bA5EF7; // 以太坊轉存地址\n', '    address icoAddress = 0xC817a2afe8F6ba1a697dAaA1df834e18Be9403e7; // ICO地址\n', '    address[] foundationAddresses = [0xBc9d9A1EE11dC2803BA2daaAa892483052Ed97f5,\n', '                                     0x3CA55e25C110b175B6622586aC31a6682a916670,\n', '                                     0xF13b2d7c5d6d6E93f79D41FA72cFD33A75c0607d,\n', '                                     0xc321Cf1D0ab11743cB5dDB4d77F6Ede8a08D3281,\n', '                                     0xf7179c8A47F511E4fcAcA9b6187ED4052cBBB7BB,\n', '                                     0x516c06F2A390E62c2F6cB3C2E38c5c6dF5A17141,\n', '                                     0xE71a86f7FFa3E3aA92e5cA6b6df8B56d8600c7D9]; // 基金会地址，7个\n', '    address[] teamAddresses = [0x3CFdEC9041b04a7eEb07a732B964a5B33f9Ebe1F]; // 团队地址，1个\n', '    address[] miningAddresses = [0x710967a31D79BCFBF053292aB21Bbc559e288407,\n', '                                 0x7bF52Ef4b6e8bEeB24c4Dea4c8e94177739561a0]; // 挖矿地址，2个\n', '    address[] angelAddresses = [0x122399734D64d6c4aa46b85959A3304CA812161f]; // 天使地址，1个\n', '    address[] cornerstoneAddresses = [0x9d35F83982A479F611fa893452f6876972Ec6348,\n', '                                      0x1EAf530897EB1D93fF4373889d9cfd5a1E405D1B,\n', '                                      0x377221D5b7776C1Ba4B8e8d11a32CF9a7469A095,\n', '                                      0xc4381bc9dDFaa8A9954CF2615F80F8Fc145E024F,\n', '                                      0x699a3be17F729F3eB965fBb7d71Db185016B1215,\n', '                                      0x9F793B134E41Bb404142B598E05Ea6ed5477D392,\n', '                                      0xA7FF388DAfD240505f9a1d3ca37c15E058B9D4ea]; // 基石地址，7个\n', '    address[] preIcoAddresses = [0x4d1Ffd49d47552adcaf1729b9C4A2320419b81E1]; // PreICO地址，1个\n', '\n', '    uint256 startTime = 1525708800; // 开始时间戳，2018/5/8 0:0:0 UTC-0\n', '    uint256 endTime = 1528473600; // 结束时间戳，2018/6/9 0:0:0 UTC-0\n', '    uint256 lockEndTime = 1528473600; // 锁定结束时间戳，2018/6/9 0:0:0 UTC-0\n', '    // <====== 正式发布需要修正的参数\n', '\n', '    uint256 public decimals = 18;\n', '    uint256 DECIMALSFACTOR = 10 ** decimals;\n', '    uint256 constant weiDECIMALS = 18; // 以太币的小数位\n', '    uint256 weiFACTOR = 10 ** weiDECIMALS; // 以太币的单位换算值\n', '\n', '    uint256[] foundationAmounts = [5 * (10**8) * DECIMALSFACTOR,\n', '                                   5 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR,\n', '                                   1 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] teamAmounts = [15 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] miningAmounts = [15 * (10**8) * DECIMALSFACTOR,\n', '                               15 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] angelAmounts = [5 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] cornerstoneAmounts = [1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    1 * (10**8) * DECIMALSFACTOR,\n', '                                    2 * (10**8) * DECIMALSFACTOR,\n', '                                    3 * (10**8) * DECIMALSFACTOR];\n', '    uint256[] preIcoAmounts = [5 * (10**8) * DECIMALSFACTOR];\n', '\n', '    address contractOwner;\n', '    uint256 ethRaised = 0; // 收到的ETH总数量，单位Wei\n', '    uint256 donationCount; // 参与的总次数\n', '\n', '    uint256 public totalSupply = 100 * (10**8) * DECIMALSFACTOR; // 总量100亿\n', '    uint256 public availableSupply = totalSupply; // 剩余的代币数量\n', '    uint256 hardCap = 30000 * weiFACTOR; // 硬顶3万ETH\n', '    uint256 minimumDonation = 1 * 10 ** (weiDECIMALS - 1); // 最低参与0.1ETH才能参与\n', '\n', '    bool public finalised = false;\n', '\n', '    // 存储所有用户的代币余额值\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    function BGXToken() public {\n', '        contractOwner = msg.sender;\n', '\n', '        // 采用累加方式，防止有地址重复\n', '        uint i = 0;\n', '        for (i = 0; i < foundationAddresses.length; i++){\n', '            balanceOf[foundationAddresses[i]] += foundationAmounts[i];\n', '            availableSupply -= foundationAmounts[i];\n', '            emit Transfer(address(0), foundationAddresses[i], foundationAmounts[i]);\n', '        }\n', '        for (i = 0; i < teamAddresses.length; i++){\n', '            balanceOf[teamAddresses[i]] += teamAmounts[i];\n', '            availableSupply -= teamAmounts[i];\n', '            emit Transfer(address(0), teamAddresses[i], teamAmounts[i]);\n', '        }\n', '        for (i = 0; i < miningAddresses.length; i++){\n', '            balanceOf[miningAddresses[i]] += miningAmounts[i];\n', '            availableSupply -= miningAmounts[i];\n', '            emit Transfer(address(0), miningAddresses[i], miningAmounts[i]);\n', '        }\n', '        for (i = 0; i < angelAddresses.length; i++){\n', '            balanceOf[angelAddresses[i]] += angelAmounts[i];\n', '            availableSupply -= angelAmounts[i];\n', '            emit Transfer(address(0), angelAddresses[i], angelAmounts[i]);\n', '        }\n', '        for (i = 0; i < cornerstoneAddresses.length; i++){\n', '            balanceOf[cornerstoneAddresses[i]] += cornerstoneAmounts[i];\n', '            availableSupply -= cornerstoneAmounts[i];\n', '            emit Transfer(address(0), cornerstoneAddresses[i], cornerstoneAmounts[i]);\n', '        }\n', '        for (i = 0; i < preIcoAddresses.length; i++){\n', '            balanceOf[preIcoAddresses[i]] += preIcoAmounts[i];\n', '            availableSupply -= preIcoAmounts[i];\n', '            emit Transfer(address(0), preIcoAddresses[i], preIcoAmounts[i]);\n', '        }\n', '\n', '        // 剩下的代币初始都存在ICO的地址上\n', '        balanceOf[icoAddress] = availableSupply;\n', '        emit Transfer(address(0), icoAddress, availableSupply);\n', '    }\n', '\n', '    // fallback方法，如果用户未在转账data中添加数据，默认是走这个方法\n', '    function () payable public {\n', '        require(!finalised);\n', '\n', '        // 判断是否在项目规定的时间范围内\n', '        require(block.timestamp >= startTime);\n', '        require(block.timestamp <= endTime);\n', '\n', '        // 判断硬顶\n', '        require(ethRaised < hardCap);\n', '\n', '        // 达到最低捐赠额度才能继续，否则失败\n', '        require(msg.value >= minimumDonation);\n', '\n', '        uint256 etherValue = msg.value;\n', '\n', '        // 边界条件，未超过部分的ETH正常收纳，超过的部分退回给用户\n', '        if (ethRaised + etherValue > hardCap){\n', '            etherValue = hardCap - ethRaised;\n', '            // 超过的部分退回给用户\n', '            assert(msg.value > etherValue);\n', '            msg.sender.transfer(msg.value - etherValue);\n', '        }\n', '\n', '        // 转移ETH到指定ETH存币地址\n', '        ethFundAddress.transfer(etherValue);\n', '\n', '        donationCount += 1;\n', '        ethRaised += etherValue;\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != 0x0);\n', '        // Check if the sender has enough\n', '        require(balanceOf[_from] >= _value);\n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        // Save this for an assertion in the future\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        // Subtract from the sender\n', '        balanceOf[_from] -= _value;\n', '        // Add the same to the recipient\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '\n', '    function _isInWhiteAddresses(address _from) internal view returns (bool success) {\n', '        if (icoAddress == _from){\n', '            return true;\n', '        }\n', '        uint i = 0;\n', '        for (i = 0; i < foundationAddresses.length; i++){\n', '            if (foundationAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < teamAddresses.length; i++){\n', '            if (teamAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < miningAddresses.length; i++){\n', '            if (miningAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < angelAddresses.length; i++){\n', '            if (angelAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < cornerstoneAddresses.length; i++){\n', '            if (cornerstoneAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        for (i = 0; i < preIcoAddresses.length; i++){\n', '            if (preIcoAddresses[i] == _from){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(block.timestamp > lockEndTime || _isInWhiteAddresses(msg.sender));\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime || _isInWhiteAddresses(_from));\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime);\n', '        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n', '        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n', '        totalSupply -= _value;                      // Update totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(block.timestamp > lockEndTime);\n', '        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n', '        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n', '        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n', "        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n", '        totalSupply -= _value;                              // Update totalSupply\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '\n', '    function finalise() public {\n', '        require(msg.sender == contractOwner);\n', '        require(!finalised);\n', '\n', '        finalised = true;\n', '    }\n', '\n', '    function setLockEndTime(uint256 t) public {\n', '        require(msg.sender == contractOwner);\n', '        lockEndTime = t;\n', '    }\n', '}']
