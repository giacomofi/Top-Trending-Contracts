['pragma solidity ^0.4.24;\n', '\n', '\n', '// The contract for the locaToken instance\n', 'contract locaToken {\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint);\n', '}\n', '\n', '// Safemath library  \n', 'library SafeMath {\n', '    function sub(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint) {\n', '        assert(_value <= _base);\n', '        return _base - _value;\n', '    }\n', '\n', '    function add(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint _ret) {\n', '        _ret = _base + _value;\n', '        assert(_ret >= _base);\n', '    }\n', '\n', '    function div(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint) {\n', '        assert(_value > 0 && (_base % _value) == 0);\n', '        return _base / _value;\n', '    }\n', '\n', '    function mul(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint _ret) {\n', '        _ret = _base * _value;\n', '        assert(0 == _base || _ret / _base == _value);\n', '    }\n', '}\n', '\n', '\n', '\n', '// The donation contract\n', '\n', 'contract Donation  {\n', '    using SafeMath for uint;\n', '    // instance the locatoken\n', '    locaToken private token = locaToken(0xcDf9bAff52117711B33210AdE38f1180CFC003ed);\n', '    address  private owner;\n', '\n', '    uint private _tokenGift;\n', '    // every donation is logged in the Blockchain\n', '    event Donated(address indexed buyer, uint tokens);\n', '     // Available tokens for donation\n', '    uint private _tokenDonation;\n', '  \n', '\n', '    // constructor to set the contract owner\n', '    constructor() public {\n', '\n', '        owner = msg.sender; \n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    // Allow the donation to start\n', '    modifier allowStart() {\n', '        require(_tokenDonation == 0);\n', '        _;\n', '    }\n', '    // There have at least to be 25000000000 Loca tokens in balance to allow a valid donation\n', '    modifier allowDonation(){\n', '        require(_tokenDonation >= 25000000000);\n', '        _;\n', '    }\n', '    // Donation amount has to be between 0.02 and 0.03 ETH\n', '    // regardless the donation amount,  250 LOCAs will be send \n', '    modifier validDonation {\n', '        require (msg.value >= 20000000000000000 && msg.value <= 30000000000000000);                                                                                        \n', '        _;\n', '    }\n', '\n', '\n', '    function startDonation() public onlyOwner allowStart returns (uint) {\n', '\n', '        _tokenDonation = token.allowance(owner, address(this));\n', '    }\n', '\n', '\n', '    function DonateEther() public allowDonation validDonation payable {\n', '\n', '       //  _tokensold = msg.value.mul(_convrate).div(Devider);\n', '        _tokenGift = 25000000000;\n', '        _tokenDonation = _tokenDonation.sub(_tokenGift);\n', '        \n', '        emit Donated(msg.sender, _tokenGift);\n', '\n', '        token.transferFrom(owner, msg.sender, _tokenGift);\n', '\n', '        \n', '\n', '    }\n', '\n', '    // Falsely send Ether will be reverted\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '\n', '    function TokenBalance () public view returns(uint){\n', '\n', '        return _tokenDonation;\n', '\n', '    }\n', '\n', '    // Withdraw Ether from the contract\n', '    function getDonation(address _to) public onlyOwner {\n', '       \n', '        _to.transfer(address(this).balance);\n', '    \n', '    } \n', '\n', '    function CloseDonation() public onlyOwner {\n', '\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '\n', '// The contract for the locaToken instance\n', 'contract locaToken {\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool);\n', '    function allowance(address _owner, address _spender) public view returns (uint);\n', '}\n', '\n', '// Safemath library  \n', 'library SafeMath {\n', '    function sub(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint) {\n', '        assert(_value <= _base);\n', '        return _base - _value;\n', '    }\n', '\n', '    function add(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint _ret) {\n', '        _ret = _base + _value;\n', '        assert(_ret >= _base);\n', '    }\n', '\n', '    function div(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint) {\n', '        assert(_value > 0 && (_base % _value) == 0);\n', '        return _base / _value;\n', '    }\n', '\n', '    function mul(uint _base, uint _value)\n', '    internal\n', '    pure\n', '    returns (uint _ret) {\n', '        _ret = _base * _value;\n', '        assert(0 == _base || _ret / _base == _value);\n', '    }\n', '}\n', '\n', '\n', '\n', '// The donation contract\n', '\n', 'contract Donation  {\n', '    using SafeMath for uint;\n', '    // instance the locatoken\n', '    locaToken private token = locaToken(0xcDf9bAff52117711B33210AdE38f1180CFC003ed);\n', '    address  private owner;\n', '\n', '    uint private _tokenGift;\n', '    // every donation is logged in the Blockchain\n', '    event Donated(address indexed buyer, uint tokens);\n', '     // Available tokens for donation\n', '    uint private _tokenDonation;\n', '  \n', '\n', '    // constructor to set the contract owner\n', '    constructor() public {\n', '\n', '        owner = msg.sender; \n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    // Allow the donation to start\n', '    modifier allowStart() {\n', '        require(_tokenDonation == 0);\n', '        _;\n', '    }\n', '    // There have at least to be 25000000000 Loca tokens in balance to allow a valid donation\n', '    modifier allowDonation(){\n', '        require(_tokenDonation >= 25000000000);\n', '        _;\n', '    }\n', '    // Donation amount has to be between 0.02 and 0.03 ETH\n', '    // regardless the donation amount,  250 LOCAs will be send \n', '    modifier validDonation {\n', '        require (msg.value >= 20000000000000000 && msg.value <= 30000000000000000);                                                                                        \n', '        _;\n', '    }\n', '\n', '\n', '    function startDonation() public onlyOwner allowStart returns (uint) {\n', '\n', '        _tokenDonation = token.allowance(owner, address(this));\n', '    }\n', '\n', '\n', '    function DonateEther() public allowDonation validDonation payable {\n', '\n', '       //  _tokensold = msg.value.mul(_convrate).div(Devider);\n', '        _tokenGift = 25000000000;\n', '        _tokenDonation = _tokenDonation.sub(_tokenGift);\n', '        \n', '        emit Donated(msg.sender, _tokenGift);\n', '\n', '        token.transferFrom(owner, msg.sender, _tokenGift);\n', '\n', '        \n', '\n', '    }\n', '\n', '    // Falsely send Ether will be reverted\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '\n', '    function TokenBalance () public view returns(uint){\n', '\n', '        return _tokenDonation;\n', '\n', '    }\n', '\n', '    // Withdraw Ether from the contract\n', '    function getDonation(address _to) public onlyOwner {\n', '       \n', '        _to.transfer(address(this).balance);\n', '    \n', '    } \n', '\n', '    function CloseDonation() public onlyOwner {\n', '\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
