['pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, &#39;Only the owner can call this method&#39;);\n', '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract EtheroStabilizationFund{\n', '    /**\n', '     * In the event of the shortage of funds for the level payments\n', '     * stabilization the contract of the stabilization fund provides backup support to the investment fund.\n', '     * ethero contract address = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;\n', '     */\n', '    \n', '    address public  ethero = 0x0223f73a53a549B8F5a9661aDB4cD9Dd4E25BEDa;\n', '    uint public investFund;\n', '    uint estGas = 100000;\n', '    event MoneyWithdraw(uint balance);\n', '    event MoneyAdd(uint holding);\n', '    \n', '     /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyHero() {\n', '         require(msg.sender == ethero, &#39;Only Hero call&#39;);\n', '         _;\n', '    }\n', '    \n', '    function ReturnEthToEthero()public onlyHero returns(bool){\n', '        \n', '        uint balance = address(this).balance;\n', '        \n', '        require(balance > estGas, &#39;Not enough funds for transaction&#39;);\n', '        \n', '        if(ethero.call.value(address(this).balance).gas(estGas)()){\n', '            emit MoneyWithdraw(balance);\n', '            investFund = address(this).balance;\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '        \n', '    }\n', '     \n', '    function() external payable{\n', '        \n', '        investFund+=msg.value;\n', '        emit MoneyAdd(msg.value);\n', '    }\n', '    \n', '    \n', '}\n', '\n', 'contract EtHero is Ownable{\n', '\n', '   using SafeMath for uint;\n', '    // array containing information about beneficiaries\n', '    mapping (address => uint) public balances;\n', '    //array containing information about the time of payment\n', '    mapping (address => uint) private time;\n', '    \n', '    //purse addresses for payments\n', '    //when call the method LevelUpDeposit, money is transferred to the first two purses\n', '    // fund1 and fund2\n', '    address public  fund1 = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;\n', '    address public  fund2 = 0xa7A20b9f36CD88fC2c776C9BB23FcEA34ba80ef7;\n', '    address public stabFund;\n', '    uint estGas = 100000;\n', '    \n', '    uint standartPersent = 30; // 30/1000*100 = 3%\n', '    uint  minPercent = 5; // 5/1000*100 = 0.5%\n', '    uint public minPayment = 5 finney; //0.05 ether \n', '    \n', '    //the time through which dividends will be paid\n', '    uint dividendsTime = 1 days;\n', '    \n', '    event NewInvestor(address indexed investor, uint deposit);\n', '    event PayOffDividends(address indexed investor, uint value);\n', '    event NewDeposit(address indexed investor, uint value);\n', '    event ResiveFromStubFund(uint value);\n', '    \n', '    uint public allDeposits;\n', '    uint public allPercents;\n', '    uint public allBeneficiaries;\n', '    uint public lastPayment;\n', '    \n', '    struct Beneficiaries{\n', '      address investorAddress;\n', '      uint registerTime;\n', '      uint persentWithdraw;\n', '      uint ethWithdraw;\n', '      uint deposits;\n', '      bool real;\n', '      \n', '  }\n', '  \n', '  mapping(address => Beneficiaries) beneficiaries;\n', '  \n', '  \n', '  function setStubFund(address _address)onlyOwner public{\n', '      require(_address>0, &#39;Incorrect address&#39;);\n', '      stabFund = _address;\n', '      \n', '      \n', '  }\n', '  \n', '  \n', '  function insertBeneficiaries(address _address, uint _persentWithdraw, uint _ethWithdraw, uint _deposits)private{\n', '      \n', '      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '      \n', '      if (!s_beneficiaries.real){\n', '          \n', '          s_beneficiaries.real = true;\n', '          s_beneficiaries.investorAddress = _address;\n', '          s_beneficiaries.persentWithdraw = _persentWithdraw;\n', '          s_beneficiaries.ethWithdraw = _ethWithdraw;\n', '          s_beneficiaries.deposits = _deposits;\n', '          s_beneficiaries.registerTime = now;\n', '          \n', '          allBeneficiaries+=1;\n', '      }else{\n', '          s_beneficiaries.persentWithdraw += _persentWithdraw;\n', '          s_beneficiaries.ethWithdraw += _ethWithdraw;\n', '      }\n', '  } \n', '  \n', '  function getBeneficiaries(address _address)public view returns(\n', '      address investorAddress,\n', '      uint persentWithdraw,\n', '      uint ethWithdraw,\n', '      uint registerTime \n', '      ){\n', '      \n', '      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '      \n', '      require(s_beneficiaries.real, &#39;404: Investor Not Found :(&#39;);\n', '      \n', '      \n', '      return(\n', '          s_beneficiaries.investorAddress,\n', '          s_beneficiaries.persentWithdraw,\n', '          s_beneficiaries.ethWithdraw,\n', '          s_beneficiaries.registerTime\n', '          );\n', '  } \n', '    \n', '    \n', '    \n', '    modifier isIssetRecepient(){\n', '        require(balances[msg.sender] > 0, "Deposit not found");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * modifier checking the next payout time\n', '     */\n', '    modifier timeCheck(){\n', '        \n', '         require(now >= time[msg.sender].add(dividendsTime), "Too fast payout request");\n', '         _;\n', '        \n', '    }\n', '    \n', '   \n', '    function receivePayment()isIssetRecepient timeCheck internal{\n', '        uint percent = getPercent();\n', '        uint rate = balances[msg.sender].mul(percent).div(1000);\n', '        time[msg.sender] = now;\n', '        msg.sender.transfer(rate);\n', '        \n', '        allPercents+=rate;\n', '        lastPayment =now;\n', '        \n', '        insertBeneficiaries(msg.sender, percent, rate,0);\n', '        emit PayOffDividends(msg.sender, rate);\n', '        \n', '    }\n', '    \n', '    \n', '    function authorizationPayment()public view returns(bool){\n', '        \n', '        if (balances[msg.sender] > 0 && now >= (time[msg.sender].add(dividendsTime))){\n', '            return (true);\n', '        }else{\n', '            return(false);\n', '        }\n', '        \n', '    }\n', '   \n', '    \n', '    function getPercent()internal  returns(uint){\n', '        \n', '        \n', '        uint value = balances[msg.sender].mul(standartPersent).div(1000);\n', '        uint min_value = balances[msg.sender].mul(minPercent).div(1000);\n', '        \n', '        \n', '        \n', '        if(address(this).balance < min_value){\n', '            // Return money from stab. fund\n', '            EtheroStabilizationFund stubF = EtheroStabilizationFund(stabFund);\n', '            require(stubF.ReturnEthToEthero(), &#39;Forgive, the stabilization fund can not cover your deposit, try to withdraw your interest later &#39;);\n', '            emit ResiveFromStubFund(25);\n', '        }\n', '        \n', '        \n', '        \n', '        uint contractBalance = address(this).balance;\n', '        \n', '        require(contractBalance > min_value, &#39;Out of money, wait a few days, we will attract new investments&#39;);\n', '       \n', '        if(contractBalance > (value.mul(standartPersent).div(1000))){\n', '            return(30);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(5)).div(1000))){\n', '            return(25);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(10)).div(1000))){\n', '            return(20);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(15)).div(1000))){\n', '            return(15);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(20)).div(1000))){\n', '            return(10);\n', '        }\n', '         if(contractBalance > (value.mul(standartPersent.sub(25)).div(1000))){\n', '            return(5);\n', '        }\n', '        \n', '        \n', '        \n', '    }\n', '    \n', '    function createDeposit() private{\n', '        \n', '        uint value = msg.value;\n', '        uint rateFund1 = value.mul(5).div(100);\n', '        uint rateFund2 = value.mul(5).div(100);\n', '        uint rateStubFund = value.mul(10).div(100);\n', '        \n', '        if(msg.value > 0){\n', '            \n', '            if (balances[msg.sender] == 0){\n', '                emit NewInvestor(msg.sender, msg.value);\n', '            }\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '            time[msg.sender] = now;\n', '            insertBeneficiaries(msg.sender,0,0, msg.value);\n', '            \n', '            fund1.transfer(rateFund1);\n', '            fund2.transfer(rateFund2);\n', '            stabFund.call.value(rateStubFund).gas(estGas)();\n', '            \n', '            allDeposits+=msg.value;\n', '            \n', '            emit NewDeposit(msg.sender, msg.value);\n', '            \n', '        }else{\n', '            \n', '            receivePayment();\n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    function() external payable{\n', '        \n', '        //buffer overflow protection\n', '        require((balances[msg.sender].add(msg.value)) >= balances[msg.sender]);\n', '        if(msg.sender!=stabFund){\n', '            createDeposit();\n', '        }else{\n', '            emit ResiveFromStubFund(msg.value);\n', '        }        \n', '        \n', '       \n', '    }\n', '    \n', '    \n', '}']
['pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public{\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', "    require(msg.sender == owner, 'Only the owner can call this method');\n", '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract EtheroStabilizationFund{\n', '    /**\n', '     * In the event of the shortage of funds for the level payments\n', '     * stabilization the contract of the stabilization fund provides backup support to the investment fund.\n', '     * ethero contract address = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;\n', '     */\n', '    \n', '    address public  ethero = 0x0223f73a53a549B8F5a9661aDB4cD9Dd4E25BEDa;\n', '    uint public investFund;\n', '    uint estGas = 100000;\n', '    event MoneyWithdraw(uint balance);\n', '    event MoneyAdd(uint holding);\n', '    \n', '     /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyHero() {\n', "         require(msg.sender == ethero, 'Only Hero call');\n", '         _;\n', '    }\n', '    \n', '    function ReturnEthToEthero()public onlyHero returns(bool){\n', '        \n', '        uint balance = address(this).balance;\n', '        \n', "        require(balance > estGas, 'Not enough funds for transaction');\n", '        \n', '        if(ethero.call.value(address(this).balance).gas(estGas)()){\n', '            emit MoneyWithdraw(balance);\n', '            investFund = address(this).balance;\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '        \n', '    }\n', '     \n', '    function() external payable{\n', '        \n', '        investFund+=msg.value;\n', '        emit MoneyAdd(msg.value);\n', '    }\n', '    \n', '    \n', '}\n', '\n', 'contract EtHero is Ownable{\n', '\n', '   using SafeMath for uint;\n', '    // array containing information about beneficiaries\n', '    mapping (address => uint) public balances;\n', '    //array containing information about the time of payment\n', '    mapping (address => uint) private time;\n', '    \n', '    //purse addresses for payments\n', '    //when call the method LevelUpDeposit, money is transferred to the first two purses\n', '    // fund1 and fund2\n', '    address public  fund1 = 0xf846f84841b3242Ccdeac8c43C9cF73Bd781baA7;\n', '    address public  fund2 = 0xa7A20b9f36CD88fC2c776C9BB23FcEA34ba80ef7;\n', '    address public stabFund;\n', '    uint estGas = 100000;\n', '    \n', '    uint standartPersent = 30; // 30/1000*100 = 3%\n', '    uint  minPercent = 5; // 5/1000*100 = 0.5%\n', '    uint public minPayment = 5 finney; //0.05 ether \n', '    \n', '    //the time through which dividends will be paid\n', '    uint dividendsTime = 1 days;\n', '    \n', '    event NewInvestor(address indexed investor, uint deposit);\n', '    event PayOffDividends(address indexed investor, uint value);\n', '    event NewDeposit(address indexed investor, uint value);\n', '    event ResiveFromStubFund(uint value);\n', '    \n', '    uint public allDeposits;\n', '    uint public allPercents;\n', '    uint public allBeneficiaries;\n', '    uint public lastPayment;\n', '    \n', '    struct Beneficiaries{\n', '      address investorAddress;\n', '      uint registerTime;\n', '      uint persentWithdraw;\n', '      uint ethWithdraw;\n', '      uint deposits;\n', '      bool real;\n', '      \n', '  }\n', '  \n', '  mapping(address => Beneficiaries) beneficiaries;\n', '  \n', '  \n', '  function setStubFund(address _address)onlyOwner public{\n', "      require(_address>0, 'Incorrect address');\n", '      stabFund = _address;\n', '      \n', '      \n', '  }\n', '  \n', '  \n', '  function insertBeneficiaries(address _address, uint _persentWithdraw, uint _ethWithdraw, uint _deposits)private{\n', '      \n', '      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '      \n', '      if (!s_beneficiaries.real){\n', '          \n', '          s_beneficiaries.real = true;\n', '          s_beneficiaries.investorAddress = _address;\n', '          s_beneficiaries.persentWithdraw = _persentWithdraw;\n', '          s_beneficiaries.ethWithdraw = _ethWithdraw;\n', '          s_beneficiaries.deposits = _deposits;\n', '          s_beneficiaries.registerTime = now;\n', '          \n', '          allBeneficiaries+=1;\n', '      }else{\n', '          s_beneficiaries.persentWithdraw += _persentWithdraw;\n', '          s_beneficiaries.ethWithdraw += _ethWithdraw;\n', '      }\n', '  } \n', '  \n', '  function getBeneficiaries(address _address)public view returns(\n', '      address investorAddress,\n', '      uint persentWithdraw,\n', '      uint ethWithdraw,\n', '      uint registerTime \n', '      ){\n', '      \n', '      Beneficiaries storage s_beneficiaries = beneficiaries[_address];\n', '      \n', "      require(s_beneficiaries.real, '404: Investor Not Found :(');\n", '      \n', '      \n', '      return(\n', '          s_beneficiaries.investorAddress,\n', '          s_beneficiaries.persentWithdraw,\n', '          s_beneficiaries.ethWithdraw,\n', '          s_beneficiaries.registerTime\n', '          );\n', '  } \n', '    \n', '    \n', '    \n', '    modifier isIssetRecepient(){\n', '        require(balances[msg.sender] > 0, "Deposit not found");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * modifier checking the next payout time\n', '     */\n', '    modifier timeCheck(){\n', '        \n', '         require(now >= time[msg.sender].add(dividendsTime), "Too fast payout request");\n', '         _;\n', '        \n', '    }\n', '    \n', '   \n', '    function receivePayment()isIssetRecepient timeCheck internal{\n', '        uint percent = getPercent();\n', '        uint rate = balances[msg.sender].mul(percent).div(1000);\n', '        time[msg.sender] = now;\n', '        msg.sender.transfer(rate);\n', '        \n', '        allPercents+=rate;\n', '        lastPayment =now;\n', '        \n', '        insertBeneficiaries(msg.sender, percent, rate,0);\n', '        emit PayOffDividends(msg.sender, rate);\n', '        \n', '    }\n', '    \n', '    \n', '    function authorizationPayment()public view returns(bool){\n', '        \n', '        if (balances[msg.sender] > 0 && now >= (time[msg.sender].add(dividendsTime))){\n', '            return (true);\n', '        }else{\n', '            return(false);\n', '        }\n', '        \n', '    }\n', '   \n', '    \n', '    function getPercent()internal  returns(uint){\n', '        \n', '        \n', '        uint value = balances[msg.sender].mul(standartPersent).div(1000);\n', '        uint min_value = balances[msg.sender].mul(minPercent).div(1000);\n', '        \n', '        \n', '        \n', '        if(address(this).balance < min_value){\n', '            // Return money from stab. fund\n', '            EtheroStabilizationFund stubF = EtheroStabilizationFund(stabFund);\n', "            require(stubF.ReturnEthToEthero(), 'Forgive, the stabilization fund can not cover your deposit, try to withdraw your interest later ');\n", '            emit ResiveFromStubFund(25);\n', '        }\n', '        \n', '        \n', '        \n', '        uint contractBalance = address(this).balance;\n', '        \n', "        require(contractBalance > min_value, 'Out of money, wait a few days, we will attract new investments');\n", '       \n', '        if(contractBalance > (value.mul(standartPersent).div(1000))){\n', '            return(30);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(5)).div(1000))){\n', '            return(25);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(10)).div(1000))){\n', '            return(20);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(15)).div(1000))){\n', '            return(15);\n', '        }\n', '        if(contractBalance > (value.mul(standartPersent.sub(20)).div(1000))){\n', '            return(10);\n', '        }\n', '         if(contractBalance > (value.mul(standartPersent.sub(25)).div(1000))){\n', '            return(5);\n', '        }\n', '        \n', '        \n', '        \n', '    }\n', '    \n', '    function createDeposit() private{\n', '        \n', '        uint value = msg.value;\n', '        uint rateFund1 = value.mul(5).div(100);\n', '        uint rateFund2 = value.mul(5).div(100);\n', '        uint rateStubFund = value.mul(10).div(100);\n', '        \n', '        if(msg.value > 0){\n', '            \n', '            if (balances[msg.sender] == 0){\n', '                emit NewInvestor(msg.sender, msg.value);\n', '            }\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '            time[msg.sender] = now;\n', '            insertBeneficiaries(msg.sender,0,0, msg.value);\n', '            \n', '            fund1.transfer(rateFund1);\n', '            fund2.transfer(rateFund2);\n', '            stabFund.call.value(rateStubFund).gas(estGas)();\n', '            \n', '            allDeposits+=msg.value;\n', '            \n', '            emit NewDeposit(msg.sender, msg.value);\n', '            \n', '        }else{\n', '            \n', '            receivePayment();\n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    function() external payable{\n', '        \n', '        //buffer overflow protection\n', '        require((balances[msg.sender].add(msg.value)) >= balances[msg.sender]);\n', '        if(msg.sender!=stabFund){\n', '            createDeposit();\n', '        }else{\n', '            emit ResiveFromStubFund(msg.value);\n', '        }        \n', '        \n', '       \n', '    }\n', '    \n', '    \n', '}']
