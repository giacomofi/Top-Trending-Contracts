['pragma solidity ^0.4.21;\n', '\n', 'contract Math \n', '{\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', 'contract Grass is Math\n', '{\n', '  uint256 public availableTokens;\n', '  uint256 currentTokenPriceInDollar;\n', '\n', '  uint256 public lastUpdateEtherPrice;\n', '  uint256 public etherPriceInDollarIn;\n', '  uint256 public etherPriceInDollarOut;\n', '\n', '  function getCurrentTokenPrice() public constant returns (uint256)\n', '  {\n', '      uint256 today = getToday();\n', '      return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today];\n', '  }\n', '\n', '  mapping(uint256 => uint256) public tokenPriceHistory;\n', '  struct ExtraTokensInfo\n', '  {\n', '    uint256 timestamp;\n', '    uint256 extraTokens;\n', '    string  proofLink;\n', '    uint256 videoFileHash;\n', '  }\n', '\n', '  ExtraTokensInfo[] public extraTokens;\n', '\n', '  struct TokenInfo \n', '  {    \n', '    uint256 amount;\n', '    bool isReturnedInPool;    \n', '  }\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '\n', '  // address => day => amount  \n', '  mapping(address => mapping(uint256 => TokenInfo)) timeTable;\n', '  mapping(address => mapping(uint256 => uint256)) bonuses;\n', '  mapping (address => uint256) public balances;  \n', '  uint256 public totalSupply;\n', '\n', '  string public name;\n', '  uint8 public decimals;\n', '  string public symbol;\n', '  \n', '  bool isCanBuy = true;\n', '\n', '  modifier canBuy()\n', '  {\n', '      assert(isCanBuy);\n', '      _;\n', '  }\n', '\n', '  function changeState(bool bNewState) public onlyAdmin\n', '  {\n', '      isCanBuy = bNewState;\n', '  }\n', '  \n', '  address owner;\n', '  mapping(address => bool) admins;\n', '  modifier onlyAdmin()\n', '  {\n', '      assert(admins[msg.sender] == true || msg.sender == owner);\n', '      _;\n', '  }\n', '\n', '  modifier onlyOwner()\n', '  {\n', '      assert(msg.sender == owner);\n', '      _;\n', '  }\n', '  function addAdmin(address addr) public onlyOwner\n', '  {\n', '      admins[addr] = true;\n', '  }\n', '  function removeAdmin(address addr) public onlyOwner\n', '  {\n', '      admins[addr] = false;\n', '  }\n', '    \n', '  function Grass() public\n', '  {   \n', '    // startTime = block.timestamp;\n', '    owner = msg.sender;\n', '    admins[msg.sender] = true;\n', '    totalSupply = 0;                        \n', '    name = &#39;GRASS Token&#39;;                   \n', '    decimals = 18;                          \n', '    symbol = &#39;GRASS&#39;;\n', '    availableTokens = 800 * 10**18;\n', '    currentTokenPriceInDollar = 35 * 100; // 35.00$ (price may change) \n', '\n', '    etherPriceInDollarIn = 530 * 100;  // 550.00 $  (price may change)\n', '    etherPriceInDollarOut = 530 * 100; // 550.00 $  (price may change)\n', '    lastUpdateEtherPrice = block.timestamp;\n', '  }\n', '\n', '  function increaseMaxAvailableTokens(uint256 amount, string link, uint256 videoFileHash) onlyAdmin public\n', '  {\n', '    extraTokens.push(ExtraTokensInfo(block.timestamp, amount, link, videoFileHash));\n', '    availableTokens = add(availableTokens, amount);\n', '  }\n', '  \n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '      return balances[_owner];\n', '  }\n', '\n', '  function updateEtherPrice (uint256 newPriceIn, uint256 newPriceOut) onlyAdmin public \n', '  {   \n', '    etherPriceInDollarIn = newPriceIn;\n', '    etherPriceInDollarOut = newPriceOut;\n', '    lastUpdateEtherPrice = block.timestamp;\n', '  }\n', '\n', '  modifier isEtherPriceUpdated() \n', '  {\n', '      require(now - lastUpdateEtherPrice < 24 hours);\n', '      _;\n', '  }\n', '\n', '  function updateTokenPrice (uint256 newPrice) onlyAdmin public \n', '  {   \n', '    currentTokenPriceInDollar = newPrice;   \n', '  }\n', '  \n', '  function getToday() public constant returns (uint256)\n', '  {\n', '      return block.timestamp / 24 hours;\n', '  }\n', '\n', '  function() isEtherPriceUpdated canBuy payable public\n', '  {\n', '      buyInternal(msg.sender);\n', '  }\n', '\n', '  function buyFor(address addr) isEtherPriceUpdated canBuy payable public\n', '  {\n', '      buyInternal(addr);\n', '      // \n', '      if (addr.balance == 0) addr.transfer(1 finney);\n', '  }\n', '\n', '  function buy() isEtherPriceUpdated canBuy payable public\n', '  {\n', '    buyInternal(msg.sender);\n', '  }\n', '  \n', '  function getPartnerBalance (address addr) public view returns(uint256)  \n', '  {\n', '    return partners[addr];\n', '  }\n', '\n', '  function partnerWithdraw () public \n', '  {\n', '    assert (partners[msg.sender] > 0);\n', '    uint256 ethToWidthdraw = partners[msg.sender];\n', '    partners[msg.sender] = 0;\n', '    msg.sender.transfer(ethToWidthdraw);\n', '  }  \n', '  \n', '  mapping(address => uint256) partners;\n', '  // refferal => partner\n', '  mapping(address => address) referrals;\n', '\n', '  function takeEther(address dest, uint256 amount) onlyAdmin public\n', '  {\n', '      dest.transfer(amount);\n', '  }\n', '  \n', '  function addEther() payable onlyAdmin public\n', '  {\n', '  }\n', '\n', '  function buyWithPromo(address partner) isEtherPriceUpdated canBuy payable public\n', '  {\n', '      if (referrals[msg.sender] == 0 && partner != msg.sender)\n', '      {\n', '        referrals[msg.sender] = partner;\n', '      }\n', '\n', '      buyInternal(msg.sender);\n', '  }\n', '  \n', '  function buyInternal(address addr) internal\n', '  {\n', '    if (referrals[addr] != 0)\n', '    {\n', '        partners[referrals[addr]] += msg.value / 100; // 1% to partner\n', '    }  \n', '      \n', '    // проверка lastUpdateEtherPrice\n', '    uint256 today = getToday();\n', '    if (tokenPriceHistory[today] == 0) tokenPriceHistory[today] = currentTokenPriceInDollar;\n', '\n', '    // timeTable\n', '    uint256 amount = msg.value * etherPriceInDollarIn / tokenPriceHistory[today] ;\n', '    if (amount > availableTokens)\n', '    {\n', '       addr.transfer((amount - availableTokens) * tokenPriceHistory[today] / etherPriceInDollarIn);\n', '       amount = availableTokens;\n', '    }\n', '      \n', '    assert(amount > 0);\n', '      \n', '    availableTokens = sub(availableTokens, amount);\n', '\n', '    // is new day ?\n', '    if (timeTable[addr][today].amount == 0)\n', '    {\n', '      timeTable[addr][today] = TokenInfo(amount, false);\n', '    }\n', '    else\n', '    {\n', '      timeTable[addr][today].amount += amount;\n', '    }\n', '\n', '    //                  < 30.03.2018\n', '    if (block.timestamp < 1522357200 && bonuses[addr][today] == 0)\n', '    {\n', '      bonuses[addr][today] = 1;\n', '    }\n', '\n', '    balances[addr] = add(balances[addr], amount);\n', '    totalSupply = add(totalSupply, amount);\n', '    emit Transfer(0, addr, amount);\n', '  }\n', '\n', '  function calculateProfit (uint256 day) public constant returns(int256) \n', '  {\n', '    uint256 today = getToday();\n', '    assert(today >= day);\n', '    uint256 daysLeft = today - day;\n', '    int256 extraProfit = 0;\n', '\n', '    // is referral ?\n', '    if (referrals[msg.sender] != 0) extraProfit++;\n', '    // participant until March 30\n', '    if (bonuses[msg.sender][day] > 0) extraProfit++;\n', '\n', '    if (daysLeft <= 7) return -10;\n', '    if (daysLeft <= 14) return -5;\n', '    if (daysLeft <= 21) return 1 + extraProfit;\n', '    if (daysLeft <= 28) return 3 + extraProfit;\n', '    if (daysLeft <= 60) return 5 + extraProfit;\n', '    if (daysLeft <= 90) return 12 + extraProfit;\n', '    return 18 + extraProfit;  \n', '  }\n', '  \n', '  function getTokensPerDay(uint256 _day) public view returns (uint256)\n', '  {\n', '      return timeTable[msg.sender][_day].amount;\n', '  }\n', '\n', '  // returns amount, ether  \n', '  function getProfitForDay(uint256 day, uint256 amount) isEtherPriceUpdated public constant returns(uint256, uint256)\n', '  {      \n', '    assert (day <= getToday());\n', '    \n', '    uint256 tokenPrice = tokenPriceHistory[day];\n', '    if (timeTable[msg.sender][day].amount < amount) amount = timeTable[msg.sender][day].amount;    \n', '\n', '    assert (amount > 0);\n', '          \n', '    return (amount, amount * tokenPrice * uint256(100 + calculateProfit(day)) / 100 / etherPriceInDollarOut);\n', '  }\n', '\n', '  function returnTokensInPool (address[] addr, uint256[] _days) public\n', '  {\n', '    assert (addr.length == _days.length);\n', '    \n', '    TokenInfo storage info; \n', '    for(uint256 i = 0; i < addr.length;i++)\n', '    {\n', '      assert(_days[i] + 92 < getToday() && info.amount > 0);\n', '      info = timeTable[addr[i]][_days[i]];\n', '      info.isReturnedInPool = true;\n', '      availableTokens = add(availableTokens, info.amount);      \n', '    }\n', '  }\n', '\n', '  function getInfo(address addr, uint256 start, uint256 end) public constant returns (uint256[30] _days, uint256[30] _amounts, int256[30] _profits, uint256[30] _etherAmounts)\n', '  {\n', '      if (addr == 0) addr = msg.sender;\n', '\n', '      uint256 j = 0;\n', '      for(uint256 iDay = start; iDay < end; iDay++)\n', '      {\n', '        if (timeTable[addr][iDay].amount > 0)\n', '        {\n', '          _days[j] = iDay;\n', '          _profits[j] = calculateProfit(iDay);\n', '          _amounts[j] = timeTable[addr][iDay].amount;\n', '          (_amounts[j], _etherAmounts[j]) = getProfitForDay(iDay, _amounts[j]);\n', '          j++;\n', '          if (j == 30) break;\n', '        }\n', '      }\n', '  }\n', '  \n', '  function returnTokensForDay(uint256 day, uint256 userTokensAmount) public \n', '  {\n', '    uint256 tokensAmount;\n', '    uint256 etherAmount;\n', '    (tokensAmount, etherAmount) = getProfitForDay(day, userTokensAmount);\n', '\n', '    require(day > 0);\n', '    require(balances[msg.sender] >= tokensAmount);\n', '    \n', '    balances[msg.sender] = sub(balances[msg.sender], tokensAmount);\n', '    totalSupply = sub(totalSupply, tokensAmount);\n', '    timeTable[msg.sender][day].amount = sub(timeTable[msg.sender][day].amount, tokensAmount);\n', '    \n', '    if (!timeTable[msg.sender][day].isReturnedInPool)\n', '    {\n', '      availableTokens = add(availableTokens, tokensAmount);      \n', '    }\n', '\n', '    msg.sender.transfer(etherAmount);\n', '    emit Transfer(msg.sender, 0, tokensAmount);\n', '  }\n', '  \n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Math \n', '{\n', '    /*\n', '    standard uint256 functions\n', '     */\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x * y) >= x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '}\n', '\n', 'contract Grass is Math\n', '{\n', '  uint256 public availableTokens;\n', '  uint256 currentTokenPriceInDollar;\n', '\n', '  uint256 public lastUpdateEtherPrice;\n', '  uint256 public etherPriceInDollarIn;\n', '  uint256 public etherPriceInDollarOut;\n', '\n', '  function getCurrentTokenPrice() public constant returns (uint256)\n', '  {\n', '      uint256 today = getToday();\n', '      return (tokenPriceHistory[today] == 0)?currentTokenPriceInDollar:tokenPriceHistory[today];\n', '  }\n', '\n', '  mapping(uint256 => uint256) public tokenPriceHistory;\n', '  struct ExtraTokensInfo\n', '  {\n', '    uint256 timestamp;\n', '    uint256 extraTokens;\n', '    string  proofLink;\n', '    uint256 videoFileHash;\n', '  }\n', '\n', '  ExtraTokensInfo[] public extraTokens;\n', '\n', '  struct TokenInfo \n', '  {    \n', '    uint256 amount;\n', '    bool isReturnedInPool;    \n', '  }\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value); \n', '\n', '  // address => day => amount  \n', '  mapping(address => mapping(uint256 => TokenInfo)) timeTable;\n', '  mapping(address => mapping(uint256 => uint256)) bonuses;\n', '  mapping (address => uint256) public balances;  \n', '  uint256 public totalSupply;\n', '\n', '  string public name;\n', '  uint8 public decimals;\n', '  string public symbol;\n', '  \n', '  bool isCanBuy = true;\n', '\n', '  modifier canBuy()\n', '  {\n', '      assert(isCanBuy);\n', '      _;\n', '  }\n', '\n', '  function changeState(bool bNewState) public onlyAdmin\n', '  {\n', '      isCanBuy = bNewState;\n', '  }\n', '  \n', '  address owner;\n', '  mapping(address => bool) admins;\n', '  modifier onlyAdmin()\n', '  {\n', '      assert(admins[msg.sender] == true || msg.sender == owner);\n', '      _;\n', '  }\n', '\n', '  modifier onlyOwner()\n', '  {\n', '      assert(msg.sender == owner);\n', '      _;\n', '  }\n', '  function addAdmin(address addr) public onlyOwner\n', '  {\n', '      admins[addr] = true;\n', '  }\n', '  function removeAdmin(address addr) public onlyOwner\n', '  {\n', '      admins[addr] = false;\n', '  }\n', '    \n', '  function Grass() public\n', '  {   \n', '    // startTime = block.timestamp;\n', '    owner = msg.sender;\n', '    admins[msg.sender] = true;\n', '    totalSupply = 0;                        \n', "    name = 'GRASS Token';                   \n", '    decimals = 18;                          \n', "    symbol = 'GRASS';\n", '    availableTokens = 800 * 10**18;\n', '    currentTokenPriceInDollar = 35 * 100; // 35.00$ (price may change) \n', '\n', '    etherPriceInDollarIn = 530 * 100;  // 550.00 $  (price may change)\n', '    etherPriceInDollarOut = 530 * 100; // 550.00 $  (price may change)\n', '    lastUpdateEtherPrice = block.timestamp;\n', '  }\n', '\n', '  function increaseMaxAvailableTokens(uint256 amount, string link, uint256 videoFileHash) onlyAdmin public\n', '  {\n', '    extraTokens.push(ExtraTokensInfo(block.timestamp, amount, link, videoFileHash));\n', '    availableTokens = add(availableTokens, amount);\n', '  }\n', '  \n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '      return balances[_owner];\n', '  }\n', '\n', '  function updateEtherPrice (uint256 newPriceIn, uint256 newPriceOut) onlyAdmin public \n', '  {   \n', '    etherPriceInDollarIn = newPriceIn;\n', '    etherPriceInDollarOut = newPriceOut;\n', '    lastUpdateEtherPrice = block.timestamp;\n', '  }\n', '\n', '  modifier isEtherPriceUpdated() \n', '  {\n', '      require(now - lastUpdateEtherPrice < 24 hours);\n', '      _;\n', '  }\n', '\n', '  function updateTokenPrice (uint256 newPrice) onlyAdmin public \n', '  {   \n', '    currentTokenPriceInDollar = newPrice;   \n', '  }\n', '  \n', '  function getToday() public constant returns (uint256)\n', '  {\n', '      return block.timestamp / 24 hours;\n', '  }\n', '\n', '  function() isEtherPriceUpdated canBuy payable public\n', '  {\n', '      buyInternal(msg.sender);\n', '  }\n', '\n', '  function buyFor(address addr) isEtherPriceUpdated canBuy payable public\n', '  {\n', '      buyInternal(addr);\n', '      // \n', '      if (addr.balance == 0) addr.transfer(1 finney);\n', '  }\n', '\n', '  function buy() isEtherPriceUpdated canBuy payable public\n', '  {\n', '    buyInternal(msg.sender);\n', '  }\n', '  \n', '  function getPartnerBalance (address addr) public view returns(uint256)  \n', '  {\n', '    return partners[addr];\n', '  }\n', '\n', '  function partnerWithdraw () public \n', '  {\n', '    assert (partners[msg.sender] > 0);\n', '    uint256 ethToWidthdraw = partners[msg.sender];\n', '    partners[msg.sender] = 0;\n', '    msg.sender.transfer(ethToWidthdraw);\n', '  }  \n', '  \n', '  mapping(address => uint256) partners;\n', '  // refferal => partner\n', '  mapping(address => address) referrals;\n', '\n', '  function takeEther(address dest, uint256 amount) onlyAdmin public\n', '  {\n', '      dest.transfer(amount);\n', '  }\n', '  \n', '  function addEther() payable onlyAdmin public\n', '  {\n', '  }\n', '\n', '  function buyWithPromo(address partner) isEtherPriceUpdated canBuy payable public\n', '  {\n', '      if (referrals[msg.sender] == 0 && partner != msg.sender)\n', '      {\n', '        referrals[msg.sender] = partner;\n', '      }\n', '\n', '      buyInternal(msg.sender);\n', '  }\n', '  \n', '  function buyInternal(address addr) internal\n', '  {\n', '    if (referrals[addr] != 0)\n', '    {\n', '        partners[referrals[addr]] += msg.value / 100; // 1% to partner\n', '    }  \n', '      \n', '    // проверка lastUpdateEtherPrice\n', '    uint256 today = getToday();\n', '    if (tokenPriceHistory[today] == 0) tokenPriceHistory[today] = currentTokenPriceInDollar;\n', '\n', '    // timeTable\n', '    uint256 amount = msg.value * etherPriceInDollarIn / tokenPriceHistory[today] ;\n', '    if (amount > availableTokens)\n', '    {\n', '       addr.transfer((amount - availableTokens) * tokenPriceHistory[today] / etherPriceInDollarIn);\n', '       amount = availableTokens;\n', '    }\n', '      \n', '    assert(amount > 0);\n', '      \n', '    availableTokens = sub(availableTokens, amount);\n', '\n', '    // is new day ?\n', '    if (timeTable[addr][today].amount == 0)\n', '    {\n', '      timeTable[addr][today] = TokenInfo(amount, false);\n', '    }\n', '    else\n', '    {\n', '      timeTable[addr][today].amount += amount;\n', '    }\n', '\n', '    //                  < 30.03.2018\n', '    if (block.timestamp < 1522357200 && bonuses[addr][today] == 0)\n', '    {\n', '      bonuses[addr][today] = 1;\n', '    }\n', '\n', '    balances[addr] = add(balances[addr], amount);\n', '    totalSupply = add(totalSupply, amount);\n', '    emit Transfer(0, addr, amount);\n', '  }\n', '\n', '  function calculateProfit (uint256 day) public constant returns(int256) \n', '  {\n', '    uint256 today = getToday();\n', '    assert(today >= day);\n', '    uint256 daysLeft = today - day;\n', '    int256 extraProfit = 0;\n', '\n', '    // is referral ?\n', '    if (referrals[msg.sender] != 0) extraProfit++;\n', '    // participant until March 30\n', '    if (bonuses[msg.sender][day] > 0) extraProfit++;\n', '\n', '    if (daysLeft <= 7) return -10;\n', '    if (daysLeft <= 14) return -5;\n', '    if (daysLeft <= 21) return 1 + extraProfit;\n', '    if (daysLeft <= 28) return 3 + extraProfit;\n', '    if (daysLeft <= 60) return 5 + extraProfit;\n', '    if (daysLeft <= 90) return 12 + extraProfit;\n', '    return 18 + extraProfit;  \n', '  }\n', '  \n', '  function getTokensPerDay(uint256 _day) public view returns (uint256)\n', '  {\n', '      return timeTable[msg.sender][_day].amount;\n', '  }\n', '\n', '  // returns amount, ether  \n', '  function getProfitForDay(uint256 day, uint256 amount) isEtherPriceUpdated public constant returns(uint256, uint256)\n', '  {      \n', '    assert (day <= getToday());\n', '    \n', '    uint256 tokenPrice = tokenPriceHistory[day];\n', '    if (timeTable[msg.sender][day].amount < amount) amount = timeTable[msg.sender][day].amount;    \n', '\n', '    assert (amount > 0);\n', '          \n', '    return (amount, amount * tokenPrice * uint256(100 + calculateProfit(day)) / 100 / etherPriceInDollarOut);\n', '  }\n', '\n', '  function returnTokensInPool (address[] addr, uint256[] _days) public\n', '  {\n', '    assert (addr.length == _days.length);\n', '    \n', '    TokenInfo storage info; \n', '    for(uint256 i = 0; i < addr.length;i++)\n', '    {\n', '      assert(_days[i] + 92 < getToday() && info.amount > 0);\n', '      info = timeTable[addr[i]][_days[i]];\n', '      info.isReturnedInPool = true;\n', '      availableTokens = add(availableTokens, info.amount);      \n', '    }\n', '  }\n', '\n', '  function getInfo(address addr, uint256 start, uint256 end) public constant returns (uint256[30] _days, uint256[30] _amounts, int256[30] _profits, uint256[30] _etherAmounts)\n', '  {\n', '      if (addr == 0) addr = msg.sender;\n', '\n', '      uint256 j = 0;\n', '      for(uint256 iDay = start; iDay < end; iDay++)\n', '      {\n', '        if (timeTable[addr][iDay].amount > 0)\n', '        {\n', '          _days[j] = iDay;\n', '          _profits[j] = calculateProfit(iDay);\n', '          _amounts[j] = timeTable[addr][iDay].amount;\n', '          (_amounts[j], _etherAmounts[j]) = getProfitForDay(iDay, _amounts[j]);\n', '          j++;\n', '          if (j == 30) break;\n', '        }\n', '      }\n', '  }\n', '  \n', '  function returnTokensForDay(uint256 day, uint256 userTokensAmount) public \n', '  {\n', '    uint256 tokensAmount;\n', '    uint256 etherAmount;\n', '    (tokensAmount, etherAmount) = getProfitForDay(day, userTokensAmount);\n', '\n', '    require(day > 0);\n', '    require(balances[msg.sender] >= tokensAmount);\n', '    \n', '    balances[msg.sender] = sub(balances[msg.sender], tokensAmount);\n', '    totalSupply = sub(totalSupply, tokensAmount);\n', '    timeTable[msg.sender][day].amount = sub(timeTable[msg.sender][day].amount, tokensAmount);\n', '    \n', '    if (!timeTable[msg.sender][day].isReturnedInPool)\n', '    {\n', '      availableTokens = add(availableTokens, tokensAmount);      \n', '    }\n', '\n', '    msg.sender.transfer(etherAmount);\n', '    emit Transfer(msg.sender, 0, tokensAmount);\n', '  }\n', '  \n', '}']
