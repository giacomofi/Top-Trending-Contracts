['pragma solidity ^0.4.25;\n', '\n', 'contract MajorityGameFactory {\n', '\n', '    address[] private deployedGames;\n', '    address[] private endedGames;\n', '\n', '    address private adminAddress;\n', '\n', '    mapping(address => uint) private gameAddressIdMap;\n', '\n', '    uint private gameCount = 320;\n', '    uint private endedGameCount = 0;\n', '\n', '    modifier adminOnly() {\n', '        require(msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    constructor () public {\n', '        adminAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * create new game\n', '     **/\n', '    function createGame (uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public adminOnly payable {\n', '        gameCount ++;\n', '        address newGameAddress = new MajorityGame(gameCount, _gameBet, _endTime, _questionText, _officialAddress);\n', '        deployedGames.push(newGameAddress);\n', '        gameAddressIdMap[newGameAddress] = deployedGames.length;\n', '\n', '        setJackpot(newGameAddress, msg.value);\n', '    }\n', '\n', '    /**\n', '     * return all available games address\n', '     **/\n', '    function getDeployedGames() public view returns (address[]) {\n', '        return deployedGames;\n', '    }\n', '\n', '    /**\n', '     * return all available games address\n', '     **/\n', '    function getEndedGames() public view returns (address[]) {\n', '        return endedGames;\n', '    }\n', '\n', '    /**\n', '     * set bonus of the game\n', '     **/\n', '    function setJackpot(address targetAddress, uint val) adminOnly public {\n', '        if (val > 0) {\n', '            MajorityGame mGame = MajorityGame(targetAddress);\n', '            mGame.setJackpot.value(val)();\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * player submit choose\n', '     **/\n', '    function submitChoose(address gameAddress, uint choose) public payable {\n', '        if (msg.value > 0) {\n', '            MajorityGame mGame = MajorityGame(gameAddress);\n', '            mGame.submitChooseByFactory.value(msg.value)(msg.sender, choose);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * end the game\n', '     **/\n', '    function endGame(address targetAddress) public {\n', '        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\n', '        endedGameCount++;\n', '        endedGames.push(targetAddress);\n', '        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\n', '\n', '        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\n', '\n', '        delete deployedGames[deployedGames.length-1];\n', '        deployedGames.length--;\n', '\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.endGame();\n', '    }\n', '\n', '    /**\n', '     * force to end the game\n', '     **/\n', '    function forceEndGame(address targetAddress) public adminOnly {\n', '        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\n', '        endedGameCount++;\n', '        endedGames.push(targetAddress);\n', '        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\n', '\n', '        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\n', '\n', '        delete deployedGames[deployedGames.length-1];\n', '        deployedGames.length--;\n', '\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.forceEndGame();\n', '    }\n', '    \n', '    /**\n', '     * selfdestruct\n', '     */\n', '    function destruct() public adminOnly{\n', '        selfdestruct(adminAddress);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * destruct a game\n', '     */\n', '    function destructGame(address targetAddress) public adminOnly{\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.destruct();\n', '    }\n', '}\n', '\n', '\n', 'contract MajorityGame {\n', '\n', '    uint private gameId;\n', '\n', '    uint private jackpot;\n', '    uint private gameBet;\n', '\n', '    // address of the creator\n', '    address private adminAddress;\n', '    address private officialAddress;\n', '\n', '    // game start time\n', '    uint private startTime;\n', '    uint private endTime;\n', '\n', '    // game data\n', '    string private questionText;\n', '\n', '    // store all player option record\n', '    mapping(address => bool) private option1List;\n', '    mapping(address => bool) private option2List;\n', '\n', '    // address list\n', '    address[] private option1AddressList;\n', '    address[] private option2AddressList;\n', '\n', '\t// award\n', '    uint private awardCounter;\n', '\n', '    address[] private first6AddresstList;\n', '    address private lastAddress;\n', '\n', '    uint private winnerSide;\n', '    uint private finalBalance;\n', '    uint private award;\n', '\n', '    modifier adminOnly() {\n', '        require(msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier withinGameTime() {\n', '\t\t    require(now >= startTime);\n', '        require(now <= endTime);\n', '        _;\n', '    }\n', '\n', '    modifier afterGameTime() {\n', '        require(now > endTime);\n', '        _;\n', '    }\n', '\n', '    modifier notEnded() {\n', '        require(winnerSide == 0);\n', '        _;\n', '    }\n', '\n', '    modifier isEnded() {\n', '        require(winnerSide > 0);\n', '        _;\n', '    }\n', '\n', '    modifier withinLimitPlayer() {\n', '        require((option1AddressList.length + option2AddressList.length) < 500);\n', '        _;\n', '    }\n', '\n', '    constructor(uint _gameId, uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public {\n', '        gameId = _gameId;\n', '        adminAddress = msg.sender;\n', '\n', '        gameBet = _gameBet;\n', '        startTime = _endTime - 25*60*60;\n', '        endTime = _endTime;\n', '        questionText = _questionText;\n', '\n', '        winnerSide = 0;\n', '        award = 0;\n', '\n', '        officialAddress = _officialAddress;\n', '    }\n', '\n', '    /**\n', '     * set the bonus of the game\n', '     **/\n', '    function setJackpot() public payable adminOnly returns (bool) {\n', '        if (msg.value > 0) {\n', '            jackpot += msg.value;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * return the game details:\n', '     * 0 game id\n', '     * 1 start time\n', '     * 2 end time\n', '     * 3 no of player\n', '     * 4 game balance\n', '     * 5 question + option 1 + option 2\n', '     * 6 jackpot\n', '     * 7 is ended game\n', '     * 8 game bet value\n', '     **/\n', '    function getGameData() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {\n', '\n', '        return (\n', '            gameId,\n', '            startTime,\n', '            endTime,\n', '            option1AddressList.length + option2AddressList.length,\n', '            address(this).balance,\n', '            questionText,\n', '            jackpot,\n', '            winnerSide,\n', '            gameBet\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * player submit their option\n', '     **/\n', '    function submitChooseByFactory(address playerAddress, uint _chooseValue) public payable adminOnly notEnded withinGameTime {\n', '        require(!option1List[playerAddress] && !option2List[playerAddress]);\n', '        require(msg.value == gameBet);\n', '\n', '        if (_chooseValue == 1) {\n', '            option1List[playerAddress] = true;\n', '            option1AddressList.push(playerAddress);\n', '        } else if (_chooseValue == 2) {\n', '            option2List[playerAddress] = true;\n', '            option2AddressList.push(playerAddress);\n', '        }\n', '\n', '        // add to first 6 player\n', '        if(option1AddressList.length + option2AddressList.length <= 6){\n', '            first6AddresstList.push(playerAddress);\n', '        }\n', '\n', '        // add to last player\n', '        lastAddress = playerAddress;\n', '    }\n', '\n', '\n', '    /**\n', '     * calculate the winner side\n', '     * calculate the award to winner\n', '     **/\n', '    function endGame() public afterGameTime {\n', '        require(winnerSide == 0);\n', '\n', '        finalBalance = address(this).balance;\n', '\n', '        // 10% for commision\n', '        uint totalAward = finalBalance * 9 / 10;\n', '\n', '        uint option1Count = uint(option1AddressList.length);\n', '        uint option2Count = uint(option2AddressList.length);\n', '\n', '        uint sumCount = option1Count + option2Count;\n', '\n', '        if(sumCount == 0 ){\n', '            award = 0;\n', '            awardCounter = 0;\n', '            if(gameId % 2 == 1){\n', '                winnerSide = 1;\n', '            }else{\n', '                winnerSide = 2;\n', '            }\n', '            return;\n', '        }else{\n', '            if (option1Count != 0 && sumCount / option1Count > 10) {\n', '\t\t\t\twinnerSide = 1;\n', '\t\t\t} else if (option2Count != 0 && sumCount / option2Count > 10) {\n', '\t\t\t\twinnerSide = 2;\n', '\t\t\t} else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\n', '\t\t\t\twinnerSide = 1;\n', '\t\t\t} else {\n', '\t\t\t\twinnerSide = 2;\n', '\t\t\t}\n', '        }\n', '\n', '        if (winnerSide == 1) {\n', '            award = uint(totalAward / option1Count);\n', '            awardCounter = option1Count;\n', '        } else {\n', '            award = uint(totalAward / option2Count);\n', '            awardCounter = option2Count;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * calculate the winner side\n', '     * calculate the award to winner\n', '     **/\n', '    function forceEndGame() public adminOnly {\n', '        require(winnerSide == 0);\n', '\n', '        finalBalance = address(this).balance;\n', '\n', '        // 10% for commision\n', '        uint totalAward = finalBalance * 9 / 10;\n', '\n', '        uint option1Count = uint(option1AddressList.length);\n', '        uint option2Count = uint(option2AddressList.length);\n', '\n', '        uint sumCount = option1Count + option2Count;\n', '\n', '        if(sumCount == 0 ){\n', '            award = 0;\n', '            awardCounter = 0;\n', '            if(gameId % 2 == 1){\n', '                winnerSide = 1;\n', '            }else{\n', '                winnerSide = 2;\n', '            }\n', '            return;\n', '        }\n', '\n', '        if (option1Count != 0 && sumCount / option1Count > 10) {\n', '            winnerSide = 1;\n', '        } else if (option2Count != 0 && sumCount / option2Count > 10) {\n', '            winnerSide = 2;\n', '        } else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\n', '            winnerSide = 1;\n', '        } else {\n', '            winnerSide = 2;\n', '        }\n', '\n', '        if (winnerSide == 1) {\n', '            award = uint(totalAward / option1Count);\n', '            awardCounter = option1Count;\n', '        } else {\n', '            award = uint(totalAward / option2Count);\n', '            awardCounter = option2Count;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * send award to winner\n', '     **/\n', '    function sendAward() public isEnded {\n', '        require(awardCounter > 0);\n', '\n', '        uint count = awardCounter;\n', '\n', '        if (awardCounter > 400) {\n', '            for (uint i = 0; i < 400; i++) {\n', '                this.sendAwardToLastOne();\n', '            }\n', '        } else {\n', '            for (uint j = 0; j < count; j++) {\n', '                this.sendAwardToLastOne();\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * send award to last winner of the list\n', '     **/\n', '    function sendAwardToLastOne() public isEnded {\n', '\t\trequire(awardCounter > 0);\n', '        if(winnerSide == 1){\n', '            address(option1AddressList[awardCounter - 1]).transfer(award);\n', '        }else{\n', '            address(option2AddressList[awardCounter - 1]).transfer(award);\n', '        }\n', '\n', '        awardCounter--;\n', '\n', '        if(awardCounter == 0){\n', '            if(option1AddressList.length + option2AddressList.length >= 7){\n', '                // send 0.5% of total bet to each first player\n', '                uint awardFirst6 = uint(finalBalance / 200);\n', '                for (uint k = 0; k < 6; k++) {\n', '                    address(first6AddresstList[k]).transfer(awardFirst6);\n', '                }\n', '                // send 2% of total bet to last player\n', '                address(lastAddress).transfer(uint(finalBalance / 50));\n', '            }\n', '\n', '            // send the rest of balance to officialAddress\n', '            address(officialAddress).transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * return the game details after ended\n', '     * 0 winner side\n', '     * 1 nomber of player who choose option 1\n', '     * 2 nomber of player who choose option 2\n', '     * 3 total award\n', '     * 4 award of each winner\n', '     **/\n', '    function getEndGameStatus() public isEnded view returns (uint, uint, uint, uint, uint) {\n', '        return (\n', '            winnerSide,\n', '            option1AddressList.length,\n', '            option2AddressList.length,\n', '            finalBalance,\n', '            award\n', '        );\n', '    }\n', '\n', '    /**\n', '    * get the option of the player choosed\n', '    **/\n', '    function getPlayerOption() public view returns (uint) {\n', '        if (option1List[msg.sender]) {\n', '            return 1;\n', '        } else if (option2List[msg.sender]) {\n', '            return 2;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * return the players who won the game\n', '     **/\n', '    function getWinnerAddressList() public isEnded view returns (address[]) {\n', '      if (winnerSide == 1) {\n', '        return option1AddressList;\n', '      }else {\n', '        return option2AddressList;\n', '      }\n', '    }\n', '\n', '    /**\n', '     * return the players who lose the game\n', '     **/\n', '    function getLoserAddressList() public isEnded view returns (address[]) {\n', '      if (winnerSide == 1) {\n', '        return option2AddressList;\n', '      }else {\n', '        return option1AddressList;\n', '      }\n', '    }\n', '    \n', '    /**\n', '     * selfdestruct\n', '     */\n', '    function destruct() public adminOnly{\n', '        selfdestruct(adminAddress);\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', 'contract MajorityGameFactory {\n', '\n', '    address[] private deployedGames;\n', '    address[] private endedGames;\n', '\n', '    address private adminAddress;\n', '\n', '    mapping(address => uint) private gameAddressIdMap;\n', '\n', '    uint private gameCount = 320;\n', '    uint private endedGameCount = 0;\n', '\n', '    modifier adminOnly() {\n', '        require(msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    constructor () public {\n', '        adminAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * create new game\n', '     **/\n', '    function createGame (uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public adminOnly payable {\n', '        gameCount ++;\n', '        address newGameAddress = new MajorityGame(gameCount, _gameBet, _endTime, _questionText, _officialAddress);\n', '        deployedGames.push(newGameAddress);\n', '        gameAddressIdMap[newGameAddress] = deployedGames.length;\n', '\n', '        setJackpot(newGameAddress, msg.value);\n', '    }\n', '\n', '    /**\n', '     * return all available games address\n', '     **/\n', '    function getDeployedGames() public view returns (address[]) {\n', '        return deployedGames;\n', '    }\n', '\n', '    /**\n', '     * return all available games address\n', '     **/\n', '    function getEndedGames() public view returns (address[]) {\n', '        return endedGames;\n', '    }\n', '\n', '    /**\n', '     * set bonus of the game\n', '     **/\n', '    function setJackpot(address targetAddress, uint val) adminOnly public {\n', '        if (val > 0) {\n', '            MajorityGame mGame = MajorityGame(targetAddress);\n', '            mGame.setJackpot.value(val)();\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * player submit choose\n', '     **/\n', '    function submitChoose(address gameAddress, uint choose) public payable {\n', '        if (msg.value > 0) {\n', '            MajorityGame mGame = MajorityGame(gameAddress);\n', '            mGame.submitChooseByFactory.value(msg.value)(msg.sender, choose);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * end the game\n', '     **/\n', '    function endGame(address targetAddress) public {\n', '        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\n', '        endedGameCount++;\n', '        endedGames.push(targetAddress);\n', '        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\n', '\n', '        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\n', '\n', '        delete deployedGames[deployedGames.length-1];\n', '        deployedGames.length--;\n', '\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.endGame();\n', '    }\n', '\n', '    /**\n', '     * force to end the game\n', '     **/\n', '    function forceEndGame(address targetAddress) public adminOnly {\n', '        uint targetGameIndex = gameAddressIdMap[address(targetAddress)];\n', '        endedGameCount++;\n', '        endedGames.push(targetAddress);\n', '        deployedGames[targetGameIndex-1] = deployedGames[deployedGames.length-1];\n', '\n', '        gameAddressIdMap[deployedGames[deployedGames.length-1]] = targetGameIndex;\n', '\n', '        delete deployedGames[deployedGames.length-1];\n', '        deployedGames.length--;\n', '\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.forceEndGame();\n', '    }\n', '    \n', '    /**\n', '     * selfdestruct\n', '     */\n', '    function destruct() public adminOnly{\n', '        selfdestruct(adminAddress);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * destruct a game\n', '     */\n', '    function destructGame(address targetAddress) public adminOnly{\n', '        MajorityGame mGame = MajorityGame(address(targetAddress));\n', '        mGame.destruct();\n', '    }\n', '}\n', '\n', '\n', 'contract MajorityGame {\n', '\n', '    uint private gameId;\n', '\n', '    uint private jackpot;\n', '    uint private gameBet;\n', '\n', '    // address of the creator\n', '    address private adminAddress;\n', '    address private officialAddress;\n', '\n', '    // game start time\n', '    uint private startTime;\n', '    uint private endTime;\n', '\n', '    // game data\n', '    string private questionText;\n', '\n', '    // store all player option record\n', '    mapping(address => bool) private option1List;\n', '    mapping(address => bool) private option2List;\n', '\n', '    // address list\n', '    address[] private option1AddressList;\n', '    address[] private option2AddressList;\n', '\n', '\t// award\n', '    uint private awardCounter;\n', '\n', '    address[] private first6AddresstList;\n', '    address private lastAddress;\n', '\n', '    uint private winnerSide;\n', '    uint private finalBalance;\n', '    uint private award;\n', '\n', '    modifier adminOnly() {\n', '        require(msg.sender == adminAddress);\n', '        _;\n', '    }\n', '\n', '    modifier withinGameTime() {\n', '\t\t    require(now >= startTime);\n', '        require(now <= endTime);\n', '        _;\n', '    }\n', '\n', '    modifier afterGameTime() {\n', '        require(now > endTime);\n', '        _;\n', '    }\n', '\n', '    modifier notEnded() {\n', '        require(winnerSide == 0);\n', '        _;\n', '    }\n', '\n', '    modifier isEnded() {\n', '        require(winnerSide > 0);\n', '        _;\n', '    }\n', '\n', '    modifier withinLimitPlayer() {\n', '        require((option1AddressList.length + option2AddressList.length) < 500);\n', '        _;\n', '    }\n', '\n', '    constructor(uint _gameId, uint _gameBet, uint _endTime, string _questionText, address _officialAddress) public {\n', '        gameId = _gameId;\n', '        adminAddress = msg.sender;\n', '\n', '        gameBet = _gameBet;\n', '        startTime = _endTime - 25*60*60;\n', '        endTime = _endTime;\n', '        questionText = _questionText;\n', '\n', '        winnerSide = 0;\n', '        award = 0;\n', '\n', '        officialAddress = _officialAddress;\n', '    }\n', '\n', '    /**\n', '     * set the bonus of the game\n', '     **/\n', '    function setJackpot() public payable adminOnly returns (bool) {\n', '        if (msg.value > 0) {\n', '            jackpot += msg.value;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * return the game details:\n', '     * 0 game id\n', '     * 1 start time\n', '     * 2 end time\n', '     * 3 no of player\n', '     * 4 game balance\n', '     * 5 question + option 1 + option 2\n', '     * 6 jackpot\n', '     * 7 is ended game\n', '     * 8 game bet value\n', '     **/\n', '    function getGameData() public view returns (uint, uint, uint, uint, uint, string, uint, uint, uint) {\n', '\n', '        return (\n', '            gameId,\n', '            startTime,\n', '            endTime,\n', '            option1AddressList.length + option2AddressList.length,\n', '            address(this).balance,\n', '            questionText,\n', '            jackpot,\n', '            winnerSide,\n', '            gameBet\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * player submit their option\n', '     **/\n', '    function submitChooseByFactory(address playerAddress, uint _chooseValue) public payable adminOnly notEnded withinGameTime {\n', '        require(!option1List[playerAddress] && !option2List[playerAddress]);\n', '        require(msg.value == gameBet);\n', '\n', '        if (_chooseValue == 1) {\n', '            option1List[playerAddress] = true;\n', '            option1AddressList.push(playerAddress);\n', '        } else if (_chooseValue == 2) {\n', '            option2List[playerAddress] = true;\n', '            option2AddressList.push(playerAddress);\n', '        }\n', '\n', '        // add to first 6 player\n', '        if(option1AddressList.length + option2AddressList.length <= 6){\n', '            first6AddresstList.push(playerAddress);\n', '        }\n', '\n', '        // add to last player\n', '        lastAddress = playerAddress;\n', '    }\n', '\n', '\n', '    /**\n', '     * calculate the winner side\n', '     * calculate the award to winner\n', '     **/\n', '    function endGame() public afterGameTime {\n', '        require(winnerSide == 0);\n', '\n', '        finalBalance = address(this).balance;\n', '\n', '        // 10% for commision\n', '        uint totalAward = finalBalance * 9 / 10;\n', '\n', '        uint option1Count = uint(option1AddressList.length);\n', '        uint option2Count = uint(option2AddressList.length);\n', '\n', '        uint sumCount = option1Count + option2Count;\n', '\n', '        if(sumCount == 0 ){\n', '            award = 0;\n', '            awardCounter = 0;\n', '            if(gameId % 2 == 1){\n', '                winnerSide = 1;\n', '            }else{\n', '                winnerSide = 2;\n', '            }\n', '            return;\n', '        }else{\n', '            if (option1Count != 0 && sumCount / option1Count > 10) {\n', '\t\t\t\twinnerSide = 1;\n', '\t\t\t} else if (option2Count != 0 && sumCount / option2Count > 10) {\n', '\t\t\t\twinnerSide = 2;\n', '\t\t\t} else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\n', '\t\t\t\twinnerSide = 1;\n', '\t\t\t} else {\n', '\t\t\t\twinnerSide = 2;\n', '\t\t\t}\n', '        }\n', '\n', '        if (winnerSide == 1) {\n', '            award = uint(totalAward / option1Count);\n', '            awardCounter = option1Count;\n', '        } else {\n', '            award = uint(totalAward / option2Count);\n', '            awardCounter = option2Count;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * calculate the winner side\n', '     * calculate the award to winner\n', '     **/\n', '    function forceEndGame() public adminOnly {\n', '        require(winnerSide == 0);\n', '\n', '        finalBalance = address(this).balance;\n', '\n', '        // 10% for commision\n', '        uint totalAward = finalBalance * 9 / 10;\n', '\n', '        uint option1Count = uint(option1AddressList.length);\n', '        uint option2Count = uint(option2AddressList.length);\n', '\n', '        uint sumCount = option1Count + option2Count;\n', '\n', '        if(sumCount == 0 ){\n', '            award = 0;\n', '            awardCounter = 0;\n', '            if(gameId % 2 == 1){\n', '                winnerSide = 1;\n', '            }else{\n', '                winnerSide = 2;\n', '            }\n', '            return;\n', '        }\n', '\n', '        if (option1Count != 0 && sumCount / option1Count > 10) {\n', '            winnerSide = 1;\n', '        } else if (option2Count != 0 && sumCount / option2Count > 10) {\n', '            winnerSide = 2;\n', '        } else if (option1Count > option2Count || (option1Count == option2Count && gameId % 2 == 1)) {\n', '            winnerSide = 1;\n', '        } else {\n', '            winnerSide = 2;\n', '        }\n', '\n', '        if (winnerSide == 1) {\n', '            award = uint(totalAward / option1Count);\n', '            awardCounter = option1Count;\n', '        } else {\n', '            award = uint(totalAward / option2Count);\n', '            awardCounter = option2Count;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * send award to winner\n', '     **/\n', '    function sendAward() public isEnded {\n', '        require(awardCounter > 0);\n', '\n', '        uint count = awardCounter;\n', '\n', '        if (awardCounter > 400) {\n', '            for (uint i = 0; i < 400; i++) {\n', '                this.sendAwardToLastOne();\n', '            }\n', '        } else {\n', '            for (uint j = 0; j < count; j++) {\n', '                this.sendAwardToLastOne();\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * send award to last winner of the list\n', '     **/\n', '    function sendAwardToLastOne() public isEnded {\n', '\t\trequire(awardCounter > 0);\n', '        if(winnerSide == 1){\n', '            address(option1AddressList[awardCounter - 1]).transfer(award);\n', '        }else{\n', '            address(option2AddressList[awardCounter - 1]).transfer(award);\n', '        }\n', '\n', '        awardCounter--;\n', '\n', '        if(awardCounter == 0){\n', '            if(option1AddressList.length + option2AddressList.length >= 7){\n', '                // send 0.5% of total bet to each first player\n', '                uint awardFirst6 = uint(finalBalance / 200);\n', '                for (uint k = 0; k < 6; k++) {\n', '                    address(first6AddresstList[k]).transfer(awardFirst6);\n', '                }\n', '                // send 2% of total bet to last player\n', '                address(lastAddress).transfer(uint(finalBalance / 50));\n', '            }\n', '\n', '            // send the rest of balance to officialAddress\n', '            address(officialAddress).transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * return the game details after ended\n', '     * 0 winner side\n', '     * 1 nomber of player who choose option 1\n', '     * 2 nomber of player who choose option 2\n', '     * 3 total award\n', '     * 4 award of each winner\n', '     **/\n', '    function getEndGameStatus() public isEnded view returns (uint, uint, uint, uint, uint) {\n', '        return (\n', '            winnerSide,\n', '            option1AddressList.length,\n', '            option2AddressList.length,\n', '            finalBalance,\n', '            award\n', '        );\n', '    }\n', '\n', '    /**\n', '    * get the option of the player choosed\n', '    **/\n', '    function getPlayerOption() public view returns (uint) {\n', '        if (option1List[msg.sender]) {\n', '            return 1;\n', '        } else if (option2List[msg.sender]) {\n', '            return 2;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * return the players who won the game\n', '     **/\n', '    function getWinnerAddressList() public isEnded view returns (address[]) {\n', '      if (winnerSide == 1) {\n', '        return option1AddressList;\n', '      }else {\n', '        return option2AddressList;\n', '      }\n', '    }\n', '\n', '    /**\n', '     * return the players who lose the game\n', '     **/\n', '    function getLoserAddressList() public isEnded view returns (address[]) {\n', '      if (winnerSide == 1) {\n', '        return option2AddressList;\n', '      }else {\n', '        return option1AddressList;\n', '      }\n', '    }\n', '    \n', '    /**\n', '     * selfdestruct\n', '     */\n', '    function destruct() public adminOnly{\n', '        selfdestruct(adminAddress);\n', '    }\n', '}']
