['pragma solidity ^0.4.19;\n', '\n', 'contract StandardToken {\n', '    function balanceOf(address _owner) constant public returns (uint256);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface Token { \n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function totalSupply() constant public returns (uint256 supply);\n', '    function balanceOf(address _owner) constant public returns (uint256 balance);\n', '}\n', '\n', 'contract CslTokenDistribution {\n', '    \n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) balances;\n', '    Token public cslToken;\n', '    address public owner;\n', '    uint256 public decimals = 10e17;      //token decimals\n', '    uint256 public value = 50000;         //50000 tokens for 1 ETH\n', '    uint256 public bonus = 5000;          //5000 tokens for 1 ETH\n', '    uint256 public drop;                  //tokens for airdrop\n', '    bool public contractLocked = true;    //crowdsale locked\n', '    bool public bonusTime = true;         //bonus true for early investors\n', '    \n', '    event sendTokens(address indexed to, uint256 value);\n', '    event Locked();\n', '    event Unlocked();\n', '    event Bonustimer();\n', '    event NoBonustimer();\n', '\n', '    function CslTokenDistribution(address _tokenAddress, address _owner) public {\n', '        cslToken = Token(_tokenAddress);\n', '        owner = _owner;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '        owner = newOwner;\n', '        }\n', '    }\n', '    \n', '    function setAirdrop(uint256 _Drop) onlyOwner public {\n', '        drop = _Drop;\n', '    }\n', '    \n', '    function setCrowdsale(uint256 _value, uint256 _bonus) onlyOwner public {\n', '        value = _value;\n', '        bonus = _bonus;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '    \n', '    modifier isUnlocked() {\n', '        require(!contractLocked);\n', '        _;\n', '    }\n', '    \n', '    function lockContract() onlyOwner public returns (bool) {\n', '        contractLocked = true;\n', '        Locked();\n', '        return true;\n', '    }\n', '    \n', '    function unlockContract() onlyOwner public returns (bool) {\n', '        contractLocked = false;\n', '        Unlocked();\n', '        return false;\n', '    }\n', '    \n', '    function bonusOn() onlyOwner public returns (bool) {\n', '        bonusTime = true;\n', '        Bonustimer();\n', '        return true;\n', '    }\n', '    \n', '    function bonusOff() onlyOwner public returns (bool) {\n', '        bonusTime = false;\n', '        NoBonustimer();\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _holder) constant public returns (uint256 balance) {\n', '        return balances[_holder];\n', '    }\n', '    \n', '    function getTokenBalance(address who) constant public returns (uint){\n', '        uint bal = cslToken.balanceOf(who);\n', '        return bal;\n', '    }\n', '    \n', '    function getEthBalance(address _addr) constant public returns(uint) {\n', '        return _addr.balance;\n', '    }\n', '    \n', '    function airdrop(address[] addresses) onlyOwner public {\n', '        \n', '        require(addresses.length <= 255);\n', '        \n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            sendTokens(addresses[i], drop);\n', '            cslToken.transfer(addresses[i], drop);\n', '        }\n', '\t\n', '    }\n', '    \n', '    function distribution(address[] addresses, uint256 amount) onlyOwner public {\n', '        \n', '        require(addresses.length <= 255);\n', '\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            sendTokens(addresses[i], amount);\n', '            cslToken.transfer(addresses[i], amount);\n', '        }\n', '\n', '    }\n', '    \n', '    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n', '\n', '        require(addresses.length <= 255);\n', '        require(addresses.length == amounts.length);\n', '        \n', '        for (uint8 i = 0; i < addresses.length; i++) {\n', '            sendTokens(addresses[i], amounts[i]);\n', '            cslToken.transfer(addresses[i], amounts[i]);\n', '        }\n', '        \n', '    }\n', '    \n', '    function () external payable {\n', '            getTokens();\n', '    }\n', '    \n', '    function getTokens() payable isUnlocked public {\n', '        address investor = msg.sender;\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens = weiAmount.mul(value);\n', '        \n', '        if (msg.value == 0) { return; }\n', '        if (bonusTime == true) {\n', '            uint256 bonusTokens = weiAmount.mul(bonus);\n', '            tokens = tokens.add(bonusTokens);\n', '        }\n', '        \n', '        sendTokens(investor, tokens);\n', '        cslToken.transfer(investor, tokens);\n', '    \n', '    }\n', '    \n', '    function tokensAvailable() constant public returns (uint256) {\n', '        return cslToken.balanceOf(this);\n', '    }\n', '    \n', '    function withdraw() onlyOwner public {\n', '        uint256 etherBalance = this.balance;\n', '        owner.transfer(etherBalance);\n', '    }\n', '    \n', '    function withdrawStandardTokens(address _tokenContract) onlyOwner public returns (bool) {\n', '        StandardToken token = StandardToken(_tokenContract);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        return token.transfer(owner, amount);\n', '    }\n', '\n', '}']