['pragma solidity ^0.4.23;\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', 'contract PreSale is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) public unconfirmedMap;\n', '    mapping(address => uint256) public confirmedMap;\n', '    mapping(address => address) public holderReferrer;\n', '    mapping(address => uint256) public holdersOrder;\n', '    address[] public holders;\n', '    uint256 public holdersCount;\n', '    mapping(address => uint256) public bonusMap;\n', '    mapping(address => uint256) public topMap;\n', '    uint256 public confirmedAmount;\n', '    uint256 public bonusAmount;\n', '    uint256 lastOf10 = 0;\n', '    uint256 lastOf15 = 0;\n', '    mapping(address => bool) _isConfirmed;\n', '    uint256 public totalSupply;\n', '    uint256 REF_BONUS_PERCENT = 50;\n', '    uint256 MIN_AMOUNT = 9 * 10e15;\n', '    uint256 OPERATIONS_FEE = 10e15;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    //48 hours\n', '    uint256 public confirmTime = 48 * 3600;\n', '    bool internal _isGoalReached = false;\n', '    ERC20 token;\n', '    constructor(\n', '        uint256 _totalSupply,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        ERC20 _token\n', '    ) public {\n', '        require(_startTime >= now);\n', '        require(_startTime < _endTime);\n', '        totalSupply = _totalSupply;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        token = _token;\n', '    }\n', '    modifier pending() {\n', '        require(now >= startTime && now < endTime);\n', '        _;\n', '    }\n', '    modifier isAbleConfirmation() {\n', '        require(now >= startTime && now < endTime + confirmTime);\n', '        _;\n', '    }\n', '    modifier hasClosed() {\n', '        require(now >= endTime + confirmTime);\n', '        _;\n', '    }\n', '    modifier isGoalReached() {\n', '        require(_isGoalReached);\n', '        _;\n', '    }\n', '    modifier onlyConfirmed() {\n', '        require(_isConfirmed[msg.sender]);\n', '        _;\n', '    }\n', '    function() payable public pending {\n', '        _buyTokens(msg.sender, msg.value);\n', '    }\n', '    function buyTokens(address holder) payable public pending {\n', '        _buyTokens(holder, msg.value);\n', '    }\n', '    function buyTokensByReferrer(address holder, address referrer) payable public pending {\n', '        if (_canSetReferrer(holder, referrer)) {\n', '            _setReferrer(holder, referrer);\n', '        }\n', '        uint256 amount = msg.value - OPERATIONS_FEE;\n', '        holder.transfer(OPERATIONS_FEE);\n', '        _buyTokens(holder, amount);\n', '    }\n', '    function _buyTokens(address holder, uint256 amount) private {\n', '        require(amount >= MIN_AMOUNT);\n', '        if (_isConfirmed[holder]) {\n', '            confirmedMap[holder] = confirmedMap[holder].add(amount);\n', '            confirmedAmount = confirmedAmount.add(amount);\n', '        } else {\n', '            unconfirmedMap[holder] = unconfirmedMap[holder].add(amount);\n', '        }\n', '        if (holdersOrder[holder] == 0) {\n', '            holders.push(holder);\n', '            holdersOrder[holder] = holders.length;\n', '            holdersCount++;\n', '        }\n', '        _addBonus(holder, amount);\n', '    }\n', '    function _addBonus(address holder, uint256 amount) internal {\n', '        _addBonusOfTop(holder, amount);\n', '        _topBonus();\n', '        _addBonusOfReferrer(holder, amount);\n', '    }\n', '    function _addBonusOfTop(address holder, uint256 amount) internal {\n', '        uint256 bonusOf = 0;\n', '        if (holdersOrder[holder] <= holdersCount.div(10)) {\n', '            bonusOf = amount.div(10);\n', '        } else if (holdersOrder[holder] <= holdersCount.mul(15).div(100)) {\n', '            bonusOf = amount.mul(5).div(100);\n', '        }\n', '        if (bonusOf == 0) {\n', '            return;\n', '        }\n', '        topMap[holder] = topMap[holder].add(bonusOf);\n', '        if (_isConfirmed[holder]) {\n', '            bonusAmount = bonusAmount.add(bonusOf);\n', '        }\n', '    }\n', '    function _topBonus() internal {\n', '        uint256 bonusFor = 0;\n', '        address holder;\n', '        uint256 currentAmount;\n', '        if (lastOf10 < holdersCount.div(10)) {\n', '            holder = holders[lastOf10++];\n', '            currentAmount = _isConfirmed[holder] ? confirmedMap[holder] : unconfirmedMap[holder];\n', '            bonusFor = currentAmount.div(10);\n', '        } else if (lastOf15 < holdersCount.mul(15).div(100)) {\n', '            holder = holders[lastOf15++];\n', '            currentAmount = _isConfirmed[holder] ? confirmedMap[holder] : unconfirmedMap[holder];\n', '            bonusFor = currentAmount.div(20);\n', '        } else {\n', '            return;\n', '        }\n', '        if (bonusFor <= topMap[holder]) {\n', '            return;\n', '        }\n', '        if (_isConfirmed[holder]) {\n', '            uint256 diff = bonusFor - topMap[holder];\n', '            bonusAmount = bonusAmount.add(diff);\n', '        }\n', '        topMap[holder] = bonusFor;\n', '    }\n', '    function _addBonusOfReferrer(address holder, uint256 amount) internal {\n', '        if (holderReferrer[holder] == 0x0) {\n', '            return;\n', '        }\n', '        address referrer = holderReferrer[holder];\n', '        uint256 bonus = amount.div(2);\n', '        bonusMap[holder] = bonusMap[holder].add(bonus);\n', '        bonusMap[referrer] = bonusMap[referrer].add(bonus);\n', '        if (_isConfirmed[holder]) {\n', '            bonusAmount = bonusAmount.add(bonus);\n', '        }\n', '        if (_isConfirmed[referrer]) {\n', '            bonusAmount = bonusAmount.add(bonus);\n', '        }\n', '    }\n', '    function _canSetReferrer(address holder, address referrer) view private returns (bool) {\n', '        return holderReferrer[holder] == 0x0\n', '        && holder != referrer\n', '        && referrer != 0x0\n', '        && holderReferrer[referrer] != holder;\n', '    }\n', '    function _setReferrer(address holder, address referrer) private {\n', '        holderReferrer[holder] = referrer;\n', '        if (_isConfirmed[holder]) {\n', '            _addBonusOfReferrer(holder, confirmedMap[holder]);\n', '        } else {\n', '            _addBonusOfReferrer(holder, unconfirmedMap[holder]);\n', '        }\n', '    }\n', '    function setReferrer(address referrer) public pending {\n', '        require(_canSetReferrer(msg.sender, referrer));\n', '        _setReferrer(msg.sender, referrer);\n', '    }\n', '    function _confirm(address holder) private {\n', '        confirmedMap[holder] = unconfirmedMap[holder];\n', '        unconfirmedMap[holder] = 0;\n', '        confirmedAmount = confirmedAmount.add(confirmedMap[holder]);\n', '        bonusAmount = bonusAmount.add(bonusMap[holder]).add(topMap[holder]);\n', '        _isConfirmed[holder] = true;\n', '    }\n', '    function isConfirmed(address holder) public view returns (bool) {\n', '        return _isConfirmed[holder];\n', '    }\n', '    function getTokens() public hasClosed isGoalReached onlyConfirmed returns (uint256) {\n', '        uint256 tokens = calculateTokens(msg.sender);\n', '        require(tokens > 0);\n', '        confirmedMap[msg.sender] = 0;\n', '        bonusMap[msg.sender] = 0;\n', '        topMap[msg.sender] = 0;\n', '        require(token.transfer(msg.sender, tokens));\n', '    }\n', '    function getRefund() public hasClosed {\n', '        address holder = msg.sender;\n', '        uint256 funds = 0;\n', '        if (_isConfirmed[holder]) {\n', '            require(_isGoalReached == false);\n', '            funds = confirmedMap[holder];\n', '            require(funds > 0);\n', '            confirmedMap[holder] = 0;\n', '        } else {\n', '            funds = unconfirmedMap[holder];\n', '            require(funds > 0);\n', '            unconfirmedMap[holder] = 0;\n', '        }\n', '        holder.transfer(funds);\n', '    }\n', '    function calculateTokens(address holder) public view returns (uint256) {\n', '        return totalSupply.mul(calculateHolderPiece(holder)).div(calculatePie());\n', '    }\n', '    function calculatePie() public view returns (uint256) {\n', '        return confirmedAmount.add(bonusAmount);\n', '    }\n', '    function getCurrentPrice() public view returns (uint256) {\n', '        return calculatePie().div(totalSupply);\n', '    }\n', '    function calculateHolderPiece(address holder) public view returns (uint256){\n', '        return confirmedMap[holder].add(bonusMap[holder]).add(topMap[holder]);\n', '    }\n', '    //***** admin ***\n', '    function confirm(address holder) public isAbleConfirmation onlyOwner {\n', '        require(!_isConfirmed[holder]);\n', '        _confirm(holder);\n', '    }\n', '    function confirmBatch(address[] _holders) public isAbleConfirmation onlyOwner {\n', '        for (uint i = 0; i < _holders.length; i++) {\n', '            if (!_isConfirmed[_holders[i]]) {\n', '                _confirm(_holders[i]);\n', '            }\n', '        }\n', '    }\n', '    function setReached(bool _isIt) public onlyOwner isAbleConfirmation {\n', '        _isGoalReached = _isIt;\n', '        if (!_isIt) {\n', '            token.transfer(owner, totalSupply);\n', '        }\n', '    }\n', '    function getRaised() public hasClosed isGoalReached onlyOwner {\n', '        owner.transfer(confirmedAmount);\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', 'contract PreSale is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) public unconfirmedMap;\n', '    mapping(address => uint256) public confirmedMap;\n', '    mapping(address => address) public holderReferrer;\n', '    mapping(address => uint256) public holdersOrder;\n', '    address[] public holders;\n', '    uint256 public holdersCount;\n', '    mapping(address => uint256) public bonusMap;\n', '    mapping(address => uint256) public topMap;\n', '    uint256 public confirmedAmount;\n', '    uint256 public bonusAmount;\n', '    uint256 lastOf10 = 0;\n', '    uint256 lastOf15 = 0;\n', '    mapping(address => bool) _isConfirmed;\n', '    uint256 public totalSupply;\n', '    uint256 REF_BONUS_PERCENT = 50;\n', '    uint256 MIN_AMOUNT = 9 * 10e15;\n', '    uint256 OPERATIONS_FEE = 10e15;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    //48 hours\n', '    uint256 public confirmTime = 48 * 3600;\n', '    bool internal _isGoalReached = false;\n', '    ERC20 token;\n', '    constructor(\n', '        uint256 _totalSupply,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        ERC20 _token\n', '    ) public {\n', '        require(_startTime >= now);\n', '        require(_startTime < _endTime);\n', '        totalSupply = _totalSupply;\n', '        startTime = _startTime;\n', '        endTime = _endTime;\n', '        token = _token;\n', '    }\n', '    modifier pending() {\n', '        require(now >= startTime && now < endTime);\n', '        _;\n', '    }\n', '    modifier isAbleConfirmation() {\n', '        require(now >= startTime && now < endTime + confirmTime);\n', '        _;\n', '    }\n', '    modifier hasClosed() {\n', '        require(now >= endTime + confirmTime);\n', '        _;\n', '    }\n', '    modifier isGoalReached() {\n', '        require(_isGoalReached);\n', '        _;\n', '    }\n', '    modifier onlyConfirmed() {\n', '        require(_isConfirmed[msg.sender]);\n', '        _;\n', '    }\n', '    function() payable public pending {\n', '        _buyTokens(msg.sender, msg.value);\n', '    }\n', '    function buyTokens(address holder) payable public pending {\n', '        _buyTokens(holder, msg.value);\n', '    }\n', '    function buyTokensByReferrer(address holder, address referrer) payable public pending {\n', '        if (_canSetReferrer(holder, referrer)) {\n', '            _setReferrer(holder, referrer);\n', '        }\n', '        uint256 amount = msg.value - OPERATIONS_FEE;\n', '        holder.transfer(OPERATIONS_FEE);\n', '        _buyTokens(holder, amount);\n', '    }\n', '    function _buyTokens(address holder, uint256 amount) private {\n', '        require(amount >= MIN_AMOUNT);\n', '        if (_isConfirmed[holder]) {\n', '            confirmedMap[holder] = confirmedMap[holder].add(amount);\n', '            confirmedAmount = confirmedAmount.add(amount);\n', '        } else {\n', '            unconfirmedMap[holder] = unconfirmedMap[holder].add(amount);\n', '        }\n', '        if (holdersOrder[holder] == 0) {\n', '            holders.push(holder);\n', '            holdersOrder[holder] = holders.length;\n', '            holdersCount++;\n', '        }\n', '        _addBonus(holder, amount);\n', '    }\n', '    function _addBonus(address holder, uint256 amount) internal {\n', '        _addBonusOfTop(holder, amount);\n', '        _topBonus();\n', '        _addBonusOfReferrer(holder, amount);\n', '    }\n', '    function _addBonusOfTop(address holder, uint256 amount) internal {\n', '        uint256 bonusOf = 0;\n', '        if (holdersOrder[holder] <= holdersCount.div(10)) {\n', '            bonusOf = amount.div(10);\n', '        } else if (holdersOrder[holder] <= holdersCount.mul(15).div(100)) {\n', '            bonusOf = amount.mul(5).div(100);\n', '        }\n', '        if (bonusOf == 0) {\n', '            return;\n', '        }\n', '        topMap[holder] = topMap[holder].add(bonusOf);\n', '        if (_isConfirmed[holder]) {\n', '            bonusAmount = bonusAmount.add(bonusOf);\n', '        }\n', '    }\n', '    function _topBonus() internal {\n', '        uint256 bonusFor = 0;\n', '        address holder;\n', '        uint256 currentAmount;\n', '        if (lastOf10 < holdersCount.div(10)) {\n', '            holder = holders[lastOf10++];\n', '            currentAmount = _isConfirmed[holder] ? confirmedMap[holder] : unconfirmedMap[holder];\n', '            bonusFor = currentAmount.div(10);\n', '        } else if (lastOf15 < holdersCount.mul(15).div(100)) {\n', '            holder = holders[lastOf15++];\n', '            currentAmount = _isConfirmed[holder] ? confirmedMap[holder] : unconfirmedMap[holder];\n', '            bonusFor = currentAmount.div(20);\n', '        } else {\n', '            return;\n', '        }\n', '        if (bonusFor <= topMap[holder]) {\n', '            return;\n', '        }\n', '        if (_isConfirmed[holder]) {\n', '            uint256 diff = bonusFor - topMap[holder];\n', '            bonusAmount = bonusAmount.add(diff);\n', '        }\n', '        topMap[holder] = bonusFor;\n', '    }\n', '    function _addBonusOfReferrer(address holder, uint256 amount) internal {\n', '        if (holderReferrer[holder] == 0x0) {\n', '            return;\n', '        }\n', '        address referrer = holderReferrer[holder];\n', '        uint256 bonus = amount.div(2);\n', '        bonusMap[holder] = bonusMap[holder].add(bonus);\n', '        bonusMap[referrer] = bonusMap[referrer].add(bonus);\n', '        if (_isConfirmed[holder]) {\n', '            bonusAmount = bonusAmount.add(bonus);\n', '        }\n', '        if (_isConfirmed[referrer]) {\n', '            bonusAmount = bonusAmount.add(bonus);\n', '        }\n', '    }\n', '    function _canSetReferrer(address holder, address referrer) view private returns (bool) {\n', '        return holderReferrer[holder] == 0x0\n', '        && holder != referrer\n', '        && referrer != 0x0\n', '        && holderReferrer[referrer] != holder;\n', '    }\n', '    function _setReferrer(address holder, address referrer) private {\n', '        holderReferrer[holder] = referrer;\n', '        if (_isConfirmed[holder]) {\n', '            _addBonusOfReferrer(holder, confirmedMap[holder]);\n', '        } else {\n', '            _addBonusOfReferrer(holder, unconfirmedMap[holder]);\n', '        }\n', '    }\n', '    function setReferrer(address referrer) public pending {\n', '        require(_canSetReferrer(msg.sender, referrer));\n', '        _setReferrer(msg.sender, referrer);\n', '    }\n', '    function _confirm(address holder) private {\n', '        confirmedMap[holder] = unconfirmedMap[holder];\n', '        unconfirmedMap[holder] = 0;\n', '        confirmedAmount = confirmedAmount.add(confirmedMap[holder]);\n', '        bonusAmount = bonusAmount.add(bonusMap[holder]).add(topMap[holder]);\n', '        _isConfirmed[holder] = true;\n', '    }\n', '    function isConfirmed(address holder) public view returns (bool) {\n', '        return _isConfirmed[holder];\n', '    }\n', '    function getTokens() public hasClosed isGoalReached onlyConfirmed returns (uint256) {\n', '        uint256 tokens = calculateTokens(msg.sender);\n', '        require(tokens > 0);\n', '        confirmedMap[msg.sender] = 0;\n', '        bonusMap[msg.sender] = 0;\n', '        topMap[msg.sender] = 0;\n', '        require(token.transfer(msg.sender, tokens));\n', '    }\n', '    function getRefund() public hasClosed {\n', '        address holder = msg.sender;\n', '        uint256 funds = 0;\n', '        if (_isConfirmed[holder]) {\n', '            require(_isGoalReached == false);\n', '            funds = confirmedMap[holder];\n', '            require(funds > 0);\n', '            confirmedMap[holder] = 0;\n', '        } else {\n', '            funds = unconfirmedMap[holder];\n', '            require(funds > 0);\n', '            unconfirmedMap[holder] = 0;\n', '        }\n', '        holder.transfer(funds);\n', '    }\n', '    function calculateTokens(address holder) public view returns (uint256) {\n', '        return totalSupply.mul(calculateHolderPiece(holder)).div(calculatePie());\n', '    }\n', '    function calculatePie() public view returns (uint256) {\n', '        return confirmedAmount.add(bonusAmount);\n', '    }\n', '    function getCurrentPrice() public view returns (uint256) {\n', '        return calculatePie().div(totalSupply);\n', '    }\n', '    function calculateHolderPiece(address holder) public view returns (uint256){\n', '        return confirmedMap[holder].add(bonusMap[holder]).add(topMap[holder]);\n', '    }\n', '    //***** admin ***\n', '    function confirm(address holder) public isAbleConfirmation onlyOwner {\n', '        require(!_isConfirmed[holder]);\n', '        _confirm(holder);\n', '    }\n', '    function confirmBatch(address[] _holders) public isAbleConfirmation onlyOwner {\n', '        for (uint i = 0; i < _holders.length; i++) {\n', '            if (!_isConfirmed[_holders[i]]) {\n', '                _confirm(_holders[i]);\n', '            }\n', '        }\n', '    }\n', '    function setReached(bool _isIt) public onlyOwner isAbleConfirmation {\n', '        _isGoalReached = _isIt;\n', '        if (!_isIt) {\n', '            token.transfer(owner, totalSupply);\n', '        }\n', '    }\n', '    function getRaised() public hasClosed isGoalReached onlyOwner {\n', '        owner.transfer(confirmedAmount);\n', '    }\n', '}']
