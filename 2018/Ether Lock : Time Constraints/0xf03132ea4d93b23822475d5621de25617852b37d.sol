['pragma solidity ^0.4.18;\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/TokenVesting.sol\n', '\n', '/**\n', ' * @title Vesting contract for SDT\n', ' * @dev see https://send.sd/token\n', ' */\n', 'contract TokenVesting is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  address public ico;\n', '  bool public initialized;\n', '  bool public active;\n', '  ERC20Basic public token;\n', '  mapping (address => TokenGrant[]) public grants;\n', '\n', '  uint256 public circulatingSupply = 0;\n', '\n', '  struct TokenGrant {\n', '    uint256 value;\n', '    uint256 claimed;\n', '    uint256 vesting;\n', '    uint256 start;\n', '  }\n', '\n', '  event NewTokenGrant (\n', '    address indexed to,\n', '    uint256 value,\n', '    uint256 start,\n', '    uint256 vesting\n', '  );\n', '\n', '  event NewTokenClaim (\n', '    address indexed holder,\n', '    uint256 value\n', '  );\n', '\n', '  modifier icoResticted() {\n', '    require(msg.sender == ico);\n', '    _;\n', '  }\n', '\n', '  modifier isActive() {\n', '    require(active);\n', '    _;\n', '  }\n', '\n', '  function TokenVesting() public {\n', '    active = false;\n', '  }\n', '\n', '  function init(address _token, address _ico) public onlyOwner {\n', '    token = ERC20Basic(_token);\n', '    ico = _ico;\n', '    initialized = true;\n', '    active = true;\n', '  }\n', '\n', '  function stop() public isActive onlyOwner {\n', '    active = false;\n', '  }\n', '\n', '  function resume() public onlyOwner {\n', '    require(!active);\n', '    require(initialized);\n', '    active = true;\n', '  }\n', '\n', '  /**\n', '  * @dev Grant vested tokens.\n', '  * @notice Only for ICO contract address.\n', '  * @param _to Addres to grant tokens to.\n', '  * @param _value Number of tokens granted.\n', '  * @param _vesting Vesting finish timestamp.\n', '  * @param _start Vesting start timestamp.\n', '  */\n', '  function grantVestedTokens(\n', '      address _to,\n', '      uint256 _value,\n', '      uint256 _start,\n', '      uint256 _vesting\n', '  ) public icoResticted isActive {\n', '    require(_value > 0);\n', '    require(_vesting > _start);\n', '    require(grants[_to].length < 10);\n', '\n', '    TokenGrant memory grant = TokenGrant(_value, 0, _vesting, _start);\n', '    grants[_to].push(grant);\n', '\n', '    NewTokenGrant(_to, _value, _start, _vesting);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date for myself\n', '  */\n', '  function claimTokens() public {\n', '    claim(msg.sender);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date in behaviour of an user\n', '  * @param _to address Addres to claim tokens\n', '  */\n', '  function claimTokensFor(address _to) public onlyOwner {\n', '    claim(_to);\n', '  }\n', '\n', '  /**\n', '  * @dev Get claimable tokens\n', '  */\n', '  function claimableTokens() public constant returns (uint256) {\n', '    address _to = msg.sender;\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    uint256 claimableFor = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimableFor = calculateVestedTokens(\n', '        grants[_to][i].value,\n', '        grants[_to][i].vesting,\n', '        grants[_to][i].start,\n', '        grants[_to][i].claimed\n', '      );\n', '      claimable = claimable.add(claimableFor);\n', '    }\n', '    return claimable;\n', '  }\n', '\n', '  /**\n', '  * @dev Get all veted tokens\n', '  */\n', '  function totalVestedTokens() public constant returns (uint256) {\n', '    address _to = msg.sender;\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimable = claimable.add(\n', '        grants[_to][i].value.sub(grants[_to][i].claimed)\n', '      );\n', '    }\n', '    return claimable;\n', '  }\n', '\n', '  /**\n', '  * @dev Calculate vested claimable tokens on current time\n', '  * @param _tokens Number of tokens granted\n', '  * @param _vesting Vesting finish timestamp\n', '  * @param _start Vesting start timestamp\n', '  * @param _claimed Number of tokens already claimed\n', '  */\n', '  function calculateVestedTokens(\n', '      uint256 _tokens,\n', '      uint256 _vesting,\n', '      uint256 _start,\n', '      uint256 _claimed\n', '  ) internal constant returns (uint256) {\n', '    uint256 time = block.timestamp;\n', '\n', '    if (time < _start) {\n', '      return 0;\n', '    }\n', '\n', '    if (time >= _vesting) {\n', '      return _tokens.sub(_claimed);\n', '    }\n', '\n', '    uint256 vestedTokens = _tokens.mul(time.sub(_start)).div(\n', '      _vesting.sub(_start)\n', '    );\n', '\n', '    return vestedTokens.sub(_claimed);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date\n', '  */\n', '  function claim(address _to) internal {\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    uint256 claimableFor = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimableFor = calculateVestedTokens(\n', '        grants[_to][i].value,\n', '        grants[_to][i].vesting,\n', '        grants[_to][i].start,\n', '        grants[_to][i].claimed\n', '      );\n', '      claimable = claimable.add(claimableFor);\n', '      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n', '    }\n', '\n', '    token.transfer(_to, claimable);\n', '    circulatingSupply += claimable;\n', '\n', '    NewTokenClaim(_to, claimable);\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/TokenVesting.sol\n', '\n', '/**\n', ' * @title Vesting contract for SDT\n', ' * @dev see https://send.sd/token\n', ' */\n', 'contract TokenVesting is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  address public ico;\n', '  bool public initialized;\n', '  bool public active;\n', '  ERC20Basic public token;\n', '  mapping (address => TokenGrant[]) public grants;\n', '\n', '  uint256 public circulatingSupply = 0;\n', '\n', '  struct TokenGrant {\n', '    uint256 value;\n', '    uint256 claimed;\n', '    uint256 vesting;\n', '    uint256 start;\n', '  }\n', '\n', '  event NewTokenGrant (\n', '    address indexed to,\n', '    uint256 value,\n', '    uint256 start,\n', '    uint256 vesting\n', '  );\n', '\n', '  event NewTokenClaim (\n', '    address indexed holder,\n', '    uint256 value\n', '  );\n', '\n', '  modifier icoResticted() {\n', '    require(msg.sender == ico);\n', '    _;\n', '  }\n', '\n', '  modifier isActive() {\n', '    require(active);\n', '    _;\n', '  }\n', '\n', '  function TokenVesting() public {\n', '    active = false;\n', '  }\n', '\n', '  function init(address _token, address _ico) public onlyOwner {\n', '    token = ERC20Basic(_token);\n', '    ico = _ico;\n', '    initialized = true;\n', '    active = true;\n', '  }\n', '\n', '  function stop() public isActive onlyOwner {\n', '    active = false;\n', '  }\n', '\n', '  function resume() public onlyOwner {\n', '    require(!active);\n', '    require(initialized);\n', '    active = true;\n', '  }\n', '\n', '  /**\n', '  * @dev Grant vested tokens.\n', '  * @notice Only for ICO contract address.\n', '  * @param _to Addres to grant tokens to.\n', '  * @param _value Number of tokens granted.\n', '  * @param _vesting Vesting finish timestamp.\n', '  * @param _start Vesting start timestamp.\n', '  */\n', '  function grantVestedTokens(\n', '      address _to,\n', '      uint256 _value,\n', '      uint256 _start,\n', '      uint256 _vesting\n', '  ) public icoResticted isActive {\n', '    require(_value > 0);\n', '    require(_vesting > _start);\n', '    require(grants[_to].length < 10);\n', '\n', '    TokenGrant memory grant = TokenGrant(_value, 0, _vesting, _start);\n', '    grants[_to].push(grant);\n', '\n', '    NewTokenGrant(_to, _value, _start, _vesting);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date for myself\n', '  */\n', '  function claimTokens() public {\n', '    claim(msg.sender);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date in behaviour of an user\n', '  * @param _to address Addres to claim tokens\n', '  */\n', '  function claimTokensFor(address _to) public onlyOwner {\n', '    claim(_to);\n', '  }\n', '\n', '  /**\n', '  * @dev Get claimable tokens\n', '  */\n', '  function claimableTokens() public constant returns (uint256) {\n', '    address _to = msg.sender;\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    uint256 claimableFor = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimableFor = calculateVestedTokens(\n', '        grants[_to][i].value,\n', '        grants[_to][i].vesting,\n', '        grants[_to][i].start,\n', '        grants[_to][i].claimed\n', '      );\n', '      claimable = claimable.add(claimableFor);\n', '    }\n', '    return claimable;\n', '  }\n', '\n', '  /**\n', '  * @dev Get all veted tokens\n', '  */\n', '  function totalVestedTokens() public constant returns (uint256) {\n', '    address _to = msg.sender;\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimable = claimable.add(\n', '        grants[_to][i].value.sub(grants[_to][i].claimed)\n', '      );\n', '    }\n', '    return claimable;\n', '  }\n', '\n', '  /**\n', '  * @dev Calculate vested claimable tokens on current time\n', '  * @param _tokens Number of tokens granted\n', '  * @param _vesting Vesting finish timestamp\n', '  * @param _start Vesting start timestamp\n', '  * @param _claimed Number of tokens already claimed\n', '  */\n', '  function calculateVestedTokens(\n', '      uint256 _tokens,\n', '      uint256 _vesting,\n', '      uint256 _start,\n', '      uint256 _claimed\n', '  ) internal constant returns (uint256) {\n', '    uint256 time = block.timestamp;\n', '\n', '    if (time < _start) {\n', '      return 0;\n', '    }\n', '\n', '    if (time >= _vesting) {\n', '      return _tokens.sub(_claimed);\n', '    }\n', '\n', '    uint256 vestedTokens = _tokens.mul(time.sub(_start)).div(\n', '      _vesting.sub(_start)\n', '    );\n', '\n', '    return vestedTokens.sub(_claimed);\n', '  }\n', '\n', '  /**\n', '  * @dev Claim all vested tokens up to current date\n', '  */\n', '  function claim(address _to) internal {\n', '    uint256 numberOfGrants = grants[_to].length;\n', '\n', '    if (numberOfGrants == 0) {\n', '      return;\n', '    }\n', '\n', '    uint256 claimable = 0;\n', '    uint256 claimableFor = 0;\n', '    for (uint256 i = 0; i < numberOfGrants; i++) {\n', '      claimableFor = calculateVestedTokens(\n', '        grants[_to][i].value,\n', '        grants[_to][i].vesting,\n', '        grants[_to][i].start,\n', '        grants[_to][i].claimed\n', '      );\n', '      claimable = claimable.add(claimableFor);\n', '      grants[_to][i].claimed = grants[_to][i].claimed.add(claimableFor);\n', '    }\n', '\n', '    token.transfer(_to, claimable);\n', '    circulatingSupply += claimable;\n', '\n', '    NewTokenClaim(_to, claimable);\n', '  }\n', '}']
