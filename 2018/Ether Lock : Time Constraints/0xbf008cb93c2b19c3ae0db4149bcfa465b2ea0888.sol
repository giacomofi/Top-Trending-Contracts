['pragma solidity ^0.4.18;\n', '\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) public;\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a==0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract GameTable {\n', '    using SafeMath for uint;\n', '\n', '    struct Player {\n', '        address addr;\n', '        uint amount;\n', '        uint profit;\n', '    }\n', '\n', '    struct Option {\n', '        uint optionid;\n', '        bytes32 optionName;\n', '        bytes32 optionImage;\n', '        uint amount;\n', '        uint numPlayers;\n', '        mapping (uint => Player) players;\n', '        mapping (address => uint) playeramounts;\n', '    }\n', '\n', '    struct Game {\n', '        address gameManager;\n', '        bytes32 gameName;\n', '        uint numOptions;\n', '        uint amount;\n', '        uint balance;\n', '        uint winner;\n', '        uint startTime;\n', '        uint endTime;\n', '        uint openTime;\n', '        uint runingStatus;\n', '        mapping (uint => Option) options;\n', '    }\n', '\n', '    address owner;\n', '    uint numGames;\n', '    mapping (uint => Game) games;\n', '    address gameDeveloper = 0x18d91206b297359e8aed91810a86D6bFF0AF3462;\n', '    //0x18d91206b297359e8aed91810a86d6bff0af3462\n', '    \n', '    function GameTable() public { \n', '        owner = msg.sender;\n', '        numGames=0;\n', '    }\n', '    \n', '    function kill() public {\n', '       if (owner == msg.sender) { \n', '          selfdestruct(owner);\n', '       }\n', '    }\n', '\n', '    function newGame(bytes32 name, uint startDuration, uint endDuration, uint openDuration)  public returns (uint) {\n', '        if(startDuration < 1 || openDuration>888888888888 || endDuration<startDuration || openDuration<startDuration || openDuration<endDuration || owner != msg.sender) revert();\n', '        address manager =  msg.sender;\n', '        uint startTime = now + startDuration * 1 minutes;\n', '        uint endTime = now + endDuration * 1 minutes;\n', '        uint openTime = now + openDuration * 1 minutes;\n', '        games[numGames] = Game(manager, name, 0, 0, 0, 0, startTime, endTime, openTime, 0);\n', '        numGames = numGames+1; \n', '        return (numGames-1);\n', '    }\n', '\n', '    function getGameNum() public constant returns(uint) {return numGames;}\n', '\n', '    function getGameInfo (uint gameinx) public constant returns(bytes32 _gamename,uint _numoptions,uint _amount,uint _startTime,uint _endTime,uint _openTime,uint _runingStatus) {\n', '        _gamename = games[gameinx].gameName;\n', '        _numoptions = games[gameinx].numOptions;\n', '        _amount = games[gameinx].amount;\n', '        _startTime = games[gameinx].startTime;\n', '        _endTime = games[gameinx].endTime;\n', '        _openTime = games[gameinx].openTime;\n', '        _runingStatus = games[gameinx].runingStatus;\n', '    }\n', '    \n', '\n', '    function newOption(uint gameinx, uint optionid, bytes32 name, bytes32 optionimage)  public returns (uint) {\n', '        if (owner != msg.sender) revert();\n', '        if (gameinx > numGames) revert();\n', '        if (now >= games[gameinx].startTime) revert();\n', '        if (games[gameinx].runingStatus == 0){\n', '            games[gameinx].runingStatus = 1;\n', '        }\n', '        games[gameinx].numOptions = games[gameinx].numOptions+1;\n', '        games[gameinx].options[games[gameinx].numOptions-1] = Option(optionid, name, optionimage, 0, 0);\n', '        return games[gameinx].numOptions-1;\n', '    }\n', '\n', '\n', '    function getGameWinner (uint gameinx) public constant returns(uint) {return games[gameinx].winner;}\n', '    function getOptionInfo (uint gameinx, uint optioninx) public constant returns(uint _gameinx, uint _optionid, uint _optioninx,bytes32 _optionname,bytes32 _optionimage,uint _numplayers, uint _amount, uint _playeramount) {\n', '        _gameinx = gameinx;\n', '        _optioninx = optioninx;\n', '        _optionid = games[gameinx].options[optioninx].optionid;\n', '        _optionname = games[gameinx].options[optioninx].optionName;\n', '        _optionimage = games[gameinx].options[optioninx].optionImage;\n', '        _numplayers = games[gameinx].options[optioninx].numPlayers;\n', '        _amount = games[gameinx].options[optioninx].amount;\n', '        _playeramount = games[gameinx].options[optioninx].playeramounts[msg.sender];\n', '    }\n', '\n', '    function getPlayerPlayInfo (uint gameinx, uint optioninx, uint playerinx) public constant returns(address _addr, uint _amount, uint _profit) {\n', '        if(msg.sender != owner) revert();\n', '        _addr = games[gameinx].options[optioninx].players[playerinx].addr;\n', '        _amount = games[gameinx].options[optioninx].players[playerinx].amount;\n', '        _profit = games[gameinx].options[optioninx].players[playerinx].profit;\n', '    }\n', '\n', '    function getPlayerAmount (uint gameinx, uint optioninx, address addr) public constant returns(uint) {\n', '        if(msg.sender != owner) revert();\n', '        return games[gameinx].options[optioninx].playeramounts[addr];\n', '    }\n', '\n', '  \n', '    function contribute(uint gameinx,uint optioninx)  public payable {\n', '        if ((gameinx<0)||(gameinx>999999999999999999999999999999999999)||(optioninx<0)) revert();\n', '        if (optioninx >= games[gameinx].numOptions) revert();\n', '        if (now <= games[gameinx].startTime) revert();\n', '        if (now >= games[gameinx].endTime) revert();\n', '        //1000000000000000000=1eth\n', '        //5000000000000000  = 0.005 ETH\n', '        if (msg.value<5000000000000000 || msg.value>1000000000000000000000000000) revert();\n', '        if (games[gameinx].amount > 99999999999999999999999999999999999999999999999999999999) revert();\n', '\n', '        games[gameinx].options[optioninx].players[games[gameinx].options[optioninx].numPlayers++] = Player({addr: msg.sender, amount: msg.value, profit:0});\n', '        games[gameinx].options[optioninx].amount = games[gameinx].options[optioninx].amount.add(msg.value);\n', '        games[gameinx].options[optioninx].playeramounts[msg.sender] = games[gameinx].options[optioninx].playeramounts[msg.sender].add(msg.value);\n', '        games[gameinx].amount = games[gameinx].amount.add(msg.value);\n', '    }\n', '\n', '    function setWinner(uint gameinx,bytes32 gameName, uint optioninx, uint optionid, bytes32 optionName) public returns(bool res) {\n', '        if (owner != msg.sender) revert();\n', '        if ((now <= games[gameinx].openTime)||(games[gameinx].runingStatus>1)) revert();\n', '        if (gameName != games[gameinx].gameName) revert();\n', '        if (games[gameinx].options[optioninx].optionName != optionName) revert();\n', '        if (games[gameinx].options[optioninx].optionid != optionid) revert();\n', '\n', '        games[gameinx].winner = optioninx;\n', '        games[gameinx].runingStatus = 2;\n', '        safeWithdrawal(gameinx);\n', '        return true;\n', '    }\n', '\n', '    function safeWithdrawal(uint gameid) private {\n', '        \n', '        if ((gameid<0)||(gameid>999999999999999999999999999999999999)) revert();\n', '        if (now <= games[gameid].openTime) revert();\n', '        if (games[gameid].runingStatus != 2) revert();\n', '\n', '        uint winnerID = games[gameid].winner;\n', '        if (winnerID >0 && winnerID < 9999) {\n', '            \n', '            games[gameid].runingStatus = 3;\n', '            uint totalWinpool = games[gameid].options[winnerID].amount;\n', '            totalWinpool = games[gameid].amount.sub(totalWinpool);\n', '            //Calculate Fee\n', '            uint fee = totalWinpool.mul(15);\n', '            fee = fee.div(1000);\n', '            uint reward=totalWinpool.sub(fee);\n', '            //1000000000000000000=1eth\n', '            if(games[gameid].options[winnerID].amount<100000000000){\n', '                gameDeveloper.transfer(reward);\n', '            }\n', '            else{\n', '                uint ratio = reward.mul(100);\n', '                ratio = ratio.div(games[gameid].options[winnerID].amount); //safe????\n', '                uint totalReturn = 0;\n', '                for(uint i = 0; i < games[gameid].options[winnerID].numPlayers; i++) {\n', '                    uint returnWinAmount = games[gameid].options[winnerID].players[i].amount.mul(ratio);\n', '                    returnWinAmount = returnWinAmount.div(100);\n', '                    returnWinAmount = games[gameid].options[winnerID].players[i].amount.add(returnWinAmount);\n', '                    games[gameid].options[winnerID].players[i].addr.transfer(returnWinAmount);\n', '                    games[gameid].options[winnerID].players[i].profit = returnWinAmount;\n', '                    totalReturn = totalReturn.add(returnWinAmount);\n', '                }  \n', '                uint totalFee = games[gameid].amount.sub(totalReturn);\n', '                gameDeveloper.transfer(totalFee);\n', '            }\n', '        }\n', '    } \n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) public;\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a==0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract GameTable {\n', '    using SafeMath for uint;\n', '\n', '    struct Player {\n', '        address addr;\n', '        uint amount;\n', '        uint profit;\n', '    }\n', '\n', '    struct Option {\n', '        uint optionid;\n', '        bytes32 optionName;\n', '        bytes32 optionImage;\n', '        uint amount;\n', '        uint numPlayers;\n', '        mapping (uint => Player) players;\n', '        mapping (address => uint) playeramounts;\n', '    }\n', '\n', '    struct Game {\n', '        address gameManager;\n', '        bytes32 gameName;\n', '        uint numOptions;\n', '        uint amount;\n', '        uint balance;\n', '        uint winner;\n', '        uint startTime;\n', '        uint endTime;\n', '        uint openTime;\n', '        uint runingStatus;\n', '        mapping (uint => Option) options;\n', '    }\n', '\n', '    address owner;\n', '    uint numGames;\n', '    mapping (uint => Game) games;\n', '    address gameDeveloper = 0x18d91206b297359e8aed91810a86D6bFF0AF3462;\n', '    //0x18d91206b297359e8aed91810a86d6bff0af3462\n', '    \n', '    function GameTable() public { \n', '        owner = msg.sender;\n', '        numGames=0;\n', '    }\n', '    \n', '    function kill() public {\n', '       if (owner == msg.sender) { \n', '          selfdestruct(owner);\n', '       }\n', '    }\n', '\n', '    function newGame(bytes32 name, uint startDuration, uint endDuration, uint openDuration)  public returns (uint) {\n', '        if(startDuration < 1 || openDuration>888888888888 || endDuration<startDuration || openDuration<startDuration || openDuration<endDuration || owner != msg.sender) revert();\n', '        address manager =  msg.sender;\n', '        uint startTime = now + startDuration * 1 minutes;\n', '        uint endTime = now + endDuration * 1 minutes;\n', '        uint openTime = now + openDuration * 1 minutes;\n', '        games[numGames] = Game(manager, name, 0, 0, 0, 0, startTime, endTime, openTime, 0);\n', '        numGames = numGames+1; \n', '        return (numGames-1);\n', '    }\n', '\n', '    function getGameNum() public constant returns(uint) {return numGames;}\n', '\n', '    function getGameInfo (uint gameinx) public constant returns(bytes32 _gamename,uint _numoptions,uint _amount,uint _startTime,uint _endTime,uint _openTime,uint _runingStatus) {\n', '        _gamename = games[gameinx].gameName;\n', '        _numoptions = games[gameinx].numOptions;\n', '        _amount = games[gameinx].amount;\n', '        _startTime = games[gameinx].startTime;\n', '        _endTime = games[gameinx].endTime;\n', '        _openTime = games[gameinx].openTime;\n', '        _runingStatus = games[gameinx].runingStatus;\n', '    }\n', '    \n', '\n', '    function newOption(uint gameinx, uint optionid, bytes32 name, bytes32 optionimage)  public returns (uint) {\n', '        if (owner != msg.sender) revert();\n', '        if (gameinx > numGames) revert();\n', '        if (now >= games[gameinx].startTime) revert();\n', '        if (games[gameinx].runingStatus == 0){\n', '            games[gameinx].runingStatus = 1;\n', '        }\n', '        games[gameinx].numOptions = games[gameinx].numOptions+1;\n', '        games[gameinx].options[games[gameinx].numOptions-1] = Option(optionid, name, optionimage, 0, 0);\n', '        return games[gameinx].numOptions-1;\n', '    }\n', '\n', '\n', '    function getGameWinner (uint gameinx) public constant returns(uint) {return games[gameinx].winner;}\n', '    function getOptionInfo (uint gameinx, uint optioninx) public constant returns(uint _gameinx, uint _optionid, uint _optioninx,bytes32 _optionname,bytes32 _optionimage,uint _numplayers, uint _amount, uint _playeramount) {\n', '        _gameinx = gameinx;\n', '        _optioninx = optioninx;\n', '        _optionid = games[gameinx].options[optioninx].optionid;\n', '        _optionname = games[gameinx].options[optioninx].optionName;\n', '        _optionimage = games[gameinx].options[optioninx].optionImage;\n', '        _numplayers = games[gameinx].options[optioninx].numPlayers;\n', '        _amount = games[gameinx].options[optioninx].amount;\n', '        _playeramount = games[gameinx].options[optioninx].playeramounts[msg.sender];\n', '    }\n', '\n', '    function getPlayerPlayInfo (uint gameinx, uint optioninx, uint playerinx) public constant returns(address _addr, uint _amount, uint _profit) {\n', '        if(msg.sender != owner) revert();\n', '        _addr = games[gameinx].options[optioninx].players[playerinx].addr;\n', '        _amount = games[gameinx].options[optioninx].players[playerinx].amount;\n', '        _profit = games[gameinx].options[optioninx].players[playerinx].profit;\n', '    }\n', '\n', '    function getPlayerAmount (uint gameinx, uint optioninx, address addr) public constant returns(uint) {\n', '        if(msg.sender != owner) revert();\n', '        return games[gameinx].options[optioninx].playeramounts[addr];\n', '    }\n', '\n', '  \n', '    function contribute(uint gameinx,uint optioninx)  public payable {\n', '        if ((gameinx<0)||(gameinx>999999999999999999999999999999999999)||(optioninx<0)) revert();\n', '        if (optioninx >= games[gameinx].numOptions) revert();\n', '        if (now <= games[gameinx].startTime) revert();\n', '        if (now >= games[gameinx].endTime) revert();\n', '        //1000000000000000000=1eth\n', '        //5000000000000000  = 0.005 ETH\n', '        if (msg.value<5000000000000000 || msg.value>1000000000000000000000000000) revert();\n', '        if (games[gameinx].amount > 99999999999999999999999999999999999999999999999999999999) revert();\n', '\n', '        games[gameinx].options[optioninx].players[games[gameinx].options[optioninx].numPlayers++] = Player({addr: msg.sender, amount: msg.value, profit:0});\n', '        games[gameinx].options[optioninx].amount = games[gameinx].options[optioninx].amount.add(msg.value);\n', '        games[gameinx].options[optioninx].playeramounts[msg.sender] = games[gameinx].options[optioninx].playeramounts[msg.sender].add(msg.value);\n', '        games[gameinx].amount = games[gameinx].amount.add(msg.value);\n', '    }\n', '\n', '    function setWinner(uint gameinx,bytes32 gameName, uint optioninx, uint optionid, bytes32 optionName) public returns(bool res) {\n', '        if (owner != msg.sender) revert();\n', '        if ((now <= games[gameinx].openTime)||(games[gameinx].runingStatus>1)) revert();\n', '        if (gameName != games[gameinx].gameName) revert();\n', '        if (games[gameinx].options[optioninx].optionName != optionName) revert();\n', '        if (games[gameinx].options[optioninx].optionid != optionid) revert();\n', '\n', '        games[gameinx].winner = optioninx;\n', '        games[gameinx].runingStatus = 2;\n', '        safeWithdrawal(gameinx);\n', '        return true;\n', '    }\n', '\n', '    function safeWithdrawal(uint gameid) private {\n', '        \n', '        if ((gameid<0)||(gameid>999999999999999999999999999999999999)) revert();\n', '        if (now <= games[gameid].openTime) revert();\n', '        if (games[gameid].runingStatus != 2) revert();\n', '\n', '        uint winnerID = games[gameid].winner;\n', '        if (winnerID >0 && winnerID < 9999) {\n', '            \n', '            games[gameid].runingStatus = 3;\n', '            uint totalWinpool = games[gameid].options[winnerID].amount;\n', '            totalWinpool = games[gameid].amount.sub(totalWinpool);\n', '            //Calculate Fee\n', '            uint fee = totalWinpool.mul(15);\n', '            fee = fee.div(1000);\n', '            uint reward=totalWinpool.sub(fee);\n', '            //1000000000000000000=1eth\n', '            if(games[gameid].options[winnerID].amount<100000000000){\n', '                gameDeveloper.transfer(reward);\n', '            }\n', '            else{\n', '                uint ratio = reward.mul(100);\n', '                ratio = ratio.div(games[gameid].options[winnerID].amount); //safe????\n', '                uint totalReturn = 0;\n', '                for(uint i = 0; i < games[gameid].options[winnerID].numPlayers; i++) {\n', '                    uint returnWinAmount = games[gameid].options[winnerID].players[i].amount.mul(ratio);\n', '                    returnWinAmount = returnWinAmount.div(100);\n', '                    returnWinAmount = games[gameid].options[winnerID].players[i].amount.add(returnWinAmount);\n', '                    games[gameid].options[winnerID].players[i].addr.transfer(returnWinAmount);\n', '                    games[gameid].options[winnerID].players[i].profit = returnWinAmount;\n', '                    totalReturn = totalReturn.add(returnWinAmount);\n', '                }  \n', '                uint totalFee = games[gameid].amount.sub(totalReturn);\n', '                gameDeveloper.transfer(totalFee);\n', '            }\n', '        }\n', '    } \n', '\n', '}']
