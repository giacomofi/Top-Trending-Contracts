['pragma solidity ^0.4.11;\n', '\n', '\n', 'interface CommonWallet {\n', '    function receive() external payable;\n', '}\n', '\n', 'library StringUtils {\n', '    function concat(string _a, string _b)\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '\n', '        bytes memory bab = new bytes(_ba.length + _bb.length);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '        return string(bab);\n', '    }\n', '}\n', '\n', 'library UintStringUtils {\n', '    function toString(uint i)\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', '        if (i == 0) return &#39;0&#39;;\n', '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}\n', '\n', '// @title AddressUtils\n', '// @dev Utility library of inline functions on addresses\n', 'library AddressUtils {\n', '    // Returns whether the target address is a contract\n', '    // @dev This function will return false if invoked during the constructor of a contract,\n', '    // as the code is not actually created until after the constructor finishes.\n', '    // @param addr address to check\n', '    // @return whether the target address is a contract\n', '    function isContract(address addr)\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', ' // @title SafeMath256\n', ' // @dev Math operations with safety checks that throw on error\n', 'library SafeMath256 {\n', '\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath32 {\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath8 {\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint8 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/// @title A facet of DragonCore that manages special access privileges.\n', 'contract DragonAccessControl \n', '{\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', '    /// @dev Contract owner\n', '    address internal controller_;\n', '\n', '    /// @dev Contract modes\n', '    enum Mode {TEST, PRESALE, OPERATE}\n', '\n', '    /// @dev Contract state\n', '    Mode internal mode_ = Mode.TEST;\n', '\n', '    /// @dev OffChain Server accounts (&#39;minions&#39;) addresses\n', '    /// It&#39;s used for money withdrawal and export of tokens \n', '    mapping(address => bool) internal minions_;\n', '    \n', '    /// @dev Presale contract address. Can call `presale` method.\n', '    address internal presale_;\n', '\n', '    // Modifiers ---------------------------------------------------------------\n', '    /// @dev Limit execution to controller account only.\n', '    modifier controllerOnly() {\n', '        require(controller_ == msg.sender, "controller_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to minion account only.\n', '    modifier minionOnly() {\n', '        require(minions_[msg.sender], "minion_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to test time only.\n', '    modifier testModeOnly {\n', '        require(mode_ == Mode.TEST, "test_mode_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to presale time only.\n', '    modifier presaleModeOnly {\n', '        require(mode_ == Mode.PRESALE, "presale_mode_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to operate time only.\n', '    modifier operateModeOnly {\n', '        require(mode_ == Mode.OPERATE, "operate_mode_only");\n', '        _;\n', '    }\n', '\n', '     /// @dev Limit execution to presale account only.\n', '    modifier presaleOnly() {\n', '        require(msg.sender == presale_, "presale_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev set state to Mode.OPERATE.\n', '    function setOperateMode()\n', '        external \n', '        controllerOnly\n', '        presaleModeOnly\n', '    {\n', '        mode_ = Mode.OPERATE;\n', '    }\n', '\n', '    /// @dev Set presale contract address. Becomes useless when presale is over.\n', '    /// @param _presale Presale contract address.\n', '    function setPresale(address _presale)\n', '        external\n', '        controllerOnly\n', '    {\n', '        presale_ = _presale;\n', '    }\n', '\n', '    /// @dev set state to Mode.PRESALE.\n', '    function setPresaleMode()\n', '        external\n', '        controllerOnly\n', '        testModeOnly\n', '    {\n', '        mode_ = Mode.PRESALE;\n', '    }    \n', '\n', '        /// @dev Get controller address.\n', '    /// @return Address of contract&#39;s controller.\n', '    function controller()\n', '        external\n', '        view\n', '        returns(address)\n', '    {\n', '        return controller_;\n', '    }\n', '\n', '    /// @dev Transfer control to new address. Set controller an approvee for\n', '    /// tokens that managed by contract itself. Remove previous controller value\n', '    /// from contract&#39;s approvees.\n', '    /// @param _to New controller address.\n', '    function setController(address _to)\n', '        external\n', '        controllerOnly\n', '    {\n', '        require(_to != NA, "_to");\n', '        require(controller_ != _to, "already_controller");\n', '\n', '        controller_ = _to;\n', '    }\n', '\n', '    /// @dev Check if address is a minion.\n', '    /// @param _addr Address to check.\n', '    /// @return True if address is a minion.\n', '    function isMinion(address _addr)\n', '        public view returns(bool)\n', '    {\n', '        return minions_[_addr];\n', '    }   \n', '\n', '    function getCurrentMode() \n', '        public view returns (Mode) \n', '    {\n', '        return mode_;\n', '    }    \n', '}\n', '\n', '/// @dev token description, storage and transfer functions\n', 'contract DragonBase is DragonAccessControl\n', '{\n', '    using SafeMath8 for uint8;\n', '    using SafeMath32 for uint32;\n', '    using SafeMath256 for uint256;\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;    \n', '\n', '    /// @dev The Birth event is fired whenever a new dragon comes into existence. \n', '    event Birth(address owner, uint256 petId, uint256 tokenId, uint256 parentA, uint256 parentB, string genes, string params);\n', '\n', '    /// @dev Token name\n', '    string internal name_;\n', '    /// @dev Token symbol\n', '    string internal symbol_;\n', '    /// @dev Token resolving url\n', '    string internal url_;\n', '\n', '    struct DragonToken {\n', '        // Constant Token params\n', '        uint8   genNum;  // generation number. uses for dragon view\n', '        string  genome;  // genome description\n', '        uint256 petId;   // offchain dragon identifier\n', '\n', '        // Parents\n', '        uint256 parentA;\n', '        uint256 parentB;\n', '\n', '        // Game-depening Token params\n', '        string  params;  // can change in export operation\n', '\n', '        // State\n', '        address owner; \n', '    }\n', '\n', '    /// @dev Count of minted tokens\n', '    uint256 internal mintCount_;\n', '    /// @dev Maximum token supply\n', '    uint256 internal maxSupply_;\n', '     /// @dev Count of burn tokens\n', '    uint256 internal burnCount_;\n', '\n', '    // Tokens state\n', '    /// @dev Token approvals values\n', '    mapping(uint256 => address) internal approvals_;\n', '    /// @dev Operator approvals\n', '    mapping(address => mapping(address => bool)) internal operatorApprovals_;\n', '    /// @dev Index of token in owner&#39;s token list\n', '    mapping(uint256 => uint256) internal ownerIndex_;\n', '    /// @dev Owner&#39;s tokens list\n', '    mapping(address => uint256[]) internal ownTokens_;\n', '    /// @dev Tokens\n', '    mapping(uint256 => DragonToken) internal tokens_;\n', '\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', '    /// @dev Add token to new owner. Increase owner&#39;s balance.\n', '    /// @param _to Token receiver.\n', '    /// @param _tokenId New token id.\n', '    function _addTo(address _to, uint256 _tokenId)\n', '        internal\n', '    {\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        require(token.owner == NA, "taken");\n', '\n', '        uint256 lastIndex = ownTokens_[_to].length;\n', '        ownTokens_[_to].push(_tokenId);\n', '        ownerIndex_[_tokenId] = lastIndex;\n', '\n', '        token.owner = _to;\n', '    }\n', '\n', '    /// @dev Create new token and increase mintCount.\n', '    /// @param _genome New token&#39;s genome.\n', '    /// @param _params Token params string. \n', '    /// @param _parentA Token A parent.\n', '    /// @param _parentB Token B parent.\n', '    /// @return New token id.\n', '    function _createToken(\n', '        address _to,\n', '        \n', '        // Constant Token params\n', '        uint8   _genNum,\n', '        string   _genome,\n', '        uint256 _parentA,\n', '        uint256 _parentB,\n', '        \n', '        // Game-depening Token params\n', '        uint256 _petId,\n', '        string   _params        \n', '    )\n', '        internal returns(uint256)\n', '    {\n', '        uint256 tokenId = mintCount_.add(1);\n', '        mintCount_ = tokenId;\n', '\n', '        DragonToken memory token = DragonToken(\n', '            _genNum,\n', '            _genome,\n', '            _petId,\n', '\n', '            _parentA,\n', '            _parentB,\n', '\n', '            _params,\n', '            NA\n', '        );\n', '        \n', '        tokens_[tokenId] = token;\n', '        \n', '        _addTo(_to, tokenId);\n', '        \n', '        emit Birth(_to, _petId, tokenId, _parentA, _parentB, _genome, _params);\n', '        \n', '        return tokenId;\n', '    }    \n', ' \n', '    /// @dev Get token genome.\n', '    /// @param _tokenId Token id.\n', '    /// @return Token&#39;s genome.\n', '    function getGenome(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return tokens_[_tokenId].genome;\n', '    }\n', '\n', '    /// @dev Get token params.\n', '    /// @param _tokenId Token id.\n', '    /// @return Token&#39;s params.\n', '    function getParams(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return tokens_[_tokenId].params;\n', '    }\n', '\n', '    /// @dev Get token parentA.\n', '    /// @param _tokenId Token id.\n', '    /// @return Parent token id.\n', '    function getParentA(uint256 _tokenId)\n', '        external view returns(uint256)\n', '    {\n', '        return tokens_[_tokenId].parentA;\n', '    }   \n', '\n', '    /// @dev Get token parentB.\n', '    /// @param _tokenId Token id.\n', '    /// @return Parent token id.\n', '    function getParentB(uint256 _tokenId)\n', '        external view returns(uint256)\n', '    {\n', '        return tokens_[_tokenId].parentB;\n', '    }\n', '\n', '    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\n', '    /// @param _tokenId Token id\n', '    /// @return Return true if token owner is real.\n', '    function isExisting(uint256 _tokenId)\n', '        public view returns(bool)\n', '    {\n', '        return tokens_[_tokenId].owner != NA;\n', '    }    \n', '\n', '    /// @dev Receive maxium token supply value.\n', '    /// @return Contracts `maxSupply_` variable.\n', '    function maxSupply()\n', '        external view returns(uint256)\n', '    {\n', '        return maxSupply_;\n', '    }\n', '\n', '    /// @dev Set url prefix for tokenURI generation.\n', '    /// @param _url Url prefix value.\n', '    function setUrl(string _url)\n', '        external controllerOnly\n', '    {\n', '        url_ = _url;\n', '    }\n', '\n', '    /// @dev Get token symbol.\n', '    /// @return Token symbol name.\n', '    function symbol()\n', '        external view returns(string)\n', '    {\n', '        return symbol_;\n', '    }\n', '\n', '    /// @dev Get token URI to receive offchain information by it&#39;s id.\n', '    /// @param _tokenId Token id.\n', '    /// @return URL string. For example "http://erc721.tld/tokens/1".\n', '    function tokenURI(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return url_.concat(_tokenId.toString());\n', '    }\n', '\n', '     /// @dev Get token name.\n', '    /// @return Token name string.\n', '    function name()\n', '        external view returns(string)\n', '    {\n', '        return name_;\n', '    }\n', '\n', '    /// @dev return information about _owner tokens\n', '    function getTokens(address _owner)\n', '        external view  returns (uint256[], uint256[], byte[]) \n', '    {\n', '        uint256[] memory tokens = ownTokens_[_owner];\n', '        uint256[] memory tokenIds = new uint256[](tokens.length);\n', '        uint256[] memory petIds = new uint256[](tokens.length);\n', '\n', '        byte[] memory genomes = new byte[](tokens.length * 77);\n', '        uint index = 0;\n', '\n', '        for(uint i = 0; i < tokens.length; i++) {\n', '            uint256 tokenId = tokens[i];\n', '            \n', '            DragonToken storage token = tokens_[tokenId];\n', '\n', '            tokenIds[i] = tokenId;\n', '            petIds[i] = token.petId;\n', '            \n', '            bytes storage genome = bytes(token.genome);\n', '            \n', '            for(uint j = 0; j < genome.length; j++) {\n', '                genomes[index++] = genome[j];\n', '            }\n', '        }\n', '        return (tokenIds, petIds, genomes);\n', '    }\n', '    \n', '}\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @dev See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721.sol\n', '\n', 'contract ERC721Basic \n', '{\n', '    /// @dev Emitted when token approvee is set\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    /// @dev Emitted when owner approve all own tokens to operator.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    /// @dev Emitted when user deposit some funds.\n', '    event Deposit(address indexed _sender, uint256 _value);\n', '    /// @dev Emitted when user deposit some funds.\n', '    event Withdraw(address indexed _sender, uint256 _value);\n', '    /// @dev Emitted when token transferred to new owner\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    // Required methods\n', '    function balanceOf(address _owner) external view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    \n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function getApproved(uint256 _tokenId) public view returns (address _to);\n', '\n', '    //function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '\n', '    function totalSupply() public view returns (uint256 total);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic \n', '{\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver \n', '{\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes _data )\n', '        public returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Metadata, ERC721Receiver \n', '{\n', '    /// @dev Interface signature 721 for interface detection.\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\n', '    /*\n', '    bytes4(keccak256(&#39;supportsInterface(bytes4)&#39;));\n', '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\n', '    /*\n', '    bytes4(keccak256(&#39;totalSupply()&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenOfOwnerByIndex(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenByIndex(uint256)&#39;));\n', '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\n', '    /*\n', '    bytes4(keccak256(&#39;name()&#39;)) ^\n', '    bytes4(keccak256(&#39;symbol()&#39;)) ^\n', '    bytes4(keccak256(&#39;tokenURI(uint256)&#39;));\n', '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\n', '    /*\n', '    bytes4(keccak256(&#39;balanceOf(address)&#39;)) ^\n', '    bytes4(keccak256(&#39;ownerOf(uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;approve(address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;getApproved(uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;setApprovalForAll(address,bool)&#39;)) ^\n', '    bytes4(keccak256(&#39;isApprovedForAll(address,address)&#39;)) ^\n', '    bytes4(keccak256(&#39;transferFrom(address,address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256)&#39;)) ^\n', '    bytes4(keccak256(&#39;safeTransferFrom(address,address,uint256,bytes)&#39;));\n', '    */\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        return ((_interfaceID == InterfaceSignature_ERC165)\n', '            || (_interfaceID == InterfaceSignature_ERC721)\n', '            || (_interfaceID == InterfaceSignature_ERC721Enumerable)\n', '            || (_interfaceID == InterfaceSignature_ERC721Metadata));\n', '    }    \n', '}\n', '\n', '/// @dev ERC721 methods\n', 'contract DragonOwnership is ERC721, DragonBase\n', '{\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;    \n', '    using AddressUtils for address;\n', '\n', '    /// @dev Emitted when token transferred to new owner. Additional fields is petId, genes, params\n', '    /// it uses for client-side indication\n', '    event TransferInfo(address indexed _from, address indexed _to, uint256 _tokenId, uint256 petId, string genes, string params);\n', '\n', '    /// @dev Specify if _addr is token owner or approvee. Also check if `_addr`\n', '    /// is operator for token owner.\n', '    /// @param _tokenId Token to check ownership of.\n', '    /// @param _addr Address to check if it&#39;s an owner or an aprovee of `_tokenId`.\n', '    /// @return True if token can be managed by provided `_addr`.\n', '    function isOwnerOrApproved(uint256 _tokenId, address _addr)\n', '        public view returns(bool)\n', '    {\n', '        DragonToken memory token = tokens_[_tokenId];\n', '\n', '        if (token.owner == _addr) {\n', '            return true;\n', '        }\n', '        else if (isApprovedFor(_tokenId, _addr)) {\n', '            return true;\n', '        }\n', '        else if (isApprovedForAll(token.owner, _addr)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /// @dev Limit execution to token owner or approvee only.\n', '    /// @param _tokenId Token to check ownership of.\n', '    modifier ownerOrApprovedOnly(uint256 _tokenId) {\n', '        require(isOwnerOrApproved(_tokenId, msg.sender), "tokenOwnerOrApproved_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Contract&#39;s own token only acceptable.\n', '    /// @param _tokenId Contract&#39;s token id.\n', '    modifier ownOnly(uint256 _tokenId) {\n', '        require(tokens_[_tokenId].owner == address(this), "own_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Determine if token is approved for specified approvee.\n', '    /// @param _tokenId Target token id.\n', '    /// @param _approvee Approvee address.\n', '    /// @return True if so.\n', '    function isApprovedFor(uint256 _tokenId, address _approvee)\n', '        public view returns(bool)\n', '    {\n', '        return approvals_[_tokenId] == _approvee;\n', '    }\n', '\n', '    /// @dev Specify is given address set as operator with setApprovalForAll.\n', '    /// @param _owner Token owner.\n', '    /// @param _operator Address to check if it an operator.\n', '    /// @return True if operator is set.\n', '    function isApprovedForAll(address _owner, address _operator)\n', '        public view returns(bool)\n', '    {\n', '        return operatorApprovals_[_owner][_operator];\n', '    }\n', '\n', '    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\n', '    /// @param _tokenId Token id\n', '    /// @return Return true if token owner is real.\n', '    function exists(uint256 _tokenId)\n', '        public view returns(bool)\n', '    {\n', '        return tokens_[_tokenId].owner != NA;\n', '    }\n', '\n', '    /// @dev Get owner of a token.\n', '    /// @param _tokenId Token owner id.\n', '    /// @return Token owner address.\n', '    function ownerOf(uint256 _tokenId)\n', '        public view returns(address)\n', '    {\n', '        return tokens_[_tokenId].owner;\n', '    }\n', '\n', '    /// @dev Get approvee address. If there is not approvee returns 0x0.\n', '    /// @param _tokenId Token id to get approvee of.\n', '    /// @return Approvee address or 0x0.\n', '    function getApproved(uint256 _tokenId)\n', '        public view returns(address)\n', '    {\n', '        return approvals_[_tokenId];\n', '    }\n', '\n', '    /// @dev Grant owner alike controll permissions to third party.\n', '    /// @param _to Permission receiver.\n', '    /// @param _tokenId Granted token id.\n', '    function approve(address _to, uint256 _tokenId)\n', '        external ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        require(_to != owner);\n', '\n', '        if (getApproved(_tokenId) != NA || _to != NA) {\n', '            approvals_[_tokenId] = _to;\n', '\n', '            emit Approval(owner, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    /// @dev Current total tokens supply. Always less then maxSupply.\n', '    /// @return Difference between minted and burned tokens.\n', '    function totalSupply()\n', '        public view returns(uint256)\n', '    {\n', '        return mintCount_;\n', '    }    \n', '\n', '    /// @dev Get number of tokens which `_owner` owns.\n', '    /// @param _owner Address to count own tokens.\n', '    /// @return Count of owned tokens.\n', '    function balanceOf(address _owner)\n', '        external view returns(uint256)\n', '    {\n', '        return ownTokens_[_owner].length;\n', '    }    \n', '\n', '    /// @dev Internal set approval for all without _owner check.\n', '    /// @param _owner Granting user.\n', '    /// @param _to New account approvee.\n', '    /// @param _approved Set new approvee status.\n', '    function _setApprovalForAll(address _owner, address _to, bool _approved)\n', '        internal\n', '    {\n', '        operatorApprovals_[_owner][_to] = _approved;\n', '\n', '        emit ApprovalForAll(_owner, _to, _approved);\n', '    }\n', '\n', '    /// @dev Set approval for all account tokens.\n', '    /// @param _to Approvee address.\n', '    /// @param _approved Value true or false.\n', '    function setApprovalForAll(address _to, bool _approved)\n', '        external\n', '    {\n', '        require(_to != msg.sender);\n', '\n', '        _setApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', '\n', '    /// @dev Remove approval bindings for token. Do nothing if no approval\n', '    /// exists.\n', '    /// @param _from Address of token owner.\n', '    /// @param _tokenId Target token id.\n', '    function _clearApproval(address _from, uint256 _tokenId)\n', '        internal\n', '    {\n', '        if (approvals_[_tokenId] == NA) {\n', '            return;\n', '        }\n', '\n', '        approvals_[_tokenId] = NA;\n', '        emit Approval(_from, NA, _tokenId);\n', '    }\n', '\n', '    /// @dev Check if contract was received by other side properly if receiver\n', '    /// is a ctontract.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    /// @param _data Transaction data.\n', '    /// @return True on success.\n', '    function _checkAndCallSafeTransfer(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        internal returns(bool)\n', '    {\n', '        if (! _to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n', '            _from, _tokenId, _data\n', '        );\n', '\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '\n', '    /// @dev Remove token from owner. Unrecoverable.\n', '    /// @param _tokenId Removing token id.\n', '    function _remove(uint256 _tokenId)\n', '        internal\n', '    {\n', '        address owner = tokens_[_tokenId].owner;\n', '        _removeFrom(owner, _tokenId);\n', '    }\n', '\n', '    /// @dev Completely remove token from the contract. Unrecoverable.\n', '    /// @param _owner Owner of removing token.\n', '    /// @param _tokenId Removing token id.\n', '    function _removeFrom(address _owner, uint256 _tokenId)\n', '        internal\n', '    {\n', '        uint256 lastIndex = ownTokens_[_owner].length.sub(1);\n', '        uint256 lastToken = ownTokens_[_owner][lastIndex];\n', '\n', '        // Swap users token\n', '        ownTokens_[_owner][ownerIndex_[_tokenId]] = lastToken;\n', '        ownTokens_[_owner].length--;\n', '\n', '        // Swap token indexes\n', '        ownerIndex_[lastToken] = ownerIndex_[_tokenId];\n', '        ownerIndex_[_tokenId] = 0;\n', '\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        token.owner = NA;\n', '    }\n', '\n', '    /// @dev Transfer token from owner `_from` to another address or contract\n', '    /// `_to` by it&#39;s `_tokenId`.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    function transferFrom( address _from, address _to, uint256 _tokenId )\n', '        public ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        require(_from != NA);\n', '        require(_to != NA);\n', '\n', '        _clearApproval(_from, _tokenId);\n', '        _removeFrom(_from, _tokenId);\n', '        _addTo(_to, _tokenId);\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        emit TransferInfo(_from, _to, _tokenId, token.petId, token.genome, token.params);\n', '    }\n', '\n', '    /// @dev Update token params and transfer to new owner. Only contract&#39;s own\n', '    /// tokens could be updated. Also notifies receiver of the token.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    function updateAndSafeTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params\n', '    )\n', '        public\n', '    {\n', '        updateAndSafeTransferFrom(_to, _tokenId, _params, "");\n', '    }\n', '\n', '    /// @dev Update token params and transfer to new owner. Only contract&#39;s own\n', '    /// tokens could be updated. Also notifies receiver of the token and send\n', '    /// protion of _data to it.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    /// @param _data Notification data.\n', '    function updateAndSafeTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params,\n', '        bytes _data\n', '    )\n', '        public\n', '    {\n', '        // Safe transfer from\n', '        updateAndTransferFrom(_to, _tokenId, _params, 0, 0);\n', '        require(_checkAndCallSafeTransfer(address(this), _to, _tokenId, _data));\n', '    }\n', '\n', '    /// @dev Update token params and transfer to new owner. Only contract&#39;s own\n', '    /// tokens could be updated.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    function updateAndTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params,\n', '        uint256 _petId, \n', '        uint256 _transferCost\n', '    )\n', '        public\n', '        ownOnly(_tokenId)\n', '        minionOnly\n', '    {\n', '        require(bytes(_params).length > 0, "params_length");\n', '\n', '        // Update\n', '        tokens_[_tokenId].params = _params;\n', '        if (tokens_[_tokenId].petId == 0 ) {\n', '            tokens_[_tokenId].petId = _petId;\n', '        }\n', '\n', '        address from = tokens_[_tokenId].owner;\n', '\n', '        // Transfer from\n', '        transferFrom(from, _to, _tokenId);\n', '\n', '        // send to the server&#39;s wallet the transaction cost\n', '        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server        \n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '    }\n', '\n', '    /// @dev Transfer token from one owner to new one and check if it was\n', '    /// properly received if receiver is a contact.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        public\n', '    {\n', '        safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /// @dev Transfer token from one owner to new one and check if it was\n', '    /// properly received if receiver is a contact.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    /// @param _data Transaction data.\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '    {\n', '        transferFrom(_from, _to, _tokenId);\n', '        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '    }\n', '\n', '    /// @dev Burn owned token. Increases `burnCount_` and decrease `totalSupply`\n', '    /// value.\n', '    /// @param _tokenId Id of burning token.\n', '    function burn(uint256 _tokenId)\n', '        public\n', '        ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        address owner = tokens_[_tokenId].owner;\n', '        _remove(_tokenId);\n', '\n', '        burnCount_ += 1;\n', '\n', '        emit Transfer(owner, NA, _tokenId);\n', '    }\n', '\n', '    /// @dev Receive count of burned tokens. Should be greater than `totalSupply`\n', '    /// but less than `mintCount`.\n', '    /// @return Number of burned tokens\n', '    function burnCount()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return burnCount_;\n', '    }\n', '\n', '    function onERC721Received(address, uint256, bytes)\n', '        public returns(bytes4) \n', '    {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title Managing contract. implements the logic of buying tokens, depositing / withdrawing funds \n', '/// to the project account and importing / exporting tokens\n', 'contract EtherDragonsCore is DragonOwnership \n', '{\n', '    using SafeMath8 for uint8;\n', '    using SafeMath32 for uint32;\n', '    using SafeMath256 for uint256;\n', '    using AddressUtils for address;\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;\n', '\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', '    /// @dev Bounty tokens count limit\n', '    uint256 public constant BOUNTY_LIMIT = 2500;\n', '    /// @dev Presale tokens count limit\n', '    uint256 public constant PRESALE_LIMIT = 7500;\n', '    ///@dev Total gen0tokens generation limit\n', '    uint256 public constant GEN0_CREATION_LIMIT = 90000;\n', '    \n', '    /// @dev Number of tokens minted in presale stage\n', '    uint256 internal presaleCount_;  \n', '    /// @dev Number of tokens minted for bounty campaign\n', '    uint256 internal bountyCount_;\n', '   \n', '    ///@dev Company bank address\n', '    address internal bank_;\n', '\n', '    // Extension ---------------------------------------------------------------\n', '\n', '    /// @dev Contract is not payable. To fullfil balance method `depositTo`\n', '    /// should be used.\n', '    function ()\n', '        public payable\n', '    {\n', '        revert();\n', '    }\n', '\n', '    /// @dev amount on the account of the contract. This amount consists of deposits  from players and the system reserve for payment of transactions\n', '    /// the player at any time to withdraw the amount corresponding to his account in the game, minus the cost of the transaction \n', '    function getBalance() \n', '        public view returns (uint256)\n', '    {\n', '        return address(this).balance;\n', '    }    \n', '\n', '    /// @dev at the moment of creation of the contract we transfer the address of the bank\n', '    /// presell contract address set later\n', '    constructor(\n', '        address _bank\n', '    )\n', '        public\n', '    {\n', '        require(_bank != NA);\n', '        \n', '        controller_ = msg.sender;\n', '        bank_ = _bank;\n', '        \n', '        // Meta\n', '        name_ = "EtherDragons";\n', '        symbol_ = "ED";\n', '        url_ = "https://game.etherdragons.world/token/";\n', '\n', '        // Token mint limit\n', '        maxSupply_ = GEN0_CREATION_LIMIT + BOUNTY_LIMIT + PRESALE_LIMIT;\n', '    }\n', '\n', '    /// Number of tokens minted in presale stage\n', '    function totalPresaleCount()\n', '        public view returns(uint256)\n', '    {\n', '        return presaleCount_;\n', '    }    \n', '\n', '    /// @dev Number of tokens minted for bounty campaign\n', '    function totalBountyCount()\n', '        public view returns(uint256)\n', '    {\n', '        return bountyCount_;\n', '    }    \n', '    \n', '    /// @dev Check if new token could be minted. Return true if count of minted\n', '    /// tokens less than could be minted through contract deploy.\n', '    /// Also, tokens can not be created more often than once in mintDelay_ minutes\n', '    /// @return True if current count is less then maximum tokens available for now.\n', '    function canMint()\n', '        public view returns(bool)\n', '    {\n', '        return (mintCount_ + presaleCount_ + bountyCount_) < maxSupply_;\n', '    }\n', '\n', '    /// @dev Here we write the addresses of the wallets of the server from which it is accessed\n', '    /// to contract methods.\n', '    /// @param _to New minion address\n', '    function minionAdd(address _to)\n', '        external controllerOnly\n', '    {\n', '        require(minions_[_to] == false, "already_minion");\n', '        \n', '        // разрешаем этому адресу пользоваться токенами контакта\n', '        // allow the address to use contract tokens \n', '        _setApprovalForAll(address(this), _to, true);\n', '        \n', '        minions_[_to] = true;\n', '    }\n', '\n', '    /// @dev delete the address of the server wallet\n', '    /// @param _to Minion address\n', '    function minionRemove(address _to)\n', '        external controllerOnly\n', '    {\n', '        require(minions_[_to], "not_a_minion");\n', '\n', '        // and forbid this wallet to use tokens of the contract\n', '        _setApprovalForAll(address(this), _to, false);\n', '        minions_[_to] = false;\n', '    }\n', '\n', '    /// @dev Here the player can put funds to the account of the contract\n', '    /// and get the same amount of in-game currency\n', '    /// the game server understands who puts money at the wallet address\n', '    function depositTo()\n', '        public payable\n', '    {\n', '        emit Deposit(msg.sender, msg.value);\n', '    }    \n', '    \n', '    /// @dev Transfer amount of Ethers to specified receiver. Only owner can\n', '    // call this method.\n', '    /// @param _to Transfer receiver.\n', '    /// @param _amount Transfer value.\n', '    /// @param _transferCost Transfer cost.\n', '    function transferAmount(address _to, uint256 _amount, uint256 _transferCost)\n', '        external minionOnly\n', '    {\n', '        require((_amount + _transferCost) <= address(this).balance, "not enough money!");\n', '        _to.transfer(_amount);\n', '\n', '        // send to the wallet of the server the transfer cost\n', '        // withdraw  it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server\n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '\n', '        emit Withdraw(_to, _amount);\n', '    }        \n', '\n', '   /// @dev Mint new token with specified params. Transfer `_fee` to the\n', '    /// `bank`. \n', '    /// @param _to New token owner.\n', '    /// @param _fee Transaction fee.\n', '    /// @param _genNum Generation number..\n', '    /// @param _genome New genome unique value.\n', '    /// @param _parentA Parent A.\n', '    /// @param _parentB Parent B.\n', '    /// @param _petId Pet identifier.\n', '    /// @param _params List of parameters for pet.\n', '    /// @param _transferCost Transfer cost.\n', '    /// @return New token id.\n', '    function mintRelease(\n', '        address _to,\n', '        uint256 _fee,\n', '        \n', '        // Constant Token params\n', '        uint8   _genNum,\n', '        string   _genome,\n', '        uint256 _parentA,\n', '        uint256 _parentB,\n', '        \n', '        // Game-depening Token params\n', '        uint256 _petId,  //if petID = 0, then it was created outside of the server\n', '        string   _params,\n', '        uint256 _transferCost\n', '    )\n', '        external minionOnly operateModeOnly returns(uint256)\n', '    {\n', '        require(canMint(), "can_mint");\n', '        require(_to != NA, "_to");\n', '        require((_fee + _transferCost) <= address(this).balance, "_fee");\n', '        require(bytes(_params).length != 0, "params_length");\n', '        require(bytes(_genome).length == 77, "genome_length");\n', '        \n', '        // Parents should be both 0 or both not.\n', '        if (_parentA != 0 && _parentB != 0) {\n', '            require(_parentA != _parentB, "same_parent");\n', '        }\n', '        else if (_parentA == 0 && _parentB != 0) {\n', '            revert("parentA_empty");\n', '        }\n', '        else if (_parentB == 0 && _parentA != 0) {\n', '            revert("parentB_empty");\n', '        }\n', '\n', '        uint256 tokenId = _createToken(_to, _genNum, _genome, _parentA, _parentB, _petId, _params);\n', '\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        // Transfer mint fee to the fund\n', '        CommonWallet(bank_).receive.value(_fee)();\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '\n', '        // send to the server wallet server the transfer cost,\n', '        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server\n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '\n', '        return tokenId;\n', '    }\n', '\n', '    /// @dev Create new token via presale state\n', '    /// @param _to New token owner.\n', '    /// @param _genome New genome unique value.\n', '    /// @return New token id.\n', '    /// at the pre-sale stage we sell the zero-generation pets, which have only a genome.\n', '    /// other attributes of such a token get when importing to the server\n', '    function mintPresell(address _to, string _genome)\n', '        external presaleOnly presaleModeOnly returns(uint256)\n', '    {\n', '        require(presaleCount_ < PRESALE_LIMIT, "presale_limit");\n', '\n', '        // у пресейл пета нет параметров. Их он получит после ввода в игру.\n', '        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, "");\n', '        presaleCount_ += 1;\n', '\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '        \n', '        return tokenId;\n', '    }    \n', '    \n', '    /// @dev Create new token for bounty activity\n', '    /// @param _to New token owner.\n', '    /// @return New token id.\n', '    function mintBounty(address _to, string _genome)\n', '        external controllerOnly returns(uint256)\n', '    {\n', '        require(bountyCount_ < BOUNTY_LIMIT, "bounty_limit");\n', '\n', '        // bounty pet has no parameters. They will receive them after importing to the game.\n', '        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, "");\n', '    \n', '        bountyCount_ += 1;\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '\n', '        return tokenId;\n', '    }        \n', '}\n', '\n', 'contract Presale\n', '{\n', '    // Extension ---------------------------------------------------------------\n', '    using AddressUtils for address;\n', '\n', '    // Events ------------------------------------------------------------------\n', '    ///the event is fired when starting a new wave presale stage\n', '    event StageBegin(uint8 stage, uint256 timestamp);\n', '\n', '    ///the event is fired when token sold\n', '    event TokensBought(address buyerAddr, uint256[] tokenIds, bytes genomes);\n', '\n', '    // Types -------------------------------------------------------------------\n', '    struct Stage {\n', '        // Predefined values\n', '        uint256 price;      // token&#39;s price on the stage\n', '        uint16 softcap;     // stage softCap\n', '        uint16 hardcap;     // stage hardCap\n', '        \n', '        // Unknown values\n', '        uint16 bought;      // sold on stage\n', '        uint32 startDate;   // stage&#39;s beginDate\n', '        uint32 endDate;     // stage&#39;s endDate\n', '    }\n', '    \n', '    // Constants ---------------------------------------------------------------\n', '    // 10 stages of 5 genocodes\n', '    uint8 public constant STAGES = 10;\n', '    uint8 internal constant TOKENS_PER_STAGE = 5;\n', '    address constant NA = address(0);\n', '    \n', '    // State -------------------------------------------------------------------\n', '    address internal CEOAddress;    // contract owner\n', '    address internal bank_;         // profit wallet address (not a contract)\n', '    address internal erc721_;       // main contract address\n', '    \n', '    /// @dev genomes for bounty stage\n', '    string[TOKENS_PER_STAGE][STAGES] internal genomes_;\n', '\n', '    /// stages data\n', '    Stage[STAGES] internal stages_;\n', '    \n', '    // internal transaction counter, it uses for random generator\n', '    uint32  internal counter_;\n', '    \n', '    /// stage is over\n', '    bool    internal isOver_;\n', '\n', '    /// stage number\n', '    uint8   internal stageIndex_;\n', '\n', '    ///  stage start Data\n', '    uint32  internal stageStart_;\n', '\n', '    // Lifetime ----------------------------------------------------------------\n', '    constructor(\n', '        address _bank,  \n', '        address _erc721\n', '    )\n', '        public\n', '    {\n', '        require(_bank != NA, &#39;_bank&#39;);\n', '        require(_erc721.isContract(), &#39;_erc721&#39;);\n', '\n', '        CEOAddress = msg.sender;\n', '\n', '        // Addresses should not be the same.\n', '        require(_bank != CEOAddress, "bank = CEO");\n', '        require(CEOAddress != _erc721, "CEO = erc721");\n', '        require(_erc721 != _bank, "bank = erc721");\n', '\n', '        // Update state\n', '        bank_ = _bank;\n', '        erc721_ = _erc721;\n', '       \n', '        // stages data \n', '        stages_[0].price = 10 finney;\n', '        stages_[0].softcap = 100;\n', '        stages_[0].hardcap = 300;\n', '        \n', '        stages_[1].price = 20 finney;\n', '        stages_[1].softcap = 156;\n', '        stages_[1].hardcap = 400;\n', '    \n', '        stages_[2].price = 32 finney;\n', '        stages_[2].softcap = 212;\n', '        stages_[2].hardcap = 500;\n', '        \n', '        stages_[3].price = 45 finney;\n', '        stages_[3].softcap = 268;\n', '        stages_[3].hardcap = 600;\n', '        \n', '        stages_[4].price = 58 finney;\n', '        stages_[4].softcap = 324;\n', '        stages_[4].hardcap = 700;\n', '    \n', '        stages_[5].price = 73 finney;\n', '        stages_[5].softcap = 380;\n', '        stages_[5].hardcap = 800;\n', '    \n', '        stages_[6].price = 87 finney;\n', '        stages_[6].softcap = 436;\n', '        stages_[6].hardcap = 900;\n', '    \n', '        stages_[7].price = 102 finney;\n', '        stages_[7].softcap = 492;\n', '        stages_[7].hardcap = 1000;\n', '    \n', '        stages_[8].price = 118 finney;\n', '        stages_[8].softcap = 548;\n', '        stages_[8].hardcap = 1100;\n', '        \n', '        stages_[9].price = 129 finney;\n', '        stages_[9].softcap = 604;\n', '        stages_[9].hardcap = 1200;\n', '    }\n', '\n', '    /// fill the genomes data\n', '    function setStageGenomes(\n', '        uint8 _stage,\n', '        string _genome0, \n', '        string _genome1,\n', '        string _genome2, \n', '        string _genome3, \n', '        string _genome4\n', '    ) \n', '        external controllerOnly\n', '    {\n', '        genomes_[_stage][0] = _genome0;\n', '        genomes_[_stage][1] = _genome1;\n', '        genomes_[_stage][2] = _genome2;\n', '        genomes_[_stage][3] = _genome3;\n', '        genomes_[_stage][4] = _genome4;\n', '    }\n', '\n', '    /// @dev Contract itself is non payable\n', '    function ()\n', '        public payable\n', '    {\n', '        revert();\n', '    }\n', '    \n', '    // Modifiers ---------------------------------------------------------------\n', '    \n', '    /// only from contract owner\n', '    modifier controllerOnly() {\n', '        require(msg.sender == CEOAddress, &#39;controller_only&#39;);\n', '        _;\n', '    }\n', '\n', '    /// only for active stage\n', '    modifier notOverOnly() {\n', '        require(isOver_ == false, &#39;notOver_only&#39;);\n', '        _;\n', '    }\n', '\n', '    // Getters -----------------------------------------------------------------\n', '    /// owner address\n', '    function getCEOAddress()\n', '        public view returns(address)\n', '    {\n', '        return CEOAddress;\n', '    }\n', '\n', '    /// counter from random number generator\n', '    function counter()\n', '        internal view returns(uint32)\n', '    {\n', '        return counter_;\n', '    }\n', '\n', '    // tokens sold by stage ...\n', '    function stageTokensBought(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].bought;\n', '    }\n', '\n', '    // stage softcap\n', '    function stageSoftcap(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].softcap;\n', '    }\n', '\n', '    /// stage hardcap\n', '    function stageHardcap(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].hardcap;\n', '    }\n', '\n', '    /// stage Start Date    \n', '    function stageStartDate(uint8 _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].startDate;\n', '    }\n', '    \n', '    /// stage Finish Date\n', '    function stageEndDate(uint8 _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].endDate;\n', '    }\n', '\n', '    /// stage token price\n', '    function stagePrice(uint _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].price;\n', '    }\n', '    \n', '    // Genome Logic -----------------------------------------------------------------\n', '    /// within the prelase , the dragons are generated, which are the ancestors of the destiny\n', '    /// newborns have a high chance of mutation and are unlikely to be purebred\n', '    /// the player will have to collect the breed, crossing a lot of pets\n', '    /// In addition, you will need to pick up combat abilities\n', '    /// these characteristics are assigned to the pet when the dragon is imported to the game server.    \n', '    function nextGenome()\n', '        internal returns(string)\n', '    {\n', '        uint8 n = getPseudoRandomNumber();\n', '\n', '        counter_ += 1;\n', '        \n', '        return genomes_[stageIndex_][n];\n', '    }\n', '\n', '    function getPseudoRandomNumber()\n', '        internal view returns(uint8 index)\n', '    {\n', '        uint8 n = uint8(\n', '            keccak256(abi.encode(msg.sender, block.timestamp + counter_))\n', '        );\n', '        return n % TOKENS_PER_STAGE;\n', '    }\n', '    \n', '    // PreSale Logic -----------------------------------------------------------------\n', '    /// Presale stage0 begin date set\n', '    /// presale start is possible only once    \n', '    function setStartDate(uint32 _startDate)\n', '        external controllerOnly\n', '    {\n', '        require(stages_[0].startDate == 0, &#39;already_set&#39;);\n', '        \n', '        stages_[0].startDate = _startDate;\n', '        stageStart_ = _startDate;\n', '        stageIndex_ = 0;\n', '        \n', '        emit StageBegin(stageIndex_, stageStart_); \n', '    }\n', '\n', '    /// current stage number\n', '    /// switches to the next stage if the time has come\n', '    function stageIndex()\n', '        external view returns(uint8)\n', '    {\n', '        Stage memory stage = stages_[stageIndex_];\n', '\n', '        if (stage.endDate > 0 && stage.endDate <= now) {\n', '            return stageIndex_ + 1;\n', '        }\n', '        else {\n', '            return stageIndex_;\n', '        }\n', '    }\n', '    \n', '    /// check whether the phase started\n', '    /// switch to the next stage, if necessary    \n', '    function beforeBuy()\n', '        internal\n', '    {\n', '        if (stageStart_ == 0) {\n', '            revert(&#39;presale_not_started&#39;);\n', '        }\n', '        else if (stageStart_ > now) {\n', '            revert(&#39;stage_not_started&#39;);\n', '        }\n', '\n', '        Stage memory stage = stages_[stageIndex_];\n', '        if (stage.endDate > 0 && stage.endDate <= now) \n', '        {\n', '            stageIndex_ += 1;\n', '            stageStart_ = stages_[stageIndex_].startDate;\n', '\n', '            if (stageStart_ > now) {\n', '                revert(&#39;stage_not_started&#39;);\n', '            }\n', '        }\n', '    }\n', '    \n', '    /// time to next midnight\n', '    function midnight()\n', '        public view returns(uint32)\n', '    {\n', '        uint32 tomorrow = uint32(now + 1 days);\n', '        uint32 remain = uint32(tomorrow % 1 days);\n', '        return tomorrow - remain;\n', '    }\n', '    \n', '    /// buying a specified number of tokens\n', '    function buyTokens(uint16 numToBuy)\n', '        public payable notOverOnly returns(uint256[])\n', '    {\n', '        beforeBuy();\n', '        \n', '        require(numToBuy > 0 && numToBuy <= 10, "numToBuy error");\n', '\n', '        Stage storage stage = stages_[stageIndex_];\n', '        require((stage.price * numToBuy) <= msg.value, &#39;price&#39;);\n', '        \n', '        uint16 prevBought = stage.bought;\n', '        require(prevBought + numToBuy <= stage.hardcap, "have required tokens");\n', '        \n', '        stage.bought += numToBuy;\n', '        uint256[] memory tokenIds = new uint256[](numToBuy);\n', '        \n', '        bytes memory genomes = new bytes(numToBuy * 77);\n', '        uint32 genomeByteIndex = 0;\n', '\n', '        for(uint16 t = 0; t < numToBuy; t++) \n', '        {\n', '            string memory genome = nextGenome();\n', '            uint256 tokenId = EtherDragonsCore(erc721_).mintPresell(msg.sender, genome);\n', '\n', '            bytes memory genomeBytes = bytes(genome);\n', '            \n', '            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\n', '                genomes[genomeByteIndex++] = genomeBytes[gi];\n', '            }\n', '\n', '            tokenIds[t] = tokenId;\n', '        }\n', '\n', '        // Transfer mint fee to the fund\n', '        bank_.transfer(address(this).balance);\n', '\n', '        if (stage.bought == stage.hardcap) {\n', '            stage.endDate = uint32(now);\n', '            stageStart_ = midnight() + 1 days + 1 seconds;\n', '            if (stageIndex_ < STAGES - 1) {\n', '                stageIndex_ += 1;\n', '            }\n', '            else {\n', '                isOver_ = true;\n', '            }\n', '        }\n', '        else if (stage.bought >= stage.softcap && prevBought < stage.softcap) {\n', '            stage.endDate = midnight() + 1 days;\n', '            if (stageIndex_ < STAGES - 1) {\n', '                stages_[stageIndex_ + 1].startDate = stage.endDate + 1 days;\n', '            }\n', '        }\n', '\n', '        emit TokensBought(msg.sender, tokenIds, genomes);\n', '\n', '        return tokenIds;\n', '    }\n', '\n', '    function currTime()\n', '        public view returns(uint)\n', '    {\n', '        return now;\n', '    }\n', '    \n', '    /// stages data\n', '    function getStagesInfo() \n', '        public view returns (uint256[] prices, uint16[] softcaps, uint16[] hardcaps, uint16[] boughts) \n', '    {\n', '            prices = new uint256[](STAGES);\n', '            softcaps = new uint16[](STAGES);\n', '            hardcaps = new uint16[](STAGES);\n', '            boughts = new uint16[](STAGES);\n', '            \n', '            for(uint8 s = 0; s < STAGES; s++) {\n', '                prices[s] = stages_[s].price;\n', '                softcaps[s] = stages_[s].softcap;\n', '                hardcaps[s] = stages_[s].hardcap;\n', '                boughts[s] = stages_[s].bought;\n', '            }\n', '    }\n', '    \n', '    /// stages dates data\n', '    function getStagesBeginEnd() \n', '        public view returns (uint32[] startDates, uint32[] endDates) \n', '    {\n', '        startDates = new uint32[](STAGES);\n', '        endDates = new uint32[](STAGES);\n', '        \n', '        for(uint8 s = 0; s < STAGES; s++) {\n', '            startDates[s] = stages_[s].startDate;\n', '            endDates[s] = stages_[s].endDate;\n', '        }\n', '    }\n', '\n', '    /// returns data which genomes can be purchased at the stage\n', '    function stageGenomes(uint8 _stage)\n', '        public view returns(byte[])\n', '    {\n', '        byte[] memory genomes = new byte[](uint16(TOKENS_PER_STAGE) * 77);\n', '        uint32 gbIndex = 0;\n', '\n', '        for(uint8 tokenIndex = 0; tokenIndex < TOKENS_PER_STAGE; tokenIndex++) {\n', '            \n', '            bytes memory genomeBytes = bytes(genomes_[_stage][tokenIndex]);\n', '            \n', '            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\n', '                genomes[gbIndex++] = genomeBytes[gi];\n', '            }\n', '        }\n', '\n', '        return genomes;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', 'interface CommonWallet {\n', '    function receive() external payable;\n', '}\n', '\n', 'library StringUtils {\n', '    function concat(string _a, string _b)\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '\n', '        bytes memory bab = new bytes(_ba.length + _bb.length);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n', '        return string(bab);\n', '    }\n', '}\n', '\n', 'library UintStringUtils {\n', '    function toString(uint i)\n', '        internal\n', '        pure\n', '        returns (string)\n', '    {\n', "        if (i == 0) return '0';\n", '        uint j = i;\n', '        uint len;\n', '        while (j != 0){\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (i != 0){\n', '            bstr[k--] = byte(48 + i % 10);\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '}\n', '\n', '// @title AddressUtils\n', '// @dev Utility library of inline functions on addresses\n', 'library AddressUtils {\n', '    // Returns whether the target address is a contract\n', '    // @dev This function will return false if invoked during the constructor of a contract,\n', '    // as the code is not actually created until after the constructor finishes.\n', '    // @param addr address to check\n', '    // @return whether the target address is a contract\n', '    function isContract(address addr)\n', '        internal\n', '        view\n', '        returns(bool)\n', '    {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', ' // @title SafeMath256\n', ' // @dev Math operations with safety checks that throw on error\n', 'library SafeMath256 {\n', '\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath32 {\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'library SafeMath8 {\n', '  // @dev Multiplies two numbers, throws on overflow.\n', '  function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '\n', '  // @dev Integer division of two numbers, truncating the quotient.\n', '  function div(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint8 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '\n', '  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '\n', '  // @dev Adds two numbers, throws on overflow.\n', '  function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/// @title A facet of DragonCore that manages special access privileges.\n', 'contract DragonAccessControl \n', '{\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', '    /// @dev Contract owner\n', '    address internal controller_;\n', '\n', '    /// @dev Contract modes\n', '    enum Mode {TEST, PRESALE, OPERATE}\n', '\n', '    /// @dev Contract state\n', '    Mode internal mode_ = Mode.TEST;\n', '\n', "    /// @dev OffChain Server accounts ('minions') addresses\n", "    /// It's used for money withdrawal and export of tokens \n", '    mapping(address => bool) internal minions_;\n', '    \n', '    /// @dev Presale contract address. Can call `presale` method.\n', '    address internal presale_;\n', '\n', '    // Modifiers ---------------------------------------------------------------\n', '    /// @dev Limit execution to controller account only.\n', '    modifier controllerOnly() {\n', '        require(controller_ == msg.sender, "controller_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to minion account only.\n', '    modifier minionOnly() {\n', '        require(minions_[msg.sender], "minion_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to test time only.\n', '    modifier testModeOnly {\n', '        require(mode_ == Mode.TEST, "test_mode_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to presale time only.\n', '    modifier presaleModeOnly {\n', '        require(mode_ == Mode.PRESALE, "presale_mode_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Limit execution to operate time only.\n', '    modifier operateModeOnly {\n', '        require(mode_ == Mode.OPERATE, "operate_mode_only");\n', '        _;\n', '    }\n', '\n', '     /// @dev Limit execution to presale account only.\n', '    modifier presaleOnly() {\n', '        require(msg.sender == presale_, "presale_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev set state to Mode.OPERATE.\n', '    function setOperateMode()\n', '        external \n', '        controllerOnly\n', '        presaleModeOnly\n', '    {\n', '        mode_ = Mode.OPERATE;\n', '    }\n', '\n', '    /// @dev Set presale contract address. Becomes useless when presale is over.\n', '    /// @param _presale Presale contract address.\n', '    function setPresale(address _presale)\n', '        external\n', '        controllerOnly\n', '    {\n', '        presale_ = _presale;\n', '    }\n', '\n', '    /// @dev set state to Mode.PRESALE.\n', '    function setPresaleMode()\n', '        external\n', '        controllerOnly\n', '        testModeOnly\n', '    {\n', '        mode_ = Mode.PRESALE;\n', '    }    \n', '\n', '        /// @dev Get controller address.\n', "    /// @return Address of contract's controller.\n", '    function controller()\n', '        external\n', '        view\n', '        returns(address)\n', '    {\n', '        return controller_;\n', '    }\n', '\n', '    /// @dev Transfer control to new address. Set controller an approvee for\n', '    /// tokens that managed by contract itself. Remove previous controller value\n', "    /// from contract's approvees.\n", '    /// @param _to New controller address.\n', '    function setController(address _to)\n', '        external\n', '        controllerOnly\n', '    {\n', '        require(_to != NA, "_to");\n', '        require(controller_ != _to, "already_controller");\n', '\n', '        controller_ = _to;\n', '    }\n', '\n', '    /// @dev Check if address is a minion.\n', '    /// @param _addr Address to check.\n', '    /// @return True if address is a minion.\n', '    function isMinion(address _addr)\n', '        public view returns(bool)\n', '    {\n', '        return minions_[_addr];\n', '    }   \n', '\n', '    function getCurrentMode() \n', '        public view returns (Mode) \n', '    {\n', '        return mode_;\n', '    }    \n', '}\n', '\n', '/// @dev token description, storage and transfer functions\n', 'contract DragonBase is DragonAccessControl\n', '{\n', '    using SafeMath8 for uint8;\n', '    using SafeMath32 for uint32;\n', '    using SafeMath256 for uint256;\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;    \n', '\n', '    /// @dev The Birth event is fired whenever a new dragon comes into existence. \n', '    event Birth(address owner, uint256 petId, uint256 tokenId, uint256 parentA, uint256 parentB, string genes, string params);\n', '\n', '    /// @dev Token name\n', '    string internal name_;\n', '    /// @dev Token symbol\n', '    string internal symbol_;\n', '    /// @dev Token resolving url\n', '    string internal url_;\n', '\n', '    struct DragonToken {\n', '        // Constant Token params\n', '        uint8   genNum;  // generation number. uses for dragon view\n', '        string  genome;  // genome description\n', '        uint256 petId;   // offchain dragon identifier\n', '\n', '        // Parents\n', '        uint256 parentA;\n', '        uint256 parentB;\n', '\n', '        // Game-depening Token params\n', '        string  params;  // can change in export operation\n', '\n', '        // State\n', '        address owner; \n', '    }\n', '\n', '    /// @dev Count of minted tokens\n', '    uint256 internal mintCount_;\n', '    /// @dev Maximum token supply\n', '    uint256 internal maxSupply_;\n', '     /// @dev Count of burn tokens\n', '    uint256 internal burnCount_;\n', '\n', '    // Tokens state\n', '    /// @dev Token approvals values\n', '    mapping(uint256 => address) internal approvals_;\n', '    /// @dev Operator approvals\n', '    mapping(address => mapping(address => bool)) internal operatorApprovals_;\n', "    /// @dev Index of token in owner's token list\n", '    mapping(uint256 => uint256) internal ownerIndex_;\n', "    /// @dev Owner's tokens list\n", '    mapping(address => uint256[]) internal ownTokens_;\n', '    /// @dev Tokens\n', '    mapping(uint256 => DragonToken) internal tokens_;\n', '\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', "    /// @dev Add token to new owner. Increase owner's balance.\n", '    /// @param _to Token receiver.\n', '    /// @param _tokenId New token id.\n', '    function _addTo(address _to, uint256 _tokenId)\n', '        internal\n', '    {\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        require(token.owner == NA, "taken");\n', '\n', '        uint256 lastIndex = ownTokens_[_to].length;\n', '        ownTokens_[_to].push(_tokenId);\n', '        ownerIndex_[_tokenId] = lastIndex;\n', '\n', '        token.owner = _to;\n', '    }\n', '\n', '    /// @dev Create new token and increase mintCount.\n', "    /// @param _genome New token's genome.\n", '    /// @param _params Token params string. \n', '    /// @param _parentA Token A parent.\n', '    /// @param _parentB Token B parent.\n', '    /// @return New token id.\n', '    function _createToken(\n', '        address _to,\n', '        \n', '        // Constant Token params\n', '        uint8   _genNum,\n', '        string   _genome,\n', '        uint256 _parentA,\n', '        uint256 _parentB,\n', '        \n', '        // Game-depening Token params\n', '        uint256 _petId,\n', '        string   _params        \n', '    )\n', '        internal returns(uint256)\n', '    {\n', '        uint256 tokenId = mintCount_.add(1);\n', '        mintCount_ = tokenId;\n', '\n', '        DragonToken memory token = DragonToken(\n', '            _genNum,\n', '            _genome,\n', '            _petId,\n', '\n', '            _parentA,\n', '            _parentB,\n', '\n', '            _params,\n', '            NA\n', '        );\n', '        \n', '        tokens_[tokenId] = token;\n', '        \n', '        _addTo(_to, tokenId);\n', '        \n', '        emit Birth(_to, _petId, tokenId, _parentA, _parentB, _genome, _params);\n', '        \n', '        return tokenId;\n', '    }    \n', ' \n', '    /// @dev Get token genome.\n', '    /// @param _tokenId Token id.\n', "    /// @return Token's genome.\n", '    function getGenome(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return tokens_[_tokenId].genome;\n', '    }\n', '\n', '    /// @dev Get token params.\n', '    /// @param _tokenId Token id.\n', "    /// @return Token's params.\n", '    function getParams(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return tokens_[_tokenId].params;\n', '    }\n', '\n', '    /// @dev Get token parentA.\n', '    /// @param _tokenId Token id.\n', '    /// @return Parent token id.\n', '    function getParentA(uint256 _tokenId)\n', '        external view returns(uint256)\n', '    {\n', '        return tokens_[_tokenId].parentA;\n', '    }   \n', '\n', '    /// @dev Get token parentB.\n', '    /// @param _tokenId Token id.\n', '    /// @return Parent token id.\n', '    function getParentB(uint256 _tokenId)\n', '        external view returns(uint256)\n', '    {\n', '        return tokens_[_tokenId].parentB;\n', '    }\n', '\n', '    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\n', '    /// @param _tokenId Token id\n', '    /// @return Return true if token owner is real.\n', '    function isExisting(uint256 _tokenId)\n', '        public view returns(bool)\n', '    {\n', '        return tokens_[_tokenId].owner != NA;\n', '    }    \n', '\n', '    /// @dev Receive maxium token supply value.\n', '    /// @return Contracts `maxSupply_` variable.\n', '    function maxSupply()\n', '        external view returns(uint256)\n', '    {\n', '        return maxSupply_;\n', '    }\n', '\n', '    /// @dev Set url prefix for tokenURI generation.\n', '    /// @param _url Url prefix value.\n', '    function setUrl(string _url)\n', '        external controllerOnly\n', '    {\n', '        url_ = _url;\n', '    }\n', '\n', '    /// @dev Get token symbol.\n', '    /// @return Token symbol name.\n', '    function symbol()\n', '        external view returns(string)\n', '    {\n', '        return symbol_;\n', '    }\n', '\n', "    /// @dev Get token URI to receive offchain information by it's id.\n", '    /// @param _tokenId Token id.\n', '    /// @return URL string. For example "http://erc721.tld/tokens/1".\n', '    function tokenURI(uint256 _tokenId)\n', '        external view returns(string)\n', '    {\n', '        return url_.concat(_tokenId.toString());\n', '    }\n', '\n', '     /// @dev Get token name.\n', '    /// @return Token name string.\n', '    function name()\n', '        external view returns(string)\n', '    {\n', '        return name_;\n', '    }\n', '\n', '    /// @dev return information about _owner tokens\n', '    function getTokens(address _owner)\n', '        external view  returns (uint256[], uint256[], byte[]) \n', '    {\n', '        uint256[] memory tokens = ownTokens_[_owner];\n', '        uint256[] memory tokenIds = new uint256[](tokens.length);\n', '        uint256[] memory petIds = new uint256[](tokens.length);\n', '\n', '        byte[] memory genomes = new byte[](tokens.length * 77);\n', '        uint index = 0;\n', '\n', '        for(uint i = 0; i < tokens.length; i++) {\n', '            uint256 tokenId = tokens[i];\n', '            \n', '            DragonToken storage token = tokens_[tokenId];\n', '\n', '            tokenIds[i] = tokenId;\n', '            petIds[i] = token.petId;\n', '            \n', '            bytes storage genome = bytes(token.genome);\n', '            \n', '            for(uint j = 0; j < genome.length; j++) {\n', '                genomes[index++] = genome[j];\n', '            }\n', '        }\n', '        return (tokenIds, petIds, genomes);\n', '    }\n', '    \n', '}\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @dev See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721.sol\n', '\n', 'contract ERC721Basic \n', '{\n', '    /// @dev Emitted when token approvee is set\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n', '    /// @dev Emitted when owner approve all own tokens to operator.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    /// @dev Emitted when user deposit some funds.\n', '    event Deposit(address indexed _sender, uint256 _value);\n', '    /// @dev Emitted when user deposit some funds.\n', '    event Withdraw(address indexed _sender, uint256 _value);\n', '    /// @dev Emitted when token transferred to new owner\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n', '\n', '    // Required methods\n', '    function balanceOf(address _owner) external view returns (uint256 _balance);\n', '    function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '    function exists(uint256 _tokenId) public view returns (bool _exists);\n', '    \n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function getApproved(uint256 _tokenId) public view returns (address _to);\n', '\n', '    //function transfer(address _to, uint256 _tokenId) public;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '\n', '    function totalSupply() public view returns (uint256 total);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Metadata is ERC721Basic \n', '{\n', '    function name() external view returns (string _name);\n', '    function symbol() external view returns (string _symbol);\n', '    function tokenURI(uint256 _tokenId) external view returns (string);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721 asset contracts.\n', ' */\n', 'contract ERC721Receiver \n', '{\n', '  /**\n', '   * @dev Magic value to be returned upon successful reception of an NFT\n', '   *  Equals to `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`,\n', '   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n', '   */\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '  /**\n', '   * @notice Handle the receipt of an NFT\n', '   * @dev The ERC721 smart contract calls this function on the recipient\n', '   *  after a `safetransfer`. This function MAY throw to revert and reject the\n', '   *  transfer. This function MUST use 50,000 gas or less. Return of other\n', '   *  than the magic value MUST result in the transaction being reverted.\n', '   *  Note: the contract address is always the message sender.\n', '   * @param _from The sending address\n', '   * @param _tokenId The NFT identifier which is being transfered\n', '   * @param _data Additional data with no specified format\n', '   * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`\n', '   */\n', '    function onERC721Received(address _from, uint256 _tokenId, bytes _data )\n', '        public returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC721Basic, ERC721Metadata, ERC721Receiver \n', '{\n', '    /// @dev Interface signature 721 for interface detection.\n', '    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\n', '    /*\n', "    bytes4(keccak256('supportsInterface(bytes4)'));\n", '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\n', '    /*\n', "    bytes4(keccak256('totalSupply()')) ^\n", "    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "    bytes4(keccak256('tokenByIndex(uint256)'));\n", '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\n', '    /*\n', "    bytes4(keccak256('name()')) ^\n", "    bytes4(keccak256('symbol()')) ^\n", "    bytes4(keccak256('tokenURI(uint256)'));\n", '    */\n', '\n', '    bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\n', '    /*\n', "    bytes4(keccak256('balanceOf(address)')) ^\n", "    bytes4(keccak256('ownerOf(uint256)')) ^\n", "    bytes4(keccak256('approve(address,uint256)')) ^\n", "    bytes4(keccak256('getApproved(uint256)')) ^\n", "    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "    bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\n", '    */\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n', '    {\n', '        return ((_interfaceID == InterfaceSignature_ERC165)\n', '            || (_interfaceID == InterfaceSignature_ERC721)\n', '            || (_interfaceID == InterfaceSignature_ERC721Enumerable)\n', '            || (_interfaceID == InterfaceSignature_ERC721Metadata));\n', '    }    \n', '}\n', '\n', '/// @dev ERC721 methods\n', 'contract DragonOwnership is ERC721, DragonBase\n', '{\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;    \n', '    using AddressUtils for address;\n', '\n', '    /// @dev Emitted when token transferred to new owner. Additional fields is petId, genes, params\n', '    /// it uses for client-side indication\n', '    event TransferInfo(address indexed _from, address indexed _to, uint256 _tokenId, uint256 petId, string genes, string params);\n', '\n', '    /// @dev Specify if _addr is token owner or approvee. Also check if `_addr`\n', '    /// is operator for token owner.\n', '    /// @param _tokenId Token to check ownership of.\n', "    /// @param _addr Address to check if it's an owner or an aprovee of `_tokenId`.\n", '    /// @return True if token can be managed by provided `_addr`.\n', '    function isOwnerOrApproved(uint256 _tokenId, address _addr)\n', '        public view returns(bool)\n', '    {\n', '        DragonToken memory token = tokens_[_tokenId];\n', '\n', '        if (token.owner == _addr) {\n', '            return true;\n', '        }\n', '        else if (isApprovedFor(_tokenId, _addr)) {\n', '            return true;\n', '        }\n', '        else if (isApprovedForAll(token.owner, _addr)) {\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /// @dev Limit execution to token owner or approvee only.\n', '    /// @param _tokenId Token to check ownership of.\n', '    modifier ownerOrApprovedOnly(uint256 _tokenId) {\n', '        require(isOwnerOrApproved(_tokenId, msg.sender), "tokenOwnerOrApproved_only");\n', '        _;\n', '    }\n', '\n', "    /// @dev Contract's own token only acceptable.\n", "    /// @param _tokenId Contract's token id.\n", '    modifier ownOnly(uint256 _tokenId) {\n', '        require(tokens_[_tokenId].owner == address(this), "own_only");\n', '        _;\n', '    }\n', '\n', '    /// @dev Determine if token is approved for specified approvee.\n', '    /// @param _tokenId Target token id.\n', '    /// @param _approvee Approvee address.\n', '    /// @return True if so.\n', '    function isApprovedFor(uint256 _tokenId, address _approvee)\n', '        public view returns(bool)\n', '    {\n', '        return approvals_[_tokenId] == _approvee;\n', '    }\n', '\n', '    /// @dev Specify is given address set as operator with setApprovalForAll.\n', '    /// @param _owner Token owner.\n', '    /// @param _operator Address to check if it an operator.\n', '    /// @return True if operator is set.\n', '    function isApprovedForAll(address _owner, address _operator)\n', '        public view returns(bool)\n', '    {\n', '        return operatorApprovals_[_owner][_operator];\n', '    }\n', '\n', '    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\n', '    /// @param _tokenId Token id\n', '    /// @return Return true if token owner is real.\n', '    function exists(uint256 _tokenId)\n', '        public view returns(bool)\n', '    {\n', '        return tokens_[_tokenId].owner != NA;\n', '    }\n', '\n', '    /// @dev Get owner of a token.\n', '    /// @param _tokenId Token owner id.\n', '    /// @return Token owner address.\n', '    function ownerOf(uint256 _tokenId)\n', '        public view returns(address)\n', '    {\n', '        return tokens_[_tokenId].owner;\n', '    }\n', '\n', '    /// @dev Get approvee address. If there is not approvee returns 0x0.\n', '    /// @param _tokenId Token id to get approvee of.\n', '    /// @return Approvee address or 0x0.\n', '    function getApproved(uint256 _tokenId)\n', '        public view returns(address)\n', '    {\n', '        return approvals_[_tokenId];\n', '    }\n', '\n', '    /// @dev Grant owner alike controll permissions to third party.\n', '    /// @param _to Permission receiver.\n', '    /// @param _tokenId Granted token id.\n', '    function approve(address _to, uint256 _tokenId)\n', '        external ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        address owner = ownerOf(_tokenId);\n', '        require(_to != owner);\n', '\n', '        if (getApproved(_tokenId) != NA || _to != NA) {\n', '            approvals_[_tokenId] = _to;\n', '\n', '            emit Approval(owner, _to, _tokenId);\n', '        }\n', '    }\n', '\n', '    /// @dev Current total tokens supply. Always less then maxSupply.\n', '    /// @return Difference between minted and burned tokens.\n', '    function totalSupply()\n', '        public view returns(uint256)\n', '    {\n', '        return mintCount_;\n', '    }    \n', '\n', '    /// @dev Get number of tokens which `_owner` owns.\n', '    /// @param _owner Address to count own tokens.\n', '    /// @return Count of owned tokens.\n', '    function balanceOf(address _owner)\n', '        external view returns(uint256)\n', '    {\n', '        return ownTokens_[_owner].length;\n', '    }    \n', '\n', '    /// @dev Internal set approval for all without _owner check.\n', '    /// @param _owner Granting user.\n', '    /// @param _to New account approvee.\n', '    /// @param _approved Set new approvee status.\n', '    function _setApprovalForAll(address _owner, address _to, bool _approved)\n', '        internal\n', '    {\n', '        operatorApprovals_[_owner][_to] = _approved;\n', '\n', '        emit ApprovalForAll(_owner, _to, _approved);\n', '    }\n', '\n', '    /// @dev Set approval for all account tokens.\n', '    /// @param _to Approvee address.\n', '    /// @param _approved Value true or false.\n', '    function setApprovalForAll(address _to, bool _approved)\n', '        external\n', '    {\n', '        require(_to != msg.sender);\n', '\n', '        _setApprovalForAll(msg.sender, _to, _approved);\n', '    }\n', '\n', '    /// @dev Remove approval bindings for token. Do nothing if no approval\n', '    /// exists.\n', '    /// @param _from Address of token owner.\n', '    /// @param _tokenId Target token id.\n', '    function _clearApproval(address _from, uint256 _tokenId)\n', '        internal\n', '    {\n', '        if (approvals_[_tokenId] == NA) {\n', '            return;\n', '        }\n', '\n', '        approvals_[_tokenId] = NA;\n', '        emit Approval(_from, NA, _tokenId);\n', '    }\n', '\n', '    /// @dev Check if contract was received by other side properly if receiver\n', '    /// is a ctontract.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    /// @param _data Transaction data.\n', '    /// @return True on success.\n', '    function _checkAndCallSafeTransfer(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        internal returns(bool)\n', '    {\n', '        if (! _to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n', '            _from, _tokenId, _data\n', '        );\n', '\n', '        return (retval == ERC721_RECEIVED);\n', '    }\n', '\n', '    /// @dev Remove token from owner. Unrecoverable.\n', '    /// @param _tokenId Removing token id.\n', '    function _remove(uint256 _tokenId)\n', '        internal\n', '    {\n', '        address owner = tokens_[_tokenId].owner;\n', '        _removeFrom(owner, _tokenId);\n', '    }\n', '\n', '    /// @dev Completely remove token from the contract. Unrecoverable.\n', '    /// @param _owner Owner of removing token.\n', '    /// @param _tokenId Removing token id.\n', '    function _removeFrom(address _owner, uint256 _tokenId)\n', '        internal\n', '    {\n', '        uint256 lastIndex = ownTokens_[_owner].length.sub(1);\n', '        uint256 lastToken = ownTokens_[_owner][lastIndex];\n', '\n', '        // Swap users token\n', '        ownTokens_[_owner][ownerIndex_[_tokenId]] = lastToken;\n', '        ownTokens_[_owner].length--;\n', '\n', '        // Swap token indexes\n', '        ownerIndex_[lastToken] = ownerIndex_[_tokenId];\n', '        ownerIndex_[_tokenId] = 0;\n', '\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        token.owner = NA;\n', '    }\n', '\n', '    /// @dev Transfer token from owner `_from` to another address or contract\n', "    /// `_to` by it's `_tokenId`.\n", '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    function transferFrom( address _from, address _to, uint256 _tokenId )\n', '        public ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        require(_from != NA);\n', '        require(_to != NA);\n', '\n', '        _clearApproval(_from, _tokenId);\n', '        _removeFrom(_from, _tokenId);\n', '        _addTo(_to, _tokenId);\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '\n', '        DragonToken storage token = tokens_[_tokenId];\n', '        emit TransferInfo(_from, _to, _tokenId, token.petId, token.genome, token.params);\n', '    }\n', '\n', "    /// @dev Update token params and transfer to new owner. Only contract's own\n", '    /// tokens could be updated. Also notifies receiver of the token.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    function updateAndSafeTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params\n', '    )\n', '        public\n', '    {\n', '        updateAndSafeTransferFrom(_to, _tokenId, _params, "");\n', '    }\n', '\n', "    /// @dev Update token params and transfer to new owner. Only contract's own\n", '    /// tokens could be updated. Also notifies receiver of the token and send\n', '    /// protion of _data to it.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    /// @param _data Notification data.\n', '    function updateAndSafeTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params,\n', '        bytes _data\n', '    )\n', '        public\n', '    {\n', '        // Safe transfer from\n', '        updateAndTransferFrom(_to, _tokenId, _params, 0, 0);\n', '        require(_checkAndCallSafeTransfer(address(this), _to, _tokenId, _data));\n', '    }\n', '\n', "    /// @dev Update token params and transfer to new owner. Only contract's own\n", '    /// tokens could be updated.\n', '    /// @param _to Address to transfer token to.\n', '    /// @param _tokenId Id of token that should be transferred.\n', '    /// @param _params New token params.\n', '    function updateAndTransferFrom(\n', '        address _to,\n', '        uint256 _tokenId,\n', '        string _params,\n', '        uint256 _petId, \n', '        uint256 _transferCost\n', '    )\n', '        public\n', '        ownOnly(_tokenId)\n', '        minionOnly\n', '    {\n', '        require(bytes(_params).length > 0, "params_length");\n', '\n', '        // Update\n', '        tokens_[_tokenId].params = _params;\n', '        if (tokens_[_tokenId].petId == 0 ) {\n', '            tokens_[_tokenId].petId = _petId;\n', '        }\n', '\n', '        address from = tokens_[_tokenId].owner;\n', '\n', '        // Transfer from\n', '        transferFrom(from, _to, _tokenId);\n', '\n', "        // send to the server's wallet the transaction cost\n", '        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server        \n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '    }\n', '\n', '    /// @dev Transfer token from one owner to new one and check if it was\n', '    /// properly received if receiver is a contact.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    )\n', '        public\n', '    {\n', '        safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    /// @dev Transfer token from one owner to new one and check if it was\n', '    /// properly received if receiver is a contact.\n', '    /// @param _from Current token owner.\n', '    /// @param _to New token owner.\n', '    /// @param _tokenId token Id.\n', '    /// @param _data Transaction data.\n', '    function safeTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId,\n', '        bytes _data\n', '    )\n', '        public\n', '    {\n', '        transferFrom(_from, _to, _tokenId);\n', '        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n', '    }\n', '\n', '    /// @dev Burn owned token. Increases `burnCount_` and decrease `totalSupply`\n', '    /// value.\n', '    /// @param _tokenId Id of burning token.\n', '    function burn(uint256 _tokenId)\n', '        public\n', '        ownerOrApprovedOnly(_tokenId)\n', '    {\n', '        address owner = tokens_[_tokenId].owner;\n', '        _remove(_tokenId);\n', '\n', '        burnCount_ += 1;\n', '\n', '        emit Transfer(owner, NA, _tokenId);\n', '    }\n', '\n', '    /// @dev Receive count of burned tokens. Should be greater than `totalSupply`\n', '    /// but less than `mintCount`.\n', '    /// @return Number of burned tokens\n', '    function burnCount()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return burnCount_;\n', '    }\n', '\n', '    function onERC721Received(address, uint256, bytes)\n', '        public returns(bytes4) \n', '    {\n', '        return ERC721_RECEIVED;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title Managing contract. implements the logic of buying tokens, depositing / withdrawing funds \n', '/// to the project account and importing / exporting tokens\n', 'contract EtherDragonsCore is DragonOwnership \n', '{\n', '    using SafeMath8 for uint8;\n', '    using SafeMath32 for uint32;\n', '    using SafeMath256 for uint256;\n', '    using AddressUtils for address;\n', '    using StringUtils for string;\n', '    using UintStringUtils for uint;\n', '\n', '    // @dev Non Assigned address.\n', '    address constant NA = address(0);\n', '\n', '    /// @dev Bounty tokens count limit\n', '    uint256 public constant BOUNTY_LIMIT = 2500;\n', '    /// @dev Presale tokens count limit\n', '    uint256 public constant PRESALE_LIMIT = 7500;\n', '    ///@dev Total gen0tokens generation limit\n', '    uint256 public constant GEN0_CREATION_LIMIT = 90000;\n', '    \n', '    /// @dev Number of tokens minted in presale stage\n', '    uint256 internal presaleCount_;  \n', '    /// @dev Number of tokens minted for bounty campaign\n', '    uint256 internal bountyCount_;\n', '   \n', '    ///@dev Company bank address\n', '    address internal bank_;\n', '\n', '    // Extension ---------------------------------------------------------------\n', '\n', '    /// @dev Contract is not payable. To fullfil balance method `depositTo`\n', '    /// should be used.\n', '    function ()\n', '        public payable\n', '    {\n', '        revert();\n', '    }\n', '\n', '    /// @dev amount on the account of the contract. This amount consists of deposits  from players and the system reserve for payment of transactions\n', '    /// the player at any time to withdraw the amount corresponding to his account in the game, minus the cost of the transaction \n', '    function getBalance() \n', '        public view returns (uint256)\n', '    {\n', '        return address(this).balance;\n', '    }    \n', '\n', '    /// @dev at the moment of creation of the contract we transfer the address of the bank\n', '    /// presell contract address set later\n', '    constructor(\n', '        address _bank\n', '    )\n', '        public\n', '    {\n', '        require(_bank != NA);\n', '        \n', '        controller_ = msg.sender;\n', '        bank_ = _bank;\n', '        \n', '        // Meta\n', '        name_ = "EtherDragons";\n', '        symbol_ = "ED";\n', '        url_ = "https://game.etherdragons.world/token/";\n', '\n', '        // Token mint limit\n', '        maxSupply_ = GEN0_CREATION_LIMIT + BOUNTY_LIMIT + PRESALE_LIMIT;\n', '    }\n', '\n', '    /// Number of tokens minted in presale stage\n', '    function totalPresaleCount()\n', '        public view returns(uint256)\n', '    {\n', '        return presaleCount_;\n', '    }    \n', '\n', '    /// @dev Number of tokens minted for bounty campaign\n', '    function totalBountyCount()\n', '        public view returns(uint256)\n', '    {\n', '        return bountyCount_;\n', '    }    \n', '    \n', '    /// @dev Check if new token could be minted. Return true if count of minted\n', '    /// tokens less than could be minted through contract deploy.\n', '    /// Also, tokens can not be created more often than once in mintDelay_ minutes\n', '    /// @return True if current count is less then maximum tokens available for now.\n', '    function canMint()\n', '        public view returns(bool)\n', '    {\n', '        return (mintCount_ + presaleCount_ + bountyCount_) < maxSupply_;\n', '    }\n', '\n', '    /// @dev Here we write the addresses of the wallets of the server from which it is accessed\n', '    /// to contract methods.\n', '    /// @param _to New minion address\n', '    function minionAdd(address _to)\n', '        external controllerOnly\n', '    {\n', '        require(minions_[_to] == false, "already_minion");\n', '        \n', '        // разрешаем этому адресу пользоваться токенами контакта\n', '        // allow the address to use contract tokens \n', '        _setApprovalForAll(address(this), _to, true);\n', '        \n', '        minions_[_to] = true;\n', '    }\n', '\n', '    /// @dev delete the address of the server wallet\n', '    /// @param _to Minion address\n', '    function minionRemove(address _to)\n', '        external controllerOnly\n', '    {\n', '        require(minions_[_to], "not_a_minion");\n', '\n', '        // and forbid this wallet to use tokens of the contract\n', '        _setApprovalForAll(address(this), _to, false);\n', '        minions_[_to] = false;\n', '    }\n', '\n', '    /// @dev Here the player can put funds to the account of the contract\n', '    /// and get the same amount of in-game currency\n', '    /// the game server understands who puts money at the wallet address\n', '    function depositTo()\n', '        public payable\n', '    {\n', '        emit Deposit(msg.sender, msg.value);\n', '    }    \n', '    \n', '    /// @dev Transfer amount of Ethers to specified receiver. Only owner can\n', '    // call this method.\n', '    /// @param _to Transfer receiver.\n', '    /// @param _amount Transfer value.\n', '    /// @param _transferCost Transfer cost.\n', '    function transferAmount(address _to, uint256 _amount, uint256 _transferCost)\n', '        external minionOnly\n', '    {\n', '        require((_amount + _transferCost) <= address(this).balance, "not enough money!");\n', '        _to.transfer(_amount);\n', '\n', '        // send to the wallet of the server the transfer cost\n', '        // withdraw  it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server\n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '\n', '        emit Withdraw(_to, _amount);\n', '    }        \n', '\n', '   /// @dev Mint new token with specified params. Transfer `_fee` to the\n', '    /// `bank`. \n', '    /// @param _to New token owner.\n', '    /// @param _fee Transaction fee.\n', '    /// @param _genNum Generation number..\n', '    /// @param _genome New genome unique value.\n', '    /// @param _parentA Parent A.\n', '    /// @param _parentB Parent B.\n', '    /// @param _petId Pet identifier.\n', '    /// @param _params List of parameters for pet.\n', '    /// @param _transferCost Transfer cost.\n', '    /// @return New token id.\n', '    function mintRelease(\n', '        address _to,\n', '        uint256 _fee,\n', '        \n', '        // Constant Token params\n', '        uint8   _genNum,\n', '        string   _genome,\n', '        uint256 _parentA,\n', '        uint256 _parentB,\n', '        \n', '        // Game-depening Token params\n', '        uint256 _petId,  //if petID = 0, then it was created outside of the server\n', '        string   _params,\n', '        uint256 _transferCost\n', '    )\n', '        external minionOnly operateModeOnly returns(uint256)\n', '    {\n', '        require(canMint(), "can_mint");\n', '        require(_to != NA, "_to");\n', '        require((_fee + _transferCost) <= address(this).balance, "_fee");\n', '        require(bytes(_params).length != 0, "params_length");\n', '        require(bytes(_genome).length == 77, "genome_length");\n', '        \n', '        // Parents should be both 0 or both not.\n', '        if (_parentA != 0 && _parentB != 0) {\n', '            require(_parentA != _parentB, "same_parent");\n', '        }\n', '        else if (_parentA == 0 && _parentB != 0) {\n', '            revert("parentA_empty");\n', '        }\n', '        else if (_parentB == 0 && _parentA != 0) {\n', '            revert("parentB_empty");\n', '        }\n', '\n', '        uint256 tokenId = _createToken(_to, _genNum, _genome, _parentA, _parentB, _petId, _params);\n', '\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        // Transfer mint fee to the fund\n', '        CommonWallet(bank_).receive.value(_fee)();\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '\n', '        // send to the server wallet server the transfer cost,\n', '        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\n', '        // on the side of the game server\n', '        if (_transferCost > 0) {\n', '            msg.sender.transfer(_transferCost);\n', '        }\n', '\n', '        return tokenId;\n', '    }\n', '\n', '    /// @dev Create new token via presale state\n', '    /// @param _to New token owner.\n', '    /// @param _genome New genome unique value.\n', '    /// @return New token id.\n', '    /// at the pre-sale stage we sell the zero-generation pets, which have only a genome.\n', '    /// other attributes of such a token get when importing to the server\n', '    function mintPresell(address _to, string _genome)\n', '        external presaleOnly presaleModeOnly returns(uint256)\n', '    {\n', '        require(presaleCount_ < PRESALE_LIMIT, "presale_limit");\n', '\n', '        // у пресейл пета нет параметров. Их он получит после ввода в игру.\n', '        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, "");\n', '        presaleCount_ += 1;\n', '\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '        \n', '        return tokenId;\n', '    }    \n', '    \n', '    /// @dev Create new token for bounty activity\n', '    /// @param _to New token owner.\n', '    /// @return New token id.\n', '    function mintBounty(address _to, string _genome)\n', '        external controllerOnly returns(uint256)\n', '    {\n', '        require(bountyCount_ < BOUNTY_LIMIT, "bounty_limit");\n', '\n', '        // bounty pet has no parameters. They will receive them after importing to the game.\n', '        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, "");\n', '    \n', '        bountyCount_ += 1;\n', '        require(_checkAndCallSafeTransfer(NA, _to, tokenId, ""), "safe_transfer");\n', '\n', '        emit Transfer(NA, _to, tokenId);\n', '\n', '        return tokenId;\n', '    }        \n', '}\n', '\n', 'contract Presale\n', '{\n', '    // Extension ---------------------------------------------------------------\n', '    using AddressUtils for address;\n', '\n', '    // Events ------------------------------------------------------------------\n', '    ///the event is fired when starting a new wave presale stage\n', '    event StageBegin(uint8 stage, uint256 timestamp);\n', '\n', '    ///the event is fired when token sold\n', '    event TokensBought(address buyerAddr, uint256[] tokenIds, bytes genomes);\n', '\n', '    // Types -------------------------------------------------------------------\n', '    struct Stage {\n', '        // Predefined values\n', "        uint256 price;      // token's price on the stage\n", '        uint16 softcap;     // stage softCap\n', '        uint16 hardcap;     // stage hardCap\n', '        \n', '        // Unknown values\n', '        uint16 bought;      // sold on stage\n', "        uint32 startDate;   // stage's beginDate\n", "        uint32 endDate;     // stage's endDate\n", '    }\n', '    \n', '    // Constants ---------------------------------------------------------------\n', '    // 10 stages of 5 genocodes\n', '    uint8 public constant STAGES = 10;\n', '    uint8 internal constant TOKENS_PER_STAGE = 5;\n', '    address constant NA = address(0);\n', '    \n', '    // State -------------------------------------------------------------------\n', '    address internal CEOAddress;    // contract owner\n', '    address internal bank_;         // profit wallet address (not a contract)\n', '    address internal erc721_;       // main contract address\n', '    \n', '    /// @dev genomes for bounty stage\n', '    string[TOKENS_PER_STAGE][STAGES] internal genomes_;\n', '\n', '    /// stages data\n', '    Stage[STAGES] internal stages_;\n', '    \n', '    // internal transaction counter, it uses for random generator\n', '    uint32  internal counter_;\n', '    \n', '    /// stage is over\n', '    bool    internal isOver_;\n', '\n', '    /// stage number\n', '    uint8   internal stageIndex_;\n', '\n', '    ///  stage start Data\n', '    uint32  internal stageStart_;\n', '\n', '    // Lifetime ----------------------------------------------------------------\n', '    constructor(\n', '        address _bank,  \n', '        address _erc721\n', '    )\n', '        public\n', '    {\n', "        require(_bank != NA, '_bank');\n", "        require(_erc721.isContract(), '_erc721');\n", '\n', '        CEOAddress = msg.sender;\n', '\n', '        // Addresses should not be the same.\n', '        require(_bank != CEOAddress, "bank = CEO");\n', '        require(CEOAddress != _erc721, "CEO = erc721");\n', '        require(_erc721 != _bank, "bank = erc721");\n', '\n', '        // Update state\n', '        bank_ = _bank;\n', '        erc721_ = _erc721;\n', '       \n', '        // stages data \n', '        stages_[0].price = 10 finney;\n', '        stages_[0].softcap = 100;\n', '        stages_[0].hardcap = 300;\n', '        \n', '        stages_[1].price = 20 finney;\n', '        stages_[1].softcap = 156;\n', '        stages_[1].hardcap = 400;\n', '    \n', '        stages_[2].price = 32 finney;\n', '        stages_[2].softcap = 212;\n', '        stages_[2].hardcap = 500;\n', '        \n', '        stages_[3].price = 45 finney;\n', '        stages_[3].softcap = 268;\n', '        stages_[3].hardcap = 600;\n', '        \n', '        stages_[4].price = 58 finney;\n', '        stages_[4].softcap = 324;\n', '        stages_[4].hardcap = 700;\n', '    \n', '        stages_[5].price = 73 finney;\n', '        stages_[5].softcap = 380;\n', '        stages_[5].hardcap = 800;\n', '    \n', '        stages_[6].price = 87 finney;\n', '        stages_[6].softcap = 436;\n', '        stages_[6].hardcap = 900;\n', '    \n', '        stages_[7].price = 102 finney;\n', '        stages_[7].softcap = 492;\n', '        stages_[7].hardcap = 1000;\n', '    \n', '        stages_[8].price = 118 finney;\n', '        stages_[8].softcap = 548;\n', '        stages_[8].hardcap = 1100;\n', '        \n', '        stages_[9].price = 129 finney;\n', '        stages_[9].softcap = 604;\n', '        stages_[9].hardcap = 1200;\n', '    }\n', '\n', '    /// fill the genomes data\n', '    function setStageGenomes(\n', '        uint8 _stage,\n', '        string _genome0, \n', '        string _genome1,\n', '        string _genome2, \n', '        string _genome3, \n', '        string _genome4\n', '    ) \n', '        external controllerOnly\n', '    {\n', '        genomes_[_stage][0] = _genome0;\n', '        genomes_[_stage][1] = _genome1;\n', '        genomes_[_stage][2] = _genome2;\n', '        genomes_[_stage][3] = _genome3;\n', '        genomes_[_stage][4] = _genome4;\n', '    }\n', '\n', '    /// @dev Contract itself is non payable\n', '    function ()\n', '        public payable\n', '    {\n', '        revert();\n', '    }\n', '    \n', '    // Modifiers ---------------------------------------------------------------\n', '    \n', '    /// only from contract owner\n', '    modifier controllerOnly() {\n', "        require(msg.sender == CEOAddress, 'controller_only');\n", '        _;\n', '    }\n', '\n', '    /// only for active stage\n', '    modifier notOverOnly() {\n', "        require(isOver_ == false, 'notOver_only');\n", '        _;\n', '    }\n', '\n', '    // Getters -----------------------------------------------------------------\n', '    /// owner address\n', '    function getCEOAddress()\n', '        public view returns(address)\n', '    {\n', '        return CEOAddress;\n', '    }\n', '\n', '    /// counter from random number generator\n', '    function counter()\n', '        internal view returns(uint32)\n', '    {\n', '        return counter_;\n', '    }\n', '\n', '    // tokens sold by stage ...\n', '    function stageTokensBought(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].bought;\n', '    }\n', '\n', '    // stage softcap\n', '    function stageSoftcap(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].softcap;\n', '    }\n', '\n', '    /// stage hardcap\n', '    function stageHardcap(uint8 _stage)\n', '        public view returns(uint16)\n', '    {\n', '        return stages_[_stage].hardcap;\n', '    }\n', '\n', '    /// stage Start Date    \n', '    function stageStartDate(uint8 _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].startDate;\n', '    }\n', '    \n', '    /// stage Finish Date\n', '    function stageEndDate(uint8 _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].endDate;\n', '    }\n', '\n', '    /// stage token price\n', '    function stagePrice(uint _stage)\n', '        public view returns(uint)\n', '    {\n', '        return stages_[_stage].price;\n', '    }\n', '    \n', '    // Genome Logic -----------------------------------------------------------------\n', '    /// within the prelase , the dragons are generated, which are the ancestors of the destiny\n', '    /// newborns have a high chance of mutation and are unlikely to be purebred\n', '    /// the player will have to collect the breed, crossing a lot of pets\n', '    /// In addition, you will need to pick up combat abilities\n', '    /// these characteristics are assigned to the pet when the dragon is imported to the game server.    \n', '    function nextGenome()\n', '        internal returns(string)\n', '    {\n', '        uint8 n = getPseudoRandomNumber();\n', '\n', '        counter_ += 1;\n', '        \n', '        return genomes_[stageIndex_][n];\n', '    }\n', '\n', '    function getPseudoRandomNumber()\n', '        internal view returns(uint8 index)\n', '    {\n', '        uint8 n = uint8(\n', '            keccak256(abi.encode(msg.sender, block.timestamp + counter_))\n', '        );\n', '        return n % TOKENS_PER_STAGE;\n', '    }\n', '    \n', '    // PreSale Logic -----------------------------------------------------------------\n', '    /// Presale stage0 begin date set\n', '    /// presale start is possible only once    \n', '    function setStartDate(uint32 _startDate)\n', '        external controllerOnly\n', '    {\n', "        require(stages_[0].startDate == 0, 'already_set');\n", '        \n', '        stages_[0].startDate = _startDate;\n', '        stageStart_ = _startDate;\n', '        stageIndex_ = 0;\n', '        \n', '        emit StageBegin(stageIndex_, stageStart_); \n', '    }\n', '\n', '    /// current stage number\n', '    /// switches to the next stage if the time has come\n', '    function stageIndex()\n', '        external view returns(uint8)\n', '    {\n', '        Stage memory stage = stages_[stageIndex_];\n', '\n', '        if (stage.endDate > 0 && stage.endDate <= now) {\n', '            return stageIndex_ + 1;\n', '        }\n', '        else {\n', '            return stageIndex_;\n', '        }\n', '    }\n', '    \n', '    /// check whether the phase started\n', '    /// switch to the next stage, if necessary    \n', '    function beforeBuy()\n', '        internal\n', '    {\n', '        if (stageStart_ == 0) {\n', "            revert('presale_not_started');\n", '        }\n', '        else if (stageStart_ > now) {\n', "            revert('stage_not_started');\n", '        }\n', '\n', '        Stage memory stage = stages_[stageIndex_];\n', '        if (stage.endDate > 0 && stage.endDate <= now) \n', '        {\n', '            stageIndex_ += 1;\n', '            stageStart_ = stages_[stageIndex_].startDate;\n', '\n', '            if (stageStart_ > now) {\n', "                revert('stage_not_started');\n", '            }\n', '        }\n', '    }\n', '    \n', '    /// time to next midnight\n', '    function midnight()\n', '        public view returns(uint32)\n', '    {\n', '        uint32 tomorrow = uint32(now + 1 days);\n', '        uint32 remain = uint32(tomorrow % 1 days);\n', '        return tomorrow - remain;\n', '    }\n', '    \n', '    /// buying a specified number of tokens\n', '    function buyTokens(uint16 numToBuy)\n', '        public payable notOverOnly returns(uint256[])\n', '    {\n', '        beforeBuy();\n', '        \n', '        require(numToBuy > 0 && numToBuy <= 10, "numToBuy error");\n', '\n', '        Stage storage stage = stages_[stageIndex_];\n', "        require((stage.price * numToBuy) <= msg.value, 'price');\n", '        \n', '        uint16 prevBought = stage.bought;\n', '        require(prevBought + numToBuy <= stage.hardcap, "have required tokens");\n', '        \n', '        stage.bought += numToBuy;\n', '        uint256[] memory tokenIds = new uint256[](numToBuy);\n', '        \n', '        bytes memory genomes = new bytes(numToBuy * 77);\n', '        uint32 genomeByteIndex = 0;\n', '\n', '        for(uint16 t = 0; t < numToBuy; t++) \n', '        {\n', '            string memory genome = nextGenome();\n', '            uint256 tokenId = EtherDragonsCore(erc721_).mintPresell(msg.sender, genome);\n', '\n', '            bytes memory genomeBytes = bytes(genome);\n', '            \n', '            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\n', '                genomes[genomeByteIndex++] = genomeBytes[gi];\n', '            }\n', '\n', '            tokenIds[t] = tokenId;\n', '        }\n', '\n', '        // Transfer mint fee to the fund\n', '        bank_.transfer(address(this).balance);\n', '\n', '        if (stage.bought == stage.hardcap) {\n', '            stage.endDate = uint32(now);\n', '            stageStart_ = midnight() + 1 days + 1 seconds;\n', '            if (stageIndex_ < STAGES - 1) {\n', '                stageIndex_ += 1;\n', '            }\n', '            else {\n', '                isOver_ = true;\n', '            }\n', '        }\n', '        else if (stage.bought >= stage.softcap && prevBought < stage.softcap) {\n', '            stage.endDate = midnight() + 1 days;\n', '            if (stageIndex_ < STAGES - 1) {\n', '                stages_[stageIndex_ + 1].startDate = stage.endDate + 1 days;\n', '            }\n', '        }\n', '\n', '        emit TokensBought(msg.sender, tokenIds, genomes);\n', '\n', '        return tokenIds;\n', '    }\n', '\n', '    function currTime()\n', '        public view returns(uint)\n', '    {\n', '        return now;\n', '    }\n', '    \n', '    /// stages data\n', '    function getStagesInfo() \n', '        public view returns (uint256[] prices, uint16[] softcaps, uint16[] hardcaps, uint16[] boughts) \n', '    {\n', '            prices = new uint256[](STAGES);\n', '            softcaps = new uint16[](STAGES);\n', '            hardcaps = new uint16[](STAGES);\n', '            boughts = new uint16[](STAGES);\n', '            \n', '            for(uint8 s = 0; s < STAGES; s++) {\n', '                prices[s] = stages_[s].price;\n', '                softcaps[s] = stages_[s].softcap;\n', '                hardcaps[s] = stages_[s].hardcap;\n', '                boughts[s] = stages_[s].bought;\n', '            }\n', '    }\n', '    \n', '    /// stages dates data\n', '    function getStagesBeginEnd() \n', '        public view returns (uint32[] startDates, uint32[] endDates) \n', '    {\n', '        startDates = new uint32[](STAGES);\n', '        endDates = new uint32[](STAGES);\n', '        \n', '        for(uint8 s = 0; s < STAGES; s++) {\n', '            startDates[s] = stages_[s].startDate;\n', '            endDates[s] = stages_[s].endDate;\n', '        }\n', '    }\n', '\n', '    /// returns data which genomes can be purchased at the stage\n', '    function stageGenomes(uint8 _stage)\n', '        public view returns(byte[])\n', '    {\n', '        byte[] memory genomes = new byte[](uint16(TOKENS_PER_STAGE) * 77);\n', '        uint32 gbIndex = 0;\n', '\n', '        for(uint8 tokenIndex = 0; tokenIndex < TOKENS_PER_STAGE; tokenIndex++) {\n', '            \n', '            bytes memory genomeBytes = bytes(genomes_[_stage][tokenIndex]);\n', '            \n', '            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\n', '                genomes[gbIndex++] = genomeBytes[gi];\n', '            }\n', '        }\n', '\n', '        return genomes;\n', '    }\n', '}']
