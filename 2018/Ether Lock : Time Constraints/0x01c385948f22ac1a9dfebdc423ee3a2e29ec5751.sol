['pragma solidity ^0.4.13;\n', '\n', 'interface IFlyDropTokenMgr {\n', '    // Send tokens to other multi addresses in one function\n', '    function prepare(uint256 _rand,\n', '                     address _from,\n', '                     address _token,\n', '                     uint256 _value) external returns (bool);\n', '\n', '    // Send tokens to other multi addresses in one function\n', '    function flyDrop(address[] _destAddrs, uint256[] _values) external returns (uint256);\n', '\n', '    // getter to determine if address has poweruser role\n', '    function isPoweruser(address _addr) external view returns (bool);\n', '}\n', '\n', 'interface ILockedStorage {\n', '    // get frozen status for the _wallet address\n', '    function frozenAccounts(address _wallet) external view returns (bool);\n', '\n', '    // get a wallet address by the account address and the index\n', '    function isExisted(address _wallet) external view returns (bool);\n', '\n', '    // get a wallet name by the account address and the index\n', '    function walletName(address _wallet) external view returns (string);\n', '\n', '    // get the frozen amount of the account address\n', '    function frozenAmount(address _wallet) external view returns (uint256);\n', '\n', '    // get the balance of the account address\n', '    function balanceOf(address _wallet) external view returns (uint256);\n', '\n', '    // get the account address by index\n', '    function addressByIndex(uint256 _ind) external view returns (address);\n', '\n', '    // get the number of the locked stage of the target address\n', '    function lockedStagesNum(address _target) external view returns (uint256);\n', '\n', '    // get the endtime of the locked stages of an account\n', '    function endTimeOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain unrleased tokens of the locked stages of an account\n', '    function remainOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain unrleased tokens of the locked stages of an account\n', '    function amountOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain releasing period end time of an account\n', '    function releaseEndTimeOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the frozen amount of the account address\n', '    function size() external view returns (uint256);\n', '\n', '    // add one account address for that wallet\n', '    function addAccount(address _wallet, string _name, uint256 _value) external returns (bool);\n', '\n', '    // add a time record of one account\n', '    function addLockedTime(address _target,\n', '                           uint256 _value,\n', '                           uint256 _frozenEndTime,\n', '                           uint256 _releasePeriod) external returns (bool);\n', '\n', '    // freeze or release the tokens that has been locked in the account address.\n', '    function freezeTokens(address _wallet, bool _freeze, uint256 _value) external returns (bool);\n', '\n', '    // increase balance of this account address\n', '    function increaseBalance(address _wallet, uint256 _value) external returns (bool);\n', '\n', '    // decrease balance of this account address\n', '    function decreaseBalance(address _wallet, uint256 _value) external returns (bool);\n', '\n', '    // remove account contract address from storage\n', '    function removeAccount(address _wallet) external returns (bool);\n', '\n', '    // remove a time records from the time records list of one account\n', '    function removeLockedTime(address _target, uint _ind) external returns (bool);\n', '\n', '    // set the new endtime of the released time of an account\n', '    function changeEndTime(address _target, uint256 _ind, uint256 _newEndTime) external returns (bool);\n', '\n', '    // set the new released period end time of an account\n', '    function setNewReleaseEndTime(address _target, uint256 _ind, uint256 _newReleaseEndTime) external returns (bool);\n', '\n', '    // decrease the remaining locked amount of an account\n', '    function decreaseRemainLockedOf(address _target, uint256 _ind, uint256 _value) external returns (bool);\n', '\n', '    // withdraw tokens from this contract\n', '    function withdrawToken(address _token, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    // Gas optimization: this is cheaper than asserting &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract DelayedClaimable is Claimable {\n', '\n', '  uint256 public end;\n', '  uint256 public start;\n', '\n', '  /**\n', '   * @dev Used to specify the time period during which a pending\n', '   * owner can claim ownership.\n', '   * @param _start The earliest time ownership can be claimed.\n', '   * @param _end The latest time ownership can be claimed.\n', '   */\n', '  function setLimits(uint256 _start, uint256 _end) public onlyOwner {\n', '    require(_start <= _end);\n', '    end = _end;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\n', '   * the specified start and end time.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    require((block.number <= end) && (block.number >= start));\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '    end = 0;\n', '  }\n', '\n', '}\n', '\n', 'contract OwnerContract is DelayedClaimable {\n', '    Claimable public ownedContract;\n', '    address public pendingOwnedOwner;\n', '    // address internal origOwner;\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        // origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        if (ownedContract.owner() != address(this)) {\n', '            ownedContract.claimOwnership();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one.\n', '     *\n', '     */\n', '    // function transferOwnershipBack() onlyOwner public {\n', '    //     ownedContract.transferOwnership(origOwner);\n', '    //     ownedContract = Claimable(address(0));\n', '    //     origOwner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnershipto(address _nextOwner)  onlyOwner public {\n', '        require(ownedContract != address(0));\n', '\n', '        if (ownedContract.owner() != pendingOwnedOwner) {\n', '            ownedContract.transferOwnership(_nextOwner);\n', '            pendingOwnedOwner = _nextOwner;\n', '            // ownedContract = Claimable(address(0));\n', '            // origOwner = address(0);\n', '        } else {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev to confirm the owner of the owned contract has already been transferred.\n', '     *\n', '     */\n', '    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\n', '        require(ownedContract != address(0));\n', '        if (ownedContract.owner() == pendingOwnedOwner) {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReleaseAndLockToken is OwnerContract {\n', '    using SafeMath for uint256;\n', '\n', '    ILockedStorage lockedStorage;\n', '    IFlyDropTokenMgr flyDropMgr;\n', '    // ERC20 public erc20tk;\n', '    mapping (address => uint256) preReleaseAmounts;\n', '\n', '    event ReleaseFunds(address indexed _target, uint256 _amount);\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the LockedStorage contract address that will be binded by this Owner Contract\n', '     * @param _flyDropContract the flydrop contract for transfer tokens from the fixed main accounts\n', '     */\n', '    function initialize(address _contract, address _flyDropContract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        require(_flyDropContract != address(0));\n', '\n', '        require(super.bindContract(_contract));\n', '        lockedStorage = ILockedStorage(_contract);\n', '        flyDropMgr = IFlyDropTokenMgr(_flyDropContract);\n', '        // erc20tk = ERC20(_tk);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * judge whether we need to release some of the locked token\n', '     *\n', '     */\n', '    function needRelease() public view returns (bool) {\n', '        uint256 len = lockedStorage.size();\n', '        uint256 i = 0;\n', '        while (i < len) {\n', '            address frozenAddr = lockedStorage.addressByIndex(i);\n', '            uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\n', '            uint256 j = 0;\n', '            while (j < timeRecLen) {\n', '                if (now >= lockedStorage.endTimeOfStage(frozenAddr, j)) {\n', '                    return true;\n', '                }\n', '\n', '                j = j.add(1);\n', '            }\n', '\n', '            i = i.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev judge whether we need to release the locked token of the target address\n', '     * @param _target the owner of the amount of tokens\n', '     *\n', '     */\n', '    function needReleaseFor(address _target) public view returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            if (now >= lockedStorage.endTimeOfStage(_target, j)) {\n', '                return true;\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev freeze the amount of tokens of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _name the user name of the _target\n', '     * @param _value the amount of the tokens\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function freeze(address _target, string _name, uint256 _value, uint256 _frozenEndTime, uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        //require(_tokenAddr != address(0));\n', '        require(_target != address(0));\n', '        require(_value > 0);\n', '        require(_frozenEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            lockedStorage.addAccount(_target, _name, _value); // add new account\n', '        }\n', '\n', '        // each time the new locked time will be added to the backend\n', '        require(lockedStorage.addLockedTime(_target, _value, _frozenEndTime, _releasePeriod));\n', '        require(lockedStorage.freezeTokens(_target, true, _value));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer an amount of tokens to an account, and then freeze the tokens\n', '     *\n', '     * @param _target the account address that will hold an amount of the tokens\n', '     * @param _name the user name of the _target\n', '     * @param _from the tokens holder who will transfer the tokens to target address\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _value the amount of the tokens which has been transferred\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function transferAndFreeze(address _target,\n', '                               string _name,\n', '                               address _from,\n', '                               address _tk,\n', '                               uint256 _value,\n', '                               uint256 _frozenEndTime,\n', '                               uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        require(_from != address(0));\n', '        require(_target != address(0));\n', '        require(_value > 0);\n', '        require(_frozenEndTime > 0);\n', '\n', '        // check firstly that the allowance of this contract has been set\n', '        // require(owned.allowance(msg.sender, this) > 0);\n', '        uint rand = now % 6 + 7; // random number between 7 to 12\n', '        require(flyDropMgr.prepare(rand, _from, _tk, _value));\n', '\n', '        // now we need transfer the funds before freeze them\n', '        // require(owned.transferFrom(msg.sender, lockedStorage, _value));\n', '        address[] memory dests = new address[](1);\n', '        dests[0] = address(lockedStorage);\n', '        uint256[] memory amounts = new uint256[](1);\n', '        amounts[0] = _value;\n', '        require(flyDropMgr.flyDrop(dests, amounts) >= 1);\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            require(lockedStorage.addAccount(_target, _name, _value));\n', '        } else {\n', '            require(lockedStorage.increaseBalance(_target, _value));\n', '        }\n', '\n', '        // freeze the account after transfering funds\n', '        require(freeze(_target, _name, _value, _frozenEndTime, _releasePeriod));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer an amount of tokens to an account, and then freeze the tokens\n', '     *\n', '     * @param _target the account address that will hold an amount of the tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _value the amount of the tokens which has been transferred\n', '     */\n', '    function releaseTokens(address _target, address _tk, uint256 _value) internal {\n', '        require(lockedStorage.withdrawToken(_tk, _target, _value));\n', '        require(lockedStorage.freezeTokens(_target, false, _value));\n', '        require(lockedStorage.decreaseBalance(_target, _value));\n', '    }\n', '\n', '    /**\n', '     * @dev release the token which are locked for once and will be total released at once\n', '     * after the end point of the lock period\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseAllOnceLock(address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        uint256 len = lockedStorage.size();\n', '        uint256 i = 0;\n', '        while (i < len) {\n', '            address target = lockedStorage.addressByIndex(i);\n', '            if (lockedStorage.lockedStagesNum(target) == 1\n', '                && lockedStorage.endTimeOfStage(target, 0) == lockedStorage.releaseEndTimeOfStage(target, 0)\n', '                && lockedStorage.endTimeOfStage(target, 0) > 0\n', '                && now >= lockedStorage.endTimeOfStage(target, 0)) {\n', '                uint256 releasedAmount = lockedStorage.amountOfStage(target, 0);\n', '\n', '                // remove current release period time record\n', '                if (!lockedStorage.removeLockedTime(target, 0)) {\n', '                    return false;\n', '                }\n', '\n', '                // remove the froze account\n', '                if (!lockedStorage.removeAccount(target)) {\n', '                    return false;\n', '                }\n', '\n', '                releaseTokens(target, _tk, releasedAmount);\n', '                emit ReleaseFunds(target, releasedAmount);\n', '                len = len.sub(1);\n', '            } else {\n', '                // no account has been removed\n', '                i = i.add(1);\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account, which only have only one locked time\n', '     * and don&#39;t have release stage.\n', '     *\n', '     * @param _target the account address that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseAccount(address _target, address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        if (lockedStorage.lockedStagesNum(_target) == 1\n', '            && lockedStorage.endTimeOfStage(_target, 0) == lockedStorage.releaseEndTimeOfStage(_target, 0)\n', '            && lockedStorage.endTimeOfStage(_target, 0) > 0\n', '            && now >= lockedStorage.endTimeOfStage(_target, 0)) {\n', '            uint256 releasedAmount = lockedStorage.amountOfStage(_target, 0);\n', '\n', '            // remove current release period time record\n', '            if (!lockedStorage.removeLockedTime(_target, 0)) {\n', '                return false;\n', '            }\n', '\n', '            // remove the froze account\n', '            if (!lockedStorage.removeAccount(_target)) {\n', '                return false;\n', '            }\n', '\n', '            releaseTokens(_target, _tk, releasedAmount);\n', '            emit ReleaseFunds(_target, releasedAmount);\n', '        }\n', '\n', '        // if the account are not locked for once, we will do nothing here\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account with several stages\n', '     * this need the contract get approval from the account by call approve() in the token contract\n', '     *\n', '     * @param _target the account address that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseWithStage(address _target, address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        address frozenAddr = _target;\n', '        if (!lockedStorage.isExisted(frozenAddr)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\n', '        bool released = false;\n', '        uint256 nowTime = now;\n', '        for (uint256 j = 0; j < timeRecLen; released = false) {\n', '            // iterate every time records to caculate how many tokens need to be released.\n', '            uint256 endTime = lockedStorage.endTimeOfStage(frozenAddr, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(frozenAddr, j);\n', '            uint256 amount = lockedStorage.amountOfStage(frozenAddr, j);\n', '            uint256 remain = lockedStorage.remainOfStage(frozenAddr, j);\n', '            if (nowTime > endTime && endTime > 0 && releasedEndTime > endTime) {\n', '                uint256 lastReleased = amount.sub(remain);\n', '                uint256 value = (amount * nowTime.sub(endTime) / releasedEndTime.sub(endTime)).sub(lastReleased);\n', '\n', '                if (value > remain) {\n', '                    value = remain;\n', '                }\n', '                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, value);\n', '                emit ReleaseFunds(_target, value);\n', '\n', '                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(value);\n', '                if (lockedStorage.remainOfStage(frozenAddr, j) < 1e8) {\n', '                    if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\n', '                        return false;\n', '                    }\n', '                    released = true;\n', '                    timeRecLen = timeRecLen.sub(1);\n', '                }\n', '            } else if (nowTime >= endTime && endTime > 0 && releasedEndTime == endTime) {\n', '                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, remain);\n', '                emit ReleaseFunds(frozenAddr, amount);\n', '                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(amount);\n', '                if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\n', '                    return false;\n', '                }\n', '                released = true;\n', '                timeRecLen = timeRecLen.sub(1);\n', '            }\n', '\n', '            if (!released) {\n', '                j = j.add(1);\n', '            }\n', '        }\n', '\n', '        // we got some amount need to be released\n', '        if (preReleaseAmounts[frozenAddr] > 0) {\n', '            releaseTokens(frozenAddr, _tk, preReleaseAmounts[frozenAddr]);\n', '\n', '            // set the pre-release amount to 0 for next time\n', '            preReleaseAmounts[frozenAddr] = 0;\n', '        }\n', '\n', '        // if all the frozen amounts had been released, then unlock the account finally\n', '        if (lockedStorage.lockedStagesNum(frozenAddr) == 0) {\n', '            if (!lockedStorage.removeAccount(frozenAddr)) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new endtime of the released time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _oldEndTime the original endtime for the lock period, unit is second\n', '     * @param _oldDuration the original duration time for the released period, unit is second\n', '     * @param _newEndTime the new endtime for the lock period\n', '     */\n', '    function setNewEndtime(address _target, uint256 _oldEndTime, uint256 _oldDuration, uint256 _newEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_oldEndTime > 0 && _newEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\n', '            uint256 duration = releasedEndTime.sub(endTime);\n', '            if (_oldEndTime == endTime && _oldDuration == duration) {\n', '                bool res = lockedStorage.changeEndTime(_target, j, _newEndTime);\n', '                res = lockedStorage.setNewReleaseEndTime(_target, j, _newEndTime.add(duration)) && res;\n', '                return res;\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new released period length of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _origEndTime the original endtime for the lock period\n', '     * @param _origDuration the original duration time for the released period, unit is second\n', '     * @param _newDuration the new releasing period\n', '     */\n', '    function setNewReleasePeriod(address _target, uint256 _origEndTime, uint256 _origDuration, uint256 _newDuration) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_origEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\n', '            if (_origEndTime == endTime && _origDuration == releasedEndTime.sub(endTime)) {\n', '                return lockedStorage.setNewReleaseEndTime(_target, j, _origEndTime.add(_newDuration));\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev get the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     */\n', '    function getLockedStages(address _target) public view returns (uint) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.lockedStagesNum(_target);\n', '    }\n', '\n', '    /**\n', '     * @dev get the endtime of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getEndTimeOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.endTimeOfStage(_target, _num);\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getRemainOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.remainOfStage(_target, _num);\n', '    }\n', '\n', '    /**\n', '     * @dev get total remain locked tokens of an account\n', '     *\n', '     * @param _account the owner of some amount of tokens\n', '     */\n', '    function getRemainLockedOf(address _account) public view returns (uint256) {\n', '        require(_account != address(0));\n', '\n', '        uint256 totalRemain = 0;\n', '        if(lockedStorage.isExisted(_account)) {\n', '            uint256 timeRecLen = lockedStorage.lockedStagesNum(_account);\n', '            uint256 j = 0;\n', '            while (j < timeRecLen) {\n', '                totalRemain = totalRemain.add(lockedStorage.remainOfStage(_account, j));\n', '                j = j.add(1);\n', '            }\n', '        }\n', '\n', '        return totalRemain;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain releasing period of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getRemainReleaseTimeOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        uint256 nowTime = now;\n', '        uint256 releaseEndTime = lockedStorage.releaseEndTimeOfStage(_target, _num);\n', '\n', '        if (releaseEndTime == 0 || releaseEndTime < nowTime) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 endTime = lockedStorage.endTimeOfStage(_target, _num);\n', '        if (releaseEndTime == endTime || nowTime <= endTime ) {\n', '            return (releaseEndTime.sub(endTime));\n', '        }\n', '\n', '        return (releaseEndTime.sub(nowTime));\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by a number of accounts\n', '     *\n', '     * @param _targets the accounts list that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseMultiAccounts(address[] _targets, address _tk) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '\n', '        bool res = false;\n', '        uint256 i = 0;\n', '        while (i < _targets.length) {\n', '            res = releaseAccount(_targets[i], _tk) || res;\n', '            i = i.add(1);\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account\n', '     *\n', '     * @param _targets the account addresses list that hold amounts of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseMultiWithStage(address[] _targets, address _tk) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '\n', '        bool res = false;\n', '        uint256 i = 0;\n', '        while (i < _targets.length) {\n', '            res = releaseWithStage(_targets[i], _tk) || res; // as long as there is one true transaction, then the result will be true\n', '            i = i.add(1);\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev convert bytes32 stream to string\n', '     *\n', '     * @param _b32 the bytes32 that hold a string in content\n', '     */\n', '    function bytes32ToString(bytes32 _b32) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(_b32) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '\n', '     /**\n', '     * @dev freeze multiple of the accounts\n', '     *\n', '     * @param _targets the owners of some amount of tokens\n', '     * @param _names the user names of the _targets\n', '     * @param _values the amounts of the tokens\n', '     * @param _frozenEndTimes the list of the end time of the lock period, unit is second\n', '     * @param _releasePeriods the list of the locking period, unit is second\n', '     */\n', '    function freezeMulti(address[] _targets, bytes32[] _names, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '        require(_names.length != 0);\n', '        require(_values.length != 0);\n', '        require(_frozenEndTimes.length != 0);\n', '        require(_releasePeriods.length != 0);\n', '        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\n', '\n', '        bool res = true;\n', '        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\n', '            // as long as one transaction failed, then the result will be failure\n', '            res = freeze(_targets[i], bytes32ToString(_names[i]), _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer a list of amounts of tokens to a list of accounts, and then freeze the tokens\n', '     *\n', '     * @param _targets the account addresses that will hold a list of amounts of the tokens\n', '     * @param _names the user names of the _targets\n', '     * @param _from the tokens holder who will transfer the tokens to target address\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _values the amounts of the tokens which have been transferred\n', '     * @param _frozenEndTimes the end time list of the locked periods, unit is second\n', '     * @param _releasePeriods the list of locking periods, unit is second\n', '     */\n', '    function transferAndFreezeMulti(address[] _targets, bytes32[] _names, address _from, address _tk, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '        require(_names.length != 0);\n', '        require(_values.length != 0);\n', '        require(_frozenEndTimes.length != 0);\n', '        require(_releasePeriods.length != 0);\n', '        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\n', '\n', '        bool res = true;\n', '        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\n', '            // as long as one transaction failed, then the result will be failure\n', '            res = transferAndFreeze(_targets[i], bytes32ToString(_names[i]), _from, _tk, _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\n', '        }\n', '\n', '        return res;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'interface IFlyDropTokenMgr {\n', '    // Send tokens to other multi addresses in one function\n', '    function prepare(uint256 _rand,\n', '                     address _from,\n', '                     address _token,\n', '                     uint256 _value) external returns (bool);\n', '\n', '    // Send tokens to other multi addresses in one function\n', '    function flyDrop(address[] _destAddrs, uint256[] _values) external returns (uint256);\n', '\n', '    // getter to determine if address has poweruser role\n', '    function isPoweruser(address _addr) external view returns (bool);\n', '}\n', '\n', 'interface ILockedStorage {\n', '    // get frozen status for the _wallet address\n', '    function frozenAccounts(address _wallet) external view returns (bool);\n', '\n', '    // get a wallet address by the account address and the index\n', '    function isExisted(address _wallet) external view returns (bool);\n', '\n', '    // get a wallet name by the account address and the index\n', '    function walletName(address _wallet) external view returns (string);\n', '\n', '    // get the frozen amount of the account address\n', '    function frozenAmount(address _wallet) external view returns (uint256);\n', '\n', '    // get the balance of the account address\n', '    function balanceOf(address _wallet) external view returns (uint256);\n', '\n', '    // get the account address by index\n', '    function addressByIndex(uint256 _ind) external view returns (address);\n', '\n', '    // get the number of the locked stage of the target address\n', '    function lockedStagesNum(address _target) external view returns (uint256);\n', '\n', '    // get the endtime of the locked stages of an account\n', '    function endTimeOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain unrleased tokens of the locked stages of an account\n', '    function remainOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain unrleased tokens of the locked stages of an account\n', '    function amountOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the remain releasing period end time of an account\n', '    function releaseEndTimeOfStage(address _target, uint _ind) external view returns (uint256);\n', '\n', '    // get the frozen amount of the account address\n', '    function size() external view returns (uint256);\n', '\n', '    // add one account address for that wallet\n', '    function addAccount(address _wallet, string _name, uint256 _value) external returns (bool);\n', '\n', '    // add a time record of one account\n', '    function addLockedTime(address _target,\n', '                           uint256 _value,\n', '                           uint256 _frozenEndTime,\n', '                           uint256 _releasePeriod) external returns (bool);\n', '\n', '    // freeze or release the tokens that has been locked in the account address.\n', '    function freezeTokens(address _wallet, bool _freeze, uint256 _value) external returns (bool);\n', '\n', '    // increase balance of this account address\n', '    function increaseBalance(address _wallet, uint256 _value) external returns (bool);\n', '\n', '    // decrease balance of this account address\n', '    function decreaseBalance(address _wallet, uint256 _value) external returns (bool);\n', '\n', '    // remove account contract address from storage\n', '    function removeAccount(address _wallet) external returns (bool);\n', '\n', '    // remove a time records from the time records list of one account\n', '    function removeLockedTime(address _target, uint _ind) external returns (bool);\n', '\n', '    // set the new endtime of the released time of an account\n', '    function changeEndTime(address _target, uint256 _ind, uint256 _newEndTime) external returns (bool);\n', '\n', '    // set the new released period end time of an account\n', '    function setNewReleaseEndTime(address _target, uint256 _ind, uint256 _newReleaseEndTime) external returns (bool);\n', '\n', '    // decrease the remaining locked amount of an account\n', '    function decreaseRemainLockedOf(address _target, uint256 _ind, uint256 _value) external returns (bool);\n', '\n', '    // withdraw tokens from this contract\n', '    function withdrawToken(address _token, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0));\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'contract DelayedClaimable is Claimable {\n', '\n', '  uint256 public end;\n', '  uint256 public start;\n', '\n', '  /**\n', '   * @dev Used to specify the time period during which a pending\n', '   * owner can claim ownership.\n', '   * @param _start The earliest time ownership can be claimed.\n', '   * @param _end The latest time ownership can be claimed.\n', '   */\n', '  function setLimits(uint256 _start, uint256 _end) public onlyOwner {\n', '    require(_start <= _end);\n', '    end = _end;\n', '    start = _start;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer, as long as it is called within\n', '   * the specified start and end time.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    require((block.number <= end) && (block.number >= start));\n', '    emit OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '    end = 0;\n', '  }\n', '\n', '}\n', '\n', 'contract OwnerContract is DelayedClaimable {\n', '    Claimable public ownedContract;\n', '    address public pendingOwnedOwner;\n', '    // address internal origOwner;\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the contract address that will be binded by this Owner Contract\n', '     */\n', '    function bindContract(address _contract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        ownedContract = Claimable(_contract);\n', '        // origOwner = ownedContract.owner();\n', '\n', '        // take ownership of the owned contract\n', '        if (ownedContract.owner() != address(this)) {\n', '            ownedContract.claimOwnership();\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to the original one.\n', '     *\n', '     */\n', '    // function transferOwnershipBack() onlyOwner public {\n', '    //     ownedContract.transferOwnership(origOwner);\n', '    //     ownedContract = Claimable(address(0));\n', '    //     origOwner = address(0);\n', '    // }\n', '\n', '    /**\n', '     * @dev change the owner of the contract from this contract address to another one.\n', '     *\n', '     * @param _nextOwner the contract address that will be next Owner of the original Contract\n', '     */\n', '    function changeOwnershipto(address _nextOwner)  onlyOwner public {\n', '        require(ownedContract != address(0));\n', '\n', '        if (ownedContract.owner() != pendingOwnedOwner) {\n', '            ownedContract.transferOwnership(_nextOwner);\n', '            pendingOwnedOwner = _nextOwner;\n', '            // ownedContract = Claimable(address(0));\n', '            // origOwner = address(0);\n', '        } else {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev to confirm the owner of the owned contract has already been transferred.\n', '     *\n', '     */\n', '    function ownedOwnershipTransferred() onlyOwner public returns (bool) {\n', '        require(ownedContract != address(0));\n', '        if (ownedContract.owner() == pendingOwnedOwner) {\n', '            // the pending owner has already taken the ownership\n', '            ownedContract = Claimable(address(0));\n', '            pendingOwnedOwner = address(0);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReleaseAndLockToken is OwnerContract {\n', '    using SafeMath for uint256;\n', '\n', '    ILockedStorage lockedStorage;\n', '    IFlyDropTokenMgr flyDropMgr;\n', '    // ERC20 public erc20tk;\n', '    mapping (address => uint256) preReleaseAmounts;\n', '\n', '    event ReleaseFunds(address indexed _target, uint256 _amount);\n', '\n', '    /**\n', '     * @dev bind a contract as its owner\n', '     *\n', '     * @param _contract the LockedStorage contract address that will be binded by this Owner Contract\n', '     * @param _flyDropContract the flydrop contract for transfer tokens from the fixed main accounts\n', '     */\n', '    function initialize(address _contract, address _flyDropContract) onlyOwner public returns (bool) {\n', '        require(_contract != address(0));\n', '        require(_flyDropContract != address(0));\n', '\n', '        require(super.bindContract(_contract));\n', '        lockedStorage = ILockedStorage(_contract);\n', '        flyDropMgr = IFlyDropTokenMgr(_flyDropContract);\n', '        // erc20tk = ERC20(_tk);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * judge whether we need to release some of the locked token\n', '     *\n', '     */\n', '    function needRelease() public view returns (bool) {\n', '        uint256 len = lockedStorage.size();\n', '        uint256 i = 0;\n', '        while (i < len) {\n', '            address frozenAddr = lockedStorage.addressByIndex(i);\n', '            uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\n', '            uint256 j = 0;\n', '            while (j < timeRecLen) {\n', '                if (now >= lockedStorage.endTimeOfStage(frozenAddr, j)) {\n', '                    return true;\n', '                }\n', '\n', '                j = j.add(1);\n', '            }\n', '\n', '            i = i.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev judge whether we need to release the locked token of the target address\n', '     * @param _target the owner of the amount of tokens\n', '     *\n', '     */\n', '    function needReleaseFor(address _target) public view returns (bool) {\n', '        require(_target != address(0));\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            if (now >= lockedStorage.endTimeOfStage(_target, j)) {\n', '                return true;\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev freeze the amount of tokens of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _name the user name of the _target\n', '     * @param _value the amount of the tokens\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function freeze(address _target, string _name, uint256 _value, uint256 _frozenEndTime, uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        //require(_tokenAddr != address(0));\n', '        require(_target != address(0));\n', '        require(_value > 0);\n', '        require(_frozenEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            lockedStorage.addAccount(_target, _name, _value); // add new account\n', '        }\n', '\n', '        // each time the new locked time will be added to the backend\n', '        require(lockedStorage.addLockedTime(_target, _value, _frozenEndTime, _releasePeriod));\n', '        require(lockedStorage.freezeTokens(_target, true, _value));\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer an amount of tokens to an account, and then freeze the tokens\n', '     *\n', '     * @param _target the account address that will hold an amount of the tokens\n', '     * @param _name the user name of the _target\n', '     * @param _from the tokens holder who will transfer the tokens to target address\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _value the amount of the tokens which has been transferred\n', '     * @param _frozenEndTime the end time of the lock period, unit is second\n', '     * @param _releasePeriod the locking period, unit is second\n', '     */\n', '    function transferAndFreeze(address _target,\n', '                               string _name,\n', '                               address _from,\n', '                               address _tk,\n', '                               uint256 _value,\n', '                               uint256 _frozenEndTime,\n', '                               uint256 _releasePeriod) onlyOwner public returns (bool) {\n', '        require(_from != address(0));\n', '        require(_target != address(0));\n', '        require(_value > 0);\n', '        require(_frozenEndTime > 0);\n', '\n', '        // check firstly that the allowance of this contract has been set\n', '        // require(owned.allowance(msg.sender, this) > 0);\n', '        uint rand = now % 6 + 7; // random number between 7 to 12\n', '        require(flyDropMgr.prepare(rand, _from, _tk, _value));\n', '\n', '        // now we need transfer the funds before freeze them\n', '        // require(owned.transferFrom(msg.sender, lockedStorage, _value));\n', '        address[] memory dests = new address[](1);\n', '        dests[0] = address(lockedStorage);\n', '        uint256[] memory amounts = new uint256[](1);\n', '        amounts[0] = _value;\n', '        require(flyDropMgr.flyDrop(dests, amounts) >= 1);\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            require(lockedStorage.addAccount(_target, _name, _value));\n', '        } else {\n', '            require(lockedStorage.increaseBalance(_target, _value));\n', '        }\n', '\n', '        // freeze the account after transfering funds\n', '        require(freeze(_target, _name, _value, _frozenEndTime, _releasePeriod));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer an amount of tokens to an account, and then freeze the tokens\n', '     *\n', '     * @param _target the account address that will hold an amount of the tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _value the amount of the tokens which has been transferred\n', '     */\n', '    function releaseTokens(address _target, address _tk, uint256 _value) internal {\n', '        require(lockedStorage.withdrawToken(_tk, _target, _value));\n', '        require(lockedStorage.freezeTokens(_target, false, _value));\n', '        require(lockedStorage.decreaseBalance(_target, _value));\n', '    }\n', '\n', '    /**\n', '     * @dev release the token which are locked for once and will be total released at once\n', '     * after the end point of the lock period\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseAllOnceLock(address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        uint256 len = lockedStorage.size();\n', '        uint256 i = 0;\n', '        while (i < len) {\n', '            address target = lockedStorage.addressByIndex(i);\n', '            if (lockedStorage.lockedStagesNum(target) == 1\n', '                && lockedStorage.endTimeOfStage(target, 0) == lockedStorage.releaseEndTimeOfStage(target, 0)\n', '                && lockedStorage.endTimeOfStage(target, 0) > 0\n', '                && now >= lockedStorage.endTimeOfStage(target, 0)) {\n', '                uint256 releasedAmount = lockedStorage.amountOfStage(target, 0);\n', '\n', '                // remove current release period time record\n', '                if (!lockedStorage.removeLockedTime(target, 0)) {\n', '                    return false;\n', '                }\n', '\n', '                // remove the froze account\n', '                if (!lockedStorage.removeAccount(target)) {\n', '                    return false;\n', '                }\n', '\n', '                releaseTokens(target, _tk, releasedAmount);\n', '                emit ReleaseFunds(target, releasedAmount);\n', '                len = len.sub(1);\n', '            } else {\n', '                // no account has been removed\n', '                i = i.add(1);\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account, which only have only one locked time\n', "     * and don't have release stage.\n", '     *\n', '     * @param _target the account address that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseAccount(address _target, address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        if (lockedStorage.lockedStagesNum(_target) == 1\n', '            && lockedStorage.endTimeOfStage(_target, 0) == lockedStorage.releaseEndTimeOfStage(_target, 0)\n', '            && lockedStorage.endTimeOfStage(_target, 0) > 0\n', '            && now >= lockedStorage.endTimeOfStage(_target, 0)) {\n', '            uint256 releasedAmount = lockedStorage.amountOfStage(_target, 0);\n', '\n', '            // remove current release period time record\n', '            if (!lockedStorage.removeLockedTime(_target, 0)) {\n', '                return false;\n', '            }\n', '\n', '            // remove the froze account\n', '            if (!lockedStorage.removeAccount(_target)) {\n', '                return false;\n', '            }\n', '\n', '            releaseTokens(_target, _tk, releasedAmount);\n', '            emit ReleaseFunds(_target, releasedAmount);\n', '        }\n', '\n', '        // if the account are not locked for once, we will do nothing here\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account with several stages\n', '     * this need the contract get approval from the account by call approve() in the token contract\n', '     *\n', '     * @param _target the account address that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseWithStage(address _target, address _tk) onlyOwner public returns (bool) {\n', '        require(_tk != address(0));\n', '\n', '        address frozenAddr = _target;\n', '        if (!lockedStorage.isExisted(frozenAddr)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(frozenAddr);\n', '        bool released = false;\n', '        uint256 nowTime = now;\n', '        for (uint256 j = 0; j < timeRecLen; released = false) {\n', '            // iterate every time records to caculate how many tokens need to be released.\n', '            uint256 endTime = lockedStorage.endTimeOfStage(frozenAddr, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(frozenAddr, j);\n', '            uint256 amount = lockedStorage.amountOfStage(frozenAddr, j);\n', '            uint256 remain = lockedStorage.remainOfStage(frozenAddr, j);\n', '            if (nowTime > endTime && endTime > 0 && releasedEndTime > endTime) {\n', '                uint256 lastReleased = amount.sub(remain);\n', '                uint256 value = (amount * nowTime.sub(endTime) / releasedEndTime.sub(endTime)).sub(lastReleased);\n', '\n', '                if (value > remain) {\n', '                    value = remain;\n', '                }\n', '                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, value);\n', '                emit ReleaseFunds(_target, value);\n', '\n', '                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(value);\n', '                if (lockedStorage.remainOfStage(frozenAddr, j) < 1e8) {\n', '                    if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\n', '                        return false;\n', '                    }\n', '                    released = true;\n', '                    timeRecLen = timeRecLen.sub(1);\n', '                }\n', '            } else if (nowTime >= endTime && endTime > 0 && releasedEndTime == endTime) {\n', '                lockedStorage.decreaseRemainLockedOf(frozenAddr, j, remain);\n', '                emit ReleaseFunds(frozenAddr, amount);\n', '                preReleaseAmounts[frozenAddr] = preReleaseAmounts[frozenAddr].add(amount);\n', '                if (!lockedStorage.removeLockedTime(frozenAddr, j)) {\n', '                    return false;\n', '                }\n', '                released = true;\n', '                timeRecLen = timeRecLen.sub(1);\n', '            }\n', '\n', '            if (!released) {\n', '                j = j.add(1);\n', '            }\n', '        }\n', '\n', '        // we got some amount need to be released\n', '        if (preReleaseAmounts[frozenAddr] > 0) {\n', '            releaseTokens(frozenAddr, _tk, preReleaseAmounts[frozenAddr]);\n', '\n', '            // set the pre-release amount to 0 for next time\n', '            preReleaseAmounts[frozenAddr] = 0;\n', '        }\n', '\n', '        // if all the frozen amounts had been released, then unlock the account finally\n', '        if (lockedStorage.lockedStagesNum(frozenAddr) == 0) {\n', '            if (!lockedStorage.removeAccount(frozenAddr)) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new endtime of the released time of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _oldEndTime the original endtime for the lock period, unit is second\n', '     * @param _oldDuration the original duration time for the released period, unit is second\n', '     * @param _newEndTime the new endtime for the lock period\n', '     */\n', '    function setNewEndtime(address _target, uint256 _oldEndTime, uint256 _oldDuration, uint256 _newEndTime) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_oldEndTime > 0 && _newEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\n', '            uint256 duration = releasedEndTime.sub(endTime);\n', '            if (_oldEndTime == endTime && _oldDuration == duration) {\n', '                bool res = lockedStorage.changeEndTime(_target, j, _newEndTime);\n', '                res = lockedStorage.setNewReleaseEndTime(_target, j, _newEndTime.add(duration)) && res;\n', '                return res;\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev set the new released period length of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _origEndTime the original endtime for the lock period\n', '     * @param _origDuration the original duration time for the released period, unit is second\n', '     * @param _newDuration the new releasing period\n', '     */\n', '    function setNewReleasePeriod(address _target, uint256 _origEndTime, uint256 _origDuration, uint256 _newDuration) onlyOwner public returns (bool) {\n', '        require(_target != address(0));\n', '        require(_origEndTime > 0);\n', '\n', '        if (!lockedStorage.isExisted(_target)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 timeRecLen = lockedStorage.lockedStagesNum(_target);\n', '        uint256 j = 0;\n', '        while (j < timeRecLen) {\n', '            uint256 endTime = lockedStorage.endTimeOfStage(_target, j);\n', '            uint256 releasedEndTime = lockedStorage.releaseEndTimeOfStage(_target, j);\n', '            if (_origEndTime == endTime && _origDuration == releasedEndTime.sub(endTime)) {\n', '                return lockedStorage.setNewReleaseEndTime(_target, j, _origEndTime.add(_newDuration));\n', '            }\n', '\n', '            j = j.add(1);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev get the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     */\n', '    function getLockedStages(address _target) public view returns (uint) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.lockedStagesNum(_target);\n', '    }\n', '\n', '    /**\n', '     * @dev get the endtime of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getEndTimeOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.endTimeOfStage(_target, _num);\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain unrleased tokens of the locked stages of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getRemainOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        return lockedStorage.remainOfStage(_target, _num);\n', '    }\n', '\n', '    /**\n', '     * @dev get total remain locked tokens of an account\n', '     *\n', '     * @param _account the owner of some amount of tokens\n', '     */\n', '    function getRemainLockedOf(address _account) public view returns (uint256) {\n', '        require(_account != address(0));\n', '\n', '        uint256 totalRemain = 0;\n', '        if(lockedStorage.isExisted(_account)) {\n', '            uint256 timeRecLen = lockedStorage.lockedStagesNum(_account);\n', '            uint256 j = 0;\n', '            while (j < timeRecLen) {\n', '                totalRemain = totalRemain.add(lockedStorage.remainOfStage(_account, j));\n', '                j = j.add(1);\n', '            }\n', '        }\n', '\n', '        return totalRemain;\n', '    }\n', '\n', '    /**\n', '     * @dev get the remain releasing period of an account\n', '     *\n', '     * @param _target the owner of some amount of tokens\n', '     * @param _num the stage number of the releasing period\n', '     */\n', '    function getRemainReleaseTimeOfStage(address _target, uint _num) public view returns (uint256) {\n', '        require(_target != address(0));\n', '\n', '        uint256 nowTime = now;\n', '        uint256 releaseEndTime = lockedStorage.releaseEndTimeOfStage(_target, _num);\n', '\n', '        if (releaseEndTime == 0 || releaseEndTime < nowTime) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 endTime = lockedStorage.endTimeOfStage(_target, _num);\n', '        if (releaseEndTime == endTime || nowTime <= endTime ) {\n', '            return (releaseEndTime.sub(endTime));\n', '        }\n', '\n', '        return (releaseEndTime.sub(nowTime));\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by a number of accounts\n', '     *\n', '     * @param _targets the accounts list that hold an amount of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseMultiAccounts(address[] _targets, address _tk) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '\n', '        bool res = false;\n', '        uint256 i = 0;\n', '        while (i < _targets.length) {\n', '            res = releaseAccount(_targets[i], _tk) || res;\n', '            i = i.add(1);\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev release the locked tokens owned by an account\n', '     *\n', '     * @param _targets the account addresses list that hold amounts of locked tokens\n', '     * @param _tk the erc20 token need to be transferred\n', '     */\n', '    function releaseMultiWithStage(address[] _targets, address _tk) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '\n', '        bool res = false;\n', '        uint256 i = 0;\n', '        while (i < _targets.length) {\n', '            res = releaseWithStage(_targets[i], _tk) || res; // as long as there is one true transaction, then the result will be true\n', '            i = i.add(1);\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev convert bytes32 stream to string\n', '     *\n', '     * @param _b32 the bytes32 that hold a string in content\n', '     */\n', '    function bytes32ToString(bytes32 _b32) internal pure returns (string) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(_b32) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '\n', '     /**\n', '     * @dev freeze multiple of the accounts\n', '     *\n', '     * @param _targets the owners of some amount of tokens\n', '     * @param _names the user names of the _targets\n', '     * @param _values the amounts of the tokens\n', '     * @param _frozenEndTimes the list of the end time of the lock period, unit is second\n', '     * @param _releasePeriods the list of the locking period, unit is second\n', '     */\n', '    function freezeMulti(address[] _targets, bytes32[] _names, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '        require(_names.length != 0);\n', '        require(_values.length != 0);\n', '        require(_frozenEndTimes.length != 0);\n', '        require(_releasePeriods.length != 0);\n', '        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\n', '\n', '        bool res = true;\n', '        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\n', '            // as long as one transaction failed, then the result will be failure\n', '            res = freeze(_targets[i], bytes32ToString(_names[i]), _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * @dev transfer a list of amounts of tokens to a list of accounts, and then freeze the tokens\n', '     *\n', '     * @param _targets the account addresses that will hold a list of amounts of the tokens\n', '     * @param _names the user names of the _targets\n', '     * @param _from the tokens holder who will transfer the tokens to target address\n', '     * @param _tk the erc20 token need to be transferred\n', '     * @param _values the amounts of the tokens which have been transferred\n', '     * @param _frozenEndTimes the end time list of the locked periods, unit is second\n', '     * @param _releasePeriods the list of locking periods, unit is second\n', '     */\n', '    function transferAndFreezeMulti(address[] _targets, bytes32[] _names, address _from, address _tk, uint256[] _values, uint256[] _frozenEndTimes, uint256[] _releasePeriods) onlyOwner public returns (bool) {\n', '        require(_targets.length != 0);\n', '        require(_names.length != 0);\n', '        require(_values.length != 0);\n', '        require(_frozenEndTimes.length != 0);\n', '        require(_releasePeriods.length != 0);\n', '        require(_targets.length == _names.length && _names.length == _values.length && _values.length == _frozenEndTimes.length && _frozenEndTimes.length == _releasePeriods.length);\n', '\n', '        bool res = true;\n', '        for (uint256 i = 0; i < _targets.length; i = i.add(1)) {\n', '            // as long as one transaction failed, then the result will be failure\n', '            res = transferAndFreeze(_targets[i], bytes32ToString(_names[i]), _from, _tk, _values[i], _frozenEndTimes[i], _releasePeriods[i]) && res;\n', '        }\n', '\n', '        return res;\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}']
