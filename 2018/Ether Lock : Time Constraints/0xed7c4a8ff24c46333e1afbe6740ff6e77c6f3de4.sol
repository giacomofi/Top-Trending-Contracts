['pragma solidity ^0.4.18;\n', '\n', '//https://github.com/OpenZeppelin/zeppelin-solIdity/blob/master/contracts/math/SafeMath.sol\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // SolIdity automatically throws when divIding by 0\n', '    // uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return a / b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract EtherTool { \n', '    using   SafeMath for uint256;     \n', '\n', '    function EtherTool()  public {\n', '    }\n', '\n', '    bool public globalLocked = false;     \n', '\n', '    function lock() internal {            \n', '        require(!globalLocked);\n', '        globalLocked = true;\n', '    }\n', '\n', '    function unLock() internal {\n', '        require(globalLocked);\n', '        globalLocked = false;\n', '    }    \n', '\n', '    mapping (address => uint256) public userEtherOf;    \n', '    \n', '    function depositEther() public payable {\n', '        if (msg.value > 0){\n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);  \n', '        }\n', '    }\n', '    \n', '    function withdrawEther() public  returns(bool _result) {                  \n', '        return _withdrawEther(msg.sender);\n', '    }\n', '    \n', '    function withdrawEtherTo(address _user) public returns(bool _result) {     \n', '        return _withdrawEther(_user);\n', '    }\n', '\n', '    function _withdrawEther(address _to) internal returns(bool _result) {     \n', '        require (_to != 0x0);  \n', '        lock();\n', '        uint256 amount = userEtherOf[msg.sender];   \n', '        if(amount > 0) {\n', '            userEtherOf[msg.sender] = 0;\n', '            _to.transfer(amount); \n', '            _result = true;\n', '        }\n', '        else {\n', '            _result = false;\n', '        }\n', '        unLock();\n', '    }\n', '    \n', '    uint public currentEventId = 1;                                    \n', '\n', '    function getEventId() internal returns(uint _result) {           \n', '        _result = currentEventId;\n', '        currentEventId ++;\n', '    }\n', '\n', '    event OnTransfer(address indexed _sender, address indexed _to, bool indexed _done, uint256 _amount, uint _eventTime, uint eventId);\n', '\n', '    function batchTransfer1(address[] _tos, uint256 _amount) public payable returns (uint256 _doneNum){\n', '        lock();\n', '        if(msg.value > 0) {          \n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '        }\n', '        require(_amount > 0);\n', '        require(_tos.length > 0);\n', '\n', '        _doneNum = 0;\n', '        for(uint i = 0; i < _tos.length; i++){\n', '            bool done = false;\n', '            address to = _tos[i];\n', '            if(to != 0x0 && userEtherOf[msg.sender] >= _amount){\n', '                userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(_amount);\n', '                to.transfer(_amount);                                            \n', '                _doneNum = _doneNum.add(1);\n', '                done = true;\n', '            }\n', '            emit OnTransfer(msg.sender, to, done, _amount, now, getEventId());\n', '        }\n', '        unLock();\n', '    }\n', '\n', '    function batchTransfer2(address[] _tos, uint256[] _amounts) public payable returns (uint256 _doneNum){\n', '        lock();\n', '        if(msg.value > 0) {          \n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '        }\n', '        require(_amounts.length > 0);\n', '        require(_tos.length > 0);\n', '        require(_tos.length == _amounts.length);\n', '\n', '        _doneNum = 0;\n', '        for(uint i = 0; i < _tos.length; i++){\n', '            bool done = false;\n', '            address to = _tos[i];\n', '            uint256 amount = _amounts[i]; \n', '            if((to != 0x0) && (amount > 0) && (userEtherOf[msg.sender] >= amount)){\n', '                userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(amount);\n', '                to.transfer(amount);                                            \n', '                _doneNum = _doneNum.add(1);\n', '                done = true;\n', '            }\n', '            emit OnTransfer(msg.sender, to, done, amount, now, getEventId());\n', '        }\n', '        unLock();\n', '    }\n', '        \n', '    function uint8ToString(uint8 v) private pure returns (string)\n', '    {\n', '        uint maxlength = 8;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '        uint remainder = v % 10;\n', '        v = v / 10;\n', '        reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i);\n', '        for (uint j = 0; j < i; j++) {\n', '        s[j] = reversed[i - j - 1];\n', '        }\n', '        string memory str = string(s);\n', '        return str;\n', '    }\n', '\n', '    function getBytes32() public view returns (bytes32 _result){\n', '        _result = keccak256(now, block.blockhash(block.number - 1));\n', '    }\n', '\n', '    function getHash1(uint8[5]  _winWhiteBall, uint8 _winRedBall, bytes32 _nonce) public pure returns (bytes32 _result){\n', '        _result =  keccak256(_winWhiteBall, _winRedBall, _nonce);\n', '    }\n', '\n', '    function getHash2(address _user, bytes32 _nonce) public pure returns (bytes32 _result){\n', '        _result =  keccak256(_user, _nonce);\n', '    }\n', '\n', '    function () public payable {                                    //function depositEther() public payable \n', '        if(msg.value > 0) {          \n', '            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n', '        }\n', '    }\n', '\n', '}']