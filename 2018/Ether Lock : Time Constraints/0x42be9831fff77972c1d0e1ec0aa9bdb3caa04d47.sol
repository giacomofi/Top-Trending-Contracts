['pragma solidity ^0.4.24;\n', '\n', '// 22.07.18\n', '\n', '\n', '//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n', '//\n', '//  Ethertote token contract\n', '//\n', '//  (parts of the token contract\n', '//  are based on the &#39;MiniMeToken&#39; - Jordi Baylina)\n', '//\n', '//  Fully ERC20 Compliant token\n', '//\n', '//  Name:            Ethertote\n', '//  Symbol:          TOTE\n', '//  Decimals:        0\n', '//  Total supply:    10000000 (10 million tokens)\n', '//\n', '//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// TokenController contract is called when `_owner` sends ether to the \n', '// Ethertote Token contract\n', '// ----------------------------------------------------------------------------\n', 'contract TokenController {\n', '\n', '    function proxyPayments(address _owner) public payable returns(bool);\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ApproveAndCallFallBack\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The main EthertoteToken contract, the default controller is the msg.sender\n', '// that deploys the contract\n', '// ----------------------------------------------------------------------------\n', 'contract EthertoteToken {\n', '\n', '    // Variables to ensure contract is conforming to ERC220\n', '    string public name;                \n', '    uint8 public decimals;             \n', '    string public symbol;              \n', '    uint public _totalSupply;\n', '    \n', '    // Addtional variables \n', '    string public version; \n', '    address public contractOwner;\n', '    address public thisContractAddress;\n', '    address public EthertoteAdminAddress;\n', '    \n', '    bool public tokenGenerationLock;            // ensure tokens can only be minted once\n', '    \n', '    // the controller takes full control of the contract\n', '    address public controller;\n', '    \n', '    // null address which will be assigned as controller for security purposes\n', '    address public relinquishOwnershipAddress = 0x0000000000000000000000000000000000000000;\n', '    \n', '    \n', '    // Modifier to ensure generateTokens() is only ran once by the constructor\n', '    modifier onlyController { \n', '        require(\n', '            msg.sender == controller\n', '            ); \n', '            _; \n', '    }\n', '    \n', '    \n', '    modifier onlyContract { \n', '        require(\n', '            address(this) == thisContractAddress\n', '            \n', '        ); \n', '        _; \n', '    }\n', '    \n', '    \n', '    modifier EthertoteAdmin { \n', '        require(\n', '            msg.sender == EthertoteAdminAddress\n', '            \n', '        ); \n', '        _; \n', '    }\n', '\n', '\n', '    // Checkpoint is the struct that attaches a block number to a\n', '    // given value, and the block number attached is the one that last changed the\n', '    // value\n', '    struct  Checkpoint {\n', '        uint128 fromBlock;\n', '        uint128 value;\n', '    }\n', '\n', '    // parentToken will be 0x0 for the token unless cloned\n', '    EthertoteToken private parentToken;\n', '\n', '    // parentSnapShotBlock is the block number from the Parent Token which will\n', '    // be 0x0 unless cloned\n', '    uint private parentSnapShotBlock;\n', '\n', '    // creationBlock is the &#39;genesis&#39; block number when contract is deployed\n', '    uint public creationBlock;\n', '\n', '    // balances is the mapping which tracks the balance of each address\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '    // allowed is the mapping which tracks any extra transfer rights \n', '    // as per ERC20 token standards\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Checkpoint array tracks the history of the totalSupply of the token\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', '    // needs to be set to &#39;true&#39; to allow tokens to be transferred\n', '    bool public transfersEnabled;\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Constructor function initiated automatically when contract is deployed\n', '// ----------------------------------------------------------------------------\n', '    constructor() public {\n', '        \n', '        controller = msg.sender;\n', '        EthertoteAdminAddress = msg.sender;\n', '        tokenGenerationLock = false;\n', '        \n', '    // --------------------------------------------------------------------\n', '    // set the following values prior to deployment\n', '    // --------------------------------------------------------------------\n', '    \n', '        name = "Ethertote";                                   // Set the name\n', '        symbol = "TOTE";                                 // Set the symbol\n', '        decimals = 0;                                       // Set the decimals\n', '        _totalSupply = 10000000 * 10**uint(decimals);       // 10,000,000 tokens\n', '        \n', '        version = "Ethertote Token contract - version 1.0";\n', '    \n', '    //---------------------------------------------------------------------\n', '\n', '        // Additional variables set by the constructor\n', '        contractOwner = msg.sender;\n', '        thisContractAddress = address(this);\n', '\n', '        transfersEnabled = true;                            // allows tokens to be traded\n', '        \n', '        creationBlock = block.number;                       // sets the genesis block\n', '\n', '\n', '        // Now call the internal generateTokens function to create the tokens \n', '        // and send them to owner\n', '        generateTokens(contractOwner, _totalSupply);\n', '        \n', '        // Now that the tokens have been generated, finally reliquish \n', '        // ownership of the token contract for security purposes\n', '        controller = relinquishOwnershipAddress;\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface Methods for full compliance\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', '\n', '    // totalSupply //\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '    \n', '    // balanceOf //\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    // allowance //\n', '    function allowance(address _owner, address _spender\n', '    ) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // transfer //\n', '    function transfer(address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        \n', '        require(transfersEnabled);\n', '        \n', '        // prevent tokens from ever being sent back to the contract address \n', '        require(_to != address(this) );\n', '        // prevent tokens from ever accidentally being sent to the nul (0x0) address\n', '        require(_to != 0x0);\n', '        doTransfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    // approve //\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        if (isContract(controller)) {\n', '            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // transferFrom\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        \n', '        // prevent tokens from ever being sent back to the contract address \n', '        require(_to != address(this) );\n', '        // prevent tokens from ever accidentally being sent to the nul (0x0) address\n', '        require(_to != 0x0);\n', '        \n', '        if (msg.sender != controller) {\n', '            require(transfersEnabled);\n', '\n', '            require(allowed[_from][msg.sender] >= _amount);\n', '            allowed[_from][msg.sender] -= _amount;\n', '        }\n', '        doTransfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '// ----------------------------------------------------------------------------\n', '//  ERC20 compliant events\n', '// ----------------------------------------------------------------------------\n', '\n', '    event Transfer(\n', '        address indexed _from, address indexed _to, uint256 _amount\n', '        );\n', '    \n', '    event Approval(\n', '        address indexed _owner, address indexed _spender, uint256 _amount\n', '        );\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', '    // once constructor assigns control to 0x0 the contract cannot be changed\n', '    function changeController(address _newController) onlyController private {\n', '        controller = _newController;\n', '    }\n', '    \n', '    function doTransfer(address _from, address _to, uint _amount) internal {\n', '\n', '           if (_amount == 0) {\n', '               emit Transfer(_from, _to, _amount); \n', '               return;\n', '           }\n', '\n', '           require(parentSnapShotBlock < block.number);\n', '\n', '           // Do not allow transfer to 0x0 or the token contract itself\n', '           // require((_to != 0) && (_to != address(this)));\n', '           \n', '           require(_to != address(this));\n', '           \n', '           \n', '\n', '           // If the amount being transfered is more than the balance of the\n', '           //  account, the transfer throws\n', '           uint previousBalanceFrom = balanceOfAt(_from, block.number);\n', '           require(previousBalanceFrom >= _amount);\n', '\n', '           // Alerts the token controller of the transfer\n', '           if (isContract(controller)) {\n', '               require(TokenController(controller).onTransfer(_from, _to, _amount));\n', '           }\n', '\n', '           // First update the balance array with the new value for the address\n', '           //  sending the tokens\n', '           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '           // Then update the balance array with the new value for the address\n', '           //  receiving the tokens\n', '           uint previousBalanceTo = balanceOfAt(_to, block.number);\n', '           \n', '           // Check for overflow\n', '           require(previousBalanceTo + _amount >= previousBalanceTo); \n', '           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '           // An event to make the transfer easy to find on the blockchain\n', '           emit Transfer(_from, _to, _amount);\n', '\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// approveAndCall allows users to use their tokens to interact with contracts\n', '// in a single function call\n', '// msg.sender approves `_spender` to send an `_amount` of tokens on\n', '// its behalf, and then a function is triggered in the contract that is\n', '// being approved, `_spender`. This allows users to use their tokens to\n', '// interact with contracts in one function call instead of two\n', '    \n', '// _spender is the address of the contract able to transfer the tokens\n', '// _amount is the amount of tokens to be approved for transfer\n', '// return &#39;true&#39; if the function call was successful\n', '// ----------------------------------------------------------------------------    \n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) public returns (bool success) {\n', '        require(approve(_spender, _amount));\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Query the balance of an address at a specific block number\n', '// ----------------------------------------------------------------------------\n', '    function balanceOfAt(address _owner, uint _blockNumber) public constant\n', '        returns (uint) {\n', '\n', '        if ((balances[_owner].length == 0)\n', '            || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '\n', '        } \n', '        \n', '        else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Queries the total supply of tokens at a specific block number\n', '// will return 0 if called before the creationBlock value\n', '// ----------------------------------------------------------------------------\n', '    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '        if (\n', '            (totalSupplyHistory.length == 0) ||\n', '            (totalSupplyHistory[0].fromBlock > _blockNumber)\n', '            ) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '\n', '        } \n', '        else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The generateTokens function will generate the initial supply of tokens\n', '// Can only be called once during the constructor as it has the onlyContract\n', '// modifier attached to the function\n', '// ----------------------------------------------------------------------------\n', '    function generateTokens(address _owner, uint _theTotalSupply) \n', '    private onlyContract returns (bool) {\n', '        require(tokenGenerationLock == false);\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _theTotalSupply >= curTotalSupply); // Check for overflow\n', '        uint previousBalanceTo = balanceOf(_owner);\n', '        require(previousBalanceTo + _totalSupply >= previousBalanceTo); // Check for overflow\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply);\n', '        updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply);\n', '        emit Transfer(0, _owner, _totalSupply);\n', '        tokenGenerationLock = true;\n', '        return true;\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Enable tokens transfers to allow tokens to be traded\n', '// ----------------------------------------------------------------------------\n', '\n', '    function enableTransfers(bool _transfersEnabled) private onlyController {\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Internal helper functions\n', '// ----------------------------------------------------------------------------\n', '\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n', '    ) constant internal returns (uint) {\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '            return checkpoints[checkpoints.length-1].value;\n', '        if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '        // Binary search of the value in the array\n', '        uint min = 0;\n', '        uint max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1)/ 2;\n', '            if (checkpoints[mid].fromBlock<=_block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// function used to update the `balances` map and the `totalSupplyHistory`\n', '// ----------------------------------------------------------------------------\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n', '    ) internal  {\n', '        if ((checkpoints.length == 0)\n', '        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '               newCheckPoint.fromBlock =  uint128(block.number);\n', '               newCheckPoint.value = uint128(_value);\n', '           } else {\n', '               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '               oldCheckPoint.value = uint128(_value);\n', '           }\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// function to check if address is a contract\n', '// ----------------------------------------------------------------------------\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Helper function to return a min betwen the two uints\n', '// ----------------------------------------------------------------------------\n', '    function min(uint a, uint b) pure internal returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// fallback function: If the contract&#39;s controller has not been set to 0, \n', '// then the `proxyPayment` method is called which relays the eth and creates \n', '// tokens as described in the token controller contract\n', '// ----------------------------------------------------------------------------\n', '    function () public payable {\n', '        require(isContract(controller));\n', '        require(\n', '            TokenController(controller).proxyPayments.value(msg.value)(msg.sender)\n', '            );\n', '    }\n', '\n', '\n', '    event ClaimedTokens(\n', '        address indexed _token, address indexed _controller, uint _amount\n', '        );\n', '\n', '// ----------------------------------------------------------------------------\n', '// This method can be used by the controller to extract other tokens accidentally \n', '// sent to this contract.\n', '// _token is the address of the token contract to recover\n', '//  can be set to 0 to extract eth\n', '// ----------------------------------------------------------------------------\n', '    function withdrawOtherTokens(address _token) EthertoteAdmin public {\n', '        if (_token == 0x0) {\n', '            controller.transfer(address(this).balance);\n', '            return;\n', '        }\n', '        EthertoteToken token = EthertoteToken(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '        emit ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '// 22.07.18\n', '\n', '\n', '//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n', '//\n', '//  Ethertote token contract\n', '//\n', '//  (parts of the token contract\n', "//  are based on the 'MiniMeToken' - Jordi Baylina)\n", '//\n', '//  Fully ERC20 Compliant token\n', '//\n', '//  Name:            Ethertote\n', '//  Symbol:          TOTE\n', '//  Decimals:        0\n', '//  Total supply:    10000000 (10 million tokens)\n', '//\n', '//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// TokenController contract is called when `_owner` sends ether to the \n', '// Ethertote Token contract\n', '// ----------------------------------------------------------------------------\n', 'contract TokenController {\n', '\n', '    function proxyPayments(address _owner) public payable returns(bool);\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ApproveAndCallFallBack\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The main EthertoteToken contract, the default controller is the msg.sender\n', '// that deploys the contract\n', '// ----------------------------------------------------------------------------\n', 'contract EthertoteToken {\n', '\n', '    // Variables to ensure contract is conforming to ERC220\n', '    string public name;                \n', '    uint8 public decimals;             \n', '    string public symbol;              \n', '    uint public _totalSupply;\n', '    \n', '    // Addtional variables \n', '    string public version; \n', '    address public contractOwner;\n', '    address public thisContractAddress;\n', '    address public EthertoteAdminAddress;\n', '    \n', '    bool public tokenGenerationLock;            // ensure tokens can only be minted once\n', '    \n', '    // the controller takes full control of the contract\n', '    address public controller;\n', '    \n', '    // null address which will be assigned as controller for security purposes\n', '    address public relinquishOwnershipAddress = 0x0000000000000000000000000000000000000000;\n', '    \n', '    \n', '    // Modifier to ensure generateTokens() is only ran once by the constructor\n', '    modifier onlyController { \n', '        require(\n', '            msg.sender == controller\n', '            ); \n', '            _; \n', '    }\n', '    \n', '    \n', '    modifier onlyContract { \n', '        require(\n', '            address(this) == thisContractAddress\n', '            \n', '        ); \n', '        _; \n', '    }\n', '    \n', '    \n', '    modifier EthertoteAdmin { \n', '        require(\n', '            msg.sender == EthertoteAdminAddress\n', '            \n', '        ); \n', '        _; \n', '    }\n', '\n', '\n', '    // Checkpoint is the struct that attaches a block number to a\n', '    // given value, and the block number attached is the one that last changed the\n', '    // value\n', '    struct  Checkpoint {\n', '        uint128 fromBlock;\n', '        uint128 value;\n', '    }\n', '\n', '    // parentToken will be 0x0 for the token unless cloned\n', '    EthertoteToken private parentToken;\n', '\n', '    // parentSnapShotBlock is the block number from the Parent Token which will\n', '    // be 0x0 unless cloned\n', '    uint private parentSnapShotBlock;\n', '\n', "    // creationBlock is the 'genesis' block number when contract is deployed\n", '    uint public creationBlock;\n', '\n', '    // balances is the mapping which tracks the balance of each address\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '    // allowed is the mapping which tracks any extra transfer rights \n', '    // as per ERC20 token standards\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Checkpoint array tracks the history of the totalSupply of the token\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', "    // needs to be set to 'true' to allow tokens to be transferred\n", '    bool public transfersEnabled;\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Constructor function initiated automatically when contract is deployed\n', '// ----------------------------------------------------------------------------\n', '    constructor() public {\n', '        \n', '        controller = msg.sender;\n', '        EthertoteAdminAddress = msg.sender;\n', '        tokenGenerationLock = false;\n', '        \n', '    // --------------------------------------------------------------------\n', '    // set the following values prior to deployment\n', '    // --------------------------------------------------------------------\n', '    \n', '        name = "Ethertote";                                   // Set the name\n', '        symbol = "TOTE";                                 // Set the symbol\n', '        decimals = 0;                                       // Set the decimals\n', '        _totalSupply = 10000000 * 10**uint(decimals);       // 10,000,000 tokens\n', '        \n', '        version = "Ethertote Token contract - version 1.0";\n', '    \n', '    //---------------------------------------------------------------------\n', '\n', '        // Additional variables set by the constructor\n', '        contractOwner = msg.sender;\n', '        thisContractAddress = address(this);\n', '\n', '        transfersEnabled = true;                            // allows tokens to be traded\n', '        \n', '        creationBlock = block.number;                       // sets the genesis block\n', '\n', '\n', '        // Now call the internal generateTokens function to create the tokens \n', '        // and send them to owner\n', '        generateTokens(contractOwner, _totalSupply);\n', '        \n', '        // Now that the tokens have been generated, finally reliquish \n', '        // ownership of the token contract for security purposes\n', '        controller = relinquishOwnershipAddress;\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface Methods for full compliance\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', '\n', '    // totalSupply //\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '    \n', '    // balanceOf //\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    // allowance //\n', '    function allowance(address _owner, address _spender\n', '    ) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // transfer //\n', '    function transfer(address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        \n', '        require(transfersEnabled);\n', '        \n', '        // prevent tokens from ever being sent back to the contract address \n', '        require(_to != address(this) );\n', '        // prevent tokens from ever accidentally being sent to the nul (0x0) address\n', '        require(_to != 0x0);\n', '        doTransfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    // approve //\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '        if (isContract(controller)) {\n', '            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // transferFrom\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        \n', '        // prevent tokens from ever being sent back to the contract address \n', '        require(_to != address(this) );\n', '        // prevent tokens from ever accidentally being sent to the nul (0x0) address\n', '        require(_to != 0x0);\n', '        \n', '        if (msg.sender != controller) {\n', '            require(transfersEnabled);\n', '\n', '            require(allowed[_from][msg.sender] >= _amount);\n', '            allowed[_from][msg.sender] -= _amount;\n', '        }\n', '        doTransfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '// ----------------------------------------------------------------------------\n', '//  ERC20 compliant events\n', '// ----------------------------------------------------------------------------\n', '\n', '    event Transfer(\n', '        address indexed _from, address indexed _to, uint256 _amount\n', '        );\n', '    \n', '    event Approval(\n', '        address indexed _owner, address indexed _spender, uint256 _amount\n', '        );\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', '    // once constructor assigns control to 0x0 the contract cannot be changed\n', '    function changeController(address _newController) onlyController private {\n', '        controller = _newController;\n', '    }\n', '    \n', '    function doTransfer(address _from, address _to, uint _amount) internal {\n', '\n', '           if (_amount == 0) {\n', '               emit Transfer(_from, _to, _amount); \n', '               return;\n', '           }\n', '\n', '           require(parentSnapShotBlock < block.number);\n', '\n', '           // Do not allow transfer to 0x0 or the token contract itself\n', '           // require((_to != 0) && (_to != address(this)));\n', '           \n', '           require(_to != address(this));\n', '           \n', '           \n', '\n', '           // If the amount being transfered is more than the balance of the\n', '           //  account, the transfer throws\n', '           uint previousBalanceFrom = balanceOfAt(_from, block.number);\n', '           require(previousBalanceFrom >= _amount);\n', '\n', '           // Alerts the token controller of the transfer\n', '           if (isContract(controller)) {\n', '               require(TokenController(controller).onTransfer(_from, _to, _amount));\n', '           }\n', '\n', '           // First update the balance array with the new value for the address\n', '           //  sending the tokens\n', '           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '           // Then update the balance array with the new value for the address\n', '           //  receiving the tokens\n', '           uint previousBalanceTo = balanceOfAt(_to, block.number);\n', '           \n', '           // Check for overflow\n', '           require(previousBalanceTo + _amount >= previousBalanceTo); \n', '           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '           // An event to make the transfer easy to find on the blockchain\n', '           emit Transfer(_from, _to, _amount);\n', '\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// approveAndCall allows users to use their tokens to interact with contracts\n', '// in a single function call\n', '// msg.sender approves `_spender` to send an `_amount` of tokens on\n', '// its behalf, and then a function is triggered in the contract that is\n', '// being approved, `_spender`. This allows users to use their tokens to\n', '// interact with contracts in one function call instead of two\n', '    \n', '// _spender is the address of the contract able to transfer the tokens\n', '// _amount is the amount of tokens to be approved for transfer\n', "// return 'true' if the function call was successful\n", '// ----------------------------------------------------------------------------    \n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) public returns (bool success) {\n', '        require(approve(_spender, _amount));\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Query the balance of an address at a specific block number\n', '// ----------------------------------------------------------------------------\n', '    function balanceOfAt(address _owner, uint _blockNumber) public constant\n', '        returns (uint) {\n', '\n', '        if ((balances[_owner].length == 0)\n', '            || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '\n', '        } \n', '        \n', '        else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Queries the total supply of tokens at a specific block number\n', '// will return 0 if called before the creationBlock value\n', '// ----------------------------------------------------------------------------\n', '    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '        if (\n', '            (totalSupplyHistory.length == 0) ||\n', '            (totalSupplyHistory[0].fromBlock > _blockNumber)\n', '            ) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '\n', '        } \n', '        else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// The generateTokens function will generate the initial supply of tokens\n', '// Can only be called once during the constructor as it has the onlyContract\n', '// modifier attached to the function\n', '// ----------------------------------------------------------------------------\n', '    function generateTokens(address _owner, uint _theTotalSupply) \n', '    private onlyContract returns (bool) {\n', '        require(tokenGenerationLock == false);\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _theTotalSupply >= curTotalSupply); // Check for overflow\n', '        uint previousBalanceTo = balanceOf(_owner);\n', '        require(previousBalanceTo + _totalSupply >= previousBalanceTo); // Check for overflow\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply);\n', '        updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply);\n', '        emit Transfer(0, _owner, _totalSupply);\n', '        tokenGenerationLock = true;\n', '        return true;\n', '    }\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Enable tokens transfers to allow tokens to be traded\n', '// ----------------------------------------------------------------------------\n', '\n', '    function enableTransfers(bool _transfersEnabled) private onlyController {\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Internal helper functions\n', '// ----------------------------------------------------------------------------\n', '\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n', '    ) constant internal returns (uint) {\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '            return checkpoints[checkpoints.length-1].value;\n', '        if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '        // Binary search of the value in the array\n', '        uint min = 0;\n', '        uint max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1)/ 2;\n', '            if (checkpoints[mid].fromBlock<=_block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// function used to update the `balances` map and the `totalSupplyHistory`\n', '// ----------------------------------------------------------------------------\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n', '    ) internal  {\n', '        if ((checkpoints.length == 0)\n', '        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '               newCheckPoint.fromBlock =  uint128(block.number);\n', '               newCheckPoint.value = uint128(_value);\n', '           } else {\n', '               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '               oldCheckPoint.value = uint128(_value);\n', '           }\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// function to check if address is a contract\n', '// ----------------------------------------------------------------------------\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Helper function to return a min betwen the two uints\n', '// ----------------------------------------------------------------------------\n', '    function min(uint a, uint b) pure internal returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', "// fallback function: If the contract's controller has not been set to 0, \n", '// then the `proxyPayment` method is called which relays the eth and creates \n', '// tokens as described in the token controller contract\n', '// ----------------------------------------------------------------------------\n', '    function () public payable {\n', '        require(isContract(controller));\n', '        require(\n', '            TokenController(controller).proxyPayments.value(msg.value)(msg.sender)\n', '            );\n', '    }\n', '\n', '\n', '    event ClaimedTokens(\n', '        address indexed _token, address indexed _controller, uint _amount\n', '        );\n', '\n', '// ----------------------------------------------------------------------------\n', '// This method can be used by the controller to extract other tokens accidentally \n', '// sent to this contract.\n', '// _token is the address of the token contract to recover\n', '//  can be set to 0 to extract eth\n', '// ----------------------------------------------------------------------------\n', '    function withdrawOtherTokens(address _token) EthertoteAdmin public {\n', '        if (_token == 0x0) {\n', '            controller.transfer(address(this).balance);\n', '            return;\n', '        }\n', '        EthertoteToken token = EthertoteToken(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '        emit ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '}']
