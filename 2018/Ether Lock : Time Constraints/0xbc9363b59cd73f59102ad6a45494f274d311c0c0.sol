['pragma solidity ^0.4.24;\n', '\n', 'contract Control {\n', '    address public owner;\n', '    bool public pause;\n', '\n', '    event PAUSED();\n', '    event STARTED();\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(pause);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused {\n', '        require(!pause);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setState(bool _pause) onlyOwner public {\n', '        pause = _pause;\n', '        if (pause) {\n', '            emit PAUSED();\n', '        } else {\n', '            emit STARTED();\n', '        }\n', '    }\n', '\n', '}\n', '/**\n', ' * this contract stands for the holds of WestIndia group\n', ' * all income will be split to holders according to their holds\n', ' * user can buy holds from shareholders at his will\n', ' */\n', 'contract Share is Control {    /**\n', '     * the holds of every holder\n', '     * the total holds stick to total\n', '     */\n', '    mapping (address => uint) public holds;\n', '\n', '    /**\n', '     * since we don&#39;t record holders&#39; address in a list\n', '     * and we don&#39;t want to loop holders list everytime when there is income\n', '     *\n', '     * we use a mechanism called &#39;watermark&#39;\n', '     * \n', '     * the watermark indicates the value that brought into each holds from the begining\n', '     * it only goes up when new income send to the contract\n', '\n', '     * fullfilled indicate the amount that the holder has withdrawaled from his share\n', '     * it goes up when user withdrawal bonus\n', '     * and it goes up when user sell holds, goes down when user buy holds, since the total bonus of him stays the same.\n', '     */\n', '    mapping (address => uint256) public fullfilled;\n', '\n', '    /**\n', '     * any one can setup a price to sell his holds\n', '     * if set to 0, means not on sell\n', '     */\n', '    mapping (address => uint256) public sellPrice;\n', '    mapping (address => uint256) public toSell;\n', '    mapping (address => mapping(address => uint256)) public allowance;\n', '    uint256 public watermark;\n', '    uint256 public total;\n', '    uint256 public decimals;\n', '    \n', '    string public symbol;\n', '    string public name;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    event INCOME(uint256);\n', '    event PRICE_SET(address holder, uint shares, uint256 price, uint sell);\n', '    event WITHDRAWAL(address owner, uint256 amount);\n', '    event SELL_HOLDS(address from, address to, uint amount, uint256 price);\n', '    event SEND_HOLDS(address from, address to, uint amount);\n', '\n', '    /**\n', '     * at start the owner has 100% share, which is 10,000 holds\n', '     */\n', '    constructor(string _symbol, string _name, uint256 _total) public {        \n', '        symbol = _symbol;\n', '        name = _name;\n', '        owner = msg.sender;\n', '        total = _total;\n', '        holds[owner] = total;\n', '        decimals = 0;\n', '        pause = false;\n', '    }\n', '\n', '    /**\n', '     * when there&#39;s income, the water mark goes up\n', '     */\n', '    function onIncome() public payable {\n', '        if (msg.value > 0) {\n', '            watermark += (msg.value / total);\n', '            assert(watermark * total > watermark);\n', '            emit INCOME(msg.value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * automatically split income\n', '     */\n', '    function() public payable {\n', '        onIncome();\n', '    }\n', '\n', '    function bonus() public view returns (uint256) {\n', '        return (watermark - fullfilled[msg.sender]) * holds[msg.sender];\n', '    }\n', '    \n', '    function setPrice(uint256 price, uint256 sell) public {\n', '        sellPrice[msg.sender] = price;\n', '        toSell[msg.sender] = sell;\n', '        emit PRICE_SET(msg.sender, holds[msg.sender], price, sell);\n', '    }\n', '\n', '    /**\n', '     * withdrawal the bonus\n', '     */\n', '    function withdrawal() public whenNotPaused {\n', '        if (holds[msg.sender] == 0) {\n', '            //you don&#39;t have any, don&#39;t bother\n', '            return;\n', '        }\n', '        uint256 value = bonus();\n', '        fullfilled[msg.sender] = watermark;\n', '\n', '        msg.sender.transfer(value);\n', '\n', '        emit WITHDRAWAL(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * transfer holds from => to (only holds, no bouns)\n', '     * this will withdrawal the holder bonus of these holds\n', '     * and the to&#39;s fullfilled will go up, since total bonus unchanged, but holds goes more\n', '     */\n', '    function transferHolds(address from, address to, uint256 amount) internal {\n', '        require(holds[from] >= amount);\n', '        require(holds[to] + amount > holds[to]);\n', '\n', '        uint256 fromBonus = (watermark - fullfilled[from]) * amount;\n', '        uint256 toBonus = (watermark - fullfilled[to]) * holds[to];\n', '        \n', '\n', '        holds[from] -= amount;\n', '        holds[to] += amount;\n', '        fullfilled[to] = watermark - toBonus / holds[to];\n', '\n', '        from.transfer(fromBonus);\n', '\n', '        emit Transfer(from, to, amount);\n', '        emit WITHDRAWAL(from, fromBonus);\n', '    }\n', '\n', '    /**\n', '     * one can buy holds from anyone who set up an price,\n', '     * and u can buy @ price higher than he setup\n', '     */\n', '    function buyFrom(address from) public payable whenNotPaused {\n', '        require(sellPrice[from] > 0);\n', '        uint256 amount = msg.value / sellPrice[from];\n', '\n', '        if (amount >= holds[from]) {\n', '            amount = holds[from];\n', '        }\n', '\n', '        if (amount >= toSell[from]) {\n', '            amount = toSell[from];\n', '        }\n', '\n', '        require(amount > 0);\n', '\n', '        toSell[from] -= amount;\n', '        transferHolds(from, msg.sender, amount);\n', '        \n', '        from.transfer(msg.value);\n', '        emit SELL_HOLDS(from, msg.sender, amount, sellPrice[from]);\n', '    }\n', '    \n', '    function balanceOf(address _addr) public view returns (uint256) {\n', '        return holds[_addr];\n', '    }\n', '    \n', '    function transfer(address to, uint amount) public whenNotPaused returns(bool) {\n', '        transferHolds(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 amount) public whenNotPaused returns (bool) {\n', '        require(allowance[from][msg.sender] >= amount);\n', '        \n', '        allowance[from][msg.sender] -= amount;\n', '        transferHolds(from, to, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address to, uint256 amount) public returns (bool) {\n', '        allowance[msg.sender][to] = amount;\n', '        \n', '        emit Approval(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return total;\n', '    }\n', '    \n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowance[owner][spender];\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Control {\n', '    address public owner;\n', '    bool public pause;\n', '\n', '    event PAUSED();\n', '    event STARTED();\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused {\n', '        require(pause);\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused {\n', '        require(!pause);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _owner) onlyOwner public {\n', '        owner = _owner;\n', '    }\n', '\n', '    function setState(bool _pause) onlyOwner public {\n', '        pause = _pause;\n', '        if (pause) {\n', '            emit PAUSED();\n', '        } else {\n', '            emit STARTED();\n', '        }\n', '    }\n', '\n', '}\n', '/**\n', ' * this contract stands for the holds of WestIndia group\n', ' * all income will be split to holders according to their holds\n', ' * user can buy holds from shareholders at his will\n', ' */\n', 'contract Share is Control {    /**\n', '     * the holds of every holder\n', '     * the total holds stick to total\n', '     */\n', '    mapping (address => uint) public holds;\n', '\n', '    /**\n', "     * since we don't record holders' address in a list\n", "     * and we don't want to loop holders list everytime when there is income\n", '     *\n', "     * we use a mechanism called 'watermark'\n", '     * \n', '     * the watermark indicates the value that brought into each holds from the begining\n', '     * it only goes up when new income send to the contract\n', '\n', '     * fullfilled indicate the amount that the holder has withdrawaled from his share\n', '     * it goes up when user withdrawal bonus\n', '     * and it goes up when user sell holds, goes down when user buy holds, since the total bonus of him stays the same.\n', '     */\n', '    mapping (address => uint256) public fullfilled;\n', '\n', '    /**\n', '     * any one can setup a price to sell his holds\n', '     * if set to 0, means not on sell\n', '     */\n', '    mapping (address => uint256) public sellPrice;\n', '    mapping (address => uint256) public toSell;\n', '    mapping (address => mapping(address => uint256)) public allowance;\n', '    uint256 public watermark;\n', '    uint256 public total;\n', '    uint256 public decimals;\n', '    \n', '    string public symbol;\n', '    string public name;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    event INCOME(uint256);\n', '    event PRICE_SET(address holder, uint shares, uint256 price, uint sell);\n', '    event WITHDRAWAL(address owner, uint256 amount);\n', '    event SELL_HOLDS(address from, address to, uint amount, uint256 price);\n', '    event SEND_HOLDS(address from, address to, uint amount);\n', '\n', '    /**\n', '     * at start the owner has 100% share, which is 10,000 holds\n', '     */\n', '    constructor(string _symbol, string _name, uint256 _total) public {        \n', '        symbol = _symbol;\n', '        name = _name;\n', '        owner = msg.sender;\n', '        total = _total;\n', '        holds[owner] = total;\n', '        decimals = 0;\n', '        pause = false;\n', '    }\n', '\n', '    /**\n', "     * when there's income, the water mark goes up\n", '     */\n', '    function onIncome() public payable {\n', '        if (msg.value > 0) {\n', '            watermark += (msg.value / total);\n', '            assert(watermark * total > watermark);\n', '            emit INCOME(msg.value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * automatically split income\n', '     */\n', '    function() public payable {\n', '        onIncome();\n', '    }\n', '\n', '    function bonus() public view returns (uint256) {\n', '        return (watermark - fullfilled[msg.sender]) * holds[msg.sender];\n', '    }\n', '    \n', '    function setPrice(uint256 price, uint256 sell) public {\n', '        sellPrice[msg.sender] = price;\n', '        toSell[msg.sender] = sell;\n', '        emit PRICE_SET(msg.sender, holds[msg.sender], price, sell);\n', '    }\n', '\n', '    /**\n', '     * withdrawal the bonus\n', '     */\n', '    function withdrawal() public whenNotPaused {\n', '        if (holds[msg.sender] == 0) {\n', "            //you don't have any, don't bother\n", '            return;\n', '        }\n', '        uint256 value = bonus();\n', '        fullfilled[msg.sender] = watermark;\n', '\n', '        msg.sender.transfer(value);\n', '\n', '        emit WITHDRAWAL(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * transfer holds from => to (only holds, no bouns)\n', '     * this will withdrawal the holder bonus of these holds\n', "     * and the to's fullfilled will go up, since total bonus unchanged, but holds goes more\n", '     */\n', '    function transferHolds(address from, address to, uint256 amount) internal {\n', '        require(holds[from] >= amount);\n', '        require(holds[to] + amount > holds[to]);\n', '\n', '        uint256 fromBonus = (watermark - fullfilled[from]) * amount;\n', '        uint256 toBonus = (watermark - fullfilled[to]) * holds[to];\n', '        \n', '\n', '        holds[from] -= amount;\n', '        holds[to] += amount;\n', '        fullfilled[to] = watermark - toBonus / holds[to];\n', '\n', '        from.transfer(fromBonus);\n', '\n', '        emit Transfer(from, to, amount);\n', '        emit WITHDRAWAL(from, fromBonus);\n', '    }\n', '\n', '    /**\n', '     * one can buy holds from anyone who set up an price,\n', '     * and u can buy @ price higher than he setup\n', '     */\n', '    function buyFrom(address from) public payable whenNotPaused {\n', '        require(sellPrice[from] > 0);\n', '        uint256 amount = msg.value / sellPrice[from];\n', '\n', '        if (amount >= holds[from]) {\n', '            amount = holds[from];\n', '        }\n', '\n', '        if (amount >= toSell[from]) {\n', '            amount = toSell[from];\n', '        }\n', '\n', '        require(amount > 0);\n', '\n', '        toSell[from] -= amount;\n', '        transferHolds(from, msg.sender, amount);\n', '        \n', '        from.transfer(msg.value);\n', '        emit SELL_HOLDS(from, msg.sender, amount, sellPrice[from]);\n', '    }\n', '    \n', '    function balanceOf(address _addr) public view returns (uint256) {\n', '        return holds[_addr];\n', '    }\n', '    \n', '    function transfer(address to, uint amount) public whenNotPaused returns(bool) {\n', '        transferHolds(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 amount) public whenNotPaused returns (bool) {\n', '        require(allowance[from][msg.sender] >= amount);\n', '        \n', '        allowance[from][msg.sender] -= amount;\n', '        transferHolds(from, to, amount);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function approve(address to, uint256 amount) public returns (bool) {\n', '        allowance[msg.sender][to] = amount;\n', '        \n', '        emit Approval(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return total;\n', '    }\n', '    \n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowance[owner][spender];\n', '    }\n', '}']
