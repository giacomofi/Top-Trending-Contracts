['//StrongCapital v1.2.2\n', '\n', '\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract Capital {\n', '  uint constant public CASH_BACK_PERCENT = 3;\n', '  uint constant public PROJECT_FEE_PERCENT = 20;\n', '  uint constant public PER_BLOCK = 48;\n', '  uint constant public MINIMUM_INVEST = 10000000000000000 wei;\n', '  uint public wave;\n', '  \n', '  address public owner;\n', '  address public admin;\n', '  address[] public addresses;\n', '\n', '  bool public pause;\n', '\n', '  mapping(address => Investor) public investors;\n', '  TheStrongest public boss;\n', '  \n', '  modifier onlyOwner {\n', '    require(owner == msg.sender);\n', '    _;\n', '  }\n', '\n', '  struct Investor {\n', '    uint ID;\n', '    uint deposit;\n', '    uint depositCount;\n', '    uint blockNumber;\n', '    address referrer;\n', '  }\n', '\n', '  struct TheStrongest {\n', '    address addr;\n', '    uint deposit;\n', '  }\n', '\n', '  constructor () public {\n', '    owner = msg.sender;\n', '    admin = msg.sender;\n', '    addresses.length = 1;\n', '    wave = 1;\n', '  }\n', '\n', '  function() payable public {\n', '    if(owner == msg.sender){\n', '      return;\n', '    }\n', '\n', '    require(pause == false);\n', '    require(msg.value == 0 || msg.value >= MINIMUM_INVEST);\n', '\n', '    Investor storage user = investors[msg.sender];\n', '    \n', '    if(user.ID == 0){\n', '      msg.sender.transfer(0 wei);\n', '      user.ID = addresses.push(msg.sender);\n', '\n', '      address referrer = bytesToAddress(msg.data);\n', '      if (investors[referrer].deposit > 0 && referrer != msg.sender) {\n', '        user.referrer = referrer;\n', '      }\n', '    }\n', '\n', '    if(user.deposit != 0) {\n', '      uint amount = getInvestorDividendsAmount(msg.sender);\n', '      if(address(this).balance < amount){\n', '        pause = true;\n', '        return;\n', '      }\n', '\n', '      msg.sender.transfer(amount);\n', '    }\n', '\n', '    admin.transfer(msg.value * PROJECT_FEE_PERCENT / 100);\n', '\n', '    user.deposit += msg.value;\n', '    user.depositCount += 1;\n', '    user.blockNumber = block.number;\n', '\n', '    uint bonusAmount = msg.value * CASH_BACK_PERCENT / 100;\n', '\n', '    if (user.referrer != 0x0) {\n', '      user.referrer.transfer(bonusAmount);\n', '      if (user.depositCount == 1) {\n', '        msg.sender.transfer(bonusAmount);\n', '      }\n', '    } else if (boss.addr > 0x0) {\n', '      if(msg.sender != boss.addr){\n', '        if(user.deposit < boss.deposit){\n', '          boss.addr.transfer(bonusAmount);\n', '        }\n', '      }\n', '    }\n', '\n', '    if(user.deposit > boss.deposit) {\n', '      boss = TheStrongest(msg.sender, user.deposit);\n', '    }\n', '  }\n', '\n', '  function getInvestorCount() public view returns (uint) {\n', '    return addresses.length - 1;\n', '  }\n', '\n', '  function getInvestorDividendsAmount(address addr) public view returns (uint) {\n', '    uint amount = ((investors[addr].deposit * ((block.number - investors[addr].blockNumber) * PER_BLOCK)) / 10000000);\n', '    return amount;\n', '  }\n', '\n', '  function Restart() private {\n', '    address addr;\n', '\n', '    for (uint256 i = addresses.length - 1; i > 0; i--) {\n', '      addr = addresses[i];\n', '      addresses.length -= 1;\n', '      delete investors[addr];\n', '    }\n', '\n', '    pause = false;\n', '    wave += 1;\n', '\n', '    delete boss;\n', '  }\n', '\n', '  function payout() public {\n', '    if (pause) {\n', '      Restart();\n', '      return;\n', '    }\n', '\n', '    uint amount;\n', '\n', '    for(uint256 i = addresses.length - 1; i >= 1; i--){\n', '      address addr = addresses[i];\n', '\n', '      amount = getInvestorDividendsAmount(addr);\n', '      investors[addr].blockNumber = block.number;\n', '\n', '      if (address(this).balance < amount) {\n', '        pause = true;\n', '        return;\n', '      }\n', '\n', '      addr.transfer(amount);\n', '    }\n', '  }\n', '  \n', '  function transferOwnership(address addr) onlyOwner public {\n', '    owner = addr;\n', '  }\n', '\n', '  function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '    assembly {\n', '      addr := mload(add(bys, 20))\n', '    }\n', '  }\n', '}']