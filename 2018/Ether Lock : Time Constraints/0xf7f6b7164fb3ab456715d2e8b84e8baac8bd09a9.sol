['pragma solidity ^0.4.19;\n', '\n', 'contract Club {\n', '  struct Member {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage members.\n', '  mapping(address => Member) public members;\n', '}\n', '\n', '// Last person to press the button before time runs out, wins the pot.\n', '// Button presses cost $.50\n', '// You must pay .5% of the total pot to press the button the first time. (this amount is donated to the reddithereum community).\n', '// After the first button press, a 6 hour countdown will begin, and you won&#39;t be able to press the button for 12 hours.\n', '// Each time you press the button, the countdown will decrease by 10%, and cooldown will increase by 10%.\n', '// The pot starts at $100.\n', 'contract Button {\n', '  event Pressed(address indexed presser, uint256 endBlock);\n', '  event Winner(address winner, uint256 winnings);\n', '\n', '  uint64 public countdown;\n', '  uint64 public countdownDecrement;\n', '  uint64 public cooloffIncrement;\n', '\n', '  uint64 public pressFee;\n', '  uint64 public signupFee; // basis points * contract value\n', '  Club public club; // collects signup, bypasses signup.\n', '\n', '  address public lastPresser;\n', '  uint64 public endBlock;\n', '\n', '  struct Presser {\n', '    uint64 numPresses;\n', '    uint64 cooloffEnd;\n', '  }\n', '\n', '  mapping (address => Presser) public pressers;\n', '\n', '  function Button(\n', '    uint64 _countdown, \n', '    uint64 _countdownDecrement, \n', '    uint64 _cooloffIncrement, \n', '    uint64 _pressFee, \n', '    uint64 _signupFee, \n', '    address _club\n', '  ) public payable {\n', '    countdown = _countdown;\n', '    countdownDecrement = _countdownDecrement;\n', '    cooloffIncrement = _cooloffIncrement;\n', '    pressFee = _pressFee;\n', '    signupFee = _signupFee;\n', '    club = Club(_club);\n', '\n', '    lastPresser = msg.sender;\n', '    endBlock = uint64(block.number + countdown);\n', '  }\n', '\n', '  function press() public payable {\n', '    require(block.number <= endBlock);\n', '\n', '    uint256 change = msg.value-pressFee;\n', '    Presser storage p = pressers[msg.sender];\n', '    require(p.cooloffEnd < block.number);\n', '\n', '    if (p.numPresses == 0) {\n', '      // balance - value will never be negative.\n', '      uint128 npf = _newPresserFee(address(this).balance - msg.value);\n', '      change -= npf;\n', '      address(club).transfer(npf);\n', '    }\n', '    // Breaks when pressFee+presserFee > 2^256\n', '    require(change <= msg.value);\n', '\n', '    lastPresser = msg.sender;\n', '    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);\n', '    if (finalCountdown < 10 || finalCountdown > countdown) {\n', '      finalCountdown = 10;\n', '    }\n', '    endBlock = uint64(block.number + finalCountdown);\n', '\n', '    p.numPresses++;\n', '    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));\n', '\n', '    if (change > 0) {\n', '      msg.sender.transfer(change);\n', '    }\n', '\n', '    Pressed(msg.sender, endBlock);\n', '  }\n', '\n', '  function close() public {\n', '    require(block.number > endBlock);\n', '    require(lastPresser == msg.sender);\n', '    Winner(msg.sender, address(this).balance);\n', '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  // Breaks when balance = 10^20 ether.\n', '  function newPresserFee() public view returns (uint128) {\n', '    return _newPresserFee(address(this).balance);\n', '  }\n', '\n', '  function isMember() public view returns (bool) {\n', '    return _isMember();\n', '  }\n', '\n', '  // Caller must assure that _balance < max_uint128.\n', '  function _newPresserFee(uint256 _balance) private view returns (uint128) {\n', '    if (_isMember()){\n', '      return 0;\n', '    }\n', '    return uint128((_balance * signupFee) / 10000);\n', '  }\n', '\n', '  function _isMember() private view returns (bool) {\n', '    var(un, k, cwp, bp) = club.members(msg.sender);\n', '    // members have non-zero birthPeriods\n', '    return bp != 0;\n', '  }\n', '\n', '  // Up the stakes...\n', '  function() payable public {}\n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract Club {\n', '  struct Member {\n', '    bytes20 username;\n', '    uint64 karma; \n', '    uint16 canWithdrawPeriod;\n', '    uint16 birthPeriod;\n', '  }\n', '\n', '  // Manage members.\n', '  mapping(address => Member) public members;\n', '}\n', '\n', '// Last person to press the button before time runs out, wins the pot.\n', '// Button presses cost $.50\n', '// You must pay .5% of the total pot to press the button the first time. (this amount is donated to the reddithereum community).\n', "// After the first button press, a 6 hour countdown will begin, and you won't be able to press the button for 12 hours.\n", '// Each time you press the button, the countdown will decrease by 10%, and cooldown will increase by 10%.\n', '// The pot starts at $100.\n', 'contract Button {\n', '  event Pressed(address indexed presser, uint256 endBlock);\n', '  event Winner(address winner, uint256 winnings);\n', '\n', '  uint64 public countdown;\n', '  uint64 public countdownDecrement;\n', '  uint64 public cooloffIncrement;\n', '\n', '  uint64 public pressFee;\n', '  uint64 public signupFee; // basis points * contract value\n', '  Club public club; // collects signup, bypasses signup.\n', '\n', '  address public lastPresser;\n', '  uint64 public endBlock;\n', '\n', '  struct Presser {\n', '    uint64 numPresses;\n', '    uint64 cooloffEnd;\n', '  }\n', '\n', '  mapping (address => Presser) public pressers;\n', '\n', '  function Button(\n', '    uint64 _countdown, \n', '    uint64 _countdownDecrement, \n', '    uint64 _cooloffIncrement, \n', '    uint64 _pressFee, \n', '    uint64 _signupFee, \n', '    address _club\n', '  ) public payable {\n', '    countdown = _countdown;\n', '    countdownDecrement = _countdownDecrement;\n', '    cooloffIncrement = _cooloffIncrement;\n', '    pressFee = _pressFee;\n', '    signupFee = _signupFee;\n', '    club = Club(_club);\n', '\n', '    lastPresser = msg.sender;\n', '    endBlock = uint64(block.number + countdown);\n', '  }\n', '\n', '  function press() public payable {\n', '    require(block.number <= endBlock);\n', '\n', '    uint256 change = msg.value-pressFee;\n', '    Presser storage p = pressers[msg.sender];\n', '    require(p.cooloffEnd < block.number);\n', '\n', '    if (p.numPresses == 0) {\n', '      // balance - value will never be negative.\n', '      uint128 npf = _newPresserFee(address(this).balance - msg.value);\n', '      change -= npf;\n', '      address(club).transfer(npf);\n', '    }\n', '    // Breaks when pressFee+presserFee > 2^256\n', '    require(change <= msg.value);\n', '\n', '    lastPresser = msg.sender;\n', '    uint64 finalCountdown = countdown - (p.numPresses*countdownDecrement);\n', '    if (finalCountdown < 10 || finalCountdown > countdown) {\n', '      finalCountdown = 10;\n', '    }\n', '    endBlock = uint64(block.number + finalCountdown);\n', '\n', '    p.numPresses++;\n', '    p.cooloffEnd = uint64(block.number + (p.numPresses*cooloffIncrement));\n', '\n', '    if (change > 0) {\n', '      msg.sender.transfer(change);\n', '    }\n', '\n', '    Pressed(msg.sender, endBlock);\n', '  }\n', '\n', '  function close() public {\n', '    require(block.number > endBlock);\n', '    require(lastPresser == msg.sender);\n', '    Winner(msg.sender, address(this).balance);\n', '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  // Breaks when balance = 10^20 ether.\n', '  function newPresserFee() public view returns (uint128) {\n', '    return _newPresserFee(address(this).balance);\n', '  }\n', '\n', '  function isMember() public view returns (bool) {\n', '    return _isMember();\n', '  }\n', '\n', '  // Caller must assure that _balance < max_uint128.\n', '  function _newPresserFee(uint256 _balance) private view returns (uint128) {\n', '    if (_isMember()){\n', '      return 0;\n', '    }\n', '    return uint128((_balance * signupFee) / 10000);\n', '  }\n', '\n', '  function _isMember() private view returns (bool) {\n', '    var(un, k, cwp, bp) = club.members(msg.sender);\n', '    // members have non-zero birthPeriods\n', '    return bp != 0;\n', '  }\n', '\n', '  // Up the stakes...\n', '  function() payable public {}\n', '}']
