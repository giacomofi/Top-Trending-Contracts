['/**\n', ' *  https://Smart-234.io\n', ' *\n', ' * Smart-contract start at 11 Dec 2018 10:00 UTC\n', ' *\n', ' *\n', ' * Smart-234 Contract\n', ' *  - GAIN 2.34% PER 24 HOURS\n', ' *  -     +0.02% every day before the payment\n', ' *\n', ' *  - Minimal contribution 0.01 eth\n', ' *  - Currency and payment - ETH\n', ' *  - Contribution allocation schemes:\n', ' *    -- 96% payments\n', ' *    -- 4% Marketing\n', ' *\n', ' *\n', ' * You get MORE PROFIT if you withdraw later !\n', ' * Increase of the total rate of return by 0.02% every day before the payment.\n', ' * The increase in profitability affects all previous days!\n', ' *  After the dividend is paid, the rate of return is returned to 2.34 % per day\n', ' *\n', ' *           For example: if the Deposit is 10 ETH\n', ' *\n', ' *                days      |   %    |   profit\n', ' *          --------------------------------------\n', ' *            1 (>24 hours) | 2.36 % | 0.235 ETH\n', ' *              10          | 2.54 % | 2.54  ETH\n', ' *              30          | 2.94 % | 8.82  ETH\n', ' *              50          | 3.34 % | 16.7  ETH\n', ' *              100         | 4.34 % | 43.4  ETH\n', ' *\n', ' *\n', ' * How to use:\n', ' *  1. Send any amount of ether to make an investment\n', " *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\n", ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * RECOMMENDED GAS LIMIT: 250000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' * Contract reviewed and approved by experts!\n', ' *\n', ' */\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract InvestorsStorage {\n', '    using SafeMath for uint256;\n', '\n', '    address private owner;\n', '    uint private _investorsCount;\n', '\n', '    struct Deposit {\n', '        uint amount;\n', '        uint start;\n', '    }\n', '\n', '    struct Investor {\n', '        Deposit[] deposits;\n', '        uint checkpoint;\n', '        address referrer;\n', '    }\n', '\n', '    mapping (address => Investor) private investors;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function addDeposit(address _address, uint _value) external onlyOwner {\n', '        investors[_address].deposits.push(Deposit(_value, block.timestamp));\n', '        if (investors[_address].checkpoint == 0) {\n', '            investors[_address].checkpoint = block.timestamp;\n', '            _investorsCount += 1;\n', '        }\n', '    }\n', '\n', '    function updateCheckpoint(address _address) external onlyOwner {\n', '        investors[_address].checkpoint = block.timestamp;\n', '    }\n', '\n', '    function addReferrer(address _referral, address _referrer) external onlyOwner {\n', '        investors[_referral].referrer = _referrer;\n', '    }\n', '\n', '    function getInterest(address _address, uint _index, bool _exception) public view returns(uint) {\n', '        if (investors[_address].deposits[_index].amount > 0) {\n', '            if (_exception) {\n', '                uint time = investors[_address].deposits[_index].start;\n', '            } else {\n', '                time = investors[_address].checkpoint;\n', '            }\n', '            return(234 + ((block.timestamp - time) / 1 days) * 2);\n', '        }\n', '    }\n', '\n', '    function isException(address _address, uint _index) public view returns(bool) {\n', '        if (investors[_address].deposits[_index].start > investors[_address].checkpoint) {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function d(address _address, uint _index) public view returns(uint) {\n', '        return investors[_address].deposits[_index].amount;\n', '    }\n', '\n', '    function c(address _address) public view returns(uint) {\n', '        return investors[_address].checkpoint;\n', '    }\n', '\n', '    function r(address _address) external view returns(address) {\n', '        return investors[_address].referrer;\n', '    }\n', '\n', '    function s(address _address, uint _index) public view returns(uint) {\n', '        return investors[_address].deposits[_index].start;\n', '    }\n', '\n', '    function sumOfDeposits(address _address) external view returns(uint) {\n', '        uint sum;\n', '        for (uint i = 0; i < investors[_address].deposits.length; i++) {\n', '            sum += investors[_address].deposits[i].amount;\n', '        }\n', '        return sum;\n', '    }\n', '\n', '    function amountOfDeposits(address _address) external view returns(uint) {\n', '        return investors[_address].deposits.length;\n', '    }\n', '\n', '    function dividends(address _address) external view returns(uint) {\n', '        uint _payout;\n', '        uint percent = getInterest(_address, 0, false);\n', '\n', '        for (uint i = 0; i < investors[_address].deposits.length; i++) {\n', '            if (!isException(_address, i)) {\n', '                _payout += (d(_address, i).mul(percent).div(10000)).mul(block.timestamp.sub(c(_address))).div(1 days);\n', '            } else {\n', '                _payout += (d(_address, i).mul(getInterest(_address, i, true)).div(10000)).mul(block.timestamp.sub(s(_address, i))).div(1 days);\n', '            }\n', '        }\n', '\n', '        return _payout;\n', '    }\n', '\n', '    function investorsCount() external view returns(uint) {\n', '        return _investorsCount;\n', '    }\n', '}\n', '\n', 'contract Smart234 {\n', '    using SafeMath for uint;\n', '\n', '    address admin;\n', '    uint waveStartUp;\n', '\n', '    uint invested;\n', '    uint payed;\n', '    uint startTime;\n', '\n', '    event LogInvestment(address indexed _addr, uint _value, uint _bonus);\n', '    event LogIncome(address indexed _addr, uint _value);\n', '    event LogReferrerAdded(address indexed _investor, address indexed _referrer);\n', '    event LogRefBonus(address indexed _investor, address indexed _referrer, uint _amount, uint indexed _level);\n', '    event LogNewWave(uint _waveStartUp);\n', '\n', '    InvestorsStorage private x;\n', '\n', '    modifier notOnPause() {\n', '        require(waveStartUp <= block.timestamp);\n', '        _;\n', '    }\n', '\n', '    function bytesToAddress(bytes _source) internal pure returns(address parsedReferrer) {\n', '        assembly {\n', '            parsedReferrer := mload(add(_source,0x14))\n', '        }\n', '        return parsedReferrer;\n', '    }\n', '\n', '    function addReferrer() internal returns(uint) {\n', '        address _referrer = bytesToAddress(bytes(msg.data));\n', '        if (_referrer != msg.sender) {\n', '            x.addReferrer(msg.sender, _referrer);\n', '            emit LogReferrerAdded(msg.sender, _referrer);\n', '            return(msg.value / 20);\n', '        }\n', '    }\n', '\n', '    function refSystem() private {\n', '        address first = x.r(msg.sender);\n', '        if (x.amountOfDeposits(first) < 500) {\n', '            x.addDeposit(first, msg.value / 10);\n', '            emit LogRefBonus(msg.sender, first, msg.value / 10, 1);\n', '        }\n', '        address second = x.r(first);\n', '        if (second != 0x0) {\n', '            if (x.amountOfDeposits(second) < 500) {\n', '                x.addDeposit(second, msg.value / 20);\n', '                emit LogRefBonus(msg.sender, second, msg.value / 20, 2);\n', '            }\n', '            address third = x.r(second);\n', '            if (third != 0x0) {\n', '                if (x.amountOfDeposits(third) < 500) {\n', '                    x.addDeposit(third, msg.value * 3 / 100);\n', '                    emit LogRefBonus(msg.sender, third, msg.value * 3 / 100, 3);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    constructor(address _admin) public {\n', '        admin = _admin;\n', '        x = new InvestorsStorage();\n', '        startTime = 1544522400;\n', '        waveStartUp = 1544522400;\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value == 0) {\n', '            withdraw();\n', '        } else {\n', '            invest();\n', '        }\n', '    }\n', '\n', '    function invest() notOnPause public payable {\n', '        require(msg.value >= 0.01 ether);\n', '        admin.transfer(msg.value / 25);\n', '\n', '        if (x.r(msg.sender) != 0x0) {\n', '            refSystem();\n', '        } else if (msg.data.length == 20) {\n', '            uint bonus = addReferrer();\n', '            refSystem();\n', '        }\n', '\n', '        x.addDeposit(msg.sender, msg.value + bonus);\n', '\n', '        invested += msg.value;\n', '        emit LogInvestment(msg.sender, msg.value, bonus);\n', '    }\n', '\n', '    function withdraw() public {\n', '\n', '        uint _payout = x.dividends(msg.sender);\n', '\n', '        if (_payout > 0) {\n', '\n', '            if (_payout > address(this).balance) {\n', '                nextWave();\n', '                return;\n', '            }\n', '\n', '            x.updateCheckpoint(msg.sender);\n', '            admin.transfer(_payout / 25);\n', '            msg.sender.transfer(_payout * 24 / 25);\n', '            emit LogIncome(msg.sender, _payout);\n', '            payed += _payout;\n', '        }\n', '    }\n', '\n', '    function getDeposits(address _address) external view returns(uint) {\n', '        return x.sumOfDeposits(_address);\n', '    }\n', '\n', '    function getDividends(address _address) external view returns(uint) {\n', '        return x.dividends(_address);\n', '    }\n', '\n', '    function getDividendsWithFee(address _address) external view returns(uint) {\n', '        return x.dividends(_address) * 24 / 25;\n', '    }\n', '\n', '    function getDaysAfterStart() external view returns(uint) {\n', '        return (block.timestamp.sub(startTime)) / 1 days;\n', '    }\n', '\n', '    function investorsCount() external view returns(uint) {\n', '        return x.investorsCount();\n', '    }\n', '\n', '    function getInvestedAmount() external view returns(uint) {\n', '        return invested;\n', '    }\n', '\n', '    function getPayedAmount() external view returns(uint) {\n', '        return payed;\n', '    }\n', '\n', '    function nextWave() private {\n', '        x = new InvestorsStorage();\n', '        invested = 0;\n', '        payed = 0;\n', '        waveStartUp = block.timestamp + 7 days;\n', '        emit LogNewWave(waveStartUp);\n', '    }\n', '}']