['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* ZETHR PRESENTS: SLOTS\n', '*\n', '* Written August 2018 by the Zethr team for zethr.io.\n', '*\n', '* Code framework written by Norsefire.\n', '* EV calculations written by TropicalRogue.\n', '* Audit and edits written by Klob.\n', '* Multiroll framework written by Etherguy.\n', '*\n', '* Rolling Odds:\n', '*   49.31%  Lose / 50.69% Win  \n', '*   35.64%  Two Matching Icons\n', '*       - 10.00% : 2.50x    Multiplier [Two Rockets]\n', '*       - 15.00% : 1.33x    Multiplier [Two Gold  Pyramids]\n', '*       - 15.00% : 1.00x    Multiplier [Two &#39;Z&#39; Symbols]\n', '*       - 15.00% : 1.00x    Multiplier [Two &#39;T&#39; Symbols]\n', '*       - 15.00% : 1.00x    Multiplier [Two &#39;H&#39; Symbols]\n', '*       - 15.00% : 1.25x    Multiplier [Two Purple Pyramids]\n', '*       - 15.00% : 2.00x    Multiplier [Two Ether Icons]\n', '*   6.79%   One Of Each Pyramid\n', '*       - 1.50x  Multiplier\n', '*   2.94%   One Moon Icon\n', '*       - 2.50x Multiplier\n', '*   5.00%   Three Matching Icons\n', '*       - 03.00% : 13.00x   Multiplier [Three Rockets]\n', '*       - 05.00% : 09.00x   Multiplier [Three Gold  Pyramids]\n', '*       - 27.67% : 03.00x   Multiplier [Three &#39;Z&#39; Symbols]\n', '*       - 27.67% : 03.00x   Multiplier [Three &#39;T&#39; Symbols]\n', '*       - 27.67% : 03.00x   Multiplier [Three &#39;H&#39; Symbols]\n', '*       - 05.00% : 07.50x   Multiplier [Three Purple Pyramids]\n', '*       - 04.00% : 11.00x   Multiplier [Three Ether Icons]\n', '*   0.28%   Z T H Prize\n', '*       - 20x Multiplier\n', '*   0.03%   Two Moon Icons\n', '*       - 50x  Multiplier\n', '*   0.0001% Three Moon Grand Jackpot\n', '*       - Jackpot Amount (variable)\n', '*\n', '*   From all of us at Zethr, thank you for playing!    \n', '*\n', '*/\n', '\n', '// Zethr Token Bankroll interface\n', 'contract ZethrTokenBankroll{\n', '  // Game request token transfer to player \n', '  function gameRequestTokens(address target, uint tokens) public;\n', '  function gameTokenAmount(address what) public returns (uint);\n', '}\n', '\n', '// Zether Main Bankroll interface\n', 'contract ZethrMainBankroll{\n', '  function gameGetTokenBankrollList() public view returns (address[7]);\n', '}\n', '\n', '// Zethr main contract interface\n', 'contract ZethrInterface{\n', '  function withdraw() public;\n', '}\n', '\n', '// Library for figuring out the "tier" (1-7) of a dividend rate\n', 'library ZethrTierLibrary{\n', '\n', '  function getTier(uint divRate) \n', '    internal \n', '    pure \n', '    returns (uint)\n', '  {\n', '    // Tier logic \n', '    // Returns the index of the UsedBankrollAddresses which should be used to call into to withdraw tokens \n', '        \n', '    // We can divide by magnitude\n', '    // Remainder is removed so we only get the actual number we want\n', '    uint actualDiv = divRate; \n', '    if (actualDiv >= 30){\n', '      return 6;\n', '    } else if (actualDiv >= 25){\n', '      return 5;\n', '    } else if (actualDiv >= 20){\n', '      return 4;\n', '    } else if (actualDiv >= 15){\n', '      return 3;\n', '    } else if (actualDiv >= 10){\n', '      return 2; \n', '    } else if (actualDiv >= 5){\n', '      return 1;\n', '    } else if (actualDiv >= 2){\n', '      return 0;\n', '    } else{\n', '      // Impossible\n', '      revert(); \n', '    }\n', '  }\n', '}\n', '\n', '// Contract that contains the functions to interact with the ZlotsJackpotHoldingContract\n', 'contract ZlotsJackpotHoldingContract {\n', '  function payOutWinner(address winner) public; \n', '  function getJackpot() public view returns (uint);\n', '}\n', ' \n', '// Contract that contains the functions to interact with the bankroll system\n', 'contract ZethrBankrollBridge {\n', '  // Must have an interface with the main Zethr token contract \n', '  ZethrInterface Zethr;\n', '   \n', '  // Store the bankroll addresses \n', '  // address[0] is tier1: 2-5% \n', '  // address[1] is tier2: 5-10, etc\n', '  address[7] UsedBankrollAddresses; \n', '\n', '  // Mapping for easy checking\n', '  mapping(address => bool) ValidBankrollAddress;\n', '    \n', '  // Set up the tokenbankroll stuff \n', '  function setupBankrollInterface(address ZethrMainBankrollAddress) \n', '    internal \n', '  {\n', '    // Instantiate Zethr\n', '    Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D);\n', '\n', '    // Get the bankroll addresses from the main bankroll\n', '    UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\n', '    for(uint i=0; i<7; i++){\n', '      ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\n', '    }\n', '  }\n', '    \n', '  // Require a function to be called from a *token* bankroll \n', '  modifier fromBankroll() {\n', '    require(ValidBankrollAddress[msg.sender], "msg.sender should be a valid bankroll");\n', '    _;\n', '  }\n', '    \n', '  // Request a payment in tokens to a user FROM the appropriate tokenBankroll \n', '  // Figure out the right bankroll via divRate \n', '  function RequestBankrollPayment(address to, uint tokens, uint tier) \n', '    internal \n', '  {\n', '    address tokenBankrollAddress = UsedBankrollAddresses[tier];\n', '    ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\n', '  }\n', '    \n', '  function getZethrTokenBankroll(uint divRate) \n', '    public \n', '    constant \n', '    returns (ZethrTokenBankroll)\n', '  {\n', '    return ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)]);\n', '  }\n', '}\n', '\n', '// Contract that contains functions to move divs to the main bankroll\n', 'contract ZethrShell is ZethrBankrollBridge {\n', '\n', '  // Dump ETH balance to main bankroll\n', '  function WithdrawToBankroll() \n', '    public \n', '  {\n', '    address(UsedBankrollAddresses[0]).transfer(address(this).balance);\n', '  }\n', '\n', '  // Dump divs and dump ETH into bankroll\n', '  function WithdrawAndTransferToBankroll() \n', '    public \n', '  {\n', '    Zethr.withdraw();\n', '    WithdrawToBankroll();\n', '  }\n', '}\n', '\n', '// Zethr game data setup\n', '// Includes all necessary to run with Zethr\n', 'contract ZlotsMulti is ZethrShell {\n', '  using SafeMath for uint;\n', '\n', '  // ---------------------- Events\n', '\n', '  // Might as well notify everyone when the house takes its cut out.\n', '  event HouseRetrievedTake(\n', '    uint timeTaken,\n', '    uint tokensWithdrawn\n', '  );\n', '\n', '  // Fire an event whenever someone places a bet.\n', '  event TokensWagered(\n', '    address _wagerer,\n', '    uint _wagered\n', '  );\n', '\n', '  event LogResult(\n', '    address _wagerer,\n', '    uint _result,\n', '    uint _profit,\n', '    uint _wagered,\n', '    uint _category,\n', '    bool _win\n', '  );\n', '\n', '  // Result announcement events (to dictate UI output!)\n', '  event Loss(address _wagerer, uint _block);                  // Category 0\n', '  event ThreeMoonJackpot(address _wagerer, uint _block);      // Category 1\n', '  event TwoMoonPrize(address _wagerer, uint _block);          // Category 2\n', '  event ZTHPrize(address _wagerer, uint _block);              // Category 3\n', '  event ThreeZSymbols(address _wagerer, uint _block);         // Category 4\n', '  event ThreeTSymbols(address _wagerer, uint _block);         // Category 5\n', '  event ThreeHSymbols(address _wagerer, uint _block);         // Category 6\n', '  event ThreeEtherIcons(address _wagerer, uint _block);       // Category 7\n', '  event ThreePurplePyramids(address _wagerer, uint _block);   // Category 8\n', '  event ThreeGoldPyramids(address _wagerer, uint _block);     // Category 9\n', '  event ThreeRockets(address _wagerer, uint _block);          // Category 10\n', '  event OneMoonPrize(address _wagerer, uint _block);          // Category 11\n', '  event OneOfEachPyramidPrize(address _wagerer, uint _block); // Category 12\n', '  event TwoZSymbols(address _wagerer, uint _block);           // Category 13\n', '  event TwoTSymbols(address _wagerer, uint _block);           // Category 14\n', '  event TwoHSymbols(address _wagerer, uint _block);           // Category 15\n', '  event TwoEtherIcons(address _wagerer, uint _block);         // Category 16\n', '  event TwoPurplePyramids(address _wagerer, uint _block);     // Category 17\n', '  event TwoGoldPyramids(address _wagerer, uint _block);       // Category 18\n', '  event TwoRockets(address _wagerer, uint _block);            // Category 19    \n', '  event SpinConcluded(address _wagerer, uint _block);         // Debug event\n', '\n', '  // ---------------------- Modifiers\n', '\n', '  // Makes sure that player porfit can&#39;t exceed a maximum amount\n', '  // We use the max win here - 50x\n', '  modifier betIsValid(uint _betSize, uint divRate, uint8 spins) {\n', '    require(_betSize.div(spins).mul(50) <= getMaxProfit(divRate));\n', '    require(_betSize.div(spins) >= minBet);\n', '    _;\n', '  }\n', '\n', '  // Requires the game to be currently active\n', '  modifier gameIsActive {\n', '    require(gamePaused == false);\n', '    _;\n', '  }\n', '\n', '  // Require msg.sender to be owner\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner); \n', '    _;\n', '  }\n', '\n', '  // Requires msg.sender to be bankroll\n', '  modifier onlyBankroll {\n', '    require(msg.sender == bankroll);\n', '    _;\n', '  }\n', '\n', '  // Requires msg.sender to be owner or bankroll\n', '  modifier onlyOwnerOrBankroll {\n', '    require(msg.sender == owner || msg.sender == bankroll);\n', '    _;\n', '  }\n', '\n', '  // ---------------------- Variables\n', '\n', '  // Configurables\n', '  uint constant public maxProfitDivisor = 1000000;\n', '  uint constant public houseEdgeDivisor = 1000;\n', '  mapping (uint => uint) public maxProfit;\n', '  uint public maxProfitAsPercentOfHouse;\n', '  uint public minBet = 1e18;\n', '  address public zlotsJackpot;\n', '  address private owner;\n', '  address private bankroll;\n', '  bool gamePaused;\n', '\n', '  // Trackers\n', '  uint  public totalSpins;\n', '  uint  public totalZTHWagered;\n', '  mapping (uint => uint) public contractBalance;\n', '    \n', '  // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\n', '  bool public gameActive;\n', '\n', '  // Bankroll & token addresses\n', '  address private ZTHTKNADDR;\n', '  address private ZTHBANKROLL;\n', '\n', '  // ---------------------- Functions \n', '\n', '  // Constructor; must supply bankroll address\n', '  constructor(address BankrollAddress) \n', '    public \n', '  {\n', '    // Set up the bankroll interface\n', '    setupBankrollInterface(BankrollAddress); \n', '\n', '    // Owner is deployer\n', '    owner = msg.sender;\n', '\n', '    // Default max profit to 5% of contract balance\n', '    ownerSetMaxProfitAsPercentOfHouse(50000);\n', '\n', '    // Set starting variables\n', '    bankroll      = ZTHBANKROLL;\n', '    gameActive  = true;\n', '\n', '    // Init min bet (1 ZTH)\n', '    ownerSetMinBet(1e18);\n', '  }\n', '\n', '  // Zethr dividends gained are accumulated and sent to bankroll manually\n', '  function() public payable {  }\n', '\n', '  // If the contract receives tokens, bundle them up in a struct and fire them over to _spinTokens for validation.\n', '  struct TKN { address sender; uint value; }\n', '  function execute(address _from, uint _value, uint divRate, bytes _data) \n', '    public \n', '    fromBankroll \n', '    returns (bool)\n', '  {\n', '      TKN memory _tkn;\n', '      _tkn.sender = _from;\n', '      _tkn.value = _value;\n', '      _spinTokens(_tkn, divRate, uint8(_data[0]));\n', '      return true;\n', '  }\n', '\n', '  struct playerSpin {\n', '    uint192 tokenValue; // Token value in uint\n', '    uint48 blockn;      // Block number 48 bits\n', '    uint8 tier;\n', '    uint8 spins;\n', '    uint divRate;\n', '  }\n', '\n', '  // Mapping because a player can do one spin at a time\n', '  mapping(address => playerSpin) public playerSpins;\n', '\n', '  // Execute spin.\n', '  function _spinTokens(TKN _tkn, uint divRate, uint8 spins) \n', '    private \n', '    betIsValid(_tkn.value, divRate, spins)\n', '  {\n', '    require(gameActive);\n', '    require(block.number <= ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint56\n', '    require(_tkn.value <= ((2 ** 192) - 1));\n', '    address _customerAddress = _tkn.sender;\n', '    uint    _wagered         = _tkn.value;\n', '\n', '    playerSpin memory spin = playerSpins[_tkn.sender];\n', ' \n', '    // We update the contract balance *before* the spin is over, not after\n', '    // This means that we don&#39;t have to worry about unresolved rolls never resolving\n', '    // (we also update it when a player wins)\n', '    addContractBalance(divRate, _wagered);\n', '\n', '    // Cannot spin twice in one block\n', '    require(block.number != spin.blockn);\n', '\n', '    // If there exists a spin, finish it\n', '    if (spin.blockn != 0) {\n', '      _finishSpin(_tkn.sender);\n', '    }\n', '\n', '    // Set struct block number and token value\n', '    spin.blockn = uint48(block.number);\n', '    spin.tokenValue = uint192(_wagered.div(spins));\n', '    spin.tier = uint8(ZethrTierLibrary.getTier(divRate));\n', '    spin.divRate = divRate;\n', '    spin.spins = spins;\n', '\n', '    // Store the roll struct - 40k gas.\n', '    playerSpins[_tkn.sender] = spin;\n', '\n', '    // Increment total number of spins\n', '    totalSpins += spins;\n', '\n', '    // Total wagered\n', '    totalZTHWagered += _wagered;\n', '\n', '    emit TokensWagered(_customerAddress, _wagered);\n', '  }\n', '\n', '  // Finish the current spin of a player, if they have one\n', '  function finishSpin() \n', '    public\n', '    gameIsActive\n', '    returns (uint[])\n', '  {\n', '    return _finishSpin(msg.sender);\n', '  }\n', '\n', '  // Stores the data for the roll (spin)\n', '  struct rollData {\n', '    uint win;\n', '    uint loss; \n', '    uint jp;\n', '  }\n', '\n', '  // Pay winners, update contract balance, send rewards where applicable.\n', '  function _finishSpin(address target)\n', '    private \n', '    returns (uint[])\n', '  {\n', '    playerSpin memory spin = playerSpins[target];\n', '\n', '    require(spin.tokenValue > 0); // No re-entrancy\n', '    require(spin.blockn != block.number);\n', '        \n', '    uint[] memory output = new uint[](spin.spins);\n', '    rollData memory outcomeTrack = rollData(0,0,0);\n', '    uint category = 0;\n', '    uint profit;\n', '    uint playerDivrate = spin.divRate;\n', '        \n', '    for(uint i=0; i<spin.spins; i++) {\n', '        \n', '      // If the block is more than 255 blocks old, we can&#39;t get the result\n', '      // Also, if the result has already happened, fail as well\n', '      uint result;\n', '      if (block.number - spin.blockn > 255) {\n', '        result = 1000000; // Can&#39;t win: default to largest number\n', '        output[i] = 1000000;\n', '      } else {\n', '        // Generate a result - random based ONLY on a past block (future when submitted).\n', '        // Case statement barrier numbers defined by the current payment schema at the top of the contract.\n', '        result = random(1000000, spin.blockn, target, i) + 1;\n', '        output[i] = result;\n', '      }\n', '\n', '      if (result > 506856) {\n', '        // Player has lost. Womp womp.\n', '\n', '        // Add one percent of player loss to the jackpot\n', '        // (do this by requesting a payout to the jackpot)\n', '        outcomeTrack.loss += spin.tokenValue/100;\n', '\n', '        emit Loss(target, spin.blockn);\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, false);\n', '      } else if (result < 2) {\n', '        // Player has won the three-moon mega jackpot!\n', '      \n', '        // Get profit amount via jackpot\n', '        profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot();\n', '        category = 1;\n', '    \n', '        // Emit events\n', '        emit ThreeMoonJackpot(target, spin.blockn);\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '\n', '        outcomeTrack.jp += 1;\n', '\n', '      } else {\n', '        if (result < 299) {\n', '          // Player has won a two-moon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 50);\n', '          category = 2;\n', '          emit TwoMoonPrize(target, spin.blockn);\n', '        } else if (result < 3128) {\n', '          // Player has won the Z T H prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 20);\n', '          category = 3;\n', '          emit ZTHPrize(target, spin.blockn);\n', '        } else if (result < 16961) {\n', '          // Player has won a three Z symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 4;\n', '          emit ThreeZSymbols(target, spin.blockn);\n', '        } else if (result < 30794) {\n', '          // Player has won a three T symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 5;\n', '          emit ThreeTSymbols(target, spin.blockn);\n', '        } else if (result < 44627) {\n', '          // Player has won a three H symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 6;\n', '          emit ThreeHSymbols(target, spin.blockn);\n', '        } else if (result < 46627) {\n', '          // Player has won a three Ether icon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 11);\n', '          category = 7;\n', '          emit ThreeEtherIcons(target, spin.blockn);\n', '        } else if (result < 49127) {\n', '          // Player has won a three purple pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 75), 10);\n', '          category = 8;\n', '          emit ThreePurplePyramids(target, spin.blockn);\n', '        } else if (result < 51627) {\n', '          // Player has won a three gold pyramid prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 9);\n', '          category = 9;\n', '          emit ThreeGoldPyramids(target, spin.blockn);\n', '        } else if (result < 53127) {\n', '          // Player has won a three rocket prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 13);\n', '          category = 10;\n', '          emit ThreeRockets(target, spin.blockn);\n', '        } else if (result < 82530) {\n', '          // Player has won a one moon prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25),10);\n', '          category = 11;\n', '          emit OneMoonPrize(target, spin.blockn);\n', '        } else if (result < 150423) {\n', '          // Player has won a each-coloured-pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n', '          category = 12;\n', '          emit OneOfEachPyramidPrize(target, spin.blockn);\n', '        } else if (result < 203888) {\n', '          // Player has won a two Z symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 13;\n', '          emit TwoZSymbols(target, spin.blockn);\n', '        } else if (result < 257353) {\n', '          // Player has won a two T symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 14;\n', '          emit TwoTSymbols(target, spin.blockn);\n', '        } else if (result < 310818) {\n', '          // Player has won a two H symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 15;\n', '          emit TwoHSymbols(target, spin.blockn);\n', '        } else if (result < 364283) {\n', '          // Player has won a two Ether icon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 2);\n', '          category = 16;\n', '          emit TwoEtherIcons(target, spin.blockn);\n', '        } else if (result < 417748) {\n', '          // Player has won a two purple pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125), 100);\n', '          category = 17;\n', '          emit TwoPurplePyramids(target, spin.blockn);\n', '        } else if (result < 471213) {\n', '          // Player has won a two gold pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 133), 100);\n', '          category = 18;\n', '          emit TwoGoldPyramids(target, spin.blockn);\n', '        } else {\n', '          // Player has won a two rocket prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\n', '          category = 19;\n', '          emit TwoRockets(target, spin.blockn);\n', '        }\n', '\n', '        uint newMaxProfit = getNewMaxProfit(playerDivrate, outcomeTrack.win);\n', '        if (profit > newMaxProfit){\n', '          profit = newMaxProfit;\n', '        }\n', '\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '        outcomeTrack.win += profit;\n', '      }\n', '    }\n', '\n', '    playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0));\n', '    if (outcomeTrack.jp > 0) {\n', '      for (i = 0; i < outcomeTrack.jp; i++) {\n', '        // In the weird case a player wins two jackpots, we of course pay them twice \n', '        ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target);\n', '      }\n', '    }\n', '\n', '    if (outcomeTrack.win > 0) {\n', '      RequestBankrollPayment(target, outcomeTrack.win, spin.tier);\n', '    }\n', '\n', '    if (outcomeTrack.loss > 0) {\n', '      // This loss is the loss to pay to the jackpot account \n', '      // The delta in contractBalance is already updated in a pending bet.\n', '      RequestBankrollPayment(zlotsJackpot, outcomeTrack.loss, spin.tier);\n', '    }\n', '            \n', '    emit SpinConcluded(target, spin.blockn);\n', '    return output;\n', '  }   \n', '\n', '  // Returns a random number using a specified block number\n', '  // Always use a FUTURE block number.\n', '  function maxRandom(uint blockn, address entropy, uint index) \n', '    private \n', '    view\n', '    returns (uint256 randomNumber) \n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(blockn),\n', '          entropy,\n', '          index\n', '    )));\n', '  }\n', '\n', '  // Random helper\n', '  function random(uint256 upper, uint256 blockn, address entropy, uint index)\n', '    internal \n', '    view \n', '    returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(blockn, entropy, index) % upper;\n', '  }\n', '\n', '  // Sets max profit (internal)\n', '  function setMaxProfit(uint divRate) \n', '    internal \n', '  {\n', '    maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor; \n', '  } \n', '\n', '  // Gets max profit  \n', '  function getMaxProfit(uint divRate) \n', '    public \n', '    view \n', '    returns (uint) \n', '  {\n', '    return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '  }\n', '\n', '  function getNewMaxProfit(uint divRate, uint currentWin) \n', '    public \n', '    view \n', '    returns (uint) \n', '  {\n', '    return ((contractBalance[divRate] - currentWin) * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '  }\n', '\n', '  // Subtracts from the contract balance tracking var\n', '  function subContractBalance(uint divRate, uint sub) \n', '    internal \n', '  {\n', '    contractBalance[divRate] = contractBalance[divRate].sub(sub);\n', '  }\n', '\n', '  // Adds to the contract balance tracking var\n', '  function addContractBalance(uint divRate, uint add) \n', '    internal \n', '  {\n', '    contractBalance[divRate] = contractBalance[divRate].add(add);\n', '  }\n', '\n', '  // An EXTERNAL update of tokens should be handled here\n', '  // This is due to token allocation\n', '  // The game should handle internal updates itself (e.g. tokens are betted)\n', '  function bankrollExternalUpdateTokens(uint divRate, uint newBalance) \n', '    public \n', '    fromBankroll \n', '  {\n', '    contractBalance[divRate] = newBalance;\n', '    setMaxProfit(divRate);\n', '  }\n', '\n', '  // Set the new max profit as percent of house - can be as high as 20%\n', '  // (1,000,000 = 100%)\n', '  function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) \n', '    public\n', '    onlyOwner\n', '  {\n', '    // Restricts each bet to a maximum profit of 50% contractBalance\n', '    require(newMaxProfitAsPercent <= 500000);\n', '    maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n', '    setMaxProfit(2);\n', '    setMaxProfit(5);\n', '    setMaxProfit(10);\n', '    setMaxProfit(15); \n', '    setMaxProfit(20);\n', '    setMaxProfit(25);\n', '    setMaxProfit(33);\n', '  }\n', '\n', '  // Only owner can set minBet   \n', '  function ownerSetMinBet(uint newMinimumBet) \n', '    public\n', '    onlyOwner\n', '  {\n', '    minBet = newMinimumBet;\n', '  }\n', '\n', '  // Only owner can set zlotsJackpot address\n', '  function ownerSetZlotsAddress(address zlotsAddress) \n', '    public\n', '    onlyOwner\n', '  {\n', '    zlotsJackpot = zlotsAddress;\n', '  }\n', '\n', '  // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\n', '  function pauseGame() \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    gameActive = false;\n', '  }\n', '\n', '  // The converse of the above, resuming betting if a freeze had been put in place.\n', '  function resumeGame() \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    gameActive = true;\n', '  }\n', '\n', '  // Administrative function to change the owner of the contract.\n', '  function changeOwner(address _newOwner) \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    owner = _newOwner;\n', '  }\n', '\n', '  // Administrative function to change the Zethr bankroll contract, should the need arise.\n', '  function changeBankroll(address _newBankroll) \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    bankroll = _newBankroll;\n', '  }\n', '\n', '  // Is the address that the token has come from actually ZTH?\n', '  function _zthToken(address _tokenContract) \n', '    private \n', '    view \n', '    returns (bool) \n', '  {\n', '    return _tokenContract == ZTHTKNADDR;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint a, uint b) \n', '    internal \n', '    pure returns (uint) \n', '  {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/*\n', '* ZETHR PRESENTS: SLOTS\n', '*\n', '* Written August 2018 by the Zethr team for zethr.io.\n', '*\n', '* Code framework written by Norsefire.\n', '* EV calculations written by TropicalRogue.\n', '* Audit and edits written by Klob.\n', '* Multiroll framework written by Etherguy.\n', '*\n', '* Rolling Odds:\n', '*   49.31%  Lose / 50.69% Win  \n', '*   35.64%  Two Matching Icons\n', '*       - 10.00% : 2.50x    Multiplier [Two Rockets]\n', '*       - 15.00% : 1.33x    Multiplier [Two Gold  Pyramids]\n', "*       - 15.00% : 1.00x    Multiplier [Two 'Z' Symbols]\n", "*       - 15.00% : 1.00x    Multiplier [Two 'T' Symbols]\n", "*       - 15.00% : 1.00x    Multiplier [Two 'H' Symbols]\n", '*       - 15.00% : 1.25x    Multiplier [Two Purple Pyramids]\n', '*       - 15.00% : 2.00x    Multiplier [Two Ether Icons]\n', '*   6.79%   One Of Each Pyramid\n', '*       - 1.50x  Multiplier\n', '*   2.94%   One Moon Icon\n', '*       - 2.50x Multiplier\n', '*   5.00%   Three Matching Icons\n', '*       - 03.00% : 13.00x   Multiplier [Three Rockets]\n', '*       - 05.00% : 09.00x   Multiplier [Three Gold  Pyramids]\n', "*       - 27.67% : 03.00x   Multiplier [Three 'Z' Symbols]\n", "*       - 27.67% : 03.00x   Multiplier [Three 'T' Symbols]\n", "*       - 27.67% : 03.00x   Multiplier [Three 'H' Symbols]\n", '*       - 05.00% : 07.50x   Multiplier [Three Purple Pyramids]\n', '*       - 04.00% : 11.00x   Multiplier [Three Ether Icons]\n', '*   0.28%   Z T H Prize\n', '*       - 20x Multiplier\n', '*   0.03%   Two Moon Icons\n', '*       - 50x  Multiplier\n', '*   0.0001% Three Moon Grand Jackpot\n', '*       - Jackpot Amount (variable)\n', '*\n', '*   From all of us at Zethr, thank you for playing!    \n', '*\n', '*/\n', '\n', '// Zethr Token Bankroll interface\n', 'contract ZethrTokenBankroll{\n', '  // Game request token transfer to player \n', '  function gameRequestTokens(address target, uint tokens) public;\n', '  function gameTokenAmount(address what) public returns (uint);\n', '}\n', '\n', '// Zether Main Bankroll interface\n', 'contract ZethrMainBankroll{\n', '  function gameGetTokenBankrollList() public view returns (address[7]);\n', '}\n', '\n', '// Zethr main contract interface\n', 'contract ZethrInterface{\n', '  function withdraw() public;\n', '}\n', '\n', '// Library for figuring out the "tier" (1-7) of a dividend rate\n', 'library ZethrTierLibrary{\n', '\n', '  function getTier(uint divRate) \n', '    internal \n', '    pure \n', '    returns (uint)\n', '  {\n', '    // Tier logic \n', '    // Returns the index of the UsedBankrollAddresses which should be used to call into to withdraw tokens \n', '        \n', '    // We can divide by magnitude\n', '    // Remainder is removed so we only get the actual number we want\n', '    uint actualDiv = divRate; \n', '    if (actualDiv >= 30){\n', '      return 6;\n', '    } else if (actualDiv >= 25){\n', '      return 5;\n', '    } else if (actualDiv >= 20){\n', '      return 4;\n', '    } else if (actualDiv >= 15){\n', '      return 3;\n', '    } else if (actualDiv >= 10){\n', '      return 2; \n', '    } else if (actualDiv >= 5){\n', '      return 1;\n', '    } else if (actualDiv >= 2){\n', '      return 0;\n', '    } else{\n', '      // Impossible\n', '      revert(); \n', '    }\n', '  }\n', '}\n', '\n', '// Contract that contains the functions to interact with the ZlotsJackpotHoldingContract\n', 'contract ZlotsJackpotHoldingContract {\n', '  function payOutWinner(address winner) public; \n', '  function getJackpot() public view returns (uint);\n', '}\n', ' \n', '// Contract that contains the functions to interact with the bankroll system\n', 'contract ZethrBankrollBridge {\n', '  // Must have an interface with the main Zethr token contract \n', '  ZethrInterface Zethr;\n', '   \n', '  // Store the bankroll addresses \n', '  // address[0] is tier1: 2-5% \n', '  // address[1] is tier2: 5-10, etc\n', '  address[7] UsedBankrollAddresses; \n', '\n', '  // Mapping for easy checking\n', '  mapping(address => bool) ValidBankrollAddress;\n', '    \n', '  // Set up the tokenbankroll stuff \n', '  function setupBankrollInterface(address ZethrMainBankrollAddress) \n', '    internal \n', '  {\n', '    // Instantiate Zethr\n', '    Zethr = ZethrInterface(0xD48B633045af65fF636F3c6edd744748351E020D);\n', '\n', '    // Get the bankroll addresses from the main bankroll\n', '    UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\n', '    for(uint i=0; i<7; i++){\n', '      ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\n', '    }\n', '  }\n', '    \n', '  // Require a function to be called from a *token* bankroll \n', '  modifier fromBankroll() {\n', '    require(ValidBankrollAddress[msg.sender], "msg.sender should be a valid bankroll");\n', '    _;\n', '  }\n', '    \n', '  // Request a payment in tokens to a user FROM the appropriate tokenBankroll \n', '  // Figure out the right bankroll via divRate \n', '  function RequestBankrollPayment(address to, uint tokens, uint tier) \n', '    internal \n', '  {\n', '    address tokenBankrollAddress = UsedBankrollAddresses[tier];\n', '    ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\n', '  }\n', '    \n', '  function getZethrTokenBankroll(uint divRate) \n', '    public \n', '    constant \n', '    returns (ZethrTokenBankroll)\n', '  {\n', '    return ZethrTokenBankroll(UsedBankrollAddresses[ZethrTierLibrary.getTier(divRate)]);\n', '  }\n', '}\n', '\n', '// Contract that contains functions to move divs to the main bankroll\n', 'contract ZethrShell is ZethrBankrollBridge {\n', '\n', '  // Dump ETH balance to main bankroll\n', '  function WithdrawToBankroll() \n', '    public \n', '  {\n', '    address(UsedBankrollAddresses[0]).transfer(address(this).balance);\n', '  }\n', '\n', '  // Dump divs and dump ETH into bankroll\n', '  function WithdrawAndTransferToBankroll() \n', '    public \n', '  {\n', '    Zethr.withdraw();\n', '    WithdrawToBankroll();\n', '  }\n', '}\n', '\n', '// Zethr game data setup\n', '// Includes all necessary to run with Zethr\n', 'contract ZlotsMulti is ZethrShell {\n', '  using SafeMath for uint;\n', '\n', '  // ---------------------- Events\n', '\n', '  // Might as well notify everyone when the house takes its cut out.\n', '  event HouseRetrievedTake(\n', '    uint timeTaken,\n', '    uint tokensWithdrawn\n', '  );\n', '\n', '  // Fire an event whenever someone places a bet.\n', '  event TokensWagered(\n', '    address _wagerer,\n', '    uint _wagered\n', '  );\n', '\n', '  event LogResult(\n', '    address _wagerer,\n', '    uint _result,\n', '    uint _profit,\n', '    uint _wagered,\n', '    uint _category,\n', '    bool _win\n', '  );\n', '\n', '  // Result announcement events (to dictate UI output!)\n', '  event Loss(address _wagerer, uint _block);                  // Category 0\n', '  event ThreeMoonJackpot(address _wagerer, uint _block);      // Category 1\n', '  event TwoMoonPrize(address _wagerer, uint _block);          // Category 2\n', '  event ZTHPrize(address _wagerer, uint _block);              // Category 3\n', '  event ThreeZSymbols(address _wagerer, uint _block);         // Category 4\n', '  event ThreeTSymbols(address _wagerer, uint _block);         // Category 5\n', '  event ThreeHSymbols(address _wagerer, uint _block);         // Category 6\n', '  event ThreeEtherIcons(address _wagerer, uint _block);       // Category 7\n', '  event ThreePurplePyramids(address _wagerer, uint _block);   // Category 8\n', '  event ThreeGoldPyramids(address _wagerer, uint _block);     // Category 9\n', '  event ThreeRockets(address _wagerer, uint _block);          // Category 10\n', '  event OneMoonPrize(address _wagerer, uint _block);          // Category 11\n', '  event OneOfEachPyramidPrize(address _wagerer, uint _block); // Category 12\n', '  event TwoZSymbols(address _wagerer, uint _block);           // Category 13\n', '  event TwoTSymbols(address _wagerer, uint _block);           // Category 14\n', '  event TwoHSymbols(address _wagerer, uint _block);           // Category 15\n', '  event TwoEtherIcons(address _wagerer, uint _block);         // Category 16\n', '  event TwoPurplePyramids(address _wagerer, uint _block);     // Category 17\n', '  event TwoGoldPyramids(address _wagerer, uint _block);       // Category 18\n', '  event TwoRockets(address _wagerer, uint _block);            // Category 19    \n', '  event SpinConcluded(address _wagerer, uint _block);         // Debug event\n', '\n', '  // ---------------------- Modifiers\n', '\n', "  // Makes sure that player porfit can't exceed a maximum amount\n", '  // We use the max win here - 50x\n', '  modifier betIsValid(uint _betSize, uint divRate, uint8 spins) {\n', '    require(_betSize.div(spins).mul(50) <= getMaxProfit(divRate));\n', '    require(_betSize.div(spins) >= minBet);\n', '    _;\n', '  }\n', '\n', '  // Requires the game to be currently active\n', '  modifier gameIsActive {\n', '    require(gamePaused == false);\n', '    _;\n', '  }\n', '\n', '  // Require msg.sender to be owner\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner); \n', '    _;\n', '  }\n', '\n', '  // Requires msg.sender to be bankroll\n', '  modifier onlyBankroll {\n', '    require(msg.sender == bankroll);\n', '    _;\n', '  }\n', '\n', '  // Requires msg.sender to be owner or bankroll\n', '  modifier onlyOwnerOrBankroll {\n', '    require(msg.sender == owner || msg.sender == bankroll);\n', '    _;\n', '  }\n', '\n', '  // ---------------------- Variables\n', '\n', '  // Configurables\n', '  uint constant public maxProfitDivisor = 1000000;\n', '  uint constant public houseEdgeDivisor = 1000;\n', '  mapping (uint => uint) public maxProfit;\n', '  uint public maxProfitAsPercentOfHouse;\n', '  uint public minBet = 1e18;\n', '  address public zlotsJackpot;\n', '  address private owner;\n', '  address private bankroll;\n', '  bool gamePaused;\n', '\n', '  // Trackers\n', '  uint  public totalSpins;\n', '  uint  public totalZTHWagered;\n', '  mapping (uint => uint) public contractBalance;\n', '    \n', '  // Is betting allowed? (Administrative function, in the event of unforeseen bugs)\n', '  bool public gameActive;\n', '\n', '  // Bankroll & token addresses\n', '  address private ZTHTKNADDR;\n', '  address private ZTHBANKROLL;\n', '\n', '  // ---------------------- Functions \n', '\n', '  // Constructor; must supply bankroll address\n', '  constructor(address BankrollAddress) \n', '    public \n', '  {\n', '    // Set up the bankroll interface\n', '    setupBankrollInterface(BankrollAddress); \n', '\n', '    // Owner is deployer\n', '    owner = msg.sender;\n', '\n', '    // Default max profit to 5% of contract balance\n', '    ownerSetMaxProfitAsPercentOfHouse(50000);\n', '\n', '    // Set starting variables\n', '    bankroll      = ZTHBANKROLL;\n', '    gameActive  = true;\n', '\n', '    // Init min bet (1 ZTH)\n', '    ownerSetMinBet(1e18);\n', '  }\n', '\n', '  // Zethr dividends gained are accumulated and sent to bankroll manually\n', '  function() public payable {  }\n', '\n', '  // If the contract receives tokens, bundle them up in a struct and fire them over to _spinTokens for validation.\n', '  struct TKN { address sender; uint value; }\n', '  function execute(address _from, uint _value, uint divRate, bytes _data) \n', '    public \n', '    fromBankroll \n', '    returns (bool)\n', '  {\n', '      TKN memory _tkn;\n', '      _tkn.sender = _from;\n', '      _tkn.value = _value;\n', '      _spinTokens(_tkn, divRate, uint8(_data[0]));\n', '      return true;\n', '  }\n', '\n', '  struct playerSpin {\n', '    uint192 tokenValue; // Token value in uint\n', '    uint48 blockn;      // Block number 48 bits\n', '    uint8 tier;\n', '    uint8 spins;\n', '    uint divRate;\n', '  }\n', '\n', '  // Mapping because a player can do one spin at a time\n', '  mapping(address => playerSpin) public playerSpins;\n', '\n', '  // Execute spin.\n', '  function _spinTokens(TKN _tkn, uint divRate, uint8 spins) \n', '    private \n', '    betIsValid(_tkn.value, divRate, spins)\n', '  {\n', '    require(gameActive);\n', '    require(block.number <= ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint56\n', '    require(_tkn.value <= ((2 ** 192) - 1));\n', '    address _customerAddress = _tkn.sender;\n', '    uint    _wagered         = _tkn.value;\n', '\n', '    playerSpin memory spin = playerSpins[_tkn.sender];\n', ' \n', '    // We update the contract balance *before* the spin is over, not after\n', "    // This means that we don't have to worry about unresolved rolls never resolving\n", '    // (we also update it when a player wins)\n', '    addContractBalance(divRate, _wagered);\n', '\n', '    // Cannot spin twice in one block\n', '    require(block.number != spin.blockn);\n', '\n', '    // If there exists a spin, finish it\n', '    if (spin.blockn != 0) {\n', '      _finishSpin(_tkn.sender);\n', '    }\n', '\n', '    // Set struct block number and token value\n', '    spin.blockn = uint48(block.number);\n', '    spin.tokenValue = uint192(_wagered.div(spins));\n', '    spin.tier = uint8(ZethrTierLibrary.getTier(divRate));\n', '    spin.divRate = divRate;\n', '    spin.spins = spins;\n', '\n', '    // Store the roll struct - 40k gas.\n', '    playerSpins[_tkn.sender] = spin;\n', '\n', '    // Increment total number of spins\n', '    totalSpins += spins;\n', '\n', '    // Total wagered\n', '    totalZTHWagered += _wagered;\n', '\n', '    emit TokensWagered(_customerAddress, _wagered);\n', '  }\n', '\n', '  // Finish the current spin of a player, if they have one\n', '  function finishSpin() \n', '    public\n', '    gameIsActive\n', '    returns (uint[])\n', '  {\n', '    return _finishSpin(msg.sender);\n', '  }\n', '\n', '  // Stores the data for the roll (spin)\n', '  struct rollData {\n', '    uint win;\n', '    uint loss; \n', '    uint jp;\n', '  }\n', '\n', '  // Pay winners, update contract balance, send rewards where applicable.\n', '  function _finishSpin(address target)\n', '    private \n', '    returns (uint[])\n', '  {\n', '    playerSpin memory spin = playerSpins[target];\n', '\n', '    require(spin.tokenValue > 0); // No re-entrancy\n', '    require(spin.blockn != block.number);\n', '        \n', '    uint[] memory output = new uint[](spin.spins);\n', '    rollData memory outcomeTrack = rollData(0,0,0);\n', '    uint category = 0;\n', '    uint profit;\n', '    uint playerDivrate = spin.divRate;\n', '        \n', '    for(uint i=0; i<spin.spins; i++) {\n', '        \n', "      // If the block is more than 255 blocks old, we can't get the result\n", '      // Also, if the result has already happened, fail as well\n', '      uint result;\n', '      if (block.number - spin.blockn > 255) {\n', "        result = 1000000; // Can't win: default to largest number\n", '        output[i] = 1000000;\n', '      } else {\n', '        // Generate a result - random based ONLY on a past block (future when submitted).\n', '        // Case statement barrier numbers defined by the current payment schema at the top of the contract.\n', '        result = random(1000000, spin.blockn, target, i) + 1;\n', '        output[i] = result;\n', '      }\n', '\n', '      if (result > 506856) {\n', '        // Player has lost. Womp womp.\n', '\n', '        // Add one percent of player loss to the jackpot\n', '        // (do this by requesting a payout to the jackpot)\n', '        outcomeTrack.loss += spin.tokenValue/100;\n', '\n', '        emit Loss(target, spin.blockn);\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, false);\n', '      } else if (result < 2) {\n', '        // Player has won the three-moon mega jackpot!\n', '      \n', '        // Get profit amount via jackpot\n', '        profit = ZlotsJackpotHoldingContract(zlotsJackpot).getJackpot();\n', '        category = 1;\n', '    \n', '        // Emit events\n', '        emit ThreeMoonJackpot(target, spin.blockn);\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '\n', '        outcomeTrack.jp += 1;\n', '\n', '      } else {\n', '        if (result < 299) {\n', '          // Player has won a two-moon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 50);\n', '          category = 2;\n', '          emit TwoMoonPrize(target, spin.blockn);\n', '        } else if (result < 3128) {\n', '          // Player has won the Z T H prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 20);\n', '          category = 3;\n', '          emit ZTHPrize(target, spin.blockn);\n', '        } else if (result < 16961) {\n', '          // Player has won a three Z symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 4;\n', '          emit ThreeZSymbols(target, spin.blockn);\n', '        } else if (result < 30794) {\n', '          // Player has won a three T symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 5;\n', '          emit ThreeTSymbols(target, spin.blockn);\n', '        } else if (result < 44627) {\n', '          // Player has won a three H symbol prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 30), 10);\n', '          category = 6;\n', '          emit ThreeHSymbols(target, spin.blockn);\n', '        } else if (result < 46627) {\n', '          // Player has won a three Ether icon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 11);\n', '          category = 7;\n', '          emit ThreeEtherIcons(target, spin.blockn);\n', '        } else if (result < 49127) {\n', '          // Player has won a three purple pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 75), 10);\n', '          category = 8;\n', '          emit ThreePurplePyramids(target, spin.blockn);\n', '        } else if (result < 51627) {\n', '          // Player has won a three gold pyramid prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 9);\n', '          category = 9;\n', '          emit ThreeGoldPyramids(target, spin.blockn);\n', '        } else if (result < 53127) {\n', '          // Player has won a three rocket prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 13);\n', '          category = 10;\n', '          emit ThreeRockets(target, spin.blockn);\n', '        } else if (result < 82530) {\n', '          // Player has won a one moon prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25),10);\n', '          category = 11;\n', '          emit OneMoonPrize(target, spin.blockn);\n', '        } else if (result < 150423) {\n', '          // Player has won a each-coloured-pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n', '          category = 12;\n', '          emit OneOfEachPyramidPrize(target, spin.blockn);\n', '        } else if (result < 203888) {\n', '          // Player has won a two Z symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 13;\n', '          emit TwoZSymbols(target, spin.blockn);\n', '        } else if (result < 257353) {\n', '          // Player has won a two T symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 14;\n', '          emit TwoTSymbols(target, spin.blockn);\n', '        } else if (result < 310818) {\n', '          // Player has won a two H symbol prize!\n', '          profit = spin.tokenValue;\n', '          category = 15;\n', '          emit TwoHSymbols(target, spin.blockn);\n', '        } else if (result < 364283) {\n', '          // Player has won a two Ether icon prize!\n', '          profit = SafeMath.mul(spin.tokenValue, 2);\n', '          category = 16;\n', '          emit TwoEtherIcons(target, spin.blockn);\n', '        } else if (result < 417748) {\n', '          // Player has won a two purple pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125), 100);\n', '          category = 17;\n', '          emit TwoPurplePyramids(target, spin.blockn);\n', '        } else if (result < 471213) {\n', '          // Player has won a two gold pyramid prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 133), 100);\n', '          category = 18;\n', '          emit TwoGoldPyramids(target, spin.blockn);\n', '        } else {\n', '          // Player has won a two rocket prize!\n', '          profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\n', '          category = 19;\n', '          emit TwoRockets(target, spin.blockn);\n', '        }\n', '\n', '        uint newMaxProfit = getNewMaxProfit(playerDivrate, outcomeTrack.win);\n', '        if (profit > newMaxProfit){\n', '          profit = newMaxProfit;\n', '        }\n', '\n', '        emit LogResult(target, result, profit, spin.tokenValue, category, true);\n', '        outcomeTrack.win += profit;\n', '      }\n', '    }\n', '\n', '    playerSpins[target] = playerSpin(uint192(0), uint48(0), uint8(0), uint8(0),  uint(0));\n', '    if (outcomeTrack.jp > 0) {\n', '      for (i = 0; i < outcomeTrack.jp; i++) {\n', '        // In the weird case a player wins two jackpots, we of course pay them twice \n', '        ZlotsJackpotHoldingContract(zlotsJackpot).payOutWinner(target);\n', '      }\n', '    }\n', '\n', '    if (outcomeTrack.win > 0) {\n', '      RequestBankrollPayment(target, outcomeTrack.win, spin.tier);\n', '    }\n', '\n', '    if (outcomeTrack.loss > 0) {\n', '      // This loss is the loss to pay to the jackpot account \n', '      // The delta in contractBalance is already updated in a pending bet.\n', '      RequestBankrollPayment(zlotsJackpot, outcomeTrack.loss, spin.tier);\n', '    }\n', '            \n', '    emit SpinConcluded(target, spin.blockn);\n', '    return output;\n', '  }   \n', '\n', '  // Returns a random number using a specified block number\n', '  // Always use a FUTURE block number.\n', '  function maxRandom(uint blockn, address entropy, uint index) \n', '    private \n', '    view\n', '    returns (uint256 randomNumber) \n', '  {\n', '    return uint256(keccak256(\n', '        abi.encodePacked(\n', '          blockhash(blockn),\n', '          entropy,\n', '          index\n', '    )));\n', '  }\n', '\n', '  // Random helper\n', '  function random(uint256 upper, uint256 blockn, address entropy, uint index)\n', '    internal \n', '    view \n', '    returns (uint256 randomNumber)\n', '  {\n', '    return maxRandom(blockn, entropy, index) % upper;\n', '  }\n', '\n', '  // Sets max profit (internal)\n', '  function setMaxProfit(uint divRate) \n', '    internal \n', '  {\n', '    maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor; \n', '  } \n', '\n', '  // Gets max profit  \n', '  function getMaxProfit(uint divRate) \n', '    public \n', '    view \n', '    returns (uint) \n', '  {\n', '    return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '  }\n', '\n', '  function getNewMaxProfit(uint divRate, uint currentWin) \n', '    public \n', '    view \n', '    returns (uint) \n', '  {\n', '    return ((contractBalance[divRate] - currentWin) * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n', '  }\n', '\n', '  // Subtracts from the contract balance tracking var\n', '  function subContractBalance(uint divRate, uint sub) \n', '    internal \n', '  {\n', '    contractBalance[divRate] = contractBalance[divRate].sub(sub);\n', '  }\n', '\n', '  // Adds to the contract balance tracking var\n', '  function addContractBalance(uint divRate, uint add) \n', '    internal \n', '  {\n', '    contractBalance[divRate] = contractBalance[divRate].add(add);\n', '  }\n', '\n', '  // An EXTERNAL update of tokens should be handled here\n', '  // This is due to token allocation\n', '  // The game should handle internal updates itself (e.g. tokens are betted)\n', '  function bankrollExternalUpdateTokens(uint divRate, uint newBalance) \n', '    public \n', '    fromBankroll \n', '  {\n', '    contractBalance[divRate] = newBalance;\n', '    setMaxProfit(divRate);\n', '  }\n', '\n', '  // Set the new max profit as percent of house - can be as high as 20%\n', '  // (1,000,000 = 100%)\n', '  function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) \n', '    public\n', '    onlyOwner\n', '  {\n', '    // Restricts each bet to a maximum profit of 50% contractBalance\n', '    require(newMaxProfitAsPercent <= 500000);\n', '    maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n', '    setMaxProfit(2);\n', '    setMaxProfit(5);\n', '    setMaxProfit(10);\n', '    setMaxProfit(15); \n', '    setMaxProfit(20);\n', '    setMaxProfit(25);\n', '    setMaxProfit(33);\n', '  }\n', '\n', '  // Only owner can set minBet   \n', '  function ownerSetMinBet(uint newMinimumBet) \n', '    public\n', '    onlyOwner\n', '  {\n', '    minBet = newMinimumBet;\n', '  }\n', '\n', '  // Only owner can set zlotsJackpot address\n', '  function ownerSetZlotsAddress(address zlotsAddress) \n', '    public\n', '    onlyOwner\n', '  {\n', '    zlotsJackpot = zlotsAddress;\n', '  }\n', '\n', '  // If, for any reason, betting needs to be paused (very unlikely), this will freeze all bets.\n', '  function pauseGame() \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    gameActive = false;\n', '  }\n', '\n', '  // The converse of the above, resuming betting if a freeze had been put in place.\n', '  function resumeGame() \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    gameActive = true;\n', '  }\n', '\n', '  // Administrative function to change the owner of the contract.\n', '  function changeOwner(address _newOwner) \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    owner = _newOwner;\n', '  }\n', '\n', '  // Administrative function to change the Zethr bankroll contract, should the need arise.\n', '  function changeBankroll(address _newBankroll) \n', '    public \n', '    onlyOwnerOrBankroll \n', '  {\n', '    bankroll = _newBankroll;\n', '  }\n', '\n', '  // Is the address that the token has come from actually ZTH?\n', '  function _zthToken(address _tokenContract) \n', '    private \n', '    view \n', '    returns (bool) \n', '  {\n', '    return _tokenContract == ZTHTKNADDR;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    uint c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint a, uint b) \n', '    internal \n', '    pure \n', '    returns (uint) \n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint a, uint b) \n', '    internal \n', '    pure returns (uint) \n', '  {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}']
