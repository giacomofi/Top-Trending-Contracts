['// The version of the compiler.\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ETH_Silver\n', ' * @dev The main contract of the project.\n', ' */\n', 'contract ETH_Silver_White {\n', '\n', '    // Using SafeMath for safe calculations.\n', '    using SafeMath for uint;\n', '\n', '    // A variable for address of the owner.\n', '    address owner;\n', '\n', '    // A variable to store deposits of investors.\n', '    mapping (address => uint) deposit;\n', '    // A variable to store amount of withdrawn money of investors.\n', '    mapping (address => uint) withdrawn;\n', '    // A variable to store reference point to count available money to withdraw.\n', '    mapping (address => uint) lastTimeWithdraw;\n', '\n', '    // A function to transfer ownership of the contract (available only for the owner).\n', '    function transferOwnership(address _newOwner) external {\n', '        require(msg.sender == owner);\n', '        require(_newOwner != address(0));\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // A function to get key info for investors.\n', '    function getInfo() public view returns(uint Deposit, uint Withdrawn, uint AmountToWithdraw) {\n', '        // 1) Amount of invested money;\n', '        Deposit = deposit[msg.sender];\n', '        // 2) Amount of withdrawn money;\n', '        Withdrawn = withdrawn[msg.sender];\n', '        // 3) Amount of money which is available to withdraw;\n', '        // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\n', '        AmountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\n', '    }\n', '\n', '    // A constructor function for the contract. Being used once at the time as contract is deployed and simply set the owner of the contract.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // A "fallback" function. It is automatically being called when anybody sends money to the contract. Function simply calls the "invest" function.\n', '    function() external payable {\n', '        invest();\n', '    }\n', '\n', '    // A function which accepts money of investors.\n', '    function invest() public payable {\n', '        // Requires amount of money to be more than 0.01 ETH. If it is less, automatically reverts the whole function.\n', '        require(msg.value > 10000000000000000);\n', '        // Transfers a fee to the owner of the contract. The fee is 20% of the deposit (or Deposit / 5)\n', '        owner.transfer(msg.value.div(4));\n', '        // The special algorithm for investors who increase their deposits:\n', '        if (deposit[msg.sender] > 0) {\n', '            // Amount of money which is available to withdraw;\n', '            // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\n', '            uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\n', '            // The additional algorithm for investors who need to withdraw available dividends:\n', '            if (amountToWithdraw != 0) {\n', '                // Increasing amount withdrawn by an investor.\n', '                withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\n', '                // Transferring available dividends to an investor.\n', '                msg.sender.transfer(amountToWithdraw);\n', '            }\n', '            // Setting the reference point to the current time.\n', '            lastTimeWithdraw[msg.sender] = block.timestamp;\n', '            // Increasing of the deposit of an investor.\n', '            deposit[msg.sender] = deposit[msg.sender].add(msg.value);\n', '            // End of the function for investors who increases their deposits.\n', '            return;\n', '        }\n', '        // The algorithm for new investors:\n', '        // Setting the reference point to the current time.\n', '        lastTimeWithdraw[msg.sender] = block.timestamp;\n', '        // Storing the amount of the deposit for new investors.\n', '        deposit[msg.sender] = (msg.value);\n', '    }\n', '\n', '    // A function to get available dividends of an investor.\n', '    function withdraw() public {\n', '        // Amount of money which is available to withdraw.\n', '        // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 day)) * (Deposit * 3% / 100%) / 1 day\n', '        uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(3).div(100)).div(1 days);\n', '        // Reverting the whole function for investors who got nothing to withdraw yet.\n', '        if (amountToWithdraw == 0) {\n', '            revert();\n', '        }\n', '        // Increasing amount withdrawn by the investor.\n', '        withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\n', '        // Updating the reference point.\n', '        // Formula without SafeMath: Current Time - ((Current Time - Previous Reference Point) % 1 day)\n', '        lastTimeWithdraw[msg.sender] = block.timestamp.sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days));\n', '        // Transferring the available dividends to an investor.\n', '        msg.sender.transfer(amountToWithdraw);\n', '    }\n', '}']