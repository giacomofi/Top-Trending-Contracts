['pragma solidity ^0.4.21;\n', 'contract owned {\n', '    address public owner;\n', '    event Log(string s);\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '    function isOwner()public{\n', '        if(msg.sender==owner)emit Log("Owner");\n', '        else{\n', '            emit Log("Not Owner");\n', '        }\n', '    }\n', '}\n', 'contract SisterToken is owned{\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 4;\n', '    uint256 public totalSupply;\n', '    uint256 public buyPrice;\n', '    \n', '    uint256 private activeUsers;\n', '    \n', '    address[9] phonebook = [0x2c0cAC04A9Ffee0D496e45023c907b71049Ed0F0,\n', '                            0xcccC551e9701c2A5D07a3062a604972fa12226E8,\n', '                            0x97d1352b2A2E0175471Ca730Cb6510D0164bFb0B,\n', '                            0x80f395fd4E1dDE020d774faB983b8A9d0DCCA516,\n', '                            0xCeb646336bBA29A9E8106A44065561D495166230,\n', '                            0xDce66F4a697A88d00fBB3fDDC6D44FD757852394,\n', '                            0x8CCc39c1516EF25AC0E6bC1A6bb7cf159d28FD71,\n', '                            0xaF9cD61b3B5C4C07376141Ef8F718BB0893ab371,\n', '                            0x5A53D72E763b2D3e2f2f347ed774AAaE872861a4];\n', '    address bounty = 0xAB90CB176709558bA5D2DDA8aeb1F65e24f2409f;\n', '    address bank = owner;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public accountID;\n', '    mapping (uint256 => address) public accountFromID;\n', '    mapping (address => bool) public isRegistered;\n', '    mapping (address => bool) public isTrusted;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event TransferNeo(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Log(string t);\n', '    event Log32(bytes32);\n', '    event LogA(address);\n', '    event Multiplier(uint m);\n', '    event isSender(address user,bool confirm);\n', '    event isTrusted(address user,bool confirm);\n', '    event Value(uint v);\n', '\n', '    modifier registered {\n', '        require(isRegistered[msg.sender]);\n', '        _;\n', '    }\n', '    modifier trusted {\n', '        require(isTrusted[msg.sender]);\n', '        _;\n', '    }\n', '    modifier isAfterRelease{\n', '        require(block.timestamp>1525550400);\n', '        _;\n', '    }\n', '    function SisterToken(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public payable{\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '        balanceOf[owner] = 85*totalSupply/100;\n', '        balanceOf[bounty] = 5*totalSupply/100;\n', '        uint i;\n', '        for(i=0;i<9;i++){\n', '            balanceOf[phonebook[i]] = totalSupply/90;\n', '            registerAccount(phonebook[i]);\n', '        }\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '    }\n', '//----------------------------------------------------------------------ACCESSOR FUNCTIONS------------------------------------------------------------------------------//\n', '    function getbuyPrice()public view returns(uint256){\n', '        return(buyPrice);\n', '    }\n', '    function getMultiplier()public view returns(uint256){\n', '        uint256 multiplier;\n', '        if(block.timestamp>1525550400){\n', '            if(block.timestamp < 1525636800){\n', '                multiplier = 150;\n', '            }else if(block.timestamp < 1526155200){\n', '                multiplier = 140;\n', '            }else if(block.timestamp <1526760000){\n', '                multiplier = 125;\n', '            }else if(block.timestamp <1527364800){\n', '                multiplier = 115;\n', '            }else if(block.timestamp <1527969600){\n', '                multiplier = 105;\n', '            }\n', '        }else{\n', '            multiplier=100;\n', '        }\n', '        return(multiplier);\n', '    }\n', '//---------------------------------------------------------------------MUTATOR FUNCTIONS---------------------------------------------------------------------------//\n', '    function trustContract(address contract1)public onlyOwner{\n', '        isTrusted[contract1]=true;\n', '    }\n', '    function untrustContract(address contract1)public onlyOwner{\n', '        isTrusted[contract1]=false;\n', '    }\n', '    function setPrice(uint256 newBuyPrice) onlyOwner public {\n', '        buyPrice = newBuyPrice;\n', '    }\n', '    function changeBank(address newBank) onlyOwner public{\n', '        bank = newBank;\n', '    }\n', '//-------------------------------------------------------------------INTERNAL FUNCTIONS--------------------------------------------------------------------------//\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function registerAccount(address user)internal{\n', '        if(!isRegistered[user]){\n', '            isRegistered[user] = true;\n', '            activeUsers+=1;\n', '            accountID[user] = activeUsers;\n', '            accountFromID[activeUsers] = user;\n', '        }\n', '    }\n', '    function burnFrom(address _from, uint256 _value) internal returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        balanceOf[_from] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '    function trasnferFromOwner(address to,uint value)internal {\n', '        _transfer(owner,to,value);\n', '    }\n', '    function _buy(address user)external payable trusted isAfterRelease{\n', '        require(owner.balance > 0);\n', '        emit isTrusted(user,isTrusted[msg.sender]||msg.sender==user);\n', '        uint256 amount = (getMultiplier()*2*msg.value/buyPrice)/100;\n', '        emit Value(amount);\n', '        trasnferFromOwner(user,amount);\n', '        bank.transfer(msg.value);\n', '    }\n', '//------------------------------------------------------------------EXTERNAL FUNCTIONS-------------------------------------------------------------------------//\n', '    function registerExternal()external{\n', '        registerAccount(msg.sender);\n', '    }\n', '    function contractBurn(address _for,uint256 value)external trusted{\n', '        burnFrom(_for,value);\n', '    }\n', '//----------------------------------------------------------------PUBLIC USER FUNCTIONS-----------------------------------------------------------------------//\n', '    function transfer(address to, uint256 val)public payable{\n', '        _transfer(msg.sender,to,val);\n', '    }\n', '    function burn(uint256 val)public{\n', '        burnFrom(msg.sender,val);\n', '    }\n', '    function register() public {\n', '        registerAccount(msg.sender);\n', '    }\n', '    function testConnection() external {\n', '        emit Log(name);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', 'contract owned {\n', '    address public owner;\n', '    event Log(string s);\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        owner = newOwner;\n', '    }\n', '    function isOwner()public{\n', '        if(msg.sender==owner)emit Log("Owner");\n', '        else{\n', '            emit Log("Not Owner");\n', '        }\n', '    }\n', '}\n', 'contract SisterToken is owned{\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 4;\n', '    uint256 public totalSupply;\n', '    uint256 public buyPrice;\n', '    \n', '    uint256 private activeUsers;\n', '    \n', '    address[9] phonebook = [0x2c0cAC04A9Ffee0D496e45023c907b71049Ed0F0,\n', '                            0xcccC551e9701c2A5D07a3062a604972fa12226E8,\n', '                            0x97d1352b2A2E0175471Ca730Cb6510D0164bFb0B,\n', '                            0x80f395fd4E1dDE020d774faB983b8A9d0DCCA516,\n', '                            0xCeb646336bBA29A9E8106A44065561D495166230,\n', '                            0xDce66F4a697A88d00fBB3fDDC6D44FD757852394,\n', '                            0x8CCc39c1516EF25AC0E6bC1A6bb7cf159d28FD71,\n', '                            0xaF9cD61b3B5C4C07376141Ef8F718BB0893ab371,\n', '                            0x5A53D72E763b2D3e2f2f347ed774AAaE872861a4];\n', '    address bounty = 0xAB90CB176709558bA5D2DDA8aeb1F65e24f2409f;\n', '    address bank = owner;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint256) public accountID;\n', '    mapping (uint256 => address) public accountFromID;\n', '    mapping (address => bool) public isRegistered;\n', '    mapping (address => bool) public isTrusted;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event TransferNeo(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Log(string t);\n', '    event Log32(bytes32);\n', '    event LogA(address);\n', '    event Multiplier(uint m);\n', '    event isSender(address user,bool confirm);\n', '    event isTrusted(address user,bool confirm);\n', '    event Value(uint v);\n', '\n', '    modifier registered {\n', '        require(isRegistered[msg.sender]);\n', '        _;\n', '    }\n', '    modifier trusted {\n', '        require(isTrusted[msg.sender]);\n', '        _;\n', '    }\n', '    modifier isAfterRelease{\n', '        require(block.timestamp>1525550400);\n', '        _;\n', '    }\n', '    function SisterToken(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public payable{\n', '        totalSupply = initialSupply * 10 ** uint256(decimals);\n', '        balanceOf[owner] = 85*totalSupply/100;\n', '        balanceOf[bounty] = 5*totalSupply/100;\n', '        uint i;\n', '        for(i=0;i<9;i++){\n', '            balanceOf[phonebook[i]] = totalSupply/90;\n', '            registerAccount(phonebook[i]);\n', '        }\n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '    }\n', '//----------------------------------------------------------------------ACCESSOR FUNCTIONS------------------------------------------------------------------------------//\n', '    function getbuyPrice()public view returns(uint256){\n', '        return(buyPrice);\n', '    }\n', '    function getMultiplier()public view returns(uint256){\n', '        uint256 multiplier;\n', '        if(block.timestamp>1525550400){\n', '            if(block.timestamp < 1525636800){\n', '                multiplier = 150;\n', '            }else if(block.timestamp < 1526155200){\n', '                multiplier = 140;\n', '            }else if(block.timestamp <1526760000){\n', '                multiplier = 125;\n', '            }else if(block.timestamp <1527364800){\n', '                multiplier = 115;\n', '            }else if(block.timestamp <1527969600){\n', '                multiplier = 105;\n', '            }\n', '        }else{\n', '            multiplier=100;\n', '        }\n', '        return(multiplier);\n', '    }\n', '//---------------------------------------------------------------------MUTATOR FUNCTIONS---------------------------------------------------------------------------//\n', '    function trustContract(address contract1)public onlyOwner{\n', '        isTrusted[contract1]=true;\n', '    }\n', '    function untrustContract(address contract1)public onlyOwner{\n', '        isTrusted[contract1]=false;\n', '    }\n', '    function setPrice(uint256 newBuyPrice) onlyOwner public {\n', '        buyPrice = newBuyPrice;\n', '    }\n', '    function changeBank(address newBank) onlyOwner public{\n', '        bank = newBank;\n', '    }\n', '//-------------------------------------------------------------------INTERNAL FUNCTIONS--------------------------------------------------------------------------//\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != 0x0);\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        emit Transfer(_from, _to, _value);\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', '    function registerAccount(address user)internal{\n', '        if(!isRegistered[user]){\n', '            isRegistered[user] = true;\n', '            activeUsers+=1;\n', '            accountID[user] = activeUsers;\n', '            accountFromID[activeUsers] = user;\n', '        }\n', '    }\n', '    function burnFrom(address _from, uint256 _value) internal returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        balanceOf[_from] -= _value;\n', '        totalSupply -= _value;\n', '        emit Burn(_from, _value);\n', '        return true;\n', '    }\n', '    function trasnferFromOwner(address to,uint value)internal {\n', '        _transfer(owner,to,value);\n', '    }\n', '    function _buy(address user)external payable trusted isAfterRelease{\n', '        require(owner.balance > 0);\n', '        emit isTrusted(user,isTrusted[msg.sender]||msg.sender==user);\n', '        uint256 amount = (getMultiplier()*2*msg.value/buyPrice)/100;\n', '        emit Value(amount);\n', '        trasnferFromOwner(user,amount);\n', '        bank.transfer(msg.value);\n', '    }\n', '//------------------------------------------------------------------EXTERNAL FUNCTIONS-------------------------------------------------------------------------//\n', '    function registerExternal()external{\n', '        registerAccount(msg.sender);\n', '    }\n', '    function contractBurn(address _for,uint256 value)external trusted{\n', '        burnFrom(_for,value);\n', '    }\n', '//----------------------------------------------------------------PUBLIC USER FUNCTIONS-----------------------------------------------------------------------//\n', '    function transfer(address to, uint256 val)public payable{\n', '        _transfer(msg.sender,to,val);\n', '    }\n', '    function burn(uint256 val)public{\n', '        burnFrom(msg.sender,val);\n', '    }\n', '    function register() public {\n', '        registerAccount(msg.sender);\n', '    }\n', '    function testConnection() external {\n', '        emit Log(name);\n', '    }\n', '}']
