['//This file contains an eRAY token contract along with some other accompanying contracts\n', '//Generally speaking, the difference between plain ERC20 token is in way of generating token via prescribed TGR (Token Generation Rounds)\n', '//and possibility to burn token to receive contributed Ether back\n', '\n', '// Authors: Alexander Shevtsov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2456454a404b49484b434d4a1312644349454d480a474b49">[email&#160;protected]</a>>\n', '//          Vladimir Bobrov <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e99fa98d8c8a8c879d9c9b908e9b869c99c78a8684">[email&#160;protected]</a>>\n', '//          vladiuz1 <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfb9bc8faebdbdaeb6e1a6a0">[email&#160;protected]</a>>\n', '// License: see the repository file\n', '// Last updated: 16 August 2018\n', 'pragma solidity ^0.4.22;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Base {\n', '\n', '    uint private bitlocks = 0;\n', '\n', '    modifier noAnyReentrancy {\n', '        uint _locks = bitlocks;\n', '        require(_locks <= 0);\n', '        bitlocks = uint(-1);\n', '        _;\n', '        bitlocks = _locks;\n', '    }\n', '\n', '    modifier only(address allowed) {\n', '        require(msg.sender == allowed);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length == size + 4);\n', '        _;\n', '    } \n', '\n', '}\n', '\n', '\n', 'contract ERC20 is Base {\n', '    \n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    using SafeMath for uint;\n', '    uint public totalSupply;\n', '    bool public isFrozen = false; //it&#39;s not part of ERC20 specification, however it has to be here to place modifiers on usual ERC20 functions\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    modifier isNotFrozenOnly() {\n', '        require(!isFrozen);\n', '        _;\n', '    }\n', '\n', '    modifier isFrozenOnly(){\n', '        require(isFrozen);\n', '        _;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public isNotFrozenOnly onlyPayloadSize(3 * 32) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) public isNotFrozenOnly onlyPayloadSize(3 * 32) returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public isNotFrozenOnly onlyPayloadSize(2 * 32) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract Whitelist {\n', '\n', '    mapping(address => bool) public whitelist;\n', '    mapping(address => bool) operators;\n', '    address authority;\n', '\n', '    constructor(address _authority) {\n', '        authority = _authority;\n', '        operators[_authority] = true;\n', '    }\n', '    \n', '    function add(address _address) public {\n', '        require(operators[msg.sender]);\n', '        whitelist[_address] = true;\n', '    }\n', '\n', '    function remove(address _address) public {\n', '        require(operators[msg.sender]);\n', '        whitelist[_address] = false;\n', '    }\n', '\n', '    function addOperator(address _address) public {\n', '        require(authority == msg.sender);\n', '        operators[_address] = true;\n', '    }\n', '\n', '    function removeOperator(address _address) public {\n', '        require(authority == msg.sender);\n', '        operators[_address] = false;\n', '    }\n', '}\n', '\n', '\n', 'contract Token is ERC20 {\n', '\n', '    //some ERC20 definitions\n', '    string public constant name = "Array.io Token";\n', '    string public constant symbol = "eRAY";\n', '    uint8 public constant decimals = 18;\n', '\n', '    //these are settings, i.e. the values set by the initiator at the beginning of each token generation round\n', '    uint public tgrSettingsAmount; //how much is needed for current round goals. It doesn&#39;t depend on how much total funds is contributed, rather than on how much has the project received.\n', '    uint public tgrSettingsMinimalContribution; \n', '    uint public tgrSettingsPartContributor;\n', '    uint public tgrSettingsPartProject;\n', '    uint public tgrSettingsPartFounders;\n', '    uint public tgrSettingsBlocksPerStage;\n', '    uint public tgrSettingsPartContributorIncreasePerStage;\n', '    uint public tgrSettingsMaxStages;\n', '\n', '    //these are properties, i.e. some valuable variables which are changed automatically in the process of execution of this smart contract\n', '    uint public tgrStartBlock; //current token generation round initial block number\n', '    uint public tgrNumber; //how many rounds has been started. That means it equals the oridnal number of current active round starting from 1\n', '    uint public tgrAmountCollected; //total amount of funds received by PROJECT\n', '    uint public tgrContributedAmount; //total contributed amount for current round\n', '\n', '    address public projectWallet;\n', '    address public foundersWallet;\n', '    address constant public burnAddress = address(0);\n', '    mapping (address => uint) public invBalances;\n', '    uint public totalInvSupply;\n', '    Whitelist public whitelist;\n', '\n', '\n', '    modifier isTgrLive(){\n', '        require(tgrLive());\n', '        _;\n', '    }\n', '\n', '    modifier isNotTgrLive(){\n', '        require(!tgrLive());\n', '        _;\n', '    }\n', '\n', '    event Burn(address indexed _owner,  uint _value);\n', '    event TGRStarted(uint tgrSettingsAmount,\n', '                     uint tgrSettingsMinimalContribution,\n', '                     uint tgrSettingsPartContributor,\n', '                     uint tgrSettingsPartProject, \n', '                     uint tgrSettingsPartFounders, \n', '                     uint tgrSettingsBlocksPerStage, \n', '                     uint tgrSettingsPartContributorIncreasePerStage,\n', '                     uint tgrSettingsMaxStages,\n', '                     uint blockNumber,\n', '                     uint tgrNumber); \n', '\n', '    event TGRFinished(uint blockNumber, uint amountCollected);\n', '\n', '\n', '    /// @dev Constructor\n', '    /// @param _projectWallet Wallet of project\n', '    /// @param _foundersWallet Wallet of founders\n', '    constructor(address _projectWallet, address _foundersWallet) public {\n', '        projectWallet = _projectWallet;\n', '        foundersWallet = _foundersWallet;\n', '    }\n', '\n', '    /// @dev Fallback function allows to buy tokens\n', '    function () public payable isTgrLive isNotFrozenOnly noAnyReentrancy {\n', '        require(whitelist.whitelist(msg.sender)); //checking if sender is allowed to send Ether\n', '        require(tgrAmountCollected < tgrSettingsAmount); //checking if target amount is not achieved\n', '        require(msg.value >= tgrSettingsMinimalContribution); \n', '\n', '        uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n', '        require(stage < tgrSettingsMaxStages); //checking if max stage is not reached\n', '\n', '        //if the value sent is bigger than remaining amount to achieve the target, the difference is refunded\n', '        uint etherToRefund = 0;\n', '        uint etherContributed = msg.value;\n', '\n', '        uint currentPartContributor = tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage));\n', '\n', '        uint allStakes = currentPartContributor.add(tgrSettingsPartProject).add(tgrSettingsPartFounders);\n', '        uint remainsToContribute = (tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes).div(tgrSettingsPartProject);\n', '\n', '        if ((tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes) % tgrSettingsPartProject != 0) {\n', '            remainsToContribute = remainsToContribute + allStakes;\n', '        }\n', '\n', '        if (remainsToContribute < msg.value) {\n', '            etherToRefund = msg.value.sub(remainsToContribute);\n', '            etherContributed = remainsToContribute;\n', '        }\n', '\n', '        uint tokensProject = etherContributed.mul(tgrSettingsPartProject).div(allStakes);\n', '        uint tokensFounders = etherContributed.mul(tgrSettingsPartFounders).div(allStakes);\n', '        uint tokensContributor = etherContributed.sub(tokensProject).sub(tokensFounders);\n', '        \n', '        tgrAmountCollected = tgrAmountCollected.add(tokensProject);\n', '        tgrContributedAmount = tgrContributedAmount.add(etherContributed);\n', '        _mint(tokensProject, tokensFounders, tokensContributor);\n', '        msg.sender.transfer(etherToRefund);\n', '    }\n', '\n', '    /// @dev Start new tgr stage\n', '    function tgrSetLive() public only(projectWallet) isNotTgrLive isNotFrozenOnly {\n', '        tgrNumber +=1;\n', '        tgrStartBlock = block.number;\n', '        tgrAmountCollected = 0;\n', '        tgrContributedAmount = 0;\n', '        emit TGRStarted(tgrSettingsAmount,\n', '                     tgrSettingsMinimalContribution,\n', '                     tgrSettingsPartContributor,\n', '                     tgrSettingsPartProject, \n', '                     tgrSettingsPartFounders, \n', '                     tgrSettingsBlocksPerStage, \n', '                     tgrSettingsPartContributorIncreasePerStage,\n', '                     tgrSettingsMaxStages,\n', '                     block.number,\n', '                     tgrNumber); \n', '    }\n', '\n', '    function tgrSetFinished() public only(projectWallet) isTgrLive isNotFrozenOnly {\n', '        emit TGRFinished(block.number, tgrAmountCollected); \n', '        tgrStartBlock = 0;\n', '    }\n', '\n', '    /// @dev Burn tokens to burnAddress from msg.sender wallet\n', '    /// @param _amount Amount of tokens\n', '    function burn(uint _amount) public isNotFrozenOnly noAnyReentrancy returns(bool _success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[burnAddress] = balances[burnAddress].add(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        msg.sender.transfer(_amount);\n', '        emit Transfer(msg.sender, burnAddress, _amount);\n', '        emit Burn(burnAddress, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public isNotFrozenOnly onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(_to != address(this));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @dev _foundersWallet Wallet of founders\n', '    /// @param dests array of addresses \n', '    /// @param values array amount of tokens to transfer    \n', '    function multiTransfer(address[] dests, uint[] values) public isNotFrozenOnly returns(uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           transfer(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return i;\n', '    }\n', '    \n', '    /// @dev Allows to users withdraw eth in frozen stage \n', '    function withdrawFrozen() public isFrozenOnly noAnyReentrancy {\n', '        uint amountWithdraw = totalSupply.mul(invBalances[msg.sender]).div(totalInvSupply);\n', '        // fix possible rounding errors for last withdrawal:\n', '        if (amountWithdraw > address(this).balance) {\n', '            amountWithdraw = address(this).balance;\n', '        }\n', '        invBalances[msg.sender] = 0;\n', '        msg.sender.transfer(amountWithdraw);\n', '    }\n', '\n', '    function setWhitelist(address _address) public only(projectWallet) isNotFrozenOnly returns (bool) {\n', '        whitelist = Whitelist(_address);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a change settings request.\n', '    function executeSettingsChange(\n', '        uint amount, \n', '        uint minimalContribution,\n', '        uint partContributor,\n', '        uint partProject, \n', '        uint partFounders, \n', '        uint blocksPerStage, \n', '        uint partContributorIncreasePerStage,\n', '        uint maxStages\n', '    ) \n', '    public\n', '    only(projectWallet)\n', '    isNotTgrLive \n', '    isNotFrozenOnly\n', '    returns(bool success) \n', '    {\n', '        tgrSettingsAmount = amount;\n', '        tgrSettingsMinimalContribution = minimalContribution;\n', '        tgrSettingsPartContributor = partContributor;\n', '        tgrSettingsPartProject = partProject;\n', '        tgrSettingsPartFounders = partFounders;\n', '        tgrSettingsBlocksPerStage = blocksPerStage;\n', '        tgrSettingsPartContributorIncreasePerStage = partContributorIncreasePerStage;\n', '        tgrSettingsMaxStages = maxStages;\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm freezeng process\n', '    function setFreeze() public only(projectWallet) isNotFrozenOnly returns (bool) {\n', '        isFrozen = true;\n', '        return true;\n', '    }\n', '\n', '    function _mint(uint _tokensProject, uint _tokensFounders, uint _tokensContributor) internal {\n', '        balances[projectWallet] = balances[projectWallet].add(_tokensProject);\n', '        balances[foundersWallet] = balances[foundersWallet].add(_tokensFounders);\n', '        balances[msg.sender] = balances[msg.sender].add(_tokensContributor);\n', '\n', '        invBalances[msg.sender] = invBalances[msg.sender].add(_tokensContributor).add(_tokensFounders).add(_tokensProject);\n', '        totalInvSupply = totalInvSupply.add(_tokensContributor).add(_tokensFounders).add(_tokensProject);\n', '        totalSupply = totalSupply.add(_tokensProject).add(_tokensFounders).add(_tokensContributor);\n', '\n', '        emit Transfer(0x0, msg.sender, _tokensContributor);\n', '        emit Transfer(0x0, projectWallet, _tokensProject);\n', '        emit Transfer(0x0, foundersWallet, _tokensFounders);\n', '    }\n', '\n', '\n', '    //Status of tgr is initially defined by the start block of the tgr, if it&#39;s zero then tgr is not live\n', '    function tgrLive() view public returns(bool) {\n', '        if (tgrStartBlock == 0) {\n', '            return false;\n', '        }\n', '        uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n', '        if (stage < tgrSettingsMaxStages) {\n', '            if (tgrAmountCollected >= tgrSettingsAmount){\n', '                return false;\n', '            } else { \n', '                return true;\n', '            }\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //These functions are used to show information at the website.\n', '    //-1 shows that information is not accurate, for example numbers of blocks left is nonsense when the stage is not\n', '    //active. This way is easier handle than throwing errors.\n', '\n', '    /// @dev Amount of blocks left to the end of this stage of TGR \n', '    function tgrStageBlockLeft() public view returns(int) {\n', '        if (tgrLive()) {\n', '            uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n', '            return int(tgrStartBlock.add((stage+1).mul(tgrSettingsBlocksPerStage)).sub(block.number));\n', '        } else {\n', '            return -1;\n', '        }\n', '    }\n', '\n', '    function tgrCurrentPartContributor() public view returns(int) {\n', '        if (tgrLive()) {\n', '            uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n', '            return int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n', '        } else {\n', '            return -1;\n', '        }\n', '    }\n', '\n', '    function tgrNextPartContributor() public view returns(int) {\n', '        if (tgrLive()) {\n', '            uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1);        \n', '            return int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n', '        } else {\n', '            return -1;\n', '        }\n', '    }\n', '\n', '    //Keep in mind that internally stage count is started from 0 while user receives it incremented, i.e. starting from 1\n', '    function tgrCurrentStage() public view returns(int) {\n', '        if (tgrLive()) {\n', '            return int(block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1));        \n', '        } else {\n', '            return -1;\n', '        }\n', '    }\n', '\n', '}']