['pragma solidity ^0.4.25;\n', '\n', '\n', 'contract ArceonMoneyNetwork {\n', '    using SafeMath for uint256;\n', '    address public owner;\n', '    address parentUser;\n', '    address[] users;\n', '   \n', '    mapping(address => bool) usersExist;\n', '    mapping(address => address) users2users;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) balancesTotal;\n', '    \n', '    uint256 nextUserId = 0;\n', '    uint256 cyles = 5;\n', '    \n', '  constructor() public {owner = msg.sender; }\n', '  \n', '   modifier onlyOwner {if (msg.sender == owner) _;}\n', '    \n', '    \n', '    \n', '    \n', '    event Register(address indexed user, address indexed parentUser);\n', '    event BalanceUp(address indexed user, uint256 amount);\n', '    event ReferalBonus(address indexed user, uint256 amount);\n', '    event TransferMyMoney(address user, uint256 amount);\n', '    \n', '    \n', '    \n', '    function bytesToAddress(bytes bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '    \n', '    \n', '    function () payable public{\n', '\t    parentUser = bytesToAddress(msg.data);\n', '\t    if (msg.value==0){ transferMyMoney(); return;}\n', '        require(msg.value == 50 finney);\n', '        require(msg.sender != address(0));\n', '        require(parentUser != address(0));\n', '        require(!usersExist[msg.sender]);\n', '        _register(msg.sender, msg.value);\n', '    }\n', '    \n', '    \n', '    function _register(address user, uint256 amount) internal {\n', '        \n', '        \n', '         \n', '        if (users.length > 0) {\n', '            require(parentUser!=user);\n', '            require(usersExist[parentUser]); \n', '        }\n', '        \n', '       if (users.length ==0) {users2users[parentUser]=parentUser;} \n', '       \n', '       \n', '        users.push(user);\n', '        usersExist[user]=true;\n', '        users2users[user]=parentUser;\n', '        \n', '        \n', '        emit Register(user, parentUser);\n', '        \n', '        uint256 referalBonus = amount.div(2);\n', '        \n', '        if (cyles==0) {referalBonus = amount;} //we exclude a money wave\n', '        \n', '        balances[parentUser] = balances[parentUser].add(referalBonus.div(2));\n', '        balancesTotal[parentUser] = balancesTotal[parentUser].add(referalBonus.div(2));\n', '        \n', '        emit ReferalBonus(parentUser, referalBonus.div(2));\n', '        \n', '        balances[users2users[parentUser]] = balances[users2users[parentUser]].add(referalBonus.div(2));\n', '        balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(referalBonus.div(2));\n', '        \n', '        emit ReferalBonus(users2users[parentUser], referalBonus.div(2));\n', '        \n', '        uint256 length = users.length;\n', '        uint256 existLastIndex = length.sub(1);\n', '        \n', '        //we exclude a money wave\n', '        if (cyles!=0){ \n', '            \n', '        for (uint i = 1; i <= cyles; i++) {\n', '            nextUserId = nextUserId.add(1);\n', '\t\t\t\n', '            if(nextUserId > existLastIndex){ nextUserId = 0;}\n', '            \n', '            balances[users[nextUserId]] = balances[users[nextUserId]].add(referalBonus.div(cyles));\n', '            balancesTotal[users[nextUserId]] = balancesTotal[users[nextUserId]].add(referalBonus.div(cyles));\n', '            \n', '            emit BalanceUp(users[nextUserId], referalBonus.div(cyles));\n', '        }\n', '      \n', '        }  //we exclude a money wave\n', '    \n', '    }\n', '    \n', '    function transferMyMoney() public {\n', '        require(balances[msg.sender]>0);\n', '        msg.sender.transfer(balances[msg.sender]);\n', '        emit TransferMyMoney(msg.sender, balances[msg.sender]);\n', '\t\tbalances[msg.sender]=0;\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '      function ViewRealBalance(address input) public view returns (uint256 balanceReal) {  \n', '       balanceReal= balances[input];\n', '       balanceReal=balanceReal.div(1000000000000);\n', '          return balanceReal;\n', '    }\n', '    \n', '   \n', '    function ViewTotalBalance(address input)   public view returns (uint256 balanceTotal) {\n', '      balanceTotal=balancesTotal [input];\n', '      balanceTotal=balanceTotal.div(1000000000000);\n', '          return balanceTotal;\n', '   }\n', '   \n', '    \n', '   function viewBlockchainArceonMoneyNetwork(uint256 id) public view  returns (address userAddress) {\n', '        return users[id];\n', '    } \n', '    \n', '    \n', '    function  CirclePoints() public view returns (uint256 CirclePoint) {\n', '        CirclePoint = nextUserId;\n', '        \n', '        return  CirclePoint;\n', '    }\n', '    \n', '    function  NumberUser() public view returns (uint256 numberOfUser) {\n', '        \n', '        numberOfUser = users.length;\n', '        \n', '        return numberOfUser;\n', '    } \n', '    \n', '    function  LenCyless() public view returns (uint256 LenCyles) {\n', '        \n', '        LenCyles = cyles;\n', '        \n', '        return LenCyles;\n', '    } \n', '    \n', '    \n', '    \n', '    function newCyles(uint256 _newCyles) external onlyOwner {\n', '      \n', '       cyles = _newCyles;\n', '    }\n', '    \n', '}    \n', '    \n', '   library SafeMath {\n', '       \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '    \n', '}']