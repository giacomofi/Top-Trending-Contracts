['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract BouncyCoinIco {\n', '\n', '  event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount);\n', '\n', '  struct PriceThreshold {\n', '    uint256 tokenCount;\n', '    uint256 price;\n', '    uint256 tokensSold;\n', '  }\n', '\n', '  uint256 public constant PRE_ICO_TOKENS = 10000000 * 10**18;\n', '  uint256 public constant PRE_ICO_PRICE = 0.00010 * 10**18;\n', '\n', '  uint256 public constant PRE_ICO_MINIMUM_CONTRIBUTION = 5 ether;\n', '  uint256 public constant ICO_MINIMUM_CONTRIBUTION = 0.1 ether;\n', '\n', '  uint256 public maxPreIcoDuration;\n', '  uint256 public maxIcoDuration;\n', '\n', '  address public owner;\n', '\n', '  address public wallet;\n', '\n', '  ERC20 public bouncyCoinToken;\n', '\n', '  uint256 public startBlock;\n', '  uint256 public preIcoEndBlock;\n', '  uint256 public icoEndBlock;\n', '\n', '  uint256 public preIcoTokensSold;\n', '  PriceThreshold[2] public icoPriceThresholds;\n', '\n', '  /* Current stage */\n', '  Stages public stage;\n', '\n', '  enum Stages {\n', '    Deployed,\n', '    SetUp,\n', '    StartScheduled,\n', '    PreIcoStarted,\n', '    IcoStarted,\n', '    Ended\n', '  }\n', '\n', '  /* Modifiers */\n', '\n', '  modifier atStage(Stages _stage) {\n', '    require(stage == _stage);\n', '    _;\n', '  }\n', '\n', '  modifier isOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier isValidPayload() {\n', '    require(msg.data.length == 0 || msg.data.length == 4);\n', '    _;\n', '  }\n', '\n', '  modifier timedTransitions() {\n', '    if (stage == Stages.StartScheduled && block.number >= startBlock) {\n', '      startPreIco();\n', '    }\n', '    if (stage == Stages.PreIcoStarted && block.number >= preIcoEndBlock) {\n', '      startIco();\n', '    }\n', '    if (stage == Stages.IcoStarted && block.number >= icoEndBlock) {\n', '      finalize();\n', '    }\n', '    _;\n', '  }\n', '\n', '  /* Constructor */\n', '\n', '  constructor(address _wallet)\n', '    public {\n', '    require(_wallet != 0x0);\n', '\n', '    owner = msg.sender;\n', '    wallet = _wallet;\n', '    stage = Stages.Deployed;\n', '  }\n', '\n', '  /* Public functions */\n', '\n', '  function()\n', '    public\n', '    payable\n', '    timedTransitions {\n', '    if (stage == Stages.PreIcoStarted) {\n', '      buyPreIcoTokens();\n', '    } else if (stage == Stages.IcoStarted) {\n', '      buyIcoTokens();\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function setup(address _bouncyCoinToken, uint256 _maxPreIcoDuration, uint256 _maxIcoDuration)\n', '    public\n', '    isOwner\n', '    atStage(Stages.Deployed) {\n', '    require(_bouncyCoinToken != 0x0);\n', '    require(_maxPreIcoDuration > 0);\n', '    require(_maxIcoDuration > 0);\n', '\n', '    icoPriceThresholds[0] = PriceThreshold(20000000 * 10**18, 0.00020 * 10**18, 0);\n', '    icoPriceThresholds[1] = PriceThreshold(50000000 * 10**18, 0.00025 * 10**18, 0);\n', '\n', '    bouncyCoinToken = ERC20(_bouncyCoinToken);\n', '    maxPreIcoDuration = _maxPreIcoDuration;\n', '    maxIcoDuration = _maxIcoDuration;\n', '\n', '    // validate token balance\n', '    uint256 tokensRequired = PRE_ICO_TOKENS + maxIcoTokensSold();\n', '    assert(bouncyCoinToken.balanceOf(this) == tokensRequired);\n', '\n', '    stage = Stages.SetUp;\n', '  }\n', '\n', '  function maxIcoTokensSold()\n', '    public\n', '    constant\n', '    returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      total += icoPriceThresholds[i].tokenCount;\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function totalIcoTokensSold()\n', '    public\n', '    constant\n', '    returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      total += icoPriceThresholds[i].tokensSold;\n', '    }\n', '    return total;\n', '  }\n', '\n', '  /* Schedules the start */\n', '  function scheduleStart(uint256 _startBlock)\n', '    public\n', '    isOwner\n', '    atStage(Stages.SetUp) {\n', '    startBlock = _startBlock;\n', '    preIcoEndBlock = startBlock + maxPreIcoDuration;\n', '    stage = Stages.StartScheduled;\n', '  }\n', '\n', '  function updateStage()\n', '    public\n', '    timedTransitions\n', '    returns (Stages) {\n', '    return stage;\n', '  }\n', '\n', '  function buyPreIcoTokens()\n', '    public\n', '    payable\n', '    isValidPayload\n', '    timedTransitions\n', '    atStage(Stages.PreIcoStarted) {\n', '    require(msg.value >= PRE_ICO_MINIMUM_CONTRIBUTION);\n', '\n', '    uint256 amountRemaining = msg.value;\n', '\n', '    uint256 tokensAvailable = PRE_ICO_TOKENS - preIcoTokensSold;\n', '    uint256 maxTokensByAmount = amountRemaining * 10**18 / PRE_ICO_PRICE;\n', '\n', '    uint256 tokensToReceive = 0;\n', '    if (maxTokensByAmount > tokensAvailable) {\n', '      tokensToReceive = tokensAvailable;\n', '      amountRemaining -= (PRE_ICO_PRICE * tokensToReceive) / 10**18;\n', '    } else {\n', '      tokensToReceive = maxTokensByAmount;\n', '      amountRemaining = 0;\n', '    }\n', '    preIcoTokensSold += tokensToReceive;\n', '\n', '    assert(tokensToReceive > 0);\n', '\n', '    if (amountRemaining != 0) {\n', '      msg.sender.transfer(amountRemaining);\n', '    }\n', '\n', '    uint256 amountAccepted = msg.value - amountRemaining;\n', '    wallet.transfer(amountAccepted);\n', '\n', '    if (preIcoTokensSold == PRE_ICO_TOKENS) {\n', '      startIco();\n', '    }\n', '\n', '    emit TokensSold(msg.sender, tokensToReceive, amountAccepted);\n', '  }\n', '\n', '  function buyIcoTokens()\n', '    public\n', '    payable\n', '    isValidPayload\n', '    timedTransitions\n', '    atStage(Stages.IcoStarted) {\n', '    require(msg.value >= ICO_MINIMUM_CONTRIBUTION);\n', '\n', '    uint256 amountRemaining = msg.value;\n', '    uint256 tokensToReceive = 0;\n', '\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      uint256 tokensAvailable = icoPriceThresholds[i].tokenCount - icoPriceThresholds[i].tokensSold;\n', '      uint256 maxTokensByAmount = amountRemaining * 10**18 / icoPriceThresholds[i].price;\n', '\n', '      uint256 tokens;\n', '      if (maxTokensByAmount > tokensAvailable) {\n', '        tokens = tokensAvailable;\n', '        amountRemaining -= (icoPriceThresholds[i].price * tokens) / 10**18;\n', '      } else {\n', '        tokens = maxTokensByAmount;\n', '        amountRemaining = 0;\n', '      }\n', '      icoPriceThresholds[i].tokensSold += tokens;\n', '      tokensToReceive += tokens;\n', '    }\n', '\n', '    assert(tokensToReceive > 0);\n', '\n', '    if (amountRemaining != 0) {\n', '      msg.sender.transfer(amountRemaining);\n', '    }\n', '\n', '    uint256 amountAccepted = msg.value - amountRemaining;\n', '    wallet.transfer(amountAccepted);\n', '\n', '    if (totalIcoTokensSold() == maxIcoTokensSold()) {\n', '      finalize();\n', '    }\n', '\n', '    emit TokensSold(msg.sender, tokensToReceive, amountAccepted);\n', '  }\n', '\n', '  function stop()\n', '    public\n', '    isOwner {\n', '    finalize();\n', '  }\n', '\n', '  function finishPreIcoAndStartIco()\n', '    public\n', '    isOwner\n', '    timedTransitions\n', '    atStage(Stages.PreIcoStarted) {\n', '    startIco();\n', '  }\n', '\n', '  /* Private functions */\n', '\n', '  function startPreIco()\n', '    private {\n', '    stage = Stages.PreIcoStarted;\n', '  }\n', '\n', '  function startIco()\n', '    private {\n', '    stage = Stages.IcoStarted;\n', '    icoEndBlock = block.number + maxIcoDuration;\n', '  }\n', '\n', '  function finalize()\n', '    private {\n', '    stage = Stages.Ended;\n', '  }\n', '\n', '  // In case of accidental ether lock on contract\n', '  function withdraw()\n', '    public\n', '    isOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '\n', '  // In case of accidental token transfer to this address, owner can transfer it elsewhere\n', '  function transferERC20Token(address _tokenAddress, address _to, uint256 _value)\n', '    public\n', '    isOwner {\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transfer(_to, _value));\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract BouncyCoinIco {\n', '\n', '  event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount);\n', '\n', '  struct PriceThreshold {\n', '    uint256 tokenCount;\n', '    uint256 price;\n', '    uint256 tokensSold;\n', '  }\n', '\n', '  uint256 public constant PRE_ICO_TOKENS = 10000000 * 10**18;\n', '  uint256 public constant PRE_ICO_PRICE = 0.00010 * 10**18;\n', '\n', '  uint256 public constant PRE_ICO_MINIMUM_CONTRIBUTION = 5 ether;\n', '  uint256 public constant ICO_MINIMUM_CONTRIBUTION = 0.1 ether;\n', '\n', '  uint256 public maxPreIcoDuration;\n', '  uint256 public maxIcoDuration;\n', '\n', '  address public owner;\n', '\n', '  address public wallet;\n', '\n', '  ERC20 public bouncyCoinToken;\n', '\n', '  uint256 public startBlock;\n', '  uint256 public preIcoEndBlock;\n', '  uint256 public icoEndBlock;\n', '\n', '  uint256 public preIcoTokensSold;\n', '  PriceThreshold[2] public icoPriceThresholds;\n', '\n', '  /* Current stage */\n', '  Stages public stage;\n', '\n', '  enum Stages {\n', '    Deployed,\n', '    SetUp,\n', '    StartScheduled,\n', '    PreIcoStarted,\n', '    IcoStarted,\n', '    Ended\n', '  }\n', '\n', '  /* Modifiers */\n', '\n', '  modifier atStage(Stages _stage) {\n', '    require(stage == _stage);\n', '    _;\n', '  }\n', '\n', '  modifier isOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier isValidPayload() {\n', '    require(msg.data.length == 0 || msg.data.length == 4);\n', '    _;\n', '  }\n', '\n', '  modifier timedTransitions() {\n', '    if (stage == Stages.StartScheduled && block.number >= startBlock) {\n', '      startPreIco();\n', '    }\n', '    if (stage == Stages.PreIcoStarted && block.number >= preIcoEndBlock) {\n', '      startIco();\n', '    }\n', '    if (stage == Stages.IcoStarted && block.number >= icoEndBlock) {\n', '      finalize();\n', '    }\n', '    _;\n', '  }\n', '\n', '  /* Constructor */\n', '\n', '  constructor(address _wallet)\n', '    public {\n', '    require(_wallet != 0x0);\n', '\n', '    owner = msg.sender;\n', '    wallet = _wallet;\n', '    stage = Stages.Deployed;\n', '  }\n', '\n', '  /* Public functions */\n', '\n', '  function()\n', '    public\n', '    payable\n', '    timedTransitions {\n', '    if (stage == Stages.PreIcoStarted) {\n', '      buyPreIcoTokens();\n', '    } else if (stage == Stages.IcoStarted) {\n', '      buyIcoTokens();\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function setup(address _bouncyCoinToken, uint256 _maxPreIcoDuration, uint256 _maxIcoDuration)\n', '    public\n', '    isOwner\n', '    atStage(Stages.Deployed) {\n', '    require(_bouncyCoinToken != 0x0);\n', '    require(_maxPreIcoDuration > 0);\n', '    require(_maxIcoDuration > 0);\n', '\n', '    icoPriceThresholds[0] = PriceThreshold(20000000 * 10**18, 0.00020 * 10**18, 0);\n', '    icoPriceThresholds[1] = PriceThreshold(50000000 * 10**18, 0.00025 * 10**18, 0);\n', '\n', '    bouncyCoinToken = ERC20(_bouncyCoinToken);\n', '    maxPreIcoDuration = _maxPreIcoDuration;\n', '    maxIcoDuration = _maxIcoDuration;\n', '\n', '    // validate token balance\n', '    uint256 tokensRequired = PRE_ICO_TOKENS + maxIcoTokensSold();\n', '    assert(bouncyCoinToken.balanceOf(this) == tokensRequired);\n', '\n', '    stage = Stages.SetUp;\n', '  }\n', '\n', '  function maxIcoTokensSold()\n', '    public\n', '    constant\n', '    returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      total += icoPriceThresholds[i].tokenCount;\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function totalIcoTokensSold()\n', '    public\n', '    constant\n', '    returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      total += icoPriceThresholds[i].tokensSold;\n', '    }\n', '    return total;\n', '  }\n', '\n', '  /* Schedules the start */\n', '  function scheduleStart(uint256 _startBlock)\n', '    public\n', '    isOwner\n', '    atStage(Stages.SetUp) {\n', '    startBlock = _startBlock;\n', '    preIcoEndBlock = startBlock + maxPreIcoDuration;\n', '    stage = Stages.StartScheduled;\n', '  }\n', '\n', '  function updateStage()\n', '    public\n', '    timedTransitions\n', '    returns (Stages) {\n', '    return stage;\n', '  }\n', '\n', '  function buyPreIcoTokens()\n', '    public\n', '    payable\n', '    isValidPayload\n', '    timedTransitions\n', '    atStage(Stages.PreIcoStarted) {\n', '    require(msg.value >= PRE_ICO_MINIMUM_CONTRIBUTION);\n', '\n', '    uint256 amountRemaining = msg.value;\n', '\n', '    uint256 tokensAvailable = PRE_ICO_TOKENS - preIcoTokensSold;\n', '    uint256 maxTokensByAmount = amountRemaining * 10**18 / PRE_ICO_PRICE;\n', '\n', '    uint256 tokensToReceive = 0;\n', '    if (maxTokensByAmount > tokensAvailable) {\n', '      tokensToReceive = tokensAvailable;\n', '      amountRemaining -= (PRE_ICO_PRICE * tokensToReceive) / 10**18;\n', '    } else {\n', '      tokensToReceive = maxTokensByAmount;\n', '      amountRemaining = 0;\n', '    }\n', '    preIcoTokensSold += tokensToReceive;\n', '\n', '    assert(tokensToReceive > 0);\n', '\n', '    if (amountRemaining != 0) {\n', '      msg.sender.transfer(amountRemaining);\n', '    }\n', '\n', '    uint256 amountAccepted = msg.value - amountRemaining;\n', '    wallet.transfer(amountAccepted);\n', '\n', '    if (preIcoTokensSold == PRE_ICO_TOKENS) {\n', '      startIco();\n', '    }\n', '\n', '    emit TokensSold(msg.sender, tokensToReceive, amountAccepted);\n', '  }\n', '\n', '  function buyIcoTokens()\n', '    public\n', '    payable\n', '    isValidPayload\n', '    timedTransitions\n', '    atStage(Stages.IcoStarted) {\n', '    require(msg.value >= ICO_MINIMUM_CONTRIBUTION);\n', '\n', '    uint256 amountRemaining = msg.value;\n', '    uint256 tokensToReceive = 0;\n', '\n', '    for (uint8 i = 0; i < icoPriceThresholds.length; i++) {\n', '      uint256 tokensAvailable = icoPriceThresholds[i].tokenCount - icoPriceThresholds[i].tokensSold;\n', '      uint256 maxTokensByAmount = amountRemaining * 10**18 / icoPriceThresholds[i].price;\n', '\n', '      uint256 tokens;\n', '      if (maxTokensByAmount > tokensAvailable) {\n', '        tokens = tokensAvailable;\n', '        amountRemaining -= (icoPriceThresholds[i].price * tokens) / 10**18;\n', '      } else {\n', '        tokens = maxTokensByAmount;\n', '        amountRemaining = 0;\n', '      }\n', '      icoPriceThresholds[i].tokensSold += tokens;\n', '      tokensToReceive += tokens;\n', '    }\n', '\n', '    assert(tokensToReceive > 0);\n', '\n', '    if (amountRemaining != 0) {\n', '      msg.sender.transfer(amountRemaining);\n', '    }\n', '\n', '    uint256 amountAccepted = msg.value - amountRemaining;\n', '    wallet.transfer(amountAccepted);\n', '\n', '    if (totalIcoTokensSold() == maxIcoTokensSold()) {\n', '      finalize();\n', '    }\n', '\n', '    emit TokensSold(msg.sender, tokensToReceive, amountAccepted);\n', '  }\n', '\n', '  function stop()\n', '    public\n', '    isOwner {\n', '    finalize();\n', '  }\n', '\n', '  function finishPreIcoAndStartIco()\n', '    public\n', '    isOwner\n', '    timedTransitions\n', '    atStage(Stages.PreIcoStarted) {\n', '    startIco();\n', '  }\n', '\n', '  /* Private functions */\n', '\n', '  function startPreIco()\n', '    private {\n', '    stage = Stages.PreIcoStarted;\n', '  }\n', '\n', '  function startIco()\n', '    private {\n', '    stage = Stages.IcoStarted;\n', '    icoEndBlock = block.number + maxIcoDuration;\n', '  }\n', '\n', '  function finalize()\n', '    private {\n', '    stage = Stages.Ended;\n', '  }\n', '\n', '  // In case of accidental ether lock on contract\n', '  function withdraw()\n', '    public\n', '    isOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '\n', '  // In case of accidental token transfer to this address, owner can transfer it elsewhere\n', '  function transferERC20Token(address _tokenAddress, address _to, uint256 _value)\n', '    public\n', '    isOwner {\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transfer(_to, _value));\n', '  }\n', '\n', '}']
