['pragma solidity ^0.4.24;    \n', '////////////////////////////////////////////////////////////////////////////////\n', 'library     SafeMath\n', '{\n', '    //------------------\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0)     return 0;\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        return a/b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    ERC20 \n', '{\n', '    using SafeMath  for uint256;\n', '\n', '    //----- VARIABLES\n', '\n', '    address public              owner;          // Owner of this contract\n', '    address public              admin;          // The one who is allowed to do changes \n', '\n', '    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\n', '    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\n', '\n', '    //------ TOKEN SPECIFICATION\n', '\n', '    string  public  constant    name     = "Reger Diamond Security Token";\n', '    string  public  constant    symbol   = "RDS";\n', '\n', '    uint256 public  constant    decimals = 18;\n', '    \n', '    uint256 public  constant    initSupply       = 60000000 * 10**decimals;        // 10**18 max\n', '    uint256 public  constant    supplyReserveVal = 37500000 * 10**decimals;          // if quantity => the ##MACRO## addrs "* 10**decimals" \n', '\n', '    //-----\n', '\n', '    uint256 public              totalSupply;\n', '    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\n', '    uint256 public              icoReserveSupply = 0;\n', '    uint256 public              softCap =  5000000   * 10**decimals;\n', '    uint256 public              hardCap = 21500000   * 10**decimals;\n', '\n', '    //---------------------------------------------------- smartcontract control\n', '\n', '    uint256 public              icoDeadLine = 1533513600;     // 2018-08-06 00:00 (GMT+0)   not needed\n', '\n', '    bool    public              isIcoPaused            = false; \n', '    bool    public              isStoppingIcoOnHardCap = true;\n', '\n', '    //--------------------------------------------------------------------------\n', '\n', '    modifier duringIcoOnlyTheOwner()  // if not during the ico : everyone is allowed at anytime\n', '    { \n', '        require( now>icoDeadLine || msg.sender==owner );\n', '        _;\n', '    }\n', '\n', '    modifier icoFinished()          { require(now > icoDeadLine);           _; }\n', '    modifier icoNotFinished()       { require(now <= icoDeadLine);          _; }\n', '    modifier icoNotPaused()         { require(isIcoPaused==false);          _; }\n', '    modifier icoPaused()            { require(isIcoPaused==true);           _; }\n', '    modifier onlyOwner()            { require(msg.sender==owner);           _; }\n', '    modifier onlyAdmin()            { require(msg.sender==admin);           _; }\n', '\n', '    //----- EVENTS\n', '\n', '    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\n', '    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\n', '\n', '            //---- extra EVENTS\n', '\n', '    event onAdminUserChanged(   address oldAdmin,       address newAdmin);\n', '    event onOwnershipTransfered(address oldOwner,       address newOwner);\n', '    event onIcoDeadlineChanged( uint256 oldIcoDeadLine, uint256 newIcoDeadline);\n', '    event onHardcapChanged(     uint256 hardCap,        uint256 newHardCap);\n', '    event icoIsNowPaused(       uint8 newPauseStatus);\n', '    event icoHasRestarted(      uint8 newPauseStatus);\n', '\n', '    event log(string key, string value);\n', '    event log(string key, uint   value);\n', '\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    constructor()   public \n', '    {\n', '        owner       = msg.sender;\n', '        admin       = owner;\n', '\n', '        isIcoPaused = false;\n', '        \n', '        //-----\n', '\n', '        balances[owner] = initSupply;   // send the tokens to the owner\n', '        totalSupply     = initSupply;\n', '        icoSalesSupply  = totalSupply;   \n', '\n', '        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\n', '\n', '        icoSalesSupply   = totalSupply.sub(supplyReserveVal);\n', '        icoReserveSupply = totalSupply.sub(icoSalesSupply);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //----- ERC20 FUNCTIONS\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function balanceOf(address walletAddress) public constant returns (uint256 balance) \n', '    {\n', '        return balances[walletAddress];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function transfer(address toAddr, uint256 amountInWei)  public   duringIcoOnlyTheOwner   returns (bool)     // don&#39;t icoNotPaused here. It&#39;s a logic issue. \n', '    {\n', '        require(toAddr!=0x0 && toAddr!=msg.sender && amountInWei>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\n', '\n', '        uint256 availableTokens = balances[msg.sender];\n', '\n', '        //----- Checking Token reserve first : if during ICO    \n', '\n', '        if (msg.sender==owner && now <= icoDeadLine)                    // ICO Reserve Supply checking: Don&#39;t touch the RESERVE of tokens when owner is selling\n', '        {\n', '            assert(amountInWei<=availableTokens);\n', '\n', '            uint256 balanceAfterTransfer = availableTokens.sub(amountInWei);      \n', '\n', '            assert(balanceAfterTransfer >= icoReserveSupply);           // We try to sell more than allowed during an ICO\n', '        }\n', '\n', '        //-----\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amountInWei);\n', '        balances[toAddr]     = balances[toAddr].add(amountInWei);\n', '\n', '        emit Transfer(msg.sender, toAddr, amountInWei);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function allowance(address walletAddress, address spender) public constant returns (uint remaining)\n', '    {\n', '        return allowances[walletAddress][spender];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function transferFrom(address fromAddr, address toAddr, uint256 amountInWei)  public  returns (bool) \n', '    {\n', '        if (amountInWei <= 0)                                   return false;\n', '        if (allowances[fromAddr][msg.sender] < amountInWei)     return false;\n', '        if (balances[fromAddr] < amountInWei)                   return false;\n', '\n', '        balances[fromAddr]               = balances[fromAddr].sub(amountInWei);\n', '        balances[toAddr]                 = balances[toAddr].add(amountInWei);\n', '        allowances[fromAddr][msg.sender] = allowances[fromAddr][msg.sender].sub(amountInWei);\n', '\n', '        emit Transfer(fromAddr, toAddr, amountInWei);\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function approve(address spender, uint256 amountInWei) public returns (bool) \n', '    {\n', '        require((amountInWei == 0) || (allowances[msg.sender][spender] == 0));\n', '        allowances[msg.sender][spender] = amountInWei;\n', '        emit Approval(msg.sender, spender, amountInWei);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function() public                       \n', '    {\n', '        assert(true == false);      // If Ether is sent to this address, don&#39;t handle it -> send it back.\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\n', '    {\n', '        require(newOwner != address(0));\n', '\n', '        emit onOwnershipTransfered(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    changeAdminUser(address newAdminAddress) public onlyOwner\n', '    {\n', '        require(newAdminAddress!=0x0);\n', '\n', '        emit onAdminUserChanged(admin, newAdminAddress);\n', '        admin = newAdminAddress;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    changeIcoDeadLine(uint256 newIcoDeadline) public onlyAdmin\n', '    {\n', '        require(newIcoDeadline!=0);\n', '\n', '        emit onIcoDeadlineChanged(icoDeadLine, newIcoDeadline);\n', '        icoDeadLine = newIcoDeadline;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    changeHardCap(uint256 newHardCap) public onlyAdmin\n', '    {\n', '        require(newHardCap!=0);\n', '\n', '        emit onHardcapChanged(hardCap, newHardCap);\n', '        hardCap = newHardCap;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    isHardcapReached()  public view returns(bool)\n', '    {\n', '        return (isStoppingIcoOnHardCap && initSupply-balances[owner] > hardCap);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    pauseICO()  public onlyAdmin\n', '    {\n', '        isIcoPaused = true;\n', '        emit icoIsNowPaused(1);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    unpauseICO()  public onlyAdmin\n', '    {\n', '        isIcoPaused = false;\n', '        emit icoHasRestarted(0);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    isPausedICO() public view     returns(bool)\n', '    {\n', '        return (isIcoPaused) ? true : false;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    DateTime \n', '{\n', '    struct TDateTime \n', '    {\n', '        uint16 year;    uint8 month;    uint8 day;\n', '        uint8 hour;     uint8 minute;   uint8 second;\n', '        uint8 weekday;\n', '    }\n', '    uint8[] totalDays = [ 0,   31,28,31,30,31,30,  31,31,30,31,30,31];\n', '    uint constant DAY_IN_SECONDS       = 86400;\n', '    uint constant YEAR_IN_SECONDS      = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '    uint constant HOUR_IN_SECONDS      = 3600;\n', '    uint constant MINUTE_IN_SECONDS    = 60;\n', '    uint16 constant ORIGIN_YEAR        = 1970;\n', '    //-------------------------------------------------------------------------\n', '    function isLeapYear(uint16 year) public pure returns (bool) \n', '    {\n', '        if ((year %   4)!=0)    return false;\n', '        if ( year % 100 !=0)    return true;\n', '        if ( year % 400 !=0)    return false;\n', '        return true;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function leapYearsBefore(uint year) public pure returns (uint) \n', '    {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) \n', '    {\n', '        uint8   nDay = 30;\n', '             if (month==1)          nDay++;\n', '        else if (month==3)          nDay++;\n', '        else if (month==5)          nDay++;\n', '        else if (month==7)          nDay++;\n', '        else if (month==8)          nDay++;\n', '        else if (month==10)         nDay++;\n', '        else if (month==12)         nDay++;\n', '        else if (month==2) \n', '        {\n', '                                    nDay = 28;\n', '            if (isLeapYear(year))   nDay++;\n', '        }\n', '        return nDay;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function parseTimestamp(uint timestamp) internal pure returns (TDateTime dt) \n', '    {\n', '        uint  secondsAccountedFor = 0;\n', '        uint  buf;\n', '        uint8 i;\n', '        uint  secondsInMonth;\n', '        dt.year = getYear(timestamp);\n', '        buf     = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS   * (dt.year - ORIGIN_YEAR - buf);\n', '        for (i = 1; i <= 12; i++) \n', '        {\n', '            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '            if (secondsInMonth + secondsAccountedFor > timestamp) \n', '            {\n', '                dt.month = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += secondsInMonth;\n', '        }\n', '        for (i=1; i<=getDaysInMonth(dt.month, dt.year); i++) \n', '        {\n', '            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) \n', '            {\n', '                dt.day = i;\n', '                break;\n', '            }\n', '            secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '        dt.hour    = getHour(timestamp);\n', '        dt.minute  = getMinute(timestamp);\n', '        dt.second  = getSecond(timestamp);\n', '        dt.weekday = getWeekday(timestamp);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getYear(uint timestamp) public pure returns (uint16) \n', '    {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '        year         = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '        while (secondsAccountedFor > timestamp) \n', '        {\n', '            if (isLeapYear(uint16(year - 1)))   secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '            else                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '            year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getMonth(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getDay(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getHour(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return uint8(((timestamp % 86400) / 3600) % 24);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getMinute(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return uint8((timestamp % 3600) / 60);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getSecond(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return uint8(timestamp % 60);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getWeekday(uint timestamp) public pure returns (uint8) \n', '    {\n', '        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) \n', '    {\n', '        return toTimestamp(year, month, day, 0, 0, 0);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) \n', '    {\n', '        return toTimestamp(year, month, day, hour, 0, 0);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) \n', '    {\n', '        return toTimestamp(year, month, day, hour, minute, 0);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) \n', '    {\n', '        uint16 i;\n', '        for (i = ORIGIN_YEAR; i < year; i++) \n', '        {\n', '            if (isLeapYear(i))  timestamp += LEAP_YEAR_IN_SECONDS;\n', '            else                timestamp += YEAR_IN_SECONDS;\n', '        }\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0]  = 31;\n', '        monthDayCounts[1]  = 28;     if (isLeapYear(year))   monthDayCounts[1] = 29;\n', '        monthDayCounts[2]  = 31;\n', '        monthDayCounts[3]  = 30;\n', '        monthDayCounts[4]  = 31;\n', '        monthDayCounts[5]  = 30;\n', '        monthDayCounts[6]  = 31;\n', '        monthDayCounts[7]  = 31;\n', '        monthDayCounts[8]  = 30;\n', '        monthDayCounts[9]  = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '        for (i=1; i<month; i++) \n', '        {\n', '            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '        timestamp += DAY_IN_SECONDS    * (day - 1);\n', '        timestamp += HOUR_IN_SECONDS   * (hour);\n', '        timestamp += MINUTE_IN_SECONDS * (minute);\n', '        timestamp += second;\n', '        return timestamp;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getYearDay(uint timestamp) public pure returns (uint16)\n', '    {\n', '        TDateTime memory date = parseTimestamp(timestamp);\n', '        uint16 dayCount=0;\n', '        for (uint8 iMonth=1; iMonth<date.month; iMonth++)\n', '        {\n', '            dayCount += getDaysInMonth(iMonth, date.year);\n', '        }\n', '        dayCount += date.day;   \n', '        return dayCount;        // We have now the amount of days since January 1st of that year\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function getDaysInYear(uint16 year) public pure returns (uint16)\n', '    {\n', '        return (isLeapYear(year)) ? 366:365;\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function    dateToTimestamp(uint16 iYear, uint8 iMonth, uint8 iDay) public pure returns(uint)\n', '    {\n', '        uint8 monthDayCount = 30;\n', '        if (iMonth==2)\n', '        {\n', '                                    monthDayCount = 28;\n', '            if (isLeapYear(iYear))  monthDayCount++;\n', '        }\n', '        if (iMonth==4 || iMonth==6 || iMonth==9 || iMonth==11)\n', '        {\n', '            monthDayCount = 31;\n', '        }\n', '        if (iDay<1)           \n', '        {\n', '            iDay = 1;\n', '        }\n', '        else if (iDay>monthDayCount)     \n', '        {\n', '            iDay = 1;       // if day is over limit, set the date on the first day of the next month\n', '            iMonth++;\n', '            if (iMonth>12)  \n', '            {\n', '                iMonth=1;\n', '                iYear++;\n', '            }\n', '        }\n', '        return toTimestamp(iYear, iMonth, iDay);\n', '    }\n', '    //-------------------------------------------------------------------------\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    CompoundContract  is  ERC20, DateTime\n', '{\n', '    using SafeMath  for uint256;\n', '\n', '        bool private    isLiveTerm = true;\n', '\n', '    struct TCompoundItem\n', '    {\n', '        uint        id;                         // an HASH to distinguish each compound in contract\n', '        uint        plan;                       // 1: Sapphire   2: Emerald   3:Ruby   4: Diamond\n', '        address     investor;                   // wallet address of the owner of this compound contract\n', '        uint        tokenCapitalInWei;          // = capital\n', '        uint        tokenEarningsInWei;         // This contract will geneeate this amount of tokens for the investor\n', '        uint        earningPerTermInWei;        // Every "3 months" the investor will receive this amount of money\n', '        uint        currentlyEarnedInWei;       // cumulative amount of tokens already received\n', '        uint        tokenEarnedInWei;           // = totalEarnings\n', '        uint        overallTokensInWei;         // = capital + totalEarnings\n', '        uint        contractMonthCount;         // 12 or 24\n', '        uint        startTimestamp;\n', '        uint        endTimestamp;               // the date when the compound contract will cease\n', '        uint        interestRate;\n', '        uint        percent;\n', '        bool        isAllPaid;                  // if true : all compound earning has been given. Nothing more to do\n', '        uint8       termPaidCount;              //\n', '        uint8       termCount;                  //\n', '        bool        isContractValidated;        // Any compound contract needs to be confirmed otherwise they will be cancelled\n', '        bool        isCancelled;                // The compound contract was not validated and has been set to cancelled!\n', '    }\n', '\n', '    mapping(address => uint256)                 lockedCapitals;     // During ICO we block some of the tokens\n', '    mapping(address => uint256)                 lockedEarnings;     // During ICO we block some of the tokens\n', '\n', '    mapping(uint256 => bool)         private    activeContractStatues;      // Use when doing a payEarnings to navigate through all contracts\n', '    mapping(uint => TCompoundItem)   private    contracts;\n', '    mapping(uint256 => uint32[12])   private    compoundPayTimes;    \n', '    mapping(uint256 => uint8[12])    private    compoundPayStatus;          // to know if a compound has already been paid or not. So not repaying again    \n', '\n', '    event onCompoundContractCompleted(address investor, uint256 compoundId, \n', '                                                        uint256 capital, \n', '                                                        uint256 earnedAmount, \n', '                                                        uint256 total, \n', '                                                        uint256 timestamp);\n', '\n', '    event onCompoundEarnings(address investor,  uint256 compoundId, \n', '                                                uint256 capital, \n', '                                                uint256 earnedAmount, \n', '                                                uint256 earnedSoFarAmount, \n', '                                                uint32  timestamp,\n', '                                                uint8   paidTermCount,\n', '                                                uint8   totalTermCount);\n', '\n', '    event onCompoundContractLocked(address fromAddr, address toAddr, uint256 amountToLockInWei);\n', '    event onPayEarningsDone(uint contractId, uint nPaid, uint paymentCount, uint paidAmountInWei);\n', '\n', '    event onCompoundContractCancelled(uint contractId, uint lockedCapital, uint lockedEarnings);\n', '    event onCompoundContractValidated(uint contractId);\n', '\n', '    //--------------------------------------------------------------------------\n', '    function    initCompoundContract(address buyerAddress, uint256 amountInWei, uint256 compoundContractId, uint monthCount)  internal onlyOwner  returns(bool)\n', '    {\n', '        TCompoundItem memory    item;\n', '        uint                    overallTokensInWei; \n', '        uint                    tokenEarningsInWei;\n', '        uint                    earningPerTermInWei; \n', '        uint                    percentToUse; \n', '        uint                    interestRate;\n', '        uint                    i;\n', '\n', '        if (activeContractStatues[compoundContractId])\n', '        {\n', '            return false;       // the specified contract is already in place. Don&#39;t alter already running contract!!!\n', '        }\n', '\n', '        activeContractStatues[compoundContractId] = true;\n', '\n', '        //----- Calculate the contract revenue generated for the whole monthPeriod\n', '\n', '        (overallTokensInWei, \n', '         tokenEarningsInWei,\n', '         earningPerTermInWei, \n', '         percentToUse, \n', '         interestRate,\n', '         i) = calculateCompoundContract(amountInWei, monthCount);\n', '\n', '        item.plan = i;                  // Not enough stack depth. using i here\n', '\n', '        //----- Checking if we can apply this compound contract or not\n', '\n', '        if (percentToUse==0)        // an error occured\n', '        {\n', '            return false;\n', '        }\n', '\n', '        //----- Calculate when to do payments for that contract\n', '\n', '        generateCompoundTerms(compoundContractId);\n', '\n', '        //-----\n', '\n', '        item.id                   = compoundContractId;\n', '        item.startTimestamp       = now;\n', '\n', '        item.contractMonthCount   = monthCount;\n', '        item.interestRate         = interestRate;\n', '        item.percent              = percentToUse;\n', '        item.investor             = buyerAddress;\n', '        item.isAllPaid            = false;\n', '        item.termCount            = uint8(monthCount/3);\n', '        item.termPaidCount        = 0;\n', '\n', '        item.tokenCapitalInWei    = amountInWei;\n', '        item.currentlyEarnedInWei = 0;\n', '        item.overallTokensInWei   = overallTokensInWei;\n', '        item.tokenEarningsInWei   = tokenEarningsInWei;\n', '        item.earningPerTermInWei  = earningPerTermInWei;\n', '\n', '        item.isCancelled          = false;\n', '        item.isContractValidated  = false;                      // any contract must be validated 35 days after its creation.\n', '\n', '        //-----\n', '\n', '        contracts[compoundContractId] = item;\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    generateCompoundTerms(uint256 compoundContractId)    private\n', '    {\n', '        uint16 iYear  =  getYear(now);\n', '        uint8  iMonth = getMonth(now);\n', '        uint   i;\n', '\n', '        if (isLiveTerm)\n', '        {\n', '            for (i=0; i<8; i++)             // set every pay schedule date (every 3 months)  8 means 2 years payments every 3 months\n', '            {\n', '                iMonth += 3;        // every 3 months\n', '                if (iMonth>12)\n', '                {\n', '                    iYear++;\n', '                    iMonth -= 12;\n', '                }\n', '\n', '                compoundPayTimes[compoundContractId][i]  = uint32(dateToTimestamp(iYear, iMonth, getDay(now)));\n', '                compoundPayStatus[compoundContractId][i] = 0;      \n', '            }\n', '        }\n', '        else\n', '        {\n', '            uint timeSum=now;\n', '            for (i=0; i<8; i++)             // set every pay schedule date (every 3 months)  8 means 2 years payments every 3 months\n', '            {\n', '                            uint duration = 4*60;    // set first period longer to allow confirmation of the contract\n', '                if (i>0)         duration = 2*60;\n', '\n', '                timeSum += duration;\n', '\n', '                compoundPayTimes[compoundContractId][i]  = uint32(timeSum);     // DEBUGING: pay every 3 minutes\n', '                compoundPayStatus[compoundContractId][i] = 0;      \n', '            }\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    calculateCompoundContract(uint256 capitalInWei, uint contractMonthCount)   public  constant returns(uint, uint, uint, uint, uint, uint)    // DON&#39;T Set as pure, otherwise it will make investXXMonths function unusable (too much gas) \n', '    {\n', '        /*  12 months   Sapphire    From     100 to   1,000     12%\n', '                        Emerald     From   1,000 to  10,000     15%\n', '                        Rub         From  10,000 to 100,000     17%\n', '                        Diamond                     100,000+    20%\n', '            24 months   Sapphire    From     100 to   1,000     15%\n', '                        Emerald     From   1,000 to  10,000     17%\n', '                        Rub         From  10,000 to 100,000     20%\n', '                        Diamond                     100,000+    30%        */\n', '\n', '        uint    plan          = 0;\n', '        uint256 interestRate  = 0;\n', '        uint256 percentToUse  = 0;\n', '\n', '        if (contractMonthCount==12)\n', '        {\n', '                 if (capitalInWei<  1000 * 10**18)      { percentToUse=12;  interestRate=1125509;   plan=1; }   // SAPPHIRE\n', '            else if (capitalInWei< 10000 * 10**18)      { percentToUse=15;  interestRate=1158650;   plan=2; }   // EMERALD\n', '            else if (capitalInWei<100000 * 10**18)      { percentToUse=17;  interestRate=1181148;   plan=3; }   // RUBY\n', '            else                                        { percentToUse=20;  interestRate=1215506;   plan=4; }   // DIAMOND\n', '        }\n', '        else if (contractMonthCount==24)\n', '        {\n', '                 if (capitalInWei<  1000 * 10**18)      { percentToUse=15;  interestRate=1342471;   plan=1; }\n', '            else if (capitalInWei< 10000 * 10**18)      { percentToUse=17;  interestRate=1395110;   plan=2; }\n', '            else if (capitalInWei<100000 * 10**18)      { percentToUse=20;  interestRate=1477455;   plan=3; }\n', '            else                                        { percentToUse=30;  interestRate=1783478;   plan=4; }\n', '        }\n', '        else\n', '        {\n', '            return (0,0,0,0,0,0);                   // only 12 and 24 months are allowed here\n', '        }\n', '\n', '        uint256 overallTokensInWei  = (capitalInWei *  interestRate         ) / 1000000;\n', '        uint256 tokenEarningsInWei  = overallTokensInWei - capitalInWei;\n', '        uint256 earningPerTermInWei = tokenEarningsInWei / (contractMonthCount/3);      // 3 is for => Pays a Term of earning every 3 months\n', '\n', '        return (overallTokensInWei,tokenEarningsInWei,earningPerTermInWei, percentToUse, interestRate, plan);\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    lockMoneyOnCompoundCreation(address toAddr, uint compountContractId)  internal  onlyOwner   returns (bool) \n', '    {\n', '        require(toAddr!=0x0 && toAddr!=msg.sender);     // Prevent transfer to 0x0 address and to self, amount must be >0\n', '\n', '        if (isHardcapReached())                                         \n', '        {\n', '            return false;       // an extra check first, who knows. \n', '        }\n', '\n', '        TCompoundItem memory item = contracts[compountContractId];\n', '\n', '        if (item.tokenCapitalInWei==0 || item.tokenEarningsInWei==0)    \n', '        {\n', '            return false;       // don&#39;t valid such invalid contract\n', '        }\n', '\n', '        //-----\n', '\n', '        uint256 amountToLockInWei = item.tokenCapitalInWei + item.tokenEarningsInWei;\n', '        uint256 availableTokens   = balances[owner];\n', '\n', '        if (amountToLockInWei <= availableTokens)\n', '        {\n', '            uint256 balanceAfterTransfer = availableTokens.sub(amountToLockInWei);      \n', '\n', '            if (balanceAfterTransfer >= icoReserveSupply)       // don&#39;t sell more than allowed during ICO\n', '            {\n', '                lockMoney(toAddr, item.tokenCapitalInWei, item.tokenEarningsInWei);\n', '                return true;\n', '            }\n', '        }\n', '\n', '        //emit log(&#39;Exiting lockMoneyOnCompoundCreation&#39;, &#39;cannot lock money&#39;);\n', '        return false;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    payCompoundTerm(uint contractId, uint8 termId, uint8 isCalledFromOutside)   public onlyOwner returns(int32)        // DON&#39;T SET icoNotPaused here, since a runnnig compound needs to run anyway\n', '    {\n', '        uint                    id;\n', '        address                 investor;\n', '        uint                    paidAmount;\n', '        TCompoundItem   memory  item;\n', '\n', '        if (!activeContractStatues[contractId])         \n', '        {\n', '            emit log("payCompoundTerm", "Specified contract is not actived (-1)");\n', '            return -1;\n', '        }\n', '\n', '        item = contracts[contractId];\n', '\n', '        //----- \n', '        if (item.isCancelled)   // That contract was never validated!!!\n', '        {\n', '            emit log("payCompoundTerm", "Compound contract already cancelled (-2)");\n', '            return -2;\n', '        }\n', '\n', '        //-----\n', '\n', '        if (item.isAllPaid)                             \n', '        {\n', '            emit log("payCompoundTerm", "All earnings already paid for this contract (-2)");\n', '            return -4;   // everything was paid already\n', '        }\n', '\n', '        id = item.id;\n', '\n', '        if (compoundPayStatus[id][termId]!=0)           \n', '        {\n', '            emit log("payCompoundTerm", "Specified contract&#39;s term was already paid (-5)");\n', '            return -5;\n', '        }\n', '\n', '        if (now < compoundPayTimes[id][termId])         \n', '        {\n', '            emit log("payCompoundTerm", "It&#39;s too early to pay this term (-6)");\n', '            return -6;\n', '        }\n', '\n', '        investor = item.investor;                                   // address of the owner of this compound contract\n', '\n', '        //----- It&#39;s time for the payment, but was that contract already validated\n', '        //----- If it was not validated, simply refund tokens to the main wallet\n', '\n', '        if (!item.isContractValidated)                          // Compound contract self-destruction since no validation was made of it\n', '        {\n', '            uint    capital  = item.tokenCapitalInWei;\n', '            uint    earnings = item.tokenEarningsInWei;\n', '\n', '            contracts[contractId].isCancelled        = true;\n', '            contracts[contractId].tokenCapitalInWei  = 0;       /// make sure nothing residual is left\n', '            contracts[contractId].tokenEarningsInWei = 0;       ///\n', '\n', '            //-----\n', '\n', '            lockedCapitals[investor] = lockedCapitals[investor].sub(capital);\n', '            lockedEarnings[investor] = lockedEarnings[investor].sub(earnings);\n', '\n', '            balances[owner] = balances[owner].add(capital);\n', '            balances[owner] = balances[owner].add(earnings);\n', '\n', '            emit onCompoundContractCancelled(contractId, capital, earnings);\n', '            emit log("payCompoundTerm", "Cancelling compound contract (-3)");\n', '            return -3;\n', '        }\n', '\n', '        //---- it&#39;s PAY time!!!\n', '\n', '        contracts[id].termPaidCount++;\n', '        contracts[id].currentlyEarnedInWei += item.earningPerTermInWei;  \n', '\n', '        compoundPayStatus[id][termId] = 1;                          // PAID!!!      meaning not to repay again this revenue term \n', '\n', '        unlockEarnings(investor, item.earningPerTermInWei);\n', '\n', '        paidAmount = item.earningPerTermInWei;\n', '\n', '        if (contracts[id].termPaidCount>=item.termCount && !contracts[item.id].isAllPaid)   // This is the last payment of all payments for this contract\n', '        {\n', '            contracts[id].isAllPaid = true;\n', '\n', '            unlockCapital(investor, item.tokenCapitalInWei);\n', '\n', '            paidAmount += item.tokenCapitalInWei;\n', '        }\n', '\n', '        //----- let&#39;s tell the blockchain now how many we&#39;ve unlocked.\n', '\n', '        if (isCalledFromOutside==0 && paidAmount>0)\n', '        {\n', '            emit Transfer(owner, investor, paidAmount);\n', '        }\n', '\n', '        return 1;       // We just paid one earning!!!\n', '                        // 1 IS IMPORTANT FOR THE TOKEN API. don&#39;t change it\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    validateCompoundContract(uint contractId) public onlyOwner   returns(uint)\n', '    {\n', '        TCompoundItem memory  item = contracts[contractId];\n', '\n', '        if (item.isCancelled==true)\n', '        {\n', '            return 2;       // don&#39;t try to validated an already dead contract\n', '        }\n', '\n', '        contracts[contractId].isCancelled         = false;\n', '        contracts[contractId].isContractValidated = true;\n', '\n', '        emit onCompoundContractValidated(contractId);\n', '\n', '        return 1;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //-----\n', '    //----- When an investor (investor) is put money (capital) in a compound investor\n', '    //----- We do calculate all interests (earnings) he will receive for the whole contract duration\n', '    //----- Then we lock the capital and the earnings into special vaults.\n', '    //----- We remove from the main token balance the capital invested and the future earnings\n', '    //----- So there won&#39;t be wrong calculation when people wishes to buy tokens\n', '    //-----\n', '    //----- If you use the standard ERC20 balanceOf to check balance of an investor, you will see\n', '    //----- balance = 0, if he just invested. This is normal, since money is locked in other vaults.\n', '    //----- To check the exact money of the investor, use instead :\n', '    //----- lockedCapitalOf(address investor)  \n', '    //----- to see the amount of money he fully invested and which which is still not available to him\n', '    //----- Use also\n', '    //----- locakedEarningsOf(address investor)\n', '    //----- It will show all the remaining benefit the person will get soon. The amount shown by This\n', '    //----- function will decrease from time to time, while the real balanceOf(address investor)\n', '    //----- will increase\n', '    //-----\n', '    //--------------------------------------------------------------------------\n', '    function    lockMoney(address investor, uint capitalAmountInWei, uint totalEarningsToReceiveInWei) internal onlyOwner\n', '    {\n', '        uint totalAmountToLockInWei = capitalAmountInWei + totalEarningsToReceiveInWei;\n', '\n', '        if (totalAmountToLockInWei <= balances[owner])\n', '        {\n', '            balances[owner] = balances[owner].sub(capitalAmountInWei.add(totalEarningsToReceiveInWei));     /// We remove capital & future earning from the Token&#39;s main balance, to put money in safe areas\n', '\n', '            lockedCapitals[investor] = lockedCapitals[investor].add(capitalAmountInWei);            /// The capital invested is now locked during the whole contract\n', '            lockedEarnings[investor] = lockedEarnings[investor].add(totalEarningsToReceiveInWei);   /// The whole earnings is full locked also in another vault called lockedEarnings\n', '\n', '            emit Transfer(owner, investor, capitalAmountInWei);    // No need to show all locked amounts. Because these locked ones contain capital + future earnings. \n', '        }                                                            // So we just show the capital. the earnings will appear after each payment.\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    unlockCapital(address investor, uint amountToUnlockInWei) internal onlyOwner\n', '    {\n', '        if (amountToUnlockInWei <= lockedCapitals[investor])\n', '        {\n', '            balances[investor]       = balances[investor].add(amountToUnlockInWei);\n', '            lockedCapitals[investor] = lockedCapitals[investor].sub(amountToUnlockInWei);    /// So to make all locked tokens available\n', '\n', '            //---- No need of emit Transfer here. It is called from elsewhere\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    unlockEarnings(address investor, uint amountToUnlockInWei) internal onlyOwner\n', '    {\n', '        if (amountToUnlockInWei <= lockedEarnings[investor])\n', '        {\n', '            balances[investor]       = balances[investor].add(amountToUnlockInWei);\n', '            lockedEarnings[investor] = lockedEarnings[investor].sub(amountToUnlockInWei);    /// So to make all locked tokens available\n', '\n', '            //---- No need of emit Transfer here. It is called from elsewhere\n', '        }\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    lockedCapitalOf(address investor) public  constant  returns(uint256)\n', '    {\n', '        return lockedCapitals[investor];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    lockedEarningsOf(address investor) public  constant  returns(uint256)\n', '    {\n', '        return lockedEarnings[investor];\n', '    }  \n', '    //--------------------------------------------------------------------------\n', '    function    lockedBalanceOf(address investor) public  constant  returns(uint256)\n', '    {\n', '        return lockedCapitals[investor] + lockedEarnings[investor];\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    geCompoundTimestampsFor12Months(uint contractId) public view  returns(uint256,uint256,uint256,uint256)\n', '    {\n', '        uint32[12] memory t = compoundPayTimes[contractId];\n', '\n', '        return(uint256(t[0]),uint256(t[1]),uint256(t[2]),uint256(t[3]));\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function    geCompoundTimestampsFor24Months(uint contractId) public view  returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)\n', '    {\n', '        uint32[12] memory t = compoundPayTimes[contractId];\n', '\n', '        return(uint256(t[0]),uint256(t[1]),uint256(t[2]),uint256(t[3]),uint256(t[4]),uint256(t[5]),uint256(t[6]),uint256(t[7]));\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function    getCompoundContract(uint contractId) public constant    returns(address investor, \n', '                                                                        uint capital, \n', '                                                                        uint profitToGenerate,\n', '                                                                        uint earnedSoFarAmount, \n', '                                                                        uint percent,\n', '                                                                        uint interestRate,\n', '                                                                        uint paidTermCount,\n', '                                                                        uint isAllPaid,\n', '                                                                        uint monthCount,\n', '                                                                        uint earningPerTerm,\n', '                                                                        uint isCancelled)\n', '    {\n', '        TCompoundItem memory item;\n', '\n', '        item = contracts[contractId];\n', '\n', '        return\n', '        (\n', '            item.investor,\n', '            item.tokenCapitalInWei,\n', '            item.tokenEarningsInWei,\n', '            item.currentlyEarnedInWei,\n', '            item.percent,\n', '            item.interestRate,\n', '            uint(item.termPaidCount),\n', '            (item.isAllPaid) ? 1:0,\n', '            item.contractMonthCount,\n', '            item.earningPerTermInWei,\n', '            (item.isCancelled) ? 1:0\n', '        );\n', '    }\n', '    //-------------------------------------------------------------------------\n', '    function    getCompoundPlan(uint contractId) public constant  returns(uint plan)\n', '    {\n', '        return contracts[contractId].plan;\n', '    }\n', '}\n', '////////////////////////////////////////////////////////////////////////////////\n', 'contract    Token  is  CompoundContract\n', '{\n', '    using SafeMath  for uint256;\n', '\n', '    //--------------------------------------------------------------------------\n', '    //----- OVERRIDDEN FUNCTION :  "transfer" function from ERC20\n', '    //----- For this smartcontract we don&#39;t deal with a deaLine date.\n', '    //----- So it&#39;s a normally transfer function with no restriction.\n', '    //----- Restricted tokens are inside the lockedTokens balances, not in ERC20 balances\n', '    //----- That means people after 3 months can start using their earned tokens\n', '    //--------------------------------------------------------------------------\n', '    function transfer(address toAddr, uint256 amountInWei)  public      returns (bool)     // TRANSFER is not restricted during ICO!!!\n', '    {\n', '        require(toAddr!=0x0 && toAddr!=msg.sender && amountInWei>0);    // Prevent transfer to 0x0 address and to self, amount must be >0\n', '\n', '        uint256 availableTokens = balances[msg.sender];\n', '\n', '        //----- Checking Token reserve first : if during ICO    \n', '\n', '        if (msg.sender==owner && !isHardcapReached())              // for RegerDiamond : handle reserved supply while ICO is running\n', '        {\n', '            assert(amountInWei<=availableTokens);\n', '\n', '            uint256 balanceAfterTransfer = availableTokens.sub(amountInWei);      \n', '\n', '            assert(balanceAfterTransfer >= icoReserveSupply);           // We try to sell more than allowed during an ICO\n', '        }\n', '\n', '        //-----\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amountInWei);\n', '        balances[toAddr]     = balances[toAddr].add(amountInWei);\n', '\n', '        emit Transfer(msg.sender, toAddr, amountInWei);\n', '\n', '        return true;\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    function    investFor12Months(address buyerAddress, uint256  amountInWei,\n', '                                                          uint256  compoundContractId)\n', '                                                public onlyOwner  \n', '                                                returns(int)\n', '    {\n', '\n', '        uint    monthCount=12;\n', '\n', '        if (!isHardcapReached())\n', '        {\n', '            if (initCompoundContract(buyerAddress, amountInWei, compoundContractId, monthCount))\n', '            {\n', '                if (!lockMoneyOnCompoundCreation(buyerAddress, compoundContractId))      // Now lock the main capital (amountInWei) until the end of the compound\n', '                {\n', '                    return -1;\n', '                }\n', '            }\n', '            else \n', '            {\n', '                return -2; \n', '            }\n', '        }\n', '        else        // ICO is over.  Use the ERC20 transfer now. Compound is now forbidden. Nothing more to lock \n', '        {\n', '            Token.transfer(buyerAddress, amountInWei);\n', '            return 2;\n', '        }\n', '\n', '        return 1;       // -1: could not lock the capital\n', '                        // -2: Compound contract creation error\n', '                        //  2: ICO is over, coumpounds no more allowed. Standard ERC20 transfer only\n', '                        //  1: Compound contract created correctly\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    function    investFor24Months(address buyerAddress, uint256  amountInWei,\n', '                                                        uint256  compoundContractId)\n', '                                                public onlyOwner \n', '                                                returns(int)\n', '    {\n', '\n', '        uint    monthCount=24;\n', '\n', '        if (!isHardcapReached())\n', '        {\n', '            if (initCompoundContract(buyerAddress, amountInWei, compoundContractId, monthCount))\n', '            {\n', '                if (!lockMoneyOnCompoundCreation(buyerAddress, compoundContractId))    // Now lock the main capital (amountInWei) until the end of the compound\n', '                {\n', '                    return -1; \n', '                }\n', '            }\n', '            else { return -2; }\n', '        }\n', '        else        // ICO is over.  Use the ERC20 transfer now. Compound is now forbidden. Nothing more to lock \n', '        {\n', '            Token.transfer(buyerAddress, amountInWei);\n', '            return 2;\n', '        }\n', '\n', '        return 1;       // -1: could not lock the capital\n', '                        // -2: Compound contract creation error\n', '                        //  2: ICO is over, coumpounds no more allowed. Standard ERC20 transfer only\n', '                        //  1: Compound contract created correctly*/\n', '    }\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '    //--------------------------------------------------------------------------\n', '}']