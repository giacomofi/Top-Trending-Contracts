['pragma solidity ^0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface smartContract {\n', '    function transfer(address _to, uint256 _value) payable external;\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '}\n', '\n', 'contract Basic is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // This creates an array with all balances\n', '    mapping(address => uint256) public totalAmount;\n', '    mapping(address => uint256) public availableAmount;\n', '    mapping(address => uint256) public withdrawedAmount;\n', '    uint[] public periods;\n', '    uint256 public currentPeriod;\n', '    smartContract public contractAddress;\n', '    uint256 public ownerWithdrawalDate;\n', '\n', '    // fix for short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        assert(msg.data.length == size + 4);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * transfer tokens to the smart contract here\n', '     */\n', '    function Basic(address _contractAddress) public onlyOwner {\n', '        contractAddress = smartContract(_contractAddress);\n', '    }\n', '\n', '    function _recalculateAvailable(address _addr) internal {\n', '        _updateCurrentPeriod();\n', '        uint256 available;\n', '        uint256 calcPeriod = currentPeriod + 1;\n', '        if (calcPeriod < periods.length) {\n', '            available = totalAmount[_addr].div(periods.length).mul(calcPeriod);\n', '            //you don&#39;t have anything to withdraw\n', '            require(available > withdrawedAmount[_addr]);\n', '            //remove already withdrawed tokens\n', '            available = available.sub(withdrawedAmount[_addr]);\n', '        } else {\n', '            available = totalAmount[_addr].sub(withdrawedAmount[_addr]);\n', '        }\n', '        availableAmount[_addr] = available;\n', '    }\n', '\n', '    function addRecipient(address _from, uint256 _amount) external onlyOwner onlyPayloadSize(2 * 32) {\n', '        require(_from != 0x0);\n', '        require(totalAmount[_from] == 0);\n', '        totalAmount[_from] = _amount;\n', '        availableAmount[_from] = 0;\n', '        withdrawedAmount[_from] = 0;\n', '    }\n', '\n', '    function withdraw() public payable {\n', '        _withdraw(msg.sender);\n', '    }\n', '\n', '    function _withdraw(address _addr) internal {\n', '        require(_addr != 0x0);\n', '        require(totalAmount[_addr] > 0);\n', '\n', '        //Recalculate available balance if time has come\n', '        _recalculateAvailable(_addr);\n', '        require(availableAmount[_addr] > 0);\n', '        uint256 available = availableAmount[_addr];\n', '        withdrawedAmount[_addr] = withdrawedAmount[_addr].add(available);\n', '        availableAmount[_addr] = 0;\n', '\n', '        contractAddress.transfer(_addr, available);\n', '    }\n', '\n', '    function triggerWithdraw(address _addr) public payable onlyOwner {\n', '        _withdraw(_addr);\n', '    }\n', '\n', '    // owner may withdraw funds after some period of time\n', '    function withdrawToOwner(uint256 _amount) external onlyOwner {\n', '        // no need to create modifier for one case\n', '        require(now > ownerWithdrawalDate);\n', '        contractAddress.transfer(msg.sender, _amount);\n', '    }\n', '\n', '    function _updateCurrentPeriod() internal {\n', '        require(periods.length >= 1);\n', '        for (uint i = 0; i < periods.length; i++) {\n', '            if (periods[i] <= now && i >= currentPeriod) {\n', '                currentPeriod = i;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Partners is Basic{\n', '    function Partners(address _contractAddress) Basic(_contractAddress) public {\n', '        periods = [\n', '            now + 61 days\n', '        ];\n', '        ownerWithdrawalDate = now + 91 days;\n', '    }\n', '}']