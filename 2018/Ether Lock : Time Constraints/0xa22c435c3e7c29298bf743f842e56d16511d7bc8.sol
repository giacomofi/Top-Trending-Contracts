['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/TweedentityRegistry.sol\n', '\n', 'interface ManagerInterface {\n', '\n', '  function paused()\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function claimer()\n', '  public\n', '  constant returns (address);\n', '\n', '  function totalStores()\n', '  public\n', '  constant returns (uint);\n', '\n', '\n', '  function getStoreAddress(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (address);\n', '\n', '\n', '  function getStoreAddressById(\n', '    uint _appId\n', '  )\n', '  external\n', '  constant returns (address);\n', '\n', '\n', '  function isStoreActive(\n', '    uint _appId\n', '  )\n', '  public\n', '  constant returns (bool);\n', '\n', '}\n', '\n', 'interface ClaimerInterface {\n', '\n', '  function manager()\n', '  public\n', '  constant returns (address);\n', '}\n', '\n', '\n', 'interface StoreInterface {\n', '\n', '  function appSet()\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function manager()\n', '  public\n', '  constant returns (address);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title TweedentityRegistry\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev It store the tweedentities contracts addresses to allows dapp to be updated\n', ' */\n', '\n', '\n', 'contract TweedentityRegistry\n', 'is HasNoEther\n', '{\n', '\n', '  string public fromVersion = "1.0.0";\n', '\n', '  address public manager;\n', '  address public claimer;\n', '\n', '  event ContractRegistered(\n', '    bytes32 indexed key,\n', '    string spec,\n', '    address addr\n', '  );\n', '\n', '\n', '  function setManager(\n', '    address _manager\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    manager = _manager;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '  }\n', '\n', '\n', '  function setClaimer(\n', '    address _claimer\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_claimer != address(0));\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setManagerAndClaimer(\n', '    address _manager,\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    setManager(_manager);\n', '    setClaimer(_claimer);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Gets the store managing the specified app\n', '   * @param _appNickname The nickname of the app\n', '   */\n', '  function getStore(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns (address)\n', '  {\n', '    ManagerInterface theManager = ManagerInterface(manager);\n', '    return theManager.getStoreAddress(_appNickname);\n', '  }\n', '\n', '\n', '  // error codes\n', '\n', '  uint public allSet = 0;\n', '  uint public managerUnset = 10;\n', '  uint public claimerUnset = 20;\n', '  uint public wrongClaimerOrUnsetInManager = 30;\n', '  uint public wrongManagerOrUnsetInClaimer = 40;\n', '  uint public noStoresSet = 50;\n', '  uint public noStoreIsActive = 60;\n', '  uint public managerIsPaused = 70;\n', '  uint public managerNotSetInApp = 1000;\n', '\n', '  /**\n', '   * @dev Returns true if the registry looks ready\n', '   */\n', '  function isReady()\n', '  external\n', '  constant returns (uint)\n', '  {\n', '    if (manager == address(0)) {\n', '      return managerUnset;\n', '    }\n', '    if (claimer == address(0)) {\n', '      return claimerUnset;\n', '    }\n', '    ManagerInterface theManager = ManagerInterface(manager);\n', '    ClaimerInterface theClaimer = ClaimerInterface(claimer);\n', '    if (theManager.claimer() != claimer) {\n', '      return wrongClaimerOrUnsetInManager;\n', '    }\n', '    if (theClaimer.manager() != manager) {\n', '      return wrongManagerOrUnsetInClaimer;\n', '    }\n', '    uint totalStores = theManager.totalStores();\n', '    if (totalStores == 0) {\n', '      return noStoresSet;\n', '    }\n', '    bool atLeastOneIsActive;\n', '    for (uint i = 1; i <= totalStores; i++) {\n', '      StoreInterface theStore = StoreInterface(theManager.getStoreAddressById(i));\n', '      if (theManager.isStoreActive(i)) {\n', '        atLeastOneIsActive = true;\n', '      }\n', '      if (theManager.isStoreActive(i)) {\n', '        if (theStore.manager() != manager) {\n', '          return managerNotSetInApp + i;\n', '        }\n', '      }\n', '    }\n', '    if (atLeastOneIsActive == false) {\n', '      return noStoreIsActive;\n', '    }\n', '    if (theManager.paused() == true) {\n', '      return managerIsPaused;\n', '    }\n', '    return allSet;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\n', '\n', '/**\n', ' * @title Contracts that should not own Ether\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\n', ' * in the contract, it will allow the owner to reclaim this ether.\n', ' * @notice Ether can still be send to this contract by:\n', ' * calling functions labeled `payable`\n', ' * `selfdestruct(contract_address)`\n', ' * mining directly to the contract address\n', '*/\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() public payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '// File: contracts/TweedentityRegistry.sol\n', '\n', 'interface ManagerInterface {\n', '\n', '  function paused()\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function claimer()\n', '  public\n', '  constant returns (address);\n', '\n', '  function totalStores()\n', '  public\n', '  constant returns (uint);\n', '\n', '\n', '  function getStoreAddress(\n', '    string _appNickname\n', '  )\n', '  external\n', '  constant returns (address);\n', '\n', '\n', '  function getStoreAddressById(\n', '    uint _appId\n', '  )\n', '  external\n', '  constant returns (address);\n', '\n', '\n', '  function isStoreActive(\n', '    uint _appId\n', '  )\n', '  public\n', '  constant returns (bool);\n', '\n', '}\n', '\n', 'interface ClaimerInterface {\n', '\n', '  function manager()\n', '  public\n', '  constant returns (address);\n', '}\n', '\n', '\n', 'interface StoreInterface {\n', '\n', '  function appSet()\n', '  public\n', '  constant returns (bool);\n', '\n', '\n', '  function manager()\n', '  public\n', '  constant returns (address);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title TweedentityRegistry\n', ' * @author Francesco Sullo <francesco@sullo.co>\n', ' * @dev It store the tweedentities contracts addresses to allows dapp to be updated\n', ' */\n', '\n', '\n', 'contract TweedentityRegistry\n', 'is HasNoEther\n', '{\n', '\n', '  string public fromVersion = "1.0.0";\n', '\n', '  address public manager;\n', '  address public claimer;\n', '\n', '  event ContractRegistered(\n', '    bytes32 indexed key,\n', '    string spec,\n', '    address addr\n', '  );\n', '\n', '\n', '  function setManager(\n', '    address _manager\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_manager != address(0));\n', '    manager = _manager;\n', '    ContractRegistered(keccak256("manager"), "", _manager);\n', '  }\n', '\n', '\n', '  function setClaimer(\n', '    address _claimer\n', '  )\n', '  public\n', '  onlyOwner\n', '  {\n', '    require(_claimer != address(0));\n', '    claimer = _claimer;\n', '    ContractRegistered(keccak256("claimer"), "", _claimer);\n', '  }\n', '\n', '\n', '  function setManagerAndClaimer(\n', '    address _manager,\n', '    address _claimer\n', '  )\n', '  external\n', '  onlyOwner\n', '  {\n', '    setManager(_manager);\n', '    setClaimer(_claimer);\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Gets the store managing the specified app\n', '   * @param _appNickname The nickname of the app\n', '   */\n', '  function getStore(\n', '    string _appNickname\n', '  )\n', '  public\n', '  constant returns (address)\n', '  {\n', '    ManagerInterface theManager = ManagerInterface(manager);\n', '    return theManager.getStoreAddress(_appNickname);\n', '  }\n', '\n', '\n', '  // error codes\n', '\n', '  uint public allSet = 0;\n', '  uint public managerUnset = 10;\n', '  uint public claimerUnset = 20;\n', '  uint public wrongClaimerOrUnsetInManager = 30;\n', '  uint public wrongManagerOrUnsetInClaimer = 40;\n', '  uint public noStoresSet = 50;\n', '  uint public noStoreIsActive = 60;\n', '  uint public managerIsPaused = 70;\n', '  uint public managerNotSetInApp = 1000;\n', '\n', '  /**\n', '   * @dev Returns true if the registry looks ready\n', '   */\n', '  function isReady()\n', '  external\n', '  constant returns (uint)\n', '  {\n', '    if (manager == address(0)) {\n', '      return managerUnset;\n', '    }\n', '    if (claimer == address(0)) {\n', '      return claimerUnset;\n', '    }\n', '    ManagerInterface theManager = ManagerInterface(manager);\n', '    ClaimerInterface theClaimer = ClaimerInterface(claimer);\n', '    if (theManager.claimer() != claimer) {\n', '      return wrongClaimerOrUnsetInManager;\n', '    }\n', '    if (theClaimer.manager() != manager) {\n', '      return wrongManagerOrUnsetInClaimer;\n', '    }\n', '    uint totalStores = theManager.totalStores();\n', '    if (totalStores == 0) {\n', '      return noStoresSet;\n', '    }\n', '    bool atLeastOneIsActive;\n', '    for (uint i = 1; i <= totalStores; i++) {\n', '      StoreInterface theStore = StoreInterface(theManager.getStoreAddressById(i));\n', '      if (theManager.isStoreActive(i)) {\n', '        atLeastOneIsActive = true;\n', '      }\n', '      if (theManager.isStoreActive(i)) {\n', '        if (theStore.manager() != manager) {\n', '          return managerNotSetInApp + i;\n', '        }\n', '      }\n', '    }\n', '    if (atLeastOneIsActive == false) {\n', '      return noStoreIsActive;\n', '    }\n', '    if (theManager.paused() == true) {\n', '      return managerIsPaused;\n', '    }\n', '    return allSet;\n', '  }\n', '\n', '}']
