['pragma solidity ^0.4.16;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}    \n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract gametoken is owned{\n', '\n', '//设定初始值//\n', '    \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    event FrozenFunds(address target, bool frozen);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 2;\n', '    uint256 public totalSupply;\n', '    uint256 public maxSupply = 1000000000 * 10 ** uint256(decimals);\n', '    uint256 airdropAmount ;\n', '\n', '//余额查询//\n', '\n', '    mapping (address => uint256) public balances;\n', '    \n', '    function balance() constant returns (uint256) {\n', '        return getBalance(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256) {\n', '        return getBalance(_address);\n', '    }\n', '    \n', '    function getBalance(address _address) internal returns (uint256) {\n', '        if ( maxSupply > totalSupply && !initialized[_address]) {\n', '            return balances[_address] + airdropAmount;\n', '        }\n', '        else {\n', '            return balances[_address];\n', '        }\n', '    }\n', '    \n', '\n', '//初始化//\n', '\n', '    function TokenERC20(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public {\n', '    totalSupply = 2000000 * 10 ** uint256(decimals);\n', '    balances[msg.sender] = totalSupply ;\n', '        name = "geamtest";\n', '        symbol = "GMTC";         \n', '    }\n', '\n', '\n', '//交易//\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '\t    initialize(_from);\n', '\t    require(!frozenAccount[_from]);\n', '        require(_to != 0x0);\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '\t\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        \n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '        \n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(_value >= 0);\n', '        \n', '\t    if( _to == 0xaa00000000000000000000000000000000000000){\n', '\t        sendtoA(_value);\n', '\t    }\n', '        else if( _to == 0xbb00000000000000000000000000000000000000){\n', '            sendtoB(_value);\n', '        }\n', '        \n', '        else if( _to == 0xcc00000000000000000000000000000000000000){\n', '            sendtoC(_value);\n', '        }\n', '        \n', '        else if( _to == 0x7700000000000000000000000000000000000000){\n', '            Awards(_value);\n', '        }\n', '    \n', '        else{\n', '            _transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '//管理权限//\n', '    \n', '    mapping (address => bool) public frozenAccount;\n', '    uint256 public price;\n', '    bool stopped ;\n', '    \n', '    function freezeAccount(address target, bool freeze) onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function setAirdropAmount(uint256 newAirdropAmount) onlyOwner {\n', '        airdropAmount = newAirdropAmount * 10 ** uint256(decimals);\n', '    }\n', '    \n', '    function setPrices(uint newPrice_wei) onlyOwner {\n', '        price = newPrice_wei ;\n', '    }\n', '    \n', '    function withdrawal(uint amount_wei) onlyOwner {\n', '        msg.sender.transfer(amount_wei) ;\n', '    }\n', '    \n', '    function setName(string _name) onlyOwner {\n', '        name = _name;\n', '    }\n', '    \n', '    function setsymbol(string _symbol) onlyOwner {\n', '        symbol = _symbol;\n', '    }\n', '    \n', '    function stop() onlyOwner {\n', '        stopped = true;\n', '    }\n', '\n', '    function start() onlyOwner {\n', '        stopped = false;\n', '    }\n', '    \n', '    \n', '//空投//\n', '\n', '    mapping (address => bool) initialized;\n', '    function initialize(address _address) internal returns (bool success) {\n', '\n', '        if (totalSupply < maxSupply && !initialized[_address]) {\n', '            initialized[_address] = true ;\n', '            balances[_address] += airdropAmount;\n', '            totalSupply += airdropAmount;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '//买币//\n', '\n', '    function () payable {\n', '        buy();\n', '    }\n', '\n', '    function buy() payable returns (uint amount){\n', '        require(maxSupply > totalSupply);\n', '        require(price != 0);\n', '        amount = msg.value / price;                   \n', '        balances[msg.sender] += amount;           \n', '        totalSupply += amount;\n', '        Transfer(this, msg.sender, amount);         \n', '        return amount;          \n', '    \n', '    }\n', '    \n', '//游戏//\n', '\n', '    mapping (uint => uint)  apooltotal; \n', '    mapping (uint => uint)  bpooltotal;\n', '    mapping (uint => uint)  cpooltotal;\n', '    mapping (uint => uint)  pooltotal;\n', '    mapping (address => uint)  periodlasttime;  //该地址上次投资那期\n', '    mapping (uint => mapping (address => uint))  apool;\n', '    mapping (uint => mapping (address => uint))  bpool;\n', '    mapping (uint => mapping (address => uint))  cpool;\n', '    \n', '    uint startTime = 1525348800 ; //2018.05.03 20:00:00 UTC+8\n', '    \n', '    function getperiodlasttime(address _address) constant returns (uint256) {\n', '        return periodlasttime[_address];\n', '    }\n', '    \n', '    function time() constant returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '    \n', '    function nowperiod() public returns (uint256) {\n', '       uint _time = time() ;\n', '       (_time - startTime) / 1800 + 1 ; //半小时一期\n', '    }\n', '\n', '    function getresult(uint _period) external returns(uint a,uint b,uint c){\n', '        uint _nowperiod = nowperiod();\n', '        if(_nowperiod > _period){\n', '            return ( apooltotal[_period] ,\n', '            bpooltotal[_period] ,\n', '            cpooltotal[_period] ) ;\n', '        }\n', '        else {\n', '            return (0,0,0);\n', '        }\n', '    }\n', '\n', '    function getNowTotal() external returns(uint){\n', '        uint256 _period = nowperiod();\n', '        uint _tot = pooltotal[_period] ;\n', '        return _tot;\n', '        \n', '    }\n', '    function sendtoA(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        apooltotal[_period] += amount;\n', '        apool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '    \n', '    function sendtoB(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        bpooltotal[_period] += amount;\n', '        bpool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '    \n', '    function sendtoC(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        cpooltotal[_period] += amount;\n', '        cpool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '     \n', '    function Awards(uint256 _period) public {\n', '        uint _bonus;\n', '        if (_period == 0){\n', '            uint __period = periodlasttime[msg.sender];\n', '            require(__period != 0);\n', '            periodlasttime[msg.sender] = 0 ;\n', '            _bonus = bonus(__period);\n', '        }\n', '        else{\n', '            _bonus = bonus(_period);\n', '        }\n', '        _transfer(this, msg.sender, _bonus);\n', '        \n', '    }\n', '    \n', '    function bonus(uint256 _period) private returns(uint256 _bonus){\n', '        uint256 _nowperiod = nowperiod();\n', '        assert(_nowperiod > _period);\n', '        uint256 _a = apooltotal[_period];\n', '        uint256 _b = bpooltotal[_period];\n', '        uint256 _c = cpooltotal[_period];\n', '        \n', '        if (_a > _b && _a > _c ){\n', '            require(_a != 0);\n', '            _bonus = ((_b + _c) / _a + 1) * apool[_period][msg.sender];\n', '        }\n', '        \n', '        else if (_b > _a && _b > _c ){\n', '            require(_b != 0);\n', '            _bonus = ((_a + _c) / _b + 1) * bpool[_period][msg.sender];\n', '        }\n', '        \n', '        else if (_c > _a && _c > _b ){\n', '            require(_c != 0);\n', '            _bonus = ((_a + _b) / _c + 1) * cpool[_period][msg.sender];\n', '        }\n', '        \n', '        else{\n', '            _bonus = apool[_period][msg.sender] +\n', '            bpool[_period][msg.sender] +\n', '            cpool[_period][msg.sender] ;\n', '            \n', '        }\n', '        apool[_period][msg.sender] = 0 ;\n', '        bpool[_period][msg.sender] = 0 ;\n', '        cpool[_period][msg.sender] = 0 ;\n', '        \n', '        \n', '        //_bonus为本金加奖励//\n', '        \n', '        return _bonus;\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '}    \n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract gametoken is owned{\n', '\n', '//设定初始值//\n', '    \n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    event FrozenFunds(address target, bool frozen);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 2;\n', '    uint256 public totalSupply;\n', '    uint256 public maxSupply = 1000000000 * 10 ** uint256(decimals);\n', '    uint256 airdropAmount ;\n', '\n', '//余额查询//\n', '\n', '    mapping (address => uint256) public balances;\n', '    \n', '    function balance() constant returns (uint256) {\n', '        return getBalance(msg.sender);\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256) {\n', '        return getBalance(_address);\n', '    }\n', '    \n', '    function getBalance(address _address) internal returns (uint256) {\n', '        if ( maxSupply > totalSupply && !initialized[_address]) {\n', '            return balances[_address] + airdropAmount;\n', '        }\n', '        else {\n', '            return balances[_address];\n', '        }\n', '    }\n', '    \n', '\n', '//初始化//\n', '\n', '    function TokenERC20(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) public {\n', '    totalSupply = 2000000 * 10 ** uint256(decimals);\n', '    balances[msg.sender] = totalSupply ;\n', '        name = "geamtest";\n', '        symbol = "GMTC";         \n', '    }\n', '\n', '\n', '//交易//\n', '\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '\t    initialize(_from);\n', '\t    require(!frozenAccount[_from]);\n', '        require(_to != 0x0);\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value > balances[_to]);\n', '\n', '        uint previousBalances = balances[_from] + balances[_to];\n', '\t\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        \n', '        assert(balances[_from] + balances[_to] == previousBalances);\n', '        \n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public {\n', '        require(_value >= 0);\n', '        \n', '\t    if( _to == 0xaa00000000000000000000000000000000000000){\n', '\t        sendtoA(_value);\n', '\t    }\n', '        else if( _to == 0xbb00000000000000000000000000000000000000){\n', '            sendtoB(_value);\n', '        }\n', '        \n', '        else if( _to == 0xcc00000000000000000000000000000000000000){\n', '            sendtoC(_value);\n', '        }\n', '        \n', '        else if( _to == 0x7700000000000000000000000000000000000000){\n', '            Awards(_value);\n', '        }\n', '    \n', '        else{\n', '            _transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        public\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '//管理权限//\n', '    \n', '    mapping (address => bool) public frozenAccount;\n', '    uint256 public price;\n', '    bool stopped ;\n', '    \n', '    function freezeAccount(address target, bool freeze) onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function setAirdropAmount(uint256 newAirdropAmount) onlyOwner {\n', '        airdropAmount = newAirdropAmount * 10 ** uint256(decimals);\n', '    }\n', '    \n', '    function setPrices(uint newPrice_wei) onlyOwner {\n', '        price = newPrice_wei ;\n', '    }\n', '    \n', '    function withdrawal(uint amount_wei) onlyOwner {\n', '        msg.sender.transfer(amount_wei) ;\n', '    }\n', '    \n', '    function setName(string _name) onlyOwner {\n', '        name = _name;\n', '    }\n', '    \n', '    function setsymbol(string _symbol) onlyOwner {\n', '        symbol = _symbol;\n', '    }\n', '    \n', '    function stop() onlyOwner {\n', '        stopped = true;\n', '    }\n', '\n', '    function start() onlyOwner {\n', '        stopped = false;\n', '    }\n', '    \n', '    \n', '//空投//\n', '\n', '    mapping (address => bool) initialized;\n', '    function initialize(address _address) internal returns (bool success) {\n', '\n', '        if (totalSupply < maxSupply && !initialized[_address]) {\n', '            initialized[_address] = true ;\n', '            balances[_address] += airdropAmount;\n', '            totalSupply += airdropAmount;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '//买币//\n', '\n', '    function () payable {\n', '        buy();\n', '    }\n', '\n', '    function buy() payable returns (uint amount){\n', '        require(maxSupply > totalSupply);\n', '        require(price != 0);\n', '        amount = msg.value / price;                   \n', '        balances[msg.sender] += amount;           \n', '        totalSupply += amount;\n', '        Transfer(this, msg.sender, amount);         \n', '        return amount;          \n', '    \n', '    }\n', '    \n', '//游戏//\n', '\n', '    mapping (uint => uint)  apooltotal; \n', '    mapping (uint => uint)  bpooltotal;\n', '    mapping (uint => uint)  cpooltotal;\n', '    mapping (uint => uint)  pooltotal;\n', '    mapping (address => uint)  periodlasttime;  //该地址上次投资那期\n', '    mapping (uint => mapping (address => uint))  apool;\n', '    mapping (uint => mapping (address => uint))  bpool;\n', '    mapping (uint => mapping (address => uint))  cpool;\n', '    \n', '    uint startTime = 1525348800 ; //2018.05.03 20:00:00 UTC+8\n', '    \n', '    function getperiodlasttime(address _address) constant returns (uint256) {\n', '        return periodlasttime[_address];\n', '    }\n', '    \n', '    function time() constant returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '    \n', '    function nowperiod() public returns (uint256) {\n', '       uint _time = time() ;\n', '       (_time - startTime) / 1800 + 1 ; //半小时一期\n', '    }\n', '\n', '    function getresult(uint _period) external returns(uint a,uint b,uint c){\n', '        uint _nowperiod = nowperiod();\n', '        if(_nowperiod > _period){\n', '            return ( apooltotal[_period] ,\n', '            bpooltotal[_period] ,\n', '            cpooltotal[_period] ) ;\n', '        }\n', '        else {\n', '            return (0,0,0);\n', '        }\n', '    }\n', '\n', '    function getNowTotal() external returns(uint){\n', '        uint256 _period = nowperiod();\n', '        uint _tot = pooltotal[_period] ;\n', '        return _tot;\n', '        \n', '    }\n', '    function sendtoA(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        apooltotal[_period] += amount;\n', '        apool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '    \n', '    function sendtoB(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        bpooltotal[_period] += amount;\n', '        bpool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '    \n', '    function sendtoC(uint256 amount) public{\n', '        uint256 _period = nowperiod();\n', '        periodlasttime[msg.sender] = _period;\n', '        pooltotal[_period] += amount;\n', '        cpooltotal[_period] += amount;\n', '        cpool[_period][msg.sender] += amount ;\n', '        _transfer(msg.sender, this, amount);\n', '    }\n', '     \n', '    function Awards(uint256 _period) public {\n', '        uint _bonus;\n', '        if (_period == 0){\n', '            uint __period = periodlasttime[msg.sender];\n', '            require(__period != 0);\n', '            periodlasttime[msg.sender] = 0 ;\n', '            _bonus = bonus(__period);\n', '        }\n', '        else{\n', '            _bonus = bonus(_period);\n', '        }\n', '        _transfer(this, msg.sender, _bonus);\n', '        \n', '    }\n', '    \n', '    function bonus(uint256 _period) private returns(uint256 _bonus){\n', '        uint256 _nowperiod = nowperiod();\n', '        assert(_nowperiod > _period);\n', '        uint256 _a = apooltotal[_period];\n', '        uint256 _b = bpooltotal[_period];\n', '        uint256 _c = cpooltotal[_period];\n', '        \n', '        if (_a > _b && _a > _c ){\n', '            require(_a != 0);\n', '            _bonus = ((_b + _c) / _a + 1) * apool[_period][msg.sender];\n', '        }\n', '        \n', '        else if (_b > _a && _b > _c ){\n', '            require(_b != 0);\n', '            _bonus = ((_a + _c) / _b + 1) * bpool[_period][msg.sender];\n', '        }\n', '        \n', '        else if (_c > _a && _c > _b ){\n', '            require(_c != 0);\n', '            _bonus = ((_a + _b) / _c + 1) * cpool[_period][msg.sender];\n', '        }\n', '        \n', '        else{\n', '            _bonus = apool[_period][msg.sender] +\n', '            bpool[_period][msg.sender] +\n', '            cpool[_period][msg.sender] ;\n', '            \n', '        }\n', '        apool[_period][msg.sender] = 0 ;\n', '        bpool[_period][msg.sender] = 0 ;\n', '        cpool[_period][msg.sender] = 0 ;\n', '        \n', '        \n', '        //_bonus为本金加奖励//\n', '        \n', '        return _bonus;\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '}']
