['pragma solidity ^0.4.18;\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract ERC20Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view  returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns  (bool );\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', 'contract HHLCTOKEN is ERC20Token {\n', '    using SafeMath for uint256;\n', '\n', '    address public manager;\n', '    modifier onlyManager() {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '    \n', '    mapping(address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256 )) allowed;\n', '\n', '    uint256 exchangeTimestamp;\n', '\n', '    uint256[] public privateTimes;\n', '    uint256[] public airdropTimes;\n', '\n', '    uint256[] public privateRates=[50,60,70,80,90,100];\n', '    uint256[] public airdropRates=[5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100];\n', '\n', '    struct LockRuler {\n', '        uint256 utype;\n', '        uint256 money;\n', '    }\n', '\n', '    mapping (address => LockRuler[]) public  mapLockRulers;\n', '\n', '    function transfer( address _to, uint256 _value )\n', '    public \n', '    returns (bool success)\n', '    {\n', '\n', '        if( mapLockRulers[msg.sender].length > 0 ){\n', '\n', '            require (exchangeTimestamp > 0);\n', '\n', '            uint256 _lockMoney = 0;\n', '            uint256 _preMoney = 0;\n', '            uint256 _idx = 0;\n', '            uint256 _idx2 = 0;\n', '            uint256 _rate = 0;\n', '            uint256 _hundred = 100;\n', '            uint256 _var1 = 0;\n', '            uint256 _var2 = 0;\n', '            uint256 _var3 = 0;\n', '\n', '            for( _idx = 0; _idx < mapLockRulers[msg.sender].length; _idx++ ){\n', '\n', '\n', '                if( mapLockRulers[msg.sender][_idx].utype == 0){\n', '\n', '                    for( _idx2 = 0; _idx2 < privateTimes.length -1; _idx2++ ){\n', '\n', '                        if(privateTimes[_idx2]<=block.timestamp && block.timestamp < privateTimes[_idx2+1]){\n', '                            _rate = privateRates[_idx2];\n', '\n', '                            _var1 = _hundred.sub(_rate);\n', '                            _var2 = _var1.mul(mapLockRulers[msg.sender][_idx].money);\n', '                            _var3 = _var2.div(_hundred);\n', '\n', '                            _lockMoney = _lockMoney.add(_var3 );\n', '                            break;\n', '\n', '                        }else if( block.timestamp > privateTimes[privateTimes.length -1] ){\n', '\n', '                            _lockMoney = _lockMoney.add(0);\n', '                            break;\n', '\n', '                        }else if(block.timestamp<privateTimes[0]){\n', '\n', '                            _lockMoney = _lockMoney.add(mapLockRulers[msg.sender][_idx].money);\n', '                            break;\n', '\n', '                        }\n', '                    }\n', '\n', '                }\n', '\n', '                if(mapLockRulers[msg.sender][_idx].utype == 1){\n', '\n', '                    for( _idx2 = 0; _idx2 < airdropTimes.length -1; _idx2++ ){\n', '\n', '                        if(airdropTimes[_idx2] <= block.timestamp && block.timestamp <= airdropTimes[_idx2+1]){\n', '                            _rate = airdropRates[_idx2];\n', '\n', '                            _var1 = _hundred.sub(_rate);\n', '                            _var2 = _var1.mul(mapLockRulers[msg.sender][_idx].money);\n', '                            _var3 = _var2.div(_hundred);\n', '\n', '                            _lockMoney = _lockMoney.add(_var3 );\n', '                            break;\n', '\n', '                        }else if( block.timestamp > airdropTimes[airdropTimes.length -1] ){\n', '\n', '                            _lockMoney = _lockMoney.add(0);\n', '                            break;\n', '\n', '                        }else if(block.timestamp < airdropTimes[0]){\n', '\n', '                            _lockMoney = _lockMoney.add(mapLockRulers[msg.sender][_idx].money);\n', '                            break;\n', '\n', '                        }\n', '\n', '                    }\n', '\n', '                }\n', '            }\n', '\n', '            _preMoney = _value.add(_lockMoney);\n', '\n', '            require ( _preMoney <= balances[msg.sender] );\n', '            return _transfer(_to, _value);\n', '\n', '        }else{\n', '\n', '            return _transfer(_to, _value);\n', '\n', '        }\n', '    }\n', '\n', '    function _transfer(address _to, uint256 _value)\n', '    internal returns (bool success){\n', '\n', '        require(_to != 0x0);\n', '        require(_value > 0);\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        uint256 previousBalances = balances[msg.sender] + balances[_to];\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        assert(balances[msg.sender] + balances[_to] == previousBalances);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '    public\n', '    view\n', '    returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender)\n', '    public\n', '    view\n', '    returns (uint256){\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    event NewToken(uint256 indexed _decimals, uint256  _totalSupply, string  _tokenName, string  _tokenSymbol);\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public decimals;\n', '\n', '\n', '    constructor(\n', '        uint256 _initialAmount,\n', '        uint256 _decimals,\n', '        string _tokenName,\n', '        string _tokenSymbol\n', '    )public{\n', '\n', '        require (_decimals > 0);\n', '        require (_initialAmount > 0);\n', '        require (bytes(_tokenName).length>0);\n', '        require (bytes(_tokenSymbol).length>0);\n', '\n', '        manager = msg.sender;\n', '\n', '        decimals = _decimals;\n', '        totalSupply = _initialAmount * (10 ** uint256(decimals));\n', '        balances[manager] = totalSupply;\n', '        name = _tokenName;\n', '        symbol = _tokenSymbol;\n', '\n', '\n', '        exchangeTimestamp = 0;\n', '\n', '\n', '        emit NewToken(_decimals, totalSupply, name, symbol);\n', '    }\n', '\n', '\n', '    function addAirdropUsers( address[] _accounts, uint256[] _moneys )\n', '    onlyManager\n', '    public{\n', '\n', '        require (_accounts.length > 0);\n', '        require (_accounts.length == _moneys.length);\n', '\n', '        uint256 _totalMoney = 0;\n', '        uint256 _idx = 0;\n', '\n', '        for(_idx = 0; _idx < _moneys.length; _idx++){\n', '            _totalMoney += _moneys[_idx];\n', '        }\n', '\n', '        require ( _totalMoney <= balances[manager] );\n', '\n', '\n', '        for( _idx = 0; _idx < _accounts.length; _idx++ ){\n', '\n', '            LockRuler memory _lockRuler = LockRuler({\n', '                money:_moneys[_idx],\n', '                utype:1\n', '            });\n', '\n', '            mapLockRulers[_accounts[_idx]].push(_lockRuler);\n', '            _transfer(_accounts[_idx], _moneys[_idx]);\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function addPrivateUsers( address[] _accounts, uint256[] _moneys )\n', '    onlyManager\n', '    public{\n', '\n', '        require (_accounts.length > 0);\n', '        require (_accounts.length == _moneys.length);\n', '\n', '        uint256 _totalMoney = 0;\n', '        uint256 _idx = 0;\n', '\n', '        for(_idx = 0; _idx < _moneys.length; _idx++){\n', '            _totalMoney = _totalMoney.add(_moneys[_idx]) ;\n', '        }\n', '\n', '        require ( _totalMoney <= balances[manager] );\n', '\n', '\n', '        for( _idx = 0; _idx < _accounts.length; _idx++ ){\n', '\n', '            LockRuler memory _lockRuler = LockRuler({\n', '                money:_moneys[_idx],\n', '                utype:0\n', '            });\n', '\n', '            mapLockRulers[_accounts[_idx]].push(_lockRuler);\n', '            _transfer(_accounts[_idx], _moneys[_idx]);\n', '\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function addExchangeTime( uint256 _time )\n', '    onlyManager\n', '    public{\n', '        require (_time > 0);\n', '        require (privateTimes.length == 0);\n', '        require (airdropTimes.length == 0);\n', '\n', '\n', '        exchangeTimestamp = _time;\n', '\n', '        uint256 _idx = 0;\n', '        for(_idx = 0; _idx < privateRates.length; _idx++){\n', '            privateTimes.push( _getDate(_time, _idx) );\n', '        }\n', '\n', '\n', '\n', '        for(_idx = 0; _idx < airdropRates.length; _idx++){\n', '            airdropTimes.push( _getDate(_time, _idx) );\n', '        }\n', '\n', '    }\n', '\n', '    function _getDate(uint256 start, uint256 daysAfter)\n', '    internal\n', '    pure\n', '    returns (uint256){\n', '        daysAfter = daysAfter.mul(60);\n', '        return start + daysAfter * 1 days;\n', '    }  \n', '}']