['pragma solidity ^0.4.24;\n', '\n', '/**\n', '*\n', '*  https://fundingsecured.me/fair/\n', '*\n', '*\n', '*  ________ ________  ___  ________\n', '* |\\  _____\\\\   __  \\|\\  \\|\\   __  \\\n', '* \\ \\  \\__/\\ \\  \\|\\  \\ \\  \\ \\  \\|\\  \\\n', '*  \\ \\   __\\\\ \\   __  \\ \\  \\ \\   _  _\\\n', '*   \\ \\  \\_| \\ \\  \\ \\  \\ \\  \\ \\  \\\\  \\|\n', '*    \\ \\__\\   \\ \\__\\ \\__\\ \\__\\ \\__\\\\ _\\\n', '*     \\|__|    \\|__|\\|__|\\|__|\\|__|\\|__|\n', '*  ________ ___  ___  ________   ________  ________\n', '* |\\  _____\\\\  \\|\\  \\|\\   ___  \\|\\   ___ \\|\\   ____\\\n', '* \\ \\  \\__/\\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\_|\\ \\ \\  \\___|_\n', '*  \\ \\   __\\\\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\ \\\\ \\ \\_____  \\\n', '*   \\ \\  \\_| \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\_\\\\ \\|____|\\  \\\n', '*    \\ \\__\\   \\ \\_______\\ \\__\\\\ \\__\\ \\_______\\____\\_\\  \\\n', '*     \\|__|    \\|_______|\\|__| \\|__|\\|_______|\\_________\\\n', '*                                            \\|_________|\n', '*\n', '*  https://fundingsecured.me/fair/\n', '*\n', '*\n', '* Warning:\n', '*\n', '* FAIR FUNDS is a game system built on FUNDING SECURED, using infinite loops of token redistribution through open source smart contract codes and pre-defined rules.\n', '* This system is for internal use only and all could be lost by sending anything to this contract address.\n', '* No one can change anything once the contract has been deployed.\n', '* Built in Antiwhale for initial stages for a fairer system.\n', '*\n', '* Official Website: https://fundingsecured.me/\n', '* Official Exchange: https://fundingsecured.me/exchange\n', '* Official Discord: https://discordapp.com/invite/3FrBqBa\n', '* Official Twitter: https://twitter.com/FundingSecured_\n', '* Official Telegram: https://t.me/fundingsecured\n', ' *\n', '**/\n', '\n', '\n', 'contract FAIRFUNDS {\n', '    using SafeMath for uint256;\n', '\n', '    /*------------------------------\n', '                CONFIGURABLES\n', '     ------------------------------*/\n', '    string public name = "FAIRFUNDS";    // Contract name\n', '    string public symbol = "FAIRFUNDS";\n', '\n', '    uint256 public initAmount;          // Initial stage target\n', '    uint256 public amountProportion;    // Stage target growth rate %\n', '    uint256 public dividend;            // Input to Dividend %\n', '    uint256 public jackpot;             // Input to Jackpot %\n', '    uint256 public jackpotProportion;   // Jackpot payout %\n', '    uint256 public fundsTokenDividend;  // Dividend fee % to FUNDS token holders\n', '    uint256 public promotionRatio;      // Promotion %\n', '    uint256 public duration;            // Duration per stage\n', '    bool public activated = false;\n', '\n', '    address public developerAddr;\n', '    address public fundsDividendAddr;\n', '\n', '    /*------------------------------\n', '                DATASETS\n', '     ------------------------------*/\n', '    uint256 public rId;   // Current round id number\n', '    uint256 public sId;   // Current stage id number\n', '\n', '    mapping (uint256 => Indatasets.Round) public round; // (rId => data) round data by round id\n', '    mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage;    // (rId => sId => data) stage data by round id & stage id\n', '    mapping (address => Indatasets.Player) public player;   // (address => data) player data\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; // (rId => address => playerRoundAmount) round data by round id\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundSid;\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag;\n', '    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount;    // (rId => sId => address => playerStageAmount) round data by round id & stage id\n', '    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount;\n', '\n', '    //Antiwhale setting, max 5% of stage target for the first 10 stages per address\n', '    uint256[] amountLimit = [0, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250];\n', '\n', '    /*------------------------------\n', '                PUBLIC FUNCTIONS\n', '    ------------------------------*/\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        developerAddr = msg.sender;\n', '        fundsDividendAddr = 0xd529ADaE263048f495A05B858c8E7C077F047813;\n', '    }\n', '\n', '    /*------------------------------\n', '                MODIFIERS\n', '     ------------------------------*/\n', '\n', '    modifier isActivated() {\n', '        require(activated == true, "its not ready yet.  check ?eta in discord");\n', '        _;\n', '    }\n', '\n', '    modifier senderVerify() {\n', '        require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    modifier stageVerify(uint256 _rId, uint256 _sId, uint256 _amount) {\n', '        require(stage[_rId][_sId].amount.add(_amount) <= stage[_rId][_sId].targetAmount);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Don&#39;t toy or spam the contract.\n', '     */\n', '    modifier amountVerify() {\n', '        require(msg.value >= 100000000000000);\n', '        _;\n', '    }\n', '\n', '    modifier playerVerify() {\n', '        require(player[msg.sender].active == true);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Activation of contract with settings\n', '     */\n', '    function activate()\n', '        public\n', '    {\n', '        require(msg.sender == developerAddr);\n', '        require(activated == false, "FUNDS already activated");\n', '\n', '        activated = true;\n', '        initAmount = 10000000000000000000;\n', '        amountProportion = 10;\n', '        dividend = 70;\n', '        jackpot = 20;\n', '        jackpotProportion = 70;\n', '        fundsTokenDividend = 10;\n', '        promotionRatio = 10;\n', '        duration = 15600;\n', '        rId = 1;\n', '        sId = 1;\n', '\n', '        round[rId].start = now;\n', '        initStage(rId, sId);\n', '\n', '    }\n', '\n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function()\n', '        isActivated()\n', '        senderVerify()\n', '        amountVerify()\n', '        payable\n', '        public\n', '    {\n', '        buyAnalysis(0x0);\n', '    }\n', '\n', '    /**\n', '     * Standard buy function.\n', '     */\n', '    function buy(address _recommendAddr)\n', '        isActivated()\n', '        senderVerify()\n', '        amountVerify()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        buyAnalysis(_recommendAddr);\n', '    }\n', '\n', '    /**\n', '     * Withdraw function.\n', '     * Withdraw 50 stages at once on current settings.\n', '     * May require to request withdraw more than once to withdraw everything.\n', '     */\n', '    function withdraw()\n', '        isActivated()\n', '        senderVerify()\n', '        playerVerify()\n', '        public\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount;\n', '        uint256 _playerWithdrawAmountFlag;\n', '\n', '        (_amount, player[msg.sender].withdrawRid, player[msg.sender].withdrawSid, _playerWithdrawAmountFlag) = getPlayerDividendByStage(_rId, _sId, msg.sender);\n', '\n', '        if(_playerWithdrawAmountFlag > 0)\n', '            playerRoundwithdrawAmountFlag[player[msg.sender].withdrawRid][msg.sender] = _playerWithdrawAmountFlag;\n', '\n', '        if(player[msg.sender].promotionAmount > 0 ){\n', '            _amount = _amount.add(player[msg.sender].promotionAmount);\n', '            player[msg.sender].promotionAmount = 0;\n', '        }\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '\n', '    /**\n', '     * Core logic to analyse buy behaviour.\n', '     */\n', '    function buyAnalysis(address _recommendAddr)\n', '        private\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount = msg.value;\n', '        uint256 _promotionRatio = promotionRatio;\n', '\n', '        if(now > stage[_rId][_sId].end && stage[_rId][_sId].targetAmount > stage[_rId][_sId].amount){\n', '\n', '            endRound(_rId, _sId);\n', '\n', '            _rId = rId;\n', '            _sId = sId;\n', '            round[_rId].start = now;\n', '            initStage(_rId, _sId);\n', '\n', '            _amount = limitAmount(_rId, _sId);\n', '            buyRoundDataRecord(_rId, _amount);\n', '            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\n', '            buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\n', '            buyPlayerDataRecord(_rId, _sId, _amount);\n', '\n', '        }else if(now <= stage[_rId][_sId].end){\n', '\n', '            _amount = limitAmount(_rId, _sId);\n', '            buyRoundDataRecord(_rId, _amount);\n', '            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\n', '\n', '            if(stage[_rId][_sId].amount.add(_amount) >= stage[_rId][_sId].targetAmount){\n', '\n', '                uint256 differenceAmount = (stage[_rId][_sId].targetAmount).sub(stage[_rId][_sId].amount);\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, differenceAmount);\n', '                buyPlayerDataRecord(_rId, _sId, differenceAmount);\n', '\n', '                endStage(_rId, _sId);\n', '\n', '                _sId = sId;\n', '                initStage(_rId, _sId);\n', '                round[_rId].endSid = _sId;\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount.sub(differenceAmount));\n', '                buyPlayerDataRecord(_rId, _sId, _amount.sub(differenceAmount));\n', '\n', '            }else{\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\n', '                buyPlayerDataRecord(_rId, _sId, _amount);\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Sets the initial stage parameter.\n', '     */\n', '    function initStage(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        uint256 _targetAmount;\n', '        stage[_rId][_sId].start = now;\n', '        stage[_rId][_sId].end = now.add(duration);\n', '        if(_sId > 1){\n', '            stage[_rId][_sId - 1].end = now;\n', '            stage[_rId][_sId - 1].ended = true;\n', '            _targetAmount = (stage[_rId][_sId - 1].targetAmount.mul(amountProportion + 100)) / 100;\n', '        }else\n', '            _targetAmount = initAmount;\n', '\n', '        stage[_rId][_sId].targetAmount = _targetAmount;\n', '\n', '    }\n', '\n', '    /**\n', '     * Execution of antiwhale.\n', '     */\n', '    function limitAmount(uint256 _rId, uint256 _sId)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = msg.value;\n', '\n', '        if(amountLimit.length > _sId)\n', '            _amount = ((stage[_rId][_sId].targetAmount.mul(amountLimit[_sId])) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\n', '        else\n', '            _amount = ((stage[_rId][_sId].targetAmount.mul(500)) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\n', '\n', '        if(_amount >= msg.value)\n', '            return msg.value;\n', '        else\n', '            msg.sender.transfer(msg.value.sub(_amount));\n', '\n', '        return _amount;\n', '    }\n', '\n', '    /**\n', '     * Record the addresses eligible for promotion links.\n', '     */\n', '    function promotionDataRecord(address _recommendAddr, uint256 _amount)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _promotionRatio = promotionRatio;\n', '\n', '        if(_recommendAddr != 0x0000000000000000000000000000000000000000\n', '            && _recommendAddr != msg.sender\n', '            && player[_recommendAddr].active == true\n', '        )\n', '            player[_recommendAddr].promotionAmount = player[_recommendAddr].promotionAmount.add((_amount.mul(_promotionRatio)) / 100);\n', '        else\n', '            _promotionRatio = 0;\n', '\n', '        return _promotionRatio;\n', '    }\n', '\n', '\n', '    /**\n', '     * Records the round data.\n', '     */\n', '    function buyRoundDataRecord(uint256 _rId, uint256 _amount)\n', '        private\n', '    {\n', '\n', '        round[_rId].amount = round[_rId].amount.add(_amount);\n', '        fundsDividendAddr.transfer(_amount.mul(fundsTokenDividend) / 100);\n', '    }\n', '\n', '    /**\n', '     * Records the stage data.\n', '     */\n', '    function buyStageDataRecord(uint256 _rId, uint256 _sId, uint256 _promotionRatio, uint256 _amount)\n', '        stageVerify(_rId, _sId, _amount)\n', '        private\n', '    {\n', '        if(_amount <= 0)\n', '            return;\n', '        stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\n', '        stage[_rId][_sId].dividendAmount = stage[_rId][_sId].dividendAmount.add((_amount.mul(dividend.sub(_promotionRatio))) / 100);\n', '    }\n', '\n', '    /**\n', '     * Records the player data.\n', '     */\n', '    function buyPlayerDataRecord(uint256 _rId, uint256 _sId, uint256 _amount)\n', '        private\n', '    {\n', '        if(_amount <= 0)\n', '            return;\n', '\n', '        if(player[msg.sender].active == false){\n', '            player[msg.sender].active = true;\n', '            player[msg.sender].withdrawRid = _rId;\n', '            player[msg.sender].withdrawSid = _sId;\n', '        }\n', '\n', '        if(playerRoundAmount[_rId][msg.sender] == 0){\n', '            round[_rId].players++;\n', '            playerRoundSid[_rId][msg.sender] = _sId;\n', '        }\n', '\n', '        if(playerStageAmount[_rId][_sId][msg.sender] == 0)\n', '            stage[_rId][_sId].players++;\n', '\n', '        playerRoundAmount[_rId][msg.sender] = playerRoundAmount[_rId][msg.sender].add(_amount);\n', '        playerStageAmount[_rId][_sId][msg.sender] = playerStageAmount[_rId][_sId][msg.sender].add(_amount);\n', '\n', '        player[msg.sender].amount = player[msg.sender].amount.add(_amount);\n', '\n', '        if(playerRoundSid[_rId][msg.sender] > 0){\n', '\n', '            if(playerStageAccAmount[_rId][_sId][msg.sender] == 0){\n', '\n', '                for(uint256 i = playerRoundSid[_rId][msg.sender]; i < _sId; i++){\n', '\n', '                    if(playerStageAmount[_rId][i][msg.sender] > 0)\n', '                        playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(playerStageAmount[_rId][i][msg.sender]);\n', '\n', '                }\n', '            }\n', '\n', '            playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Execute end of round events.\n', '     */\n', '    function endRound(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        round[_rId].end = now;\n', '        round[_rId].ended = true;\n', '        round[_rId].endSid = _sId;\n', '        stage[_rId][_sId].end = now;\n', '        stage[_rId][_sId].ended = true;\n', '\n', '        if(stage[_rId][_sId].players == 0)\n', '            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount);\n', '        else\n', '            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount.mul(100 - jackpotProportion) / 100);\n', '\n', '        rId++;\n', '        sId = 1;\n', '\n', '    }\n', '\n', '    /**\n', '     * Execute end of stage events.\n', '     */\n', '    function endStage(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        uint256 _jackpotAmount = stage[_rId][_sId].amount.mul(jackpot) / 100;\n', '        round[_rId].endSid = _sId;\n', '        round[_rId].jackpotAmount = round[_rId].jackpotAmount.add(_jackpotAmount);\n', '        stage[_rId][_sId].end = now;\n', '        stage[_rId][_sId].ended = true;\n', '        if(_sId > 1)\n', '            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount.add(stage[_rId][_sId - 1].accAmount);\n', '        else\n', '            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount;\n', '\n', '        sId++;\n', '    }\n', '\n', '    /**\n', '     * Precalculations for withdraws to conserve gas.\n', '     */\n', '    function getPlayerDividendByStage(uint256 _rId, uint256 _sId, address _playerAddr)\n', '        private\n', '        view\n', '        returns(uint256, uint256, uint256, uint256)\n', '    {\n', '\n', '        uint256 _dividend;\n', '        uint256 _stageNumber;\n', '        uint256 _startSid;\n', '        uint256 _playerAmount;\n', '\n', '        for(uint256 i = player[_playerAddr].withdrawRid; i <= _rId; i++){\n', '\n', '            if(playerRoundAmount[i][_playerAddr] == 0)\n', '                continue;\n', '\n', '            _playerAmount = 0;\n', '            _startSid = i == player[_playerAddr].withdrawRid ? player[_playerAddr].withdrawSid : 1;\n', '            for(uint256 j = _startSid; j < round[i].endSid; j++){\n', '\n', '                if(playerStageAccAmount[i][j][_playerAddr] > 0)\n', '                    _playerAmount = playerStageAccAmount[i][j][_playerAddr];\n', '\n', '                if(_playerAmount == 0)\n', '                    _playerAmount = playerRoundwithdrawAmountFlag[i][_playerAddr];\n', '\n', '                if(_playerAmount == 0)\n', '                    continue;\n', '                _dividend = _dividend.add(\n', '                    (\n', '                        _playerAmount.mul(stage[i][j].dividendAmount)\n', '                    ).div(stage[i][j].accAmount)\n', '                );\n', '\n', '                _stageNumber++;\n', '                if(_stageNumber >= 50)\n', '                    return (_dividend, i, j + 1, _playerAmount);\n', '            }\n', '\n', '            if(round[i].ended == true\n', '                && stage[i][round[i].endSid].amount > 0\n', '                && playerStageAmount[i][round[i].endSid][_playerAddr] > 0\n', '            ){\n', '                _dividend = _dividend.add(getPlayerJackpot(_playerAddr, i));\n', '                _stageNumber++;\n', '                if(_stageNumber >= 50)\n', '                    return (_dividend, i + 1, 1, 0);\n', '            }\n', '        }\n', '        return (_dividend, _rId, _sId, _playerAmount);\n', '    }\n', '\n', '    /**\n', '     * Get player current withdrawable dividend.\n', '     */\n', '    function getPlayerDividend(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _endRid = rId;\n', '        uint256 _startRid = player[_playerAddr].withdrawRid;\n', '        uint256 _startSid;\n', '        uint256 _dividend;\n', '\n', '        for(uint256 i = _startRid; i <= _endRid; i++){\n', '\n', '            if(i == _startRid)\n', '                _startSid = player[_playerAddr].withdrawSid;\n', '            else\n', '                _startSid = 1;\n', '            _dividend = _dividend.add(getPlayerDividendByRound(_playerAddr, i, _startSid));\n', '        }\n', '\n', '        return _dividend;\n', '    }\n', '\n', '    /**\n', '     * Get player data for rounds and stages.\n', '     */\n', '    function getPlayerDividendByRound(address _playerAddr, uint256 _rId, uint256 _sId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividend;\n', '        uint256 _startSid = _sId;\n', '        uint256 _endSid = round[_rId].endSid;\n', '\n', '        uint256 _playerAmount;\n', '        uint256 _totalAmount;\n', '        for(uint256 i = _startSid; i < _endSid; i++){\n', '\n', '            if(stage[_rId][i].ended == false)\n', '                continue;\n', '\n', '            _playerAmount = 0;\n', '            _totalAmount = 0;\n', '            for(uint256 j = 1; j <= i; j++){\n', '\n', '                if(playerStageAmount[_rId][j][_playerAddr] > 0)\n', '                    _playerAmount = _playerAmount.add(playerStageAmount[_rId][j][_playerAddr]);\n', '\n', '                _totalAmount = _totalAmount.add(stage[_rId][j].amount);\n', '            }\n', '\n', '            if(_playerAmount == 0 || stage[_rId][i].dividendAmount == 0)\n', '                continue;\n', '            _dividend = _dividend.add((_playerAmount.mul(stage[_rId][i].dividendAmount)).div(_totalAmount));\n', '        }\n', '\n', '        if(round[_rId].ended == true)\n', '            _dividend = _dividend.add(getPlayerJackpot(_playerAddr, _rId));\n', '\n', '        return _dividend;\n', '    }\n', '\n', '\n', '    /**\n', '     * Get player data for jackpot winnings.\n', '     */\n', '    function getPlayerJackpot(address _playerAddr, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividend;\n', '\n', '        if(round[_rId].ended == false)\n', '            return _dividend;\n', '\n', '        uint256 _endSid = round[_rId].endSid;\n', '        uint256 _playerStageAmount = playerStageAmount[_rId][_endSid][_playerAddr];\n', '        uint256 _stageAmount = stage[_rId][_endSid].amount;\n', '        if(_stageAmount <= 0)\n', '            return _dividend;\n', '\n', '        uint256 _jackpotAmount = round[_rId].jackpotAmount.mul(jackpotProportion) / 100;\n', '        uint256 _stageDividendAmount = stage[_rId][_endSid].dividendAmount;\n', '        uint256 _stageJackpotAmount = (_stageAmount.mul(jackpot) / 100).add(_stageDividendAmount);\n', '\n', '        _dividend = _dividend.add(((_playerStageAmount.mul(_jackpotAmount)).div(_stageAmount)));\n', '        _dividend = _dividend.add(((_playerStageAmount.mul(_stageJackpotAmount)).div(_stageAmount)));\n', '\n', '        return _dividend;\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getHeadInfo()\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256, uint256, uint256, uint256, bool)\n', '    {\n', '        return\n', '            (\n', '                rId,\n', '                sId,\n', '                round[rId].jackpotAmount,\n', '                stage[rId][sId].targetAmount,\n', '                stage[rId][sId].amount,\n', '                stage[rId][sId].end,\n', '                stage[rId][sId].ended\n', '            );\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getPersonalStatus(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256)\n', '    {\n', '        if (player[_playerAddr].active == true){\n', '            return\n', '            (\n', '                round[rId].jackpotAmount,\n', '                playerRoundAmount[rId][_playerAddr],\n', '                getPlayerDividendByRound(_playerAddr, rId, 1)\n', '            );\n', '        }else{\n', '            return\n', '            (\n', '                round[rId].jackpotAmount,\n', '                0,\n', '                0\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getValueInfo(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256, uint256)\n', '    {\n', '        if (player[_playerAddr].active == true){\n', '            return\n', '            (\n', '                getPlayerDividend(_playerAddr),\n', '                player[_playerAddr].promotionAmount\n', '            );\n', '        }else{\n', '            return\n', '            (\n', '                0,\n', '                0\n', '            );\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library Indatasets {\n', '\n', '    struct Round {\n', '        uint256 start;          // time round started\n', '        uint256 end;            // time round ends/ended\n', '        bool ended;             // has round end function been ran\n', '        uint256 endSid;         // last stage for current round\n', '        uint256 amount;         // Eth recieved for current round\n', '        uint256 jackpotAmount;  // total jackpot for current round\n', '        uint256 players;        // total players for current round\n', '    }\n', '\n', '    struct Stage {\n', '        uint256 start;          // time stage started\n', '        uint256 end;            // time strage ends/ended\n', '        bool ended;             // has stage end function been ran\n', '        uint256 targetAmount;   // amount needed for current stage\n', '        uint256 amount;         // Eth received for current stage\n', '        uint256 dividendAmount; // total dividend for current stage\n', '        uint256 accAmount;      // total accumulative amount for current stage\n', '        uint256 players;        // total players for current stage\n', '    }\n', '\n', '    struct Player {\n', '        bool active;                // Activation status of player, if false player has not been activated.\n', '        uint256 amount;             // Total player input.\n', '        uint256 promotionAmount;    // Total promotion amount of the player.\n', '        uint256 withdrawRid;        // Last withdraw round of the player.\n', '        uint256 withdrawSid;        // Last withdraw stage of the player.\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y)\n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y)\n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '\n', '    /**\n', '     * @dev x to the power of y\n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else\n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', '/**\n', '*\n', '*  https://fundingsecured.me/fair/\n', '*\n', '*\n', '*  ________ ________  ___  ________\n', '* |\\  _____\\\\   __  \\|\\  \\|\\   __  \\\n', '* \\ \\  \\__/\\ \\  \\|\\  \\ \\  \\ \\  \\|\\  \\\n', '*  \\ \\   __\\\\ \\   __  \\ \\  \\ \\   _  _\\\n', '*   \\ \\  \\_| \\ \\  \\ \\  \\ \\  \\ \\  \\\\  \\|\n', '*    \\ \\__\\   \\ \\__\\ \\__\\ \\__\\ \\__\\\\ _\\\n', '*     \\|__|    \\|__|\\|__|\\|__|\\|__|\\|__|\n', '*  ________ ___  ___  ________   ________  ________\n', '* |\\  _____\\\\  \\|\\  \\|\\   ___  \\|\\   ___ \\|\\   ____\\\n', '* \\ \\  \\__/\\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\_|\\ \\ \\  \\___|_\n', '*  \\ \\   __\\\\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\ \\\\ \\ \\_____  \\\n', '*   \\ \\  \\_| \\ \\  \\\\\\  \\ \\  \\\\ \\  \\ \\  \\_\\\\ \\|____|\\  \\\n', '*    \\ \\__\\   \\ \\_______\\ \\__\\\\ \\__\\ \\_______\\____\\_\\  \\\n', '*     \\|__|    \\|_______|\\|__| \\|__|\\|_______|\\_________\\\n', '*                                            \\|_________|\n', '*\n', '*  https://fundingsecured.me/fair/\n', '*\n', '*\n', '* Warning:\n', '*\n', '* FAIR FUNDS is a game system built on FUNDING SECURED, using infinite loops of token redistribution through open source smart contract codes and pre-defined rules.\n', '* This system is for internal use only and all could be lost by sending anything to this contract address.\n', '* No one can change anything once the contract has been deployed.\n', '* Built in Antiwhale for initial stages for a fairer system.\n', '*\n', '* Official Website: https://fundingsecured.me/\n', '* Official Exchange: https://fundingsecured.me/exchange\n', '* Official Discord: https://discordapp.com/invite/3FrBqBa\n', '* Official Twitter: https://twitter.com/FundingSecured_\n', '* Official Telegram: https://t.me/fundingsecured\n', ' *\n', '**/\n', '\n', '\n', 'contract FAIRFUNDS {\n', '    using SafeMath for uint256;\n', '\n', '    /*------------------------------\n', '                CONFIGURABLES\n', '     ------------------------------*/\n', '    string public name = "FAIRFUNDS";    // Contract name\n', '    string public symbol = "FAIRFUNDS";\n', '\n', '    uint256 public initAmount;          // Initial stage target\n', '    uint256 public amountProportion;    // Stage target growth rate %\n', '    uint256 public dividend;            // Input to Dividend %\n', '    uint256 public jackpot;             // Input to Jackpot %\n', '    uint256 public jackpotProportion;   // Jackpot payout %\n', '    uint256 public fundsTokenDividend;  // Dividend fee % to FUNDS token holders\n', '    uint256 public promotionRatio;      // Promotion %\n', '    uint256 public duration;            // Duration per stage\n', '    bool public activated = false;\n', '\n', '    address public developerAddr;\n', '    address public fundsDividendAddr;\n', '\n', '    /*------------------------------\n', '                DATASETS\n', '     ------------------------------*/\n', '    uint256 public rId;   // Current round id number\n', '    uint256 public sId;   // Current stage id number\n', '\n', '    mapping (uint256 => Indatasets.Round) public round; // (rId => data) round data by round id\n', '    mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage;    // (rId => sId => data) stage data by round id & stage id\n', '    mapping (address => Indatasets.Player) public player;   // (address => data) player data\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; // (rId => address => playerRoundAmount) round data by round id\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundSid;\n', '    mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag;\n', '    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount;    // (rId => sId => address => playerStageAmount) round data by round id & stage id\n', '    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount;\n', '\n', '    //Antiwhale setting, max 5% of stage target for the first 10 stages per address\n', '    uint256[] amountLimit = [0, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250];\n', '\n', '    /*------------------------------\n', '                PUBLIC FUNCTIONS\n', '    ------------------------------*/\n', '\n', '    constructor()\n', '        public\n', '    {\n', '        developerAddr = msg.sender;\n', '        fundsDividendAddr = 0xd529ADaE263048f495A05B858c8E7C077F047813;\n', '    }\n', '\n', '    /*------------------------------\n', '                MODIFIERS\n', '     ------------------------------*/\n', '\n', '    modifier isActivated() {\n', '        require(activated == true, "its not ready yet.  check ?eta in discord");\n', '        _;\n', '    }\n', '\n', '    modifier senderVerify() {\n', '        require (msg.sender == tx.origin);\n', '        _;\n', '    }\n', '\n', '    modifier stageVerify(uint256 _rId, uint256 _sId, uint256 _amount) {\n', '        require(stage[_rId][_sId].amount.add(_amount) <= stage[_rId][_sId].targetAmount);\n', '        _;\n', '    }\n', '\n', '    /**\n', "     * Don't toy or spam the contract.\n", '     */\n', '    modifier amountVerify() {\n', '        require(msg.value >= 100000000000000);\n', '        _;\n', '    }\n', '\n', '    modifier playerVerify() {\n', '        require(player[msg.sender].active == true);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Activation of contract with settings\n', '     */\n', '    function activate()\n', '        public\n', '    {\n', '        require(msg.sender == developerAddr);\n', '        require(activated == false, "FUNDS already activated");\n', '\n', '        activated = true;\n', '        initAmount = 10000000000000000000;\n', '        amountProportion = 10;\n', '        dividend = 70;\n', '        jackpot = 20;\n', '        jackpotProportion = 70;\n', '        fundsTokenDividend = 10;\n', '        promotionRatio = 10;\n', '        duration = 15600;\n', '        rId = 1;\n', '        sId = 1;\n', '\n', '        round[rId].start = now;\n', '        initStage(rId, sId);\n', '\n', '    }\n', '\n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function()\n', '        isActivated()\n', '        senderVerify()\n', '        amountVerify()\n', '        payable\n', '        public\n', '    {\n', '        buyAnalysis(0x0);\n', '    }\n', '\n', '    /**\n', '     * Standard buy function.\n', '     */\n', '    function buy(address _recommendAddr)\n', '        isActivated()\n', '        senderVerify()\n', '        amountVerify()\n', '        public\n', '        payable\n', '        returns(uint256)\n', '    {\n', '        buyAnalysis(_recommendAddr);\n', '    }\n', '\n', '    /**\n', '     * Withdraw function.\n', '     * Withdraw 50 stages at once on current settings.\n', '     * May require to request withdraw more than once to withdraw everything.\n', '     */\n', '    function withdraw()\n', '        isActivated()\n', '        senderVerify()\n', '        playerVerify()\n', '        public\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount;\n', '        uint256 _playerWithdrawAmountFlag;\n', '\n', '        (_amount, player[msg.sender].withdrawRid, player[msg.sender].withdrawSid, _playerWithdrawAmountFlag) = getPlayerDividendByStage(_rId, _sId, msg.sender);\n', '\n', '        if(_playerWithdrawAmountFlag > 0)\n', '            playerRoundwithdrawAmountFlag[player[msg.sender].withdrawRid][msg.sender] = _playerWithdrawAmountFlag;\n', '\n', '        if(player[msg.sender].promotionAmount > 0 ){\n', '            _amount = _amount.add(player[msg.sender].promotionAmount);\n', '            player[msg.sender].promotionAmount = 0;\n', '        }\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '\n', '    /**\n', '     * Core logic to analyse buy behaviour.\n', '     */\n', '    function buyAnalysis(address _recommendAddr)\n', '        private\n', '    {\n', '        uint256 _rId = rId;\n', '        uint256 _sId = sId;\n', '        uint256 _amount = msg.value;\n', '        uint256 _promotionRatio = promotionRatio;\n', '\n', '        if(now > stage[_rId][_sId].end && stage[_rId][_sId].targetAmount > stage[_rId][_sId].amount){\n', '\n', '            endRound(_rId, _sId);\n', '\n', '            _rId = rId;\n', '            _sId = sId;\n', '            round[_rId].start = now;\n', '            initStage(_rId, _sId);\n', '\n', '            _amount = limitAmount(_rId, _sId);\n', '            buyRoundDataRecord(_rId, _amount);\n', '            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\n', '            buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\n', '            buyPlayerDataRecord(_rId, _sId, _amount);\n', '\n', '        }else if(now <= stage[_rId][_sId].end){\n', '\n', '            _amount = limitAmount(_rId, _sId);\n', '            buyRoundDataRecord(_rId, _amount);\n', '            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\n', '\n', '            if(stage[_rId][_sId].amount.add(_amount) >= stage[_rId][_sId].targetAmount){\n', '\n', '                uint256 differenceAmount = (stage[_rId][_sId].targetAmount).sub(stage[_rId][_sId].amount);\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, differenceAmount);\n', '                buyPlayerDataRecord(_rId, _sId, differenceAmount);\n', '\n', '                endStage(_rId, _sId);\n', '\n', '                _sId = sId;\n', '                initStage(_rId, _sId);\n', '                round[_rId].endSid = _sId;\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount.sub(differenceAmount));\n', '                buyPlayerDataRecord(_rId, _sId, _amount.sub(differenceAmount));\n', '\n', '            }else{\n', '                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\n', '                buyPlayerDataRecord(_rId, _sId, _amount);\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * Sets the initial stage parameter.\n', '     */\n', '    function initStage(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        uint256 _targetAmount;\n', '        stage[_rId][_sId].start = now;\n', '        stage[_rId][_sId].end = now.add(duration);\n', '        if(_sId > 1){\n', '            stage[_rId][_sId - 1].end = now;\n', '            stage[_rId][_sId - 1].ended = true;\n', '            _targetAmount = (stage[_rId][_sId - 1].targetAmount.mul(amountProportion + 100)) / 100;\n', '        }else\n', '            _targetAmount = initAmount;\n', '\n', '        stage[_rId][_sId].targetAmount = _targetAmount;\n', '\n', '    }\n', '\n', '    /**\n', '     * Execution of antiwhale.\n', '     */\n', '    function limitAmount(uint256 _rId, uint256 _sId)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _amount = msg.value;\n', '\n', '        if(amountLimit.length > _sId)\n', '            _amount = ((stage[_rId][_sId].targetAmount.mul(amountLimit[_sId])) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\n', '        else\n', '            _amount = ((stage[_rId][_sId].targetAmount.mul(500)) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\n', '\n', '        if(_amount >= msg.value)\n', '            return msg.value;\n', '        else\n', '            msg.sender.transfer(msg.value.sub(_amount));\n', '\n', '        return _amount;\n', '    }\n', '\n', '    /**\n', '     * Record the addresses eligible for promotion links.\n', '     */\n', '    function promotionDataRecord(address _recommendAddr, uint256 _amount)\n', '        private\n', '        returns(uint256)\n', '    {\n', '        uint256 _promotionRatio = promotionRatio;\n', '\n', '        if(_recommendAddr != 0x0000000000000000000000000000000000000000\n', '            && _recommendAddr != msg.sender\n', '            && player[_recommendAddr].active == true\n', '        )\n', '            player[_recommendAddr].promotionAmount = player[_recommendAddr].promotionAmount.add((_amount.mul(_promotionRatio)) / 100);\n', '        else\n', '            _promotionRatio = 0;\n', '\n', '        return _promotionRatio;\n', '    }\n', '\n', '\n', '    /**\n', '     * Records the round data.\n', '     */\n', '    function buyRoundDataRecord(uint256 _rId, uint256 _amount)\n', '        private\n', '    {\n', '\n', '        round[_rId].amount = round[_rId].amount.add(_amount);\n', '        fundsDividendAddr.transfer(_amount.mul(fundsTokenDividend) / 100);\n', '    }\n', '\n', '    /**\n', '     * Records the stage data.\n', '     */\n', '    function buyStageDataRecord(uint256 _rId, uint256 _sId, uint256 _promotionRatio, uint256 _amount)\n', '        stageVerify(_rId, _sId, _amount)\n', '        private\n', '    {\n', '        if(_amount <= 0)\n', '            return;\n', '        stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\n', '        stage[_rId][_sId].dividendAmount = stage[_rId][_sId].dividendAmount.add((_amount.mul(dividend.sub(_promotionRatio))) / 100);\n', '    }\n', '\n', '    /**\n', '     * Records the player data.\n', '     */\n', '    function buyPlayerDataRecord(uint256 _rId, uint256 _sId, uint256 _amount)\n', '        private\n', '    {\n', '        if(_amount <= 0)\n', '            return;\n', '\n', '        if(player[msg.sender].active == false){\n', '            player[msg.sender].active = true;\n', '            player[msg.sender].withdrawRid = _rId;\n', '            player[msg.sender].withdrawSid = _sId;\n', '        }\n', '\n', '        if(playerRoundAmount[_rId][msg.sender] == 0){\n', '            round[_rId].players++;\n', '            playerRoundSid[_rId][msg.sender] = _sId;\n', '        }\n', '\n', '        if(playerStageAmount[_rId][_sId][msg.sender] == 0)\n', '            stage[_rId][_sId].players++;\n', '\n', '        playerRoundAmount[_rId][msg.sender] = playerRoundAmount[_rId][msg.sender].add(_amount);\n', '        playerStageAmount[_rId][_sId][msg.sender] = playerStageAmount[_rId][_sId][msg.sender].add(_amount);\n', '\n', '        player[msg.sender].amount = player[msg.sender].amount.add(_amount);\n', '\n', '        if(playerRoundSid[_rId][msg.sender] > 0){\n', '\n', '            if(playerStageAccAmount[_rId][_sId][msg.sender] == 0){\n', '\n', '                for(uint256 i = playerRoundSid[_rId][msg.sender]; i < _sId; i++){\n', '\n', '                    if(playerStageAmount[_rId][i][msg.sender] > 0)\n', '                        playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(playerStageAmount[_rId][i][msg.sender]);\n', '\n', '                }\n', '            }\n', '\n', '            playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Execute end of round events.\n', '     */\n', '    function endRound(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        round[_rId].end = now;\n', '        round[_rId].ended = true;\n', '        round[_rId].endSid = _sId;\n', '        stage[_rId][_sId].end = now;\n', '        stage[_rId][_sId].ended = true;\n', '\n', '        if(stage[_rId][_sId].players == 0)\n', '            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount);\n', '        else\n', '            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount.mul(100 - jackpotProportion) / 100);\n', '\n', '        rId++;\n', '        sId = 1;\n', '\n', '    }\n', '\n', '    /**\n', '     * Execute end of stage events.\n', '     */\n', '    function endStage(uint256 _rId, uint256 _sId)\n', '        private\n', '    {\n', '        uint256 _jackpotAmount = stage[_rId][_sId].amount.mul(jackpot) / 100;\n', '        round[_rId].endSid = _sId;\n', '        round[_rId].jackpotAmount = round[_rId].jackpotAmount.add(_jackpotAmount);\n', '        stage[_rId][_sId].end = now;\n', '        stage[_rId][_sId].ended = true;\n', '        if(_sId > 1)\n', '            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount.add(stage[_rId][_sId - 1].accAmount);\n', '        else\n', '            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount;\n', '\n', '        sId++;\n', '    }\n', '\n', '    /**\n', '     * Precalculations for withdraws to conserve gas.\n', '     */\n', '    function getPlayerDividendByStage(uint256 _rId, uint256 _sId, address _playerAddr)\n', '        private\n', '        view\n', '        returns(uint256, uint256, uint256, uint256)\n', '    {\n', '\n', '        uint256 _dividend;\n', '        uint256 _stageNumber;\n', '        uint256 _startSid;\n', '        uint256 _playerAmount;\n', '\n', '        for(uint256 i = player[_playerAddr].withdrawRid; i <= _rId; i++){\n', '\n', '            if(playerRoundAmount[i][_playerAddr] == 0)\n', '                continue;\n', '\n', '            _playerAmount = 0;\n', '            _startSid = i == player[_playerAddr].withdrawRid ? player[_playerAddr].withdrawSid : 1;\n', '            for(uint256 j = _startSid; j < round[i].endSid; j++){\n', '\n', '                if(playerStageAccAmount[i][j][_playerAddr] > 0)\n', '                    _playerAmount = playerStageAccAmount[i][j][_playerAddr];\n', '\n', '                if(_playerAmount == 0)\n', '                    _playerAmount = playerRoundwithdrawAmountFlag[i][_playerAddr];\n', '\n', '                if(_playerAmount == 0)\n', '                    continue;\n', '                _dividend = _dividend.add(\n', '                    (\n', '                        _playerAmount.mul(stage[i][j].dividendAmount)\n', '                    ).div(stage[i][j].accAmount)\n', '                );\n', '\n', '                _stageNumber++;\n', '                if(_stageNumber >= 50)\n', '                    return (_dividend, i, j + 1, _playerAmount);\n', '            }\n', '\n', '            if(round[i].ended == true\n', '                && stage[i][round[i].endSid].amount > 0\n', '                && playerStageAmount[i][round[i].endSid][_playerAddr] > 0\n', '            ){\n', '                _dividend = _dividend.add(getPlayerJackpot(_playerAddr, i));\n', '                _stageNumber++;\n', '                if(_stageNumber >= 50)\n', '                    return (_dividend, i + 1, 1, 0);\n', '            }\n', '        }\n', '        return (_dividend, _rId, _sId, _playerAmount);\n', '    }\n', '\n', '    /**\n', '     * Get player current withdrawable dividend.\n', '     */\n', '    function getPlayerDividend(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _endRid = rId;\n', '        uint256 _startRid = player[_playerAddr].withdrawRid;\n', '        uint256 _startSid;\n', '        uint256 _dividend;\n', '\n', '        for(uint256 i = _startRid; i <= _endRid; i++){\n', '\n', '            if(i == _startRid)\n', '                _startSid = player[_playerAddr].withdrawSid;\n', '            else\n', '                _startSid = 1;\n', '            _dividend = _dividend.add(getPlayerDividendByRound(_playerAddr, i, _startSid));\n', '        }\n', '\n', '        return _dividend;\n', '    }\n', '\n', '    /**\n', '     * Get player data for rounds and stages.\n', '     */\n', '    function getPlayerDividendByRound(address _playerAddr, uint256 _rId, uint256 _sId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividend;\n', '        uint256 _startSid = _sId;\n', '        uint256 _endSid = round[_rId].endSid;\n', '\n', '        uint256 _playerAmount;\n', '        uint256 _totalAmount;\n', '        for(uint256 i = _startSid; i < _endSid; i++){\n', '\n', '            if(stage[_rId][i].ended == false)\n', '                continue;\n', '\n', '            _playerAmount = 0;\n', '            _totalAmount = 0;\n', '            for(uint256 j = 1; j <= i; j++){\n', '\n', '                if(playerStageAmount[_rId][j][_playerAddr] > 0)\n', '                    _playerAmount = _playerAmount.add(playerStageAmount[_rId][j][_playerAddr]);\n', '\n', '                _totalAmount = _totalAmount.add(stage[_rId][j].amount);\n', '            }\n', '\n', '            if(_playerAmount == 0 || stage[_rId][i].dividendAmount == 0)\n', '                continue;\n', '            _dividend = _dividend.add((_playerAmount.mul(stage[_rId][i].dividendAmount)).div(_totalAmount));\n', '        }\n', '\n', '        if(round[_rId].ended == true)\n', '            _dividend = _dividend.add(getPlayerJackpot(_playerAddr, _rId));\n', '\n', '        return _dividend;\n', '    }\n', '\n', '\n', '    /**\n', '     * Get player data for jackpot winnings.\n', '     */\n', '    function getPlayerJackpot(address _playerAddr, uint256 _rId)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividend;\n', '\n', '        if(round[_rId].ended == false)\n', '            return _dividend;\n', '\n', '        uint256 _endSid = round[_rId].endSid;\n', '        uint256 _playerStageAmount = playerStageAmount[_rId][_endSid][_playerAddr];\n', '        uint256 _stageAmount = stage[_rId][_endSid].amount;\n', '        if(_stageAmount <= 0)\n', '            return _dividend;\n', '\n', '        uint256 _jackpotAmount = round[_rId].jackpotAmount.mul(jackpotProportion) / 100;\n', '        uint256 _stageDividendAmount = stage[_rId][_endSid].dividendAmount;\n', '        uint256 _stageJackpotAmount = (_stageAmount.mul(jackpot) / 100).add(_stageDividendAmount);\n', '\n', '        _dividend = _dividend.add(((_playerStageAmount.mul(_jackpotAmount)).div(_stageAmount)));\n', '        _dividend = _dividend.add(((_playerStageAmount.mul(_stageJackpotAmount)).div(_stageAmount)));\n', '\n', '        return _dividend;\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getHeadInfo()\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256, uint256, uint256, uint256, bool)\n', '    {\n', '        return\n', '            (\n', '                rId,\n', '                sId,\n', '                round[rId].jackpotAmount,\n', '                stage[rId][sId].targetAmount,\n', '                stage[rId][sId].amount,\n', '                stage[rId][sId].end,\n', '                stage[rId][sId].ended\n', '            );\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getPersonalStatus(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256, uint256, uint256)\n', '    {\n', '        if (player[_playerAddr].active == true){\n', '            return\n', '            (\n', '                round[rId].jackpotAmount,\n', '                playerRoundAmount[rId][_playerAddr],\n', '                getPlayerDividendByRound(_playerAddr, rId, 1)\n', '            );\n', '        }else{\n', '            return\n', '            (\n', '                round[rId].jackpotAmount,\n', '                0,\n', '                0\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * For frontend.\n', '     */\n', '    function getValueInfo(address _playerAddr)\n', '        public\n', '        view\n', '        returns(uint256, uint256)\n', '    {\n', '        if (player[_playerAddr].active == true){\n', '            return\n', '            (\n', '                getPlayerDividend(_playerAddr),\n', '                player[_playerAddr].promotionAmount\n', '            );\n', '        }else{\n', '            return\n', '            (\n', '                0,\n', '                0\n', '            );\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library Indatasets {\n', '\n', '    struct Round {\n', '        uint256 start;          // time round started\n', '        uint256 end;            // time round ends/ended\n', '        bool ended;             // has round end function been ran\n', '        uint256 endSid;         // last stage for current round\n', '        uint256 amount;         // Eth recieved for current round\n', '        uint256 jackpotAmount;  // total jackpot for current round\n', '        uint256 players;        // total players for current round\n', '    }\n', '\n', '    struct Stage {\n', '        uint256 start;          // time stage started\n', '        uint256 end;            // time strage ends/ended\n', '        bool ended;             // has stage end function been ran\n', '        uint256 targetAmount;   // amount needed for current stage\n', '        uint256 amount;         // Eth received for current stage\n', '        uint256 dividendAmount; // total dividend for current stage\n', '        uint256 accAmount;      // total accumulative amount for current stage\n', '        uint256 players;        // total players for current stage\n', '    }\n', '\n', '    struct Player {\n', '        bool active;                // Activation status of player, if false player has not been activated.\n', '        uint256 amount;             // Total player input.\n', '        uint256 promotionAmount;    // Total promotion amount of the player.\n', '        uint256 withdrawRid;        // Last withdraw round of the player.\n', '        uint256 withdrawSid;        // Last withdraw stage of the player.\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath v0.1.9\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev gives square root of given x.\n', '     */\n', '    function sqrt(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256 y)\n', '    {\n', '        uint256 z = ((add(x,1)) / 2);\n', '        y = x;\n', '        while (z < y)\n', '        {\n', '            y = z;\n', '            z = ((add((x / z),z)) / 2);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev gives square. multiplies x by x\n', '     */\n', '    function sq(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return (mul(x,x));\n', '    }\n', '\n', '    /**\n', '     * @dev x to the power of y\n', '     */\n', '    function pwr(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (x==0)\n', '            return (0);\n', '        else if (y==0)\n', '            return (1);\n', '        else\n', '        {\n', '            uint256 z = x;\n', '            for (uint256 i=1; i < y; i++)\n', '                z = mul(z,x);\n', '            return (z);\n', '        }\n', '    }\n', '}']
