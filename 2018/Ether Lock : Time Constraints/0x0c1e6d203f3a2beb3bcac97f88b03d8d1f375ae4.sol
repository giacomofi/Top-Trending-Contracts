['pragma solidity ^0.4.21;\n', '\n', 'contract FangTangCoin {\n', '    string public name;\n', '    string public symbol;\n', '    uint256 public decimals;\n', '    uint256 public totalSupply;\n', '    \n', '    address public creator;\n', '    \n', '    bool public autoSend = false;\n', '    uint public start;\n', '    uint public end;\n', '    uint public rate;\n', '    uint public freeCount;\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => uint8) public buyCountOf;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // buy token \n', '    function () public payable {\n', '        require(autoSend);\n', '        require(now >= start && now <= end);\n', '        \n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens;\n', '        if (rate == 0) \n', '            tokens = freeCount*decimals;\n', '        else \n', '            tokens = (weiAmount/1000000000000000000)*rate;\n', '        \n', '        require(tokens > 0);\n', '        \n', '        // 不要自己提到自己账户\n', '        require(creator != msg.sender);\n', '\n', '        // 首先检查发token的账户是否拥有对应数量的代币 \n', '        require(balanceOf[creator] >= tokens);\n', '        \n', '\n', '\n', '        // 当 rate 为 0 时，检查是否已经领取过\n', '        if (rate == 0)\n', '            require(buyCountOf[msg.sender] < 1);\n', '            \n', '        // 开始转移代币\n', '        uint previousBalances = balanceOf[msg.sender] + balanceOf[creator];\n', '        balanceOf[msg.sender] += tokens;\n', '        balanceOf[creator] -= tokens;\n', '        \n', '        // 这个是事件\n', '        emit Transfer(creator,msg.sender, tokens);\n', '        assert(balanceOf[msg.sender] + balanceOf[creator] == previousBalances);\n', '        \n', '         if (rate == 0) \n', '            buyCountOf[msg.sender] += 1;\n', '        \n', '    }\n', '    \n', '    function getETH() public {\n', '        require(address(this).balance > 0 && msg.sender == creator);\n', '        creator.transfer(address(this).balance);\n', '    }\n', '    \n', '    function FangTangCoin( \n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        string tokenSymbol,\n', '        uint8 tokenDecimals,\n', '        bool tokenAutoSend,\n', '        uint tokenStart,\n', '        uint tokenEnd,\n', '        uint tokenPrice,\n', '        uint tokenFreeCount\n', '    ) public payable\n', '    {\n', '        name = tokenName;                       \n', '        symbol = tokenSymbol; \n', '        decimals = tokenDecimals;\n', '        \n', '        creator = msg.sender;\n', '        totalSupply = initialSupply * ( 10 ** uint256(decimals) ); \n', '        balanceOf[msg.sender] = totalSupply;\n', '        \n', '        autoSend = tokenAutoSend;\n', '        start = tokenStart;\n', '        end = tokenEnd;\n', '        rate = tokenPrice;\n', '        freeCount = tokenFreeCount;\n', '        \n', '        \n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public {\n', '        \n', '        // _value = _value * ( 10 ** uint256(decimals) );\n', '        \n', '        require(_to != 0x0);\n', '        require(msg.sender != _to);\n', '        \n', '        require(balanceOf[msg.sender] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        \n', '        uint previousBalances = balanceOf[msg.sender] + balanceOf[_to];\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        \n', '        // 这个是事件\n', '        emit Transfer(msg.sender, _to, _value);\n', '        assert(balanceOf[msg.sender] + balanceOf[_to] == previousBalances);\n', '    }\n', '    \n', '    \n', '\n', '}']