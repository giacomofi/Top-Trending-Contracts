['pragma solidity ^0.4.24;\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Copyright (c) 2018 Decentralization Authority MDAO.\n', ' * Released under the MIT License.\n', ' *\n', ' * ZeroGold POW Mining\n', ' * \n', ' * An ERC20 token wallet which dispenses tokens via Proof of Work mining.\n', ' * Based on recommendation from /u/diego_91\n', ' * \n', ' * Version 18.8.19\n', ' *\n', ' * Web    : https://d14na.org\n', ' * Email  : support@d14na.org\n', ' */\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * SafeMath\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * Owned contract\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC Token Standard #20 Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '/*******************************************************************************\n', ' *\n', ' * ERC 918 Mineable Token Interface\n', ' * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-918.md\n', ' */\n', 'contract ERC918Interface {\n', '    function getChallengeNumber() public constant returns (bytes32);\n', '    function getMiningDifficulty() public constant returns (uint);\n', '    function getMiningTarget() public constant returns (uint);\n', '    function getMiningReward() public constant returns (uint);\n', '\n', '    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    address public lastRewardTo;\n', '    uint public lastRewardEthBlockNumber;\n', '}\n', '\n', '/*******************************************************************************\n', ' *\n', ' * @notice ZeroGoldDust - Merged Mining Contract\n', ' *\n', ' * @dev This is a standard ERC20 mineable token contract.\n', ' */\n', 'contract ZeroGoldPOWMining is Owned {\n', '    using SafeMath for uint;\n', '\n', '    /* Initialize the ZeroGold contract. */\n', '    ERC20Interface zeroGold;\n', '    \n', '    /* Initialize the Mining Leader contract. */\n', '    ERC918Interface public miningLeader;\n', '    \n', '    /* Reward divisor. */\n', '    // NOTE A value of 20 means the reward is 1/20 (5%) \n', '    //      of current tokens held in the quarry. \n', '    uint rewardDivisor = 20;\n', '\n', '    /* Number of times this has been mined. */\n', '    uint epochCount = 0;\n', '    \n', '    /* Amount of pending rewards (merged but not yet transferred). */\n', '    uint unclaimedRewards = 0;\n', '    \n', '    /* MintHelper approved rewards (to be claimed in transfer). */\n', '    mapping(address => uint) mintHelperRewards;\n', '\n', '    /* Solved solutions (to prevent duplicate rewards). */\n', '    mapping(bytes32 => bytes32) solutionForChallenge;\n', '\n', '    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n', '\n', '    constructor(address _miningLeader) public  {\n', '        /* Initialize the mining leader (eg 0xBitcoin). */\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '\n', '        /* Initialize the ZeroGold contract. */\n', '        // NOTE We hard-code the address here, since it should never change.\n', '        zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968);\n', '    }\n', '\n', '    /**\n', '     * Merge\n', '     * (called from ANY MintHelper)\n', '     * \n', '     * Ensure that mergeMint() can only be called once per MintHelper.\n', '     * Do this by ensuring that the "new" challenge number from \n', '     * MiningLeader::challenge post mint can be called once and that this block time \n', '     * is the same as this mint, and the caller is msg.sender.\n', '     */\n', '    function merge() external returns (bool success) {\n', '        /* Verify MiningLeader::lastRewardTo == msg.sender. */\n', '        if (miningLeader.lastRewardTo() != msg.sender) {\n', '            // NOTE A different address called mint last \n', "            //      so return false (don't revert).\n", '            return false;\n', '        }\n', '            \n', '        /* Verify MiningLeader::lastRewardEthBlockNumber == block.number. */\n', '        if (miningLeader.lastRewardEthBlockNumber() != block.number) {\n', '            // NOTE MiningLeader::mint() was called in a different block number \n', "            //      so return false (don't revert).\n", '            return false;\n', '        }\n', '\n', '        // We now update the solutionForChallenge hashmap with the value of \n', '        // MiningLeader::challengeNumber when a solution is merge minted. Only allow \n', '        // one reward for each challenge based on MiningLeader::challengeNumber.\n', '        bytes32 challengeNumber = miningLeader.getChallengeNumber();\n', '        bytes32 solution = solutionForChallenge[challengeNumber];\n', '        if (solution != 0x0) return false; // prevent the same answer from awarding twice\n', '        \n', "        bytes32 digest = 'merge';\n", '        solutionForChallenge[challengeNumber] = digest;\n', '\n', '        // We may safely run the relevant logic to give an award to the sender, \n', '        // and update the contract.\n', '        \n', '        /* Retrieve the reward amount. */\n', '        uint reward = getRewardAmount();\n', '        \n', '        /* Increase the value of unclaimed rewards. */\n', '        unclaimedRewards = unclaimedRewards.add(reward);\n', '\n', "        /* Increase the MintHelper's reward amount. */\n", '        mintHelperRewards[msg.sender] = mintHelperRewards[msg.sender].add(reward);\n', '\n', '        /* Retrieve our ZeroGold balance. */\n', '        uint balance = zeroGold.balanceOf(address(this));\n', '\n', '        /* Verify that we will NOT try to transfer more than we HODL. */\n', '        assert(mintHelperRewards[msg.sender] <= balance);\n', '\n', '        /* Increment the epoch count. */\n', '        epochCount = epochCount.add(1);\n', '\n', '        // NOTE: Use 0 to indicate a merge mine.\n', '        emit Mint(msg.sender, mintHelperRewards[msg.sender], epochCount, 0);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfer\n', '     * (called from ANY MintHelper)\n', '     * \n', '     * Transfers the "approved" ZeroGold rewards to the MintHelpers\'s \n', '     * payout wallets. \n', '     * \n', '     * NOTE: This function will be called twice by MintHelper.merge(), \n', '     *       once for `minterWallet` and once for `payoutsWallet`.\n', '     */\n', '    function transfer(\n', '        address _wallet, \n', '        uint _reward\n', '    ) external returns (bool) {\n', '        /* Require a positive transfer value. */\n', '        if (_reward <= 0) {\n', '            return false;\n', '        }\n', '\n', "        /* Verify our MintHelper isn't trying to over reward itself. */\n", '        if (_reward > mintHelperRewards[msg.sender]) {\n', '            return false;\n', '        }\n', '\n', "        /* Reduce the MintHelper's reward amount. */\n", '        mintHelperRewards[msg.sender] = mintHelperRewards[msg.sender].sub(_reward);\n', '        \n', '        /* Reduce the unclaimed rewards amount. */\n', '        unclaimedRewards = unclaimedRewards.sub(_reward);\n', '\n', "        /* Safely transfer ZeroGold reward to MintHelper's specified wallet. */\n", '        // FIXME MintHelper can transfer rewards to ANY wallet, and NOT\n', '        //       necessarily the wallet that pool miners will benefit from.\n', '        //       How "should we" restrict/verify the specified wallet??\n', '        zeroGold.transfer(_wallet, _reward);\n', '    }\n', '\n', '    /* Calculate the current reward value. */\n', '    function getRewardAmount() public view returns (uint) {\n', '        /* Retrieve the ZeroGold balance available in this mineable contract. */\n', '        uint totalBalance = zeroGold.balanceOf(address(this));\n', '        \n', '        /* Calculate the available balance (minus unclaimed rewards). */\n', '        uint availableBalance = totalBalance.sub(unclaimedRewards);\n', '\n', '        /* Calculate the reward amount. */\n', '        uint rewardAmount = availableBalance.div(rewardDivisor);\n', '\n', '        return rewardAmount;\n', '    }\n', '    \n', '    /* Retrieves the "TOTAL" reward amount available to this MintHelper. */\n', '    // NOTE `lastRewardAmount()` is called from MintHelper during the `merge` \n', '    //      to assign the `merge_totalReward` value.\n', '    function lastRewardAmount() external view returns (uint) {\n', '        return mintHelperRewards[msg.sender];\n', '    }\n', '    \n', '    /* Set the mining leader. */\n', '    function setMiningLeader(address _miningLeader) external onlyOwner {\n', '        miningLeader = ERC918Interface(_miningLeader);\n', '    }\n', '\n', '    /* Set the reward divisor. */\n', '    function setRewardDivisor(uint _rewardDivisor) external onlyOwner {\n', '        rewardDivisor = _rewardDivisor;\n', '    }\n', '\n', '    /**\n', '     * THIS CONTRACT DOES NOT ACCEPT DIRECT ETHER\n', '     */\n', '    function () public payable {\n', '        /* Cancel this transaction. */\n', "        revert('Oops! Direct payments are NOT permitted here.');\n", '    }\n', '\n', '    /**\n', '     * Transfer Any ERC20 Token\n', '     *\n', '     * @notice Owner can transfer out any accidentally sent ERC20 tokens.\n', '     *\n', '     * @dev Provides an ERC20 interface, which allows for the recover\n', '     *      of any accidentally sent ERC20 tokens.\n', '     */\n', '    function transferAnyERC20Token(\n', '        address tokenAddress, uint tokens\n', '    ) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']