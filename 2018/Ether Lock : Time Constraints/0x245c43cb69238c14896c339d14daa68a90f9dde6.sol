['pragma solidity ^0.4.23;\n', '\n', '/**\n', '\n', '    https://zethr.io https://zethr.io https://zethr.io https://zethr.io https://zethr.io\n', '\n', '\n', '                          ███████╗███████╗████████╗██╗  ██╗██████╗\n', '                          ╚══███╔╝██╔════╝╚══██╔══╝██║  ██║██╔══██╗\n', '                            ███╔╝ █████╗     ██║   ███████║██████╔╝\n', '                           ███╔╝  ██╔══╝     ██║   ██╔══██║██╔══██╗\n', '                          ███████╗███████╗   ██║   ██║  ██║██║  ██║\n', '                          ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝\n', '\n', '\n', '.------..------.     .------..------..------.     .------..------..------..------..------.\n', '|B.--. ||E.--. |.-.  |T.--. ||H.--. ||E.--. |.-.  |H.--. ||O.--. ||U.--. ||S.--. ||E.--. |\n', '| :(): || (\\/) (( )) | :/\\: || :/\\: || (\\/) (( )) | :/\\: || :/\\: || (\\/) || :/\\: || (\\/) |\n', '| ()() || :\\/: |&#39;-.-.| (__) || (__) || :\\/: |&#39;-.-.| (__) || :\\/: || :\\/: || :\\/: || :\\/: |\n', '| &#39;--&#39;B|| &#39;--&#39;E| (( )) &#39;--&#39;T|| &#39;--&#39;H|| &#39;--&#39;E| (( )) &#39;--&#39;H|| &#39;--&#39;O|| &#39;--&#39;U|| &#39;--&#39;S|| &#39;--&#39;E|\n', '`------&#39;`------&#39;  &#39;-&#39;`------&#39;`------&#39;`------&#39;  &#39;-&#39;`------&#39;`------&#39;`------&#39;`------&#39;`------&#39;\n', '\n', 'An interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles.\n', '\n', 'Bankroll contract, containing tokens purchased from all dividend-card profit and ICO dividends.\n', 'Acts as token repository for games on the Zethr platform.\n', '\n', '\n', 'Credits\n', '=======\n', '\n', 'Analysis:\n', '    blurr\n', '    Randall\n', '\n', 'Contract Developers:\n', '    Etherguy\n', '    klob\n', '    Norsefire\n', '\n', 'Front-End Design:\n', '    cryptodude\n', '    oguzhanox\n', '    TropicalRogue\n', '\n', '**/\n', '\n', 'contract ZTHInterface {\n', '    function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass) public payable returns (uint);\n', '    function balanceOf(address who) public view returns (uint);\n', '    function transfer(address _to, uint _value)     public returns (bool);\n', '    function transferFrom(address _from, address _toAddress, uint _amountOfTokens) public returns (bool);\n', '    function exit() public;\n', '    function sell(uint amountOfTokens) public;\n', '    function withdraw(address _recipient) public;\n', '    function getUserAverageDividendRate(address user) public view returns (uint);\n', '}\n', '\n', '// Interface of zethr games \n', 'contract ZethrGameInterface{\n', '    function execute(address from, uint value, uint userDivRate, bytes data) public;\n', '}\n', '\n', 'contract ERC223Receiving {\n', '    function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\n', '}\n', '\n', '// Interface of master bankroll\n', 'contract ZethrBankroll {\n', '    address public stakeAddress;\n', '    mapping (address => bool) public isOwner;\n', '    function changeAllocation(address what, int delta) public;\n', '}\n', '\n', '// Library to return the actual tier of an average dividend rate \n', 'library ZethrTierLibrary{\n', '    uint constant internal magnitude = 2**64;\n', '\n', '    // Gets the tier (1-7) of the divs sent based off of average dividend rate\n', '    // This is an index used to call into the correct sub-bankroll to withdraw tokens\n', '    function getTier(uint divRate) internal pure returns (uint){\n', '        \n', '        // Divide the average dividned rate by magnitude\n', '        // Remainder doesn&#39;t matter because of the below logic\n', '        uint actualDiv = divRate / magnitude; \n', '        if (actualDiv >= 30){\n', '            return 7;\n', '        }\n', '        else if (actualDiv >= 25){\n', '            return 6;\n', '        }\n', '        else if (actualDiv >= 20){\n', '            return 5;\n', '        }\n', '        else if (actualDiv >= 15){\n', '            return 4;\n', '        }\n', '        else if (actualDiv >= 10){\n', '            return 3; \n', '        }\n', '        else if (actualDiv >= 5){\n', '            return 2;\n', '        }\n', '        else if (actualDiv >= 2){\n', '            return 1;\n', '        }\n', '        else{\n', '            // Should be impossible\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', 'contract ZethrTokenBankroll is ERC223Receiving {\n', '\n', '    /*=================================\n', '    =          LIST OF OWNERS         =\n', '    =================================*/\n', '\n', '    /*\n', '        This list is for reference/identification purposes only, and comprises the eight core Zethr developers.\n', '        For game contracts to be listed, they must be approved by a majority (i.e. currently five) of the owners.\n', '        Contracts can be delisted in an emergency by a single owner.\n', '\n', '        0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae // Norsefire\n', '        0x11e52c75998fe2E7928B191bfc5B25937Ca16741 // klob\n', '        0x20C945800de43394F70D789874a4daC9cFA57451 // Etherguy\n', '        0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB // blurr\n', '        0x8537aa2911b193e5B377938A723D805bb0865670 // oguzhanox\n', '        0x9D221b2100CbE5F05a0d2048E2556a6Df6f9a6C3 // Randall\n', '        0x71009e9E4e5e68e77ECc7ef2f2E95cbD98c6E696 // cryptodude\n', '        0xDa83156106c4dba7A26E9bF2Ca91E273350aa551 // TropicalRogue\n', '    */\n', '    \n', '    // Mapping of whitelisted contracts\n', '    mapping(address => bool) public whitelistedContract; \n', '  \n', '    // Daily allocation mapping is master bankroll\n', '    // mapping(address => uint) public dailyAllocation;\n', '    \n', '    mapping (address => uint) public tokenVolumeInput; // tokens in per game \n', '    mapping (address => uint) public tokenVolumeOutput; // tokens out per  game \n', '    mapping (address => uint) public gameTokenAmount; // track tokens per game\n', '    mapping (address => uint) public gameTokenAllocation; // game token allocation \n', '    \n', '    // "free" tokens in the contract, can be allocated to games\n', '    uint public freeTokens;\n', '    \n', '    // List of all games\n', '    address[] public games; \n', '    \n', '    // Zethr main contract address\n', '    address Zethr; \n', '  \n', '    // Zethr interface\n', '    ZTHInterface ZethrContract;  \n', '\n', '    // Zethr bankroll address\n', '    address ZethrMainBankroll; \n', '    \n', '    // Dividend rate of this tokenBankroll\n', '    uint public divRate;\n', '\n', '    // "tier" of this tokeknBankroll (1-7)\n', '    uint public tier;\n', '    \n', '    // Magnitude for calculating average div rate\n', '    uint constant internal magnitude = 2**64;\n', '    \n', '    // Requires supplied address to be a whitelisted contract\n', '    // Pulls from master bankroll\n', '    modifier contractIsWhiteListed(address ctr){\n', '        require(whitelistedContract[ctr]);\n', '        _;\n', '    }\n', '    \n', '    // Requires msg.sender to be a dev or the bankroll\n', '    modifier onlyDevOrBankroll(){\n', '        require(msg.sender == ZethrMainBankroll || ZethrBankroll(ZethrMainBankroll).isOwner(msg.sender));\n', '        _;\n', '    }\n', '    \n', '    // Requires msg.sender to be a dev\n', '    modifier onlyDev(){\n', '        require(ZethrBankroll(ZethrMainBankroll).isOwner(msg.sender));\n', '        _;\n', '    }\n', '\n', '    /*=================================\n', '    =         PUBLIC FUNCTIONS        =\n', '    =================================*/\n', '\n', '    /// @dev Contract constructor sets sub roll divrate \n', '    constructor (uint ctrDivRate) public {\n', '        // Set the address of Zethr main contract\n', '        Zethr = address(0xD48B633045af65fF636F3c6edd744748351E020D); \n', '       \n', '        // Instantiate the Zethr contract \n', '        ZethrContract = ZTHInterface(Zethr);\n', '\n', '    \t// Set the master bankroll address\n', '        ZethrMainBankroll = address(0x1866abdba62468c33c32eb9cc366923af4b760f9); \n', '        \n', '        // Dev addresses are pulled from the bankroll\n', '        \n', '        // Set this tokenBankroll&#39;s dividend rate\n', '        divRate = ctrDivRate;\n', '\n', '        // Set this token&#39;s dividend tier (1-7)\n', '        tier = ZethrTierLibrary.getTier(divRate * magnitude);\n', '    }\n', '\n', '    // Admin / bankroll function to change bankroll address\n', '    function setBankroll(address bankrollAddress) public onlyDevOrBankroll() {\n', '      ZethrMainBankroll =  bankrollAddress;\n', '    }\n', '\n', '    // Assembly function \n', '    // Takes: bytes data as input \n', '    // Returns: the address we want to call \n', '    // plus the remaining bytes of data which should be fed to the game\n', '    \n', '    /*\n', '        Layout of the actual bytes data as input: \n', '        First bytes32: an address you want to call to (the game address)\n', '        (Optional) extra bytes32: remaining data \n', '        Padding of the address is how we see it in raw tx data: 0x00...address \n', '        \n', '        Input MUST have bytes which are a multiple of 32 \n', '        Input MUST have at least one bytes32 \n', '        \n', '        Test cases \n', '            Only address\n', '            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\n', '            Address + bytes \n', '            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\n', '            Address + 2 bytes \n', '            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\n', '        \n', '        Error cases: \n', '            Not a multiple of 32 \n', '            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa5\n', '            Empty\n', '            0x0 \n', '            \n', '        Note: sanity check is done after the getData call to check if address is a contract \n', '    */\n', '    function getData(bytes data) public pure returns (address, bytes rem) {\n', '        // edge case: len 0 should revert \n', '        // case: len 1 should only parse addr and empty bytes \n', '        // case: len more should forloop over bytes and dump them \n', '        \n', '        require(data.length == (data.length/32) * 32); // sanity check only bytes32 multiples \n', '    \n', '        // no address found \n', '        if (data.length == 0) {\n', '            revert(); // no data \n', '        }\n', '    \n', '        address out_a;\n', '        bytes memory out_b; // initialzie to empty array \n', '        \n', '        \n', '        // start the assembly magic \n', '        if (data.length == 32){\n', '            // ONLY an address, rest is empty data. Fine! \n', '            assembly {\n', '                // Things to know here: \n', '                // x := bla sets x to bla \n', '                // mload loads 32 bytes, the input is the memory slot \n', '                // vars used here are actually POINTERS not the actual data! \n', '                // Logic (IMPORTANT)\n', '                // A bytes is laid out in solidity as: \n', '                // first bytes32: a uint which has the LENGTH of this byte \n', '                // the length of the byte is the numbers of bytes (so in here its a multiple of 32, aka 0x20!)\n', '                //So if we want to retrieve the actual data at the first slot (hence, the address) we need\n', '                //to add 32 bytes to the actual pointer of data, to skip over the length bytes32 \n', '                //then we load this bytes32 and dump it into out_a \n', '                out_a := mload(add(data, 0x20)) // load first byte into the address slot \n', '            }\n', '        }\n', '        else{\n', '            // Logic: remove 32 from the actual data length because we want to remove the game address from the data \n', '            // (Why do that here not in the game? Because it adds a load of code)\n', '            uint len = data.length - 32;\n', '            assembly {\n', '                out_a := mload(add(data, 0x20)) // load first byte into the address slot, same as above in case of only the address \n', '                // at the out_b pointer, we store the length we want this bytes to have \n', '                // yup - thats the number of bytes in data (data.length) minus 32 as defined above \n', '                mstore(out_b, len)\n', '                // now we will actually fill this bytes \n', '                // for loop: for(uint i=0; i<len; i++)\n', '                for { let i := 0 } lt(i, div(len, 0x20)) { i := add(i, 0x1) } {\n', '                    // calculate the memory slot we want to dump data in: \n', '                    // take the out_b pointer \n', '                    // add 32 * (i+1) to this (could have optimized this)\n', '                    let mem_slot := add(out_b, mul(0x20, add(i,1)))\n', '                    // calculate the load slot where we want to actually read memory from \n', '                    // this is the same as the memory slot we want to write to, +32 \n', '                    // this makes sense becausae we want to basically move all bytes32 one place back! \n', '                    let load_slot := add(mem_slot,0x20)\n', '                    // actually dump the loaded memory at load_slot into mem_slot \n', '                    mstore(mem_slot, mload(load_slot))\n', '                }\n', '            }\n', '        }\n', '        //uint codelen;\n', '        //assembly{\n', '          //  codelen := extcodesize(out_a)\n', '        //}\n', '        // require(codelen > 0); // sanity check we are delegate of a contract \n', '        return (out_a, out_b);\n', '    }\n', '\n', '    // Returns true if supplied address is a contract\n', '\t\t// Does not return true if this contract is deployed during this block\n', '    function isContract(address ctr) internal view returns (bool){\n', '        uint codelen;\n', '        assembly{\n', '            codelen := extcodesize(ctr)\n', '        }\n', '        return (codelen > 0);\n', '    }\n', '\n', '  // Token fallback - gets entered when users transfer tokens to this contract \n', '\tfunction tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool) {\n', '\n', '\t\t\t// Can only be called from Zethr\n', '\t    require(msg.sender == Zethr); \n', '\n', '\t\t\t// Get the user&#39;s dividend rate\n', '\t\t\t// This is a big nasty number\n', '\t    uint userDivRate = ZethrContract.getUserAverageDividendRate(_from);\n', '\n', '\t\t\t// Calculate the user&#39;s tier, and make sure it is appropriate for this contract\n', '\t\t\t// (sanity check)\n', '\t    require(ZethrTierLibrary.getTier(userDivRate) == tier); \n', '\n', '\t    address target;  \n', '\t    bytes memory remaining_data;\n', '\n', '\t    // Grab the data we want to forward (target is the game address)\n', '\t    (target, remaining_data) = getData(_data);\n', '\n', '\t    // Sanity check to make sure we&#39;re calling a contract\n', '\t    require(isContract(target));\n', '\n', '\t    // Sanity check to make sure this game is actually one which can use the bankroll \n', '\t    require(whitelistedContract[target]);\n', '\t    \n', '\t\t\t// Add tokens the game&#39;s token amount counter (for this contract only)\n', '\t    gameTokenAmount[target] = SafeMath.add(gameTokenAmount[target], _amountOfTokens);\n', '\n', '\t\t\t// Add tokens the game&#39;s token volume counter (for this contract only)\n', '\t    tokenVolumeInput[target] = SafeMath.add(tokenVolumeInput[target], _amountOfTokens);\n', '\t    \n', '\t    // EXECUTE the actual game! \n', '\t\t\t// Call into the game with data\n', '\t    ZethrGameInterface(target).execute(_from, _amountOfTokens, userDivRate, remaining_data);\n', '\t}\t\n', '\t\n', '\t// Function called ONLY by a whitelisted game\n', '\t// Sends tokens to the target address (player)\n', '\tfunction gameRequestTokens(address target, uint tokens) \n', '\t    public \n', '\t    contractIsWhiteListed(msg.sender)\n', '    {\n', '\t\t\t// Don&#39;t sent more tokens than the game owns\n', '\t    require(gameTokenAmount[msg.sender] >= tokens);  \n', '\n', '\t\t\t// Subtract the amount of tokens the game owns\n', '\t    gameTokenAmount[msg.sender] = gameTokenAmount[msg.sender] - tokens; \n', '\n', '\t\t\t// Update output volume\n', '\t    tokenVolumeOutput[msg.sender] = tokenVolumeOutput[msg.sender] + tokens; \n', '\n', '\t\t\t// Actually transfer. Re-entrancy possibility\n', '\t    ZethrContract.transfer(target, tokens);\n', '\t}\n', '\t\n', '\t// Add a game to the whitelist. Can only be called by dev or bankroll.\t\n', '\tfunction addGame(address game, uint allocated)\n', '\t    onlyDevOrBankroll\n', '\t    public\n', '    {\n', '\t\t\t\t// Push the game address to the list\n', '        games.push(game); \n', '\n', '\t\t\t\t// Set the token allocation\n', '        gameTokenAllocation[game] = allocated; \n', '\n', '\t\t\t\t// If we have enough "free" tokens, allocate them\n', '        if (freeTokens >= allocated){ \n', '            freeTokens = SafeMath.sub(freeTokens, allocated);\n', '            gameTokenAmount[game] = allocated;\n', '        }\n', '\n', '        // Change this tokenbankroll&#39;s allocation\n', '        ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), int(allocated));\n', '\n', '\t\t\t\t// Ad the game to the whitelisted addresses\n', '        whitelistedContract[game] = true; \n', '    }\n', '    \n', '    // Remove the game from the list & dewhitelist it\n', '    function removeGame(address game)\n', '        public\n', '        onlyDevOrBankroll\n', '        contractIsWhiteListed(game) // Only remove games which are added \n', '    {\n', '        // Loop over games to find the actual index to remove \n', '        for (uint i=0; i < games.length; i++){\n', '            if (games[i] == game){\n', '                games[i] = address(0x0); // Delete it \n', '                if (i != games.length){ // If its NOT at the end remove the last game address into the array TO this position\n', '                    games[i] = games[games.length];\n', '                }\n', '                games.length = games.length - 1; // Remove 1 from length \n', '                break; // Found it, great \n', '            }\n', '        }\n', '\n', '        // Add remaining tokens from game to the "free" list \n', '        freeTokens = SafeMath.add(freeTokens, gameTokenAmount[game]);\n', '\n', '        // Aint got no tokens \n', '        gameTokenAmount[game] = 0;\n', '\n', '        // Aint whitelisted \n', '        whitelistedContract[game] = false;\n', '\n', '        // Change this tokenBankroll&#39;s allocation\n', '        ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), int(-gameTokenAllocation[game]));\n', '\n', '        // No allocate \n', '        gameTokenAllocation[game] = 0;\n', '    }\n', '\t\n', '\t// Callable from games to change their own token allocation \n', '  // The game must have "free" tokens\n', '  // Triggers a change in the tokenBankroll&#39;s allocation amount on the master bankroll\n', '\tfunction changeAllocation(int delta)\n', '\t    public\n', '\t    contractIsWhiteListed(msg.sender)\n', '\t{\n', '\t    uint newAlloc;\n', '      // We need to INCREASE token allocation:\n', '\t    if (delta > 0){\n', '\t        // Calculate new allocation \n', '\t        newAlloc = SafeMath.add(gameTokenAllocation[msg.sender], uint(delta));\n', '\n', '\t        // It SHOULD have enough tokens\n', '\t        require(gameTokenAmount[msg.sender] >= newAlloc);\n', '\n', '\t        // Set the game&#39;s token allocation\n', '\t        gameTokenAllocation[msg.sender] = newAlloc;\n', '\n', '          // Set this tokenBankroll&#39;s allocation (increase it)\n', '          ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), delta);\n', '\t    } else {\n', '      // We need to DECREASE token allocation:\n', '\t        // Calculate the new allocation \n', '\t        newAlloc = SafeMath.sub(gameTokenAllocation[msg.sender], uint(-delta));\n', '\n', '\t        // Set the game&#39;s token allocation\n', '\t        gameTokenAllocation[msg.sender] = newAlloc;\n', '\n', '          // Set this tokenBankroll&#39;s allocation (decrease it)\n', '          ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), delta);\n', '\t    }\n', '\t}\n', '\t\n', '\t// Allocates tokens to games\n', '\t// Also buys in if balance >= 0.1 ETH\n', '\tfunction allocateTokens()\n', '\t    onlyDevOrBankroll\n', '\t    public\n', '\t{\n', '\t    // Withdraw divs first\n', '\t    ZethrContract.withdraw(address(this));\n', '\n', '\t\t\t// Buy in, but only if balance >= 0.1 ETH\n', '\t    if (address(this).balance >= (0.1 ether)){\n', '\t        zethrBuyIn(); \n', '\t    }\n', '\n', '      // Store current game address for loop\n', '      address gameAddress;    \n', '      // Stoe game&#39;s balance for loop\n', '      uint gameBalance;\n', '      // Store game&#39;s allotment for loop \n', '      uint gameAllotment;\n', '      // Store game&#39;s difference (positive or negative) in tokenBalance vs tokenAllotment\n', '      int difference;\n', '\n', '      // Loop over each game\n', '      // Remove any "free" tokens (auto-withdraw) over its allotment\n', '      for (uint i=0; i < games.length; i++) {\n', '        // Grab the info about this game&#39;s token amounts\n', '        gameAddress = games[i];\n', '        gameBalance = gameTokenAmount[gameAddress];\n', '        gameAllotment = gameTokenAllocation[gameAddress];   \n', '\n', '        // Calculate deltaTokens (positive if it has more than it needs, negative if it needs tokens)\n', '        difference = int(gameBalance) - int(gameAllotment);\n', '\n', '        // If the game has extra tokens, re-allocate them to the "free" balance\n', '        // This reminds me of when I had to write malloc() for my C class\n', '        // I hated that shit\n', '        if (difference > 0) {\n', '          // Game now has exactly the amount of tokens it needs\n', '          gameTokenAmount[gameAddress] = gameAllotment;\n', ' \n', '          // "Free" the extra\n', '          freeTokens = freeTokens + uint(difference);\n', '        } else {\n', '          // This means it needs tokenks. We&#39;ll address that in the next for loop.\n', '        } \n', '      } \n', '\n', '      // Now that all games have had their excess removed, loop through the games again and allocated them tokens\n', '      // We /will/ have enough tokens to allocate - because we bought in ETH.\n', '      for (uint j=0; j < games.length; j++) {\n', '        // Grab the info about this game&#39;s token amounts\n', '        gameAddress = games[i];\n', '        gameBalance = gameTokenAmount[gameAddress];\n', '        gameAllotment = gameTokenAllocation[gameAddress];\n', '\n', '        // Calculate deltaTokens (either zero or negative in this case)\n', '        difference = int(gameBalance) - int(gameAllotment);\n', '\n', '        // Game either has zero or negative tokens\n', '        // If it has negative tokens, allocate it tokens out of the free balance\n', '        if (difference < 0) {\n', '          // Sanity check\n', '          require(freeTokens >= uint(-difference));\n', '\n', '          // Subtract from free tokens\n', '          freeTokens = freeTokens - uint(-difference);\n', '\n', '          // Allocate\n', '          gameTokenAmount[gameAddress] = gameAllotment;\n', '        }\n', '      }\n', '\n', '      // After the above two for loops, every game has\n', '      //  a) no excess tokens\n', '      //  b) exactly it&#39;s allotment of tokens\n', '\n', '      // There will probably be some free tokens left over due to the 1% extra ETH deposit.\n', '\t}\n', '\n', '  // Dump all free tokens back to the main bankroll\n', '  function dumpFreeTokens(address stakeAddress) onlyDevOrBankroll public returns (uint) {\n', '    // First, allocate tokens    \n', '    allocateTokens();\n', '\n', '    // Don&#39;t transfer tokens if we have less than 1 free token\n', '    if (freeTokens < 1e18) { return 0; }\n', '\n', '    // Transfer free tokens to bankroll\n', '    ZethrContract.transfer(stakeAddress, freeTokens);\n', '\n', '    // Set free tokens to zero\n', '    uint sent = freeTokens;\n', '    freeTokens = 0;\n', '\n', '    // Return the number of tokens we sent\n', '    return sent;\n', '  }\n', '\n', '\t// Contract withdraw free tokens back to the free tokens \n', '\tfunction contractTokenWithdrawToFreeTokens(address ctr, uint amount)\n', '\t    onlyDevOrBankroll\n', '\t    contractIsWhiteListed(ctr)\n', '\t    public \n', '\t{\n', '\t    uint currentBalance = gameTokenAmount[ctr];\n', '\t    uint allocated = gameTokenAllocation[ctr];\n', '\t    if ( SafeMath.sub(currentBalance, amount) > allocated){\n', '\t        gameTokenAmount[ctr] = gameTokenAmount[ctr] - amount;\n', '\t        freeTokens = SafeMath.add(freeTokens, amount);\n', '\t    }\n', '\t    else{\n', '\t        revert();\n', '\t    }\n', '\t}\n', '\t\n', '\t// Function to buy in tokens with Ethereum \n', '\t// Updates free tokens so they can be allocated \n', '\tfunction zethrBuyIn()\n', '\t    onlyDevOrBankroll\n', '\t    public\n', '\t{\n', '      // Only buy in if balance >= 0.1 ETH\n', '      if (address(this).balance < 0.1 ether) { return; } \n', '\n', '      // Grab the tokenBankroll&#39;s token balance\n', '\t    uint cBal = ZethrContract.balanceOf(address(this)); \n', '\n', '      // Buy in with entire balance (divs go to bankroll)\n', '\t    ZethrContract.buyAndSetDivPercentage.value(address(this).balance)(ZethrMainBankroll, uint8(divRate), "");\n', '\n', '      // Calculate and increment freeTokens\n', '\t    freeTokens = freeTokens + (ZethrContract.balanceOf(address(this)) - cBal); \n', '\t}\n', '\t\n', '\t// Emergency this fucks up free tokens \n', '\t// Need a redeploy after this \n', '\tfunction WithdrawTokensToBankroll(uint amount) \n', '\t    onlyDevOrBankroll\n', '\t    public\n', '\t{\n', '\t    ZethrContract.transfer(ZethrMainBankroll, amount);\n', '\t}\n', '\n', '  // Withdraw eth \n', '  function WithdrawToBankroll() public {\n', '    ZethrMainBankroll.transfer(address(this).balance);\n', '  }\n', '    \n', '  // Withdraw divs and send to bankroll \n', '  function WithdrawAndTransferToBankroll() public {\n', '    ZethrContract.withdraw(ZethrMainBankroll);\n', '    WithdrawToBankroll();\n', '  }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']