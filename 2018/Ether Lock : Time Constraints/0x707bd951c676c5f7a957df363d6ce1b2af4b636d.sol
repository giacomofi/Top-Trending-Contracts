['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    \n', '}\n', '\n', '\n', 'contract BasicToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] = balances[msg.sender].sub(_value);\n', '            balances[_to] = balances[_to].add(_value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '\n', '    /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '}\n', '\n', '\n', '    /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '}\n', '\n', 'contract ANOToken is BasicToken {\n', '\n', 'using SafeMath for uint256;\n', '\n', 'string public name = "Anonium";                                 // Name of the token\n', 'string public symbol = "ANO";                                   // Symbol of the token\n', 'uint8 public decimals = 18;                                     // Decimals\n', 'uint256 public totalSupply = 21000000000 * 10**18;              // Total supply of SPC Tokens  \n', '\n', '//Variables\n', 'uint256 public tokensAllocatedToCrowdFund;                      // variable to track the allocations of the token to crowdfund\n', 'uint256 public totalAllocatedTokens;                            // variable to track the supply in to the market\n', '\n', '//Address\n', 'address public crowdFundAddress;                                // Address of the crowdfund\n', 'address public founderMultiSigAddress;                          // Address of the founder\n', '\n', '//events\n', 'event ChangeFoundersWalletAddress(uint256  _blockTimeStamp, address indexed _foundersWalletAddress);\n', '\n', '//modifiers\n', '\n', '  modifier onlyCrowdFundAddress() {\n', '    require(msg.sender == crowdFundAddress);\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address _to) {\n', '    require(_to != 0x0);\n', '    _;\n', '  }\n', '\n', '  modifier onlyFounders() {\n', '    require(msg.sender == founderMultiSigAddress);\n', '    _;\n', '  }\n', '\n', '\n', '  \n', '   // creation of the token contract \n', '   function ANOToken (address _crowdFundAddress) public {\n', '    crowdFundAddress = _crowdFundAddress;\n', '    founderMultiSigAddress = msg.sender;\n', '\n', '    tokensAllocatedToCrowdFund = totalSupply;                   // 100 % allocation of totalSupply\n', '\n', '    // Assigned balances to respective stakeholders\n', '    balances[crowdFundAddress] = tokensAllocatedToCrowdFund;\n', '  \n', '  }\n', '\n', '// function to keep track of the total token allocation\n', '  function changeSupply(uint256 _amount) public onlyCrowdFundAddress {\n', '    totalAllocatedTokens += _amount;\n', '  }\n', '\n', '// function to change founder multisig wallet address            \n', '  function changeFounderMultiSigAddress(address _newFounderMultiSigAddress) public onlyFounders nonZeroAddress(_newFounderMultiSigAddress) {\n', '    founderMultiSigAddress = _newFounderMultiSigAddress;\n', '    ChangeFoundersWalletAddress(now, founderMultiSigAddress);\n', '  }\n', '\n', '  /**\n', '    @dev `burnToken` used to burn the remianing token after the end of crowdsale\n', '    it only be called by the crowdfund address only \n', '   */\n', '\n', '  function burnToken() public onlyCrowdFundAddress returns (bool) {\n', '    totalSupply = totalSupply.sub(balances[msg.sender]);\n', '    balances[msg.sender] = 0;\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract ANOCrowdsale {\n', '\n', 'using SafeMath for uint256;\n', '\n', 'ANOToken token;                                                  // Token variable\n', '\n', 'uint256 public startDate;                                        // Start date of the crowdsale\n', 'uint256 public endDate;                                          // End date of crowdsale\n', 'uint256 private weekNo = 0;                                       // Flag variable to track the week no.\n', 'uint256 public allocatedToken = 21000000000 * 10 ** 18;          // Total tokens allocated to crowdsale \n', 'uint256 private tokenAllocatedForWeek;                           // Variable to track the allocation per week\n', 'uint256 private tokenSoldForWeek;                                // Token sold per week\n', 'uint256 public ethRaised;                                        // Public variable to track the amount of ETH raised\n', 'uint32 public tokenRate = 6078;                                  // Initialization of token rate \n', 'uint32 public appreciationRate = 1216;                           // The rate of token will increased by that much amount\n', 'bool private isTokenSet = false;                                 // Flag variable to track the token address\n', '\n', 'address public founderAddress;                                   // Founder address which will control the operations of the crowdsale\n', 'address public beneficiaryAddress;                               // Address where ETH get trasferred  \n', '\n', '/**\n', '    @note structure for keeping the weekly data to track\n', '    the week rate of the crowdsale\n', ' */\n', 'struct weeklyData {\n', '    uint256 startTime;\n', '    uint256 endTime;\n', '    uint32 weekRate;\n', '}\n', '\n', '// mapping is used to store the weeklyData corresponds to integer\n', 'mapping(uint256 => weeklyData) public weeklyRate;\n', '\n', '//Event \n', 'event LogWeekRate(uint32 _weekRate, uint256 _timestamp);\n', '\n', '// Modifier for validating the time lapse should between in start and end date\n', 'modifier isBetween() {\n', '    require(now >= startDate && now <= endDate);\n', '    _;\n', '}\n', '\n', '// Modifier for validating the msg.sender should be founder address\n', 'modifier onlyFounder() {\n', '    require(msg.sender == founderAddress);\n', '    _;\n', '}\n', '\n', '//Event \n', 'event TokenBought(address indexed _investor, uint256 _tokenQuantity);\n', '\n', '/**\n', '    @dev Fallback function\n', '    minimum 2,00,000 gas should be used at the time calling this function \n', ' */\n', '\n', 'function () public payable {\n', '    buyTokens(msg.sender);\n', '}\n', '\n', '/**\n', '    @dev Private function to set the weekly rate it called only once\n', '    in the constructor.\n', '    @return bool\n', ' */\n', '\n', 'function setWeeklyRate() private returns (bool) {\n', '    for (uint32 i = 0; i < 40; ++i) {\n', '        uint32 weekRate = tokenRate + appreciationRate * i;\n', '        uint256 weekStartTime = now + i * 1 weeks;\n', '        uint256 weekEndTime = now + (i+1) * 1 weeks;\n', '        weeklyRate[i] = weeklyData(weekStartTime, weekEndTime, weekRate);\n', '    }\n', '    return true;\n', '}\n', '\n', '/**\n', '    @dev Private function to get the weekly rate \n', '    as per the week no.\n', '    @return uint32\n', ' */\n', '\n', 'function getWeeklyRate() private returns (uint32) {\n', '   if (now <= weeklyRate[weekNo].endTime && now >= weeklyRate[weekNo].startTime) {\n', '       return weeklyRate[weekNo].weekRate;\n', '   } if (now <= weeklyRate[weekNo + 1].endTime && now >= weeklyRate[weekNo + 1].startTime ) {\n', '        weekNo = weekNo + 1;\n', '        setWeeklyAllocation();\n', '        return weeklyRate[weekNo + 1].weekRate;\n', '   } else {\n', '       uint256 increasedBy = now - startDate;\n', '       uint256 weekIncreasedBy = increasedBy.div(604800);    // 7 days seconds 7 * 24 * 60 * 60\n', '       setWeeklyAllocation();\n', '       weekNo = weekNo.add(weekIncreasedBy);\n', '       LogWeekRate(weeklyRate[weekNo].weekRate, now);\n', '       return weeklyRate[weekNo].weekRate;\n', '   }\n', '}\n', '\n', '// function to transfer the funds to founders account\n', 'function fundTransfer(uint256 weiAmount) internal {\n', '        beneficiaryAddress.transfer(weiAmount);\n', '    }\n', '\n', '/**\n', '    @dev Simple function to track the token allocation for a week\n', ' */\n', 'function setWeeklyAllocation() private {\n', '    tokenAllocatedForWeek = (tokenAllocatedForWeek + (tokenAllocatedForWeek - tokenSoldForWeek)).div(2);\n', '    tokenSoldForWeek = 0;\n', '}\n', '\n', '/**\n', '    @dev ANOCrowdsale constructor to set the founder and beneficiary\n', '    as well as to set start & end date.\n', '    @param _founderAddress address which operates all the admin functionality of the contract\n', '    @param _beneficiaryAddress address where all invested amount get transferred \n', ' */\n', '\n', 'function ANOCrowdsale (address _founderAddress, address _beneficiaryAddress) public {\n', '    startDate = now;\n', '    endDate = now + 40 weeks;\n', '    founderAddress = _founderAddress;\n', '    beneficiaryAddress = _beneficiaryAddress;\n', '    require(setWeeklyRate());\n', '    tokenAllocatedForWeek = allocatedToken.div(2);\n', '}\n', '\n', '/**\n', '    @dev `setTokenAddress` used to assign the token address into the variable\n', '    only be called by founder and called only once.\n', '    @param _tokenAddress address of the token which will be distributed using this crowdsale\n', '    @return bool\n', ' */\n', '\n', 'function setTokenAddress (address _tokenAddress) public onlyFounder returns (bool) {\n', '    require(isTokenSet == false);\n', '    token = ANOToken(_tokenAddress);\n', '    isTokenSet = !isTokenSet;\n', '    return true;\n', '}\n', '\n', '/**\n', '    @dev `buyTokens` function used to buy the token\n', '    @param _investor address of the investor where ROI will transferred\n', '    @return bool\n', ' */\n', '\n', 'function buyTokens(address _investor) \n', 'public \n', 'isBetween\n', 'payable\n', 'returns (bool) \n', '{\n', '   require(isTokenSet == true);\n', '   require(_investor != address(0));\n', '   uint256 rate = uint256(getWeeklyRate());\n', '   uint256 tokenAmount = (msg.value.div(rate)).mul(10 ** 8);\n', '   require(tokenAllocatedForWeek >= tokenSoldForWeek + tokenAmount);\n', '   fundTransfer(msg.value);\n', '   require(token.transfer(_investor, tokenAmount));\n', '   tokenSoldForWeek = tokenSoldForWeek.add(tokenAmount);\n', '   token.changeSupply(tokenAmount);\n', '   ethRaised = ethRaised.add(msg.value);\n', '   TokenBought(_investor, tokenAmount);\n', '   return true;\n', '}\n', '\n', '/**\n', '    @dev `getWeekNo` public function to get the current week no\n', ' */\n', '\n', 'function getWeekNo() public view returns (uint256) {\n', '    return weekNo;\n', '}\n', '\n', '/**\n', '    @dev `endCrowdfund` function used to end the crowdfund\n', '    called only by the founder and remiaining tokens get burned \n', ' */\n', '\n', 'function endCrowdfund() public onlyFounder returns (bool) {\n', '    require(isTokenSet == true);\n', '    require(now > endDate);\n', '    require(token.burnToken());\n', '    return true;\n', '}\n', '\n', '}']