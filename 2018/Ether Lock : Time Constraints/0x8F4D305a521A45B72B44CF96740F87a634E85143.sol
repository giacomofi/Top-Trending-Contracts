['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * SpaceWar\n', ' * ETH Idle Game\n', ' * spacewar.etherfun.net\n', ' */\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '}\n', '\n', 'library NumericSequence\n', '{\n', '    using SafeMath for uint256;\n', '    function sumOfN(uint256 basePrice, uint256 pricePerLevel, uint256 owned, uint256 count) internal pure returns (uint256 price)\n', '    {\n', '        require(count > 0);\n', '\n', '        price = 0;\n', '        price += SafeMath.mul((basePrice + pricePerLevel * owned), count);\n', '        price += pricePerLevel * (count.mul((count-1))) / 2;\n', '    }\n', '}\n', '\n', '//-----------------------------------------------------------------------\n', 'contract SpaceWar  {\n', '    using NumericSequence for uint;\n', '    using SafeMath for uint;\n', '\n', '    struct MinerData\n', '    {\n', '        uint256[9]   spaces; // space types and their upgrades\n', '        uint8[3]     hasUpgrade;\n', '        uint256      money;\n', '        uint256      lastUpdateTime;\n', '        uint256      premamentMineBonusPct;\n', '        uint256      unclaimedPot;\n', '        uint256      lastPotClaimIndex;\n', '    }\n', '\n', '    struct SpaceData\n', '    {\n', '        uint256 basePrice;\n', '        uint256 baseOutput;\n', '        uint256 pricePerLevel;\n', '        uint256 priceInETH;\n', '        uint256 limit;\n', '    }\n', '\n', '    struct BoostData\n', '    {\n', '        uint256 percentBonus;\n', '        uint256 priceInWEI;\n', '    }\n', '\n', '    struct PVPData\n', '    {\n', '        uint256[6] troops;\n', '        uint256    immunityTime;\n', '        uint256    exhaustTime;\n', '    }\n', '\n', '    struct TroopData\n', '    {\n', '        uint256 attackPower;\n', '        uint256 defensePower;\n', '        uint256 priceGold;\n', '        uint256 priceETH;\n', '    }\n', '\n', '    uint8 private constant NUMBER_OF_RIG_TYPES = 9;\n', '    SpaceData[9]  private spaceData;\n', '\n', '    uint8 private constant NUMBER_OF_UPGRADES = 3;\n', '    BoostData[3] private boostData;\n', '\n', '    uint8 private constant NUMBER_OF_TROOPS = 6;\n', '    uint8 private constant ATTACKER_START_IDX = 0;\n', '    uint8 private constant ATTACKER_END_IDX = 3;\n', '    uint8 private constant DEFENDER_START_IDX = 3;\n', '    uint8 private constant DEFENDER_END_IDX = 6;\n', '    TroopData[6] private troopData;\n', '\n', '    // honey pot variables\n', '    uint256 private honeyPotAmount;\n', '    uint256 private honeyPotSharePct; // 90%\n', '    uint256 private jackPot;\n', '    uint256 private devFund;\n', '    uint256 private nextPotDistributionTime;\n', '    mapping(address => mapping(uint256 => uint256)) private minerICOPerCycle;\n', '    uint256[] private honeyPotPerCycle;\n', '    uint256[] private globalICOPerCycle;\n', '    uint256 private cycleCount;\n', '\n', '    //booster info\n', '    uint256 private constant NUMBER_OF_BOOSTERS = 5;\n', '    uint256 private boosterIndex;\n', '    uint256 private nextBoosterPrice;\n', '    address[5] private boosterHolders;\n', '\n', '    mapping(address => MinerData) private miners;\n', '    mapping(address => PVPData)   private pvpMap;\n', '    mapping(uint256 => address)   private indexes;\n', '    uint256 private topindex;\n', '\n', '    address private owner;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    function SpaceWar() public {\n', '        owner = msg.sender;\n', '\n', '        //                   price,           prod.     upgrade,        priceETH, limit\n', '        spaceData[0] = SpaceData(500,             1,        5,               0,          999);\n', '        spaceData[1] = SpaceData(50000,           10,       500,             0,          999);\n', '        spaceData[2] = SpaceData(5000000,         100,      50000,           0,          999);\n', '        spaceData[3] = SpaceData(80000000,        1000,     800000,          0,          999);\n', '        spaceData[4] = SpaceData(500000000,       20000,    5000000,         0.01 ether, 999);\n', '        spaceData[5] = SpaceData(10000000000,     100000,   100000000,       0,          999);\n', '        spaceData[6] = SpaceData(100000000000,    1000000,  1000000000,      0,          999);\n', '        spaceData[7] = SpaceData(1000000000000,   50000000, 10000000000,     0.1 ether,  999);\n', '        spaceData[8] = SpaceData(10000000000000,  100000000,100000000000,    0,          999);\n', '\n', '        boostData[0] = BoostData(30,  0.01 ether);\n', '        boostData[1] = BoostData(50,  0.1 ether);\n', '        boostData[2] = BoostData(100, 1 ether);\n', '\n', '        topindex = 0;\n', '        honeyPotAmount = 0;\n', '        devFund = 0;\n', '        jackPot = 0;\n', '        nextPotDistributionTime = block.timestamp;\n', '        honeyPotSharePct = 90;\n', '\n', '        // has to be set to a value\n', '        boosterHolders[0] = owner;\n', '        boosterHolders[1] = owner;\n', '        boosterHolders[2] = owner;\n', '        boosterHolders[3] = owner;\n', '        boosterHolders[4] = owner;\n', '\n', '        boosterIndex = 0;\n', '        nextBoosterPrice = 0.1 ether;\n', '\n', '        //pvp\n', '        troopData[0] = TroopData(10,     0,      100000,   0);\n', '        troopData[1] = TroopData(1000,   0,      80000000, 0);\n', '        troopData[2] = TroopData(100000, 0,      1000000000,   0.01 ether);\n', '        troopData[3] = TroopData(0,      15,     100000,   0);\n', '        troopData[4] = TroopData(0,      1500,   80000000, 0);\n', '        troopData[5] = TroopData(0,      150000, 1000000000,   0.01 ether);\n', '\n', '        honeyPotPerCycle.push(0);\n', '        globalICOPerCycle.push(1);\n', '        cycleCount = 0;\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // Data access functions\n', '    //--------------------------------------------------------------------------\n', '    function GetMinerData(address minerAddr) public constant returns\n', '        (uint256 money, uint256 lastupdate, uint256 prodPerSec,\n', '         uint256[9] spaces, uint[3] upgrades, uint256 unclaimedPot, bool hasBooster, uint256 unconfirmedMoney)\n', '    {\n', '        uint8 i = 0;\n', '\n', '        money = miners[minerAddr].money;\n', '        lastupdate = miners[minerAddr].lastUpdateTime;\n', '        prodPerSec = GetProductionPerSecond(minerAddr);\n', '\n', '        for(i = 0; i < NUMBER_OF_RIG_TYPES; ++i)\n', '        {\n', '            spaces[i] = miners[minerAddr].spaces[i];\n', '        }\n', '\n', '        for(i = 0; i < NUMBER_OF_UPGRADES; ++i)\n', '        {\n', '            upgrades[i] = miners[minerAddr].hasUpgrade[i];\n', '        }\n', '\n', '        unclaimedPot = miners[minerAddr].unclaimedPot;\n', '        hasBooster = HasBooster(minerAddr);\n', '\n', '        unconfirmedMoney = money + (prodPerSec * (now - lastupdate));\n', '    }\n', '\n', '    function GetTotalMinerCount() public constant returns (uint256 count)\n', '    {\n', '        count = topindex;\n', '    }\n', '\n', '    function GetMinerAt(uint256 idx) public constant returns (address minerAddr)\n', '    {\n', '        require(idx < topindex);\n', '        minerAddr = indexes[idx];\n', '    }\n', '\n', '    function GetPotInfo() public constant returns (uint256 _honeyPotAmount, uint256 _devFunds, uint256 _jackPot, uint256 _nextDistributionTime)\n', '    {\n', '        _honeyPotAmount = honeyPotAmount;\n', '        _devFunds = devFund;\n', '        _jackPot = jackPot;\n', '        _nextDistributionTime = nextPotDistributionTime;\n', '    }\n', '\n', '    function GetProductionPerSecond(address minerAddr) public constant returns (uint256 personalProduction)\n', '    {\n', '        MinerData storage m = miners[minerAddr];\n', '\n', '        personalProduction = 0;\n', '        uint256 productionSpeed = 100 + m.premamentMineBonusPct;\n', '\n', '        if(HasBooster(minerAddr)) // 100% bonus\n', '            productionSpeed += 100;\n', '\n', '        for(uint8 j = 0; j < NUMBER_OF_RIG_TYPES; ++j)\n', '        {\n', '            personalProduction += m.spaces[j] * spaceData[j].baseOutput;\n', '        }\n', '\n', '        personalProduction = personalProduction * productionSpeed / 100;\n', '    }\n', '\n', '    function GetGlobalProduction() public constant returns (uint256 globalMoney, uint256 globalHashRate)\n', '    {\n', '        globalMoney = 0;\n', '        globalHashRate = 0;\n', '        uint i = 0;\n', '        for(i = 0; i < topindex; ++i)\n', '        {\n', '            MinerData storage m = miners[indexes[i]];\n', '            globalMoney += m.money;\n', '            globalHashRate += GetProductionPerSecond(indexes[i]);\n', '        }\n', '    }\n', '\n', '    function GetBoosterData() public constant returns (address[5] _boosterHolders, uint256 currentPrice, uint256 currentIndex)\n', '    {\n', '        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n', '        {\n', '            _boosterHolders[i] = boosterHolders[i];\n', '        }\n', '        currentPrice = nextBoosterPrice;\n', '        currentIndex = boosterIndex;\n', '    }\n', '\n', '    function HasBooster(address addr) public constant returns (bool hasBoost)\n', '    {\n', '        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n', '        {\n', '           if(boosterHolders[i] == addr)\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function GetPVPData(address addr) public constant returns (uint256 attackpower, uint256 defensepower, uint256 immunityTime, uint256 exhaustTime,\n', '    uint256[6] troops)\n', '    {\n', '        PVPData storage a = pvpMap[addr];\n', '\n', '        immunityTime = a.immunityTime;\n', '        exhaustTime = a.exhaustTime;\n', '\n', '        attackpower = 0;\n', '        defensepower = 0;\n', '        for(uint i = 0; i < NUMBER_OF_TROOPS; ++i)\n', '        {\n', '            attackpower  += a.troops[i] * troopData[i].attackPower;\n', '            defensepower += a.troops[i] * troopData[i].defensePower;\n', '\n', '            troops[i] = a.troops[i];\n', '        }\n', '    }\n', '\n', '    function GetCurrentICOCycle() public constant returns (uint256)\n', '    {\n', '        return cycleCount;\n', '    }\n', '\n', '    function GetICOData(uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOPot)\n', '    {\n', '        require(idx <= cycleCount);\n', '        ICOFund = globalICOPerCycle[idx];\n', '        if(idx < cycleCount)\n', '        {\n', '            ICOPot = honeyPotPerCycle[idx];\n', '        } else\n', '        {\n', '            ICOPot =  honeyPotAmount / 10; // actual day estimate\n', '        }\n', '    }\n', '\n', '    function GetMinerICOData(address miner, uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOShare, uint256 lastClaimIndex)\n', '    {\n', '        require(idx <= cycleCount);\n', '        ICOFund = minerICOPerCycle[miner][idx];\n', '        if(idx < cycleCount)\n', '        {\n', '            ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx];\n', '        } else\n', '        {\n', '            ICOShare = (honeyPotAmount / 10) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx];\n', '        }\n', '        lastClaimIndex = miners[miner].lastPotClaimIndex;\n', '    }\n', '\n', '    function GetMinerUnclaimedICOShare(address miner) public constant returns (uint256 unclaimedPot)\n', '    {\n', '        MinerData storage m = miners[miner];\n', '\n', '        require(m.lastUpdateTime != 0);\n', '        require(m.lastPotClaimIndex < cycleCount);\n', '\n', '        uint256 i = m.lastPotClaimIndex;\n', '        uint256 limit = cycleCount;\n', '\n', '        if((limit - i) > 30) // more than 30 iterations(days) afk\n', '            limit = i + 30;\n', '\n', '        unclaimedPot = 0;\n', '        for(; i < cycleCount; ++i)\n', '        {\n', '            if(minerICOPerCycle[miner][i] > 0)\n', '                unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[miner][i]) / globalICOPerCycle[i];\n', '        }\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // SpaceWars game handler functions\n', '    // -------------------------------------------------------------------------\n', '    function StartNewMiner() external\n', '    {\n', '        require(miners[msg.sender].lastUpdateTime == 0);\n', '\n', '        miners[msg.sender].lastUpdateTime = block.timestamp;\n', '        miners[msg.sender].money = 0;\n', '        miners[msg.sender].spaces[0] = 1;\n', '        miners[msg.sender].unclaimedPot = 0;\n', '        miners[msg.sender].lastPotClaimIndex = cycleCount;\n', '\n', '        pvpMap[msg.sender].immunityTime = block.timestamp + 14400;\n', '        pvpMap[msg.sender].exhaustTime  = block.timestamp;\n', '\n', '        indexes[topindex] = msg.sender;\n', '        ++topindex;\n', '    }\n', '\n', '    function UpgradeSpace(uint8 spaceIdx, uint16 count) external\n', '    {\n', '        require(spaceIdx < NUMBER_OF_RIG_TYPES);\n', '        require(count > 0);\n', '        require(count <= 999);\n', '        require(spaceData[spaceIdx].priceInETH == 0);\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\n', '\n', '        UpdateMoney();\n', '\n', '        // the base of geometrical sequence\n', '        uint256 price = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\n', '\n', '        require(m.money >= price);\n', '\n', '        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\n', '\n', '        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\n', '            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\n', '\n', '        m.money -= price;\n', '    }\n', '\n', '    function UpgradeSpaceETH(uint8 spaceIdx, uint256 count) external payable\n', '    {\n', '        require(spaceIdx < NUMBER_OF_RIG_TYPES);\n', '        require(count > 0);\n', '        require(count <= 999);\n', '        require(spaceData[spaceIdx].priceInETH > 0);\n', '\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\n', '\n', '        uint256 price = (spaceData[spaceIdx].priceInETH).mul(count);\n', '\n', '        uint256 priceCoin = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\n', '\n', '        UpdateMoney();\n', '        require(msg.value >= price);\n', '        require(m.money >= priceCoin);\n', '\n', '        BuyHandler(msg.value);\n', '\n', '        m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\n', '\n', '        if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\n', '            m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\n', '\n', '        m.money -= priceCoin;\n', '    }\n', '\n', '    function UpdateMoney() private\n', '    {\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '        require(block.timestamp >= miners[msg.sender].lastUpdateTime);\n', '\n', '        MinerData storage m = miners[msg.sender];\n', '        uint256 diff = block.timestamp - m.lastUpdateTime;\n', '        uint256 revenue = GetProductionPerSecond(msg.sender);\n', '\n', '        m.lastUpdateTime = block.timestamp;\n', '        if(revenue > 0)\n', '        {\n', '            revenue *= diff;\n', '\n', '            m.money += revenue;\n', '        }\n', '    }\n', '\n', '    function UpdateMoneyAt(address addr) private\n', '    {\n', '        require(miners[addr].lastUpdateTime != 0);\n', '        require(block.timestamp >= miners[addr].lastUpdateTime);\n', '\n', '        MinerData storage m = miners[addr];\n', '        uint256 diff = block.timestamp - m.lastUpdateTime;\n', '        uint256 revenue = GetProductionPerSecond(addr);\n', '\n', '        m.lastUpdateTime = block.timestamp;\n', '        if(revenue > 0)\n', '        {\n', '            revenue *= diff;\n', '\n', '            m.money += revenue;\n', '        }\n', '    }\n', '\n', '    function BuyUpgrade(uint256 idx) external payable\n', '    {\n', '        require(idx < NUMBER_OF_UPGRADES);\n', '        require(msg.value >= boostData[idx].priceInWEI);\n', '        require(miners[msg.sender].hasUpgrade[idx] == 0);\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '\n', '        BuyHandler(msg.value);\n', '\n', '        UpdateMoney();\n', '\n', '        miners[msg.sender].hasUpgrade[idx] = 1;\n', '        miners[msg.sender].premamentMineBonusPct +=  boostData[idx].percentBonus;\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // BOOSTER handlers\n', '    //--------------------------------------------------------------------------\n', '    function BuyBooster() external payable\n', '    {\n', '        require(msg.value >= nextBoosterPrice);\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '\n', '        for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n', '            if(boosterHolders[i] == msg.sender)\n', '                revert();\n', '\n', '        address beneficiary = boosterHolders[boosterIndex];\n', '\n', '        MinerData storage m = miners[beneficiary];\n', '\n', '        // 20% interest after 5 buys\n', '        m.unclaimedPot += (msg.value * 9403) / 10000;\n', '\n', '        // distribute the rest\n', '        honeyPotAmount += (msg.value * 597) / 20000;\n', '        devFund += (msg.value * 597) / 20000;\n', '\n', '        // increase price by 5%\n', '        nextBoosterPrice += nextBoosterPrice / 20;\n', '\n', '        UpdateMoney();\n', '        UpdateMoneyAt(beneficiary);\n', '\n', '        // transfer ownership\n', '        boosterHolders[boosterIndex] = msg.sender;\n', '\n', '        // increase booster index\n', '        boosterIndex += 1;\n', '        if(boosterIndex >= 5)\n', '            boosterIndex = 0;\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // PVP handler\n', '    //--------------------------------------------------------------------------\n', '    // 0 for attacker 1 for defender\n', '    function BuyTroop(uint256 idx, uint256 count) external payable\n', '    {\n', '        require(idx < NUMBER_OF_TROOPS);\n', '        require(count > 0);\n', '        require(count <= 1000);\n', '\n', '        PVPData storage pvp = pvpMap[msg.sender];\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        uint256 owned = pvp.troops[idx];\n', '\n', '        uint256 priceGold = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold / 100, owned, count);\n', '        uint256 priceETH = (troopData[idx].priceETH).mul(count);\n', '\n', '        UpdateMoney();\n', '\n', '        require(m.money >= priceGold);\n', '        require(msg.value >= priceETH);\n', '\n', '        if(priceGold > 0)\n', '            m.money -= priceGold;\n', '\n', '        if(msg.value > 0)\n', '            BuyHandler(msg.value);\n', '\n', '        pvp.troops[idx] += count;\n', '    }\n', '\n', '    function Attack(address defenderAddr) external\n', '    {\n', '        require(msg.sender != defenderAddr);\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '        require(miners[defenderAddr].lastUpdateTime != 0);\n', '\n', '        PVPData storage attacker = pvpMap[msg.sender];\n', '        PVPData storage defender = pvpMap[defenderAddr];\n', '        uint i = 0;\n', '        uint256 count = 0;\n', '\n', '        require(block.timestamp > attacker.exhaustTime);\n', '        require(block.timestamp > defender.immunityTime);\n', '\n', '        // the aggressor loses immunity\n', '        if(attacker.immunityTime > block.timestamp)\n', '            attacker.immunityTime = block.timestamp - 1;\n', '\n', '        attacker.exhaustTime = block.timestamp + 3600;\n', '\n', '        uint256 attackpower = 0;\n', '        uint256 defensepower = 0;\n', '        for(i = 0; i < ATTACKER_END_IDX; ++i)\n', '        {\n', '            attackpower  += attacker.troops[i] * troopData[i].attackPower;\n', '            defensepower += defender.troops[i + DEFENDER_START_IDX] * troopData[i + DEFENDER_START_IDX].defensePower;\n', '        }\n', '\n', '        if(attackpower > defensepower)\n', '        {\n', '            if(defender.immunityTime < block.timestamp + 14400)\n', '                defender.immunityTime = block.timestamp + 14400;\n', '\n', '            UpdateMoneyAt(defenderAddr);\n', '\n', '            MinerData storage m = miners[defenderAddr];\n', '            MinerData storage m2 = miners[msg.sender];\n', '            uint256 moneyStolen = m.money / 2;\n', '\n', '            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\n', '            {\n', '                defender.troops[i] = defender.troops[i]/2;\n', '            }\n', '\n', '            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\n', '            {\n', '                if(troopData[i].attackPower > 0)\n', '                {\n', '                    count = attacker.troops[i];\n', '\n', '                    // if the troops overpower the total defense power only a fraction is lost\n', '                    if((count * troopData[i].attackPower) > defensepower)\n', '                        {\n', '                            count = count * defensepower / attackpower / 2;\n', '                        }\n', '                    else\n', '                         {\n', '                             count =  count/2;\n', '                         }\n', '                    attacker.troops[i] = SafeMath.sub(attacker.troops[i],count);\n', '                    defensepower -= count * troopData[i].attackPower;\n', '                }\n', '            }\n', '\n', '            m.money -= moneyStolen;\n', '            m2.money += moneyStolen;\n', '        } else\n', '        {\n', '            for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\n', '            {\n', '                attacker.troops[i] = attacker.troops[i] / 2;\n', '            }\n', '\n', '            for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\n', '            {\n', '                if(troopData[i].defensePower > 0)\n', '                {\n', '                    count = defender.troops[i];\n', '\n', '                    // if the troops overpower the total defense power only a fraction is lost\n', '                    if((count * troopData[i].defensePower) > attackpower)\n', '                        count = count * attackpower / defensepower / 2;\n', '\n', '                    defender.troops[i] -= count;\n', '                    attackpower -= count * troopData[i].defensePower;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // ICO/Pot share functions\n', '    //--------------------------------------------------------------------------\n', '    function ReleaseICO() external\n', '    {\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '        require(nextPotDistributionTime <= block.timestamp);\n', '        require(honeyPotAmount > 0);\n', '        require(globalICOPerCycle[cycleCount] > 0);\n', '\n', '        nextPotDistributionTime = block.timestamp + 86400;\n', '\n', '        honeyPotPerCycle[cycleCount] = honeyPotAmount / 10; // 10% of the pot\n', '\n', '        honeyPotAmount -= honeyPotAmount / 10;\n', '\n', '        honeyPotPerCycle.push(0);\n', '        globalICOPerCycle.push(0);\n', '        cycleCount = cycleCount + 1;\n', '\n', '        MinerData storage jakpotWinner = miners[msg.sender];\n', '        jakpotWinner.unclaimedPot += jackPot;\n', '        jackPot = 0;\n', '    }\n', '\n', '    function FundICO(uint amount) external\n', '    {\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '        require(amount > 0);\n', '\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        UpdateMoney();\n', '\n', '        require(m.money >= amount);\n', '\n', '        m.money = (m.money).sub(amount);\n', '\n', '        globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint(amount));\n', '        minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint(amount));\n', '    }\n', '\n', '    function WithdrawICOEarnings() external\n', '    {\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        require(miners[msg.sender].lastUpdateTime != 0);\n', '        require(miners[msg.sender].lastPotClaimIndex < cycleCount);\n', '\n', '        uint256 i = m.lastPotClaimIndex;\n', '        uint256 limit = cycleCount;\n', '\n', '        if((limit - i) > 30) // more than 30 iterations(days) afk\n', '            limit = i + 30;\n', '\n', '        m.lastPotClaimIndex = limit;\n', '        for(; i < cycleCount; ++i)\n', '        {\n', '            if(minerICOPerCycle[msg.sender][i] > 0)\n', '                m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];\n', '        }\n', '    }\n', '\n', '    //--------------------------------------------------------------------------\n', '    // ETH handler functions\n', '    //--------------------------------------------------------------------------\n', '    function BuyHandler(uint amount) private\n', '    {\n', '        // add 90% to honeyPot\n', '        honeyPotAmount += (amount * honeyPotSharePct) / 100;\n', '        jackPot += amount / 100;\n', '        devFund += (amount * (100-(honeyPotSharePct+1))) / 100;\n', '    }\n', '\n', '    function WithdrawPotShare() public\n', '    {\n', '        MinerData storage m = miners[msg.sender];\n', '\n', '        require(m.unclaimedPot > 0);\n', '        require(m.lastUpdateTime != 0);\n', '\n', '        uint256 amntToSend = m.unclaimedPot;\n', '        m.unclaimedPot = 0;\n', '\n', '        if(msg.sender.send(amntToSend))\n', '        {\n', '            m.unclaimedPot = 0;\n', '        }\n', '    }\n', '\n', '    function WithdrawDevFunds() public\n', '    {\n', '        require(msg.sender == owner);\n', '\n', '        if(owner.send(devFund))\n', '        {\n', '            devFund = 0;\n', '        }\n', '    }\n', '\n', '    // fallback payment to pot\n', '    function() public payable {\n', '         devFund += msg.value;\n', '    }\n', '}']