['pragma solidity 0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath32 {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ether Habits\n', ' * @dev Implements the logic behind Ether Habits\n', ' */\n', 'contract Habits {\n', '    \n', '    using SafeMath for uint256;\n', '    using SafeMath32 for uint32;\n', '\n', '    // owner is only set on contract initialization, this cannot be changed\n', '    address internal owner;\n', '    mapping (address => bool) internal adminPermission;\n', '    \n', '    uint256 constant REGISTRATION_FEE = 0.005 ether;  // deposit for a single day\n', '    uint32 constant NUM_REGISTER_DAYS = 10;  // default number of days for registration\n', '    uint32 constant NINETY_DAYS = 90 days;\n', '    uint32 constant WITHDRAW_BUFFER = 129600;  // time before user can withdraw deposit\n', '    uint32 constant MAY_FIRST_2018 = 1525132800;\n', '    uint32 constant DAY = 86400;\n', '\n', '    enum UserEntryStatus {\n', '        NULL,\n', '        REGISTERED,\n', '        COMPLETED,\n', '        WITHDRAWN\n', '    }\n', '\n', '    struct DailyContestStatus {\n', '        uint256 numRegistered;\n', '        uint256 numCompleted;\n', '        bool operationFeeWithdrawn;\n', '    }\n', '\n', '    mapping (address => uint32[]) internal userToDates;\n', '    mapping (uint32 => address[]) internal dateToUsers;\n', '    mapping (address => mapping (uint32 => UserEntryStatus)) internal userDateToStatus;\n', '    mapping (uint32 => DailyContestStatus) internal dateToContestStatus;\n', '\n', '    event LogWithdraw(address user, uint256 amount);\n', '    event LogOperationFeeWithdraw(address user, uint256 amount);\n', '\n', '    /**\n', '     * @dev Sets the contract creator as the owner. Owner can&#39;t be changed in the future\n', '     */\n', '    function Habits() public {\n', '        owner = msg.sender;\n', '        adminPermission[owner] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Registers a user for NUM_REGISTER_DAYS days\n', '     * @notice Changes state\n', '     * @param _expectedStartDate (unix time: uint32) Start date the user had in mind when submitting the transaction\n', '     */\n', '    function register(uint32 _expectedStartDate) external payable {\n', '        // throw if sent ether doesn&#39;t match the total registration fee\n', '        require(REGISTRATION_FEE.mul(NUM_REGISTER_DAYS) == msg.value);\n', '\n', '        // can&#39;t register more than 100 days in advance\n', '        require(_expectedStartDate <= getDate(uint32(now)).add(NINETY_DAYS));\n', '\n', '        uint32 startDate = getStartDate();\n', '        // throw if actual start day doesn&#39;t match the user&#39;s expectation\n', '        // may happen if a transaction takes a while to get mined\n', '        require(startDate == _expectedStartDate);\n', '\n', '        for (uint32 i = 0; i < NUM_REGISTER_DAYS; i++) {\n', '            uint32 date = startDate.add(i.mul(DAY));\n', '\n', '            // double check that user already hasn&#39;t been registered\n', '            require(userDateToStatus[msg.sender][date] == UserEntryStatus.NULL);\n', '\n', '            userDateToStatus[msg.sender][date] = UserEntryStatus.REGISTERED;\n', '            userToDates[msg.sender].push(date);\n', '            dateToUsers[date].push(msg.sender);\n', '            dateToContestStatus[date].numRegistered += 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks-in a user for a given day\n', '     * @notice Changes state\n', '     */\n', '    function checkIn() external {\n', '        uint32 nowDate = getDate(uint32(now));\n', '\n', '        // throw if user entry status isn&#39;t registered\n', '        require(userDateToStatus[msg.sender][nowDate] == UserEntryStatus.REGISTERED);\n', '        userDateToStatus[msg.sender][nowDate] = UserEntryStatus.COMPLETED;\n', '        dateToContestStatus[nowDate].numCompleted += 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow users to withdraw deposit and bonus for checked-in dates\n', '     * @notice Changes state\n', '     * @param _dates Array of dates user wishes to withdraw for, this is\n', '     * calculated beforehand and verified in this method to reduce gas costs\n', '     */\n', '    function withdraw(uint32[] _dates) external {\n', '        uint256 withdrawAmount = 0;\n', '        uint256 datesLength = _dates.length;\n', '        uint32 now32 = uint32(now);\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = _dates[i];\n', '            // if it hasn&#39;t been more than 1.5 days since the entry, skip\n', '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '\n', '            // set status to WITHDRAWN to prevent re-entry\n', '            userDateToStatus[msg.sender][date] = UserEntryStatus.WITHDRAWN;\n', '            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\n', '        }\n', '\n', '        if (withdrawAmount > 0) {\n', '           msg.sender.transfer(withdrawAmount);\n', '        }\n', '        LogWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate current withdrawable amount for a user\n', '     * @notice Doesn&#39;t change state\n', '     * @return Amount of withdrawable Wei\n', '     */\n', '    function calculateWithdrawableAmount() external view returns (uint256) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', '        uint256 withdrawAmount = 0;\n', '        uint32 now32 = uint32(now);\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = dates[i];\n', '            // if it hasn&#39;t been more than 1.5 days since the entry, skip\n', '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\n', '        }\n', '\n', '        return withdrawAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate dates that a user can withdraw his/her deposit\n', '     * array may contain zeros so those need to be filtered out by the client\n', '     * @notice Doesn&#39;t change state\n', '     * @return Array of dates (unix time: uint32)\n', '     */\n', '    function getWithdrawableDates() external view returns(uint32[]) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', '        // We can&#39;t initialize a mutable array in memory, so creating an array\n', '        // with length set as the number of regsitered days\n', '        uint32[] memory withdrawableDates = new uint32[](datesLength);\n', '        uint256 index = 0;\n', '        uint32 now32 = uint32(now);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = dates[i];\n', '            // if it hasn&#39;t been more than 1.5 days since the entry, skip\n', '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '            withdrawableDates[index] = date;\n', '            index += 1;\n', '        }\n', '\n', '        // this array may contain zeroes at the end of the array\n', '        return withdrawableDates;\n', '    }\n', '\n', '    /**\n', '     * @dev Return registered days and statuses for a user\n', '     * @notice Doesn&#39;t change state\n', '     * @return Tupple of two arrays (dates registered, statuses)\n', '     */\n', '    function getUserEntryStatuses() external view returns (uint32[], uint32[]) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', '        uint32[] memory statuses = new uint32[](datesLength);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            statuses[i] = uint32(userDateToStatus[msg.sender][dates[i]]);\n', '        }\n', '        return (dates, statuses);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw operation fees for a list of dates\n', '     * @notice Changes state, owner only\n', '     * @param _dates Array of dates to withdraw operation fee\n', '     */\n', '    function withdrawOperationFees(uint32[] _dates) external {\n', '        // throw if sender isn&#39;t contract owner\n', '        require(msg.sender == owner);\n', '\n', '        uint256 withdrawAmount = 0;\n', '        uint256 datesLength = _dates.length;\n', '        uint32 now32 = uint32(now);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = _dates[i];\n', '            // if it hasn&#39;t been more than 1.5 days since the entry, skip\n', '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if already withdrawn for given date, skip\n', '            if (dateToContestStatus[date].operationFeeWithdrawn) {\n', '                continue;\n', '            }\n', '            // set operationFeeWithdrawn to true to prevent re-entry\n', '            dateToContestStatus[date].operationFeeWithdrawn = true;\n', '            withdrawAmount = withdrawAmount.add(calculateOperationFee(date));\n', '        }\n', '\n', '        if (withdrawAmount > 0) {\n', '            msg.sender.transfer(withdrawAmount);\n', '        }\n', '        LogOperationFeeWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Get total withdrawable operation fee amount and dates, owner only\n', '     * array may contain zeros so those need to be filtered out by the client\n', '     * @notice Doesn&#39;t change state\n', '     * @return Tuple(Array of dates (unix time: uint32), amount)\n', '     */\n', '    function getWithdrawableOperationFeeDatesAndAmount() external view returns (uint32[], uint256) {\n', '        // throw if sender isn&#39;t contract owner\n', '        if (msg.sender != owner) {\n', '            return (new uint32[](0), 0);\n', '        }\n', '\n', '        uint32 cutoffTime = uint32(now).sub(WITHDRAW_BUFFER);\n', '        uint32 maxLength = cutoffTime.sub(MAY_FIRST_2018).div(DAY).add(1);\n', '        uint32[] memory withdrawableDates = new uint32[](maxLength);\n', '        uint256 index = 0;\n', '        uint256 withdrawAmount = 0;\n', '        uint32 date = MAY_FIRST_2018;\n', '\n', '        while(date < cutoffTime) {\n', '            if (!dateToContestStatus[date].operationFeeWithdrawn) {\n', '                uint256 amount = calculateOperationFee(date);\n', '                if (amount > 0) {\n', '                    withdrawableDates[index] = date;\n', '                    withdrawAmount = withdrawAmount.add(amount);\n', '                    index += 1;\n', '                }\n', '            }\n', '            date = date.add(DAY);\n', '        } \n', '        return (withdrawableDates, withdrawAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Get contest status, only return complete and bonus numbers if it&#39;s been past the withdraw buffer\n', '     * Return -1 for complete and bonus numbers if still before withdraw buffer\n', '     * @notice Doesn&#39;t change state\n', '     * @param _date Date to get DailyContestStatus for\n', '     * @return Tuple(numRegistered, numCompleted, bonus)\n', '     */\n', '    function getContestStatusForDate(uint32 _date) external view returns (int256, int256, int256) {\n', '        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\n', '        int256 numRegistered = int256(dailyContestStatus.numRegistered);\n', '        int256 numCompleted = int256(dailyContestStatus.numCompleted);\n', '        int256 bonus = int256(calculateBonus(_date));\n', '\n', '        if (uint32(now) <= _date.add(WITHDRAW_BUFFER)) {\n', '            numCompleted = -1;\n', '            bonus = -1;\n', '        }\n', '        return (numRegistered, numCompleted, bonus);\n', '    }\n', '\n', '    /**\n', '     * @dev Get next valid start date.\n', '     * Tomorrow or the next non-registered date is the next start date\n', '     * @notice Doesn&#39;t change state\n', '     * @return Next start date (unix time: uint32)\n', '     */\n', '    function getStartDate() public view returns (uint32) {\n', '        uint32 startDate = getNextDate(uint32(now));\n', '        uint32 lastRegisterDate = getLastRegisterDate();\n', '        if (startDate <= lastRegisterDate) {\n', '            startDate = getNextDate(lastRegisterDate);\n', '        }\n', '        return startDate;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the next UTC midnight date\n', '     * @notice Doesn&#39;t change state\n', '     * @param _timestamp (unix time: uint32)\n', '     * @return Next date (unix time: uint32)\n', '     */\n', '    function getNextDate(uint32 _timestamp) internal pure returns (uint32) {\n', '        return getDate(_timestamp.add(DAY));\n', '    }\n', '\n', '    /**\n', '     * @dev Get the date floor (UTC midnight) for a given timestamp\n', '     * @notice Doesn&#39;t change state\n', '     * @param _timestamp (unix time: uint32)\n', '     * @return UTC midnight date (unix time: uint32)\n', '     */\n', '    function getDate(uint32 _timestamp) internal pure returns (uint32) {\n', '        return _timestamp.sub(_timestamp % DAY);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the last registered date for a user\n', '     * @notice Doesn&#39;t change state\n', '     * @return Last registered date (unix time: uint32), 0 if user has never registered\n', '     */\n', '    function getLastRegisterDate() internal view returns (uint32) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 pastRegisterCount = dates.length;\n', '\n', '        if(pastRegisterCount == 0) {\n', '            return 0;\n', '        }\n', '        return dates[pastRegisterCount.sub(1)];\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the bonus for a given day\n', '     * @notice Doesn&#39;t change state\n', '     * @param _date Date to calculate the bonus for (unix time: uint32)\n', '     * @return Bonus amount (unit256)\n', '     */ \n', '    function calculateBonus(uint32 _date) internal view returns (uint256) {\n', '        DailyContestStatus memory status = dateToContestStatus[_date];\n', '        if (status.numCompleted == 0) {\n', '            return 0;\n', '        }\n', '        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\n', '        // Split 90% of the forfeited deposits between completed users\n', '        return numFailed.mul(REGISTRATION_FEE).mul(9).div(\n', '            status.numCompleted.mul(10)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the operation fee for a given day\n', '     * @notice Doesn&#39;t change state\n', '     * @param _date Date to calculate the operation fee for (unix time: uint32)\n', '     * @return Operation fee amount (unit256)\n', '     */ \n', '    function calculateOperationFee(uint32 _date) internal view returns (uint256) {\n', '        DailyContestStatus memory status = dateToContestStatus[_date];\n', '        // if no one has completed, take all as operation fee\n', '        if (status.numCompleted == 0) {\n', '            return status.numRegistered.mul(REGISTRATION_FEE);\n', '        }\n', '        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\n', '        // 10% of forefeited deposits \n', '        return numFailed.mul(REGISTRATION_FEE).div(10);\n', '    }\n', '\n', '    /********************\n', '     * Admin only methods\n', '     ********************/\n', '\n', '    /**\n', '     * @dev Adding an admin, owner only\n', '     * @notice Changes state\n', '     * @param _newAdmin Address of new admin\n', '     */ \n', '    function addAdmin(address _newAdmin) external {\n', '        require(msg.sender == owner);\n', '        adminPermission[_newAdmin] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Return all registered dates for a user, admin only\n', '     * @notice Doesn&#39;t change state\n', '     * @param _user User to get dates for\n', '     * @return All dates(uint32[]) the user registered for\n', '     */ \n', '    function getDatesForUser(address _user) external view returns (uint32[]) {\n', '        if (!adminPermission[msg.sender]) {\n', '           return new uint32[](0); \n', '        }\n', '        return userToDates[_user];\n', '    }\n', '\n', '    /**\n', '     * @dev Return all registered users for a date, admin only\n', '     * @notice Doesn&#39;t change state\n', '     * @param _date Date to get users for\n', '     * @return All users(address[]) registered on a given date\n', '     */ \n', '    function getUsersForDate(uint32 _date) external view returns (address[]) {\n', '        if (!adminPermission[msg.sender]) {\n', '           return new address[](0); \n', '        }\n', '        return dateToUsers[_date];\n', '    }\n', '\n', '    /**\n', '     * @dev Return entry status for a user and date, admin only\n', '     * @notice Doesn&#39;t change state\n', '     * @param _user User to get EntryStatus for\n', '     * @param _date (unix time: uint32) Date to get EntryStatus for\n', '     * @return UserEntryStatus\n', '     */ \n', '    function getEntryStatus(address _user, uint32 _date)\n', '    external view returns (UserEntryStatus) {\n', '        if (!adminPermission[msg.sender]) {\n', '            return UserEntryStatus.NULL;\n', '        }\n', '        return userDateToStatus[_user][_date];\n', '    }\n', '\n', '    /**\n', '     * @dev Get daily contest status, admin only\n', '     * @notice Doesn&#39;t change state\n', '     * @param _date Date to get DailyContestStatus for\n', '     * @return Tuple(uint256, uint256, bool)\n', '     */\n', '    function getContestStatusForDateAdmin(uint32 _date)\n', '    external view returns (uint256, uint256, bool) {\n', '        if (!adminPermission[msg.sender]) {\n', '            return (0, 0, false);\n', '        }\n', '        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\n', '        return (\n', '            dailyContestStatus.numRegistered,\n', '            dailyContestStatus.numCompleted,\n', '            dailyContestStatus.operationFeeWithdrawn\n', '        );\n', '    }\n', '}']
['pragma solidity 0.4.23;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath32\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath32 {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint32 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint32 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '    uint32 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ether Habits\n', ' * @dev Implements the logic behind Ether Habits\n', ' */\n', 'contract Habits {\n', '    \n', '    using SafeMath for uint256;\n', '    using SafeMath32 for uint32;\n', '\n', '    // owner is only set on contract initialization, this cannot be changed\n', '    address internal owner;\n', '    mapping (address => bool) internal adminPermission;\n', '    \n', '    uint256 constant REGISTRATION_FEE = 0.005 ether;  // deposit for a single day\n', '    uint32 constant NUM_REGISTER_DAYS = 10;  // default number of days for registration\n', '    uint32 constant NINETY_DAYS = 90 days;\n', '    uint32 constant WITHDRAW_BUFFER = 129600;  // time before user can withdraw deposit\n', '    uint32 constant MAY_FIRST_2018 = 1525132800;\n', '    uint32 constant DAY = 86400;\n', '\n', '    enum UserEntryStatus {\n', '        NULL,\n', '        REGISTERED,\n', '        COMPLETED,\n', '        WITHDRAWN\n', '    }\n', '\n', '    struct DailyContestStatus {\n', '        uint256 numRegistered;\n', '        uint256 numCompleted;\n', '        bool operationFeeWithdrawn;\n', '    }\n', '\n', '    mapping (address => uint32[]) internal userToDates;\n', '    mapping (uint32 => address[]) internal dateToUsers;\n', '    mapping (address => mapping (uint32 => UserEntryStatus)) internal userDateToStatus;\n', '    mapping (uint32 => DailyContestStatus) internal dateToContestStatus;\n', '\n', '    event LogWithdraw(address user, uint256 amount);\n', '    event LogOperationFeeWithdraw(address user, uint256 amount);\n', '\n', '    /**\n', "     * @dev Sets the contract creator as the owner. Owner can't be changed in the future\n", '     */\n', '    function Habits() public {\n', '        owner = msg.sender;\n', '        adminPermission[owner] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Registers a user for NUM_REGISTER_DAYS days\n', '     * @notice Changes state\n', '     * @param _expectedStartDate (unix time: uint32) Start date the user had in mind when submitting the transaction\n', '     */\n', '    function register(uint32 _expectedStartDate) external payable {\n', "        // throw if sent ether doesn't match the total registration fee\n", '        require(REGISTRATION_FEE.mul(NUM_REGISTER_DAYS) == msg.value);\n', '\n', "        // can't register more than 100 days in advance\n", '        require(_expectedStartDate <= getDate(uint32(now)).add(NINETY_DAYS));\n', '\n', '        uint32 startDate = getStartDate();\n', "        // throw if actual start day doesn't match the user's expectation\n", '        // may happen if a transaction takes a while to get mined\n', '        require(startDate == _expectedStartDate);\n', '\n', '        for (uint32 i = 0; i < NUM_REGISTER_DAYS; i++) {\n', '            uint32 date = startDate.add(i.mul(DAY));\n', '\n', "            // double check that user already hasn't been registered\n", '            require(userDateToStatus[msg.sender][date] == UserEntryStatus.NULL);\n', '\n', '            userDateToStatus[msg.sender][date] = UserEntryStatus.REGISTERED;\n', '            userToDates[msg.sender].push(date);\n', '            dateToUsers[date].push(msg.sender);\n', '            dateToContestStatus[date].numRegistered += 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks-in a user for a given day\n', '     * @notice Changes state\n', '     */\n', '    function checkIn() external {\n', '        uint32 nowDate = getDate(uint32(now));\n', '\n', "        // throw if user entry status isn't registered\n", '        require(userDateToStatus[msg.sender][nowDate] == UserEntryStatus.REGISTERED);\n', '        userDateToStatus[msg.sender][nowDate] = UserEntryStatus.COMPLETED;\n', '        dateToContestStatus[nowDate].numCompleted += 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow users to withdraw deposit and bonus for checked-in dates\n', '     * @notice Changes state\n', '     * @param _dates Array of dates user wishes to withdraw for, this is\n', '     * calculated beforehand and verified in this method to reduce gas costs\n', '     */\n', '    function withdraw(uint32[] _dates) external {\n', '        uint256 withdrawAmount = 0;\n', '        uint256 datesLength = _dates.length;\n', '        uint32 now32 = uint32(now);\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = _dates[i];\n', "            // if it hasn't been more than 1.5 days since the entry, skip\n", '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '\n', '            // set status to WITHDRAWN to prevent re-entry\n', '            userDateToStatus[msg.sender][date] = UserEntryStatus.WITHDRAWN;\n', '            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\n', '        }\n', '\n', '        if (withdrawAmount > 0) {\n', '           msg.sender.transfer(withdrawAmount);\n', '        }\n', '        LogWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate current withdrawable amount for a user\n', "     * @notice Doesn't change state\n", '     * @return Amount of withdrawable Wei\n', '     */\n', '    function calculateWithdrawableAmount() external view returns (uint256) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', '        uint256 withdrawAmount = 0;\n', '        uint32 now32 = uint32(now);\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = dates[i];\n', "            // if it hasn't been more than 1.5 days since the entry, skip\n", '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '            withdrawAmount = withdrawAmount.add(REGISTRATION_FEE).add(calculateBonus(date));\n', '        }\n', '\n', '        return withdrawAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate dates that a user can withdraw his/her deposit\n', '     * array may contain zeros so those need to be filtered out by the client\n', "     * @notice Doesn't change state\n", '     * @return Array of dates (unix time: uint32)\n', '     */\n', '    function getWithdrawableDates() external view returns(uint32[]) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', "        // We can't initialize a mutable array in memory, so creating an array\n", '        // with length set as the number of regsitered days\n', '        uint32[] memory withdrawableDates = new uint32[](datesLength);\n', '        uint256 index = 0;\n', '        uint32 now32 = uint32(now);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = dates[i];\n', "            // if it hasn't been more than 1.5 days since the entry, skip\n", '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if the entry status is anything other than COMPLETED, skip\n', '            if (userDateToStatus[msg.sender][date] != UserEntryStatus.COMPLETED) {\n', '                continue;\n', '            }\n', '            withdrawableDates[index] = date;\n', '            index += 1;\n', '        }\n', '\n', '        // this array may contain zeroes at the end of the array\n', '        return withdrawableDates;\n', '    }\n', '\n', '    /**\n', '     * @dev Return registered days and statuses for a user\n', "     * @notice Doesn't change state\n", '     * @return Tupple of two arrays (dates registered, statuses)\n', '     */\n', '    function getUserEntryStatuses() external view returns (uint32[], uint32[]) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 datesLength = dates.length;\n', '        uint32[] memory statuses = new uint32[](datesLength);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            statuses[i] = uint32(userDateToStatus[msg.sender][dates[i]]);\n', '        }\n', '        return (dates, statuses);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw operation fees for a list of dates\n', '     * @notice Changes state, owner only\n', '     * @param _dates Array of dates to withdraw operation fee\n', '     */\n', '    function withdrawOperationFees(uint32[] _dates) external {\n', "        // throw if sender isn't contract owner\n", '        require(msg.sender == owner);\n', '\n', '        uint256 withdrawAmount = 0;\n', '        uint256 datesLength = _dates.length;\n', '        uint32 now32 = uint32(now);\n', '\n', '        for (uint256 i = 0; i < datesLength; i++) {\n', '            uint32 date = _dates[i];\n', "            // if it hasn't been more than 1.5 days since the entry, skip\n", '            if (now32 <= date.add(WITHDRAW_BUFFER)) {\n', '                continue;\n', '            }\n', '            // if already withdrawn for given date, skip\n', '            if (dateToContestStatus[date].operationFeeWithdrawn) {\n', '                continue;\n', '            }\n', '            // set operationFeeWithdrawn to true to prevent re-entry\n', '            dateToContestStatus[date].operationFeeWithdrawn = true;\n', '            withdrawAmount = withdrawAmount.add(calculateOperationFee(date));\n', '        }\n', '\n', '        if (withdrawAmount > 0) {\n', '            msg.sender.transfer(withdrawAmount);\n', '        }\n', '        LogOperationFeeWithdraw(msg.sender, withdrawAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Get total withdrawable operation fee amount and dates, owner only\n', '     * array may contain zeros so those need to be filtered out by the client\n', "     * @notice Doesn't change state\n", '     * @return Tuple(Array of dates (unix time: uint32), amount)\n', '     */\n', '    function getWithdrawableOperationFeeDatesAndAmount() external view returns (uint32[], uint256) {\n', "        // throw if sender isn't contract owner\n", '        if (msg.sender != owner) {\n', '            return (new uint32[](0), 0);\n', '        }\n', '\n', '        uint32 cutoffTime = uint32(now).sub(WITHDRAW_BUFFER);\n', '        uint32 maxLength = cutoffTime.sub(MAY_FIRST_2018).div(DAY).add(1);\n', '        uint32[] memory withdrawableDates = new uint32[](maxLength);\n', '        uint256 index = 0;\n', '        uint256 withdrawAmount = 0;\n', '        uint32 date = MAY_FIRST_2018;\n', '\n', '        while(date < cutoffTime) {\n', '            if (!dateToContestStatus[date].operationFeeWithdrawn) {\n', '                uint256 amount = calculateOperationFee(date);\n', '                if (amount > 0) {\n', '                    withdrawableDates[index] = date;\n', '                    withdrawAmount = withdrawAmount.add(amount);\n', '                    index += 1;\n', '                }\n', '            }\n', '            date = date.add(DAY);\n', '        } \n', '        return (withdrawableDates, withdrawAmount);\n', '    }\n', '\n', '    /**\n', "     * @dev Get contest status, only return complete and bonus numbers if it's been past the withdraw buffer\n", '     * Return -1 for complete and bonus numbers if still before withdraw buffer\n', "     * @notice Doesn't change state\n", '     * @param _date Date to get DailyContestStatus for\n', '     * @return Tuple(numRegistered, numCompleted, bonus)\n', '     */\n', '    function getContestStatusForDate(uint32 _date) external view returns (int256, int256, int256) {\n', '        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\n', '        int256 numRegistered = int256(dailyContestStatus.numRegistered);\n', '        int256 numCompleted = int256(dailyContestStatus.numCompleted);\n', '        int256 bonus = int256(calculateBonus(_date));\n', '\n', '        if (uint32(now) <= _date.add(WITHDRAW_BUFFER)) {\n', '            numCompleted = -1;\n', '            bonus = -1;\n', '        }\n', '        return (numRegistered, numCompleted, bonus);\n', '    }\n', '\n', '    /**\n', '     * @dev Get next valid start date.\n', '     * Tomorrow or the next non-registered date is the next start date\n', "     * @notice Doesn't change state\n", '     * @return Next start date (unix time: uint32)\n', '     */\n', '    function getStartDate() public view returns (uint32) {\n', '        uint32 startDate = getNextDate(uint32(now));\n', '        uint32 lastRegisterDate = getLastRegisterDate();\n', '        if (startDate <= lastRegisterDate) {\n', '            startDate = getNextDate(lastRegisterDate);\n', '        }\n', '        return startDate;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the next UTC midnight date\n', "     * @notice Doesn't change state\n", '     * @param _timestamp (unix time: uint32)\n', '     * @return Next date (unix time: uint32)\n', '     */\n', '    function getNextDate(uint32 _timestamp) internal pure returns (uint32) {\n', '        return getDate(_timestamp.add(DAY));\n', '    }\n', '\n', '    /**\n', '     * @dev Get the date floor (UTC midnight) for a given timestamp\n', "     * @notice Doesn't change state\n", '     * @param _timestamp (unix time: uint32)\n', '     * @return UTC midnight date (unix time: uint32)\n', '     */\n', '    function getDate(uint32 _timestamp) internal pure returns (uint32) {\n', '        return _timestamp.sub(_timestamp % DAY);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the last registered date for a user\n', "     * @notice Doesn't change state\n", '     * @return Last registered date (unix time: uint32), 0 if user has never registered\n', '     */\n', '    function getLastRegisterDate() internal view returns (uint32) {\n', '        uint32[] memory dates = userToDates[msg.sender];\n', '        uint256 pastRegisterCount = dates.length;\n', '\n', '        if(pastRegisterCount == 0) {\n', '            return 0;\n', '        }\n', '        return dates[pastRegisterCount.sub(1)];\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the bonus for a given day\n', "     * @notice Doesn't change state\n", '     * @param _date Date to calculate the bonus for (unix time: uint32)\n', '     * @return Bonus amount (unit256)\n', '     */ \n', '    function calculateBonus(uint32 _date) internal view returns (uint256) {\n', '        DailyContestStatus memory status = dateToContestStatus[_date];\n', '        if (status.numCompleted == 0) {\n', '            return 0;\n', '        }\n', '        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\n', '        // Split 90% of the forfeited deposits between completed users\n', '        return numFailed.mul(REGISTRATION_FEE).mul(9).div(\n', '            status.numCompleted.mul(10)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the operation fee for a given day\n', "     * @notice Doesn't change state\n", '     * @param _date Date to calculate the operation fee for (unix time: uint32)\n', '     * @return Operation fee amount (unit256)\n', '     */ \n', '    function calculateOperationFee(uint32 _date) internal view returns (uint256) {\n', '        DailyContestStatus memory status = dateToContestStatus[_date];\n', '        // if no one has completed, take all as operation fee\n', '        if (status.numCompleted == 0) {\n', '            return status.numRegistered.mul(REGISTRATION_FEE);\n', '        }\n', '        uint256 numFailed = status.numRegistered.sub(status.numCompleted);\n', '        // 10% of forefeited deposits \n', '        return numFailed.mul(REGISTRATION_FEE).div(10);\n', '    }\n', '\n', '    /********************\n', '     * Admin only methods\n', '     ********************/\n', '\n', '    /**\n', '     * @dev Adding an admin, owner only\n', '     * @notice Changes state\n', '     * @param _newAdmin Address of new admin\n', '     */ \n', '    function addAdmin(address _newAdmin) external {\n', '        require(msg.sender == owner);\n', '        adminPermission[_newAdmin] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Return all registered dates for a user, admin only\n', "     * @notice Doesn't change state\n", '     * @param _user User to get dates for\n', '     * @return All dates(uint32[]) the user registered for\n', '     */ \n', '    function getDatesForUser(address _user) external view returns (uint32[]) {\n', '        if (!adminPermission[msg.sender]) {\n', '           return new uint32[](0); \n', '        }\n', '        return userToDates[_user];\n', '    }\n', '\n', '    /**\n', '     * @dev Return all registered users for a date, admin only\n', "     * @notice Doesn't change state\n", '     * @param _date Date to get users for\n', '     * @return All users(address[]) registered on a given date\n', '     */ \n', '    function getUsersForDate(uint32 _date) external view returns (address[]) {\n', '        if (!adminPermission[msg.sender]) {\n', '           return new address[](0); \n', '        }\n', '        return dateToUsers[_date];\n', '    }\n', '\n', '    /**\n', '     * @dev Return entry status for a user and date, admin only\n', "     * @notice Doesn't change state\n", '     * @param _user User to get EntryStatus for\n', '     * @param _date (unix time: uint32) Date to get EntryStatus for\n', '     * @return UserEntryStatus\n', '     */ \n', '    function getEntryStatus(address _user, uint32 _date)\n', '    external view returns (UserEntryStatus) {\n', '        if (!adminPermission[msg.sender]) {\n', '            return UserEntryStatus.NULL;\n', '        }\n', '        return userDateToStatus[_user][_date];\n', '    }\n', '\n', '    /**\n', '     * @dev Get daily contest status, admin only\n', "     * @notice Doesn't change state\n", '     * @param _date Date to get DailyContestStatus for\n', '     * @return Tuple(uint256, uint256, bool)\n', '     */\n', '    function getContestStatusForDateAdmin(uint32 _date)\n', '    external view returns (uint256, uint256, bool) {\n', '        if (!adminPermission[msg.sender]) {\n', '            return (0, 0, false);\n', '        }\n', '        DailyContestStatus memory dailyContestStatus = dateToContestStatus[_date];\n', '        return (\n', '            dailyContestStatus.numRegistered,\n', '            dailyContestStatus.numCompleted,\n', '            dailyContestStatus.operationFeeWithdrawn\n', '        );\n', '    }\n', '}']
