['pragma solidity ^0.4.18;\n', '\n', 'contract Blockeds {\n', '  mapping (address => bool) blocked;\n', '\n', '  event Blocked(address _addr);\n', '  event Unblocked(address _addr);\n', '\n', '  function blockAddress(address _addr) public {\n', '    require(!blocked[_addr]);\n', '    blocked[_addr] = true;\n', '\n', '    Blocked(_addr);\n', '  }\n', '\n', '  function unblockAddress(address _addr) public {\n', '    require(blocked[_addr]);\n', '    blocked[_addr] = false;\n', '\n', '    Unblocked(_addr);\n', '  }\n', '}\n', '\n', '/*\n', '    저작권 2016, Jordi Baylina\n', '\n', '    이 프로그램은 무료 소프트웨어입니다.\n', '    이 프로그램은 Free Soft ware Foundation에서\n', '    게시하는 GNU General Public License의\n', '    조건에 따라 라이센스의 버전 3또는(선택 사항으로)\n', '    이후 버전으로 재배포 및 또는 수정할 수 있습니다.\n', '\n', '    이 프로그램은 유용할 것을 기대하여 배포되지만,\n', '    상품성이나 특정 목적에 대한 적합성의 묵시적\n', '    보증도 없이 모든 보증 없이 제공됩니다.\n', '    자세한 내용은 GNU General Public License를 참조하십시오.\n', '\n', '    이 프로그램과 함께 GNU General Public License 사본을 받아야합니다.\n', '    그렇지 않으면, 참조 : <http://www.gnu.org/licenses/>\n', ' */\n', '\n', '/*\n', ' * @title MiniMeToken\n', ' * @author Jordi Baylina\n', ' * @dev 이 토큰 계약의 목표는 이 토큰을 손쉽게 복제하는 것입니다.\n', ' *      토큰을 사용하면 지정된 블록에서 DAO 및 DApps가 원래 토큰에 영향을 주지 않고 기능을 분산된 방식으로 업그레이드할 수 있습니다.\n', ' * @dev ERC20과 호환되지만 추가 테스트를 진행해야합니다.\n', '*/\n', 'contract Controlled {\n', '    // 컨트롤러의 주소는 이 수정 프로그램으로 함수를 호출할 수 있는 유일한 주소입니다.\n', '    modifier onlyController { require(msg.sender == controller); _; }\n', '\n', '    address public controller;\n', '\n', '    function Controlled() public { controller = msg.sender;}\n', '\n', '    //                계약 당사자\n', '    // _newController 새로운 계약자\n', '    function changeController(address _newController) public onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', '\n', '\n', '// 토큰 컨트롤러 계약에서 이러한 기능을 구현해야 합니다.\n', 'contract TokenController {\n', '    // @notice `_owner`가 이더리움을 MiniMeToken 계약에 보낼 때 호출됩니다.\n', '    // @param   _owner 토큰을 생성하기 위해 이더리움을 보낸 주소\n', '    // @return         이더리움이 정상 전송되는 경우는 true, 아닌 경우는 false\n', '    function proxyPayment(address _owner) public payable returns(bool);\n', '\n', '    // @notice         컨트롤러에 토큰 전송에 대해 알립니다.\n', '    //                 원하는 경우 반응하는 컨트롤러\n', '    // @param _from    전송의 출처\n', '    // @param _to      전송 목적지\n', '    // @param _amount  전송 금액\n', '    // @return         컨트롤러가 전송을 승인하지 않는 경우 거짓\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '    // @notice                     컨트롤러에 승인 사실을 알리고, 필요한 경우 컨트롤러가 대응하도록 합니다.\n', '    // @param _owner `approve ()`  를 호출하는 주소.\n', '    // @param _spender `approve()` 호출하는 전송자\n', '    // @param _amount `approve ()` 호출의 양\n', '    // @return                     컨트롤러가 승인을 허가하지 않는 경우 거짓\n', '    function onApprove(address _owner, address _spender, uint _amount) public\n', '        returns(bool);\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '// 실제 토큰 계약인 기본 컨트롤러는 계약서를 배포하는 msg.sender이므로\n', '// 이 토큰은 대개 토큰 컨트롤러 계약에 의해 배포되며,\n', '// Giveth는 "Campaign"을 호출합니다.\n', 'contract MiniMeToken is Controlled {\n', '    string public name;                // 토큰 이름 : EX DigixDAO token\n', '    uint8 public decimals;             // 최소 단위의 소수 자릿수\n', '    string public symbol;              // 식별자 EX : e.g. REP\n', "    string public version = 'MMT_0.2'; // 버전 관리 방식\n", '\n', '\n', '    // @dev `Checkpoint` 블록 번호를 지정된 값에 연결하는 구조이며,\n', '    //                    첨부된 블록 번호는 마지막으로 값을 변경한 번호입니다.\n', '    struct  Checkpoint {\n', '\n', '        // `fromBlock` 값이 생성된 블록 번호입니다.\n', '        uint128 fromBlock;\n', '\n', '        // `value` 특정 블록 번호의 토큰 양입니다.\n', '        uint128 value;\n', '    }\n', '\n', '    // `parentToken` 이 토큰을 생성하기 위해 복제 된 토큰 주소입니다.\n', '    //               복제되지 않은 토큰의 경우 0x0이 됩니다.\n', '    MiniMeToken public parentToken;\n', '\n', '    // `parentSnapShotBlock` 상위 토큰의 블록 번호로,\n', '    //                       복제 토큰의 초기 배포를 결정하는 데 사용됨\n', '    uint public parentSnapShotBlock;\n', '\n', '    // `creationBlock` 복제 토큰이 생성된 블록 번호입니다.\n', '    uint public creationBlock;\n', '\n', '    // `balances` 이 계약에서 잔액이 변경될 때 변경 사항이 발생한\n', '    //            블록 번호도 맵에 포함되어 있으며 각 주소의 잔액을 추적하는 맵입니다.\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '    // `allowed` 모든 ERC20 토큰에서와 같이 추가 전송 권한을 추적합니다.\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // 토큰의 `totalSupply` 기록을 추적합니다.\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', '    // 토큰이 전송 가능한지 여부를 결정하는 플래그 입니다.\n', '    bool public transfersEnabled;\n', '\n', '    // 새 복제 토큰을 만드는 데 사용 된 팩토리\n', '    MiniMeTokenFactory public tokenFactory;\n', '\n', '    /*\n', '     * 건설자\n', '     */\n', '    // @notice MiniMeToken을 생성하는 생성자\n', '    // @param _tokenFactory MiniMeTokenFactory 계약의 주소\n', '    //                               복제 토큰 계약을 생성하는 MiniMeTokenFactory 계약의 주소,\n', '    //                               먼저 토큰 팩토리를 배포해야합니다.\n', '    // @param _parentToken           상위 토큰의 ParentTokerut 주소 (새 토큰인 경우 0x0으로 설정됨)\n', '    // @param _parentSnapShotBlock   복제 토큰의 초기 배포를 결정할 상위 토큰의 블록(새 토큰인 경우 0으로 설정됨)\n', '    // @param _tokenName             새 토큰의 이름\n', '    // @param _decimalUnits          새 토큰의 소수 자릿수\n', '    // @param _tokenSymbol           새 토큰에 대한 토큰 기호\n', '    // @param _transfersEnabled true 이면 토큰을 전송할 수 있습니다.\n', '    function MiniMeToken(\n', '        address _tokenFactory,\n', '        address _parentToken,\n', '        uint _parentSnapShotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) public {\n', '        tokenFactory = MiniMeTokenFactory(_tokenFactory);\n', '        name = _tokenName;                                 // 이름 설정\n', '        decimals = _decimalUnits;                          // 십진수 설정\n', '        symbol = _tokenSymbol;                             // 기호 설정 (심볼)\n', '        parentToken = MiniMeToken(_parentToken);\n', '        parentSnapShotBlock = _parentSnapShotBlock;\n', '        transfersEnabled = _transfersEnabled;\n', '        creationBlock = block.number;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        doTransfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '        if (msg.sender != controller) {\n', '            require(transfersEnabled);\n', '\n', '            require(allowed[_from][msg.sender] >= _amount);\n', '            allowed[_from][msg.sender] -= _amount;\n', '        }\n', '        doTransfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function doTransfer(address _from, address _to, uint _amount\n', '    ) internal {\n', '\n', '           if (_amount == 0) {\n', '               Transfer(_from, _to, _amount);\n', '               return;\n', '           }\n', '\n', '           require(parentSnapShotBlock < block.number);\n', '\n', '           require((_to != 0) && (_to != address(this)));\n', '\n', '           var previousBalanceFrom = balanceOfAt(_from, block.number);\n', '\n', '           require(previousBalanceFrom >= _amount);\n', '\n', '           if (isContract(controller)) {\n', '               require(TokenController(controller).onTransfer(_from, _to, _amount));\n', '           }\n', '\n', '           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '           var previousBalanceTo = balanceOfAt(_to, block.number);\n', '           require(previousBalanceTo + _amount >= previousBalanceTo);\n', '           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '           Transfer(_from, _to, _amount);\n', '\n', '    }\n', '\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        // 승인 기능 호출의 토큰 컨트롤러에 알림\n', '        if (isContract(controller)) {\n', '            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender\n', '    ) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) public returns (bool success) {\n', '        require(approve(_spender, _amount));\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '\n', '    /*\n', '     * 히스토리 내 쿼리 균형 및 총 공급\n', '     */\n', '    function balanceOfAt(address _owner, uint _blockNumber) public constant\n', '        returns (uint) {\n', '\n', '        if ((balances[_owner].length == 0)\n', '            || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                // 상위토큰이 없다.\n', '                return 0;\n', '            }\n', '        } else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '        if ((totalSupplyHistory.length == 0)\n', '            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '        } else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '    /*\n', '     * 토큰 복제 방법\n', '     */\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '        ) public returns(address) {\n', '        if (_snapshotBlock == 0) _snapshotBlock = block.number;\n', '        MiniMeToken cloneToken = tokenFactory.createCloneToken(\n', '            this,\n', '            _snapshotBlock,\n', '            _cloneTokenName,\n', '            _cloneDecimalUnits,\n', '            _cloneTokenSymbol,\n', '            _transfersEnabled\n', '            );\n', '\n', '        cloneToken.changeController(msg.sender);\n', '\n', '        NewCloneToken(address(cloneToken), _snapshotBlock);\n', '        return address(cloneToken);\n', '    }\n', '\n', '    /*\n', '     * 토큰 생성 및 소각\n', '     */\n', '    function generateTokens(address _owner, uint _amount\n', '    ) public onlyController returns (bool) {\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _amount >= curTotalSupply);\n', '        uint previousBalanceTo = balanceOf(_owner);\n', '        require(previousBalanceTo + _amount >= previousBalanceTo);\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '        Transfer(0, _owner, _amount);\n', '        return true;\n', '    }\n', '\n', '    function destroyTokens(address _owner, uint _amount\n', '    ) onlyController public returns (bool) {\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply >= _amount);\n', '        uint previousBalanceFrom = balanceOf(_owner);\n', '        require(previousBalanceFrom >= _amount);\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n', '        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n', '        Transfer(_owner, 0, _amount);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '     * 토큰 전송 사용\n', '     */\n', '    function enableTransfers(bool _transfersEnabled) public onlyController {\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '    /*\n', '     * 스냅 샷 배열에서 값을 쿼리하고 설정하는 내부 도우미 함수\n', '     */\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n', '    ) constant internal returns (uint) {\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        // 실제 값 바로 가기\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '            return checkpoints[checkpoints.length-1].value;\n', '        if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '        // 배열의 값을 2진 검색\n', '        uint min = 0;\n', '        uint max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1)/ 2;\n', '            if (checkpoints[mid].fromBlock<=_block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n', '    ) internal  {\n', '        if ((checkpoints.length == 0)\n', '        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '               newCheckPoint.fromBlock =  uint128(block.number);\n', '               newCheckPoint.value = uint128(_value);\n', '           } else {\n', '               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '               oldCheckPoint.value = uint128(_value);\n', '           }\n', '    }\n', '\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', '    function min(uint a, uint b) pure internal returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function () public payable {\n', '        require(isContract(controller));\n', '        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n', '    }\n', '\n', '    /*\n', '     * 안전 방법\n', '     */\n', '    function claimTokens(address _token) public onlyController {\n', '        if (_token == 0x0) {\n', '            controller.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        MiniMeToken token = MiniMeToken(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '        ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '    /*\n', '     * 이벤트\n', '     */\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount\n', '        );\n', '}\n', '\n', '/*\n', ' * MiniMeTokenFactory\n', ' */\n', '// 이 계약은 계약에서 복제 계약을 생성하는 데 사용됩니다.\n', 'contract MiniMeTokenFactory {\n', '    //                      새로운 기능으로 새로운 토큰을 만들어 DApp를 업데이트하십시오.\n', '    //  msg.sender          는 이 복제 토큰의 컨트롤러가됩니다.\n', '    // _parentToken         복제 될 토큰의 주소\n', '    // _snapshotBlock       상위 토큰 블록\n', '    //                      복제 토큰의 초기 배포 결정\n', '    // _tokenName           새 토큰의 이름\n', '    // @param _decimalUnits 새 토큰의 소수 자릿수\n', '    // @param _tokenSymbol  새 토큰에 대한 토큰 기호\n', '    // @param _transfersEnabled true 이면 토큰을 전송할 수 있습니다.\n', '    // @return              새 토큰 계약의 주소\n', '    function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) public returns (MiniMeToken) {\n', '        MiniMeToken newToken = new MiniMeToken(\n', '            this,\n', '            _parentToken,\n', '            _snapshotBlock,\n', '            _tokenName,\n', '            _decimalUnits,\n', '            _tokenSymbol,\n', '            _transfersEnabled\n', '            );\n', '\n', '        newToken.changeController(msg.sender);\n', '        return newToken;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title LEN\n', ' * @dev LEN는 MiniMeToken을 상속받은 ERC20 토큰 계약입니다.\n', ' */\n', 'contract LEN is MiniMeToken, Blockeds {\n', '  bool public StorageEnabled = true;\n', '\n', '  modifier onlyStorageEnabled() {\n', '    require(StorageEnabled);\n', '    _;\n', '  }\n', '\n', '  modifier onlyNotBlocked(address _addr) {\n', '    require(!blocked[_addr]);\n', '    _;\n', '  }\n', '\n', '  event StorageEnabled(bool _StorageEnabled);\n', '\n', '  function LEN(address _tokenFactory) MiniMeToken(\n', '    _tokenFactory,\n', '    0x0,                  // 부모 토큰 없음\n', '    0,                    // 상위의 스냅 샷 블록 번호 없음\n', '    "Lending Token",      // 토큰 이름\n', '    18,                   // 십진법\n', '    "LEN",                // 상징(심볼)\n', '    false                 // 전송 사용\n', '  ) public {}\n', '\n', '  function transfer(address _to, uint256 _amount) public onlyNotBlocked(msg.sender) returns (bool success) {\n', '    return super.transfer(_to, _amount);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amount) public onlyNotBlocked(_from) returns (bool success) {\n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', "  // 아래의 4개 기능은 'Storagersabled(하위 설정됨)'로만 활성화됩니다.\n", '  // ALL : 3 개의 Storage 레벨\n', '  function generateTokens(address _owner, uint _amount) public onlyController onlyStorageEnabled returns (bool) {\n', '    return super.generateTokens(_owner, _amount);\n', '  }\n', '\n', '  function destroyTokens(address _owner, uint _amount) public onlyController onlyStorageEnabled returns (bool) {\n', '    return super.destroyTokens(_owner, _amount);\n', '  }\n', '\n', '  function blockAddress(address _addr) public onlyController onlyStorageEnabled {\n', '    super.blockAddress(_addr);\n', '  }\n', '\n', '  function unblockAddress(address _addr) public onlyController onlyStorageEnabled {\n', '    super.unblockAddress(_addr);\n', '  }\n', '\n', '  function enableStorage(bool _StorageEnabled) public onlyController {\n', '    StorageEnabled = _StorageEnabled;\n', '    StorageEnabled(_StorageEnabled);\n', '  }\n', '\n', '  // byList 함수\n', '  function generateTokensByList(address[] _owners, uint[] _amounts) public onlyController onlyStorageEnabled returns (bool) {\n', '    require(_owners.length == _amounts.length);\n', '\n', '    for(uint i = 0; i < _owners.length; i++) {\n', '      generateTokens(_owners[i], _amounts[i]);\n', '    }\n', '\n', '    return true;\n', '  }\n', '}']