['pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract EtProfit{\n', '\n', '   using SafeMath for uint;\n', '    // array containing information about beneficiaries\n', '    mapping (address => uint) public balances;\n', '    //array containing information about the time of payment\n', '    mapping (address => uint) public time;\n', '    \n', '    //The marks of the balance on the contract after which the percentage of payments will change\n', '    uint steep1 = 1000;\n', '    uint steep2 = 2000;\n', '    uint steep3 = 3000;\n', '    uint steep4 = 4000;\n', '    uint steep5 = 5000;\n', '    \n', '    //the time through which dividends will be paid\n', '    uint dividendsTime = 1 days;\n', '    \n', '    event NewInvestor(address indexed investor, uint deposit);\n', '    event PayOffDividends(address indexed investor, uint value);\n', '    event NewDeposit(address indexed investor, uint value);\n', '    \n', '    uint public allDeposits;\n', '    uint public allPercents;\n', '    uint public allBeneficiaries;\n', '    uint public lastPayment;\n', '    \n', '    \n', '    \n', '    /**\n', '     * The modifier checking the positive balance of the beneficiary\n', '    */\n', '    modifier isIssetRecepient(){\n', '        require(balances[msg.sender] > 0,  "Deposit not found");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * modifier checking the next payout time\n', '     */\n', '    modifier timeCheck(){\n', '        \n', '         require(now >= time[msg.sender].add(dividendsTime), "Too fast payout request. The time of payment has not yet come");\n', '         _;\n', '        \n', '    }\n', '    function getDepositMultiplier()public view  returns(uint){\n', '        uint percent = getPercent();\n', '        uint rate = balances[msg.sender].mul(percent).div(10000);\n', '        uint depositMultiplier = now.sub(time[msg.sender]).div(dividendsTime);\n', '        return(rate.mul(depositMultiplier));\n', '        \n', '    }\n', '    \n', '    /**\n', '    *The method is called upon an empty payment for the contract, pays the interest on the deposit to the final beneficiary.\n', '    * A check is made on the funds on the depositor&#39;s account and the time at which he can receive a deposit interest\n', '    */\n', '    function receivePayment()isIssetRecepient timeCheck private{\n', '        \n', '        uint depositMultiplier = getDepositMultiplier();\n', '        time[msg.sender] = now;\n', '        msg.sender.transfer(depositMultiplier);\n', '        \n', '        allPercents+=depositMultiplier;\n', '        lastPayment =now;\n', '        emit PayOffDividends(msg.sender, depositMultiplier);\n', '        \n', '        \n', '    }\n', '    \n', '    /**\n', '     * Method for verifying the availability of interest payments to the ultimate beneficiary\n', '     * @return bool\n', '     */\n', '    function authorizationPayment()public view returns(bool){\n', '        \n', '        if (balances[msg.sender] > 0 && now >= (time[msg.sender].add(dividendsTime))){\n', '            return (true);\n', '        }else{\n', '            return(false);\n', '        }\n', '        \n', '    }\n', '   \n', '    /**\n', '     * Returns the percentage that will be accrued to the final beneficiary,\n', '     * depending on the available balance of the etherium on the contract\n', '     * \n', '     * @return uint percent\n', '     */ \n', '    function getPercent() public view returns(uint){\n', '        \n', '        uint contractBalance = address(this).balance;\n', '        \n', '        uint balanceSteep1 = steep1.mul(1 ether);\n', '        uint balanceSteep2 = steep2.mul(1 ether);\n', '        uint balanceSteep3 = steep3.mul(1 ether);\n', '        uint balanceSteep4 = steep4.mul(1 ether);\n', '        uint balanceSteep5 = steep5.mul(1 ether);\n', '        \n', '        \n', '        if(contractBalance < balanceSteep1){\n', '            return(425);\n', '        }\n', '        if(contractBalance >= balanceSteep1 && contractBalance < balanceSteep2){\n', '            return(450);\n', '        }\n', '        if(contractBalance >= balanceSteep2 && contractBalance < balanceSteep3){\n', '            return(475);\n', '        }\n', '        if(contractBalance >= balanceSteep3 && contractBalance < balanceSteep4){\n', '            return(500);\n', '        }\n', '        if(contractBalance >= balanceSteep4 && contractBalance < balanceSteep5){\n', '            return(525);\n', '        }\n', '        if(contractBalance >= balanceSteep5){\n', '            return(550);\n', '        }\n', '        \n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    /**\n', '     * The method of accepting payments, if a zero payment has come, then we start the procedure for refunding\n', '     * the interest on the deposit, if the payment is not empty, we record the number of broadcasts on the contract\n', '     * and the payment time\n', '     */\n', '    function createDeposit() private{\n', '        \n', '        if(msg.value > 0){\n', '            \n', '            if (balances[msg.sender] == 0){\n', '                emit NewInvestor(msg.sender, msg.value);\n', '                allBeneficiaries+=1;\n', '            }\n', '            \n', '            \n', '            if(getDepositMultiplier() > 0 && now >= time[msg.sender].add(dividendsTime) ){\n', '                receivePayment();\n', '            }\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '            time[msg.sender] = now;\n', '            \n', '            allDeposits+=msg.value;\n', '            emit NewDeposit(msg.sender, msg.value);\n', '            \n', '        }else{\n', '            receivePayment();\n', '        }\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '     * function that is launched when transferring money to a contract\n', '     */\n', '    function() external payable{\n', '        //buffer overflow protection\n', '        require((balances[msg.sender] + msg.value) >= balances[msg.sender]);\n', '        createDeposit();\n', '       \n', '    }\n', '    \n', '    \n', '}']
['pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract EtProfit{\n', '\n', '   using SafeMath for uint;\n', '    // array containing information about beneficiaries\n', '    mapping (address => uint) public balances;\n', '    //array containing information about the time of payment\n', '    mapping (address => uint) public time;\n', '    \n', '    //The marks of the balance on the contract after which the percentage of payments will change\n', '    uint steep1 = 1000;\n', '    uint steep2 = 2000;\n', '    uint steep3 = 3000;\n', '    uint steep4 = 4000;\n', '    uint steep5 = 5000;\n', '    \n', '    //the time through which dividends will be paid\n', '    uint dividendsTime = 1 days;\n', '    \n', '    event NewInvestor(address indexed investor, uint deposit);\n', '    event PayOffDividends(address indexed investor, uint value);\n', '    event NewDeposit(address indexed investor, uint value);\n', '    \n', '    uint public allDeposits;\n', '    uint public allPercents;\n', '    uint public allBeneficiaries;\n', '    uint public lastPayment;\n', '    \n', '    \n', '    \n', '    /**\n', '     * The modifier checking the positive balance of the beneficiary\n', '    */\n', '    modifier isIssetRecepient(){\n', '        require(balances[msg.sender] > 0,  "Deposit not found");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * modifier checking the next payout time\n', '     */\n', '    modifier timeCheck(){\n', '        \n', '         require(now >= time[msg.sender].add(dividendsTime), "Too fast payout request. The time of payment has not yet come");\n', '         _;\n', '        \n', '    }\n', '    function getDepositMultiplier()public view  returns(uint){\n', '        uint percent = getPercent();\n', '        uint rate = balances[msg.sender].mul(percent).div(10000);\n', '        uint depositMultiplier = now.sub(time[msg.sender]).div(dividendsTime);\n', '        return(rate.mul(depositMultiplier));\n', '        \n', '    }\n', '    \n', '    /**\n', '    *The method is called upon an empty payment for the contract, pays the interest on the deposit to the final beneficiary.\n', "    * A check is made on the funds on the depositor's account and the time at which he can receive a deposit interest\n", '    */\n', '    function receivePayment()isIssetRecepient timeCheck private{\n', '        \n', '        uint depositMultiplier = getDepositMultiplier();\n', '        time[msg.sender] = now;\n', '        msg.sender.transfer(depositMultiplier);\n', '        \n', '        allPercents+=depositMultiplier;\n', '        lastPayment =now;\n', '        emit PayOffDividends(msg.sender, depositMultiplier);\n', '        \n', '        \n', '    }\n', '    \n', '    /**\n', '     * Method for verifying the availability of interest payments to the ultimate beneficiary\n', '     * @return bool\n', '     */\n', '    function authorizationPayment()public view returns(bool){\n', '        \n', '        if (balances[msg.sender] > 0 && now >= (time[msg.sender].add(dividendsTime))){\n', '            return (true);\n', '        }else{\n', '            return(false);\n', '        }\n', '        \n', '    }\n', '   \n', '    /**\n', '     * Returns the percentage that will be accrued to the final beneficiary,\n', '     * depending on the available balance of the etherium on the contract\n', '     * \n', '     * @return uint percent\n', '     */ \n', '    function getPercent() public view returns(uint){\n', '        \n', '        uint contractBalance = address(this).balance;\n', '        \n', '        uint balanceSteep1 = steep1.mul(1 ether);\n', '        uint balanceSteep2 = steep2.mul(1 ether);\n', '        uint balanceSteep3 = steep3.mul(1 ether);\n', '        uint balanceSteep4 = steep4.mul(1 ether);\n', '        uint balanceSteep5 = steep5.mul(1 ether);\n', '        \n', '        \n', '        if(contractBalance < balanceSteep1){\n', '            return(425);\n', '        }\n', '        if(contractBalance >= balanceSteep1 && contractBalance < balanceSteep2){\n', '            return(450);\n', '        }\n', '        if(contractBalance >= balanceSteep2 && contractBalance < balanceSteep3){\n', '            return(475);\n', '        }\n', '        if(contractBalance >= balanceSteep3 && contractBalance < balanceSteep4){\n', '            return(500);\n', '        }\n', '        if(contractBalance >= balanceSteep4 && contractBalance < balanceSteep5){\n', '            return(525);\n', '        }\n', '        if(contractBalance >= balanceSteep5){\n', '            return(550);\n', '        }\n', '        \n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    /**\n', '     * The method of accepting payments, if a zero payment has come, then we start the procedure for refunding\n', '     * the interest on the deposit, if the payment is not empty, we record the number of broadcasts on the contract\n', '     * and the payment time\n', '     */\n', '    function createDeposit() private{\n', '        \n', '        if(msg.value > 0){\n', '            \n', '            if (balances[msg.sender] == 0){\n', '                emit NewInvestor(msg.sender, msg.value);\n', '                allBeneficiaries+=1;\n', '            }\n', '            \n', '            \n', '            if(getDepositMultiplier() > 0 && now >= time[msg.sender].add(dividendsTime) ){\n', '                receivePayment();\n', '            }\n', '            \n', '            balances[msg.sender] = balances[msg.sender].add(msg.value);\n', '            time[msg.sender] = now;\n', '            \n', '            allDeposits+=msg.value;\n', '            emit NewDeposit(msg.sender, msg.value);\n', '            \n', '        }else{\n', '            receivePayment();\n', '        }\n', '        \n', '    }\n', '\n', '\n', '    /**\n', '     * function that is launched when transferring money to a contract\n', '     */\n', '    function() external payable{\n', '        //buffer overflow protection\n', '        require((balances[msg.sender] + msg.value) >= balances[msg.sender]);\n', '        createDeposit();\n', '       \n', '    }\n', '    \n', '    \n', '}']
