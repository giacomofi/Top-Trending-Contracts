['/**\n', ' *  Crowdsale for m+plus coin phase 2\n', ' *\n', ' *  Based on OpenZeppelin framework.\n', ' *  https://openzeppelin.org\n', ' **/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * Safe Math library from OpenZeppelin framework\n', ' * https://openzeppelin.org\n', ' *\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Crowdsale for m+plus coin phase 1\n', ' */\n', 'contract MplusCrowdsaleB {\n', '    using SafeMath for uint256;\n', '\n', '    // Number of stages\n', '    uint256 internal constant NUM_STAGES = 4;\n', '\n', '    // 05/02 - 05/16\n', '    uint256 internal constant ICO_START1 = 1525190400;\n', '    // 05/17 - 06/01\n', '    uint256 internal constant ICO_START2 = 1526486400;\n', '    // 06/02 - 06/16\n', '    uint256 internal constant ICO_START3 = 1527868800;\n', '    // 06/17 - 07/01\n', '    uint256 internal constant ICO_START4 = 1529164800;\n', '    // 07/01\n', '    uint256 internal constant ICO_END = 1530460799;\n', '\n', '    // Exchange rate for each term periods\n', '    uint256 internal constant ICO_RATE1 = 13000;\n', '    uint256 internal constant ICO_RATE2 = 12500;\n', '    uint256 internal constant ICO_RATE3 = 12000;\n', '    uint256 internal constant ICO_RATE4 = 11500;\n', '\n', '    // Funding goal and soft cap in Token\n', '    //uint256 internal constant HARD_CAP = 2000000000 * (10 ** 18);\n', '    // Cap for each term periods in ETH\n', '    // Exchange rate for each term periods\n', '    uint256 internal constant ICO_CAP1 = 8000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP2 = 16000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP3 = 24000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP4 = 32000 * (10 ** 18);\n', '\n', '    // Caps per a purchase\n', '    uint256 internal constant MIN_CAP = (10 ** 17);\n', '    uint256 internal constant MAX_CAP = 1000 * (10 ** 18);\n', '\n', '    // Owner of this contract\n', '    address internal owner;\n', '\n', '    // The token being sold\n', '    ERC20 public tokenReward;\n', '\n', '    // Tokens will be transfered from this address\n', '    address internal tokenOwner;\n', '\n', '    // Address where funds are collected\n', '    address internal wallet;\n', '\n', '    // Stage of ICO\n', '    uint256 public stage = 0;\n', '\n', '    // Amount of tokens sold\n', '    uint256 public tokensSold = 0;\n', '\n', '    // Amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     *\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    event IcoStageStarted(uint256 stage);\n', '    event IcoEnded();\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function MplusCrowdsaleB(address _tokenAddress, address _wallet) public {\n', '        require(_tokenAddress != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        owner = msg.sender;\n', '        tokenOwner = msg.sender;\n', '        wallet = _wallet;\n', '\n', '        tokenReward = ERC20(_tokenAddress);\n', '    }\n', '\n', '    // Fallback function can be used to buy tokens\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // Low level token purchase function\n', '    function buyTokens(address _beneficiary) public payable {\n', '        require(_beneficiary != address(0));\n', '        require(msg.value >= MIN_CAP);\n', '        require(msg.value <= MAX_CAP);\n', '        require(now >= ICO_START1);\n', '        require(now <= ICO_END);\n', '        require(stage <= NUM_STAGES);\n', '\n', '        determineCurrentStage();\n', '//        require(stage >= 1 && stage <= NUM_STAGES);\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = getTokenAmount(weiAmount);\n', '        require(tokens > 0);\n', '\n', '        // Update totals\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokens);\n', '        checkCap();\n', '\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '        require(tokenReward.transferFrom(tokenOwner, _beneficiary, tokens));\n', '        forwardFunds();\n', '    }\n', '\n', '    // Send ether to the fund collection wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function determineCurrentStage() internal {\n', '//        uint256 prevStage = stage;\n', '        if (stage < 4 && now >= ICO_START4) {\n', '            stage = 4;\n', '            emit IcoStageStarted(4);\n', '        } else if (stage < 3 && now >= ICO_START3) {\n', '            stage = 3;\n', '            emit IcoStageStarted(3);\n', '        } else if (stage < 2 && now >= ICO_START2) {\n', '            stage = 2;\n', '            emit IcoStageStarted(2);\n', '        } else if (stage < 1 && now >= ICO_START1) {\n', '            stage = 1;\n', '            emit IcoStageStarted(1);\n', '        }\n', '    }\n', '\n', '    function checkCap() internal {\n', '        if (weiRaised >= ICO_CAP4) {\n', '            stage = 5;\n', '            emit IcoEnded();\n', '        } else if (stage < 4 && weiRaised >= ICO_CAP3) {\n', '            stage = 4;\n', '            emit IcoStageStarted(4);\n', '        } else if (stage < 3 && weiRaised >= ICO_CAP2) {\n', '            stage = 3;\n', '            emit IcoStageStarted(3);\n', '        } else if (stage < 2 && weiRaised >= ICO_CAP1) {\n', '            stage = 2;\n', '            emit IcoStageStarted(2);\n', '        }\n', '    }\n', '\n', '    function getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint256 rate = 0;\n', '\n', '        if (stage == 1) {\n', '            rate = ICO_RATE1;\n', '        } else if (stage == 2) {\n', '            rate = ICO_RATE2;\n', '        } else if (stage == 3) {\n', '            rate = ICO_RATE3;\n', '        } else if (stage == 4) {\n', '            rate = ICO_RATE4;\n', '        }\n', '\n', '        return rate.mul(_weiAmount);\n', '    }\n', '}']
['/**\n', ' *  Crowdsale for m+plus coin phase 2\n', ' *\n', ' *  Based on OpenZeppelin framework.\n', ' *  https://openzeppelin.org\n', ' **/\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * Safe Math library from OpenZeppelin framework\n', ' * https://openzeppelin.org\n', ' *\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title Crowdsale for m+plus coin phase 1\n', ' */\n', 'contract MplusCrowdsaleB {\n', '    using SafeMath for uint256;\n', '\n', '    // Number of stages\n', '    uint256 internal constant NUM_STAGES = 4;\n', '\n', '    // 05/02 - 05/16\n', '    uint256 internal constant ICO_START1 = 1525190400;\n', '    // 05/17 - 06/01\n', '    uint256 internal constant ICO_START2 = 1526486400;\n', '    // 06/02 - 06/16\n', '    uint256 internal constant ICO_START3 = 1527868800;\n', '    // 06/17 - 07/01\n', '    uint256 internal constant ICO_START4 = 1529164800;\n', '    // 07/01\n', '    uint256 internal constant ICO_END = 1530460799;\n', '\n', '    // Exchange rate for each term periods\n', '    uint256 internal constant ICO_RATE1 = 13000;\n', '    uint256 internal constant ICO_RATE2 = 12500;\n', '    uint256 internal constant ICO_RATE3 = 12000;\n', '    uint256 internal constant ICO_RATE4 = 11500;\n', '\n', '    // Funding goal and soft cap in Token\n', '    //uint256 internal constant HARD_CAP = 2000000000 * (10 ** 18);\n', '    // Cap for each term periods in ETH\n', '    // Exchange rate for each term periods\n', '    uint256 internal constant ICO_CAP1 = 8000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP2 = 16000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP3 = 24000 * (10 ** 18);\n', '    uint256 internal constant ICO_CAP4 = 32000 * (10 ** 18);\n', '\n', '    // Caps per a purchase\n', '    uint256 internal constant MIN_CAP = (10 ** 17);\n', '    uint256 internal constant MAX_CAP = 1000 * (10 ** 18);\n', '\n', '    // Owner of this contract\n', '    address internal owner;\n', '\n', '    // The token being sold\n', '    ERC20 public tokenReward;\n', '\n', '    // Tokens will be transfered from this address\n', '    address internal tokenOwner;\n', '\n', '    // Address where funds are collected\n', '    address internal wallet;\n', '\n', '    // Stage of ICO\n', '    uint256 public stage = 0;\n', '\n', '    // Amount of tokens sold\n', '    uint256 public tokensSold = 0;\n', '\n', '    // Amount of raised money in wei\n', '    uint256 public weiRaised = 0;\n', '\n', '    /**\n', '     * Event for token purchase logging\n', '     *\n', '     * @param purchaser who paid for the tokens\n', '     * @param beneficiary who got the tokens\n', '     * @param value weis paid for purchase\n', '     * @param amount amount of tokens purchased\n', '     */\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '\n', '    event IcoStageStarted(uint256 stage);\n', '    event IcoEnded();\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function MplusCrowdsaleB(address _tokenAddress, address _wallet) public {\n', '        require(_tokenAddress != address(0));\n', '        require(_wallet != address(0));\n', '\n', '        owner = msg.sender;\n', '        tokenOwner = msg.sender;\n', '        wallet = _wallet;\n', '\n', '        tokenReward = ERC20(_tokenAddress);\n', '    }\n', '\n', '    // Fallback function can be used to buy tokens\n', '    function () external payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    // Low level token purchase function\n', '    function buyTokens(address _beneficiary) public payable {\n', '        require(_beneficiary != address(0));\n', '        require(msg.value >= MIN_CAP);\n', '        require(msg.value <= MAX_CAP);\n', '        require(now >= ICO_START1);\n', '        require(now <= ICO_END);\n', '        require(stage <= NUM_STAGES);\n', '\n', '        determineCurrentStage();\n', '//        require(stage >= 1 && stage <= NUM_STAGES);\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        // calculate token amount to be created\n', '        uint256 tokens = getTokenAmount(weiAmount);\n', '        require(tokens > 0);\n', '\n', '        // Update totals\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokens);\n', '        checkCap();\n', '\n', '        emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n', '        require(tokenReward.transferFrom(tokenOwner, _beneficiary, tokens));\n', '        forwardFunds();\n', '    }\n', '\n', '    // Send ether to the fund collection wallet\n', '    function forwardFunds() internal {\n', '        wallet.transfer(msg.value);\n', '    }\n', '\n', '    function determineCurrentStage() internal {\n', '//        uint256 prevStage = stage;\n', '        if (stage < 4 && now >= ICO_START4) {\n', '            stage = 4;\n', '            emit IcoStageStarted(4);\n', '        } else if (stage < 3 && now >= ICO_START3) {\n', '            stage = 3;\n', '            emit IcoStageStarted(3);\n', '        } else if (stage < 2 && now >= ICO_START2) {\n', '            stage = 2;\n', '            emit IcoStageStarted(2);\n', '        } else if (stage < 1 && now >= ICO_START1) {\n', '            stage = 1;\n', '            emit IcoStageStarted(1);\n', '        }\n', '    }\n', '\n', '    function checkCap() internal {\n', '        if (weiRaised >= ICO_CAP4) {\n', '            stage = 5;\n', '            emit IcoEnded();\n', '        } else if (stage < 4 && weiRaised >= ICO_CAP3) {\n', '            stage = 4;\n', '            emit IcoStageStarted(4);\n', '        } else if (stage < 3 && weiRaised >= ICO_CAP2) {\n', '            stage = 3;\n', '            emit IcoStageStarted(3);\n', '        } else if (stage < 2 && weiRaised >= ICO_CAP1) {\n', '            stage = 2;\n', '            emit IcoStageStarted(2);\n', '        }\n', '    }\n', '\n', '    function getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n', '        uint256 rate = 0;\n', '\n', '        if (stage == 1) {\n', '            rate = ICO_RATE1;\n', '        } else if (stage == 2) {\n', '            rate = ICO_RATE2;\n', '        } else if (stage == 3) {\n', '            rate = ICO_RATE3;\n', '        } else if (stage == 4) {\n', '            rate = ICO_RATE4;\n', '        }\n', '\n', '        return rate.mul(_weiAmount);\n', '    }\n', '}']
