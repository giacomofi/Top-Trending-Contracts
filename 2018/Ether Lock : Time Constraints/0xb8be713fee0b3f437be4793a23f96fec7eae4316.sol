['pragma solidity ^0.4.21;\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/Token.sol\n', '\n', '/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/// @title Abstract token contract - Functions to be implemented by token contracts\n', 'contract Token {\n', '\n', '    /*\n', '     *  Events\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '}\n', '\n', '// File: contracts/RewardClaimHandler.sol\n', '\n', 'contract RewardClaimHandler {\n', '    Token public rewardToken;\n', '    address public operator;\n', '    address[] public winners;\n', '    mapping (address => uint) public rewardAmounts;\n', '    uint public guaranteedClaimEndTime;\n', '\n', '    function RewardClaimHandler(Token _rewardToken) public {\n', '        rewardToken = _rewardToken;\n', '        operator = msg.sender;\n', '    }\n', '\n', '    function registerRewards(address[] _winners, uint[] _rewardAmounts, uint duration) public {\n', '        require(\n', '            winners.length == 0 &&\n', '            _winners.length > 0 &&\n', '            _winners.length == _rewardAmounts.length &&\n', '            msg.sender == operator\n', '        );\n', '\n', '        uint totalAmount = 0;\n', '        for(uint i = 0; i < _winners.length; i++) {\n', '            totalAmount += _rewardAmounts[i];\n', '            rewardAmounts[_winners[i]] = _rewardAmounts[i];\n', '        }\n', '\n', '        require(rewardToken.transferFrom(msg.sender, this, totalAmount));\n', '\n', '        winners = _winners;\n', '        guaranteedClaimEndTime = now + duration;\n', '    }\n', '\n', '    function claimReward() public {\n', '        require(winners.length > 0 && rewardToken.transfer(msg.sender, rewardAmounts[msg.sender]));\n', '        rewardAmounts[msg.sender] = 0;\n', '    }\n', '\n', '    function retractRewards() public {\n', '        require(winners.length > 0 && msg.sender == operator && now >= guaranteedClaimEndTime);\n', '\n', '        uint totalAmount = 0;\n', '        for(uint i = 0; i < winners.length; i++) {\n', '            totalAmount += rewardAmounts[winners[i]];\n', '            rewardAmounts[winners[i]] = 0;\n', '            // We don&#39;t use:\n', '            //     winners[i] = 0;\n', '            // because of this:\n', '            // https://ethereum.stackexchange.com/questions/3373/how-to-clear-large-arrays-without-blowing-the-gas-limit\n', '            // This is a more gas efficient overall if more than one run happens\n', '        }\n', '\n', '        require(rewardToken.transfer(msg.sender, totalAmount));\n', '\n', '        winners.length = 0;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: @gnosis.pm/util-contracts/contracts/Token.sol\n', '\n', '/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', 'pragma solidity ^0.4.18;\n', '\n', '\n', '/// @title Abstract token contract - Functions to be implemented by token contracts\n', 'contract Token {\n', '\n', '    /*\n', '     *  Events\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    /*\n', '     *  Public functions\n', '     */\n', '    function transfer(address to, uint value) public returns (bool);\n', '    function transferFrom(address from, address to, uint value) public returns (bool);\n', '    function approve(address spender, uint value) public returns (bool);\n', '    function balanceOf(address owner) public view returns (uint);\n', '    function allowance(address owner, address spender) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '}\n', '\n', '// File: contracts/RewardClaimHandler.sol\n', '\n', 'contract RewardClaimHandler {\n', '    Token public rewardToken;\n', '    address public operator;\n', '    address[] public winners;\n', '    mapping (address => uint) public rewardAmounts;\n', '    uint public guaranteedClaimEndTime;\n', '\n', '    function RewardClaimHandler(Token _rewardToken) public {\n', '        rewardToken = _rewardToken;\n', '        operator = msg.sender;\n', '    }\n', '\n', '    function registerRewards(address[] _winners, uint[] _rewardAmounts, uint duration) public {\n', '        require(\n', '            winners.length == 0 &&\n', '            _winners.length > 0 &&\n', '            _winners.length == _rewardAmounts.length &&\n', '            msg.sender == operator\n', '        );\n', '\n', '        uint totalAmount = 0;\n', '        for(uint i = 0; i < _winners.length; i++) {\n', '            totalAmount += _rewardAmounts[i];\n', '            rewardAmounts[_winners[i]] = _rewardAmounts[i];\n', '        }\n', '\n', '        require(rewardToken.transferFrom(msg.sender, this, totalAmount));\n', '\n', '        winners = _winners;\n', '        guaranteedClaimEndTime = now + duration;\n', '    }\n', '\n', '    function claimReward() public {\n', '        require(winners.length > 0 && rewardToken.transfer(msg.sender, rewardAmounts[msg.sender]));\n', '        rewardAmounts[msg.sender] = 0;\n', '    }\n', '\n', '    function retractRewards() public {\n', '        require(winners.length > 0 && msg.sender == operator && now >= guaranteedClaimEndTime);\n', '\n', '        uint totalAmount = 0;\n', '        for(uint i = 0; i < winners.length; i++) {\n', '            totalAmount += rewardAmounts[winners[i]];\n', '            rewardAmounts[winners[i]] = 0;\n', "            // We don't use:\n", '            //     winners[i] = 0;\n', '            // because of this:\n', '            // https://ethereum.stackexchange.com/questions/3373/how-to-clear-large-arrays-without-blowing-the-gas-limit\n', '            // This is a more gas efficient overall if more than one run happens\n', '        }\n', '\n', '        require(rewardToken.transfer(msg.sender, totalAmount));\n', '\n', '        winners.length = 0;\n', '    }\n', '}']
