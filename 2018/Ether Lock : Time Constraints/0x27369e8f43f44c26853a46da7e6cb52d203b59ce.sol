['pragma solidity ^0.4.20;\n', '\n', '// File: contracts/ERC20Token.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address newOwner;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) only(owner) public {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() only(newOwner) public {\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '}\n', '\n', 'contract ERC20 is Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public totalSupply;\n', '    bool public isStarted = false;\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    modifier isStartedOnly() {\n', '        require(isStarted);\n', '        _;\n', '    }\n', '\n', '    modifier isNotStartedOnly() {\n', '        require(!isStarted);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract Token is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function start() public only(owner) isNotStartedOnly {\n', '        isStarted = true;\n', '    }\n', '\n', '    //================= Crowdsale Only =================\n', '    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '}\n', '\n', 'contract TokenWithoutStart is Owned {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint _amount) public only(owner) returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/AgileSetWithAssistance.sol\n', '\n', '// REMEMER TO UNCOMMENT TIME CHECKS!!!!!\n', 'contract AgileICOWithAssistance {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public operator; // ICO operator\n', '    address public juryOperator; // Jury.Online operator\n', '    address public projectWallet; // Wallet where project funds are sent\n', '    address public arbitrationAddress; // address of contract that handles arbitration\n', '    address public juryOnlineWallet; // Wallet for Jury.Online commission\n', '\n', '    bool public requireTokens; // if true, token balance needed before accept offer\n', '\n', '    uint public promisedTokens;\n', '    uint public etherAllowance;\n', '    uint public jotAllowance;\n', '    uint public commissionOnInvestmentJot; // commission paid in ETH when operator accepts offer\n', '    uint public commissionOnInvestmentEth; // commission paid in JOT when operator accepts offer\n', '    uint public percentForFuture; // percent of investment offer that is not sent to Cycle and kept for future\n', '    uint public rate = 1; // amount of token for each wei in investment offer\n', '    address public currentCycleAddress; // address of current AgileCycle contract\n', '    uint public currentCycleNumber; // indicates current cycle\n', '\n', '    uint public currentFundingRound; // indicates current funding round (should be removed)\n', '    uint public minimumInvestment;\n', '\n', '    uint public lastRateChange; // used to prevent changing rates more than once a day\n', '\n', '    Token public token; // proxy or real token\n', '    // Offer struct stores information about all offers and deals\n', '    // a deal is an accepted offer\n', '    struct Offer {\n', '        uint etherAmount; // etherAmount of investment offer\n', '        uint tokenAmount; // tokenAmount of investment offer\n', '        bool accepted; // true if offer has been accepted\n', '        uint numberOfDeals; // indicates number of deals an investor has\n', '    }\n', '    // below mapping maps an investor address to a deal number to the details\n', '    // of that deal (etherAmount, tokenAmount, accepted, numberOfDeals)\n', '    mapping(address => mapping(uint => Offer)) public offers;\n', '\n', '    address[] public cycles; // stores the addresses of cycles\n', '\n', '    // Stores the amount stored for future cycles\n', '    struct FutureDeal {\n', '        uint etherAmount; // etherAmount for future\n', '        uint tokenAmount; // tokenAmount for future\n', '    }\n', '    // below mapping maps investor address to a futureDeal, that is, an amount\n', '    // which will be used in future cycles.\n', '    mapping(address => FutureDeal) public futureDeals;\n', '\n', '    address[] public investorList; // list of investor\n', '\n', '    // FundingRound struct stores information about each FundingRound\n', '    struct FundingRound {\n', '        uint startTime;\n', '        uint endTime;\n', '        uint rate;\n', '        bool hasWhitelist;\n', '    }\n', '    FundingRound[] public roundPrices;  // stores list of funding rounds\n', '    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists (if any) for funding round\n', '\n', '    bool public saveMe;\n', '\n', '    modifier only(address _sender) {\n', '        require(msg.sender == _sender);\n', '        _;\n', '    }\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '            address _operator,\n', '            uint _commissionOnInvestmentJot,\n', '            uint _commissionOnInvestmentEth,\n', '            uint _percentForFuture,\n', '            address _projectWallet,\n', '            address _arbitrationAddress,\n', '\t    address _tokenAddress,\n', '            address _juryOperator,\n', '            address _juryOnlineWallet,\n', '\t    uint _minimumInvestment\n', '        ) public {\n', '        percentForFuture = _percentForFuture;\n', '        operator = _operator;\n', '        commissionOnInvestmentJot = _commissionOnInvestmentJot;\n', '        commissionOnInvestmentEth = _commissionOnInvestmentEth;\n', '        percentForFuture = _percentForFuture;\n', '        projectWallet = _projectWallet;\n', '        arbitrationAddress = _arbitrationAddress;\n', '\ttoken = Token(_tokenAddress);\n', '        juryOperator = _juryOperator;\n', '        juryOnlineWallet = _juryOnlineWallet;\n', '\tminimumInvestment = _minimumInvestment;\n', '    }\n', '\n', '    // PUBLIC ------------------------------------------------------------------\n', '    // payable function recieves ETH and creates an &#39;offer&#39;\n', '    // wont succeed with 2300 stipend for send, must add more gas\n', '    function () public payable {\n', '        // INVESTOR SENDS OFFER BY SENDING ETH TO CONTRACT\n', '        require(msg.value > minimumInvestment);\n', '    \tfor (uint i = 0; i < roundPrices.length; i++ ) {\n', '\t\tif (now > roundPrices[i].startTime && now < roundPrices[i].endTime) {\n', '\t\t\trate = roundPrices[i].rate;\n', '\t\t\tif (roundPrices[i].hasWhitelist == true) {\n', '\t\t\t\trequire(whitelist[i][msg.sender] == true);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t/*\n', '\tif (roundPrices.length > 0) {\n', '                if (roundPrices[currentFundingRound].hasWhitelist == true) {\n', '                    require(whitelist[currentFundingRound][msg.sender] == true);\n', '                }\n', '    \t}\n', '        */\n', '        uint dealNumber = offers[msg.sender][0].numberOfDeals;\n', '        // uint dealNumber = 0;\n', '\toffers[msg.sender][dealNumber].etherAmount = msg.value;\n', '        offers[msg.sender][dealNumber].tokenAmount = msg.value*rate;\n', '        offers[msg.sender][0].numberOfDeals += 1;\n', '    }\n', '    // Investor can withdraw offer if it has not been accepted\n', '    function withdrawOffer(uint _offerNumber) public {\n', '        // INVESTOR CAN WITHDRAW OFFER\n', '        require(offers[msg.sender][_offerNumber].accepted == false);\n', '        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\n', '        offers[msg.sender][_offerNumber].etherAmount = 0;\n', '    }\n', '    // Calles by Jury.Online to retrieve commission\n', '    function withdrawEther() public {\n', '        if (msg.sender == juryOperator) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ICO OPERATOR ------------------------------------------------------------\n', '    // operator can acept offer, it keeps certain amount in futureDeals, and sends\n', '    // rest to Cycle contract by calling offerAccepted() in Cycle\n', '    function setToken(address _tokenAddress) public onlyAdmin {\n', '    \trequire(token == 0x0000000000000000000000000000000000000000);\n', '\t    token = Token(_tokenAddress);\n', '    }\n', '    function acceptOffer(address _investor, uint _offerNumber) public onlyAdmin {\n', '        require(offers[_investor][_offerNumber].etherAmount > 0);\n', '        require(offers[_investor][_offerNumber].accepted != true);\n', '\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '\n', '\t    require(cycle.sealTimestamp() > 0);\n', '\n', '        offers[_investor][_offerNumber].accepted = true;\n', '        uint _etherAmount = offers[_investor][_offerNumber].etherAmount;\n', '        uint _tokenAmount = offers[_investor][_offerNumber].tokenAmount;\n', '\n', '        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\n', '        uint _etherForFuture = _etherAmount.mul(percentForFuture).div(100);\n', '        uint _tokenForFuture =  _tokenAmount.mul(percentForFuture).div(100);\n', '\n', '        if (_offerNumber == 0) {\n', '            futureDeals[_investor].etherAmount += _etherForFuture;\n', '            futureDeals[_investor].tokenAmount += _tokenForFuture;\n', '        } else {\n', '            futureDeals[_investor] = FutureDeal(_etherForFuture,_tokenForFuture);\n', '        }\n', '\n', '        _etherAmount = _etherAmount.sub(_etherForFuture);\n', '        _tokenAmount = _tokenAmount.sub(_tokenForFuture);\n', '\n', '        if (commissionOnInvestmentEth > 0 || commissionOnInvestmentJot > 0) {\n', '            uint etherCommission = _etherAmount.mul(commissionOnInvestmentEth).div(100);\n', '            uint jotCommission = _etherAmount.mul(commissionOnInvestmentJot).div(100);\n', '\t        _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\n', '            offers[_investor][_offerNumber].etherAmount = _etherAmount;\n', '            etherAllowance += etherCommission;\n', '            jotAllowance += jotCommission;\n', '        }\n', '        investorList.push(_investor);\n', '        cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\n', '    }\n', '    // after deploying Cycle, operator adds cycle address\n', '    function addCycleAddress(address _cycleAddress) public onlyAdmin {\n', '        cycles.push(_cycleAddress);\n', '    }\n', '    // Sets the active cycle. If not first one, previous one has to be finished.\n', '    function setNextCycle() public onlyAdmin {\n', '        require(cycles.length > 0);\n', '        if (currentCycleNumber > 0) {\n', '            AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '            uint finishedTimeStamp = cycle.finishedTimeStamp();\n', '            require(now > finishedTimeStamp);\n', '            uint interval = now - finishedTimeStamp;\n', '            //require(interval > 3 days);\n', '        }\n', '        currentCycleAddress = cycles[currentCycleNumber];\n', '        currentCycleNumber += 1;\n', '    }\n', '    // to add FundingRounds\n', '    function addFundingRound(uint _startTime,uint _endTime, uint _rate, address[] _whitelist) public onlyAdmin {\n', '        if (_whitelist.length == 0) {\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_rate,false));\n', '        } else {\n', '            for (uint i=0 ; i < _whitelist.length ; i++ ) {\n', '                whitelist[roundPrices.length][_whitelist[i]] = true;\n', '            }\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_rate,true));\n', '        }\n', '    }\n', '    // to set rate directly\n', '    function setRate(uint _rate) onlyAdmin public {\n', '        uint interval = now - lastRateChange;\n', '        //require(interval < 1 days);\n', '        rate = _rate;\n', '    }\n', '    // to activate a fundingRound\n', '    function setCurrentFundingRound(uint _fundingRound) public onlyAdmin {\n', '        require(roundPrices.length > _fundingRound);\n', '        currentFundingRound = _fundingRound;\n', '        rate = roundPrices[_fundingRound].rate;\n', '    }\n', '    // sends futureDeal funds to next cycle\n', '    // it has loop control in case of lack of gas\n', '    function sendFundsToNextCycle(uint _startLoop, uint _endLoop) public onlyAdmin {\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '        require(cycle.sealTimestamp() > 0);\n', '\n', '        uint _promisedTokens = cycle.promisedTokens();\n', '        uint _balanceTokens = token.balanceOf(currentCycleAddress);\n', '\n', '        if (_endLoop == 0) _endLoop = investorList.length;\n', '        require(_endLoop <= investorList.length);\n', '\n', '        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\n', '\n', '        for ( uint i=_startLoop; i < _endLoop; i++ ) {\n', '    \t    address _investor = investorList[i];\n', '    \t    uint _etherAmount = futureDeals[_investor].etherAmount;\n', '    \t    uint _tokenAmount = futureDeals[_investor].tokenAmount;\n', '            _promisedTokens += _tokenAmount;\n', '            if (requireTokens) require(_balanceTokens >= _promisedTokens);\n', '    \t    cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\n', '    \t    futureDeals[_investor].etherAmount = 0;\n', '    \t    futureDeals[_investor].tokenAmount = 0;\n', '    \t    //futureDeals[_investor].sent = true;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // HELPERS -----------------------------------------------------------------\n', '    function failSafe() public {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract AgileCycleWithAssistance {\n', '    using SafeMath for uint;\n', '    //VARIABLES\n', '    address public operator; // should be same as ICO (no check for this yet)\n', '    address public juryOperator; // for failsafe\n', '    uint public promisedTokens; // the number of tokens owed to investor by accepting offer\n', '    uint public raisedEther; // amount of ether raised by accepting offers\n', '\n', '    bool public tokenReleaseAtStart; // whether tokens released at start or by milestones\n', '\n', '    address public icoAddress; // ICO address\n', '    address public arbitrationAddress;\n', '\n', '    bool public roundFailedToStart;\n', '    address public projectWallet;\n', '    address public juryOnlineWallet;\n', '\n', '    struct Milestone {\n', '        uint etherAmount; //how many Ether is needed for this milestone\n', '        uint tokenAmount; //how many tokens releases this milestone\n', '        uint startTime; //real time when milestone has started, set upon start\n', '        uint finishTime; //real time when milestone has finished, set upon finish\n', '        uint duration; //assumed duration for milestone implementation, set upon milestone creation\n', '        string description;\n', '        string result;\n', '    }\n', '    Milestone[] public milestones; // list of milestones\n', '\n', '    uint[] public commissionEth; // each element corresponds to amount of commission paid in each milestone\n', '    uint[] public commissionJot; // same as above, but in JOT. Both amount stored in percentages\n', '    uint public currentMilestone; // stores index of current milestone\n', '    uint public etherAllowance; // amount allowed for Jury.Online in commission ETH\n', '    uint public jotAllowance; // amount allowed for Jury.Online in commission JOT\n', '    uint public ethForMilestone; // amomunt allowed for project to withdraw in milestone\n', '    Token public token; // Real or Proxy token\n', '    uint public totalToken; // sum of Tokens in all milestones\n', '    uint public totalEther; // sum of ETH in all milstones\n', '    uint public sealTimestamp; // timestamp when Cycle is sealed\n', '\n', '    mapping(address => uint[]) public etherPartition;\n', '    mapping(address => uint[]) public tokenPartition;\n', '\n', '    struct Deal {\n', '        uint etherAmount; // amount of ETH in deal\n', '        uint tokenAmount; // amount of Tokens in deal\n', '        bool disputing; // true if disputing, funds are frozen\n', '        uint tokenAllowance; // amount allowed for investor to withdraw\n', '        uint etherUsed; // ETH already used and not available for refund\n', '        bool verdictForProject; // verdict for project\n', '        bool verdictForInvestor; // verdict for investor\n', '    }\n', '    mapping(address => Deal) public deals; // mapping of investor to deal\n', '    address[] public dealsList; // list of addresses of investor deals, used for iteration in startMilestone()\n', '\n', '    uint public finishedTimeStamp; // when all milestones are finished. Checked by ICO.\n', '\n', '    uint public postDisputeEth; // for debugging\n', '    bool public saveMe; //for failsafe\n', '    bool public cycleApproved; // Jury must approve the start of an ICO\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '    modifier sealed() {\n', '    \trequire(sealTimestamp > 0);\n', '    \t_;\n', '    }\n', '    modifier notSealed() {\n', '    \trequire(sealTimestamp == 0);\n', '    \t_;\n', '    }\n', '\n', '    constructor(\n', '            bool _tokenReleaseAtStart,\n', '            address _icoAddress,\n', '            uint[] _commissionEth,\n', '            uint[] _commissionJot,\n', '            address _operator,\n', '            address _juryOperator,\n', '            address _arbitrationAddress,\n', '            address _projectWallet,\n', '            address _juryOnlineWallet\n', '        ) public {\n', '            tokenReleaseAtStart = _tokenReleaseAtStart;\n', '            icoAddress = _icoAddress;\n', '            commissionEth = _commissionEth;\n', '            commissionJot = _commissionJot;\n', '            operator = _operator;\n', '            juryOperator = _juryOperator;\n', '            arbitrationAddress = _arbitrationAddress;\n', '            projectWallet = _projectWallet;\n', '            juryOnlineWallet = _juryOnlineWallet;\n', '    }\n', '\n', '    function setToken(address _tokenAddress) public onlyAdmin {\n', '    \trequire(token == 0x0000000000000000000000000000000000000000);\n', '\t    token = Token(_tokenAddress);\n', '    }\n', '    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\n', '    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\n', '    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\n', '    function withdrawEther() public {\n', '        if (roundFailedToStart == true) {\n', '            require(msg.sender.send(deals[msg.sender].etherAmount));\n', '        }\n', '        if (msg.sender == operator) {\n', '            require(projectWallet.send(ethForMilestone+postDisputeEth));\n', '            ethForMilestone = 0;\n', '            postDisputeEth = 0;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '        if (deals[msg.sender].verdictForInvestor == true) {\n', '            require(msg.sender.send(deals[msg.sender].etherAmount - deals[msg.sender].etherUsed));\n', '        }\n', '    }\n', '    // CALLED BY INVESTOR TO RETRIEVE TOKENS\n', '    function withdrawToken() public {\n', '        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\n', '        deals[msg.sender].tokenAllowance = 0;\n', '    }\n', '\n', '\n', '    // OPERATOR ----------------------------------------------------------------\n', '    function addMilestonesAndSeal(uint[] _etherAmounts, uint[] _tokenAmounts, uint[] _startTimes, uint[] _durations) public notSealed onlyAdmin {\n', '    \trequire(_etherAmounts.length == _tokenAmounts.length);\n', '\trequire(_startTimes.length == _durations.length);\n', '\trequire(_durations.length == _etherAmounts.length);\n', '\tfor (uint i = 0; i < _etherAmounts.length; i++) {\n', '\t\ttotalEther = totalEther.add(_etherAmounts[i]);\n', '\t\ttotalToken = totalToken.add(_tokenAmounts[i]);\n', '\t\tmilestones.push(Milestone(_etherAmounts[i], _tokenAmounts[i], _startTimes[i],0,_durations[i],"",""));\n', '\t}\n', '\tsealTimestamp = now;\n', '    }\n', '    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyAdmin returns(uint) {\n', '        totalEther = totalEther.add(_etherAmount);\n', '        totalToken = totalToken.add(_tokenAmount);\n', '        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, ""));\n', '    }\n', '    function approveCycle(bool _approved) public {\n', '        require(cycleApproved != true && roundFailedToStart != true);\n', '        require(msg.sender == juryOperator);\n', '        if (_approved == true) {\n', '            cycleApproved = true;\n', '        } else {\n', '            roundFailedToStart = true;\n', '        }\n', '    }\n', '    function startMilestone() public sealed onlyAdmin {\n', '        require(cycleApproved);\n', '        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\n', '        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\n', '        // require(!roundFailedToStart);\n', '        if (currentMilestone != 0 ) {\n', '            require(milestones[currentMilestone-1].finishTime > 0);\n', '            uint interval = now - milestones[currentMilestone-1].finishTime;\n', '            require(interval > 3 days);\n', '        }\n', '        for (uint i=0; i < dealsList.length ; i++) {\n', '            address investor = dealsList[i];\n', '            if (deals[investor].disputing == false) {\n', '                if (deals[investor].verdictForInvestor != true) {\n', '                    ethForMilestone += etherPartition[investor][currentMilestone];\n', '                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\n', '                    if (tokenReleaseAtStart == false) {\n', '                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        milestones[currentMilestone].startTime = now;\n', '        currentMilestone +=1;\n', '        ethForMilestone = payCommission();\n', '    }\n', '    function finishMilestone(string _result) public onlyAdmin {\n', '        require(milestones[currentMilestone-1].finishTime == 0);\n', '        // UNCOMMENT LINES BELOW FOR PRODUCTION!!!!\n', '\t    uint interval = now - milestones[currentMilestone-1].startTime;\n', '        require(interval > 1 weeks);\n', '        milestones[currentMilestone-1].finishTime = now;\n', '        milestones[currentMilestone-1].result = _result;\n', '        if (currentMilestone == milestones.length) {\n', '            finishedTimeStamp = now;\n', '        }\n', '    }\n', '    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyAdmin {\n', '        assert(_id < milestones.length);\n', '        totalEther = (totalEther - milestones[_id].etherAmount).add(_etherAmount); //previous addition\n', '        totalToken = (totalToken - milestones[_id].tokenAmount).add(_tokenAmount);\n', '        milestones[_id].etherAmount = _etherAmount;\n', '        milestones[_id].tokenAmount = _tokenAmount;\n', '        milestones[_id].startTime = _startTime;\n', '        milestones[_id].duration = _duration;\n', '        milestones[_id].description = _description;\n', '    }\n', '\n', '    function seal() public notSealed onlyAdmin {\n', '        require(milestones.length > 0);\n', '        // Uncomment bottom line to require balance when sealing contract\n', '        // currently balance is required only when accepting offer\n', '        //require(token.balanceOf(address(this)) >= promisedTokens);\n', '        sealTimestamp = now;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ONLY(ICO) ---------------------------------------------------------------\n', '    // when operator accepts offer in ICO contract, it calls this function to add deal\n', '    function offerAccepted(address _investor, uint _tokenAmount) public payable only(icoAddress) {\n', '\t    require(sealTimestamp > 0);\n', '        uint _etherAmount = msg.value;\n', '        assignPartition(_investor, _etherAmount, _tokenAmount);\n', '        if (!(deals[_investor].etherAmount > 0)) dealsList.push(_investor);\n', '        if (tokenReleaseAtStart == true) {\n', '            deals[_investor].tokenAllowance = _tokenAmount;\n', '        }\n', '        deals[_investor].etherAmount += _etherAmount;\n', '        deals[_investor].tokenAmount += _tokenAmount;\n', '    \t// ADDS TO TOTALS\n', '    \tpromisedTokens += _tokenAmount;\n', '    \traisedEther += _etherAmount;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ONLY(ARBITRATION) -------------------------------------------------------\n', '    function disputeOpened(address _investor) public only(arbitrationAddress) {\n', '        deals[_investor].disputing = true;\n', '    }\n', '    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public only(arbitrationAddress) {\n', '        require(deals[_investor].disputing == true);\n', '        if (_verdictForInvestor) {\n', '            deals[_investor].verdictForInvestor = true;\n', '        } else {\n', '            deals[_investor].verdictForProject = true;\n', '            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\n', '                postDisputeEth += etherPartition[_investor][i];\n', '                deals[_investor].etherUsed += etherPartition[_investor][i];\n', '            }\n', '        }\n', '        deals[_investor].disputing = false;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // INTERNAL ----------------------------------------------------------------\n', '    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\n', '        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\n', '        uint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\n', '        uint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\n', '        uint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\n', '        uint totalEtherInvestment;\n', '        uint totalTokenInvestment;\n', '        for(uint i=currentMilestone; i<milestones.length; i++) {\n', '            milestoneEtherTarget = milestones[i].etherAmount;\n', '            milestoneTokenTarget = milestones[i].tokenAmount;\n', '            milestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\n', '            milestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\n', '            totalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\n', '            totalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\n', '            if (deals[_investor].etherAmount > 0) {\n', '                etherPartition[_investor][i] += milestoneEtherAmount;\n', '                tokenPartition[_investor][i] += milestoneTokenAmount;\n', '            } else {\n', '                etherPartition[_investor].push(milestoneEtherAmount);\n', '                tokenPartition[_investor].push(milestoneTokenAmount);\n', '            }\n', '\n', '        }\n', '        /* roundingErrors += _etherAmount - totalEtherInvestment; */\n', '        etherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\n', '        tokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\n', '    }\n', '    function payCommission() internal returns(uint) {\n', '        if (commissionEth.length >= currentMilestone) {\n', '            uint ethCommission = raisedEther.mul(commissionEth[currentMilestone-1]).div(100);\n', '            uint jotCommission = raisedEther.mul(commissionJot[currentMilestone-1]).div(100);\n', '            etherAllowance += ethCommission;\n', '            jotAllowance += jotCommission;\n', '            return ethForMilestone.sub(ethCommission).sub(jotCommission);\n', '        } else {\n', '            return ethForMilestone;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // HELPERS -----------------------------------------------------------------\n', '    function milestonesLength() public view returns(uint) {\n', '        return milestones.length;\n', '    }\n', '    function investorExists(address _investor) public view returns(bool) {\n', '        if (deals[_investor].etherAmount > 0) return true;\n', '        else return false;\n', '    }\n', '    function failSafe() public {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract AgileArbitrationWithAssistance is Owned {\n', '\n', '    address public operator;\n', '\n', '    uint public quorum = 3;\n', '\n', '    struct Dispute {\n', '        address icoRoundAddress;\n', '        address investorAddress;\n', '        bool pending;\n', '        uint timestamp;\n', '        uint milestone;\n', '        string reason;\n', '        uint votesForProject;\n', '        uint votesForInvestor;\n', '        // bool verdictForProject;\n', '        // bool verdictForInvestor;\n', '        mapping(address => bool) voters;\n', '    }\n', '    mapping(uint => Dispute) public disputes;\n', '\n', '    uint public disputeLength;\n', '\n', '    mapping(address => mapping(address => bool)) public arbiterPool;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        operator = msg.sender;\n', '    }\n', '\n', '    // OPERATOR\n', '    function setArbiters(address _icoRoundAddress, address[] _arbiters) only(owner) public {\n', '        for (uint i = 0; i < _arbiters.length ; i++) {\n', '            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\n', '        }\n', '    }\n', '\n', '    // ARBITER\n', '    function vote(uint _disputeId, bool _voteForInvestor) public {\n', '        require(disputes[_disputeId].pending == true);\n', '        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);\n', '        require(disputes[_disputeId].voters[msg.sender] != true);\n', '        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\n', '        else { disputes[_disputeId].votesForProject += 1; }\n', '        if (disputes[_disputeId].votesForInvestor == quorum) {\n', '            executeVerdict(_disputeId,true);\n', '        }\n', '        if (disputes[_disputeId].votesForProject == quorum) {\n', '            executeVerdict(_disputeId,false);\n', '        }\n', '        disputes[_disputeId].voters[msg.sender] == true;\n', '    }\n', '\n', '    // INVESTOR\n', '    function openDispute(address _icoRoundAddress, string _reason) public {\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(_icoRoundAddress);\n', '        uint milestoneDispute = cycle.currentMilestone();\n', '        require(milestoneDispute > 0);\n', '        require(cycle.investorExists(msg.sender) == true);\n', '        disputes[disputeLength].milestone = milestoneDispute;\n', '\n', '        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\n', '        disputes[disputeLength].investorAddress = msg.sender;\n', '        disputes[disputeLength].timestamp = now;\n', '        disputes[disputeLength].reason = _reason;\n', '        disputes[disputeLength].pending = true;\n', '\n', '        cycle.disputeOpened(msg.sender);\n', '        disputeLength +=1;\n', '    }\n', '\n', '    // INTERNAL\n', '    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\n', '        disputes[_disputeId].pending = false;\n', '        uint milestoneDispute = disputes[_disputeId].milestone;\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(disputes[_disputeId].icoRoundAddress);\n', '        cycle.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\n', '        //counter +=1;\n', '    }\n', '\n', '    function isPending(uint _disputedId) public view returns(bool) {\n', '        return disputes[_disputedId].pending;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.20;\n', '\n', '// File: contracts/ERC20Token.sol\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address newOwner;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) only(owner) public {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() only(newOwner) public {\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '}\n', '\n', 'contract ERC20 is Owned {\n', '    using SafeMath for uint;\n', '\n', '    uint public totalSupply;\n', '    bool public isStarted = false;\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '    modifier isStartedOnly() {\n', '        require(isStarted);\n', '        _;\n', '    }\n', '\n', '    modifier isNotStartedOnly() {\n', '        require(!isStarted);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract Token is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function start() public only(owner) isNotStartedOnly {\n', '        isStarted = true;\n', '    }\n', '\n', '    //================= Crowdsale Only =================\n', '    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '}\n', '\n', 'contract TokenWithoutStart is Owned {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(_to != address(0));\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\n', '        if(allowed[msg.sender][_spender] == _currentValue){\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function mint(address _to, uint _amount) public only(owner) returns(bool) {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\n', '        uint i = 0;\n', '        while (i < dests.length) {\n', '           mint(dests[i], values[i]);\n', '           i += 1;\n', '        }\n', '        return(i);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/AgileSetWithAssistance.sol\n', '\n', '// REMEMER TO UNCOMMENT TIME CHECKS!!!!!\n', 'contract AgileICOWithAssistance {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public operator; // ICO operator\n', '    address public juryOperator; // Jury.Online operator\n', '    address public projectWallet; // Wallet where project funds are sent\n', '    address public arbitrationAddress; // address of contract that handles arbitration\n', '    address public juryOnlineWallet; // Wallet for Jury.Online commission\n', '\n', '    bool public requireTokens; // if true, token balance needed before accept offer\n', '\n', '    uint public promisedTokens;\n', '    uint public etherAllowance;\n', '    uint public jotAllowance;\n', '    uint public commissionOnInvestmentJot; // commission paid in ETH when operator accepts offer\n', '    uint public commissionOnInvestmentEth; // commission paid in JOT when operator accepts offer\n', '    uint public percentForFuture; // percent of investment offer that is not sent to Cycle and kept for future\n', '    uint public rate = 1; // amount of token for each wei in investment offer\n', '    address public currentCycleAddress; // address of current AgileCycle contract\n', '    uint public currentCycleNumber; // indicates current cycle\n', '\n', '    uint public currentFundingRound; // indicates current funding round (should be removed)\n', '    uint public minimumInvestment;\n', '\n', '    uint public lastRateChange; // used to prevent changing rates more than once a day\n', '\n', '    Token public token; // proxy or real token\n', '    // Offer struct stores information about all offers and deals\n', '    // a deal is an accepted offer\n', '    struct Offer {\n', '        uint etherAmount; // etherAmount of investment offer\n', '        uint tokenAmount; // tokenAmount of investment offer\n', '        bool accepted; // true if offer has been accepted\n', '        uint numberOfDeals; // indicates number of deals an investor has\n', '    }\n', '    // below mapping maps an investor address to a deal number to the details\n', '    // of that deal (etherAmount, tokenAmount, accepted, numberOfDeals)\n', '    mapping(address => mapping(uint => Offer)) public offers;\n', '\n', '    address[] public cycles; // stores the addresses of cycles\n', '\n', '    // Stores the amount stored for future cycles\n', '    struct FutureDeal {\n', '        uint etherAmount; // etherAmount for future\n', '        uint tokenAmount; // tokenAmount for future\n', '    }\n', '    // below mapping maps investor address to a futureDeal, that is, an amount\n', '    // which will be used in future cycles.\n', '    mapping(address => FutureDeal) public futureDeals;\n', '\n', '    address[] public investorList; // list of investor\n', '\n', '    // FundingRound struct stores information about each FundingRound\n', '    struct FundingRound {\n', '        uint startTime;\n', '        uint endTime;\n', '        uint rate;\n', '        bool hasWhitelist;\n', '    }\n', '    FundingRound[] public roundPrices;  // stores list of funding rounds\n', '    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists (if any) for funding round\n', '\n', '    bool public saveMe;\n', '\n', '    modifier only(address _sender) {\n', '        require(msg.sender == _sender);\n', '        _;\n', '    }\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '            address _operator,\n', '            uint _commissionOnInvestmentJot,\n', '            uint _commissionOnInvestmentEth,\n', '            uint _percentForFuture,\n', '            address _projectWallet,\n', '            address _arbitrationAddress,\n', '\t    address _tokenAddress,\n', '            address _juryOperator,\n', '            address _juryOnlineWallet,\n', '\t    uint _minimumInvestment\n', '        ) public {\n', '        percentForFuture = _percentForFuture;\n', '        operator = _operator;\n', '        commissionOnInvestmentJot = _commissionOnInvestmentJot;\n', '        commissionOnInvestmentEth = _commissionOnInvestmentEth;\n', '        percentForFuture = _percentForFuture;\n', '        projectWallet = _projectWallet;\n', '        arbitrationAddress = _arbitrationAddress;\n', '\ttoken = Token(_tokenAddress);\n', '        juryOperator = _juryOperator;\n', '        juryOnlineWallet = _juryOnlineWallet;\n', '\tminimumInvestment = _minimumInvestment;\n', '    }\n', '\n', '    // PUBLIC ------------------------------------------------------------------\n', "    // payable function recieves ETH and creates an 'offer'\n", '    // wont succeed with 2300 stipend for send, must add more gas\n', '    function () public payable {\n', '        // INVESTOR SENDS OFFER BY SENDING ETH TO CONTRACT\n', '        require(msg.value > minimumInvestment);\n', '    \tfor (uint i = 0; i < roundPrices.length; i++ ) {\n', '\t\tif (now > roundPrices[i].startTime && now < roundPrices[i].endTime) {\n', '\t\t\trate = roundPrices[i].rate;\n', '\t\t\tif (roundPrices[i].hasWhitelist == true) {\n', '\t\t\t\trequire(whitelist[i][msg.sender] == true);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t/*\n', '\tif (roundPrices.length > 0) {\n', '                if (roundPrices[currentFundingRound].hasWhitelist == true) {\n', '                    require(whitelist[currentFundingRound][msg.sender] == true);\n', '                }\n', '    \t}\n', '        */\n', '        uint dealNumber = offers[msg.sender][0].numberOfDeals;\n', '        // uint dealNumber = 0;\n', '\toffers[msg.sender][dealNumber].etherAmount = msg.value;\n', '        offers[msg.sender][dealNumber].tokenAmount = msg.value*rate;\n', '        offers[msg.sender][0].numberOfDeals += 1;\n', '    }\n', '    // Investor can withdraw offer if it has not been accepted\n', '    function withdrawOffer(uint _offerNumber) public {\n', '        // INVESTOR CAN WITHDRAW OFFER\n', '        require(offers[msg.sender][_offerNumber].accepted == false);\n', '        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\n', '        offers[msg.sender][_offerNumber].etherAmount = 0;\n', '    }\n', '    // Calles by Jury.Online to retrieve commission\n', '    function withdrawEther() public {\n', '        if (msg.sender == juryOperator) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ICO OPERATOR ------------------------------------------------------------\n', '    // operator can acept offer, it keeps certain amount in futureDeals, and sends\n', '    // rest to Cycle contract by calling offerAccepted() in Cycle\n', '    function setToken(address _tokenAddress) public onlyAdmin {\n', '    \trequire(token == 0x0000000000000000000000000000000000000000);\n', '\t    token = Token(_tokenAddress);\n', '    }\n', '    function acceptOffer(address _investor, uint _offerNumber) public onlyAdmin {\n', '        require(offers[_investor][_offerNumber].etherAmount > 0);\n', '        require(offers[_investor][_offerNumber].accepted != true);\n', '\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '\n', '\t    require(cycle.sealTimestamp() > 0);\n', '\n', '        offers[_investor][_offerNumber].accepted = true;\n', '        uint _etherAmount = offers[_investor][_offerNumber].etherAmount;\n', '        uint _tokenAmount = offers[_investor][_offerNumber].tokenAmount;\n', '\n', '        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\n', '        uint _etherForFuture = _etherAmount.mul(percentForFuture).div(100);\n', '        uint _tokenForFuture =  _tokenAmount.mul(percentForFuture).div(100);\n', '\n', '        if (_offerNumber == 0) {\n', '            futureDeals[_investor].etherAmount += _etherForFuture;\n', '            futureDeals[_investor].tokenAmount += _tokenForFuture;\n', '        } else {\n', '            futureDeals[_investor] = FutureDeal(_etherForFuture,_tokenForFuture);\n', '        }\n', '\n', '        _etherAmount = _etherAmount.sub(_etherForFuture);\n', '        _tokenAmount = _tokenAmount.sub(_tokenForFuture);\n', '\n', '        if (commissionOnInvestmentEth > 0 || commissionOnInvestmentJot > 0) {\n', '            uint etherCommission = _etherAmount.mul(commissionOnInvestmentEth).div(100);\n', '            uint jotCommission = _etherAmount.mul(commissionOnInvestmentJot).div(100);\n', '\t        _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\n', '            offers[_investor][_offerNumber].etherAmount = _etherAmount;\n', '            etherAllowance += etherCommission;\n', '            jotAllowance += jotCommission;\n', '        }\n', '        investorList.push(_investor);\n', '        cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\n', '    }\n', '    // after deploying Cycle, operator adds cycle address\n', '    function addCycleAddress(address _cycleAddress) public onlyAdmin {\n', '        cycles.push(_cycleAddress);\n', '    }\n', '    // Sets the active cycle. If not first one, previous one has to be finished.\n', '    function setNextCycle() public onlyAdmin {\n', '        require(cycles.length > 0);\n', '        if (currentCycleNumber > 0) {\n', '            AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '            uint finishedTimeStamp = cycle.finishedTimeStamp();\n', '            require(now > finishedTimeStamp);\n', '            uint interval = now - finishedTimeStamp;\n', '            //require(interval > 3 days);\n', '        }\n', '        currentCycleAddress = cycles[currentCycleNumber];\n', '        currentCycleNumber += 1;\n', '    }\n', '    // to add FundingRounds\n', '    function addFundingRound(uint _startTime,uint _endTime, uint _rate, address[] _whitelist) public onlyAdmin {\n', '        if (_whitelist.length == 0) {\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_rate,false));\n', '        } else {\n', '            for (uint i=0 ; i < _whitelist.length ; i++ ) {\n', '                whitelist[roundPrices.length][_whitelist[i]] = true;\n', '            }\n', '            roundPrices.push(FundingRound(_startTime, _endTime,_rate,true));\n', '        }\n', '    }\n', '    // to set rate directly\n', '    function setRate(uint _rate) onlyAdmin public {\n', '        uint interval = now - lastRateChange;\n', '        //require(interval < 1 days);\n', '        rate = _rate;\n', '    }\n', '    // to activate a fundingRound\n', '    function setCurrentFundingRound(uint _fundingRound) public onlyAdmin {\n', '        require(roundPrices.length > _fundingRound);\n', '        currentFundingRound = _fundingRound;\n', '        rate = roundPrices[_fundingRound].rate;\n', '    }\n', '    // sends futureDeal funds to next cycle\n', '    // it has loop control in case of lack of gas\n', '    function sendFundsToNextCycle(uint _startLoop, uint _endLoop) public onlyAdmin {\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(currentCycleAddress);\n', '        require(cycle.sealTimestamp() > 0);\n', '\n', '        uint _promisedTokens = cycle.promisedTokens();\n', '        uint _balanceTokens = token.balanceOf(currentCycleAddress);\n', '\n', '        if (_endLoop == 0) _endLoop = investorList.length;\n', '        require(_endLoop <= investorList.length);\n', '\n', '        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\n', '\n', '        for ( uint i=_startLoop; i < _endLoop; i++ ) {\n', '    \t    address _investor = investorList[i];\n', '    \t    uint _etherAmount = futureDeals[_investor].etherAmount;\n', '    \t    uint _tokenAmount = futureDeals[_investor].tokenAmount;\n', '            _promisedTokens += _tokenAmount;\n', '            if (requireTokens) require(_balanceTokens >= _promisedTokens);\n', '    \t    cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\n', '    \t    futureDeals[_investor].etherAmount = 0;\n', '    \t    futureDeals[_investor].tokenAmount = 0;\n', '    \t    //futureDeals[_investor].sent = true;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // HELPERS -----------------------------------------------------------------\n', '    function failSafe() public {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract AgileCycleWithAssistance {\n', '    using SafeMath for uint;\n', '    //VARIABLES\n', '    address public operator; // should be same as ICO (no check for this yet)\n', '    address public juryOperator; // for failsafe\n', '    uint public promisedTokens; // the number of tokens owed to investor by accepting offer\n', '    uint public raisedEther; // amount of ether raised by accepting offers\n', '\n', '    bool public tokenReleaseAtStart; // whether tokens released at start or by milestones\n', '\n', '    address public icoAddress; // ICO address\n', '    address public arbitrationAddress;\n', '\n', '    bool public roundFailedToStart;\n', '    address public projectWallet;\n', '    address public juryOnlineWallet;\n', '\n', '    struct Milestone {\n', '        uint etherAmount; //how many Ether is needed for this milestone\n', '        uint tokenAmount; //how many tokens releases this milestone\n', '        uint startTime; //real time when milestone has started, set upon start\n', '        uint finishTime; //real time when milestone has finished, set upon finish\n', '        uint duration; //assumed duration for milestone implementation, set upon milestone creation\n', '        string description;\n', '        string result;\n', '    }\n', '    Milestone[] public milestones; // list of milestones\n', '\n', '    uint[] public commissionEth; // each element corresponds to amount of commission paid in each milestone\n', '    uint[] public commissionJot; // same as above, but in JOT. Both amount stored in percentages\n', '    uint public currentMilestone; // stores index of current milestone\n', '    uint public etherAllowance; // amount allowed for Jury.Online in commission ETH\n', '    uint public jotAllowance; // amount allowed for Jury.Online in commission JOT\n', '    uint public ethForMilestone; // amomunt allowed for project to withdraw in milestone\n', '    Token public token; // Real or Proxy token\n', '    uint public totalToken; // sum of Tokens in all milestones\n', '    uint public totalEther; // sum of ETH in all milstones\n', '    uint public sealTimestamp; // timestamp when Cycle is sealed\n', '\n', '    mapping(address => uint[]) public etherPartition;\n', '    mapping(address => uint[]) public tokenPartition;\n', '\n', '    struct Deal {\n', '        uint etherAmount; // amount of ETH in deal\n', '        uint tokenAmount; // amount of Tokens in deal\n', '        bool disputing; // true if disputing, funds are frozen\n', '        uint tokenAllowance; // amount allowed for investor to withdraw\n', '        uint etherUsed; // ETH already used and not available for refund\n', '        bool verdictForProject; // verdict for project\n', '        bool verdictForInvestor; // verdict for investor\n', '    }\n', '    mapping(address => Deal) public deals; // mapping of investor to deal\n', '    address[] public dealsList; // list of addresses of investor deals, used for iteration in startMilestone()\n', '\n', '    uint public finishedTimeStamp; // when all milestones are finished. Checked by ICO.\n', '\n', '    uint public postDisputeEth; // for debugging\n', '    bool public saveMe; //for failsafe\n', '    bool public cycleApproved; // Jury must approve the start of an ICO\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == operator || msg.sender == juryOperator);\n', '        _;\n', '    }\n', '    modifier sealed() {\n', '    \trequire(sealTimestamp > 0);\n', '    \t_;\n', '    }\n', '    modifier notSealed() {\n', '    \trequire(sealTimestamp == 0);\n', '    \t_;\n', '    }\n', '\n', '    constructor(\n', '            bool _tokenReleaseAtStart,\n', '            address _icoAddress,\n', '            uint[] _commissionEth,\n', '            uint[] _commissionJot,\n', '            address _operator,\n', '            address _juryOperator,\n', '            address _arbitrationAddress,\n', '            address _projectWallet,\n', '            address _juryOnlineWallet\n', '        ) public {\n', '            tokenReleaseAtStart = _tokenReleaseAtStart;\n', '            icoAddress = _icoAddress;\n', '            commissionEth = _commissionEth;\n', '            commissionJot = _commissionJot;\n', '            operator = _operator;\n', '            juryOperator = _juryOperator;\n', '            arbitrationAddress = _arbitrationAddress;\n', '            projectWallet = _projectWallet;\n', '            juryOnlineWallet = _juryOnlineWallet;\n', '    }\n', '\n', '    function setToken(address _tokenAddress) public onlyAdmin {\n', '    \trequire(token == 0x0000000000000000000000000000000000000000);\n', '\t    token = Token(_tokenAddress);\n', '    }\n', '    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\n', '    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\n', '    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\n', '    function withdrawEther() public {\n', '        if (roundFailedToStart == true) {\n', '            require(msg.sender.send(deals[msg.sender].etherAmount));\n', '        }\n', '        if (msg.sender == operator) {\n', '            require(projectWallet.send(ethForMilestone+postDisputeEth));\n', '            ethForMilestone = 0;\n', '            postDisputeEth = 0;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(juryOnlineWallet.send(etherAllowance));\n', '            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature("swapMe()")));\n', '            etherAllowance = 0;\n', '            jotAllowance = 0;\n', '        }\n', '        if (deals[msg.sender].verdictForInvestor == true) {\n', '            require(msg.sender.send(deals[msg.sender].etherAmount - deals[msg.sender].etherUsed));\n', '        }\n', '    }\n', '    // CALLED BY INVESTOR TO RETRIEVE TOKENS\n', '    function withdrawToken() public {\n', '        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\n', '        deals[msg.sender].tokenAllowance = 0;\n', '    }\n', '\n', '\n', '    // OPERATOR ----------------------------------------------------------------\n', '    function addMilestonesAndSeal(uint[] _etherAmounts, uint[] _tokenAmounts, uint[] _startTimes, uint[] _durations) public notSealed onlyAdmin {\n', '    \trequire(_etherAmounts.length == _tokenAmounts.length);\n', '\trequire(_startTimes.length == _durations.length);\n', '\trequire(_durations.length == _etherAmounts.length);\n', '\tfor (uint i = 0; i < _etherAmounts.length; i++) {\n', '\t\ttotalEther = totalEther.add(_etherAmounts[i]);\n', '\t\ttotalToken = totalToken.add(_tokenAmounts[i]);\n', '\t\tmilestones.push(Milestone(_etherAmounts[i], _tokenAmounts[i], _startTimes[i],0,_durations[i],"",""));\n', '\t}\n', '\tsealTimestamp = now;\n', '    }\n', '    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyAdmin returns(uint) {\n', '        totalEther = totalEther.add(_etherAmount);\n', '        totalToken = totalToken.add(_tokenAmount);\n', '        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, ""));\n', '    }\n', '    function approveCycle(bool _approved) public {\n', '        require(cycleApproved != true && roundFailedToStart != true);\n', '        require(msg.sender == juryOperator);\n', '        if (_approved == true) {\n', '            cycleApproved = true;\n', '        } else {\n', '            roundFailedToStart = true;\n', '        }\n', '    }\n', '    function startMilestone() public sealed onlyAdmin {\n', '        require(cycleApproved);\n', '        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\n', '        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\n', '        // require(!roundFailedToStart);\n', '        if (currentMilestone != 0 ) {\n', '            require(milestones[currentMilestone-1].finishTime > 0);\n', '            uint interval = now - milestones[currentMilestone-1].finishTime;\n', '            require(interval > 3 days);\n', '        }\n', '        for (uint i=0; i < dealsList.length ; i++) {\n', '            address investor = dealsList[i];\n', '            if (deals[investor].disputing == false) {\n', '                if (deals[investor].verdictForInvestor != true) {\n', '                    ethForMilestone += etherPartition[investor][currentMilestone];\n', '                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\n', '                    if (tokenReleaseAtStart == false) {\n', '                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        milestones[currentMilestone].startTime = now;\n', '        currentMilestone +=1;\n', '        ethForMilestone = payCommission();\n', '    }\n', '    function finishMilestone(string _result) public onlyAdmin {\n', '        require(milestones[currentMilestone-1].finishTime == 0);\n', '        // UNCOMMENT LINES BELOW FOR PRODUCTION!!!!\n', '\t    uint interval = now - milestones[currentMilestone-1].startTime;\n', '        require(interval > 1 weeks);\n', '        milestones[currentMilestone-1].finishTime = now;\n', '        milestones[currentMilestone-1].result = _result;\n', '        if (currentMilestone == milestones.length) {\n', '            finishedTimeStamp = now;\n', '        }\n', '    }\n', '    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyAdmin {\n', '        assert(_id < milestones.length);\n', '        totalEther = (totalEther - milestones[_id].etherAmount).add(_etherAmount); //previous addition\n', '        totalToken = (totalToken - milestones[_id].tokenAmount).add(_tokenAmount);\n', '        milestones[_id].etherAmount = _etherAmount;\n', '        milestones[_id].tokenAmount = _tokenAmount;\n', '        milestones[_id].startTime = _startTime;\n', '        milestones[_id].duration = _duration;\n', '        milestones[_id].description = _description;\n', '    }\n', '\n', '    function seal() public notSealed onlyAdmin {\n', '        require(milestones.length > 0);\n', '        // Uncomment bottom line to require balance when sealing contract\n', '        // currently balance is required only when accepting offer\n', '        //require(token.balanceOf(address(this)) >= promisedTokens);\n', '        sealTimestamp = now;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ONLY(ICO) ---------------------------------------------------------------\n', '    // when operator accepts offer in ICO contract, it calls this function to add deal\n', '    function offerAccepted(address _investor, uint _tokenAmount) public payable only(icoAddress) {\n', '\t    require(sealTimestamp > 0);\n', '        uint _etherAmount = msg.value;\n', '        assignPartition(_investor, _etherAmount, _tokenAmount);\n', '        if (!(deals[_investor].etherAmount > 0)) dealsList.push(_investor);\n', '        if (tokenReleaseAtStart == true) {\n', '            deals[_investor].tokenAllowance = _tokenAmount;\n', '        }\n', '        deals[_investor].etherAmount += _etherAmount;\n', '        deals[_investor].tokenAmount += _tokenAmount;\n', '    \t// ADDS TO TOTALS\n', '    \tpromisedTokens += _tokenAmount;\n', '    \traisedEther += _etherAmount;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // ONLY(ARBITRATION) -------------------------------------------------------\n', '    function disputeOpened(address _investor) public only(arbitrationAddress) {\n', '        deals[_investor].disputing = true;\n', '    }\n', '    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public only(arbitrationAddress) {\n', '        require(deals[_investor].disputing == true);\n', '        if (_verdictForInvestor) {\n', '            deals[_investor].verdictForInvestor = true;\n', '        } else {\n', '            deals[_investor].verdictForProject = true;\n', '            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\n', '                postDisputeEth += etherPartition[_investor][i];\n', '                deals[_investor].etherUsed += etherPartition[_investor][i];\n', '            }\n', '        }\n', '        deals[_investor].disputing = false;\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // INTERNAL ----------------------------------------------------------------\n', '    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\n', '        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\n', '        uint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\n', '        uint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\n', '        uint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\n', '        uint totalEtherInvestment;\n', '        uint totalTokenInvestment;\n', '        for(uint i=currentMilestone; i<milestones.length; i++) {\n', '            milestoneEtherTarget = milestones[i].etherAmount;\n', '            milestoneTokenTarget = milestones[i].tokenAmount;\n', '            milestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\n', '            milestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\n', '            totalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\n', '            totalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\n', '            if (deals[_investor].etherAmount > 0) {\n', '                etherPartition[_investor][i] += milestoneEtherAmount;\n', '                tokenPartition[_investor][i] += milestoneTokenAmount;\n', '            } else {\n', '                etherPartition[_investor].push(milestoneEtherAmount);\n', '                tokenPartition[_investor].push(milestoneTokenAmount);\n', '            }\n', '\n', '        }\n', '        /* roundingErrors += _etherAmount - totalEtherInvestment; */\n', '        etherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\n', '        tokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\n', '    }\n', '    function payCommission() internal returns(uint) {\n', '        if (commissionEth.length >= currentMilestone) {\n', '            uint ethCommission = raisedEther.mul(commissionEth[currentMilestone-1]).div(100);\n', '            uint jotCommission = raisedEther.mul(commissionJot[currentMilestone-1]).div(100);\n', '            etherAllowance += ethCommission;\n', '            jotAllowance += jotCommission;\n', '            return ethForMilestone.sub(ethCommission).sub(jotCommission);\n', '        } else {\n', '            return ethForMilestone;\n', '        }\n', '    }\n', '    // -------------------------------------------------------------------------\n', '    // HELPERS -----------------------------------------------------------------\n', '    function milestonesLength() public view returns(uint) {\n', '        return milestones.length;\n', '    }\n', '    function investorExists(address _investor) public view returns(bool) {\n', '        if (deals[_investor].etherAmount > 0) return true;\n', '        else return false;\n', '    }\n', '    function failSafe() public {\n', '        if (msg.sender == operator) {\n', '            saveMe = true;\n', '        }\n', '        if (msg.sender == juryOperator) {\n', '            require(saveMe == true);\n', '            require(juryOperator.send(address(this).balance));\n', '            uint allTheLockedTokens = token.balanceOf(this);\n', '            require(token.transfer(juryOperator,allTheLockedTokens));\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract AgileArbitrationWithAssistance is Owned {\n', '\n', '    address public operator;\n', '\n', '    uint public quorum = 3;\n', '\n', '    struct Dispute {\n', '        address icoRoundAddress;\n', '        address investorAddress;\n', '        bool pending;\n', '        uint timestamp;\n', '        uint milestone;\n', '        string reason;\n', '        uint votesForProject;\n', '        uint votesForInvestor;\n', '        // bool verdictForProject;\n', '        // bool verdictForInvestor;\n', '        mapping(address => bool) voters;\n', '    }\n', '    mapping(uint => Dispute) public disputes;\n', '\n', '    uint public disputeLength;\n', '\n', '    mapping(address => mapping(address => bool)) public arbiterPool;\n', '\n', '    modifier only(address _allowed) {\n', '        require(msg.sender == _allowed);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        operator = msg.sender;\n', '    }\n', '\n', '    // OPERATOR\n', '    function setArbiters(address _icoRoundAddress, address[] _arbiters) only(owner) public {\n', '        for (uint i = 0; i < _arbiters.length ; i++) {\n', '            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\n', '        }\n', '    }\n', '\n', '    // ARBITER\n', '    function vote(uint _disputeId, bool _voteForInvestor) public {\n', '        require(disputes[_disputeId].pending == true);\n', '        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);\n', '        require(disputes[_disputeId].voters[msg.sender] != true);\n', '        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\n', '        else { disputes[_disputeId].votesForProject += 1; }\n', '        if (disputes[_disputeId].votesForInvestor == quorum) {\n', '            executeVerdict(_disputeId,true);\n', '        }\n', '        if (disputes[_disputeId].votesForProject == quorum) {\n', '            executeVerdict(_disputeId,false);\n', '        }\n', '        disputes[_disputeId].voters[msg.sender] == true;\n', '    }\n', '\n', '    // INVESTOR\n', '    function openDispute(address _icoRoundAddress, string _reason) public {\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(_icoRoundAddress);\n', '        uint milestoneDispute = cycle.currentMilestone();\n', '        require(milestoneDispute > 0);\n', '        require(cycle.investorExists(msg.sender) == true);\n', '        disputes[disputeLength].milestone = milestoneDispute;\n', '\n', '        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\n', '        disputes[disputeLength].investorAddress = msg.sender;\n', '        disputes[disputeLength].timestamp = now;\n', '        disputes[disputeLength].reason = _reason;\n', '        disputes[disputeLength].pending = true;\n', '\n', '        cycle.disputeOpened(msg.sender);\n', '        disputeLength +=1;\n', '    }\n', '\n', '    // INTERNAL\n', '    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\n', '        disputes[_disputeId].pending = false;\n', '        uint milestoneDispute = disputes[_disputeId].milestone;\n', '        AgileCycleWithAssistance cycle = AgileCycleWithAssistance(disputes[_disputeId].icoRoundAddress);\n', '        cycle.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\n', '        //counter +=1;\n', '    }\n', '\n', '    function isPending(uint _disputedId) public view returns(bool) {\n', '        return disputes[_disputedId].pending;\n', '    }\n', '\n', '}']
