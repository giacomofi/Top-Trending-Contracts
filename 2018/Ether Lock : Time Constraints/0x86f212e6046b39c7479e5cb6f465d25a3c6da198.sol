['/**\n', '* start 21.11.18\n', '*\n', '* ███─█───█─████─████─███─█───█─█───█─█───█───████─████─█───█\n', '* █───██─██─█──█─█──█──█──██─██─██─██─██─██───█──█─█──█─██─██\n', '* ███─█─█─█─████─████──█──█─█─█─█─█─█─█─█─█───█────█──█─█─█─█\n', '* ──█─█───█─█──█─█─█───█──█───█─█───█─█───█───█──█─█──█─█───█\n', '* ███─█───█─█──█─█─█───█──█───█─█───█─█───█─█─████─████─█───█\n', '*\n', '*\n', '* - Contacts:\n', '*     -- t.me/Smart_MMM\n', '*     -- https://SmartMMM.com\n', '*\n', '* - GAIN PER 24 HOURS:\n', '*     -- Contract balance <   25 Ether:          1.0%\n', '*     -- Contract balance >= 25 Ether:              1.5%\n', '*     -- Contract balance >= 250 Ether:                2.0%\n', '*     -- Contract balance >= 2500 Ether:                  2.5% max!\n', '*     -- Contract balance >= 10000 Ether:              2.0%\n', '*     -- Contract balance >= 20000 Ether:           1.5%\n', '*     -- Contract balance >= 30000 Ether:       1.0%\n', '*     -- Contract balance >= 40000 Ether:      0.8%\n', '*     -- Contract balance >= 50000 Ether:     0.6%\n', '*     -- Contract balance >= 60000 Ether:    0.4%\n', '*     -- Contract balance >= 70000 Ether:   0.2%\n', '*     -- Contract balance >= 100000 Ether:  0.1%\n', '*\n', '*     -- Contract balance < 30% max Balance: "soft restart"\n', '*\n', '* - Minimal contribution 0.01 eth\n', '*\n', '* - Contribution allocation schemes:\n', '*    -- 91-97% payments to depositors and partners\n', '*    -- 1-3% technical support team\n', '*    -- 3-6% promotion\n', '*   depends on the contract balance. more on the website SmartMMM.com\n', '*\n', '* - How to use:\n', '*  1. Send from your personal ETH wallet to the smart-contract address any amount more than or equal to 0.01 ETH\n', "*  2. Add your refferer's wallet to a HEX data in your transaction to\n", '*      get a bonus amount back to your wallet\n', '*      if there is no referrer, you will not get any bonuses\n', '*  3. Use etherscan.io to verify your transaction\n', '*  4. Claim your dividents by sending 0 ether transaction (available anytime)\n', '*  5. You can reinvest anytime you want\n', '*\n', '* Smart contract has a "soft restart" function, details on smartMMM.com\n', '*\n', '* If you want to check your dividends, you can use etherscan.io site I / o by following the" internal Txns " tab of your wallet\n', '* Attention: do not use wallets exchanges - you will lose your money. Use your personal wallet only for transactions\n', '*\n', '* RECOMMENDED GAS LIMIT: 400000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @return the address of the owner.\n', '   */\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @return true if `msg.sender` is the owner of the contract.\n', '   */\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   * @notice Renouncing to ownership will leave the contract without an owner.\n', '   * It will not be possible to call the functions with the `onlyOwner`\n', '   * modifier anymore.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract SmartMMM is Ownable\n', '{\n', '    struct DepositItem {\n', '        uint time;\n', '        uint sum;\n', '        uint withdrawalTime;\n', '        uint restartIndex;\n', '        uint invested;\n', '        uint payments;\n', '        uint referralPayments;\n', '        uint cashback;\n', '        uint referalsLevelOneCount;\n', '        uint referalsLevelTwoCount;\n', '        address referrerLevelOne;\n', '        address referrerLevelTwo;\n', '    }\n', '\n', '    address public techSupport = 0x799358af628240603A1ce05b7D9ea211b9D64304;\n', '    address public adsSupport = 0x8Fa6E56c844be9B96C30B72cC2a8ccF6465a99F9;\n', '\n', '    mapping(address => DepositItem) public deposits;\n', '    mapping(address => bool) public referrers;\n', '    mapping(address => uint) public waitingReferrers;\n', '\n', '    uint public referrerPrice = 70700000000000000; // 0.0707 ether\n', '    uint public referrerBeforeEndTime = 0;\n', '    uint public maxBalance = 0;\n', '    uint public invested;\n', '    uint public payments;\n', '    uint public referralPayments;\n', '    uint public investorsCount;\n', '    uint[] public historyOfRestarts;\n', '\n', '    event Deposit(address indexed from, uint256 value);\n', '    event Withdraw(address indexed to, uint256 value);\n', '    event PayBonus(address indexed to, uint256 value);\n', '\n', '    constructor () public\n', '    {\n', '        historyOfRestarts.push(now);\n', '    }\n', '\n', '\n', '    function bytesToAddress(bytes source) private pure returns(address parsedAddress)\n', '    {\n', '        assembly {\n', '            parsedAddress := mload(add(source,0x14))\n', '        }\n', '        return parsedAddress;\n', '    }\n', '\n', '    function getPercents(uint balance) public pure returns(uint depositPercent, uint referrerLevelOnePercent, uint referrerLevelTwoPercent, uint cashBackPercent, uint techSupportPercent, uint adsSupportPercent)\n', '    {\n', '        if(balance < 25 ether) return (69444444444, 90, 10, 20, 30, 60);\n', '        else if(balance >= 25 ether && balance < 250 ether) return (104166666667, 80, 10, 20, 30, 60);\n', '        else if(balance >= 250 ether && balance < 2500 ether ) return (138888888889, 70, 10, 20, 30, 60);\n', '        else if(balance >= 2500 ether && balance < 10000 ether) return (173611111111, 60, 10, 20, 30, 60);\n', '        else if(balance >= 10000 ether && balance < 20000 ether) return (138888888889, 50, 10, 15, 25, 50);\n', '        else if(balance >= 20000 ether && balance < 30000 ether) return (104166666667, 40, 5, 15, 25, 50);\n', '        else if(balance >= 30000 ether && balance < 40000 ether) return (69444444444, 30, 5, 10, 20, 40);\n', '        else if(balance >= 40000 ether && balance < 50000 ether) return (55555555555, 20, 5, 5, 20, 40);\n', '        else if(balance >= 50000 ether && balance < 60000 ether) return (416666666667, 10, 5, 5, 15, 30);\n', '        else if(balance >= 60000 ether && balance < 70000 ether) return (277777777778, 8, 3, 3, 10, 20);\n', '        else if(balance >= 70000 ether && balance < 100000 ether) return (138888888889, 5, 2, 2, 10, 20);\n', '        else return (6944444444, 0, 0, 0, 10, 10);\n', '    }\n', '\n', '    function () public payable\n', '    {\n', '        uint balance = address(this).balance;\n', '        (uint depositPercent, uint referrerLevelOnePercent, uint referrerLevelTwoPercent, uint cashBackPercent, uint techSupportPercent, uint adsSupportPercent) = getPercents(balance);\n', '\n', '        if(msg.value == 0)\n', '        {\n', '            payWithdraw(msg.sender, balance, depositPercent);\n', '            return;\n', '        }\n', '\n', '        if(msg.value == referrerPrice && !referrers[msg.sender] && waitingReferrers[msg.sender] == 0 && deposits[msg.sender].sum != 0)\n', '        {\n', '            waitingReferrers[msg.sender] = now;\n', '        }\n', '        else\n', '        {\n', '            addDeposit(msg.sender, msg.value, balance, referrerLevelOnePercent, referrerLevelTwoPercent, cashBackPercent, depositPercent, techSupportPercent, adsSupportPercent);\n', '        }\n', '    }\n', '\n', '    function isNeedRestart(uint balance) private returns (bool)\n', '    {\n', '        if(balance < maxBalance / 100 * 30) {\n', '            maxBalance = 0;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function calculateNewTime(uint oldTime, uint oldSum, uint newSum, uint currentTime) public pure returns (uint)\n', '    {\n', '        return oldTime + newSum / (newSum + oldSum) * (currentTime - oldTime);\n', '    }\n', '\n', '    function calculateNewDepositSum(uint minutesBetweenRestart, uint minutesWork, uint depositSum) public pure returns (uint)\n', '    {\n', '        if(minutesWork > minutesBetweenRestart) minutesWork = minutesBetweenRestart;\n', '        return (depositSum *(100-(uint(minutesWork) * 100 / minutesBetweenRestart)+7)/100);\n', '    }\n', '\n', '    function addDeposit(address investorAddress, uint weiAmount, uint balance, uint referrerLevelOnePercent, uint referrerLevelTwoPercent, uint cashBackPercent, uint depositPercent, uint techSupportPercent, uint adsSupportPercent) private\n', '    {\n', '        checkReferrer(investorAddress, weiAmount, referrerLevelOnePercent, referrerLevelTwoPercent, cashBackPercent);\n', '        DepositItem memory deposit = deposits[investorAddress];\n', '        if(deposit.sum == 0)\n', '        {\n', '            deposit.time = now;\n', '            investorsCount++;\n', '        }\n', '        else\n', '        {\n', '            uint sum = getWithdrawSum(investorAddress, depositPercent);\n', '            deposit.sum += sum;\n', '            deposit.time = calculateNewTime(deposit.time, deposit.sum, weiAmount, now);\n', '        }\n', '        deposit.withdrawalTime = now;\n', '        deposit.sum += weiAmount;\n', '        deposit.restartIndex = historyOfRestarts.length - 1;\n', '        deposit.invested += weiAmount;\n', '        deposits[investorAddress] = deposit;\n', '\n', '        emit Deposit(investorAddress, weiAmount);\n', '\n', '        payToSupport(weiAmount, techSupportPercent, adsSupportPercent);\n', '\n', '        if (maxBalance < balance) {\n', '            maxBalance = balance;\n', '        }\n', '        invested += weiAmount;\n', '    }\n', '\n', '    function payToSupport(uint weiAmount, uint techSupportPercent, uint adsSupportPercent) private {\n', '        techSupport.transfer(weiAmount * techSupportPercent / 1000);\n', '        adsSupport.transfer(weiAmount * adsSupportPercent / 1000);\n', '    }\n', '\n', '    function checkReferrer(address investorAddress, uint weiAmount, uint referrerLevelOnePercent, uint referrerLevelTwoPercent, uint cashBackPercent) private\n', '    {\n', '        address referrerLevelOneAddress = deposits[investorAddress].referrerLevelOne;\n', '        address referrerLevelTwoAddress = deposits[investorAddress].referrerLevelTwo;\n', '        if (deposits[investorAddress].sum == 0 && msg.data.length == 20) {\n', '            referrerLevelOneAddress = bytesToAddress(bytes(msg.data));\n', '            if (referrerLevelOneAddress != investorAddress && referrerLevelOneAddress != address(0)) {\n', '                if (referrers[referrerLevelOneAddress] || waitingReferrers[referrerLevelOneAddress] != 0 && (now - waitingReferrers[referrerLevelOneAddress]) >= 7 days || now <= referrerBeforeEndTime) {\n', '                    deposits[investorAddress].referrerLevelOne = referrerLevelOneAddress;\n', '                    deposits[referrerLevelOneAddress].referalsLevelOneCount++;\n', '                    referrerLevelTwoAddress = deposits[referrerLevelOneAddress].referrerLevelOne;\n', '                    if (referrerLevelTwoAddress != investorAddress && referrerLevelTwoAddress != address(0)) {\n', '                        deposits[investorAddress].referrerLevelTwo = referrerLevelTwoAddress;\n', '                        deposits[referrerLevelTwoAddress].referalsLevelTwoCount++;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        if (referrerLevelOneAddress != address(0)) {\n', '            uint cashBackBonus = weiAmount * cashBackPercent / 1000;\n', '            uint referrerLevelOneBonus = weiAmount * referrerLevelOnePercent / 1000;\n', '\n', '            emit PayBonus(investorAddress, cashBackBonus);\n', '            emit PayBonus(referrerLevelOneAddress, referrerLevelOneBonus);\n', '\n', '            referralPayments += referrerLevelOneBonus;\n', '            deposits[referrerLevelOneAddress].referralPayments += referrerLevelOneBonus;\n', '            referrerLevelOneAddress.transfer(referrerLevelOneBonus);\n', '\n', '            deposits[investorAddress].cashback += cashBackBonus;\n', '            investorAddress.transfer(cashBackBonus);\n', '\n', '            if (referrerLevelTwoAddress != address(0)) {\n', '                uint referrerLevelTwoBonus = weiAmount * referrerLevelTwoPercent / 1000;\n', '                emit PayBonus(referrerLevelTwoAddress, referrerLevelTwoBonus);\n', '                referralPayments += referrerLevelTwoBonus;\n', '                deposits[referrerLevelTwoAddress].referralPayments += referrerLevelTwoBonus;\n', '                referrerLevelTwoAddress.transfer(referrerLevelTwoBonus);\n', '            }\n', '        }\n', '    }\n', '\n', '    function payWithdraw(address to, uint balance, uint percent) private\n', '    {\n', '        require(deposits[to].sum > 0);\n', '\n', '        if(isNeedRestart(balance))\n', '        {\n', '            historyOfRestarts.push(now);\n', '        }\n', '\n', '        uint lastRestartIndex = historyOfRestarts.length - 1;\n', '\n', '        if(lastRestartIndex - deposits[to].restartIndex >= 1)\n', '        {\n', '            uint minutesBetweenRestart = (historyOfRestarts[lastRestartIndex] - historyOfRestarts[deposits[to].restartIndex]) / 1 minutes;\n', '            uint minutesWork = (historyOfRestarts[lastRestartIndex] - deposits[to].time) / 1 minutes;\n', '            deposits[to].sum = calculateNewDepositSum(minutesBetweenRestart, minutesWork, deposits[to].sum);\n', '            deposits[to].restartIndex = lastRestartIndex;\n', '            deposits[to].time = now;\n', '        }\n', '\n', '        uint sum = getWithdrawSum(to, percent);\n', '        require(sum > 0);\n', '\n', '        deposits[to].withdrawalTime = now;\n', '        deposits[to].payments += sum;\n', '        payments += sum;\n', '        to.transfer(sum);\n', '\n', '        emit Withdraw(to, sum);\n', '    }\n', '\n', '    function getWithdrawSum(address investorAddress, uint percent) private view returns(uint sum) {\n', '        uint minutesCount = (now - deposits[investorAddress].withdrawalTime) / 1 minutes;\n', '        sum = deposits[investorAddress].sum * percent / 10000000000000000 * minutesCount;\n', '    }\n', '\n', '    function addReferrer(address referrerAddress) onlyOwner public\n', '    {\n', '        referrers[referrerAddress] = true;\n', '    }\n', '\n', '    function setReferrerPrice(uint newPrice) onlyOwner public\n', '    {\n', '        referrerPrice = newPrice;\n', '    }\n', '\n', '    function setReferrerBeforeEndTime(uint newTime) onlyOwner public\n', '    {\n', '        referrerBeforeEndTime = newTime;\n', '    }\n', '\n', '    function getDaysAfterStart() public constant returns(uint daysAfterStart) {\n', '        daysAfterStart = (now - historyOfRestarts[0]) / 1 days;\n', '    }\n', '\n', '    function getDaysAfterLastRestart() public constant returns(uint daysAfeterLastRestart) {\n', '        daysAfeterLastRestart = (now - historyOfRestarts[historyOfRestarts.length - 1]) / 1 days;\n', '    }\n', '}']