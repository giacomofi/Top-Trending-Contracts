['pragma solidity ^0.4.13;\n', '\n', 'interface IAffiliateList {\n', '    /**\n', '     * @dev Sets the given address as an affiliate.\n', '     *      If the address is not currently an affiliate, startTimestamp is required\n', '     *      and endTimestamp is optional.\n', '     *      If the address is already registered as an affiliate, both values are optional.\n', '     * @param startTimestamp Timestamp when the address became/becomes an affiliate.\n', '     * @param endTimestamp Timestamp when the address will no longer be an affiliate.\n', '     */\n', '    function set(address addr, uint startTimestamp, uint endTimestamp) external;\n', '\n', '    /**\n', '     * @dev Retrieves the start and end timestamps for the given address.\n', '     *      It is sufficient to check the start value to determine if the address\n', '     *      is an affiliate (start will be greater than zero).\n', '     */\n', '    function get(address addr) external view returns (uint start, uint end);\n', '\n', '    /**\n', '     * @dev Returns true if the address is, was, or will be an affiliate at the given time.\n', '     */\n', '    function inListAsOf(address addr, uint time) external view returns (bool);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract IInvestorList {\n', '    string public constant ROLE_REGD = "regd";\n', '    string public constant ROLE_REGCF = "regcf";\n', '    string public constant ROLE_REGS = "regs";\n', '    string public constant ROLE_UNKNOWN = "unknown";\n', '\n', '    function inList(address addr) public view returns (bool);\n', '    function addAddress(address addr, string role) public;\n', '    function getRole(address addr) public view returns (string);\n', '    function hasRole(address addr, string role) public view returns (bool);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Starts the 2-step process of changing ownership. The new owner\n', '     * must then call `acceptOwnership()`.\n', '     */\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Completes the process of transferring ownership to a new owner.\n', '     */\n', '    function acceptOwnership() public {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '            newOwner = 0;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract AffiliateList is Ownable, IAffiliateList {\n', '    event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n', '    event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n', '\n', '    mapping (address => uint) public affiliateStart;\n', '    mapping (address => uint) public affiliateEnd;\n', '\n', '    function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n', '        require(addr != address(0));\n', '\n', '        uint existingStart = affiliateStart[addr];\n', '\n', '        if(existingStart == 0) {\n', '            // this is a new address\n', '\n', '            require(startTimestamp != 0);\n', '            affiliateStart[addr] = startTimestamp;\n', '\n', '            if(endTimestamp != 0) {\n', '                require(endTimestamp > startTimestamp);\n', '                affiliateEnd[addr] = endTimestamp;\n', '            }\n', '\n', '            emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n', '        }\n', '        else {\n', '            // this address was previously registered\n', '\n', '            if(startTimestamp == 0) {\n', '                // don&#39;t update the start timestamp\n', '\n', '                if(endTimestamp == 0) {\n', '                    affiliateStart[addr] = 0;\n', '                    affiliateEnd[addr] = 0;\n', '                }\n', '                else {\n', '                    require(endTimestamp > existingStart);\n', '                }\n', '            }\n', '            else {\n', '                // update the start timestamp\n', '                affiliateStart[addr] = startTimestamp;\n', '\n', '                if(endTimestamp != 0) {\n', '                    require(endTimestamp > startTimestamp);\n', '                }\n', '            }\n', '            affiliateEnd[addr] = endTimestamp;\n', '\n', '            emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n', '        }\n', '    }\n', '\n', '    function get(address addr) public view returns (uint start, uint end) {\n', '        return (affiliateStart[addr], affiliateEnd[addr]);\n', '    }\n', '\n', '    function inListAsOf(address addr, uint time) public view returns (bool) {\n', '        uint start;\n', '        uint end;\n', '        (start, end) = get(addr);\n', '        if(start == 0) {\n', '            return false;\n', '        }\n', '        if(time < start) {\n', '            return false;\n', '        }\n', '        if(end != 0 && time >= end) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract InvestorList is Ownable, IInvestorList {\n', '    event AddressAdded(address addr, string role);\n', '    event AddressRemoved(address addr, string role);\n', '\n', '    mapping (address => string) internal investorList;\n', '\n', '    /**\n', '     * @dev Throws if called by any account that&#39;s not investorListed.\n', '     * @param role string\n', '     */\n', '    modifier validRole(string role) {\n', '        require(\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Getter to determine if address is in investorList.\n', '     * @param addr address\n', '     * @return true if the address was added to the investorList, false if the address was already in the investorList\n', '     */\n', '    function inList(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (bytes(investorList[addr]).length != 0) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Getter for address role if address is in list.\n', '     * @param addr address\n', '     * @return string for address role\n', '     */\n', '    function getRole(address addr)\n', '        public\n', '        view\n', '        returns (string)\n', '    {\n', '        require(inList(addr));\n', '        return investorList[addr];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns a boolean indicating if the given address is in the list\n', '     *      with the given role.\n', '     * @param addr address to check\n', '     * @param role role to check\n', '     * @ return boolean for whether the address is in the list with the role\n', '     */\n', '    function hasRole(address addr, string role)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n', '    }\n', '\n', '    /**\n', '     * @dev Add single address to the investorList.\n', '     * @param addr address\n', '     * @param role string\n', '     */\n', '    function addAddress(address addr, string role)\n', '        onlyOwner\n', '        validRole(role)\n', '        public\n', '    {\n', '        investorList[addr] = role;\n', '        emit AddressAdded(addr, role);\n', '    }\n', '\n', '    /**\n', '     * @dev Add multiple addresses to the investorList.\n', '     * @param addrs addresses\n', '     * @param role string\n', '     */\n', '    function addAddresses(address[] addrs, string role)\n', '        onlyOwner\n', '        validRole(role)\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            addAddress(addrs[i], role);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Remove single address from the investorList.\n', '     * @param addr address\n', '     */\n', '    function removeAddress(address addr)\n', '        onlyOwner\n', '        public\n', '    {\n', '        // removeRole(addr, ROLE_WHITELISTED);\n', '        require(inList(addr));\n', '        string memory role = investorList[addr];\n', '        investorList[addr] = "";\n', '        emit AddressRemoved(addr, role);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove multiple addresses from the investorList.\n', '     * @param addrs addresses\n', '     */\n', '    function removeAddresses(address[] addrs)\n', '        onlyOwner\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (inList(addrs[i])) {\n', '                removeAddress(addrs[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ISecurityController {\n', '    function balanceOf(address _a) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '\n', '    function isTransferAuthorized(address _from, address _to) public view returns (bool);\n', '    function setTransferAuthorized(address from, address to, uint expiry) public;\n', '\n', '    function transfer(address _from, address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint);\n', '    function approve(address _owner, address _spender, uint _value) public returns (bool success);\n', '    function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n', '    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n', '\n', '    function burn(address _owner, uint _amount) public;\n', '    function ledgerTransfer(address from, address to, uint val) public;\n', '    function setLedger(address _ledger) public;\n', '    function setSale(address _sale) public;\n', '    function setToken(address _token) public;\n', '    function setAffiliateList(address _affiliateList) public;\n', '}\n', '\n', 'contract SecurityController is ISecurityController, Ownable {\n', '    ISecurityLedger public ledger;\n', '    ISecurityToken public token;\n', '    ISecuritySale public sale;\n', '    IInvestorList public investorList;\n', '    ITransferAuthorizations public transferAuthorizations;\n', '    IAffiliateList public affiliateList;\n', '\n', '    uint public lockoutPeriod = 10 * 60 * 60; // length in seconds of the lockout period\n', '\n', '    // restrict who can grant transfer authorizations\n', '    mapping(address => bool) public transferAuthPermission;\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function setTransferAuthorized(address from, address to, uint expiry) public {\n', '        // Must be called from address in the transferAuthPermission mapping\n', '        require(transferAuthPermission[msg.sender]);\n', '\n', '        // don&#39;t allow &#39;from&#39; to be zero\n', '        require(from != 0);\n', '\n', '        // verify expiry is in future, but not more than 30 days\n', '        if(expiry > 0) {\n', '            require(expiry > block.timestamp);\n', '            require(expiry <= (block.timestamp + 30 days));\n', '        }\n', '\n', '        transferAuthorizations.set(from, to, expiry);\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n', '        lockoutPeriod = _lockoutPeriod;\n', '    }\n', '\n', '    function setToken(address _token) public onlyOwner {\n', '        token = ISecurityToken(_token);\n', '    }\n', '\n', '    function setLedger(address _ledger) public onlyOwner {\n', '        ledger = ISecurityLedger(_ledger);\n', '    }\n', '\n', '    function setSale(address _sale) public onlyOwner {\n', '        sale = ISecuritySale(_sale);\n', '    }\n', '\n', '    function setInvestorList(address _investorList) public onlyOwner {\n', '        investorList = IInvestorList(_investorList);\n', '    }\n', '\n', '    function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n', '        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n', '    }\n', '\n', '    function setAffiliateList(address _affiliateList) public onlyOwner {\n', '        affiliateList = IAffiliateList(_affiliateList);\n', '    }\n', '\n', '    function setDependencies(address _token, address _ledger, address _sale,\n', '        address _investorList, address _transferAuthorizations, address _affiliateList)\n', '        public onlyOwner\n', '    {\n', '        token = ISecurityToken(_token);\n', '        ledger = ISecurityLedger(_ledger);\n', '        sale = ISecuritySale(_sale);\n', '        investorList = IInvestorList(_investorList);\n', '        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n', '        affiliateList = IAffiliateList(_affiliateList);\n', '    }\n', '\n', '    function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n', '        require(agent != address(0));\n', '        transferAuthPermission[agent] = hasPermission;\n', '    }\n', '\n', '    modifier onlyToken() {\n', '        require(msg.sender == address(token));\n', '        _;\n', '    }\n', '\n', '    modifier onlyLedger() {\n', '        require(msg.sender == address(ledger));\n', '        _;\n', '    }\n', '\n', '    // public functions\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return ledger.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _a) public view returns (uint) {\n', '        return ledger.balanceOf(_a);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return ledger.allowance(_owner, _spender);\n', '    }\n', '\n', '    function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n', '        // A `from` address could have both an allowance for the `to` address\n', '        // and a global allowance (to the zero address). We pick the maximum\n', '        // of the two.\n', '\n', '        uint expiry = transferAuthorizations.get(_from, _to);\n', '        uint globalExpiry = transferAuthorizations.get(_from, 0);\n', '        if(globalExpiry > expiry) {\n', '            expiry = globalExpiry;\n', '        }\n', '\n', '        return expiry > block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * @dev Determines whether the given transfer is possible. Returns multiple\n', '     *      boolean flags specifying how the transfer must occur.\n', '     *      This is kept public to provide for testing and subclasses overriding behavior.\n', '     * @param _from Address the tokens are being transferred from\n', '     * @param _to Address the tokens are being transferred to\n', '     * @param _value Number of tokens that would be transferred\n', '     * @param lockoutTime A point in time, specified in epoch time, that specifies\n', '     *                    the lockout period (typically 1 year before now).\n', '     * @return canTransfer Whether the transfer can occur at all.\n', '     * @return useLockoutTime Whether the lockoutTime should be used to determine which tokens to transfer.\n', '     * @return newTokensAreRestricted Whether the transferred tokens should be marked as restricted.\n', '     * @return preservePurchaseDate Whether the purchase date on the tokens should be preserved, or reset to &#39;now&#39;.\n', '     */\n', '    function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n', '        public\n', '        returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n', '\n', '        // DEFAULT BEHAVIOR:\n', '        //\n', '        // If there exists a Transfer Agent authorization, allow transfer regardless\n', '        //\n', '        // All transfers from an affiliate must be authorized by Transfer Agent\n', '        //   - tokens become restricted\n', '        //\n', '        // From Reg S to Reg S: allowable, regardless of holding period\n', '        //\n', '        // otherwise must meet holding period\n', '\n', '        // presently this isn&#39;t used, so always setting to false to avoid warning\n', '        preservePurchaseDate = false;\n', '\n', '        bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n', '\n', '        bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n', '        bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n', '\n', '        if(transferIsAuthorized) {\n', '            canTransfer = true;\n', '            if(fromIsAffiliate || toIsAffiliate) {\n', '                newTokensAreRestricted = true;\n', '            }\n', '            // useLockoutTime will remain false\n', '            // preservePurchaseDate will remain false\n', '        }\n', '        else if(!fromIsAffiliate) {\n', '            // see if both are Reg S\n', '            if(investorList.hasRole(_from, investorList.ROLE_REGS())\n', '                && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n', '                canTransfer = true;\n', '                // newTokensAreRestricted will remain false\n', '                // useLockoutTime will remain false\n', '                // preservePurchaseDate will remain false\n', '            }\n', '            else {\n', '                if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n', '                    canTransfer = true;\n', '                    useLockoutTime = true;\n', '                    // newTokensAreRestricted will remain false\n', '                    // preservePurchaseDate will remain false\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    // functions below this line are onlyLedger\n', '\n', '    // let the ledger send transfer events (the most obvious case\n', '    // is when we mint directly to the ledger and need the Transfer()\n', '    // events to appear in the token)\n', '    function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n', '        token.controllerTransfer(from, to, val);\n', '    }\n', '\n', '    // functions below this line are onlyToken\n', '\n', '    function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n', '        uint lockoutTime = block.timestamp - lockoutPeriod;\n', '        bool canTransfer;\n', '        bool useLockoutTime;\n', '        bool newTokensAreRestricted;\n', '        bool preservePurchaseDate;\n', '        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n', '            = checkTransfer(_from, _to, _value, lockoutTime);\n', '\n', '        if(!canTransfer) {\n', '            return false;\n', '        }\n', '\n', '        uint overrideLockoutTime = lockoutTime;\n', '        if(!useLockoutTime) {\n', '            overrideLockoutTime = 0;\n', '        }\n', '\n', '        return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n', '        uint lockoutTime = block.timestamp - lockoutPeriod;\n', '        bool canTransfer;\n', '        bool useLockoutTime;\n', '        bool newTokensAreRestricted;\n', '        bool preservePurchaseDate;\n', '        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n', '            = checkTransfer(_from, _to, _value, lockoutTime);\n', '\n', '        if(!canTransfer) {\n', '            return false;\n', '        }\n', '\n', '        uint overrideLockoutTime = lockoutTime;\n', '        if(!useLockoutTime) {\n', '            overrideLockoutTime = 0;\n', '        }\n', '\n', '        return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n', '        return ledger.approve(_owner, _spender, _value);\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n', '        return ledger.increaseApproval(_owner, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n', '        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n', '    }\n', '\n', '    function burn(address _owner, uint _amount) public onlyToken {\n', '        ledger.burn(_owner, _amount);\n', '    }\n', '}\n', '\n', 'interface ISecurityLedger {\n', '    function balanceOf(address _a) external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n', '    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n', '    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '    function approve(address _owner, address _spender, uint _value) external returns (bool success);\n', '    function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n', '    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n', '\n', '    function burn(address _owner, uint _amount) external;\n', '    function setController(address _controller) external;\n', '}\n', '\n', 'contract SecurityLedger is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct TokenLot {\n', '        uint amount;\n', '        uint purchaseDate;\n', '        bool restricted;\n', '    }\n', '    mapping(address => TokenLot[]) public tokenLotsOf;\n', '\n', '    SecurityController public controller;\n', '    mapping(address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    uint public totalSupply;\n', '    uint public mintingNonce;\n', '    bool public mintingStopped;\n', '\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setController(address _controller) public onlyOwner {\n', '        controller = SecurityController(_controller);\n', '    }\n', '\n', '    function stopMinting() public onlyOwner {\n', '        mintingStopped = true;\n', '    }\n', '\n', '    //TODO: not sure if this function should stay long term\n', '    function mint(address addr, uint value, uint timestamp) public onlyOwner {\n', '        require(!mintingStopped);\n', '\n', '        uint time = timestamp;\n', '        if(time == 0) {\n', '            time = block.timestamp;\n', '        }\n', '\n', '        balanceOf[addr] = balanceOf[addr].add(value);\n', '        tokenLotsOf[addr].push(TokenLot(value, time, true));\n', '        controller.ledgerTransfer(0, addr, value);\n', '        totalSupply = totalSupply.add(value);\n', '    }\n', '\n', '    function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n', '        require(!mintingStopped);\n', '        if (nonce != mintingNonce) return;\n', '        mintingNonce = mintingNonce.add(1);\n', '        uint256 lomask = (1 << 96) - 1;\n', '        uint created = 0;\n', '\n', '        uint time = timestamp;\n', '        if(time == 0) {\n', '            time = block.timestamp;\n', '        }\n', '\n', '        for (uint i = 0; i < bits.length; i++) {\n', '            address addr = address(bits[i]>>96);\n', '            uint value = bits[i] & lomask;\n', '            balanceOf[addr] = balanceOf[addr].add(value);\n', '            tokenLotsOf[addr].push(TokenLot(value, time, true));\n', '            controller.ledgerTransfer(0, addr, value);\n', '            created = created.add(value);\n', '        }\n', '        totalSupply = totalSupply.add(created);\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '\n', '    // functions below this line are onlyController\n', '\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Walks through the list of TokenLots for the given address, attempting to find\n', '     *      `amount` tokens that can be transferred. It uses the given `lockoutTime` if\n', '     *      the supplied value is not zero. If `removeTokens` is true the tokens are\n', '     *      actually removed from the address, otherwise this function acts as a dry run.\n', '     *      The value returned is the actual number of transferrable tokens found, up to\n', '     *      the maximum value of `amount`.\n', '     */\n', '    function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n', '        bool newTokensAreRestricted, bool preservePurchaseDate)\n', '        internal returns (uint numTransferrableTokens)\n', '    {\n', '        TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n', '        for(uint i=0; i<fromTokenLots.length; i++) {\n', '            TokenLot storage lot = fromTokenLots[i];\n', '            uint lotAmount = lot.amount;\n', '\n', '            // skip if there are no available tokens\n', '            if(lotAmount == 0) {\n', '                continue;\n', '            }\n', '\n', '            if(lockoutTime > 0) {\n', '                // skip if it is more recent than the lockout period AND it&#39;s restricted\n', '                if(lot.restricted && lot.purchaseDate > lockoutTime) {\n', '                    continue;\n', '                }\n', '            }\n', '\n', '            uint remaining = amount.sub(numTransferrableTokens);\n', '\n', '            if(lotAmount >= remaining) {\n', '                numTransferrableTokens = numTransferrableTokens.add(remaining);\n', '                if(removeTokens) {\n', '                    lot.amount = lotAmount.sub(remaining);\n', '                    if(to != address(0)) {\n', '                        if(preservePurchaseDate) {\n', '                            tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n', '                        }\n', '                        else {\n', '                            tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n', '                        }\n', '                    }\n', '                }\n', '                break;\n', '            }\n', '\n', '            // If we&#39;re here, then amount in this lot is not yet enough.\n', '            // Take all of it.\n', '            numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n', '            if(removeTokens) {\n', '                lot.amount = 0;\n', '                if(to != address(0)) {\n', '                    if(preservePurchaseDate) {\n', '                        tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n', '                    }\n', '                    else {\n', '                        tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n', '        return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        // ensure number of tokens removed from TokenLots is as expected\n', '        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n', '        require(tokensTransferred == _value);\n', '\n', '        // adjust balances\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        // ensure there is enough allowance\n', '        uint allowed = allowance[_from][_spender];\n', '        if (allowed < _value) return false;\n', '\n', '        // ensure number of tokens removed from TokenLots is as expected\n', '        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n', '        require(tokensTransferred == _value);\n', '\n', '        // adjust balances\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '        allowance[_from][_spender] = allowed.sub(_value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n', '        // require user to set to zero before resetting to nonzero\n', '        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n', '            return false;\n', '        }\n', '\n', '        allowance[_owner][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        allowance[_owner][_spender] = oldValue.add(_addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[_owner][_spender] = 0;\n', '        } else {\n', '            allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function burn(address _owner, uint _amount) public onlyController {\n', '        require(balanceOf[_owner] >= _amount);\n', '\n', '        balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n', '\n', '        // remove tokens from TokenLots\n', '        // (i.e. transfer them to 0)\n', '        walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n', '\n', '        totalSupply = totalSupply.sub(_amount);\n', '    }\n', '}\n', '\n', 'interface ISecuritySale {\n', '    function setLive(bool newLiveness) external;\n', '    function setInvestorList(address _investorList) external;\n', '}\n', '\n', 'contract SecuritySale is Ownable {\n', '\n', '    bool public live;        // sale is live right now\n', '    IInvestorList public investorList; // approved contributors\n', '\n', '    event SaleLive(bool liveness);\n', '    event EtherIn(address from, uint amount);\n', '    event StartSale();\n', '    event EndSale();\n', '\n', '    constructor() public {\n', '        live = false;\n', '    }\n', '\n', '    function setInvestorList(address _investorList) public onlyOwner {\n', '        investorList = IInvestorList(_investorList);\n', '    }\n', '\n', '    function () public payable {\n', '        require(live);\n', '        require(investorList.inList(msg.sender));\n', '        emit EtherIn(msg.sender, msg.value);\n', '    }\n', '\n', '    // set liveness\n', '    function setLive(bool newLiveness) public onlyOwner {\n', '        if(live && !newLiveness) {\n', '            live = false;\n', '            emit EndSale();\n', '        }\n', '        else if(!live && newLiveness) {\n', '            live = true;\n', '            emit StartSale();\n', '        }\n', '    }\n', '\n', '    // withdraw all of the Ether to owner\n', '    function withdraw() public onlyOwner {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    // withdraw some of the Ether to owner\n', '    function withdrawSome(uint value) public onlyOwner {\n', '        require(value <= address(this).balance);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    // withdraw tokens to owner\n', '    function withdrawTokens(address token) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(msg.sender, t.balanceOf(this)));\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '}\n', '\n', 'interface ISecurityToken {\n', '    function balanceOf(address addr) external view returns(uint);\n', '    function transfer(address to, uint amount) external returns(bool);\n', '    function controllerTransfer(address _from, address _to, uint _value) external;\n', '}\n', '\n', 'contract SecurityToken is Ownable{\n', '    using SafeMath for uint256;\n', '\n', '    ISecurityController public controller;\n', '    // these public fields are set once in constructor\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    constructor(string _name, string  _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setName(string _name) public onlyOwner {\n', '        name = _name;\n', '    }\n', '\n', '    function setSymbol(string _symbol) public onlyOwner {\n', '        symbol = _symbol;\n', '    }\n', '    \n', '    function setController(address _c) public onlyOwner {\n', '        controller = ISecurityController(_c);\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '\n', '    // functions below this line are public\n', '\n', '    function balanceOf(address a) public view returns (uint) {\n', '        return controller.balanceOf(a);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return controller.totalSupply();\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return controller.allowance(_owner, _spender);\n', '    }\n', '\n', '    function burn(uint _amount) public {\n', '        controller.burn(msg.sender, _amount);\n', '        emit Transfer(msg.sender, 0x0, _amount);\n', '    }\n', '\n', '    // functions below this line are onlyPayloadSize\n', '\n', '    // TODO: investigate this security optimization more\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length >= numwords.mul(32).add(4));\n', '        _;\n', '    }\n', '\n', '    function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n', '        return controller.isTransferAuthorized(_from, _to);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.transfer(msg.sender, _to, _value)) {\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n', '        if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n', '        if (controller.approve(msg.sender, _spender, _value)) {\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            emit Approval(msg.sender, _spender, newval);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            emit Approval(msg.sender, _spender, newval);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // functions below this line are onlyController\n', '\n', '    modifier onlyController() {\n', '        assert(msg.sender == address(controller));\n', '        _;\n', '    }\n', '\n', '    function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '}\n', '\n', 'interface ITransferAuthorizations {\n', '    function setController(address _controller) external;\n', '    function get(address from, address to) external view returns (uint);\n', '    function set(address from, address to, uint expiry) external;\n', '}\n', '\n', 'contract TransferAuthorizations is Ownable, ITransferAuthorizations {\n', '\n', '    /**\n', '     * @dev The first key is the `from` address. The second key is the `to` address.\n', '     *      The uint value of the mapping is the epoch time (seconds since 1/1/1970)\n', '     *      of the expiration of the approved transfer.\n', '     */\n', '    mapping(address => mapping(address => uint)) public authorizations;\n', '\n', '    /**\n', '     * @dev This controller is the only contract allowed to call the `set` function.\n', '     */\n', '    address public controller;\n', '\n', '    event TransferAuthorizationSet(address from, address to, uint expiry);\n', '\n', '    function setController(address _controller) public onlyOwner {\n', '        controller = _controller;\n', '    }\n', '\n', '    modifier onlyController() {\n', '        assert(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the authorization for a transfer to occur between the &#39;from&#39; and\n', '     *      &#39;to&#39; addresses, to expire at the &#39;expiry&#39; time.\n', '     * @param from The address from which funds would be transferred.\n', '     * @param to The address to which funds would be transferred. This can be\n', '     *           the zero address to allow transfers to any address.\n', '     * @param expiry The epoch time (seconds since 1/1/1970) at which point this\n', '     *               authorization will no longer be valid.\n', '     */\n', '    function set(address from, address to, uint expiry) public onlyController {\n', '        require(from != 0);\n', '        authorizations[from][to] = expiry;\n', '        emit TransferAuthorizationSet(from, to, expiry);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the expiration time for the transfer authorization between the\n', '     *      given addresses. Returns 0 if not allowed.\n', '     * @param from The address from which funds would be transferred.\n', '     * @param to The address to which funds would be transferred. This can be\n', '     *           the zero address to allow transfers to any address.\n', '     */\n', '    function get(address from, address to) public view returns (uint) {\n', '        return authorizations[from][to];\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'interface IAffiliateList {\n', '    /**\n', '     * @dev Sets the given address as an affiliate.\n', '     *      If the address is not currently an affiliate, startTimestamp is required\n', '     *      and endTimestamp is optional.\n', '     *      If the address is already registered as an affiliate, both values are optional.\n', '     * @param startTimestamp Timestamp when the address became/becomes an affiliate.\n', '     * @param endTimestamp Timestamp when the address will no longer be an affiliate.\n', '     */\n', '    function set(address addr, uint startTimestamp, uint endTimestamp) external;\n', '\n', '    /**\n', '     * @dev Retrieves the start and end timestamps for the given address.\n', '     *      It is sufficient to check the start value to determine if the address\n', '     *      is an affiliate (start will be greater than zero).\n', '     */\n', '    function get(address addr) external view returns (uint start, uint end);\n', '\n', '    /**\n', '     * @dev Returns true if the address is, was, or will be an affiliate at the given time.\n', '     */\n', '    function inListAsOf(address addr, uint time) external view returns (bool);\n', '}\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract IInvestorList {\n', '    string public constant ROLE_REGD = "regd";\n', '    string public constant ROLE_REGCF = "regcf";\n', '    string public constant ROLE_REGS = "regs";\n', '    string public constant ROLE_UNKNOWN = "unknown";\n', '\n', '    function inList(address addr) public view returns (bool);\n', '    function addAddress(address addr, string role) public;\n', '    function getRole(address addr) public view returns (string);\n', '    function hasRole(address addr, string role) public view returns (bool);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Starts the 2-step process of changing ownership. The new owner\n', '     * must then call `acceptOwnership()`.\n', '     */\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Completes the process of transferring ownership to a new owner.\n', '     */\n', '    function acceptOwnership() public {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '            newOwner = 0;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract AffiliateList is Ownable, IAffiliateList {\n', '    event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n', '    event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n', '\n', '    mapping (address => uint) public affiliateStart;\n', '    mapping (address => uint) public affiliateEnd;\n', '\n', '    function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n', '        require(addr != address(0));\n', '\n', '        uint existingStart = affiliateStart[addr];\n', '\n', '        if(existingStart == 0) {\n', '            // this is a new address\n', '\n', '            require(startTimestamp != 0);\n', '            affiliateStart[addr] = startTimestamp;\n', '\n', '            if(endTimestamp != 0) {\n', '                require(endTimestamp > startTimestamp);\n', '                affiliateEnd[addr] = endTimestamp;\n', '            }\n', '\n', '            emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n', '        }\n', '        else {\n', '            // this address was previously registered\n', '\n', '            if(startTimestamp == 0) {\n', "                // don't update the start timestamp\n", '\n', '                if(endTimestamp == 0) {\n', '                    affiliateStart[addr] = 0;\n', '                    affiliateEnd[addr] = 0;\n', '                }\n', '                else {\n', '                    require(endTimestamp > existingStart);\n', '                }\n', '            }\n', '            else {\n', '                // update the start timestamp\n', '                affiliateStart[addr] = startTimestamp;\n', '\n', '                if(endTimestamp != 0) {\n', '                    require(endTimestamp > startTimestamp);\n', '                }\n', '            }\n', '            affiliateEnd[addr] = endTimestamp;\n', '\n', '            emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n', '        }\n', '    }\n', '\n', '    function get(address addr) public view returns (uint start, uint end) {\n', '        return (affiliateStart[addr], affiliateEnd[addr]);\n', '    }\n', '\n', '    function inListAsOf(address addr, uint time) public view returns (bool) {\n', '        uint start;\n', '        uint end;\n', '        (start, end) = get(addr);\n', '        if(start == 0) {\n', '            return false;\n', '        }\n', '        if(time < start) {\n', '            return false;\n', '        }\n', '        if(end != 0 && time >= end) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract InvestorList is Ownable, IInvestorList {\n', '    event AddressAdded(address addr, string role);\n', '    event AddressRemoved(address addr, string role);\n', '\n', '    mapping (address => string) internal investorList;\n', '\n', '    /**\n', "     * @dev Throws if called by any account that's not investorListed.\n", '     * @param role string\n', '     */\n', '    modifier validRole(string role) {\n', '        require(\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n', '            keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Getter to determine if address is in investorList.\n', '     * @param addr address\n', '     * @return true if the address was added to the investorList, false if the address was already in the investorList\n', '     */\n', '    function inList(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (bytes(investorList[addr]).length != 0) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Getter for address role if address is in list.\n', '     * @param addr address\n', '     * @return string for address role\n', '     */\n', '    function getRole(address addr)\n', '        public\n', '        view\n', '        returns (string)\n', '    {\n', '        require(inList(addr));\n', '        return investorList[addr];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns a boolean indicating if the given address is in the list\n', '     *      with the given role.\n', '     * @param addr address to check\n', '     * @param role role to check\n', '     * @ return boolean for whether the address is in the list with the role\n', '     */\n', '    function hasRole(address addr, string role)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n', '    }\n', '\n', '    /**\n', '     * @dev Add single address to the investorList.\n', '     * @param addr address\n', '     * @param role string\n', '     */\n', '    function addAddress(address addr, string role)\n', '        onlyOwner\n', '        validRole(role)\n', '        public\n', '    {\n', '        investorList[addr] = role;\n', '        emit AddressAdded(addr, role);\n', '    }\n', '\n', '    /**\n', '     * @dev Add multiple addresses to the investorList.\n', '     * @param addrs addresses\n', '     * @param role string\n', '     */\n', '    function addAddresses(address[] addrs, string role)\n', '        onlyOwner\n', '        validRole(role)\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            addAddress(addrs[i], role);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Remove single address from the investorList.\n', '     * @param addr address\n', '     */\n', '    function removeAddress(address addr)\n', '        onlyOwner\n', '        public\n', '    {\n', '        // removeRole(addr, ROLE_WHITELISTED);\n', '        require(inList(addr));\n', '        string memory role = investorList[addr];\n', '        investorList[addr] = "";\n', '        emit AddressRemoved(addr, role);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove multiple addresses from the investorList.\n', '     * @param addrs addresses\n', '     */\n', '    function removeAddresses(address[] addrs)\n', '        onlyOwner\n', '        public\n', '    {\n', '        for (uint256 i = 0; i < addrs.length; i++) {\n', '            if (inList(addrs[i])) {\n', '                removeAddress(addrs[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ISecurityController {\n', '    function balanceOf(address _a) public view returns (uint);\n', '    function totalSupply() public view returns (uint);\n', '\n', '    function isTransferAuthorized(address _from, address _to) public view returns (bool);\n', '    function setTransferAuthorized(address from, address to, uint expiry) public;\n', '\n', '    function transfer(address _from, address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint);\n', '    function approve(address _owner, address _spender, uint _value) public returns (bool success);\n', '    function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n', '    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n', '\n', '    function burn(address _owner, uint _amount) public;\n', '    function ledgerTransfer(address from, address to, uint val) public;\n', '    function setLedger(address _ledger) public;\n', '    function setSale(address _sale) public;\n', '    function setToken(address _token) public;\n', '    function setAffiliateList(address _affiliateList) public;\n', '}\n', '\n', 'contract SecurityController is ISecurityController, Ownable {\n', '    ISecurityLedger public ledger;\n', '    ISecurityToken public token;\n', '    ISecuritySale public sale;\n', '    IInvestorList public investorList;\n', '    ITransferAuthorizations public transferAuthorizations;\n', '    IAffiliateList public affiliateList;\n', '\n', '    uint public lockoutPeriod = 10 * 60 * 60; // length in seconds of the lockout period\n', '\n', '    // restrict who can grant transfer authorizations\n', '    mapping(address => bool) public transferAuthPermission;\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function setTransferAuthorized(address from, address to, uint expiry) public {\n', '        // Must be called from address in the transferAuthPermission mapping\n', '        require(transferAuthPermission[msg.sender]);\n', '\n', "        // don't allow 'from' to be zero\n", '        require(from != 0);\n', '\n', '        // verify expiry is in future, but not more than 30 days\n', '        if(expiry > 0) {\n', '            require(expiry > block.timestamp);\n', '            require(expiry <= (block.timestamp + 30 days));\n', '        }\n', '\n', '        transferAuthorizations.set(from, to, expiry);\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n', '        lockoutPeriod = _lockoutPeriod;\n', '    }\n', '\n', '    function setToken(address _token) public onlyOwner {\n', '        token = ISecurityToken(_token);\n', '    }\n', '\n', '    function setLedger(address _ledger) public onlyOwner {\n', '        ledger = ISecurityLedger(_ledger);\n', '    }\n', '\n', '    function setSale(address _sale) public onlyOwner {\n', '        sale = ISecuritySale(_sale);\n', '    }\n', '\n', '    function setInvestorList(address _investorList) public onlyOwner {\n', '        investorList = IInvestorList(_investorList);\n', '    }\n', '\n', '    function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n', '        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n', '    }\n', '\n', '    function setAffiliateList(address _affiliateList) public onlyOwner {\n', '        affiliateList = IAffiliateList(_affiliateList);\n', '    }\n', '\n', '    function setDependencies(address _token, address _ledger, address _sale,\n', '        address _investorList, address _transferAuthorizations, address _affiliateList)\n', '        public onlyOwner\n', '    {\n', '        token = ISecurityToken(_token);\n', '        ledger = ISecurityLedger(_ledger);\n', '        sale = ISecuritySale(_sale);\n', '        investorList = IInvestorList(_investorList);\n', '        transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n', '        affiliateList = IAffiliateList(_affiliateList);\n', '    }\n', '\n', '    function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n', '        require(agent != address(0));\n', '        transferAuthPermission[agent] = hasPermission;\n', '    }\n', '\n', '    modifier onlyToken() {\n', '        require(msg.sender == address(token));\n', '        _;\n', '    }\n', '\n', '    modifier onlyLedger() {\n', '        require(msg.sender == address(ledger));\n', '        _;\n', '    }\n', '\n', '    // public functions\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return ledger.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _a) public view returns (uint) {\n', '        return ledger.balanceOf(_a);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return ledger.allowance(_owner, _spender);\n', '    }\n', '\n', '    function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n', '        // A `from` address could have both an allowance for the `to` address\n', '        // and a global allowance (to the zero address). We pick the maximum\n', '        // of the two.\n', '\n', '        uint expiry = transferAuthorizations.get(_from, _to);\n', '        uint globalExpiry = transferAuthorizations.get(_from, 0);\n', '        if(globalExpiry > expiry) {\n', '            expiry = globalExpiry;\n', '        }\n', '\n', '        return expiry > block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * @dev Determines whether the given transfer is possible. Returns multiple\n', '     *      boolean flags specifying how the transfer must occur.\n', '     *      This is kept public to provide for testing and subclasses overriding behavior.\n', '     * @param _from Address the tokens are being transferred from\n', '     * @param _to Address the tokens are being transferred to\n', '     * @param _value Number of tokens that would be transferred\n', '     * @param lockoutTime A point in time, specified in epoch time, that specifies\n', '     *                    the lockout period (typically 1 year before now).\n', '     * @return canTransfer Whether the transfer can occur at all.\n', '     * @return useLockoutTime Whether the lockoutTime should be used to determine which tokens to transfer.\n', '     * @return newTokensAreRestricted Whether the transferred tokens should be marked as restricted.\n', "     * @return preservePurchaseDate Whether the purchase date on the tokens should be preserved, or reset to 'now'.\n", '     */\n', '    function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n', '        public\n', '        returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n', '\n', '        // DEFAULT BEHAVIOR:\n', '        //\n', '        // If there exists a Transfer Agent authorization, allow transfer regardless\n', '        //\n', '        // All transfers from an affiliate must be authorized by Transfer Agent\n', '        //   - tokens become restricted\n', '        //\n', '        // From Reg S to Reg S: allowable, regardless of holding period\n', '        //\n', '        // otherwise must meet holding period\n', '\n', "        // presently this isn't used, so always setting to false to avoid warning\n", '        preservePurchaseDate = false;\n', '\n', '        bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n', '\n', '        bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n', '        bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n', '\n', '        if(transferIsAuthorized) {\n', '            canTransfer = true;\n', '            if(fromIsAffiliate || toIsAffiliate) {\n', '                newTokensAreRestricted = true;\n', '            }\n', '            // useLockoutTime will remain false\n', '            // preservePurchaseDate will remain false\n', '        }\n', '        else if(!fromIsAffiliate) {\n', '            // see if both are Reg S\n', '            if(investorList.hasRole(_from, investorList.ROLE_REGS())\n', '                && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n', '                canTransfer = true;\n', '                // newTokensAreRestricted will remain false\n', '                // useLockoutTime will remain false\n', '                // preservePurchaseDate will remain false\n', '            }\n', '            else {\n', '                if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n', '                    canTransfer = true;\n', '                    useLockoutTime = true;\n', '                    // newTokensAreRestricted will remain false\n', '                    // preservePurchaseDate will remain false\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    // functions below this line are onlyLedger\n', '\n', '    // let the ledger send transfer events (the most obvious case\n', '    // is when we mint directly to the ledger and need the Transfer()\n', '    // events to appear in the token)\n', '    function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n', '        token.controllerTransfer(from, to, val);\n', '    }\n', '\n', '    // functions below this line are onlyToken\n', '\n', '    function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n', '        uint lockoutTime = block.timestamp - lockoutPeriod;\n', '        bool canTransfer;\n', '        bool useLockoutTime;\n', '        bool newTokensAreRestricted;\n', '        bool preservePurchaseDate;\n', '        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n', '            = checkTransfer(_from, _to, _value, lockoutTime);\n', '\n', '        if(!canTransfer) {\n', '            return false;\n', '        }\n', '\n', '        uint overrideLockoutTime = lockoutTime;\n', '        if(!useLockoutTime) {\n', '            overrideLockoutTime = 0;\n', '        }\n', '\n', '        return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n', '        uint lockoutTime = block.timestamp - lockoutPeriod;\n', '        bool canTransfer;\n', '        bool useLockoutTime;\n', '        bool newTokensAreRestricted;\n', '        bool preservePurchaseDate;\n', '        (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n', '            = checkTransfer(_from, _to, _value, lockoutTime);\n', '\n', '        if(!canTransfer) {\n', '            return false;\n', '        }\n', '\n', '        uint overrideLockoutTime = lockoutTime;\n', '        if(!useLockoutTime) {\n', '            overrideLockoutTime = 0;\n', '        }\n', '\n', '        return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n', '        return ledger.approve(_owner, _spender, _value);\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n', '        return ledger.increaseApproval(_owner, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n', '        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n', '    }\n', '\n', '    function burn(address _owner, uint _amount) public onlyToken {\n', '        ledger.burn(_owner, _amount);\n', '    }\n', '}\n', '\n', 'interface ISecurityLedger {\n', '    function balanceOf(address _a) external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n', '    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n', '    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '    function approve(address _owner, address _spender, uint _value) external returns (bool success);\n', '    function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n', '    function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n', '\n', '    function burn(address _owner, uint _amount) external;\n', '    function setController(address _controller) external;\n', '}\n', '\n', 'contract SecurityLedger is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    struct TokenLot {\n', '        uint amount;\n', '        uint purchaseDate;\n', '        bool restricted;\n', '    }\n', '    mapping(address => TokenLot[]) public tokenLotsOf;\n', '\n', '    SecurityController public controller;\n', '    mapping(address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    uint public totalSupply;\n', '    uint public mintingNonce;\n', '    bool public mintingStopped;\n', '\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setController(address _controller) public onlyOwner {\n', '        controller = SecurityController(_controller);\n', '    }\n', '\n', '    function stopMinting() public onlyOwner {\n', '        mintingStopped = true;\n', '    }\n', '\n', '    //TODO: not sure if this function should stay long term\n', '    function mint(address addr, uint value, uint timestamp) public onlyOwner {\n', '        require(!mintingStopped);\n', '\n', '        uint time = timestamp;\n', '        if(time == 0) {\n', '            time = block.timestamp;\n', '        }\n', '\n', '        balanceOf[addr] = balanceOf[addr].add(value);\n', '        tokenLotsOf[addr].push(TokenLot(value, time, true));\n', '        controller.ledgerTransfer(0, addr, value);\n', '        totalSupply = totalSupply.add(value);\n', '    }\n', '\n', '    function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n', '        require(!mintingStopped);\n', '        if (nonce != mintingNonce) return;\n', '        mintingNonce = mintingNonce.add(1);\n', '        uint256 lomask = (1 << 96) - 1;\n', '        uint created = 0;\n', '\n', '        uint time = timestamp;\n', '        if(time == 0) {\n', '            time = block.timestamp;\n', '        }\n', '\n', '        for (uint i = 0; i < bits.length; i++) {\n', '            address addr = address(bits[i]>>96);\n', '            uint value = bits[i] & lomask;\n', '            balanceOf[addr] = balanceOf[addr].add(value);\n', '            tokenLotsOf[addr].push(TokenLot(value, time, true));\n', '            controller.ledgerTransfer(0, addr, value);\n', '            created = created.add(value);\n', '        }\n', '        totalSupply = totalSupply.add(created);\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '\n', '    // functions below this line are onlyController\n', '\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Walks through the list of TokenLots for the given address, attempting to find\n', '     *      `amount` tokens that can be transferred. It uses the given `lockoutTime` if\n', '     *      the supplied value is not zero. If `removeTokens` is true the tokens are\n', '     *      actually removed from the address, otherwise this function acts as a dry run.\n', '     *      The value returned is the actual number of transferrable tokens found, up to\n', '     *      the maximum value of `amount`.\n', '     */\n', '    function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n', '        bool newTokensAreRestricted, bool preservePurchaseDate)\n', '        internal returns (uint numTransferrableTokens)\n', '    {\n', '        TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n', '        for(uint i=0; i<fromTokenLots.length; i++) {\n', '            TokenLot storage lot = fromTokenLots[i];\n', '            uint lotAmount = lot.amount;\n', '\n', '            // skip if there are no available tokens\n', '            if(lotAmount == 0) {\n', '                continue;\n', '            }\n', '\n', '            if(lockoutTime > 0) {\n', "                // skip if it is more recent than the lockout period AND it's restricted\n", '                if(lot.restricted && lot.purchaseDate > lockoutTime) {\n', '                    continue;\n', '                }\n', '            }\n', '\n', '            uint remaining = amount.sub(numTransferrableTokens);\n', '\n', '            if(lotAmount >= remaining) {\n', '                numTransferrableTokens = numTransferrableTokens.add(remaining);\n', '                if(removeTokens) {\n', '                    lot.amount = lotAmount.sub(remaining);\n', '                    if(to != address(0)) {\n', '                        if(preservePurchaseDate) {\n', '                            tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n', '                        }\n', '                        else {\n', '                            tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n', '                        }\n', '                    }\n', '                }\n', '                break;\n', '            }\n', '\n', "            // If we're here, then amount in this lot is not yet enough.\n", '            // Take all of it.\n', '            numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n', '            if(removeTokens) {\n', '                lot.amount = 0;\n', '                if(to != address(0)) {\n', '                    if(preservePurchaseDate) {\n', '                        tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n', '                    }\n', '                    else {\n', '                        tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n', '        return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        // ensure number of tokens removed from TokenLots is as expected\n', '        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n', '        require(tokensTransferred == _value);\n', '\n', '        // adjust balances\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        // ensure there is enough allowance\n', '        uint allowed = allowance[_from][_spender];\n', '        if (allowed < _value) return false;\n', '\n', '        // ensure number of tokens removed from TokenLots is as expected\n', '        uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n', '        require(tokensTransferred == _value);\n', '\n', '        // adjust balances\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '\n', '        allowance[_from][_spender] = allowed.sub(_value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n', '        // require user to set to zero before resetting to nonzero\n', '        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n', '            return false;\n', '        }\n', '\n', '        allowance[_owner][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        allowance[_owner][_spender] = oldValue.add(_addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[_owner][_spender] = 0;\n', '        } else {\n', '            allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function burn(address _owner, uint _amount) public onlyController {\n', '        require(balanceOf[_owner] >= _amount);\n', '\n', '        balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n', '\n', '        // remove tokens from TokenLots\n', '        // (i.e. transfer them to 0)\n', '        walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n', '\n', '        totalSupply = totalSupply.sub(_amount);\n', '    }\n', '}\n', '\n', 'interface ISecuritySale {\n', '    function setLive(bool newLiveness) external;\n', '    function setInvestorList(address _investorList) external;\n', '}\n', '\n', 'contract SecuritySale is Ownable {\n', '\n', '    bool public live;        // sale is live right now\n', '    IInvestorList public investorList; // approved contributors\n', '\n', '    event SaleLive(bool liveness);\n', '    event EtherIn(address from, uint amount);\n', '    event StartSale();\n', '    event EndSale();\n', '\n', '    constructor() public {\n', '        live = false;\n', '    }\n', '\n', '    function setInvestorList(address _investorList) public onlyOwner {\n', '        investorList = IInvestorList(_investorList);\n', '    }\n', '\n', '    function () public payable {\n', '        require(live);\n', '        require(investorList.inList(msg.sender));\n', '        emit EtherIn(msg.sender, msg.value);\n', '    }\n', '\n', '    // set liveness\n', '    function setLive(bool newLiveness) public onlyOwner {\n', '        if(live && !newLiveness) {\n', '            live = false;\n', '            emit EndSale();\n', '        }\n', '        else if(!live && newLiveness) {\n', '            live = true;\n', '            emit StartSale();\n', '        }\n', '    }\n', '\n', '    // withdraw all of the Ether to owner\n', '    function withdraw() public onlyOwner {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    // withdraw some of the Ether to owner\n', '    function withdrawSome(uint value) public onlyOwner {\n', '        require(value <= address(this).balance);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    // withdraw tokens to owner\n', '    function withdrawTokens(address token) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(msg.sender, t.balanceOf(this)));\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '}\n', '\n', 'interface ISecurityToken {\n', '    function balanceOf(address addr) external view returns(uint);\n', '    function transfer(address to, uint amount) external returns(bool);\n', '    function controllerTransfer(address _from, address _to, uint _value) external;\n', '}\n', '\n', 'contract SecurityToken is Ownable{\n', '    using SafeMath for uint256;\n', '\n', '    ISecurityController public controller;\n', '    // these public fields are set once in constructor\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    constructor(string _name, string  _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    // functions below this line are onlyOwner\n', '\n', '    function setName(string _name) public onlyOwner {\n', '        name = _name;\n', '    }\n', '\n', '    function setSymbol(string _symbol) public onlyOwner {\n', '        symbol = _symbol;\n', '    }\n', '    \n', '    function setController(address _c) public onlyOwner {\n', '        controller = ISecurityController(_c);\n', '    }\n', '\n', '    // send received tokens to anyone\n', '    function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n', '        ERC20Basic t = ERC20Basic(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '\n', '    // functions below this line are public\n', '\n', '    function balanceOf(address a) public view returns (uint) {\n', '        return controller.balanceOf(a);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return controller.totalSupply();\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return controller.allowance(_owner, _spender);\n', '    }\n', '\n', '    function burn(uint _amount) public {\n', '        controller.burn(msg.sender, _amount);\n', '        emit Transfer(msg.sender, 0x0, _amount);\n', '    }\n', '\n', '    // functions below this line are onlyPayloadSize\n', '\n', '    // TODO: investigate this security optimization more\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length >= numwords.mul(32).add(4));\n', '        _;\n', '    }\n', '\n', '    function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n', '        return controller.isTransferAuthorized(_from, _to);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.transfer(msg.sender, _to, _value)) {\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n', '        if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n', '        if (controller.approve(msg.sender, _spender, _value)) {\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            emit Approval(msg.sender, _spender, newval);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n', '        if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            emit Approval(msg.sender, _spender, newval);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // functions below this line are onlyController\n', '\n', '    modifier onlyController() {\n', '        assert(msg.sender == address(controller));\n', '        _;\n', '    }\n', '\n', '    function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n', '        emit Approval(_owner, _spender, _value);\n', '    }\n', '}\n', '\n', 'interface ITransferAuthorizations {\n', '    function setController(address _controller) external;\n', '    function get(address from, address to) external view returns (uint);\n', '    function set(address from, address to, uint expiry) external;\n', '}\n', '\n', 'contract TransferAuthorizations is Ownable, ITransferAuthorizations {\n', '\n', '    /**\n', '     * @dev The first key is the `from` address. The second key is the `to` address.\n', '     *      The uint value of the mapping is the epoch time (seconds since 1/1/1970)\n', '     *      of the expiration of the approved transfer.\n', '     */\n', '    mapping(address => mapping(address => uint)) public authorizations;\n', '\n', '    /**\n', '     * @dev This controller is the only contract allowed to call the `set` function.\n', '     */\n', '    address public controller;\n', '\n', '    event TransferAuthorizationSet(address from, address to, uint expiry);\n', '\n', '    function setController(address _controller) public onlyOwner {\n', '        controller = _controller;\n', '    }\n', '\n', '    modifier onlyController() {\n', '        assert(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    /**\n', "     * @dev Sets the authorization for a transfer to occur between the 'from' and\n", "     *      'to' addresses, to expire at the 'expiry' time.\n", '     * @param from The address from which funds would be transferred.\n', '     * @param to The address to which funds would be transferred. This can be\n', '     *           the zero address to allow transfers to any address.\n', '     * @param expiry The epoch time (seconds since 1/1/1970) at which point this\n', '     *               authorization will no longer be valid.\n', '     */\n', '    function set(address from, address to, uint expiry) public onlyController {\n', '        require(from != 0);\n', '        authorizations[from][to] = expiry;\n', '        emit TransferAuthorizationSet(from, to, expiry);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the expiration time for the transfer authorization between the\n', '     *      given addresses. Returns 0 if not allowed.\n', '     * @param from The address from which funds would be transferred.\n', '     * @param to The address to which funds would be transferred. This can be\n', '     *           the zero address to allow transfers to any address.\n', '     */\n', '    function get(address from, address to) public view returns (uint) {\n', '        return authorizations[from][to];\n', '    }\n', '}']
