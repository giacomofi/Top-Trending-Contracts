['pragma solidity ^0.4.18;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 FSN Token Generation and Voluntary Participants Program\n', ' * @dev see https://github.com/FusionFoundation/TokenSale\n', ' */\n', 'contract ShareTokenSale is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ERC20 public token;\n', '    address public receiverAddr;\n', '    uint256 public totalSaleAmount;\n', '    uint256 public totalWannaBuyAmount; \n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    uint256 public userWithdrawalStartTime;\n', '    uint256 public clearStartTime;\n', '    uint256 public withdrawn;\n', '    uint256 public proportion = 1 ether;\n', '    mapping(uint256 => uint256) public globalAmounts;    \n', '\n', '\n', '    struct Stage {\n', '        uint256 rate;\n', '        uint256 duration;\n', '        uint256 startTime;       \n', '    }\n', '    Stage[] public stages;    \n', '\n', '\n', '    struct PurchaserInfo {\n', '        bool withdrew;\n', '        bool recorded;\n', '        mapping(uint256 => uint256) amounts;\n', '    }\n', '    mapping(address => PurchaserInfo) public purchaserMapping;\n', '    address[] public purchaserList;\n', '\n', '    modifier onlyOpenTime {\n', '        require(isStarted());\n', '        require(!isEnded());\n', '        _;\n', '    }\n', '\n', '    modifier onlyAutoWithdrawalTime {\n', '         require(isEnded());\n', '        _;\n', '    }\n', '\n', '    modifier onlyUserWithdrawalTime {\n', '        require(isUserWithdrawalTime());\n', '        _;\n', '    }\n', '\n', '    modifier purchasersAllWithdrawn {\n', '        require(withdrawn==purchaserList.length);\n', '        _;\n', '    }\n', '\n', '    modifier onlyClearTime {\n', '        require(isClearTime());\n', '        _;\n', '    }\n', '\n', '    function ShareTokenSale(address _receiverAddr, address _tokenAddr, uint256 _totalSaleAmount, uint256 _startTime) public {\n', '        require(_receiverAddr != address(0));\n', '        require(_tokenAddr != address(0));\n', '        require(_totalSaleAmount > 0);\n', '        require(_startTime > 0);\n', '        receiverAddr = _receiverAddr;\n', '        token = ERC20(_tokenAddr);\n', '        totalSaleAmount = _totalSaleAmount;       \n', '        startTime = _startTime;        \n', '    }\n', '\n', '    function isStarted() public view returns(bool) {\n', '        return 0 < startTime && startTime <= now && endTime != 0;\n', '    }   \n', '\n', '    function isEnded() public view returns(bool) {\n', '        return now > endTime;\n', '    }\n', '\n', '    function isUserWithdrawalTime() public view returns(bool) {\n', '        return now > userWithdrawalStartTime;\n', '    }\n', '\n', '    function isClearTime() public view returns(bool) {\n', '        return now > clearStartTime;\n', '    }\n', '    \n', '    function startSale(uint256[] rates, uint256[] durations, uint256 userWithdrawalDelaySec, uint256 clearDelaySec) public onlyOwner {\n', '        require(endTime == 0);\n', '        require(durations.length == rates.length);\n', '        delete stages;\n', '        endTime = startTime;\n', '        for (uint256 i = 0; i < durations.length; i++) {\n', '            uint256 rate = rates[i];\n', '            uint256 duration = durations[i];            \n', '            stages.push(Stage({rate: rate, duration: duration, startTime:endTime}));\n', '            endTime = endTime.add(duration);\n', '        }\n', '        userWithdrawalStartTime = endTime.add(userWithdrawalDelaySec);\n', '        clearStartTime = endTime.add(clearDelaySec);\n', '    }\n', '    \n', '    function getCurrentStage() public onlyOpenTime view returns(uint256) {\n', '        for (uint256 i = stages.length - 1; i >= 0; i--) {\n', '            if (now >= stages[i].startTime) {\n', '                return i;\n', '            }\n', '        }\n', '        revert();\n', '    }\n', '\n', '    function getPurchaserCount() public view returns(uint256) {\n', '        return purchaserList.length;\n', '    }\n', '\n', '\n', '    function _calcProportion() internal {\n', '        if (totalWannaBuyAmount == 0 || totalSaleAmount >= totalWannaBuyAmount) {\n', '            proportion = 1 ether;\n', '            return;\n', '        }\n', '        proportion = totalSaleAmount.mul(1 ether).div(totalWannaBuyAmount);        \n', '    }\n', '\n', '    function getSaleInfo(address purchaser) public view returns (uint256, uint256, uint256) {\n', '        PurchaserInfo storage pi = purchaserMapping[purchaser];\n', '        uint256 sendEther = 0;\n', '        uint256 usedEther = 0;\n', '        uint256 getToken = 0;        \n', '        for (uint256 i = 0; i < stages.length; i++) {\n', '            sendEther = sendEther.add(pi.amounts[i]);\n', '            uint256 stageUsedEther = pi.amounts[i].mul(proportion).div(1 ether);\n', '            uint256 stageGetToken = stageUsedEther.mul(stages[i].rate);\n', '            if (stageGetToken > 0) {         \n', '                getToken = getToken.add(stageGetToken);\n', '                usedEther = usedEther.add(stageUsedEther);\n', '            }\n', '        }        \n', '        return (sendEther, usedEther, getToken);\n', '    }\n', '    \n', '    function () payable public {        \n', '        buy();\n', '    }\n', '    \n', '    function buy() payable public onlyOpenTime {\n', '        require(msg.value >= 0.1 ether);\n', '        uint256 stageIndex = getCurrentStage();\n', '        uint256 amount = msg.value;\n', '        PurchaserInfo storage pi = purchaserMapping[msg.sender];\n', '        if (!pi.recorded) {\n', '            pi.recorded = true;\n', '            purchaserList.push(msg.sender);\n', '        }\n', '        pi.amounts[stageIndex] = pi.amounts[stageIndex].add(amount);\n', '        globalAmounts[stageIndex] = globalAmounts[stageIndex].add(amount);\n', '        totalWannaBuyAmount = totalWannaBuyAmount.add(amount.mul(stages[stageIndex].rate));\n', '        _calcProportion();\n', '    }\n', '    \n', '    function _withdrawal(address purchaser) internal {\n', '        require(purchaser != 0x0);\n', '        PurchaserInfo storage pi = purchaserMapping[purchaser];        \n', '        if (pi.withdrew) {\n', '            return;\n', '        }\n', '        pi.withdrew = true;\n', '        withdrawn = withdrawn.add(1);\n', '        var (sendEther, usedEther, getToken) = getSaleInfo(purchaser);\n', '        if (usedEther > 0 && getToken > 0) {\n', '            receiverAddr.transfer(usedEther);\n', '            token.transfer(purchaser, getToken);\n', '            if (sendEther.sub(usedEther) > 0) {                \n', '                purchaser.transfer(sendEther.sub(usedEther));   \n', '            }           \n', '        } else {\n', '            purchaser.transfer(sendEther);\n', '        }\n', '        return;\n', '    }\n', '    \n', '    function withdrawal() payable public onlyUserWithdrawalTime {\n', '        _withdrawal(msg.sender);\n', '    }\n', '    \n', '    function withdrawalFor(uint256 index, uint256 stop) payable public onlyAutoWithdrawalTime onlyOwner {\n', '        for (; index < stop; index++) {\n', '            _withdrawal(purchaserList[index]);\n', '        }\n', '    }\n', '    \n', '    function clear(uint256 tokenAmount, uint256 etherAmount) payable public purchasersAllWithdrawn onlyClearTime onlyOwner {\n', '        if (tokenAmount > 0) {\n', '            token.transfer(receiverAddr, tokenAmount);\n', '        }\n', '        if (etherAmount > 0) {\n', '            receiverAddr.transfer(etherAmount);\n', '        }        \n', '    }\n', '}']