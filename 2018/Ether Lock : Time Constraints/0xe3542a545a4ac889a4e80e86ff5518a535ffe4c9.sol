['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/TokenHolder.sol\n', '\n', '/*\n', '\n', '   Token Holder\n', '   Hold ERC20 tokens to be withdrawn\n', '   by a user at a specific block.\n', '\n', '   - Element Group\n', '\n', '*/\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract TokenHolder {\n', '    address public tokenAddress;\n', '    uint public holdAmount;\n', '    ERC20 public Token;\n', '    mapping (address => uint256) public heldTokens;\n', '    mapping (address => uint) public heldTimeline;\n', '    event Deposit(address from, uint256 amount);\n', '    event Withdraw(address from, uint256 amount);\n', '\n', '    function TokenHolder(address token) public {\n', '        tokenAddress = token;\n', '        Token = ERC20(token);\n', '        holdAmount = 1;\n', '    }\n', '\n', '    function() payable {\n', '        revert();\n', '    }\n', '\n', '    // get the approved amount of tokens to deposit\n', '    function approvedAmount(address _from) public constant returns (uint256) {\n', '        return Token.allowance(_from, this);\n', '    }\n', '\n', '    // get the token balance for an individual address\n', '    function userBalance(address _owner) public constant returns (uint256) {\n', '        return heldTokens[_owner];\n', '    }\n', '\n', '    // get the token balance for an individual address\n', '    function userHeldTill(address _owner) public constant returns (uint) {\n', '        return heldTimeline[_owner];\n', '    }\n', '\n', '    // get the token balance inside this contract\n', '    function totalBalance() public constant returns (uint) {\n', '        return Token.balanceOf(this);\n', '    }\n', '\n', '    // deposit tokens to hold in the system\n', '    function depositTokens(uint256 amount) external {\n', '        require(Token.allowance(msg.sender, this) >= amount);\n', '        Token.transferFrom(msg.sender, this, amount);\n', '        heldTokens[msg.sender] += amount;\n', '        heldTimeline[msg.sender] = block.number + holdAmount;\n', '        Deposit(msg.sender, amount);\n', '    }\n', '\n', '    // external user can release the tokens on their own when the time comes\n', '    function withdrawTokens(uint256 amount) external {\n', '        uint256 held = heldTokens[msg.sender];\n', '        uint heldBlock = heldTimeline[msg.sender];\n', '        require(held >= 0 && held >= amount);\n', '        require(block.number >= heldBlock);\n', '        heldTokens[msg.sender] -= amount;\n', '        heldTimeline[msg.sender] = 0;\n', '        Withdraw(msg.sender, amount);\n', '        Token.transfer(msg.sender, amount);\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/TokenHolder.sol\n', '\n', '/*\n', '\n', '   Token Holder\n', '   Hold ERC20 tokens to be withdrawn\n', '   by a user at a specific block.\n', '\n', '   - Element Group\n', '\n', '*/\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'contract TokenHolder {\n', '    address public tokenAddress;\n', '    uint public holdAmount;\n', '    ERC20 public Token;\n', '    mapping (address => uint256) public heldTokens;\n', '    mapping (address => uint) public heldTimeline;\n', '    event Deposit(address from, uint256 amount);\n', '    event Withdraw(address from, uint256 amount);\n', '\n', '    function TokenHolder(address token) public {\n', '        tokenAddress = token;\n', '        Token = ERC20(token);\n', '        holdAmount = 1;\n', '    }\n', '\n', '    function() payable {\n', '        revert();\n', '    }\n', '\n', '    // get the approved amount of tokens to deposit\n', '    function approvedAmount(address _from) public constant returns (uint256) {\n', '        return Token.allowance(_from, this);\n', '    }\n', '\n', '    // get the token balance for an individual address\n', '    function userBalance(address _owner) public constant returns (uint256) {\n', '        return heldTokens[_owner];\n', '    }\n', '\n', '    // get the token balance for an individual address\n', '    function userHeldTill(address _owner) public constant returns (uint) {\n', '        return heldTimeline[_owner];\n', '    }\n', '\n', '    // get the token balance inside this contract\n', '    function totalBalance() public constant returns (uint) {\n', '        return Token.balanceOf(this);\n', '    }\n', '\n', '    // deposit tokens to hold in the system\n', '    function depositTokens(uint256 amount) external {\n', '        require(Token.allowance(msg.sender, this) >= amount);\n', '        Token.transferFrom(msg.sender, this, amount);\n', '        heldTokens[msg.sender] += amount;\n', '        heldTimeline[msg.sender] = block.number + holdAmount;\n', '        Deposit(msg.sender, amount);\n', '    }\n', '\n', '    // external user can release the tokens on their own when the time comes\n', '    function withdrawTokens(uint256 amount) external {\n', '        uint256 held = heldTokens[msg.sender];\n', '        uint heldBlock = heldTimeline[msg.sender];\n', '        require(held >= 0 && held >= amount);\n', '        require(block.number >= heldBlock);\n', '        heldTokens[msg.sender] -= amount;\n', '        heldTimeline[msg.sender] = 0;\n', '        Withdraw(msg.sender, amount);\n', '        Token.transfer(msg.sender, amount);\n', '    }\n', '    \n', '}']
