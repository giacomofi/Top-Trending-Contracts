['pragma solidity ^0.4.24;\n', '\n', 'contract Lottery {\n', '    using SafeMath for uint;\n', '    using SafeMath for uint8;\n', '\n', '    uint private lotteryBalance;\n', '    uint private ticketsCount;\n', '\n', '    address[] internal ticketsAddresses;\n', '    mapping(address => uint) internal tickets;\n', '\n', '    uint constant private DEPOSIT_MULTIPLY = 100 finney; // 0.1 eth\n', '    uint8 constant internal ITERATION_LIMIT = 150;\n', '    uint8 private generatorOffset = 0;\n', '    uint private randomNumber = 0;\n', '\n', '    Utils.winner private lastWinner;\n', '\n', '    function addLotteryParticipant(address addr, uint depositAmount) internal {\n', '        if (depositAmount >= DEPOSIT_MULTIPLY) {\n', '            uint investorTicketCount = depositAmount.div(DEPOSIT_MULTIPLY);\n', '            ticketsCount = ticketsCount.add(investorTicketCount);\n', '            ticketsAddresses.push(addr);\n', '            tickets[addr] = tickets[addr].add(investorTicketCount);\n', '        }\n', '    }\n', '\n', '    function getLotteryBalance() public view returns(uint) {\n', '\n', '        return lotteryBalance;\n', '    }\n', '\n', '    function increaseLotteryBalance(uint value) internal {\n', '\n', '        lotteryBalance = lotteryBalance.add(value);\n', '    }\n', '\n', '    function resetLotteryBalance() internal {\n', '\n', '        ticketsCount = 0;\n', '        lotteryBalance = 0;\n', '    }\n', '\n', '    function setLastWinner(address addr, uint balance, uint prize, uint date) internal {\n', '        lastWinner.addr = addr;\n', '        lastWinner.balance = balance;\n', '        lastWinner.prize = prize;\n', '        lastWinner.date = date;\n', '    }\n', '\n', '    function getLastWinner() public view returns(address, uint, uint, uint) {\n', '        return (lastWinner.addr, lastWinner.balance, lastWinner.prize, lastWinner.date);\n', '    }\n', '\n', '    function getRandomLotteryTicket() internal returns(address) {\n', '        address addr;\n', '        if (randomNumber != 0)\n', '            randomNumber = random(ticketsCount);\n', '        uint edge = 0;\n', '        for (uint8 key = generatorOffset; key < ticketsAddresses.length && key < ITERATION_LIMIT; key++) {\n', '            addr = ticketsAddresses[key];\n', '            edge = edge.add(tickets[addr]);\n', '            if (randomNumber <= edge) {\n', '                randomNumber = 0;\n', '                generatorOffset = 0;\n', '                return addr;\n', '            }\n', '        }\n', '        generatorOffset = key;\n', '        return 0;\n', '    }\n', '\n', '    function random(uint max) private view returns (uint) {\n', '        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % max + 1;\n', '    }\n', '}\n', '\n', 'contract Stellar {\n', '    using SafeMath for uint;\n', '\n', '    uint private stellarInvestorBalance;\n', '\n', '    struct stellar {\n', '        address addr;\n', '        uint balance;\n', '    }\n', '\n', '    stellar private stellarInvestor;\n', '\n', '    Utils.winner private lastStellar;\n', '\n', '    event NewStellar(address addr, uint balance);\n', '\n', '    function checkForNewStellar(address addr, uint balance) internal {\n', '        if (balance > stellarInvestor.balance) {\n', '            stellarInvestor = stellar(addr, balance);\n', '            emit NewStellar(addr, balance);\n', '        }\n', '    }\n', '\n', '    function getStellarInvestor() public view returns(address, uint) {\n', '\n', '        return (stellarInvestor.addr, stellarInvestor.balance);\n', '    }\n', '\n', '    function getStellarBalance() public view returns(uint) {\n', '\n', '        return stellarInvestorBalance;\n', '    }\n', '\n', '    function increaseStellarBalance(uint value) internal {\n', '\n', '        stellarInvestorBalance = stellarInvestorBalance.add(value);\n', '    }\n', '\n', '    function resetStellarBalance() internal {\n', '        stellarInvestorBalance = 0;\n', '    }\n', '\n', '    function resetStellarInvestor() internal {\n', '        stellarInvestor.addr = 0;\n', '        stellarInvestor.balance = 0;\n', '    }\n', '\n', '    function setLastStellar(address addr, uint balance, uint prize, uint date) internal {\n', '        lastStellar.addr = addr;\n', '        lastStellar.balance = balance;\n', '        lastStellar.prize = prize;\n', '        lastStellar.date = date;\n', '    }\n', '\n', '    function getLastStellar() public view returns(address, uint, uint, uint) {\n', '        return (lastStellar.addr, lastStellar.balance, lastStellar.prize, lastStellar.date);\n', '    }\n', '}\n', '\n', 'contract Star is Lottery, Stellar {\n', '\n', '    using Math for Math.percent;\n', '    using SafeMath for uint;\n', '\n', '    uint constant private MIN_DEPOSIT = 10 finney; // 0.01 eth\n', '    uint constant private PAYOUT_INTERVAL = 23 hours;\n', '    uint constant private WITHDRAW_INTERVAL = 12 hours;\n', '    uint constant private PAYOUT_TRANSACTION_LIMIT = 100;\n', '\n', '    Math.percent private DAILY_PERCENT =  Math.percent(35, 10); // Math.percent(35, 10) = 35 / 10 = 3.5%\n', '    Math.percent private FEE_PERCENT = Math.percent(18, 1);\n', '    Math.percent private LOTTERY_PERCENT = Math.percent(1, 1);\n', '    Math.percent private STELLAR_INVESTOR_PERCENT = Math.percent(1, 1);\n', '\n', '    address internal owner;\n', '\n', '    uint8 cycle;\n', '\n', '    address[] internal addresses;\n', '\n', '    uint internal investorCount;\n', '    uint internal lastPayoutDate;\n', '    uint internal lastDepositDate;\n', '\n', '    bool public isCycleFinish = false;\n', '\n', '    struct investor {\n', '        uint id;\n', '        uint balance;\n', '        uint depositCount;\n', '        uint lastDepositDate;\n', '    }\n', '\n', '    mapping(address => investor) internal investors;\n', '\n', '    event Invest(address addr, uint amount);\n', '    event InvestorPayout(address addr, uint amount, uint date);\n', '    event Payout(uint amount, uint transactionCount, uint date);\n', '    event Withdraw(address addr, uint amount);\n', '    event NextCycle(uint8 cycle, uint now, uint);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        addresses.length = 1;\n', '    }\n', '\n', '    function() payable public {\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        if (msg.value == 0) {\n', '            withdraw(msg.sender);\n', '            return;\n', '        }\n', '\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function restartCycle() public onlyOwner returns(bool) {\n', '        if (isCycleFinish == true) {\n', '            newCycle();\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function payout(uint startPosition) public onlyOwner {\n', '\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        uint transactionCount;\n', '        uint investorsPayout;\n', '        uint dividendsAmount;\n', '\n', '        if (startPosition == 0)\n', '            startPosition = 1;\n', '\n', '        for (uint key = startPosition; key <= investorCount && transactionCount < PAYOUT_TRANSACTION_LIMIT; key++) {\n', '            address addr = addresses[key];\n', '            if (investors[addr].lastDepositDate + PAYOUT_INTERVAL > now) {\n', '                continue;\n', '            }\n', '\n', '            dividendsAmount = getInvestorDividends(addr);\n', '\n', '            if (address(this).balance < dividendsAmount) {\n', '                isCycleFinish = true;\n', '                return;\n', '            }\n', '\n', '            addr.transfer(dividendsAmount);\n', '            emit InvestorPayout(addr, dividendsAmount, now);\n', '            investors[addr].lastDepositDate = now;\n', '\n', '            investorsPayout = investorsPayout.add(dividendsAmount);\n', '\n', '            transactionCount++;\n', '        }\n', '\n', '        lastPayoutDate = now;\n', '        emit Payout(investorsPayout, transactionCount, lastPayoutDate);\n', '    }\n', '\n', '    function deposit(address addr, uint amount) internal {\n', '        require(amount >= MIN_DEPOSIT, "Too small amount, minimum 0.01 eth");\n', '\n', '        investor storage user = investors[addr];\n', '\n', '        if (user.id == 0) {\n', '            user.id = addresses.length;\n', '            addresses.push(addr);\n', '            investorCount ++;\n', '        }\n', '\n', '        uint depositFee = FEE_PERCENT.getPercentFrom(amount);\n', '\n', '        increaseLotteryBalance(LOTTERY_PERCENT.getPercentFrom(amount));\n', '        increaseStellarBalance(STELLAR_INVESTOR_PERCENT.getPercentFrom(amount));\n', '\n', '        addLotteryParticipant(addr, amount);\n', '\n', '        user.balance = user.balance.add(amount);\n', '        user.depositCount ++;\n', '        user.lastDepositDate = now;\n', '        lastDepositDate = now;\n', '\n', '        checkForNewStellar(addr, user.balance);\n', '\n', '        emit Invest(msg.sender, msg.value);\n', '\n', '        owner.transfer(depositFee);\n', '    }\n', '\n', '    function withdraw(address addr) internal {\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        investor storage user = investors[addr];\n', '        require(user.id > 0, "Account not found");\n', '\n', '        require(now.sub(user.lastDepositDate).div(WITHDRAW_INTERVAL) > 0, "The latest payment was earlier than 12 hours");\n', '\n', '        uint dividendsAmount = getInvestorDividends(addr);\n', '\n', '        if (address(this).balance < dividendsAmount) {\n', '            isCycleFinish = true;\n', '            return;\n', '        }\n', '\n', '        addr.transfer(dividendsAmount);\n', '        user.lastDepositDate = now;\n', '\n', '        emit Withdraw(addr, dividendsAmount);\n', '    }\n', '\n', '    function runLottery() public onlyOwner returns(bool) {\n', '        return processLotteryReward();\n', '    }\n', '\n', '    function processLotteryReward() private returns(bool) {\n', '        if (getLotteryBalance() > 0) {\n', '            address winnerAddress = getRandomLotteryTicket();\n', '            if (winnerAddress == 0)\n', '                return false;\n', '            winnerAddress.transfer(getLotteryBalance());\n', '            setLastWinner(winnerAddress, investors[winnerAddress].balance, getLotteryBalance(), now);\n', '            resetLotteryBalance();\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function giveStellarReward() public onlyOwner {\n', '        processStellarReward();\n', '    }\n', '\n', '    function processStellarReward() private {\n', '        uint balance = getStellarBalance();\n', '        if (balance > 0) {\n', '            (address addr, uint investorBalance) = getStellarInvestor();\n', '            addr.transfer(balance);\n', '            setLastStellar(addr, investors[addr].balance, getStellarBalance(), now);\n', '            resetStellarBalance();\n', '        }\n', '    }\n', '\n', '    function getInvestorCount() public view returns (uint) {\n', '\n', '        return investorCount;\n', '    }\n', '\n', '    function getBalance() public view returns (uint) {\n', '\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getLastPayoutDate() public view returns (uint) {\n', '\n', '        return lastPayoutDate;\n', '    }\n', '\n', '    function getLastDepositDate() public view returns (uint) {\n', '\n', '        return lastDepositDate;\n', '    }\n', '\n', '    function getInvestorDividends(address addr) public view returns(uint) {\n', '        uint amountPerDay = DAILY_PERCENT.getPercentFrom(investors[addr].balance);\n', '        uint timeLapse = now.sub(investors[addr].lastDepositDate);\n', '\n', '        return amountPerDay.mul(timeLapse).div(1 days);\n', '    }\n', '\n', '    function getInvestorBalance(address addr) public view returns(uint) {\n', '\n', '        return investors[addr].balance;\n', '    }\n', '\n', '    function getInvestorInfo(address addr) public onlyOwner view returns(uint, uint, uint, uint) {\n', '\n', '        return (\n', '            investors[addr].id,\n', '            investors[addr].balance,\n', '            investors[addr].depositCount,\n', '            investors[addr].lastDepositDate\n', '        );\n', '    }\n', '\n', '    function newCycle() private {\n', '        address addr;\n', '        uint8 iteration;\n', '        uint i;\n', '\n', '        for (i = addresses.length - 1; i > 0; i--) {\n', '            addr = addresses[i];\n', '            addresses.length -= 1;\n', '            delete investors[addr];\n', '            iteration++;\n', '            if (iteration >= ITERATION_LIMIT) {\n', '                return;\n', '            }\n', '        }\n', '\n', '        for (i = ticketsAddresses.length - 1; i > 0; i--) {\n', '            addr = ticketsAddresses[i];\n', '            ticketsAddresses.length -= 1;\n', '            delete tickets[addr];\n', '            iteration++;\n', '            if (iteration >= ITERATION_LIMIT) {\n', '                return;\n', '            }\n', '        }\n', '\n', '        emit NextCycle(cycle, now, getBalance());\n', '\n', '        cycle++;\n', '        investorCount = 0;\n', '        lastPayoutDate = now;\n', '        lastDepositDate = now;\n', '        isCycleFinish = false;\n', '\n', '        resetLotteryBalance();\n', '        resetStellarBalance();\n', '        resetStellarInvestor();\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '        // benefit is lost if &#39;b&#39; is also tested.\n', '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Math {\n', '\n', '    struct percent {\n', '        uint percent;\n', '        uint base;\n', '    }\n', '\n', '    function getPercentFrom(percent storage p, uint value) internal view returns (uint) {\n', '        return value * p.percent / p.base / 100;\n', '    }\n', '\n', '}\n', '\n', 'library Utils {\n', '\n', '    struct winner {\n', '        address addr;\n', '        uint balance;\n', '        uint prize;\n', '        uint date;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Lottery {\n', '    using SafeMath for uint;\n', '    using SafeMath for uint8;\n', '\n', '    uint private lotteryBalance;\n', '    uint private ticketsCount;\n', '\n', '    address[] internal ticketsAddresses;\n', '    mapping(address => uint) internal tickets;\n', '\n', '    uint constant private DEPOSIT_MULTIPLY = 100 finney; // 0.1 eth\n', '    uint8 constant internal ITERATION_LIMIT = 150;\n', '    uint8 private generatorOffset = 0;\n', '    uint private randomNumber = 0;\n', '\n', '    Utils.winner private lastWinner;\n', '\n', '    function addLotteryParticipant(address addr, uint depositAmount) internal {\n', '        if (depositAmount >= DEPOSIT_MULTIPLY) {\n', '            uint investorTicketCount = depositAmount.div(DEPOSIT_MULTIPLY);\n', '            ticketsCount = ticketsCount.add(investorTicketCount);\n', '            ticketsAddresses.push(addr);\n', '            tickets[addr] = tickets[addr].add(investorTicketCount);\n', '        }\n', '    }\n', '\n', '    function getLotteryBalance() public view returns(uint) {\n', '\n', '        return lotteryBalance;\n', '    }\n', '\n', '    function increaseLotteryBalance(uint value) internal {\n', '\n', '        lotteryBalance = lotteryBalance.add(value);\n', '    }\n', '\n', '    function resetLotteryBalance() internal {\n', '\n', '        ticketsCount = 0;\n', '        lotteryBalance = 0;\n', '    }\n', '\n', '    function setLastWinner(address addr, uint balance, uint prize, uint date) internal {\n', '        lastWinner.addr = addr;\n', '        lastWinner.balance = balance;\n', '        lastWinner.prize = prize;\n', '        lastWinner.date = date;\n', '    }\n', '\n', '    function getLastWinner() public view returns(address, uint, uint, uint) {\n', '        return (lastWinner.addr, lastWinner.balance, lastWinner.prize, lastWinner.date);\n', '    }\n', '\n', '    function getRandomLotteryTicket() internal returns(address) {\n', '        address addr;\n', '        if (randomNumber != 0)\n', '            randomNumber = random(ticketsCount);\n', '        uint edge = 0;\n', '        for (uint8 key = generatorOffset; key < ticketsAddresses.length && key < ITERATION_LIMIT; key++) {\n', '            addr = ticketsAddresses[key];\n', '            edge = edge.add(tickets[addr]);\n', '            if (randomNumber <= edge) {\n', '                randomNumber = 0;\n', '                generatorOffset = 0;\n', '                return addr;\n', '            }\n', '        }\n', '        generatorOffset = key;\n', '        return 0;\n', '    }\n', '\n', '    function random(uint max) private view returns (uint) {\n', '        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % max + 1;\n', '    }\n', '}\n', '\n', 'contract Stellar {\n', '    using SafeMath for uint;\n', '\n', '    uint private stellarInvestorBalance;\n', '\n', '    struct stellar {\n', '        address addr;\n', '        uint balance;\n', '    }\n', '\n', '    stellar private stellarInvestor;\n', '\n', '    Utils.winner private lastStellar;\n', '\n', '    event NewStellar(address addr, uint balance);\n', '\n', '    function checkForNewStellar(address addr, uint balance) internal {\n', '        if (balance > stellarInvestor.balance) {\n', '            stellarInvestor = stellar(addr, balance);\n', '            emit NewStellar(addr, balance);\n', '        }\n', '    }\n', '\n', '    function getStellarInvestor() public view returns(address, uint) {\n', '\n', '        return (stellarInvestor.addr, stellarInvestor.balance);\n', '    }\n', '\n', '    function getStellarBalance() public view returns(uint) {\n', '\n', '        return stellarInvestorBalance;\n', '    }\n', '\n', '    function increaseStellarBalance(uint value) internal {\n', '\n', '        stellarInvestorBalance = stellarInvestorBalance.add(value);\n', '    }\n', '\n', '    function resetStellarBalance() internal {\n', '        stellarInvestorBalance = 0;\n', '    }\n', '\n', '    function resetStellarInvestor() internal {\n', '        stellarInvestor.addr = 0;\n', '        stellarInvestor.balance = 0;\n', '    }\n', '\n', '    function setLastStellar(address addr, uint balance, uint prize, uint date) internal {\n', '        lastStellar.addr = addr;\n', '        lastStellar.balance = balance;\n', '        lastStellar.prize = prize;\n', '        lastStellar.date = date;\n', '    }\n', '\n', '    function getLastStellar() public view returns(address, uint, uint, uint) {\n', '        return (lastStellar.addr, lastStellar.balance, lastStellar.prize, lastStellar.date);\n', '    }\n', '}\n', '\n', 'contract Star is Lottery, Stellar {\n', '\n', '    using Math for Math.percent;\n', '    using SafeMath for uint;\n', '\n', '    uint constant private MIN_DEPOSIT = 10 finney; // 0.01 eth\n', '    uint constant private PAYOUT_INTERVAL = 23 hours;\n', '    uint constant private WITHDRAW_INTERVAL = 12 hours;\n', '    uint constant private PAYOUT_TRANSACTION_LIMIT = 100;\n', '\n', '    Math.percent private DAILY_PERCENT =  Math.percent(35, 10); // Math.percent(35, 10) = 35 / 10 = 3.5%\n', '    Math.percent private FEE_PERCENT = Math.percent(18, 1);\n', '    Math.percent private LOTTERY_PERCENT = Math.percent(1, 1);\n', '    Math.percent private STELLAR_INVESTOR_PERCENT = Math.percent(1, 1);\n', '\n', '    address internal owner;\n', '\n', '    uint8 cycle;\n', '\n', '    address[] internal addresses;\n', '\n', '    uint internal investorCount;\n', '    uint internal lastPayoutDate;\n', '    uint internal lastDepositDate;\n', '\n', '    bool public isCycleFinish = false;\n', '\n', '    struct investor {\n', '        uint id;\n', '        uint balance;\n', '        uint depositCount;\n', '        uint lastDepositDate;\n', '    }\n', '\n', '    mapping(address => investor) internal investors;\n', '\n', '    event Invest(address addr, uint amount);\n', '    event InvestorPayout(address addr, uint amount, uint date);\n', '    event Payout(uint amount, uint transactionCount, uint date);\n', '    event Withdraw(address addr, uint amount);\n', '    event NextCycle(uint8 cycle, uint now, uint);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        addresses.length = 1;\n', '    }\n', '\n', '    function() payable public {\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        if (msg.value == 0) {\n', '            withdraw(msg.sender);\n', '            return;\n', '        }\n', '\n', '        deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    function restartCycle() public onlyOwner returns(bool) {\n', '        if (isCycleFinish == true) {\n', '            newCycle();\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function payout(uint startPosition) public onlyOwner {\n', '\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        uint transactionCount;\n', '        uint investorsPayout;\n', '        uint dividendsAmount;\n', '\n', '        if (startPosition == 0)\n', '            startPosition = 1;\n', '\n', '        for (uint key = startPosition; key <= investorCount && transactionCount < PAYOUT_TRANSACTION_LIMIT; key++) {\n', '            address addr = addresses[key];\n', '            if (investors[addr].lastDepositDate + PAYOUT_INTERVAL > now) {\n', '                continue;\n', '            }\n', '\n', '            dividendsAmount = getInvestorDividends(addr);\n', '\n', '            if (address(this).balance < dividendsAmount) {\n', '                isCycleFinish = true;\n', '                return;\n', '            }\n', '\n', '            addr.transfer(dividendsAmount);\n', '            emit InvestorPayout(addr, dividendsAmount, now);\n', '            investors[addr].lastDepositDate = now;\n', '\n', '            investorsPayout = investorsPayout.add(dividendsAmount);\n', '\n', '            transactionCount++;\n', '        }\n', '\n', '        lastPayoutDate = now;\n', '        emit Payout(investorsPayout, transactionCount, lastPayoutDate);\n', '    }\n', '\n', '    function deposit(address addr, uint amount) internal {\n', '        require(amount >= MIN_DEPOSIT, "Too small amount, minimum 0.01 eth");\n', '\n', '        investor storage user = investors[addr];\n', '\n', '        if (user.id == 0) {\n', '            user.id = addresses.length;\n', '            addresses.push(addr);\n', '            investorCount ++;\n', '        }\n', '\n', '        uint depositFee = FEE_PERCENT.getPercentFrom(amount);\n', '\n', '        increaseLotteryBalance(LOTTERY_PERCENT.getPercentFrom(amount));\n', '        increaseStellarBalance(STELLAR_INVESTOR_PERCENT.getPercentFrom(amount));\n', '\n', '        addLotteryParticipant(addr, amount);\n', '\n', '        user.balance = user.balance.add(amount);\n', '        user.depositCount ++;\n', '        user.lastDepositDate = now;\n', '        lastDepositDate = now;\n', '\n', '        checkForNewStellar(addr, user.balance);\n', '\n', '        emit Invest(msg.sender, msg.value);\n', '\n', '        owner.transfer(depositFee);\n', '    }\n', '\n', '    function withdraw(address addr) internal {\n', '        require(isCycleFinish == false, "Cycle completed. The new cycle will start within 24 hours.");\n', '\n', '        investor storage user = investors[addr];\n', '        require(user.id > 0, "Account not found");\n', '\n', '        require(now.sub(user.lastDepositDate).div(WITHDRAW_INTERVAL) > 0, "The latest payment was earlier than 12 hours");\n', '\n', '        uint dividendsAmount = getInvestorDividends(addr);\n', '\n', '        if (address(this).balance < dividendsAmount) {\n', '            isCycleFinish = true;\n', '            return;\n', '        }\n', '\n', '        addr.transfer(dividendsAmount);\n', '        user.lastDepositDate = now;\n', '\n', '        emit Withdraw(addr, dividendsAmount);\n', '    }\n', '\n', '    function runLottery() public onlyOwner returns(bool) {\n', '        return processLotteryReward();\n', '    }\n', '\n', '    function processLotteryReward() private returns(bool) {\n', '        if (getLotteryBalance() > 0) {\n', '            address winnerAddress = getRandomLotteryTicket();\n', '            if (winnerAddress == 0)\n', '                return false;\n', '            winnerAddress.transfer(getLotteryBalance());\n', '            setLastWinner(winnerAddress, investors[winnerAddress].balance, getLotteryBalance(), now);\n', '            resetLotteryBalance();\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function giveStellarReward() public onlyOwner {\n', '        processStellarReward();\n', '    }\n', '\n', '    function processStellarReward() private {\n', '        uint balance = getStellarBalance();\n', '        if (balance > 0) {\n', '            (address addr, uint investorBalance) = getStellarInvestor();\n', '            addr.transfer(balance);\n', '            setLastStellar(addr, investors[addr].balance, getStellarBalance(), now);\n', '            resetStellarBalance();\n', '        }\n', '    }\n', '\n', '    function getInvestorCount() public view returns (uint) {\n', '\n', '        return investorCount;\n', '    }\n', '\n', '    function getBalance() public view returns (uint) {\n', '\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getLastPayoutDate() public view returns (uint) {\n', '\n', '        return lastPayoutDate;\n', '    }\n', '\n', '    function getLastDepositDate() public view returns (uint) {\n', '\n', '        return lastDepositDate;\n', '    }\n', '\n', '    function getInvestorDividends(address addr) public view returns(uint) {\n', '        uint amountPerDay = DAILY_PERCENT.getPercentFrom(investors[addr].balance);\n', '        uint timeLapse = now.sub(investors[addr].lastDepositDate);\n', '\n', '        return amountPerDay.mul(timeLapse).div(1 days);\n', '    }\n', '\n', '    function getInvestorBalance(address addr) public view returns(uint) {\n', '\n', '        return investors[addr].balance;\n', '    }\n', '\n', '    function getInvestorInfo(address addr) public onlyOwner view returns(uint, uint, uint, uint) {\n', '\n', '        return (\n', '            investors[addr].id,\n', '            investors[addr].balance,\n', '            investors[addr].depositCount,\n', '            investors[addr].lastDepositDate\n', '        );\n', '    }\n', '\n', '    function newCycle() private {\n', '        address addr;\n', '        uint8 iteration;\n', '        uint i;\n', '\n', '        for (i = addresses.length - 1; i > 0; i--) {\n', '            addr = addresses[i];\n', '            addresses.length -= 1;\n', '            delete investors[addr];\n', '            iteration++;\n', '            if (iteration >= ITERATION_LIMIT) {\n', '                return;\n', '            }\n', '        }\n', '\n', '        for (i = ticketsAddresses.length - 1; i > 0; i--) {\n', '            addr = ticketsAddresses[i];\n', '            ticketsAddresses.length -= 1;\n', '            delete tickets[addr];\n', '            iteration++;\n', '            if (iteration >= ITERATION_LIMIT) {\n', '                return;\n', '            }\n', '        }\n', '\n', '        emit NextCycle(cycle, now, getBalance());\n', '\n', '        cycle++;\n', '        investorCount = 0;\n', '        lastPayoutDate = now;\n', '        lastDepositDate = now;\n', '        isCycleFinish = false;\n', '\n', '        resetLotteryBalance();\n', '        resetStellarBalance();\n', '        resetStellarInvestor();\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Math {\n', '\n', '    struct percent {\n', '        uint percent;\n', '        uint base;\n', '    }\n', '\n', '    function getPercentFrom(percent storage p, uint value) internal view returns (uint) {\n', '        return value * p.percent / p.base / 100;\n', '    }\n', '\n', '}\n', '\n', 'library Utils {\n', '\n', '    struct winner {\n', '        address addr;\n', '        uint balance;\n', '        uint prize;\n', '        uint date;\n', '    }\n', '\n', '}']
