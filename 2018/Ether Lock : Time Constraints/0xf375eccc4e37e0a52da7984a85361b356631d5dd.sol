['pragma solidity ^0.4.18;\n', '\n', 'contract Jackpot {\n', '\n', '    uint64 public nextJackpotTime;\n', '    bool public jackpotPaused;\n', '    address public owner;\n', '    uint public jackpotPersent = 100;\n', '    uint public  winnerLimit = 1;\n', '    uint public JackpotPeriods = 1;\n', '    address public diceRollAddress;\n', '\n', '    mapping (uint=>address) public winnerHistory;\n', '    address[] public tempPlayer;\n', '\n', '    event SendJackpotSuccesss(address indexed winner, uint amount, uint JackpotPeriods);\n', '    event OwnerTransfer(address SentToAddress, uint AmountTransferred);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDiceRoll {\n', '        require(msg.sender == diceRollAddress);\n', '        _;\n', '    }\n', '\n', '    modifier jackpotAreActive {\n', '        require(!jackpotPaused);\n', '        _;\n', '    }\n', '\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '\n', '    function() external payable {\n', '\n', '    }\n', '\n', '    function getWinnerHistory(uint periods) external view returns(address){\n', '        return winnerHistory[periods];\n', '    }\n', '\n', '    function addPlayer(address add) public onlyDiceRoll jackpotAreActive{\n', '        tempPlayer.push(add);\n', '        \n', '    }\n', '\n', '    function createWinner() public onlyOwner jackpotAreActive {\n', '        require(tempPlayer.length > 0);\n', '        uint random = rand() % tempPlayer.length;\n', '        address winner = tempPlayer[random];\n', '        winnerHistory[JackpotPeriods] = winner;\n', '        uint64 tmNow = uint64(block.timestamp);\n', '        nextJackpotTime = tmNow + 72000;\n', '        tempPlayer.length = 0;\n', '        sendJackpot(winner, address(this).balance * jackpotPersent / 1000);\n', '        JackpotPeriods += 1;\n', '    }\n', '\n', '\n', '    function sendJackpot(address winner, uint256 amount) internal {\n', '        require(address(this).balance > amount);\n', '        emit SendJackpotSuccesss(winner, amount,JackpotPeriods);\n', '        winner.transfer(amount);\n', '        \n', '    }\n', '\n', '    function seTJackpotPersent(uint newPersent) external onlyOwner{\n', '        require(newPersent > 0 && newPersent < 1000);\n', '        jackpotPersent = newPersent;\n', '    }\n', '\n', '    function rand() internal view returns (uint256) {\n', '        return uint256(keccak256(msg.sender, blockhash(block.number - 1), block.coinbase, block.difficulty));\n', '    }\n', '\n', '\n', '    function ownerPauseJackpot(bool newStatus) public onlyOwner{\n', '        jackpotPaused = newStatus;\n', '    }\n', '\n', '    function ownerSetdiceRollAddress(address add) public onlyOwner {\n', '        diceRollAddress = add;\n', '    }\n', '\n', '    function ownerTransferEther(address sendTo, uint amount) public onlyOwner{    \n', '        sendTo.transfer(amount);\n', '        emit OwnerTransfer(sendTo, amount);\n', '    }\n', '\n', '}']