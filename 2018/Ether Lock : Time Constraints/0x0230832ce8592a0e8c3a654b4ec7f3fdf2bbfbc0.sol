['pragma solidity 0.4.25;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract\tInitAtomicSwap  {\n', '    \n', '    //Initiations store information about users first init\n', '    struct Initiations {\n', '        address addressFrom;\n', '        address addressTo;\n', '        bool isShow;\n', '        bool isInit;\n', '        uint blockTimestamp;\n', '        uint amount;\n', '        bytes32 hashSecret;\n', '    }\n', '    \n', '    //ConfirmedInitiations - struct for storing information \n', '    //about order that was already paid \n', '    struct ConfirmedInitiations {\n', '        address addressFrom;\n', '        address addressTo;\n', '        bool isShow;\n', '        bool isRedeem;\n', '        bool isInit;\n', '        uint blockTimestamp;\n', '        uint amount;\n', '        bytes32 hashSecret;\n', '    }\n', '\n', '    mapping(address=>Initiations) public inits;\n', '    \n', '    mapping(address=>mapping(bytes32=>ConfirmedInitiations)) public confirmedInits;\n', '    \n', '    modifier isInitCreated(address _addressOfInitiator) {\n', '\t    require(inits[_addressOfInitiator].isInit == false);\n', '\t    _;\n', '\t}\n', '\t\n', '\tmodifier isValidHashsecret(string _password, address _addressOfInitiator) {\n', '\t    require(inits[_addressOfInitiator].hashSecret == keccak256(abi.encodePacked(\n', '\t        inits[_addressOfInitiator].addressFrom,\n', '\t        inits[_addressOfInitiator].addressTo,\n', '\t        inits[_addressOfInitiator].amount,\n', '\t        inits[_addressOfInitiator].blockTimestamp,\n', '\t        _password)));\n', '\t    _;\n', '\t}\n', '\t\n', '\tmodifier isTxValid(address _addressOfInitiator, uint _blockTimestamp) {\n', '\t    require(inits[_addressOfInitiator].blockTimestamp >= _blockTimestamp);\n', '\t    _;\n', '\t}\n', '    \n', '    //addInit - this function will write data of order to mapping inits in Initiations struct with address of the sender key \n', '    function addInit(address _addressFrom, address _addressTo, uint _amount, string _password) public \n', '    returns(bytes32) {\n', '        \n', '        if(inits[_addressFrom].isInit == true) {\n', '            return 0;\n', '        }\n', '        inits[_addressFrom].addressFrom = _addressFrom;\n', '        inits[_addressFrom].addressTo = _addressTo;\n', '        inits[_addressFrom].isShow = false;\n', '        inits[_addressFrom].isInit = true;\n', '        inits[_addressFrom].blockTimestamp = now;\n', '        inits[_addressFrom].amount = _amount;\n', '        \n', '        inits[_addressFrom].hashSecret = keccak256(abi.encodePacked(\n', '            _addressFrom, \n', '            _addressTo, \n', '            _amount, \n', '            inits[_addressFrom].blockTimestamp, \n', '            _password));\n', '        \n', '        return inits[_addressFrom].hashSecret;\n', '\t}\n', '\t\n', '\t//getInit - this function returns data about order of the special address\n', '\tfunction getInit(address _addressOfInitiator) public view returns(address, address, uint, uint, bytes32) {\n', '\t    return (\n', '\t        inits[_addressOfInitiator].addressFrom, \n', '\t        inits[_addressOfInitiator].addressTo, \n', '\t        inits[_addressOfInitiator].amount,\n', '\t        inits[_addressOfInitiator].blockTimestamp,\n', '\t        inits[_addressOfInitiator].hashSecret\n', '\t        );\n', '\t}\n', '\t\n', '\t//confirmInit function that write information about already sended tx\n', '\tfunction confirmInit(address _addressOfInitiator, string _password, bytes32 _txHash, uint _blockTimestamp) public \n', '\tisValidHashsecret(_password, _addressOfInitiator) \n', '\tisTxValid(_addressOfInitiator, _blockTimestamp) \n', '\treturns(bool) {\n', '\t    confirmedInits[_addressOfInitiator][_txHash].addressFrom = inits[_addressOfInitiator].addressFrom;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].addressTo = inits[_addressOfInitiator].addressTo;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].isShow = inits[_addressOfInitiator].isShow;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].isInit = inits[_addressOfInitiator].isInit;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].amount = inits[_addressOfInitiator].amount;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].blockTimestamp = inits[_addressOfInitiator].blockTimestamp;\n', '\t    confirmedInits[_addressOfInitiator][_txHash].hashSecret = inits[_addressOfInitiator].hashSecret;\n', '\t    \n', '\t    delete(inits[_addressOfInitiator]);\n', '\t    \n', '\t    return true;\n', '\t}\n', '}']