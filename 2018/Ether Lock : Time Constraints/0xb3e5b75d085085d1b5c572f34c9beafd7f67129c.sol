['pragma solidity ^0.4.18;\n', '\n', '/*\n', '*   CrowdSale DapCar (DAPX)\n', '*   Created by Starlag Labs (www.starlag.com)\n', '*   Copyright &#169; DapCar.io 2018. All rights reserved.\n', '*   https://www.dapcar.io\n', '*/\n', '\n', 'library Math {\n', '    function mul(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Utils {\n', '    function Utils() public {}\n', '\n', '    modifier greaterThanZero(uint256 _value) \n', '    {\n', '        require(_value > 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint(uint256 _value) \n', '    {\n', '        require(_value >= 0);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) \n', '    {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) \n', '    {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier validAddressAndNotThis(address _address) \n', '    {\n', '        require(_address != address(0) && _address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notEmpty(string _data)\n', '    {\n', '        require(bytes(_data).length > 0);\n', '        _;\n', '    }\n', '\n', '    modifier stringLength(string _data, uint256 _length)\n', '    {\n', '        require(bytes(_data).length == _length);\n', '        _;\n', '    }\n', '    \n', '    modifier validBytes32(bytes32 _bytes)\n', '    {\n', '        require(_bytes != 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint64(uint64 _value) \n', '    {\n', '        require(_value >= 0 && _value < 4294967296);\n', '        _;\n', '    }\n', '\n', '    modifier validUint8(uint8 _value) \n', '    {\n', '        require(_value >= 0 && _value < 256);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceThis(uint256 _value)\n', '    {\n', '        require(_value <= address(this).balance);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Authorizable is Utils {\n', '    using Math for uint256;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    mapping (address => Level) authorizeds;\n', '    uint256 public authorizedCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   OWNER 1\n', '    *   ADMIN 2\n', '    *   DAPP 3\n', '    */  \n', '    enum Level {ZERO,OWNER,ADMIN,DAPP}\n', '\n', '    event OwnerTransferred(address indexed _prevOwner, address indexed _newOwner);\n', '    event Authorized(address indexed _address, Level _level);\n', '    event UnAuthorized(address indexed _address);\n', '\n', '    function Authorizable() \n', '    public \n', '    {\n', '        owner = msg.sender;\n', '        authorizeds[msg.sender] = Level.OWNER;\n', '        authorizedCount = authorizedCount.add(1);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(authorizeds[msg.sender] == Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrThis {\n', '        require(authorizeds[msg.sender] == Level.OWNER || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notOwner(address _address) {\n', '        require(authorizeds[_address] != Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier authLevel(Level _level) {\n', '        require((authorizeds[msg.sender] > Level.ZERO) && (authorizeds[msg.sender] <= _level));\n', '        _;\n', '    }\n', '\n', '    modifier authLevelOnly(Level _level) {\n', '        require(authorizeds[msg.sender] == _level);\n', '        _;\n', '    }\n', '    \n', '    modifier notSender(address _address) {\n', '        require(msg.sender != _address);\n', '        _;\n', '    }\n', '\n', '    modifier isSender(address _address) {\n', '        require(msg.sender == _address);\n', '        _;\n', '    }\n', '\n', '    modifier checkLevel(Level _level) {\n', '        require((_level > Level.ZERO) && (Level.DAPP >= _level));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) \n', '    public \n', '    {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) \n', '    onlyOwner \n', '    validAddress(_newOwner)\n', '    notThis(_newOwner)\n', '    internal \n', '    {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() \n', '    validAddress(newOwner)\n', '    isSender(newOwner)\n', '    public \n', '    {\n', '        OwnerTransferred(owner, newOwner);\n', '        if (authorizeds[owner] == Level.OWNER) {\n', '            delete authorizeds[owner];\n', '        }\n', '        if (authorizeds[newOwner] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        authorizeds[owner] = Level.OWNER;\n', '    }\n', '\n', '    function cancelOwnership() \n', '    onlyOwner\n', '    public \n', '    {\n', '        newOwner = address(0);\n', '    }\n', '\n', '    function authorized(address _address, Level _level) \n', '    public  \n', '    {\n', '        _authorized(_address, _level);\n', '    }\n', '\n', '    function _authorized(address _address, Level _level) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    checkLevel(_level)\n', '    internal  \n', '    {\n', '        if (authorizeds[_address] == Level.ZERO) {\n', '            authorizedCount = authorizedCount.add(1);\n', '        }\n', '        authorizeds[_address] = _level;\n', '        Authorized(_address, _level);\n', '    }\n', '\n', '    function unAuthorized(address _address) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    public  \n', '    {\n', '        if (authorizeds[_address] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        delete authorizeds[_address];\n', '        UnAuthorized(_address);\n', '    }\n', '\n', '    function isAuthorized(address _address) \n', '    validAddress(_address)\n', '    notThis(_address)\n', '    public \n', '    constant \n', '    returns (Level) \n', '    {\n', '        return authorizeds[_address];\n', '    }\n', '}\n', '\n', 'contract IERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ITokenRecipient { function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract ICouponToken {\n', '    function updCouponConsumed(string _code, bool _consumed) public returns (bool success);\n', '    function getCoupon(string _code) public view returns (uint256 bonus, \n', '        bool disposable, bool consumed, bool enabled);\n', '}\n', '\n', 'contract IDapCarToken {\n', '    function mint(address _address, uint256 _value) public returns (bool);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '}\n', '\n', 'contract IAirDropToken {\n', '    function burnAirDrop(address[] _address) public;\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '}\n', '\n', 'contract CrowdSaleDapCar is Authorizable {\n', '    string public version = "0.1";\n', '    string public publisher = "https://www.dapcar.io";\n', '    string public description = "This is an official CrowdSale DapCar (DAPX)";\n', '\n', '    address public walletWithdraw;\n', '    IDapCarToken public dapCarToken;\n', '    IAirDropToken public airDropToken;\n', '    ICouponToken public couponToken;\n', '\n', '    uint256 public weiRaised = 0;\n', '    uint256 public soldToken = 0;\n', '    uint256 public fundToken = 0;\n', '    uint256 public weiDonated = 0;\n', '    uint256 public minPurchaseLimit = 10 finney;\n', '\n', '    bool public crowdSaleEnabled = true;\n', '    bool public crowdSaleFinalized = false;\n', '    bool public crowdSaleInitialized = false;\n', '\n', '    bool public airDropTokenEnabled = true;\n', '    bool public airDropTokenDestroy = true;\n', '    bool public amountBonusEnabled = true;\n', '    bool public couponBonusEnabled = true;\n', '\n', '    mapping (uint8 => Rate) rates;\n', '\n', '    mapping (address => Investor) investors;\n', '    uint256 public investorCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   PRESALE 1\n', '    *   PREICO 2\n', '    *   ICO 3\n', '    *   PRERELEASE 4\n', '    */ \n', '    enum Period {ZERO,PRESALE,PREICO,ICO,PRERELEASE}\n', '\n', '    struct Rate {\n', '        Period period;\n', '        uint256 rate;\n', '        uint256 bonusAirDrop;\n', '        uint64 start;\n', '        uint64 stop;\n', '        uint64 updated;\n', '        bool enabled;\n', '        bool initialized;\n', '    }\n', '\n', '    struct Investor {\n', '        address wallet;\n', '        uint256 bonus;\n', '        uint64 updated;\n', '        bool preSaleEnabled;\n', '        bool enabled;\n', '        bool initialized;\n', '    }\n', '\n', '\n', '    event Donate(address indexed sender, uint256 value);\n', '    event WalletWithdrawChanged(address indexed sender, address indexed oldWallet, address indexed newWallet);\n', '    event Withdraw(address indexed sender, address indexed wallet, uint256 amount);\n', '    event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount);\n', '    event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData);\n', '    event RatePropsChanged(address indexed sender, uint8 period, string props, bool value);\n', '    event RateChanged(address indexed sender, uint8 period, uint256 oldBonus, uint256 newBonus);\n', '    event RateBonusChanged(address indexed sender, uint8 period, uint256 oldBonus, uint256 newBonus);\n', '    event RateTimeChanged(address indexed sender, uint8 period, uint64 oldStart, uint64 oldStop, \n', '        uint64 newStart, uint64 newStop);\n', '    event InvestorDeleted(address indexed sender, address indexed wallet);\n', '    event InvestorPropsChanged(address indexed sender, address indexed wallet, string props, bool value);\n', '    event InvestorBonusChanged(address indexed sender, address indexed wallet, uint256 oldBonus, uint256 newBonus);\n', '    event InvestorCreated(address indexed sender, address indexed wallet, uint256 bonus);\n', '    event Purchase(address indexed sender, uint256 amountWei, uint256 amountToken, uint256 totalBonus);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '    event MinPurchaseLimitChanged(address indexed sender, uint256 oldValu, uint256 newValue);\n', '    event Finalized(address indexed sender, uint64 time, uint256 weiRaised, uint256 soldToken, \n', '        uint256 fundToken, uint256 weiDonated);\n', '\n', '    modifier validPeriod(Period _period) \n', '    {\n', '        require(_period > Period.ZERO && _period <= Period.PRERELEASE);\n', '        _;\n', '    }\n', '\n', '    function CrowdSaleDapCar() public {\n', '        crowdSalePeriodInit();\n', '    }\n', '\n', '    /*\n', '    *   PRESALE: 1 DAPX = 1$\n', '    *   Monday, 5 March 2018, 00:00:00 GMT - Sunday, 25 March 2018, 23:59:59 GMT\n', '    *   PREICO: 1 DAPX = 2$\n', '    *   Monday, 9 April 2018, 00:00:00 GMT - Sunday, 29 April 2018, 23:59:59 GMT\n', '    *   ICO: 1 DAPX = 5$\n', '    *   Monday, 7 May 2018, 00:00:00 GMT - Sunday, 17 June 2018, 23:59:59 GMT\n', '    *   PRERELEASE: 1 DAPX = 10$\n', '    *   Monday, 18 June 2018, 00:00:00 GMT - Sunday, 1 July 2018, 23:59:59 GMT\n', '    *   RELEASE GAME: 1 DAPX = 1 DAPBOX >= 15$\n', '    */\n', '    \n', '    function crowdSalePeriodInit()\n', '    onlyOwnerOrThis\n', '    public\n', '    returns (bool success)\n', '    {\n', '        if (!crowdSaleInitialized) {\n', '            Rate memory ratePreSale = Rate({\n', '                period: Period.PRESALE,\n', '                rate: 740,\n', '                bonusAirDrop: 0,\n', '                start: 1520208000,\n', '                stop: 1522022399,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PRESALE)] = ratePreSale;\n', '\n', '            Rate memory ratePreIco = Rate({\n', '                period: Period.PREICO,\n', '                rate: 370,\n', '                bonusAirDrop: 10,\n', '                start: 1523232000,\n', '                stop: 1525046399,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PREICO)] = ratePreIco;\n', '\n', '            Rate memory rateIco = Rate({\n', '                period: Period.ICO,\n', '                rate: 148,\n', '                bonusAirDrop: 5,\n', '                start: 1525651200,\n', '                stop: 1529279999,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.ICO)] = rateIco;\n', '\n', '            Rate memory ratePreRelease = Rate({\n', '                period: Period.PRERELEASE,\n', '                rate: 74,\n', '                bonusAirDrop: 0,\n', '                start: 1529280000,\n', '                stop: 1530489599,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PRERELEASE)] = ratePreRelease;\n', '        \n', '            crowdSaleInitialized = true;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function nowPeriod()\n', '    public\n', '    constant\n', '    returns (Period)\n', '    {\n', '        uint64 now64 = uint64(now);\n', '        Period period = Period.ZERO;\n', '        for (uint8 i = 1; i <= uint8(Period.PRERELEASE); i++) {\n', '            Rate memory rate = rates[i];\n', '            if (!rate.initialized || !rate.enabled) { \n', '                continue; \n', '            }\n', '            if (rate.start == 0 || rate.stop == 0 || rate.rate == 0) { \n', '                continue; \n', '            }\n', '            \n', '            if (now64 >= rate.start && now64 < rate.stop) {\n', '                period = rate.period;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return period;\n', '    }\n', '\n', '    function updCrowdSaleEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "crowdSaleEnabled", crowdSaleEnabled, _value);\n', '        crowdSaleEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAirDropTokenEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "airDropTokenEnabled", airDropTokenEnabled, _value);\n', '        airDropTokenEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAirDropTokenDestroy(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "airDropTokenDestroy", airDropTokenDestroy, _value);\n', '        airDropTokenDestroy = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAmountBonusEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "amountBonusEnabled", amountBonusEnabled, _value);\n', '        amountBonusEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updCouponBonusEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "couponBonusEnabled", couponBonusEnabled, _value);\n', '        couponBonusEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updMinPurchaseLimit(uint256 _limit)\n', '    authLevel(Level.ADMIN)\n', '    validUint(_limit)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        MinPurchaseLimitChanged(msg.sender, minPurchaseLimit, _limit);\n', '        minPurchaseLimit = _limit;\n', '        return true;\n', '    }\n', '    \n', '    function getRate(Period _period)\n', '    validPeriod(_period)\n', '    public\n', '    constant\n', '    returns (uint256 rateValue, uint256 bonusAirDrop, uint64 start, uint64 stop, uint64 updated, bool enabled)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        Rate memory rate = rates[period];\n', '        require(rate.initialized);\n', '\n', '        return (rate.rate, rate.bonusAirDrop, rate.start, rate.stop, rate.updated, rate.enabled);\n', '    }\n', '\n', '    function updRate(Period _period, uint256 _rate)\n', '    authLevel(Level.DAPP)\n', '    validPeriod(_period)\n', '    greaterThanZero(_rate)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateChanged(msg.sender, period, rates[period].rate, _rate);\n', '        rates[period].rate = _rate;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateBonusAirDrop(Period _period, uint256 _bonusAirDrop)\n', '    authLevel(Level.DAPP)\n', '    validPeriod(_period)\n', '    validUint(_bonusAirDrop)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateBonusChanged(msg.sender, period, rates[period].bonusAirDrop, _bonusAirDrop);\n', '        rates[period].bonusAirDrop = _bonusAirDrop;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateTimes(Period _period, uint64 _start, uint64 _stop)\n', '    authLevel(Level.ADMIN)\n', '    validPeriod(_period)\n', '    validUint64(_start)\n', '    validUint64(_stop)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(_start < _stop);\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateTimeChanged(msg.sender, period, rates[period].start, rates[period].stop, _start, _stop);\n', '        rates[period].start = _start;\n', '        rates[period].stop = _stop;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateEnabled(Period _period, bool _enabled)\n', '    authLevel(Level.ADMIN)\n', '    validPeriod(_period)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        rates[period].enabled = _enabled;\n', '        rates[period].updated = uint64(now);\n', '        RatePropsChanged(msg.sender, period, "enabled", _enabled);\n', '        return true;\n', '    }\n', '\n', '    function setInvestor(address _wallet, uint256 _bonus)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    validUint(_bonus)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint64 now64 = uint64(now);\n', '        if (investors[_wallet].initialized) {\n', '            InvestorBonusChanged(msg.sender, _wallet, investors[_wallet].bonus, _bonus);\n', '            investors[_wallet].bonus = _bonus;\n', '            investors[_wallet].updated = now64;\n', '        } else {\n', '            Investor memory investor = Investor({\n', '                wallet: _wallet,\n', '                bonus: _bonus,\n', '                updated: now64,\n', '                preSaleEnabled: false,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            investors[_wallet] = investor;\n', '            investorCount = investorCount.add(1);\n', '            InvestorCreated(msg.sender, _wallet, _bonus);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function updInvestorEnabled(address _wallet, bool _enabled)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        investors[_wallet].enabled = _enabled;\n', '        investors[_wallet].updated = uint64(now);\n', '        InvestorPropsChanged(msg.sender, _wallet, "enabled", _enabled);\n', '        return true;\n', '    }\n', '\n', '    function updInvestorPreSaleEnabled(address _wallet, bool _preSaleEnabled)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        investors[_wallet].preSaleEnabled = _preSaleEnabled;\n', '        investors[_wallet].updated = uint64(now);\n', '        InvestorPropsChanged(msg.sender, _wallet, "preSaleEnabled", _preSaleEnabled);\n', '        return true;\n', '    }\n', '\n', '    function delInvestor(address _wallet)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        delete investors[_wallet];\n', '        investorCount = investorCount.sub(1);\n', '        InvestorDeleted(msg.sender, _wallet);\n', '        return true;\n', '    }\n', '\n', '    function getInvestor(address _wallet)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    constant\n', '    returns (uint256 bonus, uint64 updated, bool preSaleEnabled, bool enabled)\n', '    {\n', '        Investor memory investor = investors[_wallet];\n', '        require(investor.initialized);\n', '\n', '        return (investor.bonus,\n', '            investor.updated,\n', '            investor.preSaleEnabled,\n', '            investor.enabled);\n', '    }\n', '\n', '    function setWalletWithdraw(address _wallet)\n', '    onlyOwner\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        WalletWithdrawChanged(msg.sender, walletWithdraw, _wallet);\n', '        walletWithdraw = _wallet;\n', '        return true;\n', '    }\n', '\n', '    function setDapCarToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        dapCarToken = IDapCarToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function setCouponToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        couponToken = ICouponToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function setAirDropToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        airDropToken = IAirDropToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function balanceAirDropToken(address _address)\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    public\n', '    view\n', '    returns (uint256 balance)\n', '    {\n', '        if (address(airDropToken) != 0) {\n', '            return airDropToken.balanceOf(_address);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function donate() \n', '    internal \n', '    {\n', '        if (msg.value > 0) {\n', '            weiDonated = weiDonated.add(msg.value);\n', '            Donate(msg.sender, msg.value);\n', '            if (walletWithdraw != address(0)) {\n', '                walletWithdraw.transfer(msg.value);\n', '            }\n', '        }\n', '\t}\n', '\n', '    function withdrawTokens(address _token, uint256 _amount)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notOwner(_token)\n', '    notThis(_token)\n', '    greaterThanZero(_amount)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        address wallet = walletWithdraw;\n', '        if (wallet == address(0)) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        bool result = IERC20(_token).transfer(wallet, _amount);\n', '        if (result) {\n', '            WithdrawTokens(msg.sender, wallet, _token, _amount);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function withdraw() \n', '    public \n', '    returns (bool success)\n', '    {\n', '        return withdrawAmount(address(this).balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 _amount) \n', '    authLevel(Level.ADMIN) \n', '    greaterThanZero(address(this).balance)\n', '    greaterThanZero(_amount)\n', '    validBalanceThis(_amount)\n', '    public \n', '    returns (bool success)\n', '    {\n', '        address wallet = walletWithdraw;\n', '        if (wallet == address(0)) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        Withdraw(msg.sender, wallet, _amount);\n', '        wallet.transfer(_amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceToken(address _token)\n', '    validAddress(_token)\n', '    notOwner(_token)\n', '    notThis(_token)\n', '    public \n', '    constant\n', '    returns (uint256 amount) \n', '    {\n', '        return IERC20(_token).balanceOf(address(this));\n', '    }\n', '\n', '    function getCouponBonus(string _code)\n', '    internal\n', '    view\n', '    returns (uint256) \n', '    {\n', '        uint bonus = 0;\n', '        if (couponToken == address(0) || bytes(_code).length != 8) {\n', '            return bonus;\n', '        }\n', '\n', '        bool disposable;\n', '        bool consumed;\n', '        bool enabled;\n', '        (bonus, disposable, consumed, enabled) = couponToken.getCoupon(_code);\n', '\n', '        if (enabled && (!disposable || (disposable && !consumed))) { \n', '            return bonus;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function updCouponBonusConsumed(string _code, bool _consumed)\n', '    internal\n', '    returns (bool success) \n', '    {\n', '        if (couponToken == address(0) || bytes(_code).length != 8) {\n', '            return false;\n', '        }\n', '        return couponToken.updCouponConsumed(_code, _consumed);\n', '    }\n', '\n', '    function purchase()\n', '    notThis(msg.sender)\n', '    greaterThanZero(msg.value)\n', '    internal\n', '    {\n', '        Period period = nowPeriod();\n', '        if (crowdSaleFinalized || !crowdSaleEnabled || period == Period.ZERO || msg.value <= minPurchaseLimit) {\n', '            donate();\n', '        } else if (dapCarToken == address(0)) {\n', '            donate();\n', '        } else {\n', '            Rate memory rate = rates[uint8(period)];\n', '            Investor memory investor = investors[msg.sender];\n', '            uint256 bonus = 0;\n', '            if (period == Period.PRESALE) {\n', '                if (!investor.preSaleEnabled) {\n', '                    donate();\n', '                    return;\n', '                } \n', '            }\n', '            if (investor.enabled) {\n', '                if (investor.bonus > 0) {\n', '                    bonus = bonus.add(investor.bonus);\n', '                }\n', '            }\n', '            if (msg.data.length == 8) {\n', '                uint256 bonusCoupon = getCouponBonus(string(msg.data));\n', '                if (bonusCoupon > 0 && updCouponBonusConsumed(string(msg.data), true)) {\n', '                    bonus = bonus.add(bonusCoupon);\n', '                }\n', '            }\n', '            if (airDropTokenEnabled) {\n', '                if (balanceAirDropToken(msg.sender) > 0) {\n', '                    bonus = bonus.add(rate.bonusAirDrop);\n', '                    if (airDropTokenDestroy && address(airDropToken) != 0) {\n', '                        address[] memory senders = new address[](1);\n', '                        senders[0] = msg.sender;\n', '                        airDropToken.burnAirDrop(senders);\n', '                    }\n', '                }\n', '            }\n', '            if (amountBonusEnabled) {\n', '                if (msg.value >= 5 ether && msg.value < 10 ether) {\n', '                    bonus = bonus.add(5);\n', '                } else if (msg.value >= 10 ether && msg.value < 50 ether) {\n', '                    bonus = bonus.add(10);\n', '                } else if (msg.value >= 50 ether) {\n', '                    bonus = bonus.add(15);\n', '                }\n', '            }\n', '            \n', '            uint256 purchaseToken = rate.rate.mul(1 ether).mul(msg.value).div(1 ether).div(1 ether);\n', '            if (bonus > 0) {\n', '                purchaseToken = purchaseToken.add(purchaseToken.mul(bonus).div(100));\n', '            }\n', '\n', '            if (walletWithdraw != address(0)) {\n', '                walletWithdraw.transfer(msg.value);\n', '            }\n', '\n', '            dapCarToken.mint(msg.sender, purchaseToken);\n', '            Purchase(msg.sender, msg.value, purchaseToken, bonus);\n', '\n', '            weiRaised = weiRaised.add(msg.value);\n', '            soldToken = soldToken.add(purchaseToken);\n', '        }\n', '    }\n', '\n', '    function () \n', '    notThis(msg.sender)\n', '    greaterThanZero(msg.value)\n', '    external \n', '    payable \n', '    {\n', '        purchase();\n', '\t}\n', '\n', '    function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData)\n', '    validAddress(_spender)\n', '    validAddress(_token)\n', '    greaterThanZero(_value)\n', '    public \n', '    {\n', '        IERC20 token = IERC20(_token);\n', '        require(token.transferFrom(_spender, address(this), _value));\n', '        ReceiveTokens(_spender, _token, _value, _extraData);\n', '    }\n', '\n', '    function finalize()\n', '    onlyOwner\n', '    public\n', '    returns (bool success)\n', '    {\n', '        return finalization();\n', '    }\n', '\n', '    function finalization()\n', '    internal\n', '    returns (bool success)\n', '    {\n', '        if (address(this).balance > 0) {\n', '            address wallet = walletWithdraw;\n', '            if (wallet == address(0)) {\n', '                wallet = owner;\n', '            }\n', '\n', '            Withdraw(msg.sender, wallet, address(this).balance);\n', '            wallet.transfer(address(this).balance);\n', '        }\n', '\n', '        //42% for Team, Advisor, Bounty, Reserve and Charity funds.\n', '        fundToken = soldToken.mul(42).div(100);\n', '        dapCarToken.mint(walletWithdraw, fundToken);\n', '\n', '        Finalized(msg.sender, uint64(now), weiRaised, soldToken, fundToken, weiDonated);\n', '        crowdSaleFinalized = true;\n', '        return true;\n', '    }\n', '\n', '    function kill() \n', '    onlyOwner \n', '    public \n', '    { \n', '        if (crowdSaleFinalized) {\n', '            selfdestruct(owner);\n', '        }\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '/*\n', '*   CrowdSale DapCar (DAPX)\n', '*   Created by Starlag Labs (www.starlag.com)\n', '*   Copyright © DapCar.io 2018. All rights reserved.\n', '*   https://www.dapcar.io\n', '*/\n', '\n', 'library Math {\n', '    function mul(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) \n', '    internal \n', '    pure \n', '    returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Utils {\n', '    function Utils() public {}\n', '\n', '    modifier greaterThanZero(uint256 _value) \n', '    {\n', '        require(_value > 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint(uint256 _value) \n', '    {\n', '        require(_value >= 0);\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _address) \n', '    {\n', '        require(_address != address(0));\n', '        _;\n', '    }\n', '\n', '    modifier notThis(address _address) \n', '    {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier validAddressAndNotThis(address _address) \n', '    {\n', '        require(_address != address(0) && _address != address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notEmpty(string _data)\n', '    {\n', '        require(bytes(_data).length > 0);\n', '        _;\n', '    }\n', '\n', '    modifier stringLength(string _data, uint256 _length)\n', '    {\n', '        require(bytes(_data).length == _length);\n', '        _;\n', '    }\n', '    \n', '    modifier validBytes32(bytes32 _bytes)\n', '    {\n', '        require(_bytes != 0);\n', '        _;\n', '    }\n', '\n', '    modifier validUint64(uint64 _value) \n', '    {\n', '        require(_value >= 0 && _value < 4294967296);\n', '        _;\n', '    }\n', '\n', '    modifier validUint8(uint8 _value) \n', '    {\n', '        require(_value >= 0 && _value < 256);\n', '        _;\n', '    }\n', '\n', '    modifier validBalanceThis(uint256 _value)\n', '    {\n', '        require(_value <= address(this).balance);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Authorizable is Utils {\n', '    using Math for uint256;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    mapping (address => Level) authorizeds;\n', '    uint256 public authorizedCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   OWNER 1\n', '    *   ADMIN 2\n', '    *   DAPP 3\n', '    */  \n', '    enum Level {ZERO,OWNER,ADMIN,DAPP}\n', '\n', '    event OwnerTransferred(address indexed _prevOwner, address indexed _newOwner);\n', '    event Authorized(address indexed _address, Level _level);\n', '    event UnAuthorized(address indexed _address);\n', '\n', '    function Authorizable() \n', '    public \n', '    {\n', '        owner = msg.sender;\n', '        authorizeds[msg.sender] = Level.OWNER;\n', '        authorizedCount = authorizedCount.add(1);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(authorizeds[msg.sender] == Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrThis {\n', '        require(authorizeds[msg.sender] == Level.OWNER || msg.sender == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier notOwner(address _address) {\n', '        require(authorizeds[_address] != Level.OWNER);\n', '        _;\n', '    }\n', '\n', '    modifier authLevel(Level _level) {\n', '        require((authorizeds[msg.sender] > Level.ZERO) && (authorizeds[msg.sender] <= _level));\n', '        _;\n', '    }\n', '\n', '    modifier authLevelOnly(Level _level) {\n', '        require(authorizeds[msg.sender] == _level);\n', '        _;\n', '    }\n', '    \n', '    modifier notSender(address _address) {\n', '        require(msg.sender != _address);\n', '        _;\n', '    }\n', '\n', '    modifier isSender(address _address) {\n', '        require(msg.sender == _address);\n', '        _;\n', '    }\n', '\n', '    modifier checkLevel(Level _level) {\n', '        require((_level > Level.ZERO) && (Level.DAPP >= _level));\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) \n', '    public \n', '    {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) \n', '    onlyOwner \n', '    validAddress(_newOwner)\n', '    notThis(_newOwner)\n', '    internal \n', '    {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() \n', '    validAddress(newOwner)\n', '    isSender(newOwner)\n', '    public \n', '    {\n', '        OwnerTransferred(owner, newOwner);\n', '        if (authorizeds[owner] == Level.OWNER) {\n', '            delete authorizeds[owner];\n', '        }\n', '        if (authorizeds[newOwner] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        authorizeds[owner] = Level.OWNER;\n', '    }\n', '\n', '    function cancelOwnership() \n', '    onlyOwner\n', '    public \n', '    {\n', '        newOwner = address(0);\n', '    }\n', '\n', '    function authorized(address _address, Level _level) \n', '    public  \n', '    {\n', '        _authorized(_address, _level);\n', '    }\n', '\n', '    function _authorized(address _address, Level _level) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    checkLevel(_level)\n', '    internal  \n', '    {\n', '        if (authorizeds[_address] == Level.ZERO) {\n', '            authorizedCount = authorizedCount.add(1);\n', '        }\n', '        authorizeds[_address] = _level;\n', '        Authorized(_address, _level);\n', '    }\n', '\n', '    function unAuthorized(address _address) \n', '    onlyOwner\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    notThis(_address)\n', '    public  \n', '    {\n', '        if (authorizeds[_address] > Level.ZERO) {\n', '            authorizedCount = authorizedCount.sub(1);\n', '        }\n', '        delete authorizeds[_address];\n', '        UnAuthorized(_address);\n', '    }\n', '\n', '    function isAuthorized(address _address) \n', '    validAddress(_address)\n', '    notThis(_address)\n', '    public \n', '    constant \n', '    returns (Level) \n', '    {\n', '        return authorizeds[_address];\n', '    }\n', '}\n', '\n', 'contract IERC20 {\n', '    function totalSupply() public constant returns (uint256);\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ITokenRecipient { function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData) public; }\n', '\n', 'contract ICouponToken {\n', '    function updCouponConsumed(string _code, bool _consumed) public returns (bool success);\n', '    function getCoupon(string _code) public view returns (uint256 bonus, \n', '        bool disposable, bool consumed, bool enabled);\n', '}\n', '\n', 'contract IDapCarToken {\n', '    function mint(address _address, uint256 _value) public returns (bool);\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '}\n', '\n', 'contract IAirDropToken {\n', '    function burnAirDrop(address[] _address) public;\n', '    function balanceOf(address _owner) public constant returns (uint balance);\n', '}\n', '\n', 'contract CrowdSaleDapCar is Authorizable {\n', '    string public version = "0.1";\n', '    string public publisher = "https://www.dapcar.io";\n', '    string public description = "This is an official CrowdSale DapCar (DAPX)";\n', '\n', '    address public walletWithdraw;\n', '    IDapCarToken public dapCarToken;\n', '    IAirDropToken public airDropToken;\n', '    ICouponToken public couponToken;\n', '\n', '    uint256 public weiRaised = 0;\n', '    uint256 public soldToken = 0;\n', '    uint256 public fundToken = 0;\n', '    uint256 public weiDonated = 0;\n', '    uint256 public minPurchaseLimit = 10 finney;\n', '\n', '    bool public crowdSaleEnabled = true;\n', '    bool public crowdSaleFinalized = false;\n', '    bool public crowdSaleInitialized = false;\n', '\n', '    bool public airDropTokenEnabled = true;\n', '    bool public airDropTokenDestroy = true;\n', '    bool public amountBonusEnabled = true;\n', '    bool public couponBonusEnabled = true;\n', '\n', '    mapping (uint8 => Rate) rates;\n', '\n', '    mapping (address => Investor) investors;\n', '    uint256 public investorCount;\n', '\n', '    /*  \n', '    *   ZERO 0 - bug for null object\n', '    *   PRESALE 1\n', '    *   PREICO 2\n', '    *   ICO 3\n', '    *   PRERELEASE 4\n', '    */ \n', '    enum Period {ZERO,PRESALE,PREICO,ICO,PRERELEASE}\n', '\n', '    struct Rate {\n', '        Period period;\n', '        uint256 rate;\n', '        uint256 bonusAirDrop;\n', '        uint64 start;\n', '        uint64 stop;\n', '        uint64 updated;\n', '        bool enabled;\n', '        bool initialized;\n', '    }\n', '\n', '    struct Investor {\n', '        address wallet;\n', '        uint256 bonus;\n', '        uint64 updated;\n', '        bool preSaleEnabled;\n', '        bool enabled;\n', '        bool initialized;\n', '    }\n', '\n', '\n', '    event Donate(address indexed sender, uint256 value);\n', '    event WalletWithdrawChanged(address indexed sender, address indexed oldWallet, address indexed newWallet);\n', '    event Withdraw(address indexed sender, address indexed wallet, uint256 amount);\n', '    event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount);\n', '    event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData);\n', '    event RatePropsChanged(address indexed sender, uint8 period, string props, bool value);\n', '    event RateChanged(address indexed sender, uint8 period, uint256 oldBonus, uint256 newBonus);\n', '    event RateBonusChanged(address indexed sender, uint8 period, uint256 oldBonus, uint256 newBonus);\n', '    event RateTimeChanged(address indexed sender, uint8 period, uint64 oldStart, uint64 oldStop, \n', '        uint64 newStart, uint64 newStop);\n', '    event InvestorDeleted(address indexed sender, address indexed wallet);\n', '    event InvestorPropsChanged(address indexed sender, address indexed wallet, string props, bool value);\n', '    event InvestorBonusChanged(address indexed sender, address indexed wallet, uint256 oldBonus, uint256 newBonus);\n', '    event InvestorCreated(address indexed sender, address indexed wallet, uint256 bonus);\n', '    event Purchase(address indexed sender, uint256 amountWei, uint256 amountToken, uint256 totalBonus);\n', '    event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue);\n', '    event MinPurchaseLimitChanged(address indexed sender, uint256 oldValu, uint256 newValue);\n', '    event Finalized(address indexed sender, uint64 time, uint256 weiRaised, uint256 soldToken, \n', '        uint256 fundToken, uint256 weiDonated);\n', '\n', '    modifier validPeriod(Period _period) \n', '    {\n', '        require(_period > Period.ZERO && _period <= Period.PRERELEASE);\n', '        _;\n', '    }\n', '\n', '    function CrowdSaleDapCar() public {\n', '        crowdSalePeriodInit();\n', '    }\n', '\n', '    /*\n', '    *   PRESALE: 1 DAPX = 1$\n', '    *   Monday, 5 March 2018, 00:00:00 GMT - Sunday, 25 March 2018, 23:59:59 GMT\n', '    *   PREICO: 1 DAPX = 2$\n', '    *   Monday, 9 April 2018, 00:00:00 GMT - Sunday, 29 April 2018, 23:59:59 GMT\n', '    *   ICO: 1 DAPX = 5$\n', '    *   Monday, 7 May 2018, 00:00:00 GMT - Sunday, 17 June 2018, 23:59:59 GMT\n', '    *   PRERELEASE: 1 DAPX = 10$\n', '    *   Monday, 18 June 2018, 00:00:00 GMT - Sunday, 1 July 2018, 23:59:59 GMT\n', '    *   RELEASE GAME: 1 DAPX = 1 DAPBOX >= 15$\n', '    */\n', '    \n', '    function crowdSalePeriodInit()\n', '    onlyOwnerOrThis\n', '    public\n', '    returns (bool success)\n', '    {\n', '        if (!crowdSaleInitialized) {\n', '            Rate memory ratePreSale = Rate({\n', '                period: Period.PRESALE,\n', '                rate: 740,\n', '                bonusAirDrop: 0,\n', '                start: 1520208000,\n', '                stop: 1522022399,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PRESALE)] = ratePreSale;\n', '\n', '            Rate memory ratePreIco = Rate({\n', '                period: Period.PREICO,\n', '                rate: 370,\n', '                bonusAirDrop: 10,\n', '                start: 1523232000,\n', '                stop: 1525046399,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PREICO)] = ratePreIco;\n', '\n', '            Rate memory rateIco = Rate({\n', '                period: Period.ICO,\n', '                rate: 148,\n', '                bonusAirDrop: 5,\n', '                start: 1525651200,\n', '                stop: 1529279999,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.ICO)] = rateIco;\n', '\n', '            Rate memory ratePreRelease = Rate({\n', '                period: Period.PRERELEASE,\n', '                rate: 74,\n', '                bonusAirDrop: 0,\n', '                start: 1529280000,\n', '                stop: 1530489599,\n', '                updated: 0,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            rates[uint8(Period.PRERELEASE)] = ratePreRelease;\n', '        \n', '            crowdSaleInitialized = true;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function nowPeriod()\n', '    public\n', '    constant\n', '    returns (Period)\n', '    {\n', '        uint64 now64 = uint64(now);\n', '        Period period = Period.ZERO;\n', '        for (uint8 i = 1; i <= uint8(Period.PRERELEASE); i++) {\n', '            Rate memory rate = rates[i];\n', '            if (!rate.initialized || !rate.enabled) { \n', '                continue; \n', '            }\n', '            if (rate.start == 0 || rate.stop == 0 || rate.rate == 0) { \n', '                continue; \n', '            }\n', '            \n', '            if (now64 >= rate.start && now64 < rate.stop) {\n', '                period = rate.period;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return period;\n', '    }\n', '\n', '    function updCrowdSaleEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "crowdSaleEnabled", crowdSaleEnabled, _value);\n', '        crowdSaleEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAirDropTokenEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "airDropTokenEnabled", airDropTokenEnabled, _value);\n', '        airDropTokenEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAirDropTokenDestroy(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "airDropTokenDestroy", airDropTokenDestroy, _value);\n', '        airDropTokenDestroy = _value;\n', '        return true;\n', '    }\n', '\n', '    function updAmountBonusEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "amountBonusEnabled", amountBonusEnabled, _value);\n', '        amountBonusEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updCouponBonusEnabled(bool _value)\n', '    authLevel(Level.ADMIN)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        PropsChanged(msg.sender, "couponBonusEnabled", couponBonusEnabled, _value);\n', '        couponBonusEnabled = _value;\n', '        return true;\n', '    }\n', '\n', '    function updMinPurchaseLimit(uint256 _limit)\n', '    authLevel(Level.ADMIN)\n', '    validUint(_limit)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        MinPurchaseLimitChanged(msg.sender, minPurchaseLimit, _limit);\n', '        minPurchaseLimit = _limit;\n', '        return true;\n', '    }\n', '    \n', '    function getRate(Period _period)\n', '    validPeriod(_period)\n', '    public\n', '    constant\n', '    returns (uint256 rateValue, uint256 bonusAirDrop, uint64 start, uint64 stop, uint64 updated, bool enabled)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        Rate memory rate = rates[period];\n', '        require(rate.initialized);\n', '\n', '        return (rate.rate, rate.bonusAirDrop, rate.start, rate.stop, rate.updated, rate.enabled);\n', '    }\n', '\n', '    function updRate(Period _period, uint256 _rate)\n', '    authLevel(Level.DAPP)\n', '    validPeriod(_period)\n', '    greaterThanZero(_rate)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateChanged(msg.sender, period, rates[period].rate, _rate);\n', '        rates[period].rate = _rate;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateBonusAirDrop(Period _period, uint256 _bonusAirDrop)\n', '    authLevel(Level.DAPP)\n', '    validPeriod(_period)\n', '    validUint(_bonusAirDrop)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateBonusChanged(msg.sender, period, rates[period].bonusAirDrop, _bonusAirDrop);\n', '        rates[period].bonusAirDrop = _bonusAirDrop;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateTimes(Period _period, uint64 _start, uint64 _stop)\n', '    authLevel(Level.ADMIN)\n', '    validPeriod(_period)\n', '    validUint64(_start)\n', '    validUint64(_stop)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(_start < _stop);\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        RateTimeChanged(msg.sender, period, rates[period].start, rates[period].stop, _start, _stop);\n', '        rates[period].start = _start;\n', '        rates[period].stop = _stop;\n', '        rates[period].updated = uint64(now);\n', '        return true;\n', '    }\n', '\n', '    function updRateEnabled(Period _period, bool _enabled)\n', '    authLevel(Level.ADMIN)\n', '    validPeriod(_period)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint8 period = uint8(_period);\n', '        require(rates[period].initialized);\n', '\n', '        rates[period].enabled = _enabled;\n', '        rates[period].updated = uint64(now);\n', '        RatePropsChanged(msg.sender, period, "enabled", _enabled);\n', '        return true;\n', '    }\n', '\n', '    function setInvestor(address _wallet, uint256 _bonus)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    validUint(_bonus)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        uint64 now64 = uint64(now);\n', '        if (investors[_wallet].initialized) {\n', '            InvestorBonusChanged(msg.sender, _wallet, investors[_wallet].bonus, _bonus);\n', '            investors[_wallet].bonus = _bonus;\n', '            investors[_wallet].updated = now64;\n', '        } else {\n', '            Investor memory investor = Investor({\n', '                wallet: _wallet,\n', '                bonus: _bonus,\n', '                updated: now64,\n', '                preSaleEnabled: false,\n', '                enabled: true,\n', '                initialized: true\n', '            });\n', '            investors[_wallet] = investor;\n', '            investorCount = investorCount.add(1);\n', '            InvestorCreated(msg.sender, _wallet, _bonus);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function updInvestorEnabled(address _wallet, bool _enabled)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        investors[_wallet].enabled = _enabled;\n', '        investors[_wallet].updated = uint64(now);\n', '        InvestorPropsChanged(msg.sender, _wallet, "enabled", _enabled);\n', '        return true;\n', '    }\n', '\n', '    function updInvestorPreSaleEnabled(address _wallet, bool _preSaleEnabled)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        investors[_wallet].preSaleEnabled = _preSaleEnabled;\n', '        investors[_wallet].updated = uint64(now);\n', '        InvestorPropsChanged(msg.sender, _wallet, "preSaleEnabled", _preSaleEnabled);\n', '        return true;\n', '    }\n', '\n', '    function delInvestor(address _wallet)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        require(investors[_wallet].initialized);\n', '\n', '        delete investors[_wallet];\n', '        investorCount = investorCount.sub(1);\n', '        InvestorDeleted(msg.sender, _wallet);\n', '        return true;\n', '    }\n', '\n', '    function getInvestor(address _wallet)\n', '    validAddress(_wallet)\n', '    notThis(_wallet)\n', '    public\n', '    constant\n', '    returns (uint256 bonus, uint64 updated, bool preSaleEnabled, bool enabled)\n', '    {\n', '        Investor memory investor = investors[_wallet];\n', '        require(investor.initialized);\n', '\n', '        return (investor.bonus,\n', '            investor.updated,\n', '            investor.preSaleEnabled,\n', '            investor.enabled);\n', '    }\n', '\n', '    function setWalletWithdraw(address _wallet)\n', '    onlyOwner\n', '    notThis(_wallet)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        WalletWithdrawChanged(msg.sender, walletWithdraw, _wallet);\n', '        walletWithdraw = _wallet;\n', '        return true;\n', '    }\n', '\n', '    function setDapCarToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        dapCarToken = IDapCarToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function setCouponToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        couponToken = ICouponToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function setAirDropToken(address _token)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notThis(_token)\n', '    notOwner(_token)\n', '    public\n', '    returns (bool success)\n', '    {\n', '        airDropToken = IAirDropToken(_token);\n', '        return true;\n', '    }\n', '\n', '    function balanceAirDropToken(address _address)\n', '    validAddress(_address)\n', '    notOwner(_address)\n', '    public\n', '    view\n', '    returns (uint256 balance)\n', '    {\n', '        if (address(airDropToken) != 0) {\n', '            return airDropToken.balanceOf(_address);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function donate() \n', '    internal \n', '    {\n', '        if (msg.value > 0) {\n', '            weiDonated = weiDonated.add(msg.value);\n', '            Donate(msg.sender, msg.value);\n', '            if (walletWithdraw != address(0)) {\n', '                walletWithdraw.transfer(msg.value);\n', '            }\n', '        }\n', '\t}\n', '\n', '    function withdrawTokens(address _token, uint256 _amount)\n', '    authLevel(Level.ADMIN)\n', '    validAddress(_token)\n', '    notOwner(_token)\n', '    notThis(_token)\n', '    greaterThanZero(_amount)\n', '    public \n', '    returns (bool success) \n', '    {\n', '        address wallet = walletWithdraw;\n', '        if (wallet == address(0)) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        bool result = IERC20(_token).transfer(wallet, _amount);\n', '        if (result) {\n', '            WithdrawTokens(msg.sender, wallet, _token, _amount);\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function withdraw() \n', '    public \n', '    returns (bool success)\n', '    {\n', '        return withdrawAmount(address(this).balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 _amount) \n', '    authLevel(Level.ADMIN) \n', '    greaterThanZero(address(this).balance)\n', '    greaterThanZero(_amount)\n', '    validBalanceThis(_amount)\n', '    public \n', '    returns (bool success)\n', '    {\n', '        address wallet = walletWithdraw;\n', '        if (wallet == address(0)) {\n', '            wallet = msg.sender;\n', '        }\n', '\n', '        Withdraw(msg.sender, wallet, _amount);\n', '        wallet.transfer(_amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceToken(address _token)\n', '    validAddress(_token)\n', '    notOwner(_token)\n', '    notThis(_token)\n', '    public \n', '    constant\n', '    returns (uint256 amount) \n', '    {\n', '        return IERC20(_token).balanceOf(address(this));\n', '    }\n', '\n', '    function getCouponBonus(string _code)\n', '    internal\n', '    view\n', '    returns (uint256) \n', '    {\n', '        uint bonus = 0;\n', '        if (couponToken == address(0) || bytes(_code).length != 8) {\n', '            return bonus;\n', '        }\n', '\n', '        bool disposable;\n', '        bool consumed;\n', '        bool enabled;\n', '        (bonus, disposable, consumed, enabled) = couponToken.getCoupon(_code);\n', '\n', '        if (enabled && (!disposable || (disposable && !consumed))) { \n', '            return bonus;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function updCouponBonusConsumed(string _code, bool _consumed)\n', '    internal\n', '    returns (bool success) \n', '    {\n', '        if (couponToken == address(0) || bytes(_code).length != 8) {\n', '            return false;\n', '        }\n', '        return couponToken.updCouponConsumed(_code, _consumed);\n', '    }\n', '\n', '    function purchase()\n', '    notThis(msg.sender)\n', '    greaterThanZero(msg.value)\n', '    internal\n', '    {\n', '        Period period = nowPeriod();\n', '        if (crowdSaleFinalized || !crowdSaleEnabled || period == Period.ZERO || msg.value <= minPurchaseLimit) {\n', '            donate();\n', '        } else if (dapCarToken == address(0)) {\n', '            donate();\n', '        } else {\n', '            Rate memory rate = rates[uint8(period)];\n', '            Investor memory investor = investors[msg.sender];\n', '            uint256 bonus = 0;\n', '            if (period == Period.PRESALE) {\n', '                if (!investor.preSaleEnabled) {\n', '                    donate();\n', '                    return;\n', '                } \n', '            }\n', '            if (investor.enabled) {\n', '                if (investor.bonus > 0) {\n', '                    bonus = bonus.add(investor.bonus);\n', '                }\n', '            }\n', '            if (msg.data.length == 8) {\n', '                uint256 bonusCoupon = getCouponBonus(string(msg.data));\n', '                if (bonusCoupon > 0 && updCouponBonusConsumed(string(msg.data), true)) {\n', '                    bonus = bonus.add(bonusCoupon);\n', '                }\n', '            }\n', '            if (airDropTokenEnabled) {\n', '                if (balanceAirDropToken(msg.sender) > 0) {\n', '                    bonus = bonus.add(rate.bonusAirDrop);\n', '                    if (airDropTokenDestroy && address(airDropToken) != 0) {\n', '                        address[] memory senders = new address[](1);\n', '                        senders[0] = msg.sender;\n', '                        airDropToken.burnAirDrop(senders);\n', '                    }\n', '                }\n', '            }\n', '            if (amountBonusEnabled) {\n', '                if (msg.value >= 5 ether && msg.value < 10 ether) {\n', '                    bonus = bonus.add(5);\n', '                } else if (msg.value >= 10 ether && msg.value < 50 ether) {\n', '                    bonus = bonus.add(10);\n', '                } else if (msg.value >= 50 ether) {\n', '                    bonus = bonus.add(15);\n', '                }\n', '            }\n', '            \n', '            uint256 purchaseToken = rate.rate.mul(1 ether).mul(msg.value).div(1 ether).div(1 ether);\n', '            if (bonus > 0) {\n', '                purchaseToken = purchaseToken.add(purchaseToken.mul(bonus).div(100));\n', '            }\n', '\n', '            if (walletWithdraw != address(0)) {\n', '                walletWithdraw.transfer(msg.value);\n', '            }\n', '\n', '            dapCarToken.mint(msg.sender, purchaseToken);\n', '            Purchase(msg.sender, msg.value, purchaseToken, bonus);\n', '\n', '            weiRaised = weiRaised.add(msg.value);\n', '            soldToken = soldToken.add(purchaseToken);\n', '        }\n', '    }\n', '\n', '    function () \n', '    notThis(msg.sender)\n', '    greaterThanZero(msg.value)\n', '    external \n', '    payable \n', '    {\n', '        purchase();\n', '\t}\n', '\n', '    function receiveApproval(address _spender, uint256 _value, address _token, bytes _extraData)\n', '    validAddress(_spender)\n', '    validAddress(_token)\n', '    greaterThanZero(_value)\n', '    public \n', '    {\n', '        IERC20 token = IERC20(_token);\n', '        require(token.transferFrom(_spender, address(this), _value));\n', '        ReceiveTokens(_spender, _token, _value, _extraData);\n', '    }\n', '\n', '    function finalize()\n', '    onlyOwner\n', '    public\n', '    returns (bool success)\n', '    {\n', '        return finalization();\n', '    }\n', '\n', '    function finalization()\n', '    internal\n', '    returns (bool success)\n', '    {\n', '        if (address(this).balance > 0) {\n', '            address wallet = walletWithdraw;\n', '            if (wallet == address(0)) {\n', '                wallet = owner;\n', '            }\n', '\n', '            Withdraw(msg.sender, wallet, address(this).balance);\n', '            wallet.transfer(address(this).balance);\n', '        }\n', '\n', '        //42% for Team, Advisor, Bounty, Reserve and Charity funds.\n', '        fundToken = soldToken.mul(42).div(100);\n', '        dapCarToken.mint(walletWithdraw, fundToken);\n', '\n', '        Finalized(msg.sender, uint64(now), weiRaised, soldToken, fundToken, weiDonated);\n', '        crowdSaleFinalized = true;\n', '        return true;\n', '    }\n', '\n', '    function kill() \n', '    onlyOwner \n', '    public \n', '    { \n', '        if (crowdSaleFinalized) {\n', '            selfdestruct(owner);\n', '        }\n', '    }\n', '\n', '}']
