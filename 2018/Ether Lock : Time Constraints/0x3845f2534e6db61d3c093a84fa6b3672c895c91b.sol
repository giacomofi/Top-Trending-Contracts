['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/Interfaces/MasterDepositInterface.sol\n', '\n', '/**\n', ' * @dev Interface of MasterDeposit that should be used in child contracts \n', ' * @dev this ensures that no duplication of code and implicit gasprice will be used for the dynamic creation of child contract\n', ' */\n', 'contract MasterDepositInterface {\n', '    address public coldWallet1;\n', '    address public coldWallet2;\n', '    uint public percentage;\n', '    function fireDepositToChildEvent(uint _amount) public;\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/ChildDeposit.sol\n', '\n', '/**\n', '* @dev Should be dinamically created from master contract \n', '* @dev multiple payers can contribute here \n', '*/\n', 'contract ChildDeposit {\n', '    \n', '    /**\n', '    * @dev prevents over and under flows\n', '    */\n', '    using SafeMath for uint;\n', '    \n', '    /**\n', '    * @dev import only the interface for low gas cost\n', '    */\n', '    // MasterDepositInterface public master;\n', '    address masterAddress;\n', '\n', '    function ChildDeposit() public {\n', '        masterAddress = msg.sender;\n', '        // master = MasterDepositInterface(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev any ETH income will fire a master deposit contract event\n', '    * @dev the redirect of ETH will be split in the two wallets provided by the master with respect to the share percentage set for wallet 1 \n', '    */\n', '    function() public payable {\n', '\n', '        MasterDepositInterface master = MasterDepositInterface(masterAddress);\n', '        // fire transfer event\n', '        master.fireDepositToChildEvent(msg.value);\n', '\n', '        // trasnfer of ETH\n', '        // with respect to the percentage set\n', '        uint coldWallet1Share = msg.value.mul(master.percentage()).div(100);\n', '        \n', '        // actual transfer\n', '        master.coldWallet1().transfer(coldWallet1Share);\n', '        master.coldWallet2().transfer(msg.value.sub(coldWallet1Share));\n', '    }\n', '\n', '    /**\n', '    * @dev function that can only be called by the creator of this contract\n', '    * @dev the actual condition of transfer is in the logic of the master contract\n', '    * @param _value ERC20 amount \n', '    * @param _tokenAddress ERC20 contract address \n', '    * @param _destination should be onbe of the 2 coldwallets\n', '    */\n', '    function withdraw(address _tokenAddress, uint _value, address _destination) public onlyMaster {\n', '        ERC20(_tokenAddress).transfer(_destination, _value);\n', '    }\n', '\n', '    modifier onlyMaster() {\n', '        require(msg.sender == address(masterAddress));\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="44362129272b0476">[email&#160;protected]</span>&#207;€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Claimable.sol\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '// File: contracts/MasterDeposit.sol\n', '\n', '/**\n', '* @dev master contract that creates ChildDeposits. Responsible for controlling and setup of deposit chain.  \n', '* @dev all functions that should be called from child deposits are specified in the MasterDepositInterface \n', '*/\n', 'contract MasterDeposit is MasterDepositInterface, Claimable, ReentrancyGuard {\n', '    \n', '    /**\n', '    * @dev prevents over and under flows\n', '    */\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev mapping of all created child deposits\n', '    */\n', '    mapping (address => bool) public childDeposits;\n', '\n', '    /**\n', '    * @dev responsible for creating deposits (in this way the owner isn&#39;t exposed to a api/server security breach)\n', '    * @dev by loosing the depositCreator key an attacker can only create deposits that will not be a real threat and another depositCreator can be allocated\n', '    */\n', '    address public depositCreator;\n', '\n', '    /**\n', '    * @dev Fired at create time\n', '    * @param _depositAddress blockchain address of the newly created deposit contract\n', '    */\n', '    event CreatedDepositEvent (\n', '    address indexed _depositAddress\n', '    );\n', '    \n', '    /**\n', '    * @dev Fired at transfer time\n', '    * @dev Event that signals the transfer of an ETH amount \n', '    * @param _depositAddress blockchain address of the deposit contract that received ETH\n', '    * @param _amount of ETH\n', '    */\n', '    event DepositToChildEvent(\n', '    address indexed _depositAddress, \n', '    uint _amount\n', '    );\n', '\n', '\n', '    /**\n', '    * @param _wallet1 redirect of tokens (ERC20) or ETH\n', '    * @param _wallet2 redirect of tokens (ERC20) or eth\n', '    * @param _percentage _wallet1 split percentage \n', '    */\n', '    function MasterDeposit(address _wallet1, address _wallet2, uint _percentage) onlyValidPercentage(_percentage) public {\n', '        require(_wallet1 != address(0));\n', '        require(_wallet2 != address(0));\n', '        percentage = _percentage;\n', '        coldWallet1 = _wallet1;\n', '        coldWallet2 = _wallet2;\n', '    }\n', '\n', '    /**\n', '    * @dev creates a number of instances of ChildDeposit contracts\n', '    * @param _count creates a specified number of deposit contracts\n', '    */\n', '    function createChildDeposits(uint _count) public onlyDepositCreatorOrMaster {\n', '        for (uint i = 0; i < _count; i++) {\n', '            ChildDeposit childDeposit = new ChildDeposit();\n', '            childDeposits[address(childDeposit)] = true;\n', '            emit CreatedDepositEvent(address(childDeposit));    \n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev setter for the address that is responsible for creating deposits \n', '    */\n', '    function setDepositCreator(address _depositCreator) public onlyOwner {\n', '        require(_depositCreator != address(0));\n', '        depositCreator = _depositCreator;\n', '    }\n', '\n', '    /**\n', '    * @dev Setter for the income percentage in the first coldwallet (not setting this the second wallet will receive all income)\n', '    */\n', '    function setColdWallet1SplitPercentage(uint _percentage) public onlyOwner onlyValidPercentage(_percentage) {\n', '        percentage = _percentage;\n', '    }\n', '\n', '    /**\n', '    * @dev function created to emit the ETH transfer event from the child contract only\n', '    * @param _amount ETH amount \n', '    */\n', '    function fireDepositToChildEvent(uint _amount) public onlyChildContract {\n', '        emit DepositToChildEvent(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev changes the coldwallet1 address\n', '    */\n', '    function setColdWallet1(address _coldWallet1) public onlyOwner {\n', '        require(_coldWallet1 != address(0));\n', '        coldWallet1 = _coldWallet1;\n', '    }\n', '\n', '    /**\n', '    * @dev changes the coldwallet2 address\n', '    */\n', '    function setColdWallet2(address _coldWallet2) public onlyOwner {\n', '        require(_coldWallet2 != address(0));\n', '        coldWallet2 = _coldWallet2;\n', '    }\n', '\n', '    /**\n', '    * @dev function that can be called only by owner due to security reasons and will withdraw the amount of ERC20 tokens\n', '    * @dev from the deposit contract list to the cold wallets \n', '    * @dev transfers only the ERC20 tokens, ETH should be transferred automatically\n', '    * @param _deposits batch list with all deposit contracts that might hold ERC20 tokens\n', '    * @param _tokenContractAddress specifies what token to be transfered form each deposit from the batch to the cold wallets\n', '    */\n', '    function transferTokens(address[] _deposits, address _tokenContractAddress) public onlyOwner nonReentrant {\n', '        for (uint i = 0; i < _deposits.length; i++) {\n', '            address deposit = _deposits[i];\n', '            uint erc20Balance = ERC20(_tokenContractAddress).balanceOf(deposit);\n', '\n', '            // if no balance found just skip\n', '            if (erc20Balance == 0) {\n', '                continue;\n', '            }\n', '            \n', '            // trasnfer of erc20 tokens\n', '            // with respect to the percentage set\n', '            uint coldWallet1Share = erc20Balance.mul(percentage).div(100);\n', '            uint coldWallet2Share = erc20Balance.sub(coldWallet1Share); \n', '            ChildDeposit(deposit).withdraw(_tokenContractAddress,coldWallet1Share, coldWallet1);\n', '            ChildDeposit(deposit).withdraw(_tokenContractAddress,coldWallet2Share, coldWallet2);\n', '        }\n', '    }\n', '\n', '    modifier onlyChildContract() {\n', '        require(childDeposits[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDepositCreatorOrMaster() {\n', '        require(msg.sender == owner || msg.sender == depositCreator);\n', '        _;\n', '    }\n', '\n', '    modifier onlyValidPercentage(uint _percentage) {\n', '        require(_percentage >=0 && _percentage <= 100);\n', '        _;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '// File: contracts/Interfaces/MasterDepositInterface.sol\n', '\n', '/**\n', ' * @dev Interface of MasterDeposit that should be used in child contracts \n', ' * @dev this ensures that no duplication of code and implicit gasprice will be used for the dynamic creation of child contract\n', ' */\n', 'contract MasterDepositInterface {\n', '    address public coldWallet1;\n', '    address public coldWallet2;\n', '    uint public percentage;\n', '    function fireDepositToChildEvent(uint _amount) public;\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/ChildDeposit.sol\n', '\n', '/**\n', '* @dev Should be dinamically created from master contract \n', '* @dev multiple payers can contribute here \n', '*/\n', 'contract ChildDeposit {\n', '    \n', '    /**\n', '    * @dev prevents over and under flows\n', '    */\n', '    using SafeMath for uint;\n', '    \n', '    /**\n', '    * @dev import only the interface for low gas cost\n', '    */\n', '    // MasterDepositInterface public master;\n', '    address masterAddress;\n', '\n', '    function ChildDeposit() public {\n', '        masterAddress = msg.sender;\n', '        // master = MasterDepositInterface(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev any ETH income will fire a master deposit contract event\n', '    * @dev the redirect of ETH will be split in the two wallets provided by the master with respect to the share percentage set for wallet 1 \n', '    */\n', '    function() public payable {\n', '\n', '        MasterDepositInterface master = MasterDepositInterface(masterAddress);\n', '        // fire transfer event\n', '        master.fireDepositToChildEvent(msg.value);\n', '\n', '        // trasnfer of ETH\n', '        // with respect to the percentage set\n', '        uint coldWallet1Share = msg.value.mul(master.percentage()).div(100);\n', '        \n', '        // actual transfer\n', '        master.coldWallet1().transfer(coldWallet1Share);\n', '        master.coldWallet2().transfer(msg.value.sub(coldWallet1Share));\n', '    }\n', '\n', '    /**\n', '    * @dev function that can only be called by the creator of this contract\n', '    * @dev the actual condition of transfer is in the logic of the master contract\n', '    * @param _value ERC20 amount \n', '    * @param _tokenAddress ERC20 contract address \n', '    * @param _destination should be onbe of the 2 coldwallets\n', '    */\n', '    function withdraw(address _tokenAddress, uint _value, address _destination) public onlyMaster {\n', '        ERC20(_tokenAddress).transfer(_destination, _value);\n', '    }\n', '\n', '    modifier onlyMaster() {\n', '        require(msg.sender == address(masterAddress));\n', '        _;\n', '    }\n', '    \n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @title Helps contracts guard agains reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>\n', ' * @notice If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancy_lock);\n', '    reentrancy_lock = true;\n', '    _;\n', '    reentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: zeppelin-solidity/contracts/ownership/Claimable.sol\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = address(0);\n', '  }\n', '}\n', '\n', '// File: contracts/MasterDeposit.sol\n', '\n', '/**\n', '* @dev master contract that creates ChildDeposits. Responsible for controlling and setup of deposit chain.  \n', '* @dev all functions that should be called from child deposits are specified in the MasterDepositInterface \n', '*/\n', 'contract MasterDeposit is MasterDepositInterface, Claimable, ReentrancyGuard {\n', '    \n', '    /**\n', '    * @dev prevents over and under flows\n', '    */\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev mapping of all created child deposits\n', '    */\n', '    mapping (address => bool) public childDeposits;\n', '\n', '    /**\n', "    * @dev responsible for creating deposits (in this way the owner isn't exposed to a api/server security breach)\n", '    * @dev by loosing the depositCreator key an attacker can only create deposits that will not be a real threat and another depositCreator can be allocated\n', '    */\n', '    address public depositCreator;\n', '\n', '    /**\n', '    * @dev Fired at create time\n', '    * @param _depositAddress blockchain address of the newly created deposit contract\n', '    */\n', '    event CreatedDepositEvent (\n', '    address indexed _depositAddress\n', '    );\n', '    \n', '    /**\n', '    * @dev Fired at transfer time\n', '    * @dev Event that signals the transfer of an ETH amount \n', '    * @param _depositAddress blockchain address of the deposit contract that received ETH\n', '    * @param _amount of ETH\n', '    */\n', '    event DepositToChildEvent(\n', '    address indexed _depositAddress, \n', '    uint _amount\n', '    );\n', '\n', '\n', '    /**\n', '    * @param _wallet1 redirect of tokens (ERC20) or ETH\n', '    * @param _wallet2 redirect of tokens (ERC20) or eth\n', '    * @param _percentage _wallet1 split percentage \n', '    */\n', '    function MasterDeposit(address _wallet1, address _wallet2, uint _percentage) onlyValidPercentage(_percentage) public {\n', '        require(_wallet1 != address(0));\n', '        require(_wallet2 != address(0));\n', '        percentage = _percentage;\n', '        coldWallet1 = _wallet1;\n', '        coldWallet2 = _wallet2;\n', '    }\n', '\n', '    /**\n', '    * @dev creates a number of instances of ChildDeposit contracts\n', '    * @param _count creates a specified number of deposit contracts\n', '    */\n', '    function createChildDeposits(uint _count) public onlyDepositCreatorOrMaster {\n', '        for (uint i = 0; i < _count; i++) {\n', '            ChildDeposit childDeposit = new ChildDeposit();\n', '            childDeposits[address(childDeposit)] = true;\n', '            emit CreatedDepositEvent(address(childDeposit));    \n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev setter for the address that is responsible for creating deposits \n', '    */\n', '    function setDepositCreator(address _depositCreator) public onlyOwner {\n', '        require(_depositCreator != address(0));\n', '        depositCreator = _depositCreator;\n', '    }\n', '\n', '    /**\n', '    * @dev Setter for the income percentage in the first coldwallet (not setting this the second wallet will receive all income)\n', '    */\n', '    function setColdWallet1SplitPercentage(uint _percentage) public onlyOwner onlyValidPercentage(_percentage) {\n', '        percentage = _percentage;\n', '    }\n', '\n', '    /**\n', '    * @dev function created to emit the ETH transfer event from the child contract only\n', '    * @param _amount ETH amount \n', '    */\n', '    function fireDepositToChildEvent(uint _amount) public onlyChildContract {\n', '        emit DepositToChildEvent(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev changes the coldwallet1 address\n', '    */\n', '    function setColdWallet1(address _coldWallet1) public onlyOwner {\n', '        require(_coldWallet1 != address(0));\n', '        coldWallet1 = _coldWallet1;\n', '    }\n', '\n', '    /**\n', '    * @dev changes the coldwallet2 address\n', '    */\n', '    function setColdWallet2(address _coldWallet2) public onlyOwner {\n', '        require(_coldWallet2 != address(0));\n', '        coldWallet2 = _coldWallet2;\n', '    }\n', '\n', '    /**\n', '    * @dev function that can be called only by owner due to security reasons and will withdraw the amount of ERC20 tokens\n', '    * @dev from the deposit contract list to the cold wallets \n', '    * @dev transfers only the ERC20 tokens, ETH should be transferred automatically\n', '    * @param _deposits batch list with all deposit contracts that might hold ERC20 tokens\n', '    * @param _tokenContractAddress specifies what token to be transfered form each deposit from the batch to the cold wallets\n', '    */\n', '    function transferTokens(address[] _deposits, address _tokenContractAddress) public onlyOwner nonReentrant {\n', '        for (uint i = 0; i < _deposits.length; i++) {\n', '            address deposit = _deposits[i];\n', '            uint erc20Balance = ERC20(_tokenContractAddress).balanceOf(deposit);\n', '\n', '            // if no balance found just skip\n', '            if (erc20Balance == 0) {\n', '                continue;\n', '            }\n', '            \n', '            // trasnfer of erc20 tokens\n', '            // with respect to the percentage set\n', '            uint coldWallet1Share = erc20Balance.mul(percentage).div(100);\n', '            uint coldWallet2Share = erc20Balance.sub(coldWallet1Share); \n', '            ChildDeposit(deposit).withdraw(_tokenContractAddress,coldWallet1Share, coldWallet1);\n', '            ChildDeposit(deposit).withdraw(_tokenContractAddress,coldWallet2Share, coldWallet2);\n', '        }\n', '    }\n', '\n', '    modifier onlyChildContract() {\n', '        require(childDeposits[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyDepositCreatorOrMaster() {\n', '        require(msg.sender == owner || msg.sender == depositCreator);\n', '        _;\n', '    }\n', '\n', '    modifier onlyValidPercentage(uint _percentage) {\n', '        require(_percentage >=0 && _percentage <= 100);\n', '        _;\n', '    }\n', '\n', '}']
