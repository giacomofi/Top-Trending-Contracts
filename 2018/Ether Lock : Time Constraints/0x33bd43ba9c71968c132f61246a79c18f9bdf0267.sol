['pragma solidity ^0.4.25;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'contract BouncyCoinSelfdrop {\n', '\n', '  event TokensSold(address buyer, uint256 tokensAmount, uint256 ethAmount);\n', '\n', '  // Total Supply: 20,000,000,000, 70% for the selfrop\n', '  uint256 public constant MAX_TOKENS_SOLD = 14000000000 * 10**18;\n', '\n', '  // Token Price: 0.00000006665 ETH = 1 BOUNCY <=> 1 ETH ~= 15,000,000 BOUNCY\n', '  uint256 public constant PRICE = 0.00000006665 * 10**18;\n', '\n', '  uint256 public constant MIN_CONTRIBUTION = 0.01 ether;\n', '\n', '  uint256 public constant HARD_CAP = 500 ether;\n', '\n', '  // 1st round: October 17-23, 2018\n', '  // 1539734400 is equivalent to: 10/17/2018 @ 12:00am (UTC)\n', '  uint256 oct_17 = 1539734400;\n', '\n', '  // 2nd round: October 24-27, 2018\n', '  // 1540339200 is equivalent to: 10/24/2018 @ 12:00am (UTC)\n', '  uint256 oct_24 = 1540339200;\n', '\n', '  // 3rd round: October 28-31, 2018\n', '  // 1540684800 is equivalent to: 10/28/2018 @ 12:00am (UTC)\n', '  uint256 oct_28 = 1540684800;\n', '\n', '  // base multiplier does not include extra 10% for 1 ETH and above\n', '  uint256 public first_round_base_multiplier = 40; // 40% base bonus\n', '  uint256 public second_round_base_multiplier = 20; // 20% base bonus\n', '  uint256 public third_round_base_multiplier = 0; // 0% base bonus\n', '\n', '  address public owner;\n', '\n', '  address public wallet;\n', '\n', '  uint256 public tokensSold;\n', '\n', '  uint256 public totalReceived;\n', '\n', '  ERC20 public bouncyCoinToken;\n', '\n', '  /* Current stage */\n', '  Stages public stage;\n', '\n', '  enum Stages {\n', '    Deployed,\n', '    Started,\n', '    Ended\n', '  }\n', '\n', '  /* Modifiers */\n', '\n', '  modifier atStage(Stages _stage) {\n', '    require(stage == _stage);\n', '    _;\n', '  }\n', '\n', '  modifier isOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /* Constructor */\n', '\n', '  constructor(address _wallet, address _bouncyCoinToken)\n', '    public {\n', '    require(_wallet != 0x0);\n', '    require(_bouncyCoinToken != 0x0);\n', '\n', '    owner = msg.sender;\n', '    wallet = _wallet;\n', '    bouncyCoinToken = ERC20(_bouncyCoinToken);\n', '    stage = Stages.Deployed;\n', '  }\n', '\n', '  /* Public functions */\n', '\n', '  function()\n', '    public\n', '    payable {\n', '    if (stage == Stages.Started) {\n', '      buyTokens();\n', '    } else {\n', '      revert();\n', '    }\n', '  }\n', '\n', '  function buyTokens()\n', '    public\n', '    payable\n', '    atStage(Stages.Started) {\n', '    require(msg.value >= MIN_CONTRIBUTION);\n', '\n', '    uint256 base_multiplier;\n', '    if (now > oct_28) {\n', '      base_multiplier = third_round_base_multiplier;\n', '    } else if (now > oct_24) {\n', '      base_multiplier = second_round_base_multiplier;\n', '    } else if (now > oct_17) {\n', '      base_multiplier = first_round_base_multiplier;\n', '    } else {\n', '      base_multiplier = 0;\n', '    }\n', '\n', '    uint256 multiplier;\n', '    if (msg.value >= 1 ether) multiplier = base_multiplier + 10;\n', '    else multiplier = base_multiplier;\n', '\n', '    uint256 amountRemaining = msg.value;\n', '\n', '    uint256 tokensAvailable = MAX_TOKENS_SOLD - tokensSold;\n', '    uint256 baseTokens = amountRemaining * 10**18 / PRICE;\n', '    // adjust for bonus multiplier\n', '    uint256 maxTokensByAmount = baseTokens + ((baseTokens * multiplier) / 100);\n', '\n', '    uint256 tokensToReceive = 0;\n', '    if (maxTokensByAmount > tokensAvailable) {\n', '      tokensToReceive = tokensAvailable;\n', '      amountRemaining -= (PRICE * tokensToReceive) / 10**18;\n', '    } else {\n', '      tokensToReceive = maxTokensByAmount;\n', '      amountRemaining = 0;\n', '    }\n', '    tokensSold += tokensToReceive;\n', '\n', '    assert(tokensToReceive > 0);\n', '    assert(bouncyCoinToken.transfer(msg.sender, tokensToReceive));\n', '\n', '    if (amountRemaining != 0) {\n', '      msg.sender.transfer(amountRemaining);\n', '    }\n', '\n', '    uint256 amountAccepted = msg.value - amountRemaining;\n', '    wallet.transfer(amountAccepted);\n', '    totalReceived += amountAccepted;\n', '    require(totalReceived <= HARD_CAP);\n', '\n', '    if (tokensSold == MAX_TOKENS_SOLD) {\n', '      finalize();\n', '    }\n', '\n', '    emit TokensSold(msg.sender, tokensToReceive, amountAccepted);\n', '  }\n', '\n', '  function start()\n', '    public\n', '    isOwner {\n', '    stage = Stages.Started;\n', '  }\n', '\n', '  function stop()\n', '    public\n', '    isOwner {\n', '    finalize();\n', '  }\n', '\n', '  function finalize()\n', '    private {\n', '    stage = Stages.Ended;\n', '  }\n', '\n', '  // In case of accidental ether lock on contract\n', '  function withdraw()\n', '    public\n', '    isOwner {\n', '    owner.transfer(address(this).balance);\n', '  }\n', '\n', '  // In case of accidental token transfer to this address, owner can transfer it elsewhere\n', '  function transferERC20Token(address _tokenAddress, address _to, uint256 _value)\n', '    public\n', '    isOwner {\n', '    ERC20 token = ERC20(_tokenAddress);\n', '    assert(token.transfer(_to, _value));\n', '  }\n', '\n', '}']