['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '//Abstract contract for Calling ERC20 contract\n', 'contract AbstractCon {\n', '    function allowance(address _owner, address _spender)  public pure returns (uint256 remaining);\n', '    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n', '    function decimals() public returns (uint8);\n', '    //function approve(address _spender, uint256 _value) public returns (bool); //test\n', '    //function transfer(address _to, uint256 _value) public returns (bool); //test\n', '    \n', '}\n', '\n', '//...\n', 'contract EXOTokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "EXO_TOKEN_SALE";\n', '\n', '    ///////////////////////\n', '    // DATA STRUCTURES  ///\n', '    ///////////////////////\n', '    enum StageName {Pause, PreSale, Sale, Ended, Refund}\n', '    struct StageProperties {\n', '        uint256 planEndDate;\n', '        address tokenKeeper;\n', '    }\n', '    \n', '    StageName public currentStage;\n', '    mapping(uint8   => StageProperties) public campaignStages;\n', '    mapping(address => uint256)         public deposited;\n', '    \n', '    uint256 public weiRaised=0; //All raised ether\n', '    uint256 public token_rate=1600; // decimal part of token per wei (0.3$ if 480$==1ETH)\n', '    uint256 public minimum_token_sell=1000; // !!! token count - without decimals!!!\n', '    uint256 public softCap=1042*10**18;//    500 000$ if 480$==1ETH\n', '    uint256 public hardCap=52083*10**18;//25 000 000$ if 480$==1ETH\n', '    address public wallet ; \n', '    address public ERC20address;\n', '\n', '    ///////////////////////\n', '    /// EVENTS     ///////\n', '    //////////////////////\n', '    event Income(address from, uint256 amount, uint64 timestamp);\n', '    event NewTokenRate(uint256 rate);\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 weivalue, uint256 tokens);\n', '    event FundsWithdraw(address indexed who, uint256 amount , uint64 timestamp);\n', '    event Refunded(address investor, uint256 depositedValue);\n', '    \n', '    //20180501 = 1525132800\n', '    //20180901 = 1535760000\n', '    //20181231 = 1546214400\n', '\n', '    function EXOTokenSale(address _wallet, address _preSaleTokenKeeper , address _SaleTokenKeeper) public {\n', '        //costructor\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        campaignStages[uint8(StageName.PreSale)] = StageProperties(1525132800, _preSaleTokenKeeper);\n', '        campaignStages[uint8(StageName.Sale)]    = StageProperties(1535760000, _SaleTokenKeeper);\n', '        currentStage = StageName.Pause;\n', '    }\n', '\n', '    //For disable transfers from incompatible wallet (Coinbase) \n', '    // or from a non ERC-20 compatible wallet\n', '    //it may be purposefully comment this fallback function and recieve\n', '    // Ether  direct through exchangeEtherOnTokens()\n', '    function() public payable {\n', '        exchangeEtherOnTokens(msg.sender);\n', '    }\n', '\n', '        // low level token purchase function\n', '    function exchangeEtherOnTokens(address beneficiary) public payable  {\n', '        emit Income(msg.sender, msg.value, uint64(now));\n', '        require(currentStage == StageName.PreSale || currentStage == StageName.Sale);\n', '        uint256 weiAmount = msg.value; //local\n', '        uint256 tokens = getTokenAmount(weiAmount);\n', '        require(beneficiary != address(0));\n', '        require(token_rate > 0);//implicit enabling sell\n', '        AbstractCon ac = AbstractCon(ERC20address);\n', '        require(tokens >= minimum_token_sell.mul(10 ** uint256(ac.decimals())));\n', '        require(ac.transferFrom(campaignStages[uint8(currentStage)].tokenKeeper, beneficiary, tokens));\n', '        checkCurrentStage();\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        deposited[beneficiary] = deposited[beneficiary].add(weiAmount);\n', '        emit TokenPurchase(msg.sender, beneficiary, msg.value, tokens);\n', '        if (weiRaised >= softCap) \n', '            withdrawETH();\n', '    }\n', '\n', '    //Stage time and conditions control\n', '    function checkCurrentStage() internal {\n', '        if  (campaignStages[uint8(currentStage)].planEndDate <= now) {\n', '            // Allow refund if softCap is not reached during PreSale stage\n', '            if  (currentStage == StageName.PreSale \n', '                 && (weiRaised + msg.value) < softCap\n', '                ) {\n', '                    currentStage = StageName.Refund;\n', '                    return;\n', '            }\n', '            currentStage = StageName.Pause;\n', '        }\n', '        //Finish tokensale campaign when hardCap will reached\n', '        if (currentStage == StageName.Sale \n', '            && (weiRaised + msg.value) >= hardCap\n', '            ) { \n', '               currentStage = StageName.Ended;\n', '        }\n', '    }\n', '\n', '    //for all discount logic\n', '    function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\n', '        return weiAmount.mul(token_rate);\n', '    }\n', '\n', '    function withdrawETH() internal {\n', '        emit FundsWithdraw(wallet, this.balance, uint64(now));\n', '        wallet.transfer(this.balance);// or weiAmount\n', '    }\n', '\n', '    //Set current stage of campaign manually\n', '    function setCurrentStage(StageName _name) external onlyOwner  {\n', '        currentStage = _name;\n', '    }\n', '\n', '    //Manually stages control\n', '    function setStageProperties(\n', '        StageName _name, \n', '        uint256 _planEndDate, \n', '        address _tokenKeeper \n', '        ) external onlyOwner {\n', '        campaignStages[uint8(_name)] = StageProperties(_planEndDate, _tokenKeeper);\n', '    } \n', '\n', '    //set   erc20 address for token process  with check of allowance \n', '    function setERC20address(address newERC20contract)  external onlyOwner {\n', '        require(address(newERC20contract) != 0);\n', '        AbstractCon ac = AbstractCon(newERC20contract);\n', '        require(ac.allowance(campaignStages[uint8(currentStage)].tokenKeeper, address(this))>0);\n', '        ERC20address = newERC20contract;\n', '    }\n', '    \n', '    //refund if not softCapped\n', '    function refund(address investor) external {\n', '        require(currentStage == StageName.Refund);\n', '        require(investor != address(0));\n', '        assert(msg.data.length >= 32 + 4);  //Short Address Attack\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        emit Refunded(investor, depositedValue);\n', '    }\n', '\n', '    function setTokenRate(uint256 newRate) external onlyOwner {\n', '        token_rate = newRate;\n', '        emit NewTokenRate(newRate);\n', '    }\n', '\n', '    function setSoftCap(uint256 _val) external onlyOwner {\n', '        softCap = _val;\n', '    }\n', '\n', '    function setHardCap(uint256 _val) external onlyOwner {\n', '        hardCap = _val;\n', '    }\n', '\n', '\n', '    function setMinimumTokenSell(uint256 newNumber) external onlyOwner {\n', '        minimum_token_sell = newNumber;\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        wallet = _wallet;\n', '    } \n', '\n', '    function destroy()  external onlyOwner {\n', '      if  (weiRaised >= softCap)\n', '          selfdestruct(owner);\n', '  } \n', '\n', '}              \n', '//***************************************************************\n', '  // Designed by by IBERGroup, email:<span class="__cf_email__" data-cfemail="ef828e979c869582808d86838aaf868d8a9dc1889d809a9f">[email&#160;protected]</span>; \n', '  //     Telegram: https://t.me/msmobile\n', '  //               https://t.me/alexamuek\n', '  // Code released under the MIT License(see git root).\n', '  //// SafeMath and Ownable part of this contract based on \n', '  //// https://github.com/OpenZeppelin/zeppelin-solidity\n', '  ////**************************************************************']
['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '//Abstract contract for Calling ERC20 contract\n', 'contract AbstractCon {\n', '    function allowance(address _owner, address _spender)  public pure returns (uint256 remaining);\n', '    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success);\n', '    function decimals() public returns (uint8);\n', '    //function approve(address _spender, uint256 _value) public returns (bool); //test\n', '    //function transfer(address _to, uint256 _value) public returns (bool); //test\n', '    \n', '}\n', '\n', '//...\n', 'contract EXOTokenSale is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "EXO_TOKEN_SALE";\n', '\n', '    ///////////////////////\n', '    // DATA STRUCTURES  ///\n', '    ///////////////////////\n', '    enum StageName {Pause, PreSale, Sale, Ended, Refund}\n', '    struct StageProperties {\n', '        uint256 planEndDate;\n', '        address tokenKeeper;\n', '    }\n', '    \n', '    StageName public currentStage;\n', '    mapping(uint8   => StageProperties) public campaignStages;\n', '    mapping(address => uint256)         public deposited;\n', '    \n', '    uint256 public weiRaised=0; //All raised ether\n', '    uint256 public token_rate=1600; // decimal part of token per wei (0.3$ if 480$==1ETH)\n', '    uint256 public minimum_token_sell=1000; // !!! token count - without decimals!!!\n', '    uint256 public softCap=1042*10**18;//    500 000$ if 480$==1ETH\n', '    uint256 public hardCap=52083*10**18;//25 000 000$ if 480$==1ETH\n', '    address public wallet ; \n', '    address public ERC20address;\n', '\n', '    ///////////////////////\n', '    /// EVENTS     ///////\n', '    //////////////////////\n', '    event Income(address from, uint256 amount, uint64 timestamp);\n', '    event NewTokenRate(uint256 rate);\n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 weivalue, uint256 tokens);\n', '    event FundsWithdraw(address indexed who, uint256 amount , uint64 timestamp);\n', '    event Refunded(address investor, uint256 depositedValue);\n', '    \n', '    //20180501 = 1525132800\n', '    //20180901 = 1535760000\n', '    //20181231 = 1546214400\n', '\n', '    function EXOTokenSale(address _wallet, address _preSaleTokenKeeper , address _SaleTokenKeeper) public {\n', '        //costructor\n', '        require(_wallet != address(0));\n', '        wallet = _wallet;\n', '        campaignStages[uint8(StageName.PreSale)] = StageProperties(1525132800, _preSaleTokenKeeper);\n', '        campaignStages[uint8(StageName.Sale)]    = StageProperties(1535760000, _SaleTokenKeeper);\n', '        currentStage = StageName.Pause;\n', '    }\n', '\n', '    //For disable transfers from incompatible wallet (Coinbase) \n', '    // or from a non ERC-20 compatible wallet\n', '    //it may be purposefully comment this fallback function and recieve\n', '    // Ether  direct through exchangeEtherOnTokens()\n', '    function() public payable {\n', '        exchangeEtherOnTokens(msg.sender);\n', '    }\n', '\n', '        // low level token purchase function\n', '    function exchangeEtherOnTokens(address beneficiary) public payable  {\n', '        emit Income(msg.sender, msg.value, uint64(now));\n', '        require(currentStage == StageName.PreSale || currentStage == StageName.Sale);\n', '        uint256 weiAmount = msg.value; //local\n', '        uint256 tokens = getTokenAmount(weiAmount);\n', '        require(beneficiary != address(0));\n', '        require(token_rate > 0);//implicit enabling sell\n', '        AbstractCon ac = AbstractCon(ERC20address);\n', '        require(tokens >= minimum_token_sell.mul(10 ** uint256(ac.decimals())));\n', '        require(ac.transferFrom(campaignStages[uint8(currentStage)].tokenKeeper, beneficiary, tokens));\n', '        checkCurrentStage();\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        deposited[beneficiary] = deposited[beneficiary].add(weiAmount);\n', '        emit TokenPurchase(msg.sender, beneficiary, msg.value, tokens);\n', '        if (weiRaised >= softCap) \n', '            withdrawETH();\n', '    }\n', '\n', '    //Stage time and conditions control\n', '    function checkCurrentStage() internal {\n', '        if  (campaignStages[uint8(currentStage)].planEndDate <= now) {\n', '            // Allow refund if softCap is not reached during PreSale stage\n', '            if  (currentStage == StageName.PreSale \n', '                 && (weiRaised + msg.value) < softCap\n', '                ) {\n', '                    currentStage = StageName.Refund;\n', '                    return;\n', '            }\n', '            currentStage = StageName.Pause;\n', '        }\n', '        //Finish tokensale campaign when hardCap will reached\n', '        if (currentStage == StageName.Sale \n', '            && (weiRaised + msg.value) >= hardCap\n', '            ) { \n', '               currentStage = StageName.Ended;\n', '        }\n', '    }\n', '\n', '    //for all discount logic\n', '    function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\n', '        return weiAmount.mul(token_rate);\n', '    }\n', '\n', '    function withdrawETH() internal {\n', '        emit FundsWithdraw(wallet, this.balance, uint64(now));\n', '        wallet.transfer(this.balance);// or weiAmount\n', '    }\n', '\n', '    //Set current stage of campaign manually\n', '    function setCurrentStage(StageName _name) external onlyOwner  {\n', '        currentStage = _name;\n', '    }\n', '\n', '    //Manually stages control\n', '    function setStageProperties(\n', '        StageName _name, \n', '        uint256 _planEndDate, \n', '        address _tokenKeeper \n', '        ) external onlyOwner {\n', '        campaignStages[uint8(_name)] = StageProperties(_planEndDate, _tokenKeeper);\n', '    } \n', '\n', '    //set   erc20 address for token process  with check of allowance \n', '    function setERC20address(address newERC20contract)  external onlyOwner {\n', '        require(address(newERC20contract) != 0);\n', '        AbstractCon ac = AbstractCon(newERC20contract);\n', '        require(ac.allowance(campaignStages[uint8(currentStage)].tokenKeeper, address(this))>0);\n', '        ERC20address = newERC20contract;\n', '    }\n', '    \n', '    //refund if not softCapped\n', '    function refund(address investor) external {\n', '        require(currentStage == StageName.Refund);\n', '        require(investor != address(0));\n', '        assert(msg.data.length >= 32 + 4);  //Short Address Attack\n', '        uint256 depositedValue = deposited[investor];\n', '        deposited[investor] = 0;\n', '        investor.transfer(depositedValue);\n', '        emit Refunded(investor, depositedValue);\n', '    }\n', '\n', '    function setTokenRate(uint256 newRate) external onlyOwner {\n', '        token_rate = newRate;\n', '        emit NewTokenRate(newRate);\n', '    }\n', '\n', '    function setSoftCap(uint256 _val) external onlyOwner {\n', '        softCap = _val;\n', '    }\n', '\n', '    function setHardCap(uint256 _val) external onlyOwner {\n', '        hardCap = _val;\n', '    }\n', '\n', '\n', '    function setMinimumTokenSell(uint256 newNumber) external onlyOwner {\n', '        minimum_token_sell = newNumber;\n', '    }\n', '\n', '    function setWallet(address _wallet) external onlyOwner {\n', '        wallet = _wallet;\n', '    } \n', '\n', '    function destroy()  external onlyOwner {\n', '      if  (weiRaised >= softCap)\n', '          selfdestruct(owner);\n', '  } \n', '\n', '}              \n', '//***************************************************************\n', '  // Designed by by IBERGroup, email:maxsizmobile@iber.group; \n', '  //     Telegram: https://t.me/msmobile\n', '  //               https://t.me/alexamuek\n', '  // Code released under the MIT License(see git root).\n', '  //// SafeMath and Ownable part of this contract based on \n', '  //// https://github.com/OpenZeppelin/zeppelin-solidity\n', '  ////**************************************************************']
