['pragma solidity ^0.4.20;\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    mapping(address => uint256) balances;\n', '}\n', 'contract AthTokenInterface is ERC20{\n', '\n', '  function delivery( address _to, uint256 _amount ) public returns( bool );\n', '  function afterIco( uint256 _redemptionPrice ) public  returns( bool );\n', '  function currentBalance() public returns( uint256 );\n', '  \n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Crowdsale is Ownable{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    bool _initialize = false;\n', '    \n', '    AthTokenInterface token;\n', '\n', '    enum CrowdsaleStates { Disabled, Presale, ICO1, ICO2, ICO3, ICO4, Finished }\n', '    \n', '    uint256 public presale                  = 750000  ether;\n', '    uint256 public bounty                   = 500000  ether;\n', '    uint256 public constant price           = 0.00024 ether;\n', '    uint256 public constant threshold       = 50000 ether;\n', '    uint256 public constant min             = price * 500;\n', '    uint256 public constant hardcap         = 1000 ether; \n', '    uint256 public          totalEth        = 0;\n', '    \n', '    uint256 public constant affiliatThreshold1 = 1 * min;\n', '    uint256 public constant affiliatThreshold2 = 10 * min;\n', '    uint256 public constant affiliatThreshold3 = 50 * min;\n', '    uint256 public constant affiliatThreshold4 = 100 * min;\n', '    \n', '    uint256 public icoTimeStart          = 0;\n', '    uint256 public ICO1Period            = 1 days;\n', '    uint256 public ICO2Period            = 7 days + ICO1Period;\n', '    uint256 public ICO3Period            = 10 days + ICO2Period;\n', '    uint256 public ICO4Period            = 12 days + ICO3Period;\n', '    \n', '    \n', '    address[] owners;\n', '    \n', '    \n', '    CrowdsaleStates public CrowdsaleState = CrowdsaleStates.Disabled;\n', '    \n', '    modifier icoActive {\n', '        require( \n', '               getCrowdsaleState() == CrowdsaleStates.Presale \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO1 \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO2 \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO3\n', '            || getCrowdsaleState() == CrowdsaleStates.ICO4\n', '            );\n', '        _;\n', '    }\n', '    \n', '    modifier Finished {\n', '        require( getCrowdsaleState() == CrowdsaleStates.Finished );\n', '        _;\n', '    }\n', '    modifier notFinished {\n', '        require( getCrowdsaleState() != CrowdsaleStates.Finished );\n', '        _;\n', '    }\n', '    \n', '    modifier Initialized {\n', '        require( _initialize );\n', '        _;\n', '    }\n', '    \n', '    \n', '    \n', '    event NewInvestor( address );\n', '    event NewReferrer( address );\n', '    event Referral( address, address, uint256, uint256 );\n', '    event Bounty( address, uint256 );\n', '    event Swap( address, address, uint256 );\n', '    event NewSwapToken( address );\n', '    event Delivery( address, uint256 );\n', '    \n', '    \n', '    \n', '    mapping( address => uint256 ) investorsTotalBalances;\n', '    mapping( address => uint256 ) investorsStock;\n', '    mapping( address => bool ) investorsCheck;\n', '    address[] public investors;\n', '    \n', '    \n', '    \n', '    mapping( address => bool ) referrers;\n', '    address[] public referrersList;\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    function initialize( address _a, address[] _owners ) public onlyOwner returns( bool )\n', '    {\n', '        require( _a != address(0) && _owners.length == 2 && _owners[0] != address(0) && _owners[1] != address(0) && !_initialize );\n', '        \n', '        \n', '        token = AthTokenInterface( _a );\n', '        owners = _owners;\n', '        _initialize = true;\n', '    }\n', '\n', '    \n', '    function getOwners(uint8 _i) public constant returns( address )\n', '    {\n', '        return owners[_i];\n', '    }\n', '    \n', '   \n', '    \n', '    function referrersCount() public constant returns( uint256 )\n', '    {\n', '        return referrersList.length;\n', '    }\n', '    \n', '    \n', '    \n', '    function regReferrer( address _a ) public onlyOwner Initialized returns( bool )\n', '    {\n', '        if( referrers[_a] != true ) {\n', '            \n', '            referrers[_a] = true;\n', '            referrersList.push( _a );\n', '            \n', '            NewReferrer( _a );\n', '            \n', '        }\n', '    }\n', '    function regReferrers( address[] _a ) public onlyOwner Initialized returns( bool )\n', '    {\n', '        for( uint256 i = 0; i <= _a.length - 1; i++ ){\n', '            \n', '            if( referrers[_a[i]] != true ) {\n', '            \n', '                referrers[_a[i]] = true;\n', '                referrersList.push( _a[i] );\n', '                \n', '                NewReferrer( _a[i] );\n', '                \n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    \n', '    function referralBonusCalculate( uint256 _amount, uint256 _amountTokens ) public pure returns( uint256 )\n', '    {\n', '        uint256 amount = 0;\n', '        \n', '        if( _amount < affiliatThreshold2  )  amount =  _amountTokens.mul( 7 ).div( 100 );\n', '        if( _amount < affiliatThreshold3  )  amount =  _amountTokens.mul( 10 ).div( 100 );\n', '        if( _amount < affiliatThreshold4  )  amount =  _amountTokens.mul( 15 ).div( 100 );\n', '        if( _amount >= affiliatThreshold4  ) amount =  _amountTokens.mul( 20 ).div( 100 );\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    function referrerBonusCalculate( uint256 _amount ) public pure returns( uint256 )\n', '    {\n', '        uint256 amount = 0;\n', '        \n', '        if( _amount < affiliatThreshold2  )  amount =  _amount.mul( 3 ).div( 100 );\n', '        if( _amount < affiliatThreshold3  )  amount =  _amount.mul( 7 ).div( 100 );\n', '        if( _amount < affiliatThreshold4  )  amount =  _amount.mul( 10 ).div( 100 );\n', '        if( _amount >= affiliatThreshold4  ) amount =  _amount.mul( 15 ).div( 100 );\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    \n', '    function redemptionPriceCalculate( uint256 _ath ) public pure returns( uint256 )\n', '    {\n', '        if( _ath >= 3333333 ether ) return price.mul( 150 ).div( 100 );\n', '        if( _ath >= 2917777 ether ) return price.mul( 145 ).div( 100 );\n', '        if( _ath >= 2500000 ether ) return price.mul( 140 ).div( 100 );\n', '        if( _ath >= 2083333 ether ) return price.mul( 135 ).div( 100 );\n', '        if( _ath >= 1700000 ether ) return price.mul( 130 ).div( 100 );\n', '        if( _ath >= 1250000 ether ) return price.mul( 125 ).div( 100 );  \n', '        \n', '        return price;\n', '    }\n', '    \n', '   \n', '    function() public payable\n', '    {\n', '        buy( address(0) );\n', '    }\n', '    \n', '\n', '    \n', '    function buy( address _referrer ) public payable icoActive Initialized\n', '    {\n', '        \n', '        \n', '        \n', '      require( msg.value >= min );\n', '      \n', '\n', '      uint256 _amount = crowdsaleBonus( msg.value.div( price ) * 1 ether );\n', '      uint256 toReferrer = 0;\n', '      \n', '      if( referrers[_referrer] ){\n', '          \n', '        toReferrer = referrerBonusCalculate( msg.value );\n', '        _referrer.transfer( toReferrer );\n', '        _amount = _amount.add( referralBonusCalculate( msg.value, _amount ) );\n', '        \n', '        Referral( _referrer, msg.sender, msg.value, _amount );\n', '        \n', '      }\n', '      \n', '      \n', '      \n', '       \n', '       \n', '      token.delivery( msg.sender, _amount );\n', '      totalEth = totalEth.add( msg.value );\n', '      \n', '      Delivery( msg.sender, _amount );\n', '      \n', '       \n', '        \n', '      if( getCrowdsaleState() == CrowdsaleStates.Presale ) {\n', '          \n', '          presale = presale.sub( _amount );\n', '          \n', '          for( uint256 i = 0; i <= owners.length - 1; i++ ){\n', '              \n', '            owners[i].transfer( ( msg.value.sub( toReferrer ) ).div( owners.length ) );\n', '            \n', '          }\n', '      \n', '      }\n', '      \n', '      \n', '      investorsTotalBalances[msg.sender]  = investorsTotalBalances[msg.sender].add( _amount );\n', '       \n', '      if( investorsTotalBalances[msg.sender] >= threshold && investorsCheck[msg.sender] == false ){\n', '          investors.push( msg.sender );\n', '          investorsCheck[msg.sender] = true;\n', '          \n', '          NewInvestor( msg.sender );\n', '      }\n', '       \n', '       \n', '      \n', '       \n', '    }\n', '    \n', '\n', '    \n', '\n', '    \n', '    function getCrowdsaleState() public constant returns( CrowdsaleStates )\n', '    {\n', '        if( CrowdsaleState == CrowdsaleStates.Disabled ) return CrowdsaleStates.Disabled;\n', '        if( CrowdsaleState == CrowdsaleStates.Finished ) return CrowdsaleStates.Finished;\n', '        \n', '        if( CrowdsaleState == CrowdsaleStates.Presale ){\n', '            if( presale > 0 ) \n', '                return CrowdsaleStates.Presale;\n', '            else\n', '                return CrowdsaleStates.Disabled;\n', '        }\n', '        \n', '        if( CrowdsaleState == CrowdsaleStates.ICO1 ){\n', '            \n', '            if( token.currentBalance() <= 0 || totalEth >= hardcap ) return CrowdsaleStates.Finished; \n', '            \n', '            if( now.sub( icoTimeStart ) <= ICO1Period)  return CrowdsaleStates.ICO1;\n', '            if( now.sub( icoTimeStart ) <= ICO2Period ) return CrowdsaleStates.ICO2;\n', '            if( now.sub( icoTimeStart ) <= ICO3Period ) return CrowdsaleStates.ICO3;\n', '            if( now.sub( icoTimeStart ) <= ICO4Period ) return CrowdsaleStates.ICO4;\n', '            if( now.sub( icoTimeStart ) >  ICO4Period ) return CrowdsaleStates.Finished;\n', '            \n', '        }\n', '    }\n', '    \n', '    \n', '    \n', '    function crowdsaleBonus( uint256 _amount ) internal constant  returns ( uint256 )\n', '    {\n', '        uint256 bonus = 0;\n', '        \n', '        if( getCrowdsaleState() == CrowdsaleStates.Presale ){\n', '            bonus = _amount.mul( 50 ).div( 100 );\n', '        }\n', '        \n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO1 ){\n', '            bonus = _amount.mul( 35 ).div( 100 );\n', '        }\n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO2 ){\n', '            bonus = _amount.mul( 25 ).div( 100 );\n', '        }\n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO3 ){\n', '            bonus = _amount.mul( 15 ).div( 100 );\n', '        }\n', '        \n', '        return _amount.add( bonus );\n', '        \n', '    }\n', '    \n', '    \n', '    function startPresale() public onlyOwner notFinished Initialized returns ( bool )\n', '    {\n', '        CrowdsaleState = CrowdsaleStates.Presale;\n', '        return true;\n', '    }\n', '    \n', '    function startIco() public onlyOwner notFinished Initialized returns ( bool )\n', '    {\n', '        CrowdsaleState = CrowdsaleStates.ICO1;\n', '        icoTimeStart = now;\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function completeIcoPart1() public onlyOwner Finished Initialized returns( bool )\n', '    {\n', '        //stop ico\n', '        CrowdsaleState = CrowdsaleStates.Finished;\n', '        \n', '        uint256 sales = token.totalSupply() - token.currentBalance();\n', '        \n', '        \n', '        uint256 i;\n', '        \n', '        //burn\n', '        if( totalEth >= hardcap ) {\n', '            \n', '            for( i = 0; i <= owners.length - 1; i++ ){\n', '                token.delivery( owners[i], bounty.div( owners.length ) );\n', '            }\n', '            \n', '        } else {\n', '            \n', '            uint256 tmp = sales.mul( 20 ).div( 100 ).add( bounty );\n', '            for( i = 0; i <= owners.length - 1; i++ ){\n', '                token.delivery( owners[i], tmp.div( owners.length ) );\n', '            }  \n', '            \n', '        }\n', '        \n', '        uint b = address(this).balance;\n', '         for( i = 0; i <= owners.length - 1; i++ ){\n', '            owners[i].transfer(  b.div( owners.length ) );\n', '        }\n', '        \n', '        token.afterIco(  redemptionPriceCalculate( sales )  );\n', '    }\n', '    \n', '    function completeIcoPart2() public onlyOwner Finished Initialized returns( bool )\n', '    {\n', '        uint256 sum = 0;\n', '        uint256 i = 0;\n', '        for( i = 0; i <= investors.length - 1; i++ ) {\n', '            sum = sum.add( investorsTotalBalances[ investors[i] ] );\n', '        }\n', '        for( i = 0; i <= investors.length - 1; i++ ) {\n', '            investorsStock[ investors[i] ] = investorsTotalBalances[ investors[i] ].mul( 100 ).div( sum );\n', '        }\n', '    }\n', '    \n', '    \n', '    function investorsCount() public constant returns( uint256 )\n', '    {\n', '        return investors.length ;\n', '    }\n', '    \n', '    function investorsAddress( uint256 _i ) public constant returns( address )\n', '    {\n', '        return investors[_i] ;\n', '    }\n', '    \n', '    function investorsInfo( address _a ) public constant returns( uint256, uint256 )\n', '    {\n', '        return ( investorsTotalBalances[_a], investorsStock[_a] );\n', '    }\n', '    \n', '    function investorsStockInfo( address _a)  public constant returns(uint256)\n', '    {\n', '        return  investorsStock[_a];\n', '    }\n', '    \n', '    \n', '\n', '    \n', '    function bountyTransfer( address _to, uint256 amount) public onlyOwner Initialized returns( bool )\n', '    {\n', '        \n', '        \n', '        require( bounty >= amount && token.currentBalance() >= amount );\n', '        \n', '        \n', '        token.delivery( _to, amount );\n', '        bounty = bounty.sub( amount );\n', '        \n', '        Delivery( _to, amount );\n', '        Bounty( _to, amount );\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    bool public swapActivity = true;\n', '    address[] tokenList;\n', '    mapping( address => uint256 ) tokenRateAth;\n', '    mapping( address => uint256 ) tokenRateToken;\n', '    mapping( address => uint256 ) tokenLimit;\n', '    mapping( address => uint256 ) tokenMinAmount;\n', '    mapping( address => bool ) tokenActivity;\n', '    mapping( address => bool ) tokenFirst;\n', '    mapping ( address => uint256 ) tokenSwapped;\n', '    \n', '    \n', '    function swapActivityHandler() public onlyOwner\n', '    {\n', '        swapActivity = !swapActivity;\n', '    }\n', '    \n', '    \n', '    function setSwapToken( address _a, uint256 _rateAth, uint256 _rateToken, uint256 _limit, uint256 _minAmount,  bool _activity ) public onlyOwner returns( bool )\n', '    {\n', '       if( tokenFirst[_a] == false ) {\n', '           tokenFirst[_a] = true;\n', '           \n', '           NewSwapToken( _a );\n', '       }\n', '       \n', '       tokenRateAth[_a]     = _rateAth;\n', '       tokenRateToken[_a]   = _rateToken;\n', '       tokenLimit[_a]       = _limit;\n', '       tokenMinAmount[_a]   = _minAmount;\n', '       tokenActivity[_a]    = _activity;\n', '    }\n', '    \n', '\n', '    function swapTokenInfo( address _a) public constant returns( uint256, uint256, uint256, uint256,  bool )\n', '    {\n', '        return ( tokenRateAth[_a], tokenRateToken[_a], tokenLimit[_a], tokenMinAmount[_a], tokenActivity[_a] );\n', '    }\n', '    \n', '    function swap( address _a, uint256 _amount ) public returns( bool )\n', '    {\n', '        require( swapActivity && tokenActivity[_a] && ( _amount >= tokenMinAmount[_a] ) );\n', '        \n', '        uint256 ath = tokenRateAth[_a].mul( _amount ).div( tokenRateToken[_a] );\n', '        tokenSwapped[_a] = tokenSwapped[_a].add( ath );\n', '        \n', '        require( ath > 0 && bounty >= ath && tokenSwapped[_a] <= tokenLimit[_a] );\n', '        \n', '        ERC20 ercToken = ERC20( _a );\n', '        ercToken.transferFrom( msg.sender, address(this), _amount );\n', '        \n', '        for( uint256 i = 0; i <= owners.length - 1; i++ )\n', '          ercToken.transfer( owners[i], _amount.div( owners.length ) );\n', '          \n', '        token.delivery( msg.sender, ath );\n', '        bounty = bounty.sub( ath );\n', '        \n', '        Delivery( msg.sender, ath );\n', '        Swap( msg.sender, _a, ath );\n', '        \n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.20;\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    mapping(address => uint256) balances;\n', '}\n', 'contract AthTokenInterface is ERC20{\n', '\n', '  function delivery( address _to, uint256 _amount ) public returns( bool );\n', '  function afterIco( uint256 _redemptionPrice ) public  returns( bool );\n', '  function currentBalance() public returns( uint256 );\n', '  \n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Crowdsale is Ownable{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    bool _initialize = false;\n', '    \n', '    AthTokenInterface token;\n', '\n', '    enum CrowdsaleStates { Disabled, Presale, ICO1, ICO2, ICO3, ICO4, Finished }\n', '    \n', '    uint256 public presale                  = 750000  ether;\n', '    uint256 public bounty                   = 500000  ether;\n', '    uint256 public constant price           = 0.00024 ether;\n', '    uint256 public constant threshold       = 50000 ether;\n', '    uint256 public constant min             = price * 500;\n', '    uint256 public constant hardcap         = 1000 ether; \n', '    uint256 public          totalEth        = 0;\n', '    \n', '    uint256 public constant affiliatThreshold1 = 1 * min;\n', '    uint256 public constant affiliatThreshold2 = 10 * min;\n', '    uint256 public constant affiliatThreshold3 = 50 * min;\n', '    uint256 public constant affiliatThreshold4 = 100 * min;\n', '    \n', '    uint256 public icoTimeStart          = 0;\n', '    uint256 public ICO1Period            = 1 days;\n', '    uint256 public ICO2Period            = 7 days + ICO1Period;\n', '    uint256 public ICO3Period            = 10 days + ICO2Period;\n', '    uint256 public ICO4Period            = 12 days + ICO3Period;\n', '    \n', '    \n', '    address[] owners;\n', '    \n', '    \n', '    CrowdsaleStates public CrowdsaleState = CrowdsaleStates.Disabled;\n', '    \n', '    modifier icoActive {\n', '        require( \n', '               getCrowdsaleState() == CrowdsaleStates.Presale \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO1 \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO2 \n', '            || getCrowdsaleState() == CrowdsaleStates.ICO3\n', '            || getCrowdsaleState() == CrowdsaleStates.ICO4\n', '            );\n', '        _;\n', '    }\n', '    \n', '    modifier Finished {\n', '        require( getCrowdsaleState() == CrowdsaleStates.Finished );\n', '        _;\n', '    }\n', '    modifier notFinished {\n', '        require( getCrowdsaleState() != CrowdsaleStates.Finished );\n', '        _;\n', '    }\n', '    \n', '    modifier Initialized {\n', '        require( _initialize );\n', '        _;\n', '    }\n', '    \n', '    \n', '    \n', '    event NewInvestor( address );\n', '    event NewReferrer( address );\n', '    event Referral( address, address, uint256, uint256 );\n', '    event Bounty( address, uint256 );\n', '    event Swap( address, address, uint256 );\n', '    event NewSwapToken( address );\n', '    event Delivery( address, uint256 );\n', '    \n', '    \n', '    \n', '    mapping( address => uint256 ) investorsTotalBalances;\n', '    mapping( address => uint256 ) investorsStock;\n', '    mapping( address => bool ) investorsCheck;\n', '    address[] public investors;\n', '    \n', '    \n', '    \n', '    mapping( address => bool ) referrers;\n', '    address[] public referrersList;\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    function initialize( address _a, address[] _owners ) public onlyOwner returns( bool )\n', '    {\n', '        require( _a != address(0) && _owners.length == 2 && _owners[0] != address(0) && _owners[1] != address(0) && !_initialize );\n', '        \n', '        \n', '        token = AthTokenInterface( _a );\n', '        owners = _owners;\n', '        _initialize = true;\n', '    }\n', '\n', '    \n', '    function getOwners(uint8 _i) public constant returns( address )\n', '    {\n', '        return owners[_i];\n', '    }\n', '    \n', '   \n', '    \n', '    function referrersCount() public constant returns( uint256 )\n', '    {\n', '        return referrersList.length;\n', '    }\n', '    \n', '    \n', '    \n', '    function regReferrer( address _a ) public onlyOwner Initialized returns( bool )\n', '    {\n', '        if( referrers[_a] != true ) {\n', '            \n', '            referrers[_a] = true;\n', '            referrersList.push( _a );\n', '            \n', '            NewReferrer( _a );\n', '            \n', '        }\n', '    }\n', '    function regReferrers( address[] _a ) public onlyOwner Initialized returns( bool )\n', '    {\n', '        for( uint256 i = 0; i <= _a.length - 1; i++ ){\n', '            \n', '            if( referrers[_a[i]] != true ) {\n', '            \n', '                referrers[_a[i]] = true;\n', '                referrersList.push( _a[i] );\n', '                \n', '                NewReferrer( _a[i] );\n', '                \n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '    \n', '    function referralBonusCalculate( uint256 _amount, uint256 _amountTokens ) public pure returns( uint256 )\n', '    {\n', '        uint256 amount = 0;\n', '        \n', '        if( _amount < affiliatThreshold2  )  amount =  _amountTokens.mul( 7 ).div( 100 );\n', '        if( _amount < affiliatThreshold3  )  amount =  _amountTokens.mul( 10 ).div( 100 );\n', '        if( _amount < affiliatThreshold4  )  amount =  _amountTokens.mul( 15 ).div( 100 );\n', '        if( _amount >= affiliatThreshold4  ) amount =  _amountTokens.mul( 20 ).div( 100 );\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    function referrerBonusCalculate( uint256 _amount ) public pure returns( uint256 )\n', '    {\n', '        uint256 amount = 0;\n', '        \n', '        if( _amount < affiliatThreshold2  )  amount =  _amount.mul( 3 ).div( 100 );\n', '        if( _amount < affiliatThreshold3  )  amount =  _amount.mul( 7 ).div( 100 );\n', '        if( _amount < affiliatThreshold4  )  amount =  _amount.mul( 10 ).div( 100 );\n', '        if( _amount >= affiliatThreshold4  ) amount =  _amount.mul( 15 ).div( 100 );\n', '        \n', '        return amount;\n', '    }\n', '    \n', '    \n', '    function redemptionPriceCalculate( uint256 _ath ) public pure returns( uint256 )\n', '    {\n', '        if( _ath >= 3333333 ether ) return price.mul( 150 ).div( 100 );\n', '        if( _ath >= 2917777 ether ) return price.mul( 145 ).div( 100 );\n', '        if( _ath >= 2500000 ether ) return price.mul( 140 ).div( 100 );\n', '        if( _ath >= 2083333 ether ) return price.mul( 135 ).div( 100 );\n', '        if( _ath >= 1700000 ether ) return price.mul( 130 ).div( 100 );\n', '        if( _ath >= 1250000 ether ) return price.mul( 125 ).div( 100 );  \n', '        \n', '        return price;\n', '    }\n', '    \n', '   \n', '    function() public payable\n', '    {\n', '        buy( address(0) );\n', '    }\n', '    \n', '\n', '    \n', '    function buy( address _referrer ) public payable icoActive Initialized\n', '    {\n', '        \n', '        \n', '        \n', '      require( msg.value >= min );\n', '      \n', '\n', '      uint256 _amount = crowdsaleBonus( msg.value.div( price ) * 1 ether );\n', '      uint256 toReferrer = 0;\n', '      \n', '      if( referrers[_referrer] ){\n', '          \n', '        toReferrer = referrerBonusCalculate( msg.value );\n', '        _referrer.transfer( toReferrer );\n', '        _amount = _amount.add( referralBonusCalculate( msg.value, _amount ) );\n', '        \n', '        Referral( _referrer, msg.sender, msg.value, _amount );\n', '        \n', '      }\n', '      \n', '      \n', '      \n', '       \n', '       \n', '      token.delivery( msg.sender, _amount );\n', '      totalEth = totalEth.add( msg.value );\n', '      \n', '      Delivery( msg.sender, _amount );\n', '      \n', '       \n', '        \n', '      if( getCrowdsaleState() == CrowdsaleStates.Presale ) {\n', '          \n', '          presale = presale.sub( _amount );\n', '          \n', '          for( uint256 i = 0; i <= owners.length - 1; i++ ){\n', '              \n', '            owners[i].transfer( ( msg.value.sub( toReferrer ) ).div( owners.length ) );\n', '            \n', '          }\n', '      \n', '      }\n', '      \n', '      \n', '      investorsTotalBalances[msg.sender]  = investorsTotalBalances[msg.sender].add( _amount );\n', '       \n', '      if( investorsTotalBalances[msg.sender] >= threshold && investorsCheck[msg.sender] == false ){\n', '          investors.push( msg.sender );\n', '          investorsCheck[msg.sender] = true;\n', '          \n', '          NewInvestor( msg.sender );\n', '      }\n', '       \n', '       \n', '      \n', '       \n', '    }\n', '    \n', '\n', '    \n', '\n', '    \n', '    function getCrowdsaleState() public constant returns( CrowdsaleStates )\n', '    {\n', '        if( CrowdsaleState == CrowdsaleStates.Disabled ) return CrowdsaleStates.Disabled;\n', '        if( CrowdsaleState == CrowdsaleStates.Finished ) return CrowdsaleStates.Finished;\n', '        \n', '        if( CrowdsaleState == CrowdsaleStates.Presale ){\n', '            if( presale > 0 ) \n', '                return CrowdsaleStates.Presale;\n', '            else\n', '                return CrowdsaleStates.Disabled;\n', '        }\n', '        \n', '        if( CrowdsaleState == CrowdsaleStates.ICO1 ){\n', '            \n', '            if( token.currentBalance() <= 0 || totalEth >= hardcap ) return CrowdsaleStates.Finished; \n', '            \n', '            if( now.sub( icoTimeStart ) <= ICO1Period)  return CrowdsaleStates.ICO1;\n', '            if( now.sub( icoTimeStart ) <= ICO2Period ) return CrowdsaleStates.ICO2;\n', '            if( now.sub( icoTimeStart ) <= ICO3Period ) return CrowdsaleStates.ICO3;\n', '            if( now.sub( icoTimeStart ) <= ICO4Period ) return CrowdsaleStates.ICO4;\n', '            if( now.sub( icoTimeStart ) >  ICO4Period ) return CrowdsaleStates.Finished;\n', '            \n', '        }\n', '    }\n', '    \n', '    \n', '    \n', '    function crowdsaleBonus( uint256 _amount ) internal constant  returns ( uint256 )\n', '    {\n', '        uint256 bonus = 0;\n', '        \n', '        if( getCrowdsaleState() == CrowdsaleStates.Presale ){\n', '            bonus = _amount.mul( 50 ).div( 100 );\n', '        }\n', '        \n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO1 ){\n', '            bonus = _amount.mul( 35 ).div( 100 );\n', '        }\n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO2 ){\n', '            bonus = _amount.mul( 25 ).div( 100 );\n', '        }\n', '        if( getCrowdsaleState() == CrowdsaleStates.ICO3 ){\n', '            bonus = _amount.mul( 15 ).div( 100 );\n', '        }\n', '        \n', '        return _amount.add( bonus );\n', '        \n', '    }\n', '    \n', '    \n', '    function startPresale() public onlyOwner notFinished Initialized returns ( bool )\n', '    {\n', '        CrowdsaleState = CrowdsaleStates.Presale;\n', '        return true;\n', '    }\n', '    \n', '    function startIco() public onlyOwner notFinished Initialized returns ( bool )\n', '    {\n', '        CrowdsaleState = CrowdsaleStates.ICO1;\n', '        icoTimeStart = now;\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function completeIcoPart1() public onlyOwner Finished Initialized returns( bool )\n', '    {\n', '        //stop ico\n', '        CrowdsaleState = CrowdsaleStates.Finished;\n', '        \n', '        uint256 sales = token.totalSupply() - token.currentBalance();\n', '        \n', '        \n', '        uint256 i;\n', '        \n', '        //burn\n', '        if( totalEth >= hardcap ) {\n', '            \n', '            for( i = 0; i <= owners.length - 1; i++ ){\n', '                token.delivery( owners[i], bounty.div( owners.length ) );\n', '            }\n', '            \n', '        } else {\n', '            \n', '            uint256 tmp = sales.mul( 20 ).div( 100 ).add( bounty );\n', '            for( i = 0; i <= owners.length - 1; i++ ){\n', '                token.delivery( owners[i], tmp.div( owners.length ) );\n', '            }  \n', '            \n', '        }\n', '        \n', '        uint b = address(this).balance;\n', '         for( i = 0; i <= owners.length - 1; i++ ){\n', '            owners[i].transfer(  b.div( owners.length ) );\n', '        }\n', '        \n', '        token.afterIco(  redemptionPriceCalculate( sales )  );\n', '    }\n', '    \n', '    function completeIcoPart2() public onlyOwner Finished Initialized returns( bool )\n', '    {\n', '        uint256 sum = 0;\n', '        uint256 i = 0;\n', '        for( i = 0; i <= investors.length - 1; i++ ) {\n', '            sum = sum.add( investorsTotalBalances[ investors[i] ] );\n', '        }\n', '        for( i = 0; i <= investors.length - 1; i++ ) {\n', '            investorsStock[ investors[i] ] = investorsTotalBalances[ investors[i] ].mul( 100 ).div( sum );\n', '        }\n', '    }\n', '    \n', '    \n', '    function investorsCount() public constant returns( uint256 )\n', '    {\n', '        return investors.length ;\n', '    }\n', '    \n', '    function investorsAddress( uint256 _i ) public constant returns( address )\n', '    {\n', '        return investors[_i] ;\n', '    }\n', '    \n', '    function investorsInfo( address _a ) public constant returns( uint256, uint256 )\n', '    {\n', '        return ( investorsTotalBalances[_a], investorsStock[_a] );\n', '    }\n', '    \n', '    function investorsStockInfo( address _a)  public constant returns(uint256)\n', '    {\n', '        return  investorsStock[_a];\n', '    }\n', '    \n', '    \n', '\n', '    \n', '    function bountyTransfer( address _to, uint256 amount) public onlyOwner Initialized returns( bool )\n', '    {\n', '        \n', '        \n', '        require( bounty >= amount && token.currentBalance() >= amount );\n', '        \n', '        \n', '        token.delivery( _to, amount );\n', '        bounty = bounty.sub( amount );\n', '        \n', '        Delivery( _to, amount );\n', '        Bounty( _to, amount );\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    bool public swapActivity = true;\n', '    address[] tokenList;\n', '    mapping( address => uint256 ) tokenRateAth;\n', '    mapping( address => uint256 ) tokenRateToken;\n', '    mapping( address => uint256 ) tokenLimit;\n', '    mapping( address => uint256 ) tokenMinAmount;\n', '    mapping( address => bool ) tokenActivity;\n', '    mapping( address => bool ) tokenFirst;\n', '    mapping ( address => uint256 ) tokenSwapped;\n', '    \n', '    \n', '    function swapActivityHandler() public onlyOwner\n', '    {\n', '        swapActivity = !swapActivity;\n', '    }\n', '    \n', '    \n', '    function setSwapToken( address _a, uint256 _rateAth, uint256 _rateToken, uint256 _limit, uint256 _minAmount,  bool _activity ) public onlyOwner returns( bool )\n', '    {\n', '       if( tokenFirst[_a] == false ) {\n', '           tokenFirst[_a] = true;\n', '           \n', '           NewSwapToken( _a );\n', '       }\n', '       \n', '       tokenRateAth[_a]     = _rateAth;\n', '       tokenRateToken[_a]   = _rateToken;\n', '       tokenLimit[_a]       = _limit;\n', '       tokenMinAmount[_a]   = _minAmount;\n', '       tokenActivity[_a]    = _activity;\n', '    }\n', '    \n', '\n', '    function swapTokenInfo( address _a) public constant returns( uint256, uint256, uint256, uint256,  bool )\n', '    {\n', '        return ( tokenRateAth[_a], tokenRateToken[_a], tokenLimit[_a], tokenMinAmount[_a], tokenActivity[_a] );\n', '    }\n', '    \n', '    function swap( address _a, uint256 _amount ) public returns( bool )\n', '    {\n', '        require( swapActivity && tokenActivity[_a] && ( _amount >= tokenMinAmount[_a] ) );\n', '        \n', '        uint256 ath = tokenRateAth[_a].mul( _amount ).div( tokenRateToken[_a] );\n', '        tokenSwapped[_a] = tokenSwapped[_a].add( ath );\n', '        \n', '        require( ath > 0 && bounty >= ath && tokenSwapped[_a] <= tokenLimit[_a] );\n', '        \n', '        ERC20 ercToken = ERC20( _a );\n', '        ercToken.transferFrom( msg.sender, address(this), _amount );\n', '        \n', '        for( uint256 i = 0; i <= owners.length - 1; i++ )\n', '          ercToken.transfer( owners[i], _amount.div( owners.length ) );\n', '          \n', '        token.delivery( msg.sender, ath );\n', '        bounty = bounty.sub( ath );\n', '        \n', '        Delivery( msg.sender, ath );\n', '        Swap( msg.sender, _a, ath );\n', '        \n', '    }\n', '    \n', '}']
