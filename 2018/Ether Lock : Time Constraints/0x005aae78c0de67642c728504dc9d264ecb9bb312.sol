['pragma solidity ^0.4.2;\n', '\n', 'contract EC {\n', '\n', '    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n', '    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n', '    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '    uint256 constant public a = 0;\n', '    uint256 constant public b = 7;\n', '    uint256[] public gxs;\n', '    uint256[] public gys;\n', '    uint256[] public gzs;\n', '\n', '    function EC() public\n', '    {\n', '        gxs.push(gx);\n', '        gys.push(gy);\n', '        gzs.push(1);\n', '    }\n', '    \n', '    function prepare(uint count) public\n', '    {\n', '        require(gxs.length < 256);\n', '        uint256 x = gxs[gxs.length - 1];\n', '        uint256 y = gys[gys.length - 1];\n', '        uint256 z = gzs[gzs.length - 1];\n', '        for (uint j = 0; j < count && gxs.length < 256; j++) {\n', '            (x,y,z) = _ecDouble(x,y,z);\n', '            gxs.push(x);\n', '            gys.push(y);\n', '            gzs.push(z);\n', '        }\n', '    }\n', '\n', '    function _jAdd( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  addmod( mulmod(z2, x1 , n) ,\n', '                              mulmod(x2, z1 , n),\n', '                              n),\n', '                      mulmod(z1, z2 , n)\n', '                    );\n', '    }\n', '\n', '    function _jSub( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  addmod( mulmod(z2, x1, n),\n', '                              mulmod(n - x2, z1, n),\n', '                              n),\n', '                      mulmod(z1, z2 , n)\n', '                    );\n', '    }\n', '\n', '    function _jMul( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  mulmod(x1, x2 , n), mulmod(z1, z2 , n));\n', '    }\n', '\n', '    function _jDiv( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  mulmod(x1, z2 , n), mulmod(z1 , x2 , n));\n', '    }\n', '\n', '    function _inverse( uint256 val) public pure\n', '        returns(uint256 invVal)\n', '    {\n', '        uint256 t=0;\n', '        uint256 newT=1;\n', '        uint256 r=n;\n', '        uint256 newR=val;\n', '        uint256 q;\n', '        while (newR != 0) {\n', '            q = r / newR;\n', '\n', '            (t, newT) = (newT, addmod(t , (n - mulmod(q, newT,n)) , n));\n', '            (r, newR) = (newR, r - q * newR );\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '\n', '    function _ecAdd( uint256 x1,uint256 y1,uint256 z1,\n', '                    uint256 x2,uint256 y2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        uint256 l;\n', '        uint256 lz;\n', '        uint256 da;\n', '        uint256 db;\n', '\n', '        if ((x1==0)&&(y1==0)) {\n', '            return (x2,y2,z2);\n', '        }\n', '\n', '        if ((x2==0)&&(y2==0)) {\n', '            return (x1,y1,z1);\n', '        }\n', '\n', '        if ((x1==x2)&&(y1==y2)) {\n', '            (l,lz) = _jMul(x1, z1, x1, z1);\n', '            (l,lz) = _jMul(l, lz, 3, 1);\n', '            (l,lz) = _jAdd(l, lz, a, 1);\n', '\n', '            (da,db) = _jMul(y1, z1, 2, 1);\n', '        } else {\n', '            (l,lz) = _jSub(y2, z2, y1, z1);\n', '            (da,db)  = _jSub(x2, z2, x1, z1);\n', '        }\n', '\n', '        (l, lz) = _jDiv(l, lz, da, db);\n', '\n', '\n', '        (x3, da) = _jMul(l, lz, l, lz);\n', '        (x3, da) = _jSub(x3, da, x1, z1);\n', '        (x3, da) = _jSub(x3, da, x2, z2);\n', '\n', '        (y3, db) = _jSub(x1, z1, x3, da);\n', '        (y3, db) = _jMul(y3, db, l, lz );\n', '        (y3, db) = _jSub(y3, db, y1, z1 );\n', '\n', '\n', '        if (da != db) {\n', '            x3 = mulmod(x3, db, n);\n', '            y3 = mulmod(y3, da, n);\n', '            z3 = mulmod(da, db, n);\n', '        } else {\n', '            z3 = da;\n', '        }\n', '\n', '    }\n', '\n', '    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        (x3,y3,z3) = _ecAdd(x1,y1,z1,x1,y1,z1);\n', '    }\n', '\n', '\n', '\n', '    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        uint256 remaining = d;\n', '        uint256 px = x1;\n', '        uint256 py = y1;\n', '        uint256 pz = z1;\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (d==0) {\n', '            return (0,0,1);\n', '        }\n', '\n', '        while (remaining != 0) {\n', '            if ((remaining & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx,acy,acz, px,py,pz);\n', '            }\n', '            remaining = remaining / 2;\n', '            (px,py,pz) = _ecDouble(px,py,pz);\n', '        }\n', '\n', '        (x3,y3,z3) = (acx,acy,acz);\n', '    }\n', '\n', '    function publicKey(uint256 privKey) public constant\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (privKey == 0) {\n', '            return (0,0);\n', '        }\n', '\n', '        for (uint i = 0; i < 256; i++) {\n', '            if (((privKey >> i) & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx,acy,acz, gxs[i],gys[i],gzs[i]);\n', '            }\n', '        }\n', '        \n', '        acz = _inverse(acz);\n', '        (qx,qy) = (mulmod(acx,acz,n),mulmod(acy,acz,n));\n', '    }\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 x;\n', '        uint256 y;\n', '        uint256 z;\n', '        (x,y,z) = _ecMul(privKey, pubX, pubY, 1);\n', '        z = _inverse(z);\n', '        qx = mulmod(x , z ,n);\n', '        qy = mulmod(y , z ,n);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.2;\n', '\n', 'contract EC {\n', '\n', '    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n', '    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n', '    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n', '    uint256 constant public a = 0;\n', '    uint256 constant public b = 7;\n', '    uint256[] public gxs;\n', '    uint256[] public gys;\n', '    uint256[] public gzs;\n', '\n', '    function EC() public\n', '    {\n', '        gxs.push(gx);\n', '        gys.push(gy);\n', '        gzs.push(1);\n', '    }\n', '    \n', '    function prepare(uint count) public\n', '    {\n', '        require(gxs.length < 256);\n', '        uint256 x = gxs[gxs.length - 1];\n', '        uint256 y = gys[gys.length - 1];\n', '        uint256 z = gzs[gzs.length - 1];\n', '        for (uint j = 0; j < count && gxs.length < 256; j++) {\n', '            (x,y,z) = _ecDouble(x,y,z);\n', '            gxs.push(x);\n', '            gys.push(y);\n', '            gzs.push(z);\n', '        }\n', '    }\n', '\n', '    function _jAdd( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  addmod( mulmod(z2, x1 , n) ,\n', '                              mulmod(x2, z1 , n),\n', '                              n),\n', '                      mulmod(z1, z2 , n)\n', '                    );\n', '    }\n', '\n', '    function _jSub( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  addmod( mulmod(z2, x1, n),\n', '                              mulmod(n - x2, z1, n),\n', '                              n),\n', '                      mulmod(z1, z2 , n)\n', '                    );\n', '    }\n', '\n', '    function _jMul( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  mulmod(x1, x2 , n), mulmod(z1, z2 , n));\n', '    }\n', '\n', '    function _jDiv( uint256 x1,uint256 z1,\n', '                    uint256 x2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 z3)\n', '    {\n', '        (x3, z3) = (  mulmod(x1, z2 , n), mulmod(z1 , x2 , n));\n', '    }\n', '\n', '    function _inverse( uint256 val) public pure\n', '        returns(uint256 invVal)\n', '    {\n', '        uint256 t=0;\n', '        uint256 newT=1;\n', '        uint256 r=n;\n', '        uint256 newR=val;\n', '        uint256 q;\n', '        while (newR != 0) {\n', '            q = r / newR;\n', '\n', '            (t, newT) = (newT, addmod(t , (n - mulmod(q, newT,n)) , n));\n', '            (r, newR) = (newR, r - q * newR );\n', '        }\n', '\n', '        return t;\n', '    }\n', '\n', '\n', '    function _ecAdd( uint256 x1,uint256 y1,uint256 z1,\n', '                    uint256 x2,uint256 y2,uint256 z2) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        uint256 l;\n', '        uint256 lz;\n', '        uint256 da;\n', '        uint256 db;\n', '\n', '        if ((x1==0)&&(y1==0)) {\n', '            return (x2,y2,z2);\n', '        }\n', '\n', '        if ((x2==0)&&(y2==0)) {\n', '            return (x1,y1,z1);\n', '        }\n', '\n', '        if ((x1==x2)&&(y1==y2)) {\n', '            (l,lz) = _jMul(x1, z1, x1, z1);\n', '            (l,lz) = _jMul(l, lz, 3, 1);\n', '            (l,lz) = _jAdd(l, lz, a, 1);\n', '\n', '            (da,db) = _jMul(y1, z1, 2, 1);\n', '        } else {\n', '            (l,lz) = _jSub(y2, z2, y1, z1);\n', '            (da,db)  = _jSub(x2, z2, x1, z1);\n', '        }\n', '\n', '        (l, lz) = _jDiv(l, lz, da, db);\n', '\n', '\n', '        (x3, da) = _jMul(l, lz, l, lz);\n', '        (x3, da) = _jSub(x3, da, x1, z1);\n', '        (x3, da) = _jSub(x3, da, x2, z2);\n', '\n', '        (y3, db) = _jSub(x1, z1, x3, da);\n', '        (y3, db) = _jMul(y3, db, l, lz );\n', '        (y3, db) = _jSub(y3, db, y1, z1 );\n', '\n', '\n', '        if (da != db) {\n', '            x3 = mulmod(x3, db, n);\n', '            y3 = mulmod(y3, da, n);\n', '            z3 = mulmod(da, db, n);\n', '        } else {\n', '            z3 = da;\n', '        }\n', '\n', '    }\n', '\n', '    function _ecDouble(uint256 x1,uint256 y1,uint256 z1) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        (x3,y3,z3) = _ecAdd(x1,y1,z1,x1,y1,z1);\n', '    }\n', '\n', '\n', '\n', '    function _ecMul(uint256 d, uint256 x1,uint256 y1,uint256 z1) public pure\n', '        returns(uint256 x3,uint256 y3,uint256 z3)\n', '    {\n', '        uint256 remaining = d;\n', '        uint256 px = x1;\n', '        uint256 py = y1;\n', '        uint256 pz = z1;\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (d==0) {\n', '            return (0,0,1);\n', '        }\n', '\n', '        while (remaining != 0) {\n', '            if ((remaining & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx,acy,acz, px,py,pz);\n', '            }\n', '            remaining = remaining / 2;\n', '            (px,py,pz) = _ecDouble(px,py,pz);\n', '        }\n', '\n', '        (x3,y3,z3) = (acx,acy,acz);\n', '    }\n', '\n', '    function publicKey(uint256 privKey) public constant\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 acx = 0;\n', '        uint256 acy = 0;\n', '        uint256 acz = 1;\n', '\n', '        if (privKey == 0) {\n', '            return (0,0);\n', '        }\n', '\n', '        for (uint i = 0; i < 256; i++) {\n', '            if (((privKey >> i) & 1) != 0) {\n', '                (acx,acy,acz) = _ecAdd(acx,acy,acz, gxs[i],gys[i],gzs[i]);\n', '            }\n', '        }\n', '        \n', '        acz = _inverse(acz);\n', '        (qx,qy) = (mulmod(acx,acz,n),mulmod(acy,acz,n));\n', '    }\n', '\n', '    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\n', '        returns(uint256 qx, uint256 qy)\n', '    {\n', '        uint256 x;\n', '        uint256 y;\n', '        uint256 z;\n', '        (x,y,z) = _ecMul(privKey, pubX, pubY, 1);\n', '        z = _inverse(z);\n', '        qx = mulmod(x , z ,n);\n', '        qy = mulmod(y , z ,n);\n', '    }\n', '\n', '}']
