['pragma solidity ^0.4.25;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0);\n', '        uint256 c = _a / _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '\n', '\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract Multiplier is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    //Address for promo expences\n', '    address constant private support = 0x8Fa6E56c844be9B96C30B72cC2a8ccF6465a99F9;\n', '    //Percent for promo expences\n', '    uint constant public supportPercent = 3;\n', '\n', '    uint public reserved;\n', '    uint public delayed;\n', '\n', '    uint minCycle  = 5 minutes;\n', '    uint initCycle = 2 hours;\n', '    uint maxCycle  = 1 days;\n', '\n', '    uint public cycleStart;\n', '    uint public actualCycle;\n', '    uint public lastCycle;\n', '    uint public cycles;\n', '\n', '    uint minPercent = 1;\n', '    uint maxPercent = 33;\n', '\n', '    uint frontier = 50;\n', '\n', '    mapping (address => address) referrer;\n', '    mapping (address => bool) verified;\n', '\n', '    uint refBonus = 5;\n', '\n', '    uint verificationPrice = 0.0303 ether;\n', '\n', '    event NewCycle(uint start, uint duration, uint indexed cycle);\n', '    event NewDeposit(address indexed addr, uint idx, uint amount, uint profit, uint indexed cycle);\n', '    event Payed(address indexed addr, uint amount, uint indexed cycle);\n', '    event Refunded(address indexed addr, uint amount, uint indexed cycle);\n', '    event RefundCompleted(uint indexed cycle);\n', '    event RefVerified(address indexed addr);\n', '    event RefBonusPayed(address indexed investor, address referrer, uint amount, uint level);\n', '    event VerPriceChanged(uint oldPrice, uint newPrice);\n', '\n', '\n', '    constructor() public {\n', '        verified[owner()] = true;\n', '        actualCycle = initCycle * 2;\n', '        queue.length += 1;\n', '    }\n', '\n', '    //The deposit structure holds all the info about the deposit made\n', '    struct Deposit {\n', '        address depositor; //The depositor address\n', '        uint128 deposit;   //The deposit amount\n', '        uint128 expect;    //How much we should pay out\n', '    }\n', '\n', '    Deposit[] public queue;  //The queue\n', '    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\n', '    uint public currentRefundIndex = 0;\n', '\n', '    function bytesToAddress(bytes _source) internal pure returns(address parsedreferrer) {\n', '        assembly {\n', '            parsedreferrer := mload(add(_source,0x14))\n', '        }\n', '        return parsedreferrer;\n', '    }\n', '\n', '    function setRef() internal returns(bool) {\n', '        address _referrer = bytesToAddress(bytes(msg.data));\n', '        if (_referrer != msg.sender && msg.data.length == 20 && verified[_referrer]) {\n', '            referrer[msg.sender] = _referrer;\n', '            return true;\n', '        }\n', '    }\n', '\n', '    function setVerificationPrice(uint newPrice) external onlyOwner {\n', '        emit VerPriceChanged(verificationPrice, newPrice);\n', '        verificationPrice = newPrice;\n', '    }\n', '\n', '    function verify(address addr) public payable {\n', '        if (msg.sender != owner()) {\n', '            require(msg.value == verificationPrice);\n', '            support.send(verificationPrice);\n', '        }\n', '        verified[addr] = true;\n', '        emit RefVerified(addr);\n', '    }\n', '\n', '    //This function receives all the deposits\n', '    //stores them and make immediate payouts\n', '    function () public payable {\n', '        //check if sender is not a smart contract\n', '        require(!isContract(msg.sender));\n', '\n', '        if(msg.value == verificationPrice) {\n', '            verify(msg.sender);\n', '            return;\n', '        }\n', '\n', '        if (msg.value == 0 && msg.sender == owner()) {\n', '            address a = bytesToAddress(bytes(msg.data));\n', '            verify(a);\n', '            return;\n', '        }\n', '\n', '        if (referrer[msg.sender] == address(0)) {\n', '            require(setRef());\n', '        }\n', '\n', '        if(msg.value > 0){\n', '            require(gasleft() >= 300000, "We require more gas!"); //We need gas to process queue\n', '            require(msg.value <= 10 ether); //Do not allow too big investments to stabilize payouts\n', '\n', '            if (block.timestamp >= cycleStart + actualCycle) {\n', '                if (queue.length.sub(lastCycle) >= frontier) {\n', '                    actualCycle = actualCycle * 2;\n', '                    if (actualCycle > maxCycle) {\n', '                        actualCycle = maxCycle;\n', '                    }\n', '                } else {\n', '                    actualCycle = actualCycle / 2;\n', '\n', '                    if (actualCycle < minCycle) {\n', '                        actualCycle = minCycle;\n', '                    }\n', '                }\n', '\n', '                uint amountOfPlayers = queue.length - lastCycle;\n', '                lastCycle = queue.length;\n', '                cycleStart = block.timestamp;\n', '                currentReceiverIndex = lastCycle;\n', '                cycles++;\n', '\n', '                if (amountOfPlayers != 1) {\n', '                    currentRefundIndex = lastCycle.sub(1);\n', '                    refunding();\n', '                } else {\n', '                    singleRefunding();\n', '                }\n', '\n', '                emit NewCycle(cycleStart, actualCycle, cycles);\n', '            }\n', '\n', '            if (currentRefundIndex != 0) {\n', '                refunding();\n', '            }\n', '\n', '            //Add the investor into the queue. Mark that he expects to receive 121% of deposit back\n', '            uint percent = queue.length.sub(lastCycle).add(1);\n', '            if (percent >= 33) {\n', '                percent = 33;\n', '            }\n', '\n', '            queue.push(Deposit(msg.sender, uint128(msg.value), uint128(msg.value * (100 + percent) / 100)));\n', '\n', '            //Send fee\n', '            uint _support = msg.value * supportPercent / 100;\n', '            support.send(_support);\n', '            uint _refBonus = msg.value * refBonus / 1000;\n', '            referrer[msg.sender].send(_refBonus);\n', '            emit RefBonusPayed(msg.sender, referrer[msg.sender], _refBonus, 1);\n', '            if (referrer[referrer[msg.sender]] != address(0)) {\n', '                referrer[referrer[msg.sender]].send(_refBonus);\n', '                emit RefBonusPayed(msg.sender, referrer[referrer[msg.sender]], _refBonus, 2);\n', '            }\n', '\n', '            emit NewDeposit(msg.sender, queue.length - 1, msg.value, msg.value * (100 + percent) / 100, cycles);\n', '\n', '            if (currentRefundIndex == 0) {\n', '                reserved += msg.value * 96 / 100 / 2;\n', '                if (delayed != 0) {\n', '                    reserved != delayed;\n', '                    delayed = 0;\n', '                }\n', '                //Pay to first investors in line\n', '                pay();\n', '            } else {\n', '                delayed += msg.value * 96 / 100 / 2;\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '    //Used to pay to current investors\n', '    //Each new transaction processes 1 - 4+ investors in the head of queue\n', '    //depending on balance and gas left\n', '    function pay() private {\n', '        //Try to send all the money on contract to the first investors in line\n', '        uint128 money = uint128(address(this).balance - reserved);\n', '\n', '        //We will do cycle on the queue\n', '        for(uint i=0; i<queue.length; i++){\n', '\n', '            uint idx = currentReceiverIndex + i;  //get the index of the currently first investor\n', '\n', '            Deposit storage dep = queue[idx]; //get the info of the first investor\n', '\n', '            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\n', '                dep.depositor.send(dep.expect); //Send money to him\n', '                money -= dep.expect;            //update money left\n', '\n', '                emit Payed(dep.depositor, dep.expect, cycles);\n', '\n', '                //this investor is fully paid, so remove him\n', '                delete queue[idx];\n', '            }else{\n', "                //Here we don't have enough money so partially pay to investor\n", '                dep.depositor.send(money); //Send to him everything we have\n', '                dep.expect -= money;       //Update the expected amount\n', '\n', '                emit Payed(dep.depositor, money, cycles);\n', '\n', '                break;                     //Exit cycle\n', '            }\n', '\n', '            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\n', '                break;                     //The next investor will process the line further\n', '        }\n', '\n', '        currentReceiverIndex += i; //Update the index of the current first investor\n', '    }\n', '\n', '    function refunding() private {\n', '\n', '        uint128 refund = uint128(reserved);\n', '        if (refund >= 1 ether) {\n', '            refund -= 1 ether;\n', '        }\n', '\n', '        for(uint i=0; i<=currentRefundIndex; i++){\n', '\n', '            uint idx = currentRefundIndex.sub(i);\n', '\n', '            Deposit storage dep = queue[idx];\n', '\n', '            if (lastCycle.sub(idx) <= 33) {\n', '                uint percent = lastCycle - idx;\n', '            } else {\n', '                percent = 33;\n', '            }\n', '\n', '            uint128 amount = uint128(dep.deposit + (dep.deposit * percent / 100));\n', '\n', '            if(refund > amount){\n', '                dep.depositor.send(amount);\n', '                refund -= amount;\n', '                reserved -= amount;\n', '\n', '                emit Refunded(dep.depositor, amount, cycles - 1);\n', '                delete queue[idx];\n', '            }else{\n', '                dep.depositor.send(refund);\n', '                reserved -= refund;\n', '                currentRefundIndex = 0;\n', '\n', '                emit Refunded(dep.depositor, refund, cycles - 1);\n', '                emit RefundCompleted(cycles - 1);\n', '                break;\n', '            }\n', '\n', '            if(gasleft() <= 100000)\n', '                break;\n', '        }\n', '\n', '        if (currentRefundIndex != 0) {\n', '            currentRefundIndex -= i;\n', '        }\n', '    }\n', '\n', '    function singleRefunding() private {\n', '        Deposit storage dep = queue[queue.length - 1];\n', '        uint amount = dep.deposit * 2 / 100 + dep.expect;\n', '        if (reserved < amount) {\n', '            amount = reserved;\n', '        }\n', '        dep.depositor.send(amount);\n', '        reserved -= amount;\n', '        emit Refunded(dep.depositor, amount, cycles - 1);\n', '        delete queue[queue.length - 1];\n', '        emit RefundCompleted(cycles - 1);\n', '    }\n', '\n', '    //Get the deposit info by its index\n', '    //You can get deposit index from\n', '    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n', '        Deposit storage dep = queue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expect);\n', '    }\n', '\n', '    //Get the count of deposits of specific investor\n', '    function getDepositsCount(address depositor) public view returns (uint) {\n', '        uint c = 0;\n', '        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n', '            if(queue[i].depositor == depositor)\n', '                c++;\n', '        }\n', '        return c;\n', '    }\n', '\n', '    //Get all deposits (index, deposit, expect) of a specific investor\n', '    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\n', '        uint c = getDepositsCount(depositor);\n', '\n', '        idxs = new uint[](c);\n', '        deposits = new uint128[](c);\n', '        expects = new uint128[](c);\n', '\n', '        if(c > 0) {\n', '            uint j = 0;\n', '            for(uint i=currentReceiverIndex; i<queue.length; ++i){\n', '                Deposit storage dep = queue[i];\n', '                if(dep.depositor == depositor){\n', '                    idxs[j] = i;\n', '                    deposits[j] = dep.deposit;\n', '                    expects[j] = dep.expect;\n', '                    j++;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    //Get current queue size\n', '    function getQueueLength() public view returns (uint) {\n', '        return queue.length - currentReceiverIndex;\n', '    }\n', '\n', '    function isContract(address addr) private view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function contractBalance() external view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '}']