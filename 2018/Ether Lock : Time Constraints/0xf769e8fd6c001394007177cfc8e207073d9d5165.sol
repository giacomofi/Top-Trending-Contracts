['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract KahnAirDrop{\n', '    using SafeMath for uint256;\n', '\t\n', '    struct User{\n', '\t\taddress user_address;\n', '\t\tuint signup_time;\n', '\t\tuint256 reward_amount;\n', '\t\tbool blacklisted;\n', '\t\tuint paid_time;\n', '\t\tuint256 paid_token;\n', '\t\tbool status;\n', '\t}\n', '\t\n', '\t/* @dev Contract creator address */\n', '    address public owner;\n', '\t\n', '    /* @dev Assigned wallet where the remaining unclaim tokens to be return */\n', '    address public wallet;\n', '\t\n', '\t/* @dev The minimum either in wei must received to execute the claim function */\n', '    uint256 public mineth = 0;\n', '\n', '\t/* @dev The minimum either in wei must received to execute the claim function */\n', '    uint256 public minsignupeth = 0;\n', '\n', '\t/* @dev Whether or not the contract is pause (in case of a problem is detected) */\n', '\tbool public paused = false;\n', '\t\n', '\t/* @dev Fixed amount payout for each bounty */\n', '\tuint public maxSignup = 1000;\n', '\t\n', '\t/* @dev allows direct signup  */\n', '\tbool public allowsSignup = true;\n', '\t\n', '\t/* @dev bounty address  */\n', '\taddress[] public bountyaddress;\n', '\t\n', '\t/* @dev admin address  */\n', '\taddress[] public adminaddress;\n', '\t\n', '\t/* @dev staff address  */\n', '\taddress[] public staffaddress;\n', '\t\n', '\t/* @dev block time to start the contract */\n', '\tuint public startTimes;\n', '\t\n', '\t/* @dev block time to end the contract */\n', '\tuint public endTimes;\n', '\t\n', '\t/* @dev Whether or not the contract is blacklisted (in case of a problem is detected) */\n', '\tbool public contractbacklist = false;\n', '\n', '    /* @dev Total Signup count */\n', '    uint public userSignupCount = 0;\n', '\t\n', '    /* @dev Total tokens claimed */\n', '    uint256 public userClaimAmt = 0;\n', '\n', '    /* @dev The token being distribute */\n', '    ERC20 public token;\n', '\n', '\t/* \n', '\t* @dev This set how the bounty reward will be paying out \n', '\t* @param 0 = pay evenly\n', '\t* @param 1 = pay fixed amount\n', '\t* @param 2 = pay various amount\n', '\t*/\n', '\tuint public payStyle = 2;\n', '\t\n', '\t/* \n', '\t* @dev False = Free version, contract creator will received the ether\n', '\t* @dev True = Paid version, client will received the ether \n', '\t*/\n', '\tbool public paidversion = true;\n', '\n', '\t/* @dev Setup the payout method\n', '\t* @param 0 = Enabled Signup Disabled Payout\n', '\t* @param 1 = Disable Signup Disable Payout\n', '\t* @param 2 = Disabled Signup Enable Payout\n', '\t* @param 3 = Enabled Signup Enabled Payout\n', '\t* @param 4 = Disabled Signup Immediate Payout\n', '\t*/\n', '\tuint public payoutNow = 4;\n', '\t\n', '\t/* @dev Fixed amount payout for each bounty */\n', '\tuint256 public fixPayAmt = 0;\n', '\t\n', '    /* @dev To record the different reward amount for each bounty  */\n', '    mapping(address => User) public bounties;\n', '\t\n', '    /* @dev to include the bounty in the list */\n', '\tmapping(address => bool) public signups;\n', '\t\n', '    /* @dev Store bounty address to blacklist */\n', '\tmapping(address => bool) public blacklist;\n', '\t\n', '    /* @dev to check is the claim in the process */\n', '\tmapping(address => bool) public isProcess;\n', '\t\n', '    /* @dev Admin with permission to manage the signed up bounty */\n', '    mapping (address => bool) public admins;\n', '\t\n', '    /* @dev Staff with permission to manage the signed up bounty */\n', '    mapping (address => bool) public staffs;\n', '\t\n', '    /**\n', '    * @dev Event for token distribution logging\n', '    * @param _address who claim the tokens\n', '    * @param _amount amount of tokens to be delivery\n', '    */\n', '    event eTokenClaim(address indexed _address, uint256 _amount);   \n', '    event eReClaimToken(uint256 _taBal, address _wallet, address _address);   \n', '    event eWalletChange(address _wallet, address indexed _address);\n', '    event eUpdatePayout(uint _payStyle, uint _payoutNow, uint256 _fixPayAmt, bool _allowsSignup, address indexed _address); \n', '    event eUpdateStartEndTime(uint _startTimes, uint _endTimes, address indexed _address); \n', '\n', '    /* \n', '    * event eAddAdmin(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveAdmin(address _newaddress, address indexed _byaddress);   \n', '    * event eAddStaff(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveStaff(address _newaddress, address indexed _byaddress);   \n', '    * event eAddBounty(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveBounty(address _address, address indexed _byaddress);   \n', '\t*/\n', '\t\n', '    /**\n', '    * @param _token Token smart contract address\n', '    * @param _wallet ETH address to reclaim unclaim tokens\n', '    */\n', '    function KahnAirDrop(ERC20 _token, uint256 _min_eth, uint256 _minsignupeth, uint _paystyle, address _wallet, uint _starttimes, uint _endtimes, uint _payoutnow, uint256 _fixpayamt, uint _maxsignup, bool _allowssignup, bool _paidversion) public {\n', '        require(_token != address(0));\n', '        token = _token;\n', '        admins[msg.sender] = true;\n', '        adminaddress.push(msg.sender) -1;\n', '        owner = msg.sender;\n', '        mineth = _min_eth;\n', '        minsignupeth = _minsignupeth;\n', '        wallet = _wallet;\n', '        payStyle = _paystyle;\n', '        startTimes = _starttimes;\n', '        endTimes = _endtimes;\n', '        payoutNow = _payoutnow;\n', '        fixPayAmt = _fixpayamt;\n', '        maxSignup = _maxsignup;\n', '        allowsSignup = _allowssignup;\n', '        paidversion = _paidversion;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '       require(msg.sender == owner);\n', '       _;\n', '    }\n', '\t\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyStaffs {\n', '        require(admins[msg.sender] || staffs[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier ifNotPaused {\n', '       require(!paused);\n', '       _;\n', '    }\n', '\n', '    modifier ifNotStartExp {\n', '       require(now >= startTimes && now <= endTimes);\n', '       _;\n', '    }\n', '\n', '    modifier ifNotBlacklisted {\n', '       require(!contractbacklist);\n', '       _;\n', '    }\n', '\n', '\t/*******************/\n', '\t/* Owner Function **/\n', '\t/*******************/\n', '    /* @dev Update Contract Configuration  */\n', '    function ownerUpdateToken(ERC20 _token, address _wallet) public onlyOwner{\n', '        token = _token;\n', '        wallet = _wallet;\n', '        emit eWalletChange(wallet, msg.sender);\n', '    }\n', '\n', '    /* @dev Update Contract Configuration  */\n', '    function ownerUpdateOthers(uint _maxno, bool _isBacklisted, uint256 _min_eth, uint256 _minsignupeth, bool _paidversion) public onlyOwner{\n', '        maxSignup = _maxno;\n', '        contractbacklist = _isBacklisted;\n', '        mineth = _min_eth;\n', '        minsignupeth = _minsignupeth;\n', '        paidversion = _paidversion;\n', '    }\n', '\n', '\t/* @dev Owner Retrieve Contract Configuration */\n', '    function ownerRetrieveTokenDetails() view public onlyOwner returns(ERC20, address, uint256, uint256, bool){\n', '\t\treturn(token, wallet, token.balanceOf(this), userClaimAmt, contractbacklist);\n', '    }\n', '\n', '\t/* @dev Owner Retrieve Contract Configuration */\n', '    function ownerRetrieveContractConfig2() view public onlyOwner returns(uint256, bool, uint, uint, uint, uint, uint256, uint, bool){\n', '\t\treturn(mineth, paidversion, payStyle, startTimes, endTimes, payoutNow, fixPayAmt, maxSignup, allowsSignup);\n', '    }\n', '\n', '\t/*******************/\n', '\t/* Admin Function **/\n', '\t/*******************/\n', '    /* @dev Add admin to whitelist */\n', '\tfunction addAdminWhitelist(address[] _userlist) public onlyOwner onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(!admins[baddr]){\n', '\t\t\t\t\tadmins[baddr] = true;\n', '\t\t\t\t\tadminaddress.push(baddr) -1;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Remove admin from whitelist */\n', '\tfunction removeAdminWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(admins[baddr]){\n', '\t\t\t\t\tadmins[baddr] = false;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Add staff to whitelist */\n', '\tfunction addStaffWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(!staffs[baddr]){\n', '\t\t\t\t\tstaffs[baddr] = true;\n', '\t\t\t\t\tstaffaddress.push(baddr) -1;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Remove staff from whitelist */\n', '\tfunction removeStaffWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(staffs[baddr]){\n', '\t\t\t\t\tstaffs[baddr] = false;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\t/* @dev Allow Admin to reclaim all unclaim tokens back to the specified wallet */\n', '\tfunction reClaimBalance() public onlyAdmin{\n', '\t\tuint256 taBal = token.balanceOf(this);\n', '\t\ttoken.transfer(wallet, taBal);\n', '\t\temit eReClaimToken(taBal, wallet, msg.sender);\n', '\t}\n', '\t\n', '\tfunction adminUpdateWallet(address _wallet) public onlyAdmin{\n', '\t\trequire(_wallet != address(0));\n', '\t\twallet = _wallet;\n', '\t\temit eWalletChange(wallet, msg.sender);\n', '\t}\n', '\n', '\tfunction adminUpdateStartEndTime(uint _startTimes, uint _endTimes) public onlyAdmin{\n', '\t\trequire(_startTimes > 0);\n', '\t\trequire(_endTimes > 0);\n', '\t\tstartTimes = _startTimes;\n', '\t\tendTimes = _endTimes;\n', '\t\temit eUpdateStartEndTime(startTimes, endTimes, msg.sender);\n', '\t}\n', '\n', '    /* @dev Update Contract Configuration  */\n', '    function adminUpdMinSign(uint256 _min_eth, uint256 _minsignupeth) public onlyAdmin{\n', '       if(paidversion){\n', '\t\t\tmineth = _min_eth;\n', '\t\t\tminsignupeth = _minsignupeth;\n', '\t   } \n', '    }\n', '\n', '\tfunction adminUpdatePayout(uint _payStyle, uint _payoutNow, uint256 _fixPayAmt, bool _allowsSignup) public onlyAdmin{\n', '\t\tpayStyle = _payStyle;\n', '\t\tpayoutNow = _payoutNow;\n', '\t\tfixPayAmt = _fixPayAmt;\n', '\t\tallowsSignup = _allowsSignup;\n', '\t\temit eUpdatePayout(payStyle, payoutNow, fixPayAmt, allowsSignup, msg.sender);\n', '\t}\n', '\n', '\t/***************************/\n', '\t/* Admin & Staff Function **/\n', '\t/***************************/\n', '\t/* @dev Admin/Staffs Update Contract Configuration */\n', '\n', '    /* @dev Add user to whitelist */\n', '    function signupUserWhitelist(address[] _userlist, uint256[] _amount) public onlyStaffs{\n', '    \trequire(_userlist.length > 0);\n', '\t\trequire(_amount.length > 0);\n', '    \tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '    \t\taddress baddr = _userlist[i];\n', '    \t\tuint256 bval = _amount[i];\n', '    \t\tif(baddr != address(0) && userSignupCount <= maxSignup){\n', '    \t\t\tif(!bounties[baddr].blacklisted && bounties[baddr].user_address != baddr){\n', '\t\t\t\t\tsignups[baddr] = true;\n', '\t\t\t\t\tbountyaddress.push(baddr) -1;\n', '\t\t\t\t\tuserSignupCount++;\n', '\t\t\t\t\tif(payoutNow==4){\n', '\t\t\t\t\t\tbounties[baddr] = User(baddr,now,0,false,now,bval,true);\n', '\t\t\t\t\t\ttoken.transfer(baddr, bval);\n', '\t\t\t\t\t\tuserClaimAmt = userClaimAmt.add(bval);\n', '\t\t\t\t\t}else{\n', '\t\t\t\t\t\tbounties[baddr] = User(baddr,now,bval,false,0,0,true);\n', '\t\t\t\t\t}\n', '    \t\t\t}\n', '    \t\t}\n', '    \t}\n', '    }\n', '\t\n', '    /* @dev Remove user from whitelist */\n', '    function removeUserWhitelist(address[] _userlist) public onlyStaffs{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0) && bounties[baddr].user_address == baddr){\n', '\t\t\t\tbounties[baddr].status = false;\n', '            \tsignups[baddr] = false;\n', '            \tuserSignupCount--;\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\t\n', '\tfunction updUserBlackList(address[] _addlist, address[] _removelist) public onlyStaffs{\n', '\t\tif(_addlist.length > 0){\n', '\t\t\tfor (uint256 i = 0; i < _addlist.length; i++) {\n', '\t\t\t\taddress baddr = _addlist[i];\n', '\t\t\t\tif(baddr != address(0) && !bounties[baddr].blacklisted){\n', '\t\t\t\t\tbounties[baddr].blacklisted = true;\n', '\t\t\t\t\tblacklist[baddr] = true;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(_removelist.length > 0){ removeUserFromBlackList(_removelist); }\n', '\t}\n', '\t\n', '\tfunction removeUserFromBlackList(address[] _userlist) internal{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0) && bounties[baddr].blacklisted){\n', '\t\t\t\tbounties[baddr].blacklisted = false;\n', '\t\t\t\tblacklist[baddr] = false;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Update Multiple Users Reward Amount */\n', '    function updateMultipleUsersReward(address[] _userlist, uint256[] _amount) public onlyStaffs{\n', '\t\trequire(_userlist.length > 0);\n', '\t\trequire(_amount.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tuint256 bval = _amount[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(bounties[baddr].user_address == baddr){\n', '\t\t\t\t\tbounties[baddr].reward_amount = bval;\n', '\t\t\t\t}else{\n', '\t\t\t\t\tif(userSignupCount <= maxSignup){\n', '\t\t\t\t\t    bounties[baddr] = User(baddr,now,bval,false,0,0,true);\n', '\t\t\t\t\t    signups[baddr] = true;\n', '\t\t\t\t\t\tbountyaddress.push(baddr) -1;\n', '\t\t\t\t\t    userSignupCount++;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\t\n', '\t/***************************/\n', '\t/* Query Display Function **/\n', '\t/***************************/\n', '    function adminRetrieveContractConfig() view public onlyStaffs returns(uint, uint, uint256, uint, bool, bool){\n', '\t\treturn(payStyle, payoutNow, fixPayAmt, maxSignup, allowsSignup, paidversion);\n', '    }\n', '\n', '    function adminRetrieveContractConfig2() view public onlyStaffs returns(uint256, uint256, address, uint, uint, uint){\n', '    \treturn(mineth, minsignupeth, wallet, startTimes, endTimes, userSignupCount);\n', '    }\n', '\n', '    function adminRetrieveContractConfig3() view public onlyStaffs returns(ERC20, uint256, uint256, uint, uint){\n', '    \tuint256 taBal = token.balanceOf(this);\n', '\t\treturn(token, taBal,userClaimAmt, now, block.number);\n', '    }\n', '\n', '\t/* @dev Check is the address is in Admin list */\n', '\tfunction chkAdmin(address _address) view public onlyAdmin returns(bool){\n', '\t\treturn admins[_address];\n', '\t}\n', '\t\n', '\t/* @dev Check is the address is in Staff list */\n', '\tfunction chkStaff(address _address) view public onlyAdmin returns(bool){\n', '\t\treturn staffs[_address];\n', '\t}\n', '\n', '\t/* @dev Return admin addresses list */\n', '\tfunction getAllAdmin() view public onlyAdmin returns(address[]){\n', '\t\treturn adminaddress;\n', '\t}\n', '\n', '\t/* @dev Return staff addresses list */\n', '\tfunction getAllStaff() view public onlyAdmin returns(address[]){\n', '\t\treturn staffaddress;\n', '\t}\n', '\n', '\t/* @dev Return list of bounty addresses */\n', '\tfunction getBountyAddress() view public onlyStaffs returns(address[]){\n', '\t\treturn bountyaddress;\n', '\t}\n', '\t\n', '\t/*  \n', '\t* @dev Check is the user is in Signed up list \n', '\t* @dev bool = address is in the signup mapping list\n', '\t* @dev uint256 = the given bounty address reward entitlement amount\n', '\t*/\n', '\tfunction chkUserDetails(address _address) view public onlyStaffs returns(address,uint,uint256,bool,uint,uint256,bool){\n', '\t\trequire(_address != address(0));\n', '\t\treturn(bounties[_address].user_address, bounties[_address].signup_time, bounties[_address].reward_amount, bounties[_address].blacklisted, bounties[_address].paid_time, bounties[_address].paid_token, bounties[_address].status);\n', '\t}\n', '\t\n', '\t/***************************/\n', '\t/* Main Contract Function **/\n', '\t/***************************/\n', '\t/* @dev Bounty send in either to execute the claim */\n', '\tfunction () external payable ifNotStartExp ifNotPaused ifNotBlacklisted{\n', '\t\trequire(!blacklist[msg.sender]);\n', '\t\tif(payoutNow == 0){\n', '\t\t\trequire(allowsSignup);\n', '\t\t\tsingleUserSignUp(msg.sender);\n', '\t\t}else if(payoutNow == 1){\n', '\t\t\trequire(allowsSignup);\n', '\t\t}else if(payoutNow == 2){\n', '\t\t\tclaimTokens(msg.sender);\n', '\t\t}else if(payoutNow == 3){\n', '\t\t\tclaimImmediateTokens(msg.sender);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction singleUserSignUp(address _address) internal ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t\tif(userSignupCount <= maxSignup){\n', '\t\t\tif(!signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth){\n', '\t\t\t\tif(payoutNow != 1 || payoutNow != 2){\n', '\t\t\t\t\tsignups[_address] = true;\n', '\t\t\t\t\tuint256 temrew = 0;\n', '\t\t\t\t\tif(payStyle == 1){ temrew = fixPayAmt; }\n', '\t\t\t\t\tbounties[_address] = User(_address,now,temrew,false,0,0,true);\n', '\t\t\t\t\tsignups[_address] = true;\n', '\t\t\t\t\tbountyaddress.push(_address) -1;\n', '\t\t\t\t\tuserSignupCount++;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tforwardWei();\n', '\t}\n', '\t\n', '    /* @dev Bounty claim their reward tokens by sending zero ETH to this smart contract */\n', '    function claimTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t   require(msg.value >= mineth);\n', '\t   require(_beneficiary != address(0));\n', '\t   require(!blacklist[msg.sender]);\n', '\t   \n', '\t   /* @dev Check to ensure the address is not in processing to avoid double claim */\n', '       require(!isProcess[_beneficiary]);\n', '\t   \n', '\t   /* @dev Check to ensure the address is signed up to the airdrop */\n', '       require(signups[_beneficiary]);\n', '\t   \n', '\t   /* @dev Get the reward token for the given address */\n', '\t   uint256 rewardAmount = getReward(_beneficiary);\n', '\t   \n', '\t   /* @dev if the baounty reward amount is less than zero, quit the prorcess */\n', '\t   require(rewardAmount > 0);\n', '\t   \n', '\t   /* @dev get the available balance for airdrop */\n', '\t   uint256 taBal = token.balanceOf(this);\n', '\t   \n', '\t   /* @dev Check is the balance enough to pay for the claim */\n', '\t   require(rewardAmount <= taBal);\n', '\t   \n', '\t   /* @dev Set the address to processing */\n', '\t   isProcess[_beneficiary] = true;\n', '\t   \n', '\t   /* @dev Transer the token to the bounty */\n', '\t   token.transfer(_beneficiary, rewardAmount);\n', '\t   \n', '\t   /* @dev Set the bounty reward entitlement to zero */\n', '\t   bounties[_beneficiary].reward_amount = 0;\n', '\t   bounties[_beneficiary].status = true;\n', '\t   bounties[_beneficiary].paid_time = now;\n', '\t   \n', '\t   /* @dev Set the In Process to false to mark the process is completed */\n', '\t   isProcess[_beneficiary] = false;\n', '\t   \n', '\t   /* @dev Add the claim tokens to total claimed tokens */\n', '\t   userClaimAmt = userClaimAmt.add(rewardAmount);\n', '\t   \n', '\t   /* @dev Transfer the ether */\n', '\t   forwardWei();\n', '\t   \n', '\t   emit eTokenClaim(_beneficiary, rewardAmount);\n', '    }\n', '\t\n', '\t\n', '    /* @dev Bounty claim their reward tokens by sending zero ETH to this smart contract */\n', '    function claimImmediateTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t   require(msg.value >= mineth);\n', '\t   require(_beneficiary != address(0));\n', '\t   require(!blacklist[msg.sender]);\n', '\t   require(userSignupCount <= maxSignup);\n', '\t   require(fixPayAmt > 0);\n', '\t   uint256 taBal = token.balanceOf(this);\n', '\t   require(taBal > 0);\n', '\t   require(fixPayAmt <= taBal);\n', '       require(!isProcess[_beneficiary]);\n', '\t   isProcess[_beneficiary] = true;\n', '\t   signups[_beneficiary] = true;\n', '\t   bounties[_beneficiary] = User(_beneficiary,now,0,false,now,fixPayAmt,true);\n', '\t   bountyaddress.push(_beneficiary) -1;\n', '\t   userSignupCount++;\n', '\t   token.transfer(_beneficiary, fixPayAmt);\n', '\t   userClaimAmt = userClaimAmt.add(fixPayAmt);\n', '\t   forwardWei();\n', '\t   emit eTokenClaim(_beneficiary, fixPayAmt);\n', '    }\n', '\n', '    /* @dev Get Reward function based on the payout style */\n', '\tfunction getReward(address _address) internal constant returns(uint256){\n', '\t\tuint256 rtnVal = 0;\n', '\t\tif(payStyle == 0){\n', '\t\t\t/* Reward divided evenly by the total number of signed up bounty */\n', '\t\t\tuint256 taBal = token.balanceOf(this);\n', '\t\t\trtnVal = taBal.div(userSignupCount);\n', '\t\t}else if(payStyle == 1){\n', '\t\t\t// Reward for each bounty is based on Fixed amount\n', '\t\t\trtnVal = fixPayAmt;\n', '\t\t}else if(payStyle == 2){\n', '\t\t\t// Reward for each bounty is based on the amount set by the Admin when adding the bounty\n', '\t\t\trtnVal = bounties[_address].reward_amount;\n', '\t\t}\n', '\t\treturn rtnVal;\n', '\t}\n', '\t\n', '\t/* @dev Function for who will receive the paid ether */\n', '\tfunction forwardWei() internal {\n', '\t\tif(!paidversion){\n', '\t\t\t/* if paidversion is false, this is a free version, client agreed to contract creator to received the either */\n', '\t\t\t/* in exchnage to use the service for free */\n', '\t\t\tif(msg.value > 0)\n', '\t\t\t\towner.transfer(msg.value);\n', '\t\t}else{\n', '\t\t\t/* if paidversion is true, this is a paid version, received ether pay directly to client wallet */\n', '\t\t\tif(msg.value > 0)\n', '\t\t\t\twallet.transfer(msg.value);\n', '\t\t}\n', '\t}\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract KahnAirDrop{\n', '    using SafeMath for uint256;\n', '\t\n', '    struct User{\n', '\t\taddress user_address;\n', '\t\tuint signup_time;\n', '\t\tuint256 reward_amount;\n', '\t\tbool blacklisted;\n', '\t\tuint paid_time;\n', '\t\tuint256 paid_token;\n', '\t\tbool status;\n', '\t}\n', '\t\n', '\t/* @dev Contract creator address */\n', '    address public owner;\n', '\t\n', '    /* @dev Assigned wallet where the remaining unclaim tokens to be return */\n', '    address public wallet;\n', '\t\n', '\t/* @dev The minimum either in wei must received to execute the claim function */\n', '    uint256 public mineth = 0;\n', '\n', '\t/* @dev The minimum either in wei must received to execute the claim function */\n', '    uint256 public minsignupeth = 0;\n', '\n', '\t/* @dev Whether or not the contract is pause (in case of a problem is detected) */\n', '\tbool public paused = false;\n', '\t\n', '\t/* @dev Fixed amount payout for each bounty */\n', '\tuint public maxSignup = 1000;\n', '\t\n', '\t/* @dev allows direct signup  */\n', '\tbool public allowsSignup = true;\n', '\t\n', '\t/* @dev bounty address  */\n', '\taddress[] public bountyaddress;\n', '\t\n', '\t/* @dev admin address  */\n', '\taddress[] public adminaddress;\n', '\t\n', '\t/* @dev staff address  */\n', '\taddress[] public staffaddress;\n', '\t\n', '\t/* @dev block time to start the contract */\n', '\tuint public startTimes;\n', '\t\n', '\t/* @dev block time to end the contract */\n', '\tuint public endTimes;\n', '\t\n', '\t/* @dev Whether or not the contract is blacklisted (in case of a problem is detected) */\n', '\tbool public contractbacklist = false;\n', '\n', '    /* @dev Total Signup count */\n', '    uint public userSignupCount = 0;\n', '\t\n', '    /* @dev Total tokens claimed */\n', '    uint256 public userClaimAmt = 0;\n', '\n', '    /* @dev The token being distribute */\n', '    ERC20 public token;\n', '\n', '\t/* \n', '\t* @dev This set how the bounty reward will be paying out \n', '\t* @param 0 = pay evenly\n', '\t* @param 1 = pay fixed amount\n', '\t* @param 2 = pay various amount\n', '\t*/\n', '\tuint public payStyle = 2;\n', '\t\n', '\t/* \n', '\t* @dev False = Free version, contract creator will received the ether\n', '\t* @dev True = Paid version, client will received the ether \n', '\t*/\n', '\tbool public paidversion = true;\n', '\n', '\t/* @dev Setup the payout method\n', '\t* @param 0 = Enabled Signup Disabled Payout\n', '\t* @param 1 = Disable Signup Disable Payout\n', '\t* @param 2 = Disabled Signup Enable Payout\n', '\t* @param 3 = Enabled Signup Enabled Payout\n', '\t* @param 4 = Disabled Signup Immediate Payout\n', '\t*/\n', '\tuint public payoutNow = 4;\n', '\t\n', '\t/* @dev Fixed amount payout for each bounty */\n', '\tuint256 public fixPayAmt = 0;\n', '\t\n', '    /* @dev To record the different reward amount for each bounty  */\n', '    mapping(address => User) public bounties;\n', '\t\n', '    /* @dev to include the bounty in the list */\n', '\tmapping(address => bool) public signups;\n', '\t\n', '    /* @dev Store bounty address to blacklist */\n', '\tmapping(address => bool) public blacklist;\n', '\t\n', '    /* @dev to check is the claim in the process */\n', '\tmapping(address => bool) public isProcess;\n', '\t\n', '    /* @dev Admin with permission to manage the signed up bounty */\n', '    mapping (address => bool) public admins;\n', '\t\n', '    /* @dev Staff with permission to manage the signed up bounty */\n', '    mapping (address => bool) public staffs;\n', '\t\n', '    /**\n', '    * @dev Event for token distribution logging\n', '    * @param _address who claim the tokens\n', '    * @param _amount amount of tokens to be delivery\n', '    */\n', '    event eTokenClaim(address indexed _address, uint256 _amount);   \n', '    event eReClaimToken(uint256 _taBal, address _wallet, address _address);   \n', '    event eWalletChange(address _wallet, address indexed _address);\n', '    event eUpdatePayout(uint _payStyle, uint _payoutNow, uint256 _fixPayAmt, bool _allowsSignup, address indexed _address); \n', '    event eUpdateStartEndTime(uint _startTimes, uint _endTimes, address indexed _address); \n', '\n', '    /* \n', '    * event eAddAdmin(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveAdmin(address _newaddress, address indexed _byaddress);   \n', '    * event eAddStaff(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveStaff(address _newaddress, address indexed _byaddress);   \n', '    * event eAddBounty(address _newaddress, address indexed _byaddress);   \n', '    * event eRemoveBounty(address _address, address indexed _byaddress);   \n', '\t*/\n', '\t\n', '    /**\n', '    * @param _token Token smart contract address\n', '    * @param _wallet ETH address to reclaim unclaim tokens\n', '    */\n', '    function KahnAirDrop(ERC20 _token, uint256 _min_eth, uint256 _minsignupeth, uint _paystyle, address _wallet, uint _starttimes, uint _endtimes, uint _payoutnow, uint256 _fixpayamt, uint _maxsignup, bool _allowssignup, bool _paidversion) public {\n', '        require(_token != address(0));\n', '        token = _token;\n', '        admins[msg.sender] = true;\n', '        adminaddress.push(msg.sender) -1;\n', '        owner = msg.sender;\n', '        mineth = _min_eth;\n', '        minsignupeth = _minsignupeth;\n', '        wallet = _wallet;\n', '        payStyle = _paystyle;\n', '        startTimes = _starttimes;\n', '        endTimes = _endtimes;\n', '        payoutNow = _payoutnow;\n', '        fixPayAmt = _fixpayamt;\n', '        maxSignup = _maxsignup;\n', '        allowsSignup = _allowssignup;\n', '        paidversion = _paidversion;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '       require(msg.sender == owner);\n', '       _;\n', '    }\n', '\t\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier onlyStaffs {\n', '        require(admins[msg.sender] || staffs[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    modifier ifNotPaused {\n', '       require(!paused);\n', '       _;\n', '    }\n', '\n', '    modifier ifNotStartExp {\n', '       require(now >= startTimes && now <= endTimes);\n', '       _;\n', '    }\n', '\n', '    modifier ifNotBlacklisted {\n', '       require(!contractbacklist);\n', '       _;\n', '    }\n', '\n', '\t/*******************/\n', '\t/* Owner Function **/\n', '\t/*******************/\n', '    /* @dev Update Contract Configuration  */\n', '    function ownerUpdateToken(ERC20 _token, address _wallet) public onlyOwner{\n', '        token = _token;\n', '        wallet = _wallet;\n', '        emit eWalletChange(wallet, msg.sender);\n', '    }\n', '\n', '    /* @dev Update Contract Configuration  */\n', '    function ownerUpdateOthers(uint _maxno, bool _isBacklisted, uint256 _min_eth, uint256 _minsignupeth, bool _paidversion) public onlyOwner{\n', '        maxSignup = _maxno;\n', '        contractbacklist = _isBacklisted;\n', '        mineth = _min_eth;\n', '        minsignupeth = _minsignupeth;\n', '        paidversion = _paidversion;\n', '    }\n', '\n', '\t/* @dev Owner Retrieve Contract Configuration */\n', '    function ownerRetrieveTokenDetails() view public onlyOwner returns(ERC20, address, uint256, uint256, bool){\n', '\t\treturn(token, wallet, token.balanceOf(this), userClaimAmt, contractbacklist);\n', '    }\n', '\n', '\t/* @dev Owner Retrieve Contract Configuration */\n', '    function ownerRetrieveContractConfig2() view public onlyOwner returns(uint256, bool, uint, uint, uint, uint, uint256, uint, bool){\n', '\t\treturn(mineth, paidversion, payStyle, startTimes, endTimes, payoutNow, fixPayAmt, maxSignup, allowsSignup);\n', '    }\n', '\n', '\t/*******************/\n', '\t/* Admin Function **/\n', '\t/*******************/\n', '    /* @dev Add admin to whitelist */\n', '\tfunction addAdminWhitelist(address[] _userlist) public onlyOwner onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(!admins[baddr]){\n', '\t\t\t\t\tadmins[baddr] = true;\n', '\t\t\t\t\tadminaddress.push(baddr) -1;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Remove admin from whitelist */\n', '\tfunction removeAdminWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(admins[baddr]){\n', '\t\t\t\t\tadmins[baddr] = false;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Add staff to whitelist */\n', '\tfunction addStaffWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(!staffs[baddr]){\n', '\t\t\t\t\tstaffs[baddr] = true;\n', '\t\t\t\t\tstaffaddress.push(baddr) -1;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Remove staff from whitelist */\n', '\tfunction removeStaffWhitelist(address[] _userlist) public onlyAdmin{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(staffs[baddr]){\n', '\t\t\t\t\tstaffs[baddr] = false;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\t/* @dev Allow Admin to reclaim all unclaim tokens back to the specified wallet */\n', '\tfunction reClaimBalance() public onlyAdmin{\n', '\t\tuint256 taBal = token.balanceOf(this);\n', '\t\ttoken.transfer(wallet, taBal);\n', '\t\temit eReClaimToken(taBal, wallet, msg.sender);\n', '\t}\n', '\t\n', '\tfunction adminUpdateWallet(address _wallet) public onlyAdmin{\n', '\t\trequire(_wallet != address(0));\n', '\t\twallet = _wallet;\n', '\t\temit eWalletChange(wallet, msg.sender);\n', '\t}\n', '\n', '\tfunction adminUpdateStartEndTime(uint _startTimes, uint _endTimes) public onlyAdmin{\n', '\t\trequire(_startTimes > 0);\n', '\t\trequire(_endTimes > 0);\n', '\t\tstartTimes = _startTimes;\n', '\t\tendTimes = _endTimes;\n', '\t\temit eUpdateStartEndTime(startTimes, endTimes, msg.sender);\n', '\t}\n', '\n', '    /* @dev Update Contract Configuration  */\n', '    function adminUpdMinSign(uint256 _min_eth, uint256 _minsignupeth) public onlyAdmin{\n', '       if(paidversion){\n', '\t\t\tmineth = _min_eth;\n', '\t\t\tminsignupeth = _minsignupeth;\n', '\t   } \n', '    }\n', '\n', '\tfunction adminUpdatePayout(uint _payStyle, uint _payoutNow, uint256 _fixPayAmt, bool _allowsSignup) public onlyAdmin{\n', '\t\tpayStyle = _payStyle;\n', '\t\tpayoutNow = _payoutNow;\n', '\t\tfixPayAmt = _fixPayAmt;\n', '\t\tallowsSignup = _allowsSignup;\n', '\t\temit eUpdatePayout(payStyle, payoutNow, fixPayAmt, allowsSignup, msg.sender);\n', '\t}\n', '\n', '\t/***************************/\n', '\t/* Admin & Staff Function **/\n', '\t/***************************/\n', '\t/* @dev Admin/Staffs Update Contract Configuration */\n', '\n', '    /* @dev Add user to whitelist */\n', '    function signupUserWhitelist(address[] _userlist, uint256[] _amount) public onlyStaffs{\n', '    \trequire(_userlist.length > 0);\n', '\t\trequire(_amount.length > 0);\n', '    \tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '    \t\taddress baddr = _userlist[i];\n', '    \t\tuint256 bval = _amount[i];\n', '    \t\tif(baddr != address(0) && userSignupCount <= maxSignup){\n', '    \t\t\tif(!bounties[baddr].blacklisted && bounties[baddr].user_address != baddr){\n', '\t\t\t\t\tsignups[baddr] = true;\n', '\t\t\t\t\tbountyaddress.push(baddr) -1;\n', '\t\t\t\t\tuserSignupCount++;\n', '\t\t\t\t\tif(payoutNow==4){\n', '\t\t\t\t\t\tbounties[baddr] = User(baddr,now,0,false,now,bval,true);\n', '\t\t\t\t\t\ttoken.transfer(baddr, bval);\n', '\t\t\t\t\t\tuserClaimAmt = userClaimAmt.add(bval);\n', '\t\t\t\t\t}else{\n', '\t\t\t\t\t\tbounties[baddr] = User(baddr,now,bval,false,0,0,true);\n', '\t\t\t\t\t}\n', '    \t\t\t}\n', '    \t\t}\n', '    \t}\n', '    }\n', '\t\n', '    /* @dev Remove user from whitelist */\n', '    function removeUserWhitelist(address[] _userlist) public onlyStaffs{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0) && bounties[baddr].user_address == baddr){\n', '\t\t\t\tbounties[baddr].status = false;\n', '            \tsignups[baddr] = false;\n', '            \tuserSignupCount--;\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\t\n', '\tfunction updUserBlackList(address[] _addlist, address[] _removelist) public onlyStaffs{\n', '\t\tif(_addlist.length > 0){\n', '\t\t\tfor (uint256 i = 0; i < _addlist.length; i++) {\n', '\t\t\t\taddress baddr = _addlist[i];\n', '\t\t\t\tif(baddr != address(0) && !bounties[baddr].blacklisted){\n', '\t\t\t\t\tbounties[baddr].blacklisted = true;\n', '\t\t\t\t\tblacklist[baddr] = true;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(_removelist.length > 0){ removeUserFromBlackList(_removelist); }\n', '\t}\n', '\t\n', '\tfunction removeUserFromBlackList(address[] _userlist) internal{\n', '\t\trequire(_userlist.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tif(baddr != address(0) && bounties[baddr].blacklisted){\n', '\t\t\t\tbounties[baddr].blacklisted = false;\n', '\t\t\t\tblacklist[baddr] = false;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '    /* @dev Update Multiple Users Reward Amount */\n', '    function updateMultipleUsersReward(address[] _userlist, uint256[] _amount) public onlyStaffs{\n', '\t\trequire(_userlist.length > 0);\n', '\t\trequire(_amount.length > 0);\n', '\t\tfor (uint256 i = 0; i < _userlist.length; i++) {\n', '\t\t\taddress baddr = _userlist[i];\n', '\t\t\tuint256 bval = _amount[i];\n', '\t\t\tif(baddr != address(0)){\n', '\t\t\t\tif(bounties[baddr].user_address == baddr){\n', '\t\t\t\t\tbounties[baddr].reward_amount = bval;\n', '\t\t\t\t}else{\n', '\t\t\t\t\tif(userSignupCount <= maxSignup){\n', '\t\t\t\t\t    bounties[baddr] = User(baddr,now,bval,false,0,0,true);\n', '\t\t\t\t\t    signups[baddr] = true;\n', '\t\t\t\t\t\tbountyaddress.push(baddr) -1;\n', '\t\t\t\t\t    userSignupCount++;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\t\n', '\t/***************************/\n', '\t/* Query Display Function **/\n', '\t/***************************/\n', '    function adminRetrieveContractConfig() view public onlyStaffs returns(uint, uint, uint256, uint, bool, bool){\n', '\t\treturn(payStyle, payoutNow, fixPayAmt, maxSignup, allowsSignup, paidversion);\n', '    }\n', '\n', '    function adminRetrieveContractConfig2() view public onlyStaffs returns(uint256, uint256, address, uint, uint, uint){\n', '    \treturn(mineth, minsignupeth, wallet, startTimes, endTimes, userSignupCount);\n', '    }\n', '\n', '    function adminRetrieveContractConfig3() view public onlyStaffs returns(ERC20, uint256, uint256, uint, uint){\n', '    \tuint256 taBal = token.balanceOf(this);\n', '\t\treturn(token, taBal,userClaimAmt, now, block.number);\n', '    }\n', '\n', '\t/* @dev Check is the address is in Admin list */\n', '\tfunction chkAdmin(address _address) view public onlyAdmin returns(bool){\n', '\t\treturn admins[_address];\n', '\t}\n', '\t\n', '\t/* @dev Check is the address is in Staff list */\n', '\tfunction chkStaff(address _address) view public onlyAdmin returns(bool){\n', '\t\treturn staffs[_address];\n', '\t}\n', '\n', '\t/* @dev Return admin addresses list */\n', '\tfunction getAllAdmin() view public onlyAdmin returns(address[]){\n', '\t\treturn adminaddress;\n', '\t}\n', '\n', '\t/* @dev Return staff addresses list */\n', '\tfunction getAllStaff() view public onlyAdmin returns(address[]){\n', '\t\treturn staffaddress;\n', '\t}\n', '\n', '\t/* @dev Return list of bounty addresses */\n', '\tfunction getBountyAddress() view public onlyStaffs returns(address[]){\n', '\t\treturn bountyaddress;\n', '\t}\n', '\t\n', '\t/*  \n', '\t* @dev Check is the user is in Signed up list \n', '\t* @dev bool = address is in the signup mapping list\n', '\t* @dev uint256 = the given bounty address reward entitlement amount\n', '\t*/\n', '\tfunction chkUserDetails(address _address) view public onlyStaffs returns(address,uint,uint256,bool,uint,uint256,bool){\n', '\t\trequire(_address != address(0));\n', '\t\treturn(bounties[_address].user_address, bounties[_address].signup_time, bounties[_address].reward_amount, bounties[_address].blacklisted, bounties[_address].paid_time, bounties[_address].paid_token, bounties[_address].status);\n', '\t}\n', '\t\n', '\t/***************************/\n', '\t/* Main Contract Function **/\n', '\t/***************************/\n', '\t/* @dev Bounty send in either to execute the claim */\n', '\tfunction () external payable ifNotStartExp ifNotPaused ifNotBlacklisted{\n', '\t\trequire(!blacklist[msg.sender]);\n', '\t\tif(payoutNow == 0){\n', '\t\t\trequire(allowsSignup);\n', '\t\t\tsingleUserSignUp(msg.sender);\n', '\t\t}else if(payoutNow == 1){\n', '\t\t\trequire(allowsSignup);\n', '\t\t}else if(payoutNow == 2){\n', '\t\t\tclaimTokens(msg.sender);\n', '\t\t}else if(payoutNow == 3){\n', '\t\t\tclaimImmediateTokens(msg.sender);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction singleUserSignUp(address _address) internal ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t\tif(userSignupCount <= maxSignup){\n', '\t\t\tif(!signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth){\n', '\t\t\t\tif(payoutNow != 1 || payoutNow != 2){\n', '\t\t\t\t\tsignups[_address] = true;\n', '\t\t\t\t\tuint256 temrew = 0;\n', '\t\t\t\t\tif(payStyle == 1){ temrew = fixPayAmt; }\n', '\t\t\t\t\tbounties[_address] = User(_address,now,temrew,false,0,0,true);\n', '\t\t\t\t\tsignups[_address] = true;\n', '\t\t\t\t\tbountyaddress.push(_address) -1;\n', '\t\t\t\t\tuserSignupCount++;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\tforwardWei();\n', '\t}\n', '\t\n', '    /* @dev Bounty claim their reward tokens by sending zero ETH to this smart contract */\n', '    function claimTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t   require(msg.value >= mineth);\n', '\t   require(_beneficiary != address(0));\n', '\t   require(!blacklist[msg.sender]);\n', '\t   \n', '\t   /* @dev Check to ensure the address is not in processing to avoid double claim */\n', '       require(!isProcess[_beneficiary]);\n', '\t   \n', '\t   /* @dev Check to ensure the address is signed up to the airdrop */\n', '       require(signups[_beneficiary]);\n', '\t   \n', '\t   /* @dev Get the reward token for the given address */\n', '\t   uint256 rewardAmount = getReward(_beneficiary);\n', '\t   \n', '\t   /* @dev if the baounty reward amount is less than zero, quit the prorcess */\n', '\t   require(rewardAmount > 0);\n', '\t   \n', '\t   /* @dev get the available balance for airdrop */\n', '\t   uint256 taBal = token.balanceOf(this);\n', '\t   \n', '\t   /* @dev Check is the balance enough to pay for the claim */\n', '\t   require(rewardAmount <= taBal);\n', '\t   \n', '\t   /* @dev Set the address to processing */\n', '\t   isProcess[_beneficiary] = true;\n', '\t   \n', '\t   /* @dev Transer the token to the bounty */\n', '\t   token.transfer(_beneficiary, rewardAmount);\n', '\t   \n', '\t   /* @dev Set the bounty reward entitlement to zero */\n', '\t   bounties[_beneficiary].reward_amount = 0;\n', '\t   bounties[_beneficiary].status = true;\n', '\t   bounties[_beneficiary].paid_time = now;\n', '\t   \n', '\t   /* @dev Set the In Process to false to mark the process is completed */\n', '\t   isProcess[_beneficiary] = false;\n', '\t   \n', '\t   /* @dev Add the claim tokens to total claimed tokens */\n', '\t   userClaimAmt = userClaimAmt.add(rewardAmount);\n', '\t   \n', '\t   /* @dev Transfer the ether */\n', '\t   forwardWei();\n', '\t   \n', '\t   emit eTokenClaim(_beneficiary, rewardAmount);\n', '    }\n', '\t\n', '\t\n', '    /* @dev Bounty claim their reward tokens by sending zero ETH to this smart contract */\n', '    function claimImmediateTokens(address _beneficiary) public payable ifNotStartExp ifNotPaused ifNotBlacklisted {\n', '\t   require(msg.value >= mineth);\n', '\t   require(_beneficiary != address(0));\n', '\t   require(!blacklist[msg.sender]);\n', '\t   require(userSignupCount <= maxSignup);\n', '\t   require(fixPayAmt > 0);\n', '\t   uint256 taBal = token.balanceOf(this);\n', '\t   require(taBal > 0);\n', '\t   require(fixPayAmt <= taBal);\n', '       require(!isProcess[_beneficiary]);\n', '\t   isProcess[_beneficiary] = true;\n', '\t   signups[_beneficiary] = true;\n', '\t   bounties[_beneficiary] = User(_beneficiary,now,0,false,now,fixPayAmt,true);\n', '\t   bountyaddress.push(_beneficiary) -1;\n', '\t   userSignupCount++;\n', '\t   token.transfer(_beneficiary, fixPayAmt);\n', '\t   userClaimAmt = userClaimAmt.add(fixPayAmt);\n', '\t   forwardWei();\n', '\t   emit eTokenClaim(_beneficiary, fixPayAmt);\n', '    }\n', '\n', '    /* @dev Get Reward function based on the payout style */\n', '\tfunction getReward(address _address) internal constant returns(uint256){\n', '\t\tuint256 rtnVal = 0;\n', '\t\tif(payStyle == 0){\n', '\t\t\t/* Reward divided evenly by the total number of signed up bounty */\n', '\t\t\tuint256 taBal = token.balanceOf(this);\n', '\t\t\trtnVal = taBal.div(userSignupCount);\n', '\t\t}else if(payStyle == 1){\n', '\t\t\t// Reward for each bounty is based on Fixed amount\n', '\t\t\trtnVal = fixPayAmt;\n', '\t\t}else if(payStyle == 2){\n', '\t\t\t// Reward for each bounty is based on the amount set by the Admin when adding the bounty\n', '\t\t\trtnVal = bounties[_address].reward_amount;\n', '\t\t}\n', '\t\treturn rtnVal;\n', '\t}\n', '\t\n', '\t/* @dev Function for who will receive the paid ether */\n', '\tfunction forwardWei() internal {\n', '\t\tif(!paidversion){\n', '\t\t\t/* if paidversion is false, this is a free version, client agreed to contract creator to received the either */\n', '\t\t\t/* in exchnage to use the service for free */\n', '\t\t\tif(msg.value > 0)\n', '\t\t\t\towner.transfer(msg.value);\n', '\t\t}else{\n', '\t\t\t/* if paidversion is true, this is a paid version, received ether pay directly to client wallet */\n', '\t\t\tif(msg.value > 0)\n', '\t\t\t\twallet.transfer(msg.value);\n', '\t\t}\n', '\t}\n', '}']
