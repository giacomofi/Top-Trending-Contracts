['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/*\n', ' * @title MerkleProof\n', ' * @dev Merkle proof verification\n', ' * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\n', ' */\n', 'library MerkleProof {\n', '  /*\n', '   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n', '   * and each pair of pre-images is sorted.\n', '   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n', '   * @param _root Merkle root\n', '   * @param _leaf Leaf of Merkle tree\n', '   */\n', '  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\n', '    // Check if proof length is a multiple of 32\n', '    if (_proof.length % 32 != 0) return false;\n', '\n', '    bytes32 proofElement;\n', '    bytes32 computedHash = _leaf;\n', '\n', '    for (uint256 i = 32; i <= _proof.length; i += 32) {\n', '      assembly {\n', '        // Load the current element of the proof\n', '        proofElement := mload(add(_proof, i))\n', '      }\n', '\n', '      if (computedHash < proofElement) {\n', '        // Hash(current computed hash + current element of the proof)\n', '        computedHash = keccak256(computedHash, proofElement);\n', '      } else {\n', '        // Hash(current element of the proof + current computed hash)\n', '        computedHash = keccak256(proofElement, computedHash);\n', '      }\n', '    }\n', '\n', '    // Check if the computed hash (root) is equal to the provided root\n', '    return computedHash == _root;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MerkleMine\n', ' * @dev Token distribution based on providing Merkle proofs of inclusion in genesis state to generate allocation\n', ' */\n', 'contract MerkleMine {\n', '    using SafeMath for uint256;\n', '\n', '    // ERC20 token being distributed\n', '    ERC20 public token;\n', '    // Merkle root representing genesis state which encodes token recipients\n', '    bytes32 public genesisRoot;\n', '    // Total amount of tokens that can be generated\n', '    uint256 public totalGenesisTokens;\n', '    // Total number of recipients included in genesis state\n', '    uint256 public totalGenesisRecipients;\n', '    // Amount of tokens per recipient allocation. Equal to `totalGenesisTokens` / `totalGenesisRecipients`\n', '    uint256 public tokensPerAllocation;\n', '    // Minimum ETH balance threshold for recipients included in genesis state\n', '    uint256 public balanceThreshold;\n', '    // Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '    uint256 public genesisBlock;\n', '    // Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', '    // As the current block gets closer to `callerAllocationEndBlock`, the caller receives a larger precentage of the allocation\n', '    uint256 public callerAllocationStartBlock;\n', '    // From this block onwards, a third party caller (not the recipient) can generate and claim the recipient&#39;s full allocation\n', '    uint256 public callerAllocationEndBlock;\n', '    // Number of blocks in the caller allocation period as defined by `callerAllocationEndBlock` - `callerAllocationStartBlock`\n', '    uint256 public callerAllocationPeriod;\n', '\n', '    // Track if the generation process is started\n', '    bool public started;\n', '\n', '    // Track the already generated allocations for recipients\n', '    mapping (address => bool) public generated;\n', '\n', '    // Check that a recipient&#39;s allocation has not been generated\n', '    modifier notGenerated(address _recipient) {\n', '        require(!generated[_recipient]);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is started\n', '    modifier isStarted() {\n', '        require(started);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is not started\n', '    modifier isNotStarted() {\n', '        require(!started);\n', '        _;\n', '    }\n', '\n', '    event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\n', '\n', '    /**\n', '     * @dev MerkleMine constructor\n', '     * @param _token ERC20 token being distributed\n', '     * @param _genesisRoot Merkle root representing genesis state which encodes token recipients\n', '     * @param _totalGenesisTokens Total amount of tokens that can be generated\n', '     * @param _totalGenesisRecipients Total number of recipients included in genesis state\n', '     * @param _balanceThreshold Minimum ETH balance threshold for recipients included in genesis state\n', '     * @param _genesisBlock Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '     * @param _callerAllocationStartBlock Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', '     * @param _callerAllocationEndBlock From this block onwards, a third party caller (not the recipient) can generate and claim the recipient&#39;s full allocation\n', '     */\n', '    function MerkleMine(\n', '        address _token,\n', '        bytes32 _genesisRoot,\n', '        uint256 _totalGenesisTokens,\n', '        uint256 _totalGenesisRecipients,\n', '        uint256 _balanceThreshold,\n', '        uint256 _genesisBlock,\n', '        uint256 _callerAllocationStartBlock,\n', '        uint256 _callerAllocationEndBlock\n', '    )\n', '        public\n', '    {\n', '        // Address of token contract must not be null\n', '        require(_token != address(0));\n', '        // Number of recipients must be non-zero\n', '        require(_totalGenesisRecipients > 0);\n', '        // Genesis block must be at or before the current block\n', '        require(_genesisBlock <= block.number);\n', '        // Start block for caller allocation must be after current block\n', '        require(_callerAllocationStartBlock > block.number);\n', '        // End block for caller allocation must be after caller allocation start block\n', '        require(_callerAllocationEndBlock > _callerAllocationStartBlock);\n', '\n', '        token = ERC20(_token);\n', '        genesisRoot = _genesisRoot;\n', '        totalGenesisTokens = _totalGenesisTokens;\n', '        totalGenesisRecipients = _totalGenesisRecipients;\n', '        tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\n', '        balanceThreshold = _balanceThreshold;\n', '        genesisBlock = _genesisBlock;\n', '        callerAllocationStartBlock = _callerAllocationStartBlock;\n', '        callerAllocationEndBlock = _callerAllocationEndBlock;\n', '        callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\n', '    }\n', '\n', '    /**\n', '     * @dev Start the generation period - first checks that this contract&#39;s balance is equal to `totalGenesisTokens`\n', '     * The generation period must not already be started\n', '     */\n', '    function start() external isNotStarted {\n', '        // Check that this contract has a sufficient balance for the generation period\n', '        require(token.balanceOf(this) >= totalGenesisTokens);\n', '\n', '        started = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Generate a recipient&#39;s token allocation. Generation period must be started. Starting from `callerAllocationStartBlock`\n', '     * a third party caller (not the recipient) can invoke this function to generate the recipient&#39;s token\n', '     * allocation and claim a percentage of it. The percentage of the allocation claimed by the\n', '     * third party caller is determined by how many blocks have elapsed since `callerAllocationStartBlock`.\n', '     * After `callerAllocationEndBlock`, a third party caller can claim the full allocation\n', '     * @param _recipient Recipient of token allocation\n', '     * @param _merkleProof Proof of recipient&#39;s inclusion in genesis state Merkle root\n', '     */\n', '    function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\n', '        // Check the Merkle proof\n', '        bytes32 leaf = keccak256(_recipient);\n', '        // _merkleProof must prove inclusion of _recipient in the genesis state root\n', '        require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\n', '\n', '        generated[_recipient] = true;\n', '\n', '        address caller = msg.sender;\n', '\n', '        if (caller == _recipient) {\n', '            // If the caller is the recipient, transfer the full allocation to the caller/recipient\n', '            require(token.transfer(_recipient, tokensPerAllocation));\n', '\n', '            Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\n', '        } else {\n', '            // If the caller is not the recipient, the token allocation generation\n', '            // can only take place if we are in the caller allocation period\n', '            require(block.number >= callerAllocationStartBlock);\n', '\n', '            uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\n', '            uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\n', '\n', '            if (callerTokenAmount > 0) {\n', '                require(token.transfer(caller, callerTokenAmount));\n', '            }\n', '\n', '            if (recipientTokenAmount > 0) {\n', '                require(token.transfer(_recipient, recipientTokenAmount));\n', '            }\n', '\n', '            Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Return the amount of tokens claimable by a third party caller when generating a recipient&#39;s token allocation at a given block\n', '     * @param _blockNumber Block at which to compute the amount of tokens claimable by a third party caller\n', '     */\n', '    function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\n', '        if (_blockNumber < callerAllocationStartBlock) {\n', '            // If the block is before the start of the caller allocation period, the third party caller can claim nothing\n', '            return 0;\n', '        } else if (_blockNumber >= callerAllocationEndBlock) {\n', '            // If the block is at or after the end block of the caller allocation period, the third party caller can claim everything\n', '            return tokensPerAllocation;\n', '        } else {\n', '            // During the caller allocation period, the third party caller can claim an increasing percentage\n', '            // of the recipient&#39;s allocation based on a linear curve - as more blocks pass in the caller allocation\n', '            // period, the amount claimable by the third party caller increases linearly\n', '            uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\n', '            return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BytesUtil\n', ' * @dev Utilities for extracting bytes from byte arrays\n', ' * Functions taken from:\n', ' * - https://github.com/ethereum/solidity-examples/blob/master/src/unsafe/Memory.sol\n', ' * - https://github.com/ethereum/solidity-examples/blob/master/src/bytes/Bytes.sol\n', ' */\n', 'library BytesUtil{\n', '    uint256 internal constant BYTES_HEADER_SIZE = 32;\n', '    uint256 internal constant WORD_SIZE = 32;\n', '    \n', '    /**\n', '     * @dev Returns a memory pointer to the data portion of the provided bytes array.\n', '     * @param bts Memory byte array\n', '     */\n', '    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n', '        assembly {\n', '            addr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Copy &#39;len&#39; bytes from memory address &#39;src&#39;, to address &#39;dest&#39;.\n', '     * This function does not check the or destination, it only copies\n', '     * the bytes.\n', '     * @param src Memory address of source byte array\n', '     * @param dest Memory address of destination byte array\n', '     * @param len Number of bytes to copy from `src` to `dest`\n', '     */\n', '    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += WORD_SIZE;\n', '            src += WORD_SIZE;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Creates a &#39;bytes memory&#39; variable from the memory address &#39;addr&#39;, with the\n', '     * length &#39;len&#39;. The function will allocate new memory for the bytes array, and\n', '     * the &#39;len bytes starting at &#39;addr&#39; will be copied into that new memory.\n', '     * @param addr Memory address of input byte array\n', '     * @param len Number of bytes to copy from input byte array\n', '     */\n', '    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n', '        bts = new bytes(len);\n', '        uint256 btsptr = dataPtr(bts);\n', '        copy(addr, btsptr, len);\n', '    }\n', '    \n', '    /**\n', '     * @dev Copies &#39;len&#39; bytes from &#39;bts&#39; into a new array, starting at the provided &#39;startIndex&#39;.\n', '     * Returns the new copy.\n', '     * Requires that:\n', '     *  - &#39;startIndex + len <= self.length&#39;\n', '     * The length of the substring is: &#39;len&#39;\n', '     * @param bts Memory byte array to copy from\n', '     * @param startIndex Index of `bts` to start copying bytes from\n', '     * @param len Number of bytes to copy from `bts`\n', '     */\n', '    function substr(bytes memory bts, uint256 startIndex, uint256 len) internal pure returns (bytes memory) {\n', '        require(startIndex + len <= bts.length);\n', '        if (len == 0) {\n', '            return;\n', '        }\n', '        uint256 addr = dataPtr(bts);\n', '        return toBytes(addr + startIndex, len);\n', '    }\n', '\n', '    /**\n', '     * @dev Reads a bytes32 value from a byte array by copying 32 bytes from `bts` starting at the provided `startIndex`.\n', '     * @param bts Memory byte array to copy from\n', '     * @param startIndex Index of `bts` to start copying bytes from\n', '     */\n', '    function readBytes32(bytes memory bts, uint256 startIndex) internal pure returns (bytes32 result) {\n', '        require(startIndex + 32 <= bts.length);\n', '\n', '        uint256 addr = dataPtr(bts);\n', '\n', '        assembly {\n', '            result := mload(add(addr, startIndex))\n', '        }\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title MultiMerkleMine\n', ' * @dev The MultiMerkleMine contract is purely a convenience wrapper around an existing MerkleMine contract deployed on the blockchain.\n', ' */\n', 'contract MultiMerkleMine {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '     * @dev Generates token allocations for multiple recipients. Generation period must be started.\n', '     * @param _merkleMineContract Address of the deployed MerkleMine contract\n', '     * @param _recipients Array of recipients\n', '     * @param _merkleProofs Proofs for respective recipients constructed in the format: \n', '     *       [proof_1_size, proof_1, proof_2_size, proof_2, ... , proof_n_size, proof_n]\n', '     */\n', '\tfunction multiGenerate(address _merkleMineContract, address[] _recipients, bytes _merkleProofs) public {\n', '\t\tMerkleMine mine = MerkleMine(_merkleMineContract);\n', '\t\tERC20 token = ERC20(mine.token());\n', '\n', '\t\trequire(\n', '\t\t\tblock.number >= mine.callerAllocationStartBlock(),\n', '\t\t\t"caller allocation period has not started"\n', '\t\t);\n', '\t\t\n', '\t\tuint256 initialBalance = token.balanceOf(this);\n', '\t\tbytes[] memory proofs = new bytes[](_recipients.length);\n', '\n', '\t\t// Counter to keep track of position in `_merkleProofs` byte array\n', '\t\tuint256 i = 0;\n', '\t\t// Counter to keep track of index of each extracted Merkle proof\n', '\t\tuint256 j = 0;\n', '\n', '\t\t// Extract proofs\n', '\t\twhile(i < _merkleProofs.length){\n', '\t\t\tuint256 proofSize = uint256(BytesUtil.readBytes32(_merkleProofs, i));\n', '\n', '\t\t\trequire(\n', '\t\t\t\tproofSize % 32 == 0,\n', '\t\t\t\t"proof size must be a multiple of 32"\n', '\t\t\t);\n', '\n', '\t\t\tproofs[j] = BytesUtil.substr(_merkleProofs, i + 32, proofSize);\n', '\n', '\t\t\ti = i + 32 + proofSize;\n', '\t\t\tj++;\n', '\t\t}\n', '\n', '\t\trequire(\n', '\t\t\t_recipients.length == j,\n', '\t\t\t"number of recipients != number of proofs"\n', '\t\t);\n', '\n', '\t\tfor (uint256 k = 0; k < _recipients.length; k++) {\n', '\t\t\t// If recipient&#39;s token allocation has not been generated, generate the token allocation\n', '\t\t\t// Else, continue to the next recipient\n', '\t\t\tif (!mine.generated(_recipients[k])) {\n', '\t\t\t\tmine.generate(_recipients[k], proofs[k]);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint256 newBalanceSinceAllocation = token.balanceOf(this);\n', '\t\tuint256 callerTokensGenerated = newBalanceSinceAllocation.sub(initialBalance);\n', '\n', '\t\t// Transfer caller&#39;s portion of tokens generated by this function call \n', '\t\tif (callerTokensGenerated > 0) {\n', '\t\t\trequire(token.transfer(msg.sender, callerTokensGenerated));\n', '\t\t}\n', '\t}\n', '}']
['pragma solidity 0.4.24;\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/*\n', ' * @title MerkleProof\n', ' * @dev Merkle proof verification\n', ' * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\n', ' */\n', 'library MerkleProof {\n', '  /*\n', '   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\n', '   * and each pair of pre-images is sorted.\n', '   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\n', '   * @param _root Merkle root\n', '   * @param _leaf Leaf of Merkle tree\n', '   */\n', '  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\n', '    // Check if proof length is a multiple of 32\n', '    if (_proof.length % 32 != 0) return false;\n', '\n', '    bytes32 proofElement;\n', '    bytes32 computedHash = _leaf;\n', '\n', '    for (uint256 i = 32; i <= _proof.length; i += 32) {\n', '      assembly {\n', '        // Load the current element of the proof\n', '        proofElement := mload(add(_proof, i))\n', '      }\n', '\n', '      if (computedHash < proofElement) {\n', '        // Hash(current computed hash + current element of the proof)\n', '        computedHash = keccak256(computedHash, proofElement);\n', '      } else {\n', '        // Hash(current element of the proof + current computed hash)\n', '        computedHash = keccak256(proofElement, computedHash);\n', '      }\n', '    }\n', '\n', '    // Check if the computed hash (root) is equal to the provided root\n', '    return computedHash == _root;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title MerkleMine\n', ' * @dev Token distribution based on providing Merkle proofs of inclusion in genesis state to generate allocation\n', ' */\n', 'contract MerkleMine {\n', '    using SafeMath for uint256;\n', '\n', '    // ERC20 token being distributed\n', '    ERC20 public token;\n', '    // Merkle root representing genesis state which encodes token recipients\n', '    bytes32 public genesisRoot;\n', '    // Total amount of tokens that can be generated\n', '    uint256 public totalGenesisTokens;\n', '    // Total number of recipients included in genesis state\n', '    uint256 public totalGenesisRecipients;\n', '    // Amount of tokens per recipient allocation. Equal to `totalGenesisTokens` / `totalGenesisRecipients`\n', '    uint256 public tokensPerAllocation;\n', '    // Minimum ETH balance threshold for recipients included in genesis state\n', '    uint256 public balanceThreshold;\n', '    // Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '    uint256 public genesisBlock;\n', '    // Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', '    // As the current block gets closer to `callerAllocationEndBlock`, the caller receives a larger precentage of the allocation\n', '    uint256 public callerAllocationStartBlock;\n', "    // From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\n", '    uint256 public callerAllocationEndBlock;\n', '    // Number of blocks in the caller allocation period as defined by `callerAllocationEndBlock` - `callerAllocationStartBlock`\n', '    uint256 public callerAllocationPeriod;\n', '\n', '    // Track if the generation process is started\n', '    bool public started;\n', '\n', '    // Track the already generated allocations for recipients\n', '    mapping (address => bool) public generated;\n', '\n', "    // Check that a recipient's allocation has not been generated\n", '    modifier notGenerated(address _recipient) {\n', '        require(!generated[_recipient]);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is started\n', '    modifier isStarted() {\n', '        require(started);\n', '        _;\n', '    }\n', '\n', '    // Check that the generation period is not started\n', '    modifier isNotStarted() {\n', '        require(!started);\n', '        _;\n', '    }\n', '\n', '    event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\n', '\n', '    /**\n', '     * @dev MerkleMine constructor\n', '     * @param _token ERC20 token being distributed\n', '     * @param _genesisRoot Merkle root representing genesis state which encodes token recipients\n', '     * @param _totalGenesisTokens Total amount of tokens that can be generated\n', '     * @param _totalGenesisRecipients Total number of recipients included in genesis state\n', '     * @param _balanceThreshold Minimum ETH balance threshold for recipients included in genesis state\n', '     * @param _genesisBlock Block number of genesis - used to determine which ETH accounts are included in the genesis state\n', '     * @param _callerAllocationStartBlock Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\n', "     * @param _callerAllocationEndBlock From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\n", '     */\n', '    function MerkleMine(\n', '        address _token,\n', '        bytes32 _genesisRoot,\n', '        uint256 _totalGenesisTokens,\n', '        uint256 _totalGenesisRecipients,\n', '        uint256 _balanceThreshold,\n', '        uint256 _genesisBlock,\n', '        uint256 _callerAllocationStartBlock,\n', '        uint256 _callerAllocationEndBlock\n', '    )\n', '        public\n', '    {\n', '        // Address of token contract must not be null\n', '        require(_token != address(0));\n', '        // Number of recipients must be non-zero\n', '        require(_totalGenesisRecipients > 0);\n', '        // Genesis block must be at or before the current block\n', '        require(_genesisBlock <= block.number);\n', '        // Start block for caller allocation must be after current block\n', '        require(_callerAllocationStartBlock > block.number);\n', '        // End block for caller allocation must be after caller allocation start block\n', '        require(_callerAllocationEndBlock > _callerAllocationStartBlock);\n', '\n', '        token = ERC20(_token);\n', '        genesisRoot = _genesisRoot;\n', '        totalGenesisTokens = _totalGenesisTokens;\n', '        totalGenesisRecipients = _totalGenesisRecipients;\n', '        tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\n', '        balanceThreshold = _balanceThreshold;\n', '        genesisBlock = _genesisBlock;\n', '        callerAllocationStartBlock = _callerAllocationStartBlock;\n', '        callerAllocationEndBlock = _callerAllocationEndBlock;\n', '        callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\n', '    }\n', '\n', '    /**\n', "     * @dev Start the generation period - first checks that this contract's balance is equal to `totalGenesisTokens`\n", '     * The generation period must not already be started\n', '     */\n', '    function start() external isNotStarted {\n', '        // Check that this contract has a sufficient balance for the generation period\n', '        require(token.balanceOf(this) >= totalGenesisTokens);\n', '\n', '        started = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Generate a recipient's token allocation. Generation period must be started. Starting from `callerAllocationStartBlock`\n", "     * a third party caller (not the recipient) can invoke this function to generate the recipient's token\n", '     * allocation and claim a percentage of it. The percentage of the allocation claimed by the\n', '     * third party caller is determined by how many blocks have elapsed since `callerAllocationStartBlock`.\n', '     * After `callerAllocationEndBlock`, a third party caller can claim the full allocation\n', '     * @param _recipient Recipient of token allocation\n', "     * @param _merkleProof Proof of recipient's inclusion in genesis state Merkle root\n", '     */\n', '    function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\n', '        // Check the Merkle proof\n', '        bytes32 leaf = keccak256(_recipient);\n', '        // _merkleProof must prove inclusion of _recipient in the genesis state root\n', '        require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\n', '\n', '        generated[_recipient] = true;\n', '\n', '        address caller = msg.sender;\n', '\n', '        if (caller == _recipient) {\n', '            // If the caller is the recipient, transfer the full allocation to the caller/recipient\n', '            require(token.transfer(_recipient, tokensPerAllocation));\n', '\n', '            Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\n', '        } else {\n', '            // If the caller is not the recipient, the token allocation generation\n', '            // can only take place if we are in the caller allocation period\n', '            require(block.number >= callerAllocationStartBlock);\n', '\n', '            uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\n', '            uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\n', '\n', '            if (callerTokenAmount > 0) {\n', '                require(token.transfer(caller, callerTokenAmount));\n', '            }\n', '\n', '            if (recipientTokenAmount > 0) {\n', '                require(token.transfer(_recipient, recipientTokenAmount));\n', '            }\n', '\n', '            Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Return the amount of tokens claimable by a third party caller when generating a recipient's token allocation at a given block\n", '     * @param _blockNumber Block at which to compute the amount of tokens claimable by a third party caller\n', '     */\n', '    function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\n', '        if (_blockNumber < callerAllocationStartBlock) {\n', '            // If the block is before the start of the caller allocation period, the third party caller can claim nothing\n', '            return 0;\n', '        } else if (_blockNumber >= callerAllocationEndBlock) {\n', '            // If the block is at or after the end block of the caller allocation period, the third party caller can claim everything\n', '            return tokensPerAllocation;\n', '        } else {\n', '            // During the caller allocation period, the third party caller can claim an increasing percentage\n', "            // of the recipient's allocation based on a linear curve - as more blocks pass in the caller allocation\n", '            // period, the amount claimable by the third party caller increases linearly\n', '            uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\n', '            return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BytesUtil\n', ' * @dev Utilities for extracting bytes from byte arrays\n', ' * Functions taken from:\n', ' * - https://github.com/ethereum/solidity-examples/blob/master/src/unsafe/Memory.sol\n', ' * - https://github.com/ethereum/solidity-examples/blob/master/src/bytes/Bytes.sol\n', ' */\n', 'library BytesUtil{\n', '    uint256 internal constant BYTES_HEADER_SIZE = 32;\n', '    uint256 internal constant WORD_SIZE = 32;\n', '    \n', '    /**\n', '     * @dev Returns a memory pointer to the data portion of the provided bytes array.\n', '     * @param bts Memory byte array\n', '     */\n', '    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n', '        assembly {\n', '            addr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\n', '        }\n', '    }\n', '    \n', '    /**\n', "     * @dev Copy 'len' bytes from memory address 'src', to address 'dest'.\n", '     * This function does not check the or destination, it only copies\n', '     * the bytes.\n', '     * @param src Memory address of source byte array\n', '     * @param dest Memory address of destination byte array\n', '     * @param len Number of bytes to copy from `src` to `dest`\n', '     */\n', '    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += WORD_SIZE;\n', '            src += WORD_SIZE;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Creates a 'bytes memory' variable from the memory address 'addr', with the\n", "     * length 'len'. The function will allocate new memory for the bytes array, and\n", "     * the 'len bytes starting at 'addr' will be copied into that new memory.\n", '     * @param addr Memory address of input byte array\n', '     * @param len Number of bytes to copy from input byte array\n', '     */\n', '    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n', '        bts = new bytes(len);\n', '        uint256 btsptr = dataPtr(bts);\n', '        copy(addr, btsptr, len);\n', '    }\n', '    \n', '    /**\n', "     * @dev Copies 'len' bytes from 'bts' into a new array, starting at the provided 'startIndex'.\n", '     * Returns the new copy.\n', '     * Requires that:\n', "     *  - 'startIndex + len <= self.length'\n", "     * The length of the substring is: 'len'\n", '     * @param bts Memory byte array to copy from\n', '     * @param startIndex Index of `bts` to start copying bytes from\n', '     * @param len Number of bytes to copy from `bts`\n', '     */\n', '    function substr(bytes memory bts, uint256 startIndex, uint256 len) internal pure returns (bytes memory) {\n', '        require(startIndex + len <= bts.length);\n', '        if (len == 0) {\n', '            return;\n', '        }\n', '        uint256 addr = dataPtr(bts);\n', '        return toBytes(addr + startIndex, len);\n', '    }\n', '\n', '    /**\n', '     * @dev Reads a bytes32 value from a byte array by copying 32 bytes from `bts` starting at the provided `startIndex`.\n', '     * @param bts Memory byte array to copy from\n', '     * @param startIndex Index of `bts` to start copying bytes from\n', '     */\n', '    function readBytes32(bytes memory bts, uint256 startIndex) internal pure returns (bytes32 result) {\n', '        require(startIndex + 32 <= bts.length);\n', '\n', '        uint256 addr = dataPtr(bts);\n', '\n', '        assembly {\n', '            result := mload(add(addr, startIndex))\n', '        }\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title MultiMerkleMine\n', ' * @dev The MultiMerkleMine contract is purely a convenience wrapper around an existing MerkleMine contract deployed on the blockchain.\n', ' */\n', 'contract MultiMerkleMine {\n', '\tusing SafeMath for uint256;\n', '\n', '\t/**\n', '     * @dev Generates token allocations for multiple recipients. Generation period must be started.\n', '     * @param _merkleMineContract Address of the deployed MerkleMine contract\n', '     * @param _recipients Array of recipients\n', '     * @param _merkleProofs Proofs for respective recipients constructed in the format: \n', '     *       [proof_1_size, proof_1, proof_2_size, proof_2, ... , proof_n_size, proof_n]\n', '     */\n', '\tfunction multiGenerate(address _merkleMineContract, address[] _recipients, bytes _merkleProofs) public {\n', '\t\tMerkleMine mine = MerkleMine(_merkleMineContract);\n', '\t\tERC20 token = ERC20(mine.token());\n', '\n', '\t\trequire(\n', '\t\t\tblock.number >= mine.callerAllocationStartBlock(),\n', '\t\t\t"caller allocation period has not started"\n', '\t\t);\n', '\t\t\n', '\t\tuint256 initialBalance = token.balanceOf(this);\n', '\t\tbytes[] memory proofs = new bytes[](_recipients.length);\n', '\n', '\t\t// Counter to keep track of position in `_merkleProofs` byte array\n', '\t\tuint256 i = 0;\n', '\t\t// Counter to keep track of index of each extracted Merkle proof\n', '\t\tuint256 j = 0;\n', '\n', '\t\t// Extract proofs\n', '\t\twhile(i < _merkleProofs.length){\n', '\t\t\tuint256 proofSize = uint256(BytesUtil.readBytes32(_merkleProofs, i));\n', '\n', '\t\t\trequire(\n', '\t\t\t\tproofSize % 32 == 0,\n', '\t\t\t\t"proof size must be a multiple of 32"\n', '\t\t\t);\n', '\n', '\t\t\tproofs[j] = BytesUtil.substr(_merkleProofs, i + 32, proofSize);\n', '\n', '\t\t\ti = i + 32 + proofSize;\n', '\t\t\tj++;\n', '\t\t}\n', '\n', '\t\trequire(\n', '\t\t\t_recipients.length == j,\n', '\t\t\t"number of recipients != number of proofs"\n', '\t\t);\n', '\n', '\t\tfor (uint256 k = 0; k < _recipients.length; k++) {\n', "\t\t\t// If recipient's token allocation has not been generated, generate the token allocation\n", '\t\t\t// Else, continue to the next recipient\n', '\t\t\tif (!mine.generated(_recipients[k])) {\n', '\t\t\t\tmine.generate(_recipients[k], proofs[k]);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tuint256 newBalanceSinceAllocation = token.balanceOf(this);\n', '\t\tuint256 callerTokensGenerated = newBalanceSinceAllocation.sub(initialBalance);\n', '\n', "\t\t// Transfer caller's portion of tokens generated by this function call \n", '\t\tif (callerTokensGenerated > 0) {\n', '\t\t\trequire(token.transfer(msg.sender, callerTokensGenerated));\n', '\t\t}\n', '\t}\n', '}']
