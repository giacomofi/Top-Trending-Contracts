['pragma solidity 0.4.24;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "Assertion Failed");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "Assertion Failed");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface AddressRegistry {\n', '    function getAddr(string name) external view returns(address);\n', '}\n', '\n', 'interface MakerCDP {\n', '    function open() external returns (bytes32 cup);\n', '    function join(uint wad) external; // Join PETH\n', '    function exit(uint wad) external; // Exit PETH\n', '    function give(bytes32 cup, address guy) external;\n', '    function lock(bytes32 cup, uint wad) external;\n', '    function free(bytes32 cup, uint wad) external;\n', '    function draw(bytes32 cup, uint wad) external;\n', '    function wipe(bytes32 cup, uint wad) external;\n', '    function per() external view returns (uint ray);\n', '}\n', '\n', 'interface PriceInterface {\n', '    function peek() external view returns (bytes32, bool);\n', '}\n', '\n', 'interface WETHFace {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', 'interface InstaKyber {\n', '    function executeTrade(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt,\n', '        uint minConversionRate,\n', '        uint maxDestAmt\n', '    ) external payable returns (uint destAmt);\n', '\n', '    function getExpectedPrice(\n', '        address src,\n', '        address dest,\n', '        uint srcAmt\n', '    ) external view returns (uint, uint);\n', '}\n', '\n', '\n', 'contract Registry {\n', '\n', '    address public addressRegistry;\n', '    modifier onlyAdmin() {\n', '        require(\n', '            msg.sender == getAddress("admin"),\n', '            "Permission Denied"\n', '        );\n', '        _;\n', '    }\n', '    \n', '    function getAddress(string name) internal view returns(address) {\n', '        AddressRegistry addrReg = AddressRegistry(addressRegistry);\n', '        return addrReg.getAddr(name);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GlobalVar is Registry {\n', '\n', '    using SafeMath for uint;\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 blankCDP = 0x0000000000000000000000000000000000000000000000000000000000000000;\n', '    address cdpAddr; // cups\n', '    mapping (address => bytes32) cdps; // borrower >>> CDP Bytes\n', '    bool public freezed;\n', '\n', '}\n', '\n', '\n', 'contract IssueLoan is GlobalVar {\n', '\n', '    event LockedETH(address borrower, uint lockETH, uint lockPETH, address lockedBy);\n', '    event LoanedDAI(address borrower, uint loanDAI);\n', '    event NewCDP(address borrower, bytes32 cdpBytes);\n', '\n', '    function pethPEReth(uint ethNum) public view returns (uint rPETH) {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        rPETH = (ethNum.mul(10 ** 27)).div(loanMaster.per());\n', '    }\n', '\n', '    function borrow(uint daiDraw) public payable {\n', '        if (msg.value > 0) {lockETH(msg.sender);}\n', '        if (daiDraw > 0) {drawDAI(daiDraw);}\n', '    }\n', '\n', '    function lockETH(address borrower) public payable {\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        if (cdps[borrower] == blankCDP) {\n', '            require(msg.sender == borrower, "Creating CDP for others is not permitted at the moment.");\n', '            cdps[msg.sender] = loanMaster.open();\n', '            emit NewCDP(msg.sender, cdps[msg.sender]);\n', '        }\n', '        WETHFace wethTkn = WETHFace(getAddress("weth"));\n', '        wethTkn.deposit.value(msg.value)(); // ETH to WETH\n', '        uint pethToLock = pethPEReth(msg.value);\n', '        loanMaster.join(pethToLock); // WETH to PETH\n', '        loanMaster.lock(cdps[borrower], pethToLock); // PETH to CDP\n', '        emit LockedETH(\n', '            borrower, msg.value, pethToLock, msg.sender\n', '        );\n', '    }\n', '\n', '    function drawDAI(uint daiDraw) public {\n', '        require(!freezed, "Operation Disabled");\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.draw(cdps[msg.sender], daiDraw);\n', '        IERC20 daiTkn = IERC20(getAddress("dai"));\n', '        daiTkn.transfer(msg.sender, daiDraw);\n', '        emit LoanedDAI(msg.sender, daiDraw);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract RepayLoan is IssueLoan {\n', '\n', '    event WipedDAI(address borrower, uint daiWipe, uint mkrCharged, address wipedBy);\n', '    event UnlockedETH(address borrower, uint ethFree);\n', '\n', '    function repay(uint daiWipe, uint ethFree) public payable {\n', '        if (daiWipe > 0) {wipeDAI(daiWipe, msg.sender);}\n', '        if (ethFree > 0) {unlockETH(ethFree);}\n', '    }\n', '\n', '    function wipeDAI(uint daiWipe, address borrower) public payable {\n', '        address dai = getAddress("dai");\n', '        address mkr = getAddress("mkr");\n', '        address eth = getAddress("eth");\n', '\n', '        IERC20 daiTkn = IERC20(dai);\n', '        IERC20 mkrTkn = IERC20(mkr);\n', '\n', '        uint contractMKR = mkrTkn.balanceOf(address(this)); // contract MKR balance before wiping\n', '        daiTkn.transferFrom(msg.sender, address(this), daiWipe); // get DAI to pay the debt\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.wipe(cdps[borrower], daiWipe); // wipe DAI\n', '        uint mkrCharged = contractMKR - mkrTkn.balanceOf(address(this)); // MKR fee = before wiping bal - after wiping bal\n', '\n', '        // claiming paid MKR back\n', '        if (msg.value > 0) { // Interacting with Kyber to swap ETH with MKR\n', '            swapETHMKR(\n', '                eth, mkr, mkrCharged, msg.value\n', '            );\n', '        } else { // take MKR directly from address\n', '            mkrTkn.transferFrom(msg.sender, address(this), mkrCharged); // user paying MKR fees\n', '        }\n', '\n', '        emit WipedDAI(\n', '            borrower, daiWipe, mkrCharged, msg.sender\n', '        );\n', '    }\n', '\n', '    function unlockETH(uint ethFree) public {\n', '        require(!freezed, "Operation Disabled");\n', '        uint pethToUnlock = pethPEReth(ethFree);\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.free(cdps[msg.sender], pethToUnlock); // CDP to PETH\n', '        loanMaster.exit(pethToUnlock); // PETH to WETH\n', '        WETHFace wethTkn = WETHFace(getAddress("weth"));\n', '        wethTkn.withdraw(ethFree); // WETH to ETH\n', '        msg.sender.transfer(ethFree);\n', '        emit UnlockedETH(msg.sender, ethFree);\n', '    }\n', '\n', '    function swapETHMKR(\n', '        address eth,\n', '        address mkr,\n', '        uint mkrCharged,\n', '        uint ethQty\n', '    ) internal \n', '    {\n', '        InstaKyber instak = InstaKyber(getAddress("InstaKyber"));\n', '        uint minRate;\n', '        (, minRate) = instak.getExpectedPrice(eth, mkr, ethQty);\n', '        uint mkrBought = instak.executeTrade.value(ethQty)(\n', '            eth, mkr, ethQty, minRate, mkrCharged\n', '        );\n', '        require(mkrCharged == mkrBought, "ETH not sufficient to cover the MKR fees.");\n', '        if (address(this).balance > 0) {\n', '            msg.sender.transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract BorrowTasks is RepayLoan {\n', '\n', '    event TranferCDP(bytes32 cdp, address owner, address nextOwner);\n', '\n', '    function transferCDP(address nextOwner) public {\n', '        require(nextOwner != 0, "Invalid Address.");\n', '        MakerCDP loanMaster = MakerCDP(cdpAddr);\n', '        loanMaster.give(cdps[msg.sender], nextOwner);\n', '        cdps[msg.sender] = blankCDP;\n', '        emit TranferCDP(cdps[msg.sender], msg.sender, nextOwner);\n', '    }\n', '\n', '    function getETHRate() public view returns (uint) {\n', '        PriceInterface ethRate = PriceInterface(getAddress("ethfeed"));\n', '        bytes32 ethrate;\n', '        (ethrate, ) = ethRate.peek();\n', '        return uint(ethrate);\n', '    }\n', '\n', '    function getCDP(address borrower) public view returns (uint, bytes32) {\n', '        return (uint(cdps[borrower]), cdps[borrower]);\n', '    }\n', '\n', '    function approveERC20() public {\n', '        IERC20 wethTkn = IERC20(getAddress("weth"));\n', '        wethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 pethTkn = IERC20(getAddress("peth"));\n', '        pethTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 mkrTkn = IERC20(getAddress("mkr"));\n', '        mkrTkn.approve(cdpAddr, 2**256 - 1);\n', '        IERC20 daiTkn = IERC20(getAddress("dai"));\n', '        daiTkn.approve(cdpAddr, 2**256 - 1);\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract InstaMaker is BorrowTasks {\n', '\n', '    event MKRCollected(uint amount);\n', '\n', '    constructor(address rAddr) public {\n', '        addressRegistry = rAddr;\n', '        cdpAddr = getAddress("cdp");\n', '        approveERC20();\n', '    }\n', '\n', '    function () public payable {}\n', '\n', '    function freeze(bool stop) public onlyAdmin {\n', '        freezed = stop;\n', '    }\n', '\n', '    // collecting MKR token kept as balance to pay fees\n', '    function collectMKR(uint amount) public onlyAdmin {\n', '        IERC20 mkrTkn = IERC20(getAddress("mkr"));\n', '        mkrTkn.transfer(msg.sender, amount);\n', '        emit MKRCollected(amount);\n', '    }\n', '\n', '}']