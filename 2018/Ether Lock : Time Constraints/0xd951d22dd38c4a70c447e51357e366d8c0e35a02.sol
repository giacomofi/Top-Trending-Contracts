['pragma solidity ^0.4.21;\n', '\n', 'contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract MNY {\n', '\n', '    string public name = "MNY by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "MNY";\n', '\n', '    address public owner;\n', '    address public exchangeAdmin;\n', '\n', '    uint256[] tierTokens = [\n', '        5.33696E18,\n', '        7.69493333E18,\n', '        4.75684324E18,\n', '        6.30846753E18,\n', '        6.21620513E18,\n', '        5.63157219E18,\n', '        5.80023669E18,\n', '        5.04458667E18,\n', '        4.58042767E18,\n', '        5E18\n', '    ];\n', '\n', '    uint256[] costPerToken = [\n', '        9E16,\n', '        9E16,\n', '        8E16,\n', '        7E16,\n', '        8E16,\n', '        5E16,\n', '        6E16,\n', '        5E16,\n', '        5E16,\n', '        6E16\n', '    ];\n', '\n', '    // used to store list of contracts MNY holds tokens in\n', '    address[] contracts = [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0];\n', '\n', '    uint tierLevel = 0;\n', '    uint maxTier = 9;\n', '    uint256 totalSupply = 21000000000000000000000000;\n', '    uint256 circulatingSupply = 0;\n', '    uint contractCount = 1;\n', '\n', '    // flags\n', '    bool public receiveEth = true;\n', '    bool swap = false;\n', '    bool allSwapped = false;\n', '    bool distributionCalculated = false;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public tokenBalances;\n', '    mapping (address => uint256) public tokenShare;\n', '    mapping (address => uint256) public exchangeRates; // balance and rate in cents (where $1 = 1*10^18)\n', '\n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    function MNY() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                totalSupply = add(totalSupply, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) allSwapped = true;\n', '                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                require(div(_value, 1 ether) > 0);   // whole tokens only in for swap\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, div(_value, 1 ether));\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                totalSupply = add(totalSupply, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) allSwapped = true;\n', '                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, div(_value, 1 ether));\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted, address _recipient) internal {\n', '        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\n', '        uint256 _allocation = 0;\n', '\n', '        if(_submitted >= _availableInTier) {\n', '            _allocation = tierTokens[tierLevel];\n', '            tierTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            if(tierLevel > maxTier) {\n', '                swap = true;\n', '            }\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '        else {\n', '            uint256 stepOne = mul(_submitted, 1 ether);\n', '            uint256 stepTwo = div(stepOne, costPerToken[tierLevel]);\n', '            uint256 _tokens = stepTwo;\n', '            _allocation = add(_allocation, _tokens);\n', '            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '\n', '        // transfer tokens allocated so far to wallet address from contract\n', '        balances[_recipient] = add(balances[_recipient],_allocation);\n', '        circulatingSupply = add(circulatingSupply, _allocation);\n', '        totalSupply = sub(totalSupply, _allocation);\n', '\n', '        if((_submitted != 0) && (tierLevel <= maxTier)) {\n', '            allocateTokens(_submitted, _recipient);\n', '        }\n', '        else {\n', '            // emit transfer event\n', '            Transfer(this, _recipient, balances[_recipient]);\n', '        }\n', '    }\n', '\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _sentTokens) public {\n', '\n', '        require(exchangeRates[msg.sender] > 0);\n', '        uint256 _exchanged = mul(_sentTokens, exchangeRates[_source]);\n', '\n', '        require(_exchanged <= mul(totalSupply, 1 ether));\n', '        allocateTokens(_exchanged, _recipient);\n', '    }\n', '\n', '    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) {\n', '        require(msg.sender == owner);\n', '        // check that _partner is a contract address\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_partner)\n', '        }\n', '        require(codeLength > 0);\n', '        exchangeRates[_partner] = _rate;\n', '\n', '        bool isContract = existingContract(_partner);\n', '        if(isContract == false) {\n', '            contractCount++;\n', '            contracts[contractCount] = _partner;\n', '        }\n', '    }\n', '\n', '    // public data retrieval funcs\n', '    function getTotalSupply() public constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function getCirculatingSupply() public constant returns (uint256) {\n', '        return circulatingSupply;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return tierTokens[tierLevel];\n', '    }\n', '\n', '    function balanceInSpecificTier(uint tier) public constant returns (uint256) {\n', '        return tierTokens[tier];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    // admin functions\n', '    function convertTransferredTokensToMny(uint256 _value, address _recipient, address _source, uint256 _originalAmount) public {\n', '        // allows tokens transferred in for exchange to be converted to MNY and distributed\n', '        // COE is able to interact directly with contract - other exchange partners cannot\n', '        require((msg.sender == owner) || (msg.sender == exchangeAdmin));\n', '        require(exchangeRates[_source] > 0);\n', '        maintainExternalContractTokenBalance(_source, _originalAmount);\n', '        allocateTokens(_value, _recipient);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeExchangeAdmin(address _newAdmin) public {\n', '        require(msg.sender == owner);\n', '        exchangeAdmin = _newAdmin;\n', '    }\n', '\n', '    function maintainExternalContractTokenBalance(address _contract, uint256 _tokens) internal {\n', '        tokenBalances[_contract] = add(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function getTokenBalance(address _contract) public constant returns (uint256) {\n', '        return tokenBalances[_contract];\n', '    }\n', '\n', '    function calculateHeldTokenDistribution() public {\n', '        require(swap = true);\n', '        for(uint i=0; i<contractCount; i++) {\n', '//            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], div(add(totalSupply, circulatingSupply), 1 ether));\n', '            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], circulatingSupply);\n', '        }\n', '        distributionCalculated = true;\n', '    }\n', '\n', '    function tokenShare(address _contract) public constant returns (uint256) {\n', '        return tokenShare[_contract];\n', '    }\n', '\n', '    function shareStoredTokens(address _recipient, uint256 mny) internal {\n', '        Target t;\n', '        uint256 share = 0;\n', '        for(uint i=0; i<contractCount; i++) {\n', '            share = mul(mny, tokenShare[contracts[i]]);\n', '\n', '            t = Target(contracts[i]);\n', '            t.transfer(_recipient, share);\n', '        }\n', '    }\n', '\n', '    function distributeMnyAfterSwap(address _recipient, uint256 _tokens) public {\n', '        require(msg.sender == owner);\n', '        require(totalSupply <= _tokens);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '        totalSupply = sub(totalSupply, _tokens);\n', '        circulatingSupply = add(circulatingSupply, _tokens);\n', '    }\n', '\n', '    function existingContract(address _contract) internal returns (bool) {\n', '        for(uint i=0; i<contractCount; i++) {\n', '            if(contracts[i] == _contract) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function contractExchangeRate(address _contract) public constant returns (uint256) {\n', '        return exchangeRates[_contract];\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', 'contract Partner {\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _RequestedTokens);\n', '}\n', '\n', 'contract Target {\n', '    function transfer(address _to, uint _value);\n', '}\n', '\n', 'contract MNY {\n', '\n', '    string public name = "MNY by Monkey Capital";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "MNY";\n', '\n', '    address public owner;\n', '    address public exchangeAdmin;\n', '\n', '    uint256[] tierTokens = [\n', '        5.33696E18,\n', '        7.69493333E18,\n', '        4.75684324E18,\n', '        6.30846753E18,\n', '        6.21620513E18,\n', '        5.63157219E18,\n', '        5.80023669E18,\n', '        5.04458667E18,\n', '        4.58042767E18,\n', '        5E18\n', '    ];\n', '\n', '    uint256[] costPerToken = [\n', '        9E16,\n', '        9E16,\n', '        8E16,\n', '        7E16,\n', '        8E16,\n', '        5E16,\n', '        6E16,\n', '        5E16,\n', '        5E16,\n', '        6E16\n', '    ];\n', '\n', '    // used to store list of contracts MNY holds tokens in\n', '    address[] contracts = [0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0];\n', '\n', '    uint tierLevel = 0;\n', '    uint maxTier = 9;\n', '    uint256 totalSupply = 21000000000000000000000000;\n', '    uint256 circulatingSupply = 0;\n', '    uint contractCount = 1;\n', '\n', '    // flags\n', '    bool public receiveEth = true;\n', '    bool swap = false;\n', '    bool allSwapped = false;\n', '    bool distributionCalculated = false;\n', '\n', '    // Storage\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => uint256) public tokenBalances;\n', '    mapping (address => uint256) public tokenShare;\n', '    mapping (address => uint256) public exchangeRates; // balance and rate in cents (where $1 = 1*10^18)\n', '\n', '    // events\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    function MNY() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                totalSupply = add(totalSupply, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) allSwapped = true;\n', '                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                require(div(_value, 1 ether) > 0);   // whole tokens only in for swap\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, div(_value, 1 ether));\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public {\n', '        // sender must have enough tokens to transfer\n', '        require(balances[msg.sender] >= _value);\n', '\n', '        if(_to == address(this)) {\n', '            if(swap == false) {\n', '                // WARNING: if you transfer tokens back to the contract outside of the swap you will lose them\n', '                // use the exchange function to exchange for tokens with approved partner contracts\n', '                totalSupply = add(totalSupply, _value);\n', '                circulatingSupply = sub(circulatingSupply, _value);\n', '                if(circulatingSupply == 0) allSwapped = true;\n', '                tierTokens[maxTier] = add(tierTokens[maxTier], _value);\n', '                balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '                Transfer(msg.sender, _to, _value);\n', '            }\n', '            else {\n', '                if(distributionCalculated = false) {\n', '                    calculateHeldTokenDistribution();\n', '                }\n', '                balances[msg.sender] = sub(balances[msg.sender], _value);\n', '                shareStoredTokens(msg.sender, div(_value, 1 ether));\n', '            }\n', '        }\n', '        else {\n', '            // WARNING: if you transfer tokens to a contract address they will be lost unless the contract\n', '            // has been designed to handle incoming/holding tokens in other contracts\n', '            balances[msg.sender] = sub(balanceOf(msg.sender), _value);\n', '            balances[_to] = add(balances[_to], _value);\n', '\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function allocateTokens(uint256 _submitted, address _recipient) internal {\n', '        uint256 _availableInTier = mul(tierTokens[tierLevel], costPerToken[tierLevel]);\n', '        uint256 _allocation = 0;\n', '\n', '        if(_submitted >= _availableInTier) {\n', '            _allocation = tierTokens[tierLevel];\n', '            tierTokens[tierLevel] = 0;\n', '            tierLevel++;\n', '            if(tierLevel > maxTier) {\n', '                swap = true;\n', '            }\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '        else {\n', '            uint256 stepOne = mul(_submitted, 1 ether);\n', '            uint256 stepTwo = div(stepOne, costPerToken[tierLevel]);\n', '            uint256 _tokens = stepTwo;\n', '            _allocation = add(_allocation, _tokens);\n', '            tierTokens[tierLevel] = sub(tierTokens[tierLevel], _tokens);\n', '            _submitted = sub(_submitted, _availableInTier);\n', '        }\n', '\n', '        // transfer tokens allocated so far to wallet address from contract\n', '        balances[_recipient] = add(balances[_recipient],_allocation);\n', '        circulatingSupply = add(circulatingSupply, _allocation);\n', '        totalSupply = sub(totalSupply, _allocation);\n', '\n', '        if((_submitted != 0) && (tierLevel <= maxTier)) {\n', '            allocateTokens(_submitted, _recipient);\n', '        }\n', '        else {\n', '            // emit transfer event\n', '            Transfer(this, _recipient, balances[_recipient]);\n', '        }\n', '    }\n', '\n', '    function exchangeTokensFromOtherContract(address _source, address _recipient, uint256 _sentTokens) public {\n', '\n', '        require(exchangeRates[msg.sender] > 0);\n', '        uint256 _exchanged = mul(_sentTokens, exchangeRates[_source]);\n', '\n', '        require(_exchanged <= mul(totalSupply, 1 ether));\n', '        allocateTokens(_exchanged, _recipient);\n', '    }\n', '\n', '    function addExchangePartnerAddressAndRate(address _partner, uint256 _rate) {\n', '        require(msg.sender == owner);\n', '        // check that _partner is a contract address\n', '        uint codeLength;\n', '        assembly {\n', '            codeLength := extcodesize(_partner)\n', '        }\n', '        require(codeLength > 0);\n', '        exchangeRates[_partner] = _rate;\n', '\n', '        bool isContract = existingContract(_partner);\n', '        if(isContract == false) {\n', '            contractCount++;\n', '            contracts[contractCount] = _partner;\n', '        }\n', '    }\n', '\n', '    // public data retrieval funcs\n', '    function getTotalSupply() public constant returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function getCirculatingSupply() public constant returns (uint256) {\n', '        return circulatingSupply;\n', '    }\n', '\n', '    function balanceOf(address _receiver) public constant returns (uint256) {\n', '        return balances[_receiver];\n', '    }\n', '\n', '    function balanceInTier() public constant returns (uint256) {\n', '        return tierTokens[tierLevel];\n', '    }\n', '\n', '    function balanceInSpecificTier(uint tier) public constant returns (uint256) {\n', '        return tierTokens[tier];\n', '    }\n', '\n', '    function currentTier() public constant returns (uint256) {\n', '        return tierLevel;\n', '    }\n', '\n', '    // admin functions\n', '    function convertTransferredTokensToMny(uint256 _value, address _recipient, address _source, uint256 _originalAmount) public {\n', '        // allows tokens transferred in for exchange to be converted to MNY and distributed\n', '        // COE is able to interact directly with contract - other exchange partners cannot\n', '        require((msg.sender == owner) || (msg.sender == exchangeAdmin));\n', '        require(exchangeRates[_source] > 0);\n', '        maintainExternalContractTokenBalance(_source, _originalAmount);\n', '        allocateTokens(_value, _recipient);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public {\n', '        require(msg.sender == owner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '    function changeExchangeAdmin(address _newAdmin) public {\n', '        require(msg.sender == owner);\n', '        exchangeAdmin = _newAdmin;\n', '    }\n', '\n', '    function maintainExternalContractTokenBalance(address _contract, uint256 _tokens) internal {\n', '        tokenBalances[_contract] = add(tokenBalances[_contract], _tokens);\n', '    }\n', '\n', '    function getTokenBalance(address _contract) public constant returns (uint256) {\n', '        return tokenBalances[_contract];\n', '    }\n', '\n', '    function calculateHeldTokenDistribution() public {\n', '        require(swap = true);\n', '        for(uint i=0; i<contractCount; i++) {\n', '//            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], div(add(totalSupply, circulatingSupply), 1 ether));\n', '            tokenShare[contracts[i]] = div(tokenBalances[contracts[i]], circulatingSupply);\n', '        }\n', '        distributionCalculated = true;\n', '    }\n', '\n', '    function tokenShare(address _contract) public constant returns (uint256) {\n', '        return tokenShare[_contract];\n', '    }\n', '\n', '    function shareStoredTokens(address _recipient, uint256 mny) internal {\n', '        Target t;\n', '        uint256 share = 0;\n', '        for(uint i=0; i<contractCount; i++) {\n', '            share = mul(mny, tokenShare[contracts[i]]);\n', '\n', '            t = Target(contracts[i]);\n', '            t.transfer(_recipient, share);\n', '        }\n', '    }\n', '\n', '    function distributeMnyAfterSwap(address _recipient, uint256 _tokens) public {\n', '        require(msg.sender == owner);\n', '        require(totalSupply <= _tokens);\n', '        balances[_recipient] = add(balances[_recipient], _tokens);\n', '        Transfer(this, _recipient, _tokens);\n', '        totalSupply = sub(totalSupply, _tokens);\n', '        circulatingSupply = add(circulatingSupply, _tokens);\n', '    }\n', '\n', '    function existingContract(address _contract) internal returns (bool) {\n', '        for(uint i=0; i<contractCount; i++) {\n', '            if(contracts[i] == _contract) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function contractExchangeRate(address _contract) public constant returns (uint256) {\n', '        return exchangeRates[_contract];\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}']
