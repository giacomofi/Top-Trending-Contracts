['/*\n', 'Capital Technologies & Research - Capital (CALL) & CapitalGAS (CALLG) - Crowdsale Smart Contract\n', 'https://www.mycapitalco.in\n', '*/\n', 'pragma solidity ^0.4.18;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) external returns (bool success);\n', '    function balanceOf(address _owner) external returns (uint256 balance);\n', '}\n', 'contract FiatContract {\n', '    function USD(uint _id) public constant returns (uint256);\n', '}\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '  Token public token_call;\n', '  Token public token_callg;\n', '  FiatContract public fiat_contract;\n', '  uint256 public softCap = 30000 ether;\n', '  uint256 public maxContributionPerAddress = 1500 ether;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public weiRaised;\n', '  uint256 public sale_period = 75 days;\n', '  uint256 public minInvestment = 0.01 ether;\n', '  bool public sale_state = false;\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  modifier nonZeroAddress(address _to) {\n', '    require(_to != 0x0);\n', '    _;\n', '  }\n', '  modifier nonZeroEth() {\n', '\trequire(msg.value > 0);\n', '    _;\n', '  }\n', '  function Crowdsale(address _token_call, address _token_callg) public nonZeroAddress(_token_call) nonZeroAddress(_token_callg) {\n', '    token_call = Token(_token_call);\n', '    token_callg = Token(_token_callg);\n', '    fiat_contract = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\n', '  }\n', '  function calculateRate(uint256 _amount) public view returns(uint256) {\n', '        uint256 tokenPrice = fiat_contract.USD(0);\n', '        if(startTime.add(15 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(200).div(10 ** 8);\n', '        } else if(startTime.add(45 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(300).div(10 ** 8);\n', '        } else if(startTime.add(52 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(330).div(10 ** 8);\n', '        } else if(startTime.add(59 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(360).div(10 ** 8);\n', '        } else if(startTime.add(66 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(400).div(10 ** 8);\n', '        } else {\n', '            tokenPrice = tokenPrice.mul(150).div(10 ** 8);\n', '        }\n', '        return _amount.div(tokenPrice).mul(10 ** 10);\n', '  }\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  function buyTokens(address beneficiary) public payable nonZeroAddress(beneficiary) {\n', '    require(validPurchase());\n', '\tuint256 weiAmount = msg.value;\n', '    uint256 tokenPrice = fiat_contract.USD(0);\n', '    if(startTime.add(15 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(200).div(10 ** 8);\n', '    } else if(startTime.add(45 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(300).div(10 ** 8);\n', '    } else if(startTime.add(52 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(330).div(10 ** 8);\n', '    } else if(startTime.add(59 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(360).div(10 ** 8);\n', '    } else if(startTime.add(66 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(400).div(10 ** 8);\n', '    } else {\n', '        tokenPrice = tokenPrice.mul(150).div(10 ** 8);\n', '    }\n', '    uint256 call_units = weiAmount.div(tokenPrice).mul(10 ** 10);\n', '    uint256 callg_units = call_units.mul(200);\n', '    forwardFunds();\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    emit TokenPurchase(msg.sender, beneficiary, weiAmount, call_units);\n', '    require(token_call.transfer(beneficiary, call_units));\n', '    require(token_callg.transfer(beneficiary, callg_units));\n', '  }\n', '  function forwardFunds() internal;\n', '  function hasEnded() public view returns (bool) {\n', '    require(sale_state);\n', '    return block.timestamp > endTime;\n', '  }\n', '  function validPurchase() internal view returns (bool);\n', '}\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '  using SafeMath for uint256;\n', '  event Finalized();  \n', '  function FinalizableCrowdsale(address _token_call, address _token_callg) Crowdsale(_token_call, _token_callg) public {\n', '      \n', '  }\n', '  function finalize() onlyOwner public {\n', '    require(hasEnded());\n', '    finalization();\n', '    emit Finalized();\n', '    sale_state = false;\n', '  }\n', '  function finalization() internal ;\n', '}\n', 'contract CapitalTechCrowdsale is FinalizableCrowdsale {\n', '  using SafeMath for uint256;\n', '  RefundVault public vault; \n', '  event BurnedUnsold();\n', '  function CapitalTechCrowdsale( address _wallet, address _token_call, address _token_callg) FinalizableCrowdsale( _token_call, _token_callg) public nonZeroAddress(_wallet) {\n', '    vault = new RefundVault(_wallet);\n', '  }\n', '  function powerUpContract() public onlyOwner{\n', '    require(!sale_state);\n', '\tstartTime = block.timestamp;\n', '    endTime = block.timestamp.add(sale_period);    \n', '    sale_state = true;\n', '  }\n', '  function transferTokens(address _to, uint256 amount) public onlyOwner nonZeroAddress(_to) {\n', '    require(hasEnded());\n', '    token_call.transfer(_to, amount);\n', '    token_callg.transfer(_to, amount.mul(200));  \n', '  }  \n', '  function forwardFunds() internal {\n', '    vault.deposit.value(msg.value)(msg.sender);\n', '  }\n', '  function claimRefund() public {\n', '    require(!sale_state);\n', '    require(!goalReached());\n', '    vault.refund(msg.sender);\n', '  }\n', '  function withdrawFunds() public onlyOwner{\n', '    require(!sale_state);\n', '    require(goalReached());\n', '    vault.withdrawToWallet();\n', '  }\n', '  function finalization() internal {\n', '    if (goalReached()) {\n', '      burnUnsold();\n', '      vault.close();\n', '    } else {\n', '      vault.enableRefunds();\n', '    }\n', '  }\n', '  function burnUnsold() internal {\n', '    require(!sale_state);\n', '    require(!goalReached());\n', '    token_call.transfer(address(0), token_call.balanceOf(this));\n', '    token_callg.transfer(address(0), token_callg.balanceOf(this));\n', '    emit BurnedUnsold();\n', '  }\n', '  function validPurchase() internal view returns (bool) {\n', '    require(!hasEnded());\n', '    require(msg.value >= minInvestment);\n', '\trequire(vault.deposited(msg.sender).add(msg.value) <= maxContributionPerAddress); \n', '    return true;\n', '  }\n', '  function goalReached() public view returns (bool) {\n', '    return token_call.balanceOf(this) <= 5250000000000000000000000;\n', '  }\n', '}\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '  enum State { Active, Refunding, Closed }\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '  function RefundVault(address _wallet) public {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '  }\n', '  function withdrawToWallet() onlyOwner public{\n', '    require(state == State.Closed);\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    emit Refunded(investor, depositedValue);\n', '    investor.transfer(depositedValue);\n', '  }\n', '}']
['/*\n', 'Capital Technologies & Research - Capital (CALL) & CapitalGAS (CALLG) - Crowdsale Smart Contract\n', 'https://www.mycapitalco.in\n', '*/\n', 'pragma solidity ^0.4.18;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', 'interface Token {\n', '    function transfer(address _to, uint256 _amount) external returns (bool success);\n', '    function balanceOf(address _owner) external returns (uint256 balance);\n', '}\n', 'contract FiatContract {\n', '    function USD(uint _id) public constant returns (uint256);\n', '}\n', 'contract Crowdsale {\n', '  using SafeMath for uint256;\n', '  Token public token_call;\n', '  Token public token_callg;\n', '  FiatContract public fiat_contract;\n', '  uint256 public softCap = 30000 ether;\n', '  uint256 public maxContributionPerAddress = 1500 ether;\n', '  uint256 public startTime;\n', '  uint256 public endTime;\n', '  uint256 public weiRaised;\n', '  uint256 public sale_period = 75 days;\n', '  uint256 public minInvestment = 0.01 ether;\n', '  bool public sale_state = false;\n', '  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '  modifier nonZeroAddress(address _to) {\n', '    require(_to != 0x0);\n', '    _;\n', '  }\n', '  modifier nonZeroEth() {\n', '\trequire(msg.value > 0);\n', '    _;\n', '  }\n', '  function Crowdsale(address _token_call, address _token_callg) public nonZeroAddress(_token_call) nonZeroAddress(_token_callg) {\n', '    token_call = Token(_token_call);\n', '    token_callg = Token(_token_callg);\n', '    fiat_contract = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591);\n', '  }\n', '  function calculateRate(uint256 _amount) public view returns(uint256) {\n', '        uint256 tokenPrice = fiat_contract.USD(0);\n', '        if(startTime.add(15 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(200).div(10 ** 8);\n', '        } else if(startTime.add(45 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(300).div(10 ** 8);\n', '        } else if(startTime.add(52 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(330).div(10 ** 8);\n', '        } else if(startTime.add(59 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(360).div(10 ** 8);\n', '        } else if(startTime.add(66 days) >= block.timestamp) {\n', '            tokenPrice = tokenPrice.mul(400).div(10 ** 8);\n', '        } else {\n', '            tokenPrice = tokenPrice.mul(150).div(10 ** 8);\n', '        }\n', '        return _amount.div(tokenPrice).mul(10 ** 10);\n', '  }\n', '  function () external payable {\n', '    buyTokens(msg.sender);\n', '  }\n', '  function buyTokens(address beneficiary) public payable nonZeroAddress(beneficiary) {\n', '    require(validPurchase());\n', '\tuint256 weiAmount = msg.value;\n', '    uint256 tokenPrice = fiat_contract.USD(0);\n', '    if(startTime.add(15 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(200).div(10 ** 8);\n', '    } else if(startTime.add(45 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(300).div(10 ** 8);\n', '    } else if(startTime.add(52 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(330).div(10 ** 8);\n', '    } else if(startTime.add(59 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(360).div(10 ** 8);\n', '    } else if(startTime.add(66 days) >= block.timestamp) {\n', '        tokenPrice = tokenPrice.mul(400).div(10 ** 8);\n', '    } else {\n', '        tokenPrice = tokenPrice.mul(150).div(10 ** 8);\n', '    }\n', '    uint256 call_units = weiAmount.div(tokenPrice).mul(10 ** 10);\n', '    uint256 callg_units = call_units.mul(200);\n', '    forwardFunds();\n', '    weiRaised = weiRaised.add(weiAmount);\n', '    emit TokenPurchase(msg.sender, beneficiary, weiAmount, call_units);\n', '    require(token_call.transfer(beneficiary, call_units));\n', '    require(token_callg.transfer(beneficiary, callg_units));\n', '  }\n', '  function forwardFunds() internal;\n', '  function hasEnded() public view returns (bool) {\n', '    require(sale_state);\n', '    return block.timestamp > endTime;\n', '  }\n', '  function validPurchase() internal view returns (bool);\n', '}\n', 'contract FinalizableCrowdsale is Crowdsale, Ownable {\n', '  using SafeMath for uint256;\n', '  event Finalized();  \n', '  function FinalizableCrowdsale(address _token_call, address _token_callg) Crowdsale(_token_call, _token_callg) public {\n', '      \n', '  }\n', '  function finalize() onlyOwner public {\n', '    require(hasEnded());\n', '    finalization();\n', '    emit Finalized();\n', '    sale_state = false;\n', '  }\n', '  function finalization() internal ;\n', '}\n', 'contract CapitalTechCrowdsale is FinalizableCrowdsale {\n', '  using SafeMath for uint256;\n', '  RefundVault public vault; \n', '  event BurnedUnsold();\n', '  function CapitalTechCrowdsale( address _wallet, address _token_call, address _token_callg) FinalizableCrowdsale( _token_call, _token_callg) public nonZeroAddress(_wallet) {\n', '    vault = new RefundVault(_wallet);\n', '  }\n', '  function powerUpContract() public onlyOwner{\n', '    require(!sale_state);\n', '\tstartTime = block.timestamp;\n', '    endTime = block.timestamp.add(sale_period);    \n', '    sale_state = true;\n', '  }\n', '  function transferTokens(address _to, uint256 amount) public onlyOwner nonZeroAddress(_to) {\n', '    require(hasEnded());\n', '    token_call.transfer(_to, amount);\n', '    token_callg.transfer(_to, amount.mul(200));  \n', '  }  \n', '  function forwardFunds() internal {\n', '    vault.deposit.value(msg.value)(msg.sender);\n', '  }\n', '  function claimRefund() public {\n', '    require(!sale_state);\n', '    require(!goalReached());\n', '    vault.refund(msg.sender);\n', '  }\n', '  function withdrawFunds() public onlyOwner{\n', '    require(!sale_state);\n', '    require(goalReached());\n', '    vault.withdrawToWallet();\n', '  }\n', '  function finalization() internal {\n', '    if (goalReached()) {\n', '      burnUnsold();\n', '      vault.close();\n', '    } else {\n', '      vault.enableRefunds();\n', '    }\n', '  }\n', '  function burnUnsold() internal {\n', '    require(!sale_state);\n', '    require(!goalReached());\n', '    token_call.transfer(address(0), token_call.balanceOf(this));\n', '    token_callg.transfer(address(0), token_callg.balanceOf(this));\n', '    emit BurnedUnsold();\n', '  }\n', '  function validPurchase() internal view returns (bool) {\n', '    require(!hasEnded());\n', '    require(msg.value >= minInvestment);\n', '\trequire(vault.deposited(msg.sender).add(msg.value) <= maxContributionPerAddress); \n', '    return true;\n', '  }\n', '  function goalReached() public view returns (bool) {\n', '    return token_call.balanceOf(this) <= 5250000000000000000000000;\n', '  }\n', '}\n', 'contract RefundVault is Ownable {\n', '  using SafeMath for uint256;\n', '  enum State { Active, Refunding, Closed }\n', '  mapping (address => uint256) public deposited;\n', '  address public wallet;\n', '  State public state;\n', '  event Closed();\n', '  event RefundsEnabled();\n', '  event Refunded(address indexed beneficiary, uint256 weiAmount);\n', '  function RefundVault(address _wallet) public {\n', '    require(_wallet != address(0));\n', '    wallet = _wallet;\n', '    state = State.Active;\n', '  }\n', '  function deposit(address investor) onlyOwner public payable {\n', '    require(state == State.Active);\n', '    deposited[investor] = deposited[investor].add(msg.value);\n', '  }\n', '  function close() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Closed;\n', '    emit Closed();\n', '  }\n', '  function withdrawToWallet() onlyOwner public{\n', '    require(state == State.Closed);\n', '    wallet.transfer(address(this).balance);\n', '  }\n', '  function enableRefunds() onlyOwner public {\n', '    require(state == State.Active);\n', '    state = State.Refunding;\n', '    emit RefundsEnabled();\n', '  }\n', '  function refund(address investor) public {\n', '    require(state == State.Refunding);\n', '    uint256 depositedValue = deposited[investor];\n', '    deposited[investor] = 0;\n', '    emit Refunded(investor, depositedValue);\n', '    investor.transfer(depositedValue);\n', '  }\n', '}']
