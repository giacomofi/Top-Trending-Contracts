['pragma solidity ^0.4.21;\n', '\n', 'interface Token {\n', '    function totalSupply() constant external returns (uint256 ts);\n', '    function balanceOf(address _owner) constant external returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface XPAAssetToken {\n', '    function create(address user_, uint256 amount_) external returns(bool success);\n', '    function burn(uint256 amount_) external returns(bool success);\n', '    function burnFrom(address user_, uint256 amount_) external returns(bool success);\n', '    function getDefaultExchangeRate() external returns(uint256);\n', '    function getSymbol() external returns(bytes32);\n', '}\n', '\n', 'interface Baliv {\n', '    function getPrice(address fromToken_, address toToken_) external view returns(uint256);\n', '}\n', '\n', 'interface FundAccount {\n', '    function burn(address Token_, uint256 Amount_) external view returns(bool);\n', '}\n', '\n', 'interface TokenFactory {\n', '    function createToken(string symbol_, string name_, uint256 defaultExchangeRate_) external returns(address);\n', '    function getPrice(address token_) external view returns(uint256);\n', '    function getAssetLength() external view returns(uint256);\n', '    function getAssetToken(uint256 index_) external view returns(address);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint256 z = x + y;\n', '      require((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      require(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMul(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '      uint z = x * y;\n', '      require((x == 0) || (z / x == y));\n', '      return z;\n', '    }\n', '    \n', '    function safeDiv(uint x, uint y)\n', '        internal\n', '        pure\n', '    returns(uint) {\n', '        require(y > 0);\n', '        return x / y;\n', '    }\n', '\n', '    function random(uint N, uint salt)\n', '        internal\n', '        view\n', '    returns(uint) {\n', '      bytes32 hash = keccak256(block.number, msg.sender, salt);\n', '      return uint(hash) % N;\n', '    }\n', '}\n', '\n', 'contract Authorization {\n', '    mapping(address => address) public agentBooks;\n', '    address public owner;\n', '    address public operator;\n', '    address public bank;\n', '    bool public powerStatus = true;\n', '    bool public forceOff = false;\n', '    function Authorization()\n', '        public\n', '    {\n', '        owner = msg.sender;\n', '        operator = msg.sender;\n', '        bank = msg.sender;\n', '    }\n', '    modifier onlyOwner\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyOperator\n', '    {\n', '        assert(msg.sender == operator || msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyActive\n', '    {\n', '        assert(powerStatus);\n', '        _;\n', '    }\n', '    function powerSwitch(\n', '        bool onOff_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        if(forceOff) {\n', '            powerStatus = false;\n', '        } else {\n', '            powerStatus = onOff_;\n', '        }\n', '    }\n', '    function transferOwnership(address newOwner_)\n', '        onlyOwner\n', '        public\n', '    {\n', '        owner = newOwner_;\n', '    }\n', '    \n', '    function assignOperator(address user_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        operator = user_;\n', '        agentBooks[bank] = user_;\n', '    }\n', '    \n', '    function assignBank(address bank_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        bank = bank_;\n', '    }\n', '    function assignAgent(\n', '        address agent_\n', '    )\n', '        public\n', '    {\n', '        agentBooks[msg.sender] = agent_;\n', '    }\n', '    function isRepresentor(\n', '        address representor_\n', '    )\n', '        public\n', '        view\n', '    returns(bool) {\n', '        return agentBooks[representor_] == msg.sender;\n', '    }\n', '    function getUser(\n', '        address representor_\n', '    )\n', '        internal\n', '        view\n', '    returns(address) {\n', '        return isRepresentor(representor_) ? representor_ : msg.sender;\n', '    }\n', '}\n', '\n', 'contract XPAAssets is SafeMath, Authorization {\n', '    string public version = "0.5.0";\n', '\n', '    // contracts\n', '    address public XPA = 0x0090528aeb3a2b736b780fd1b6c478bb7e1d643170;\n', '    address public oldXPAAssets = 0x0002992af1dd8140193b87d2ab620ca22f6e19f26c;\n', '    address public newXPAAssets = address(0);\n', '    address public tokenFactory = 0x0036B86289ccCE0984251CCCA62871b589B0F52d68;\n', '    // setting\n', '    uint256 public maxForceOffsetAmount = 1000000 ether;\n', '    uint256 public minForceOffsetAmount = 10000 ether;\n', '    \n', '    // events\n', '    event eMortgage(address, uint256);\n', '    event eWithdraw(address, address, uint256);\n', '    event eRepayment(address, address, uint256);\n', '    event eOffset(address, address, uint256);\n', '    event eExecuteOffset(uint256, address, uint256);\n', '    event eMigrate(address);\n', '    event eMigrateAmount(address);\n', '\n', '    //data\n', '    mapping(address => uint256) public fromAmountBooks;\n', '    mapping(address => mapping(address => uint256)) public toAmountBooks;\n', '    mapping(address => uint256) public forceOffsetBooks;\n', '    mapping(address => bool) public migrateBooks;\n', '    address[] public xpaAsset;\n', '    address public fundAccount;\n', '    uint256 public profit = 0;\n', '    mapping(address => uint256) public unPaidFundAccount;\n', '    uint256 public initCanOffsetTime = 0;\n', '    \n', '    //fee\n', '    uint256 public withdrawFeeRate = 0.02 ether; // 提領手續費\n', '    uint256 public offsetFeeRate = 0.02 ether;   // 平倉手續費\n', '    uint256 public forceOffsetBasicFeeRate = 0.02 ether; // 強制平倉基本費\n', '    uint256 public forceOffsetExecuteFeeRate = 0.01 ether;// 強制平倉執行費\n', '    uint256 public forceOffsetExtraFeeRate = 0.05 ether; // 強制平倉額外手續費\n', '    uint256 public forceOffsetExecuteMaxFee = 1000 ether; \n', '    \n', '    // constructor\n', '    function XPAAssets(\n', '        uint256 initCanOffsetTime_\n', '    ) public {\n', '        initCanOffsetTime = initCanOffsetTime_;\n', '    }\n', '\n', '    function setFundAccount(\n', '        address fundAccount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        if(fundAccount_ != address(0)) {\n', '            fundAccount = fundAccount_;\n', '        }\n', '    }\n', '\n', '    function createToken(\n', '        string symbol_,\n', '        string name_,\n', '        uint256 defaultExchangeRate_\n', '    )\n', '        public\n', '        onlyOperator \n', '    {\n', '        address newAsset = TokenFactory(tokenFactory).createToken(symbol_, name_, defaultExchangeRate_);\n', '        for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '            if(xpaAsset[i] == newAsset){\n', '                return;\n', '            }\n', '        }\n', '        xpaAsset.push(newAsset);\n', '    }\n', '\n', '    //抵押 XPA\n', '    function mortgage(\n', '        address representor_\n', '    )\n', '        onlyActive\n', '        public\n', '    {\n', '        address user = getUser(representor_);\n', '        uint256 amount_ = Token(XPA).allowance(msg.sender, this); // get mortgage amount\n', '        if(\n', '            amount_ >= 100 ether && \n', '            Token(XPA).transferFrom(msg.sender, this, amount_) \n', '        ){\n', '            fromAmountBooks[user] = safeAdd(fromAmountBooks[user], amount_); // update books\n', '            emit eMortgage(user,amount_); // wirte event\n', '        }\n', '    }\n', '    \n', '    // 借出 XPA Assets, amount: 指定借出金額\n', '    function withdraw(\n', '        address token_,\n', '        uint256 amount_,\n', '        address representor_\n', '    ) \n', '        onlyActive \n', '        public \n', '    {\n', '        address user = getUser(representor_);\n', '        if(\n', '            token_ != XPA &&\n', '            amount_ > 0 &&\n', '            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n', '        ){\n', '            toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_);\n', '            uint256 withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1 ether); // calculate withdraw fee\n', '            XPAAssetToken(token_).create(user, safeSub(amount_, withdrawFee));\n', '            XPAAssetToken(token_).create(this, withdrawFee);\n', '            emit eWithdraw(user, token_, amount_); // write event\n', '        }\n', '    }\n', '    \n', '    // 領回 XPA, amount: 指定領回金額\n', '    function withdrawXPA(\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        onlyActive\n', '        public\n', '    {\n', '        address user = getUser(representor_);\n', '        if(\n', '            amount_ >= 100 ether && \n', '            amount_ <= getUsableXPA(user)\n', '        ){\n', '            fromAmountBooks[user] = safeSub(fromAmountBooks[user], amount_);\n', '            require(Token(XPA).transfer(user, amount_));\n', '            emit eWithdraw(user, XPA, amount_); // write event\n', '        }    \n', '    }\n', '    \n', '    // 檢查額度是否足夠借出 XPA Assets\n', '    /*function checkWithdraw(\n', '        address token_,\n', '        uint256 amount_,\n', '        address user_\n', '    ) \n', '        internal  \n', '        view\n', '    returns(bool) {\n', '        if(\n', '            token_ != XPA && \n', '            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n', '        ){\n', '            return true;\n', '        }else if(\n', '            token_ == XPA && \n', '            amount_ <= getUsableXPA(user_)\n', '        ){\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }*/\n', '\n', '    // 還款 XPA Assets, amount: 指定還回金額\n', '    function repayment(\n', '        address token_,\n', '        uint256 amount_,\n', '        address representor_\n', '    )\n', '        onlyActive \n', '        public\n', '    {\n', '        address user = getUser(representor_);\n', '        if(\n', '            XPAAssetToken(token_).burnFrom(user, amount_)\n', '        ) {\n', '            toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_);\n', '            emit eRepayment(user, token_, amount_);\n', '        }\n', '    }\n', '    \n', '    // 平倉 / 強行平倉, user: 指定平倉對象\n', '    function offset(\n', '        address user_,\n', '        address token_\n', '    )\n', '        onlyActive\n', '        public\n', '    {\n', '        uint256 userFromAmount = fromAmountBooks[user_] >= maxForceOffsetAmount ? maxForceOffsetAmount : fromAmountBooks[user_];\n', '        require(block.timestamp > initCanOffsetTime);\n', '        require(userFromAmount > 0);\n', '        address user = getUser(user_);\n', '\n', '        if(\n', '            user_ == user &&\n', '            getLoanAmount(user, token_) > 0\n', '        ){\n', '            emit eOffset(user, user_, userFromAmount);\n', '            uint256 remainingXPA = executeOffset(user_, userFromAmount, token_, offsetFeeRate);\n', '            \n', '            require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), 1 ether), safeAdd(1 ether, offsetFeeRate)))); //轉帳至平倉基金\n', '            fromAmountBooks[user_] = remainingXPA;\n', '        }else if(\n', '            user_ != user && \n', '            block.timestamp > (forceOffsetBooks[user_] + 28800) &&\n', '            getMortgageRate(user_) >= getClosingLine()\n', '        ){\n', '            forceOffsetBooks[user_] = block.timestamp;\n', '                \n', '            uint256 punishXPA = getPunishXPA(user_); //get 10% xpa\n', '            emit eOffset(user, user_, punishXPA);\n', '\n', '            uint256[3] memory forceOffsetFee;\n', '            forceOffsetFee[0] = safeDiv(safeMul(punishXPA, forceOffsetBasicFeeRate), 1 ether); //基本手續費(收益)\n', '            forceOffsetFee[1] = safeDiv(safeMul(punishXPA, forceOffsetExtraFeeRate), 1 ether); //額外手續費(平倉基金)\n', '            forceOffsetFee[2] = safeDiv(safeMul(punishXPA, forceOffsetExecuteFeeRate), 1 ether);//執行手續費(執行者)\n', '            forceOffsetFee[2] = forceOffsetFee[2] > forceOffsetExecuteMaxFee ? forceOffsetExecuteMaxFee : forceOffsetFee[2];\n', '\n', '            profit = safeAdd(profit, forceOffsetFee[0]);\n', '            uint256 allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0], forceOffsetFee[1]));\n', '            remainingXPA = safeSub(punishXPA,allFee);\n', '\n', '            for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '                if(getLoanAmount(user_, xpaAsset[i]) > 0){\n', '                    remainingXPA = executeOffset(user_, remainingXPA, xpaAsset[i],0);\n', '                    if(remainingXPA == 0){\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '                \n', '            fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(punishXPA, remainingXPA));\n', '            require(Token(XPA).transfer(fundAccount, safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA, allFee), remainingXPA)))); //轉帳至平倉基金\n', '            require(Token(XPA).transfer(msg.sender, forceOffsetFee[2])); //執行手續費轉給執行者\n', '        }\n', '    }\n', '    \n', '    function executeOffset(\n', '        address user_,\n', '        uint256 xpaAmount_,\n', '        address xpaAssetToken,\n', '        uint256 feeRate\n', '    )\n', '        internal\n', '    returns(uint256){\n', '        uint256 fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1 ether);\n', '        uint256 userToAmount = toAmountBooks[user_][xpaAssetToken];\n', '        uint256 fee = safeDiv(safeMul(userToAmount, feeRate), 1 ether);\n', '        uint256 burnXPA;\n', '        uint256 burnXPAAsset;\n', '        if(fromXPAAsset >= safeAdd(userToAmount, fee)){\n', '            burnXPA = safeDiv(safeMul(safeAdd(userToAmount, fee), 1 ether), getPrice(xpaAssetToken));\n', '            emit eExecuteOffset(burnXPA, xpaAssetToken, safeAdd(userToAmount, fee));\n', '            xpaAmount_ = safeSub(xpaAmount_, burnXPA);\n', '            toAmountBooks[user_][xpaAssetToken] = 0;\n', '            profit = safeAdd(profit, safeDiv(safeMul(fee,1 ether), getPrice(xpaAssetToken)));\n', '            if(\n', '                !FundAccount(fundAccount).burn(xpaAssetToken, userToAmount)\n', '            ){\n', '                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount);\n', '            }\n', '\n', '        }else{\n', '            \n', '            fee = safeDiv(safeMul(xpaAmount_, feeRate), 1 ether);\n', '            profit = safeAdd(profit, fee);\n', '            burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_, fee),getPrice(xpaAssetToken)),1 ether);\n', '            toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount, burnXPAAsset);\n', '            emit eExecuteOffset(xpaAmount_, xpaAssetToken, burnXPAAsset);\n', '            \n', '            xpaAmount_ = 0;\n', '            if(\n', '                !FundAccount(fundAccount).burn(xpaAssetToken, burnXPAAsset)\n', '            ){\n', '                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken], burnXPAAsset);\n', '            }\n', '            \n', '        }\n', '        return xpaAmount_;\n', '    }\n', '    \n', '    function getPunishXPA(\n', '        address user_\n', '    )\n', '        internal\n', '        view \n', '    returns(uint256){\n', '        uint256 userFromAmount = fromAmountBooks[user_];\n', '        uint256 punishXPA = safeDiv(safeMul(userFromAmount, 0.1 ether),1 ether);\n', '        if(userFromAmount <= safeAdd(minForceOffsetAmount, 100 ether)){\n', '            return userFromAmount;\n', '        }else if(punishXPA < minForceOffsetAmount){\n', '            return minForceOffsetAmount;\n', '        }else if(punishXPA > maxForceOffsetAmount){\n', '            return maxForceOffsetAmount;\n', '        }else{\n', '            return punishXPA;\n', '        }\n', '    }\n', '    \n', '    // 取得用戶抵押率, user: 指定用戶\n', '    function getMortgageRate(\n', '        address user_\n', '    ) \n', '        public\n', '        view \n', '    returns(uint256){\n', '        if(fromAmountBooks[user_] != 0){\n', '            uint256 totalLoanXPA = 0;\n', '            for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '                totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n', '            }\n', '            return safeDiv(safeMul(totalLoanXPA,1 ether),fromAmountBooks[user_]);\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '        \n', '    // 取得最高抵押率\n', '    function getHighestMortgageRate() \n', '        public\n', '        view \n', '    returns(uint256){\n', '        uint256 totalXPA = Token(XPA).totalSupply();\n', '        uint256 issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this), 1 ether), totalXPA);\n', '        if(issueRate >= 0.7 ether){\n', '            return 0.7 ether;\n', '        }else if(issueRate >= 0.6 ether){\n', '            return 0.6 ether;\n', '        }else if(issueRate >= 0.5 ether){\n', '            return 0.5 ether;\n', '        }else if(issueRate >= 0.3 ether){\n', '            return 0.3 ether;\n', '        }else{\n', '            return 0.1 ether;\n', '        }\n', '    }\n', '    \n', '    // 取得平倉線\n', '    function getClosingLine() \n', '        public\n', '        view\n', '    returns(uint256){\n', '        uint256 highestMortgageRate = getHighestMortgageRate();\n', '        if(highestMortgageRate >= 0.6 ether){\n', '            return safeAdd(highestMortgageRate, 0.1 ether);\n', '        }else{\n', '            return 0.6 ether;\n', '        }\n', '    }\n', '    \n', '    // 取得 XPA Assets 匯率 \n', '    function getPrice(\n', '        address token_\n', '    ) \n', '        public\n', '        view\n', '    returns(uint256){\n', '        return TokenFactory(tokenFactory).getPrice(token_);\n', '    }\n', '    \n', '    // 取得用戶可提領的XPA(扣掉最高抵押率後的XPA)\n', '    function getUsableXPA(\n', '        address user_\n', '    )\n', '        public\n', '        view\n', '    returns(uint256) {\n', '        uint256 totalLoanXPA = 0;\n', '        for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '            totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n', '        }\n', '        if(fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate())){\n', '            return safeSub(fromAmountBooks[user_], safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate()));\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    // 取得用戶可借貸 XPA Assets 最大額度, user: 指定用戶\n', '    /*function getUsableAmount(\n', '        address user_,\n', '        address token_\n', '    ) \n', '        public\n', '        view\n', '    returns(uint256) {\n', '        uint256 amount = safeDiv(safeMul(fromAmountBooks[user_], getPrice(token_)), 1 ether);\n', '        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n', '    }*/\n', '    \n', '    // 取得用戶已借貸 XPA Assets 數量, user: 指定用戶\n', '    function getLoanAmount(\n', '        address user_,\n', '        address token_\n', '    ) \n', '        public\n', '        view\n', '    returns(uint256) {\n', '        return toAmountBooks[user_][token_];\n', '    }\n', '    \n', '    // 取得用戶剩餘可借貸 XPA Assets 額度, user: 指定用戶\n', '    function getRemainingAmount(\n', '        address user_,\n', '        address token_\n', '    ) \n', '        public\n', '        view\n', '    returns(uint256) {\n', '        uint256 amount = safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether);\n', '        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n', '    }\n', '    \n', '    function burnFundAccount(\n', '        address token_,\n', '        uint256 amount_\n', '    )\n', '        onlyOperator\n', '        public\n', '    {\n', '        if(\n', '            FundAccount(fundAccount).burn(token_, amount_)\n', '        ){\n', '            unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_], amount_);\n', '        }\n', '    }\n', '\n', '    function transferProfit(\n', '        uint256 token_,\n', '        uint256 amount_\n', '    )\n', '        onlyOperator \n', '        public\n', '    {\n', '        if(amount_ > 0 && Token(token_).balanceOf(this) >= amount_){\n', '            require(Token(token_).transfer(bank, amount_));\n', '            profit = safeSub(profit,amount_);\n', '        }\n', '    }\n', '        \n', '    function setFeeRate(\n', '        uint256 withDrawFeerate_,\n', '        uint256 offsetFeerate_,\n', '        uint256 forceOffsetBasicFeerate_,\n', '        uint256 forceOffsetExecuteFeerate_,\n', '        uint256 forceOffsetExtraFeerate_,\n', '        uint256 forceOffsetExecuteMaxFee_\n', '    )\n', '        onlyOperator \n', '        public\n', '    {\n', '        require(withDrawFeerate_ < 0.05 ether);\n', '        require(offsetFeerate_ < 0.05 ether);\n', '        require(forceOffsetBasicFeerate_ < 0.05 ether);\n', '        require(forceOffsetExecuteFeerate_ < 0.05 ether);\n', '        require(forceOffsetExtraFeerate_ < 0.05 ether);\n', '        withdrawFeeRate = withDrawFeerate_;\n', '        offsetFeeRate = offsetFeerate_;\n', '        forceOffsetBasicFeeRate = forceOffsetBasicFeerate_;\n', '        forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_;\n', '        forceOffsetExtraFeeRate = forceOffsetExtraFeerate_;\n', '        forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_;\n', '    }\n', '\n', '    function migrate(\n', '        address newContract_\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        if(\n', '            newXPAAssets == address(0) &&\n', '            XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset, profit) &&\n', '            Token(XPA).transfer(newContract_, Token(XPA).balanceOf(this))\n', '        ) {\n', '            forceOff = true;\n', '            powerStatus = false;\n', '            newXPAAssets = newContract_;\n', '            for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '                XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i], unPaidFundAccount[xpaAsset[i]]);\n', '            }\n', '            emit eMigrate(newContract_);\n', '        }\n', '    }\n', '    \n', '    function transferXPAAssetAndProfit(\n', '        address[] xpaAsset_,\n', '        uint256 profit_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        xpaAsset = xpaAsset_;\n', '        profit = profit_;\n', '        return true;\n', '    }\n', '    \n', '    function transferUnPaidFundAccount(\n', '        address xpaAsset_,\n', '        uint256 unPaidAmount_\n', '    )\n', '        public\n', '        onlyOperator\n', '    returns(bool) {\n', '        unPaidFundAccount[xpaAsset_] = unPaidAmount_;\n', '        return true;\n', '    }\n', '    \n', '    function migratingAmountBooks(\n', '        address user_,\n', '        address newContract_\n', '    )\n', '        public\n', '        onlyOperator\n', '    {\n', '        XPAAssets(newContract_).migrateAmountBooks(user_); \n', '    }\n', '    \n', '    function migrateAmountBooks(\n', '        address user_\n', '    )\n', '        public\n', '        onlyOperator \n', '    {\n', '        require(msg.sender == oldXPAAssets);\n', '        require(!migrateBooks[user_]);\n', '\n', '        migrateBooks[user_] = true;\n', '        fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_));\n', '        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);\n', '        for(uint256 i = 0; i < xpaAsset.length; i++) {\n', '            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]));\n', '        }\n', '        emit eMigrateAmount(user_);\n', '    }\n', '    \n', '    function getFromAmountBooks(\n', '        address user_\n', '    )\n', '        public\n', '        view \n', '    returns(uint256) {\n', '        return fromAmountBooks[user_];\n', '    }\n', '    \n', '    function getForceOffsetBooks(\n', '        address user_\n', '    )\n', '        public \n', '        view \n', '    returns(uint256) {\n', '        return forceOffsetBooks[user_];\n', '    }\n', '}']