['pragma solidity 0.4.24;\n', '\n', 'contract IMigrationContract {\n', '    function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '    \n', '    function safeDiv(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public ethFundDeposit;\n', '\n', '    event OwnershipTransferred(address indexed ethFundDeposit, address indexed _newFundDeposit);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        ethFundDeposit = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ethFundDeposit);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a _newFundDeposit.\n', '     * @param _newFundDeposit The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newFundDeposit) public onlyOwner {\n', '        require(_newFundDeposit != address(0));\n', '        emit OwnershipTransferred(ethFundDeposit, _newFundDeposit);\n', '        ethFundDeposit = _newFundDeposit;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS paused\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS NOT paused\n', '     */\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Controllable\n', ' * @dev Base contract which allows children to control the address\n', ' */\n', 'contract controllable is Ownable {\n', '\n', '    event AddToBlacklist(address _addr);\n', '    event DeleteFromBlacklist(address _addr);\n', '\n', '    // controllable variable\n', '    mapping (address => bool) internal blacklist; // black list\n', '\n', '    /**\n', '     * @dev called by the owner to AddToBlacklist\n', '     */\n', '    function addtoblacklist(address _addr) public onlyOwner {\n', '        blacklist[_addr] = true;\n', '        emit AddToBlacklist(_addr);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpDeleteFromBlacklistause\n', '     */\n', '    function deletefromblacklist(address _addr) public onlyOwner {\n', '        blacklist[_addr] = false;\n', '        emit DeleteFromBlacklist(_addr);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to check the blacklist address\n', '     */\n', '    function isBlacklist(address _addr) public view returns(bool) {\n', '        return blacklist[_addr];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Lockable\n', ' * @dev Base contract which allows children to control the token release mechanism\n', ' */\n', 'contract Lockable is Ownable, SafeMath {\n', '\n', '    // parameters\n', '    mapping (address => uint256) balances;\n', '    mapping (address => uint256) totalbalances;\n', '    uint256 public totalreleaseblances;\n', '\n', '    mapping (address => mapping (uint256 => uint256)) userbalances; // address ， order ，balances amount\n', '    mapping (address => mapping (uint256 => uint256)) userRelease; // address ， order ，release amount\n', '    mapping (address => mapping (uint256 => uint256)) isRelease; // already release period\n', '    mapping (address => mapping (uint256 => uint256)) userChargeTime; // address ， order ，charge time\n', '    mapping (address => uint256) userChargeCount; // user total charge times\n', '    mapping (address => mapping (uint256 => uint256)) lastCliff; // address ， order ，last cliff time\n', '\n', '    // userbalances each time segmentation\n', '    mapping (address => mapping (uint256 => mapping (uint256 => uint256))) userbalancesSegmentation; // address ， order ，balances amount\n', '\n', '    uint256 internal duration = 30*15 days;\n', '    uint256 internal cliff = 90 days;\n', '\n', '    // event\n', '    event userlockmechanism(address _addr,uint256 _amount,uint256 _timestamp);\n', '    event userrelease(address _addr, uint256 _times, uint256 _amount);\n', '\n', '    modifier onlySelfOrOwner(address _addr) {\n', '        require(msg.sender == _addr || msg.sender == ethFundDeposit);\n', '        _;\n', '    }\n', '\n', '    function LockMechanism (\n', '        address _addr,\n', '        uint256 _value\n', '    )\n', '        internal\n', '    {\n', '        require(_addr != address(0));\n', '        require(_value != 0);\n', '        // count\n', '        userChargeCount[_addr] = safeAdd(userChargeCount[_addr],1);\n', '        uint256 _times = userChargeCount[_addr];\n', '        // time\n', '        userChargeTime[_addr][_times] = ShowTime();\n', '        // balances\n', '        userbalances[_addr][_times] = _value;\n', '        initsegmentation(_addr,userChargeCount[_addr],_value);\n', '        totalbalances[_addr] = safeAdd(totalbalances[_addr],_value);\n', '        isRelease[_addr][_times] = 0;\n', '        emit userlockmechanism(_addr,_value,ShowTime());\n', '    }\n', '\n', '// init segmentation\n', '    function initsegmentation(address _addr,uint256 _times,uint256 _value) internal {\n', '        for (uint8 i = 1 ; i <= 5 ; i++ ) {\n', '            userbalancesSegmentation[_addr][_times][i] = safeDiv(_value,5);\n', '        }\n', '    }\n', '\n', '// calculate period\n', '    function CalcPeriod(address _addr, uint256 _times) public view returns (uint256) {\n', '        uint256 userstart = userChargeTime[_addr][_times];\n', '        if (ShowTime() >= safeAdd(userstart,duration)) {\n', '            return 5;\n', '        }\n', '        uint256 timedifference = safeSubtract(ShowTime(),userstart);\n', '        uint256 period = 0;\n', '        for (uint8 i = 1 ; i <= 5 ; i++ ) {\n', '            if (timedifference >= cliff) {\n', '                timedifference = safeSubtract(timedifference,cliff);\n', '                period += 1;\n', '            }\n', '        }\n', '        return period;\n', '    }\n', '\n', '// ReleasableAmount() looking for the current releasable amount\n', '    function ReleasableAmount(address _addr, uint256 _times) public view returns (uint256) {\n', '        require(_addr != address(0));\n', '        uint256 period = CalcPeriod(_addr,_times);\n', '        if (safeSubtract(period,isRelease[_addr][_times]) > 0){\n', '            uint256 amount = 0;\n', '            for (uint256 i = safeAdd(isRelease[_addr][_times],1) ; i <= period ; i++ ) {\n', '                amount = safeAdd(amount,userbalancesSegmentation[_addr][_times][i]);\n', '            }\n', '            return amount;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '// release() release the current releasable amount\n', '    function release(address _addr, uint256 _times) external onlySelfOrOwner(_addr) {\n', '        uint256 amount = ReleasableAmount(_addr,_times);\n', '        require(amount > 0);\n', '        userRelease[_addr][_times] = safeAdd(userRelease[_addr][_times],amount);\n', '        balances[_addr] = safeAdd(balances[_addr],amount);\n', '        lastCliff[_addr][_times] = ShowTime();\n', '        isRelease[_addr][_times] = CalcPeriod(_addr,_times);\n', '        totalreleaseblances = safeAdd(totalreleaseblances,amount);\n', '        emit userrelease(_addr, _times, amount);\n', '    }\n', '\n', '// ShowTime\n', '    function ShowTime() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '\n', '// totalBalance()\n', '    function totalBalanceOf(address _addr) public view returns (uint256) {\n', '        return totalbalances[_addr];\n', '    }\n', '// ShowRelease() looking for the already release amount of the address at some time\n', '    function ShowRelease(address _addr, uint256 _times) public view returns (uint256) {\n', '        return userRelease[_addr][_times];\n', '    }\n', '// ShowUnrelease() looking for the not yet release amount of the address at some time\n', '    function ShowUnrelease(address _addr, uint256 _times) public view returns (uint256) {\n', '        return safeSubtract(userbalances[_addr][_times],ShowRelease(_addr,_times));\n', '    }\n', '// ShowChargeTime() looking for the charge time\n', '    function ShowChargeTime(address _addr, uint256 _times) public view returns (uint256) {\n', '        return userChargeTime[_addr][_times];\n', '    }\n', '// ShowChargeCount() looking for the user total charge times\n', '    function ShowChargeCount(address _addr) public view returns (uint256) {\n', '        return userChargeCount[_addr];\n', '    }\n', '// ShowNextCliff() looking for the nex cliff time\n', '    function ShowNextCliff(address _addr, uint256 _times) public view returns (uint256) {\n', '        return safeAdd(lastCliff[_addr][_times],cliff);\n', '    }\n', '// ShowSegmentation() looking for the user balances Segmentation\n', '    function ShowSegmentation(address _addr, uint256 _times,uint256 _period) public view returns (uint256) {\n', '        return userbalancesSegmentation[_addr][_times][_period];\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining); \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is controllable, Pausable, Token, Lockable {\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n', '            // sender\n', '            balances[msg.sender] = safeSubtract(balances[msg.sender],_value);\n', '            totalbalances[msg.sender] = safeSubtract(totalbalances[msg.sender],_value);\n', '            // _to\n', '            balances[_to] = safeAdd(balances[_to],_value);\n', '            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n', '\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n', '            // _to\n', '            balances[_to] = safeAdd(balances[_to],_value);\n', '            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n', '            // _from\n', '            balances[_from] = safeSubtract(balances[_from],_value);\n', '            totalbalances[_from] = safeSubtract(totalbalances[_from],_value);\n', '            // allowed\n', '            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value);\n', '\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) { \n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract BugXToken is StandardToken {\n', '\n', '    /**\n', '    *  base parameters\n', '    */\n', '\n', '    // metadata\n', '    string  public constant name = "BUGX2.0";\n', '    string  public constant symbol = "BUGX";\n', '    uint256 public constant decimals = 18;\n', '    string  public version = "2.0";\n', '\n', '    // contracts\n', '    address public newContractAddr;         // the new contract for BUGX token updates;\n', '\n', '    // crowdsale parameters\n', '    bool    public isFunding;                // switched to true in operational state\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingStopBlock;\n', '\n', '    uint256 public currentSupply;           // current supply tokens for sell\n', '    uint256 public tokenRaised = 0;           // the number of total sold token\n', '    uint256 public tokenIssued = 0;         // the number of total issued token\n', '    uint256 public tokenMigrated = 0;     // the number of total Migrated token\n', '    uint256 internal tokenExchangeRate = 9000;             // 9000 BUGX tokens per 1 ETH\n', '    uint256 internal tokenExchangeRateTwo = 9900;             // 9000 * 1.1 BUGX tokens per 1 ETH\n', '    uint256 internal tokenExchangeRateThree = 11250;             // 9000 * 1.25 BUGX tokens per 1 ETH\n', '\n', '    // events\n', '    event AllocateToken(address indexed _to, uint256 _value);   // issue token to buyer;\n', '    event TakebackToken(address indexed _from, uint256 _value);   //  record token take back info;\n', '    event RaiseToken(address indexed _to, uint256 _value);      // record token raise info;\n', '    event IssueToken(address indexed _to, uint256 _value);\n', '    event IncreaseSupply(uint256 _value);\n', '    event DecreaseSupply(uint256 _value);\n', '    event Migrate(address indexed _addr, uint256 _tokens, uint256 _totaltokens);\n', '\n', '    // format decimals.\n', '    function formatDecimals(uint256 _value) internal pure returns (uint256 ) {\n', '        return _value * 10 ** decimals;\n', '    }\n', '\n', '    /**\n', '    *  constructor function\n', '    */\n', '\n', '    // constructor\n', '    constructor(\n', '        address _ethFundDeposit,\n', '        uint256 _currentSupply\n', '        ) \n', '        public\n', '    {\n', '        require(_ethFundDeposit != address(0x0));\n', '        ethFundDeposit = _ethFundDeposit;\n', '\n', '        isFunding = false;                           //controls pre through crowdsale state\n', '        fundingStartBlock = 0;\n', '        fundingStopBlock = 0;\n', '\n', '        currentSupply = formatDecimals(_currentSupply);\n', '        totalSupply = formatDecimals(1500000000);    //1,500,000,000 total supply\n', '        require(currentSupply <= totalSupply);\n', '        balances[ethFundDeposit] = currentSupply;\n', '        totalbalances[ethFundDeposit] = currentSupply;\n', '    }\n', '\n', '    /**\n', '    *  Modify currentSupply functions\n', '    */\n', '\n', '    /// @dev increase the token&#39;s supply\n', '    function increaseSupply (uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        require (_value + currentSupply <= totalSupply);\n', '        currentSupply = safeAdd(currentSupply, _value);\n', '        tokenadd(ethFundDeposit,_value);\n', '        emit IncreaseSupply(_value);\n', '    }\n', '\n', '    /// @dev decrease the token&#39;s supply\n', '    function decreaseSupply (uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        currentSupply = safeSubtract(currentSupply, _value);\n', '        tokensub(ethFundDeposit,_value);\n', '        emit DecreaseSupply(_value);\n', '    }\n', '\n', '    /**\n', '    *  Funding functions\n', '    */\n', '\n', '    modifier whenFunding() {\n', '        require (isFunding);\n', '        require (block.number >= fundingStartBlock);\n', '        require (block.number <= fundingStopBlock);\n', '        _;\n', '    }\n', '\n', '    /// @dev turn on the funding state\n', '    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {\n', '        require (!isFunding);\n', '        require (_fundingStartBlock < _fundingStopBlock);\n', '        require (block.number < _fundingStartBlock);\n', '\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingStopBlock = _fundingStopBlock;\n', '        isFunding = true;\n', '    }\n', '\n', '    /// @dev turn off the funding state\n', '    function stopFunding() onlyOwner external {\n', '        require (isFunding);\n', '        isFunding = false;\n', '    }\n', '\n', '\n', '    /**\n', '    *  migrate functions\n', '    */\n', '\n', '    /// @dev set a new contract for recieve the tokens (for update contract)\n', '    function setMigrateContract(address _newContractAddr) onlyOwner external {\n', '        require (_newContractAddr != newContractAddr);\n', '        newContractAddr = _newContractAddr;\n', '    }\n', '\n', '    /// sends the tokens to new contract by owner\n', '    function migrate(address _addr) onlySelfOrOwner(_addr) external {\n', '        require(!isFunding);\n', '        require(newContractAddr != address(0x0));\n', '\n', '        uint256 tokens_value = balances[_addr];\n', '        uint256 totaltokens_value = totalbalances[_addr];\n', '        require (tokens_value != 0 || totaltokens_value != 0);\n', '\n', '        balances[_addr] = 0;\n', '        totalbalances[_addr] = 0;\n', '\n', '        IMigrationContract newContract = IMigrationContract(newContractAddr);\n', '        require (newContract.migrate(_addr, tokens_value, totaltokens_value));\n', '\n', '        tokenMigrated = safeAdd(tokenMigrated, totaltokens_value);\n', '        emit Migrate(_addr, tokens_value, totaltokens_value);\n', '    }\n', '\n', '    /**\n', '    *  tokenRaised and tokenIssued control functions\n', '    *  base functions\n', '    */\n', '\n', '    /// token raised\n', '    function tokenRaise (address _addr,uint256 _value) internal {\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        tokenRaised = safeAdd(tokenRaised, _value);\n', '        emit RaiseToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token 1 : token issued\n', '    function tokenIssue (address _addr,uint256 _value) internal {\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        tokenIssued = safeAdd(tokenIssued, _value);\n', '        emit IssueToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token 2 : issue token take back\n', '    function tokenTakeback (address _addr,uint256 _value) internal {\n', '        require (tokenIssued >= _value);\n', '        tokenIssued = safeSubtract(tokenIssued, _value);\n', '        emit TakebackToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token take from ethFundDeposit to user\n', '    function tokenadd (address _addr,uint256 _value) internal {\n', '        require(_value != 0);\n', '        require (_addr != address(0x0));\n', '        balances[_addr] = safeAdd(balances[_addr], _value);\n', '        totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n', '    }\n', '\n', '    /// issue token take from user to ethFundDeposit\n', '    function tokensub (address _addr,uint256 _value) internal {\n', '        require(_value != 0);\n', '        require (_addr != address(0x0));\n', '        balances[_addr] = safeSubtract(balances[_addr], _value);\n', '        totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n', '    }\n', '\n', '    /**\n', '    *  tokenRaised and tokenIssued control functions\n', '    *  main functions\n', '    */\n', '\n', '    /// Issues tokens to buyers.\n', '    function allocateToken(address _addr, uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokenadd(_addr,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        tokenIssue(_addr,_value);\n', '        emit Transfer(ethFundDeposit, _addr, _value);\n', '    }\n', '\n', '    /// Issues tokens deduction.\n', '    function deductionToken (address _addr, uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokensub(_addr,_value);\n', '        tokenadd(ethFundDeposit,_value);\n', '        tokenTakeback(_addr,_value);\n', '        emit Transfer(_addr, ethFundDeposit, _value);\n', '    }\n', '\n', '    /// add the segmentation\n', '    function addSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n', '        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n', '        if (amount != 0 && _tokens != 0){\n', '            uint256 _value = formatDecimals(_tokens);\n', '            userbalancesSegmentation[_addr][_times][_period] = safeAdd(amount,_value);\n', '            userbalances[_addr][_times] = safeAdd(userbalances[_addr][_times], _value);\n', '            totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n', '            tokensub(ethFundDeposit,_value);\n', '            tokenIssue(_addr,_value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// sub the segmentation\n', '    function subSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n', '        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n', '        if (amount != 0 && _tokens != 0){\n', '            uint256 _value = formatDecimals(_tokens);\n', '            userbalancesSegmentation[_addr][_times][_period] = safeSubtract(amount,_value);\n', '            userbalances[_addr][_times] = safeSubtract(userbalances[_addr][_times], _value);\n', '            totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n', '            tokenadd(ethFundDeposit,_value);\n', '            tokenTakeback(_addr,_value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '    *  tokenExchangeRate functions\n', '    */\n', '\n', '    /// @dev set the token&#39;s tokenExchangeRate,\n', '    function setTokenExchangeRate(uint256 _RateOne,uint256 _RateTwo,uint256 _RateThree) onlyOwner external {\n', '        require (_RateOne != 0 && _RateTwo != 0 && _RateThree != 0);\n', '        require (_RateOne != tokenExchangeRate && _RateTwo != tokenExchangeRateTwo && _RateThree != tokenExchangeRateThree);\n', '\n', '        tokenExchangeRate = _RateOne;\n', '        tokenExchangeRateTwo = _RateTwo;\n', '        tokenExchangeRateThree = _RateThree;\n', '    }\n', '\n', '    /// calculate the tokenExchangeRate\n', '    function computeTokenAmount(uint256 _eth) internal view returns (uint256 tokens) {\n', '        if(_eth > 0 && _eth < 100 ether){\n', '            tokens = safeMult(_eth, tokenExchangeRate);\n', '        }\n', '        \n', '        if (_eth >= 100 ether && _eth < 500 ether){\n', '            tokens = safeMult(_eth, tokenExchangeRateTwo);\n', '        }\n', '\n', '        if (_eth >= 500 ether ){\n', '            tokens = safeMult(_eth, tokenExchangeRateThree);\n', '        }\n', '    }\n', '\n', '    /**\n', '    *  Append : the LockMechanism functions by owner\n', '    */\n', '\n', '    function LockMechanismByOwner (\n', '        address _addr,\n', '        uint256 _tokens\n', '    )\n', '        external onlyOwner whenFunding\n', '    {\n', '        require (_tokens != 0);\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokenRaise(_addr,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        LockMechanism(_addr,_value);\n', '        emit Transfer(ethFundDeposit,_addr,_value);\n', '    }\n', '\n', '    /**\n', '    *  ETH control functions\n', '    */\n', '\n', '    /// @dev sends ETH to BUGX team\n', '    function transferETH() onlyOwner external {\n', '        require (address(this).balance != 0);\n', '        ethFundDeposit.transfer(address(this).balance);\n', '    }\n', '\n', '    function () public payable whenFunding { // fallback function\n', '        require (msg.value != 0);\n', '        uint256 _value = computeTokenAmount(msg.value);\n', '        tokenRaise(msg.sender,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        LockMechanism(msg.sender,_value);\n', '        emit Transfer(ethFundDeposit,msg.sender,_value);\n', '    }\n', '}']
['pragma solidity 0.4.24;\n', '\n', 'contract IMigrationContract {\n', '    function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x + y;\n', '        assert((z >= x) && (z >= y));\n', '        return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        assert(x >= y);\n', '        uint256 z = x - y;\n', '        return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x * y;\n', '        assert((x == 0)||(z/x == y));\n', '        return z;\n', '    }\n', '    \n', '    function safeDiv(uint256 x, uint256 y) internal pure returns(uint256) {\n', '        uint256 z = x / y;\n', '        return z;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public ethFundDeposit;\n', '\n', '    event OwnershipTransferred(address indexed ethFundDeposit, address indexed _newFundDeposit);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        ethFundDeposit = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == ethFundDeposit);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a _newFundDeposit.\n', '     * @param _newFundDeposit The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address _newFundDeposit) public onlyOwner {\n', '        require(_newFundDeposit != address(0));\n', '        emit OwnershipTransferred(ethFundDeposit, _newFundDeposit);\n', '        ethFundDeposit = _newFundDeposit;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS paused\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev modifier to allow actions only when the contract IS NOT paused\n', '     */\n', '    modifier whenPaused {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Controllable\n', ' * @dev Base contract which allows children to control the address\n', ' */\n', 'contract controllable is Ownable {\n', '\n', '    event AddToBlacklist(address _addr);\n', '    event DeleteFromBlacklist(address _addr);\n', '\n', '    // controllable variable\n', '    mapping (address => bool) internal blacklist; // black list\n', '\n', '    /**\n', '     * @dev called by the owner to AddToBlacklist\n', '     */\n', '    function addtoblacklist(address _addr) public onlyOwner {\n', '        blacklist[_addr] = true;\n', '        emit AddToBlacklist(_addr);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpDeleteFromBlacklistause\n', '     */\n', '    function deletefromblacklist(address _addr) public onlyOwner {\n', '        blacklist[_addr] = false;\n', '        emit DeleteFromBlacklist(_addr);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to check the blacklist address\n', '     */\n', '    function isBlacklist(address _addr) public view returns(bool) {\n', '        return blacklist[_addr];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Lockable\n', ' * @dev Base contract which allows children to control the token release mechanism\n', ' */\n', 'contract Lockable is Ownable, SafeMath {\n', '\n', '    // parameters\n', '    mapping (address => uint256) balances;\n', '    mapping (address => uint256) totalbalances;\n', '    uint256 public totalreleaseblances;\n', '\n', '    mapping (address => mapping (uint256 => uint256)) userbalances; // address ， order ，balances amount\n', '    mapping (address => mapping (uint256 => uint256)) userRelease; // address ， order ，release amount\n', '    mapping (address => mapping (uint256 => uint256)) isRelease; // already release period\n', '    mapping (address => mapping (uint256 => uint256)) userChargeTime; // address ， order ，charge time\n', '    mapping (address => uint256) userChargeCount; // user total charge times\n', '    mapping (address => mapping (uint256 => uint256)) lastCliff; // address ， order ，last cliff time\n', '\n', '    // userbalances each time segmentation\n', '    mapping (address => mapping (uint256 => mapping (uint256 => uint256))) userbalancesSegmentation; // address ， order ，balances amount\n', '\n', '    uint256 internal duration = 30*15 days;\n', '    uint256 internal cliff = 90 days;\n', '\n', '    // event\n', '    event userlockmechanism(address _addr,uint256 _amount,uint256 _timestamp);\n', '    event userrelease(address _addr, uint256 _times, uint256 _amount);\n', '\n', '    modifier onlySelfOrOwner(address _addr) {\n', '        require(msg.sender == _addr || msg.sender == ethFundDeposit);\n', '        _;\n', '    }\n', '\n', '    function LockMechanism (\n', '        address _addr,\n', '        uint256 _value\n', '    )\n', '        internal\n', '    {\n', '        require(_addr != address(0));\n', '        require(_value != 0);\n', '        // count\n', '        userChargeCount[_addr] = safeAdd(userChargeCount[_addr],1);\n', '        uint256 _times = userChargeCount[_addr];\n', '        // time\n', '        userChargeTime[_addr][_times] = ShowTime();\n', '        // balances\n', '        userbalances[_addr][_times] = _value;\n', '        initsegmentation(_addr,userChargeCount[_addr],_value);\n', '        totalbalances[_addr] = safeAdd(totalbalances[_addr],_value);\n', '        isRelease[_addr][_times] = 0;\n', '        emit userlockmechanism(_addr,_value,ShowTime());\n', '    }\n', '\n', '// init segmentation\n', '    function initsegmentation(address _addr,uint256 _times,uint256 _value) internal {\n', '        for (uint8 i = 1 ; i <= 5 ; i++ ) {\n', '            userbalancesSegmentation[_addr][_times][i] = safeDiv(_value,5);\n', '        }\n', '    }\n', '\n', '// calculate period\n', '    function CalcPeriod(address _addr, uint256 _times) public view returns (uint256) {\n', '        uint256 userstart = userChargeTime[_addr][_times];\n', '        if (ShowTime() >= safeAdd(userstart,duration)) {\n', '            return 5;\n', '        }\n', '        uint256 timedifference = safeSubtract(ShowTime(),userstart);\n', '        uint256 period = 0;\n', '        for (uint8 i = 1 ; i <= 5 ; i++ ) {\n', '            if (timedifference >= cliff) {\n', '                timedifference = safeSubtract(timedifference,cliff);\n', '                period += 1;\n', '            }\n', '        }\n', '        return period;\n', '    }\n', '\n', '// ReleasableAmount() looking for the current releasable amount\n', '    function ReleasableAmount(address _addr, uint256 _times) public view returns (uint256) {\n', '        require(_addr != address(0));\n', '        uint256 period = CalcPeriod(_addr,_times);\n', '        if (safeSubtract(period,isRelease[_addr][_times]) > 0){\n', '            uint256 amount = 0;\n', '            for (uint256 i = safeAdd(isRelease[_addr][_times],1) ; i <= period ; i++ ) {\n', '                amount = safeAdd(amount,userbalancesSegmentation[_addr][_times][i]);\n', '            }\n', '            return amount;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '// release() release the current releasable amount\n', '    function release(address _addr, uint256 _times) external onlySelfOrOwner(_addr) {\n', '        uint256 amount = ReleasableAmount(_addr,_times);\n', '        require(amount > 0);\n', '        userRelease[_addr][_times] = safeAdd(userRelease[_addr][_times],amount);\n', '        balances[_addr] = safeAdd(balances[_addr],amount);\n', '        lastCliff[_addr][_times] = ShowTime();\n', '        isRelease[_addr][_times] = CalcPeriod(_addr,_times);\n', '        totalreleaseblances = safeAdd(totalreleaseblances,amount);\n', '        emit userrelease(_addr, _times, amount);\n', '    }\n', '\n', '// ShowTime\n', '    function ShowTime() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '\n', '// totalBalance()\n', '    function totalBalanceOf(address _addr) public view returns (uint256) {\n', '        return totalbalances[_addr];\n', '    }\n', '// ShowRelease() looking for the already release amount of the address at some time\n', '    function ShowRelease(address _addr, uint256 _times) public view returns (uint256) {\n', '        return userRelease[_addr][_times];\n', '    }\n', '// ShowUnrelease() looking for the not yet release amount of the address at some time\n', '    function ShowUnrelease(address _addr, uint256 _times) public view returns (uint256) {\n', '        return safeSubtract(userbalances[_addr][_times],ShowRelease(_addr,_times));\n', '    }\n', '// ShowChargeTime() looking for the charge time\n', '    function ShowChargeTime(address _addr, uint256 _times) public view returns (uint256) {\n', '        return userChargeTime[_addr][_times];\n', '    }\n', '// ShowChargeCount() looking for the user total charge times\n', '    function ShowChargeCount(address _addr) public view returns (uint256) {\n', '        return userChargeCount[_addr];\n', '    }\n', '// ShowNextCliff() looking for the nex cliff time\n', '    function ShowNextCliff(address _addr, uint256 _times) public view returns (uint256) {\n', '        return safeAdd(lastCliff[_addr][_times],cliff);\n', '    }\n', '// ShowSegmentation() looking for the user balances Segmentation\n', '    function ShowSegmentation(address _addr, uint256 _times,uint256 _period) public view returns (uint256) {\n', '        return userbalancesSegmentation[_addr][_times][_period];\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining); \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is controllable, Pausable, Token, Lockable {\n', '\n', '    function transfer(address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n', '            // sender\n', '            balances[msg.sender] = safeSubtract(balances[msg.sender],_value);\n', '            totalbalances[msg.sender] = safeSubtract(totalbalances[msg.sender],_value);\n', '            // _to\n', '            balances[_to] = safeAdd(balances[_to],_value);\n', '            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n', '\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n', '            // _to\n', '            balances[_to] = safeAdd(balances[_to],_value);\n', '            totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n', '            // _from\n', '            balances[_from] = safeSubtract(balances[_from],_value);\n', '            totalbalances[_from] = safeSubtract(totalbalances[_from],_value);\n', '            // allowed\n', '            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value);\n', '\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) { \n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    // mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract BugXToken is StandardToken {\n', '\n', '    /**\n', '    *  base parameters\n', '    */\n', '\n', '    // metadata\n', '    string  public constant name = "BUGX2.0";\n', '    string  public constant symbol = "BUGX";\n', '    uint256 public constant decimals = 18;\n', '    string  public version = "2.0";\n', '\n', '    // contracts\n', '    address public newContractAddr;         // the new contract for BUGX token updates;\n', '\n', '    // crowdsale parameters\n', '    bool    public isFunding;                // switched to true in operational state\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingStopBlock;\n', '\n', '    uint256 public currentSupply;           // current supply tokens for sell\n', '    uint256 public tokenRaised = 0;           // the number of total sold token\n', '    uint256 public tokenIssued = 0;         // the number of total issued token\n', '    uint256 public tokenMigrated = 0;     // the number of total Migrated token\n', '    uint256 internal tokenExchangeRate = 9000;             // 9000 BUGX tokens per 1 ETH\n', '    uint256 internal tokenExchangeRateTwo = 9900;             // 9000 * 1.1 BUGX tokens per 1 ETH\n', '    uint256 internal tokenExchangeRateThree = 11250;             // 9000 * 1.25 BUGX tokens per 1 ETH\n', '\n', '    // events\n', '    event AllocateToken(address indexed _to, uint256 _value);   // issue token to buyer;\n', '    event TakebackToken(address indexed _from, uint256 _value);   //  record token take back info;\n', '    event RaiseToken(address indexed _to, uint256 _value);      // record token raise info;\n', '    event IssueToken(address indexed _to, uint256 _value);\n', '    event IncreaseSupply(uint256 _value);\n', '    event DecreaseSupply(uint256 _value);\n', '    event Migrate(address indexed _addr, uint256 _tokens, uint256 _totaltokens);\n', '\n', '    // format decimals.\n', '    function formatDecimals(uint256 _value) internal pure returns (uint256 ) {\n', '        return _value * 10 ** decimals;\n', '    }\n', '\n', '    /**\n', '    *  constructor function\n', '    */\n', '\n', '    // constructor\n', '    constructor(\n', '        address _ethFundDeposit,\n', '        uint256 _currentSupply\n', '        ) \n', '        public\n', '    {\n', '        require(_ethFundDeposit != address(0x0));\n', '        ethFundDeposit = _ethFundDeposit;\n', '\n', '        isFunding = false;                           //controls pre through crowdsale state\n', '        fundingStartBlock = 0;\n', '        fundingStopBlock = 0;\n', '\n', '        currentSupply = formatDecimals(_currentSupply);\n', '        totalSupply = formatDecimals(1500000000);    //1,500,000,000 total supply\n', '        require(currentSupply <= totalSupply);\n', '        balances[ethFundDeposit] = currentSupply;\n', '        totalbalances[ethFundDeposit] = currentSupply;\n', '    }\n', '\n', '    /**\n', '    *  Modify currentSupply functions\n', '    */\n', '\n', "    /// @dev increase the token's supply\n", '    function increaseSupply (uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        require (_value + currentSupply <= totalSupply);\n', '        currentSupply = safeAdd(currentSupply, _value);\n', '        tokenadd(ethFundDeposit,_value);\n', '        emit IncreaseSupply(_value);\n', '    }\n', '\n', "    /// @dev decrease the token's supply\n", '    function decreaseSupply (uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        currentSupply = safeSubtract(currentSupply, _value);\n', '        tokensub(ethFundDeposit,_value);\n', '        emit DecreaseSupply(_value);\n', '    }\n', '\n', '    /**\n', '    *  Funding functions\n', '    */\n', '\n', '    modifier whenFunding() {\n', '        require (isFunding);\n', '        require (block.number >= fundingStartBlock);\n', '        require (block.number <= fundingStopBlock);\n', '        _;\n', '    }\n', '\n', '    /// @dev turn on the funding state\n', '    function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {\n', '        require (!isFunding);\n', '        require (_fundingStartBlock < _fundingStopBlock);\n', '        require (block.number < _fundingStartBlock);\n', '\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingStopBlock = _fundingStopBlock;\n', '        isFunding = true;\n', '    }\n', '\n', '    /// @dev turn off the funding state\n', '    function stopFunding() onlyOwner external {\n', '        require (isFunding);\n', '        isFunding = false;\n', '    }\n', '\n', '\n', '    /**\n', '    *  migrate functions\n', '    */\n', '\n', '    /// @dev set a new contract for recieve the tokens (for update contract)\n', '    function setMigrateContract(address _newContractAddr) onlyOwner external {\n', '        require (_newContractAddr != newContractAddr);\n', '        newContractAddr = _newContractAddr;\n', '    }\n', '\n', '    /// sends the tokens to new contract by owner\n', '    function migrate(address _addr) onlySelfOrOwner(_addr) external {\n', '        require(!isFunding);\n', '        require(newContractAddr != address(0x0));\n', '\n', '        uint256 tokens_value = balances[_addr];\n', '        uint256 totaltokens_value = totalbalances[_addr];\n', '        require (tokens_value != 0 || totaltokens_value != 0);\n', '\n', '        balances[_addr] = 0;\n', '        totalbalances[_addr] = 0;\n', '\n', '        IMigrationContract newContract = IMigrationContract(newContractAddr);\n', '        require (newContract.migrate(_addr, tokens_value, totaltokens_value));\n', '\n', '        tokenMigrated = safeAdd(tokenMigrated, totaltokens_value);\n', '        emit Migrate(_addr, tokens_value, totaltokens_value);\n', '    }\n', '\n', '    /**\n', '    *  tokenRaised and tokenIssued control functions\n', '    *  base functions\n', '    */\n', '\n', '    /// token raised\n', '    function tokenRaise (address _addr,uint256 _value) internal {\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        tokenRaised = safeAdd(tokenRaised, _value);\n', '        emit RaiseToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token 1 : token issued\n', '    function tokenIssue (address _addr,uint256 _value) internal {\n', '        uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n', '        require (safeAdd(_value,tokenCirculation) <= currentSupply);\n', '        tokenIssued = safeAdd(tokenIssued, _value);\n', '        emit IssueToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token 2 : issue token take back\n', '    function tokenTakeback (address _addr,uint256 _value) internal {\n', '        require (tokenIssued >= _value);\n', '        tokenIssued = safeSubtract(tokenIssued, _value);\n', '        emit TakebackToken(_addr, _value);\n', '    }\n', '\n', '    /// issue token take from ethFundDeposit to user\n', '    function tokenadd (address _addr,uint256 _value) internal {\n', '        require(_value != 0);\n', '        require (_addr != address(0x0));\n', '        balances[_addr] = safeAdd(balances[_addr], _value);\n', '        totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n', '    }\n', '\n', '    /// issue token take from user to ethFundDeposit\n', '    function tokensub (address _addr,uint256 _value) internal {\n', '        require(_value != 0);\n', '        require (_addr != address(0x0));\n', '        balances[_addr] = safeSubtract(balances[_addr], _value);\n', '        totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n', '    }\n', '\n', '    /**\n', '    *  tokenRaised and tokenIssued control functions\n', '    *  main functions\n', '    */\n', '\n', '    /// Issues tokens to buyers.\n', '    function allocateToken(address _addr, uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokenadd(_addr,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        tokenIssue(_addr,_value);\n', '        emit Transfer(ethFundDeposit, _addr, _value);\n', '    }\n', '\n', '    /// Issues tokens deduction.\n', '    function deductionToken (address _addr, uint256 _tokens) onlyOwner external {\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokensub(_addr,_value);\n', '        tokenadd(ethFundDeposit,_value);\n', '        tokenTakeback(_addr,_value);\n', '        emit Transfer(_addr, ethFundDeposit, _value);\n', '    }\n', '\n', '    /// add the segmentation\n', '    function addSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n', '        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n', '        if (amount != 0 && _tokens != 0){\n', '            uint256 _value = formatDecimals(_tokens);\n', '            userbalancesSegmentation[_addr][_times][_period] = safeAdd(amount,_value);\n', '            userbalances[_addr][_times] = safeAdd(userbalances[_addr][_times], _value);\n', '            totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n', '            tokensub(ethFundDeposit,_value);\n', '            tokenIssue(_addr,_value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// sub the segmentation\n', '    function subSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n', '        uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n', '        if (amount != 0 && _tokens != 0){\n', '            uint256 _value = formatDecimals(_tokens);\n', '            userbalancesSegmentation[_addr][_times][_period] = safeSubtract(amount,_value);\n', '            userbalances[_addr][_times] = safeSubtract(userbalances[_addr][_times], _value);\n', '            totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n', '            tokenadd(ethFundDeposit,_value);\n', '            tokenTakeback(_addr,_value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '    *  tokenExchangeRate functions\n', '    */\n', '\n', "    /// @dev set the token's tokenExchangeRate,\n", '    function setTokenExchangeRate(uint256 _RateOne,uint256 _RateTwo,uint256 _RateThree) onlyOwner external {\n', '        require (_RateOne != 0 && _RateTwo != 0 && _RateThree != 0);\n', '        require (_RateOne != tokenExchangeRate && _RateTwo != tokenExchangeRateTwo && _RateThree != tokenExchangeRateThree);\n', '\n', '        tokenExchangeRate = _RateOne;\n', '        tokenExchangeRateTwo = _RateTwo;\n', '        tokenExchangeRateThree = _RateThree;\n', '    }\n', '\n', '    /// calculate the tokenExchangeRate\n', '    function computeTokenAmount(uint256 _eth) internal view returns (uint256 tokens) {\n', '        if(_eth > 0 && _eth < 100 ether){\n', '            tokens = safeMult(_eth, tokenExchangeRate);\n', '        }\n', '        \n', '        if (_eth >= 100 ether && _eth < 500 ether){\n', '            tokens = safeMult(_eth, tokenExchangeRateTwo);\n', '        }\n', '\n', '        if (_eth >= 500 ether ){\n', '            tokens = safeMult(_eth, tokenExchangeRateThree);\n', '        }\n', '    }\n', '\n', '    /**\n', '    *  Append : the LockMechanism functions by owner\n', '    */\n', '\n', '    function LockMechanismByOwner (\n', '        address _addr,\n', '        uint256 _tokens\n', '    )\n', '        external onlyOwner whenFunding\n', '    {\n', '        require (_tokens != 0);\n', '        uint256 _value = formatDecimals(_tokens);\n', '        tokenRaise(_addr,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        LockMechanism(_addr,_value);\n', '        emit Transfer(ethFundDeposit,_addr,_value);\n', '    }\n', '\n', '    /**\n', '    *  ETH control functions\n', '    */\n', '\n', '    /// @dev sends ETH to BUGX team\n', '    function transferETH() onlyOwner external {\n', '        require (address(this).balance != 0);\n', '        ethFundDeposit.transfer(address(this).balance);\n', '    }\n', '\n', '    function () public payable whenFunding { // fallback function\n', '        require (msg.value != 0);\n', '        uint256 _value = computeTokenAmount(msg.value);\n', '        tokenRaise(msg.sender,_value);\n', '        tokensub(ethFundDeposit,_value);\n', '        LockMechanism(msg.sender,_value);\n', '        emit Transfer(ethFundDeposit,msg.sender,_value);\n', '    }\n', '}']
