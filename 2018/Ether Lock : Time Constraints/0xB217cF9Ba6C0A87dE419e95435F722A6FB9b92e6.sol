['pragma solidity ^0.4.19;\n', '\n', '\n', 'contract AddressProxy {\n', '\n', '    struct ContractAddress {\n', '        bytes32 id;\n', '        string name;\n', '        address at;\n', '        uint createdTime;\n', '        uint updatedTime;\n', '    }\n', '\n', '    address public owner;\n', '    mapping(bytes32 => ContractAddress) private contractsAddress;\n', '    bytes32[] public availableIds;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event AddressCreated(bytes32 id, string name, address at, uint createdTime, uint updatedTime);\n', '    event AddressUpdated(bytes32 id, string name, address at, uint createdTime, uint updatedTime);\n', '\n', '    function AddressProxy() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function getAvailableIds() public view returns (bytes32[]) {\n', '        return availableIds;\n', '    }\n', '\n', '    //  Adds or updates an address\n', '    //  @params {string} name - the name of the contract Address\n', '    //  @params {address} newAddress\n', '    function addAddress(string name, address newAddress) public onlyOwner {\n', '        bytes32 contAddId = stringToBytes32(name);\n', '\n', '        uint nowInMilliseconds = now * 1000;\n', '\n', '        if (contractsAddress[contAddId].id == 0x0) {\n', '            ContractAddress memory newContractAddress;\n', '            newContractAddress.id = contAddId;\n', '            newContractAddress.name = name;\n', '            newContractAddress.at = newAddress;\n', '            newContractAddress.createdTime = nowInMilliseconds;\n', '            newContractAddress.updatedTime = nowInMilliseconds;\n', '            availableIds.push(contAddId);\n', '            contractsAddress[contAddId] = newContractAddress;\n', '\n', '            emit AddressCreated(newContractAddress.id, newContractAddress.name, newContractAddress.at, newContractAddress.createdTime, newContractAddress.updatedTime);\n', '        } else {\n', '            ContractAddress storage contAdd = contractsAddress[contAddId];\n', '            contAdd.at = newAddress;\n', '            contAdd.updatedTime = nowInMilliseconds;\n', '\n', '            emit AddressUpdated(contAdd.id, contAdd.name, contAdd.at, contAdd.createdTime, contAdd.updatedTime);\n', '        }\n', '    }\n', '\n', '    function getContractNameById(bytes32 id) public view returns(string) {\n', '        return contractsAddress[id].name;\n', '    }\n', '\n', '    function getContractAddressById(bytes32 id) public view returns(address) {\n', '        return contractsAddress[id].at;\n', '    }\n', '\n', '    function getContractCreatedTimeById(bytes32 id) public view returns(uint) {\n', '        return contractsAddress[id].createdTime;\n', '    }\n', '\n', '    function getContractUpdatedTimeById(bytes32 id) public view returns(uint) {\n', '        return contractsAddress[id].updatedTime;\n', '    }\n', '\n', '    //  @params {string} source\n', '    //  @return {bytes32}\n', '    function stringToBytes32(string source) internal pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '\n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '}']