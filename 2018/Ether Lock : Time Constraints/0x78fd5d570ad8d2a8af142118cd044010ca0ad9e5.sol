['pragma solidity ^0.4.21;\n', '\n', '/*************************/\n', '/* Blocksquare Series A  */\n', '/*************************/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function tranferOwnership(address _newOwner) public onlyOwner() {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function mintTokens(address _atAddress, uint256 _amount) public;\n', '}\n', '\n', 'contract Whitelist {\n', '    function isWhitelisted(address _user) constant public returns(bool);\n', '}\n', '\n', '\n', '/****************************************/\n', '/* BLOCKSQUARE SERIES A IMPLEMENTATION  */\n', '/****************************************/\n', 'contract BlocksquareSeriesA is owned {\n', '    using SafeMath for uint256;\n', '\n', '    /** Events **/\n', '    event Received(address indexed _from, uint256 _amount);\n', '    event FundsReturned(address indexed _to, uint256 _amount);\n', '    event TokensGiven(address indexed _to, uint256 _amount);\n', '    event ErrorReturningEth(address _to, uint256 _amount);\n', '\n', '    /** Public variables **/\n', '    uint256 public currentAmountRaised;\n', '    uint256 public currentAmountOfTokensWithNoBonus;\n', '    uint256 public valueInUSD;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    address public recipient;\n', '\n', '    /** Private variables **/\n', '    uint256 nextParticipantIndex;\n', '    uint256 currentAmountOfTokens;\n', '    bool icoHasStarted;\n', '    bool icoHasClosed;\n', '    Token reward;\n', '    Whitelist whitelist;\n', '\n', '    /** Constants **/\n', '    uint256 BONUS25 = 60*60;\n', '    uint256 BONUS15 = BONUS25.add(60*60*24*4);\n', '    uint256 BONUS7 = BONUS15.add(60*60*24*5);\n', '    uint256 PRICEOFTOKEN = 25; // It means 0.25 USD\n', '    uint256 MAXAMOUNTOFTOKENS = (1200000 * 10 ** 18);\n', '\n', '    /** Mappings **/\n', '    mapping(address => uint256) contributed;\n', '    mapping(uint256 => address) participantIndex;\n', '\n', '    function BlocksquareSeriesA() public {\n', '        owner = msg.sender;\n', '        recipient = msg.sender;\n', '        reward = Token(0x509A38b7a1cC0dcd83Aa9d06214663D9eC7c7F4a);\n', '        whitelist = Whitelist(0xCB641F6B46e1f2970dB003C19515018D0338550a);\n', '    }\n', '\n', '    /**\n', '    * Basic payment\n', '    **/\n', '    function () payable public {\n', '        require(reward != address(0));\n', '        require(whitelist != address(0));\n', '        require(msg.value >= (2 ether / 10));\n', '        require(icoHasStarted);\n', '        require(!icoHasClosed);\n', '        require(valueInUSD != 0);\n', '        require(whitelist.isWhitelisted(msg.sender));\n', '        if(contributed[msg.sender] == 0) {\n', '            participantIndex[nextParticipantIndex] = msg.sender;\n', '            nextParticipantIndex += 1;\n', '        }\n', '\n', '        uint256 amountOfWei = msg.value;\n', '\n', '        contributed[msg.sender] = contributed[msg.sender].add(amountOfWei);\n', '        currentAmountRaised = currentAmountRaised.add(amountOfWei);\n', '        uint256 tokens = tokensToMint(amountOfWei);\n', '\n', '        reward.mintTokens(msg.sender, tokens);\n', '        currentAmountOfTokens = currentAmountOfTokens.add(tokens);\n', '        emit Received(msg.sender, msg.value);\n', '        emit TokensGiven(msg.sender, tokens);\n', '\n', '        if(address(this).balance >= 50 ether) {\n', '            if(!address(recipient).send(address(this).balance)) {\n', '                emit ErrorReturningEth(recipient, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '    * Calculate tokens to mint.\n', '    *\n', '    * Calculets how much tokens sender will get based on _amountOfWei he sent.\n', '    *\n', '    * @param _amountOfWei Amount of wei sender has sent to the contract.\n', '    * @return Number of tokens sender will recieve.\n', '    **/\n', '    function tokensToMint(uint256 _amountOfWei) private returns (uint256) {\n', '        uint256 tokensPerEth = valueInUSD.div(PRICEOFTOKEN);\n', '\n', '        uint256 rewardAmount = tokensPerEth.mul(_amountOfWei);\n', '        if(currentAmountOfTokensWithNoBonus.add(rewardAmount) > MAXAMOUNTOFTOKENS) {\n', '            icoHasClosed = true;\n', '            uint256 over = currentAmountOfTokensWithNoBonus.add(rewardAmount).sub(MAXAMOUNTOFTOKENS);\n', '            rewardAmount = rewardAmount.sub(over);\n', '            uint256 weiToReturn = over.div(tokensPerEth);\n', '            currentAmountRaised = currentAmountRaised.sub(weiToReturn);\n', '            contributed[msg.sender] = contributed[msg.sender].sub(weiToReturn);\n', '            if(address(msg.sender).send(weiToReturn)) {\n', '                emit ErrorReturningEth(msg.sender, weiToReturn);\n', '            }\n', '        }\n', '        currentAmountOfTokensWithNoBonus = currentAmountOfTokensWithNoBonus.add(rewardAmount);\n', '\n', '        if(block.timestamp <= startTime.add(BONUS25)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(25).div(100));\n', '        }\n', '        else if(block.timestamp <= startTime.add(BONUS15)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(15).div(100));\n', '        }\n', '        else if(block.timestamp <= startTime.add(BONUS7)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(7).div(100));\n', '        }\n', '\n', '        return rewardAmount;\n', '    }\n', '\n', '    /**\n', '    * Change USD value\n', '    *\n', '    * Change value of ETH in USD\n', '    *\n', '    * @param _value New value of ETH in USD\n', '    **/\n', '    function changeETHUSD(uint256 _value) public onlyOwner {\n', '        valueInUSD = _value;\n', '    }\n', '\n', '    /**\n', '    * Start Series A\n', '    *\n', '    * Starts Series A and sets value of ETH in USD.\n', '    *\n', '    * @param _value Value of ETH in USD.\n', '    **/\n', '    function start(uint256 _value) public onlyOwner {\n', '        require(!icoHasStarted);\n', '        valueInUSD = _value;\n', '        startTime = block.timestamp;\n', '        endTime = startTime.add(60*60).add(60*60*24*16);\n', '        icoHasStarted = true;\n', '    }\n', '\n', '    /**\n', '    * Close Series A\n', '    *\n', '    * Closes Series A.\n', '    **/\n', '    function closeICO() public onlyOwner {\n', '        require(icoHasStarted);\n', '        icoHasClosed = true;\n', '    }\n', '\n', '    /**\n', '    * Withdraw Ether\n', '    *\n', '    * Withdraw Ether from contract.\n', '    **/\n', '    function withdrawEther() public onlyOwner {\n', '        if(!address(recipient).send(address(this).balance)) {\n', '            emit ErrorReturningEth(recipient, address(this).balance);\n', '        }\n', '    }\n', '\n', '    /** Getters functions for info **/\n', '    function getToken() constant public returns (address _tokenAddress) {\n', '        return address(reward);\n', '    }\n', '\n', '    function isCrowdsaleOpen() constant public returns (bool _isOpened) {\n', '        return (!icoHasClosed && icoHasStarted);\n', '    }\n', '\n', '    function amountContributed(address _contributor) constant public returns(uint256 _contributedUntilNow){\n', '        return contributed[_contributor];\n', '    }\n', '\n', '    function numberOfContributors() constant public returns(uint256 _numOfContributors){\n', '        return nextParticipantIndex;\n', '    }\n', '\n', '    function numberOfTokens() constant public returns(uint256) {\n', '        return currentAmountOfTokens;\n', '    }\n', '\n', '    function hasAllowanceToRecieveTokens(address _address) constant public returns(bool) {\n', '        return whitelist.isWhitelisted(_address);\n', '    }\n', '}']
['pragma solidity ^0.4.21;\n', '\n', '/*************************/\n', '/* Blocksquare Series A  */\n', '/*************************/\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function tranferOwnership(address _newOwner) public onlyOwner() {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'contract Token {\n', '    function mintTokens(address _atAddress, uint256 _amount) public;\n', '}\n', '\n', 'contract Whitelist {\n', '    function isWhitelisted(address _user) constant public returns(bool);\n', '}\n', '\n', '\n', '/****************************************/\n', '/* BLOCKSQUARE SERIES A IMPLEMENTATION  */\n', '/****************************************/\n', 'contract BlocksquareSeriesA is owned {\n', '    using SafeMath for uint256;\n', '\n', '    /** Events **/\n', '    event Received(address indexed _from, uint256 _amount);\n', '    event FundsReturned(address indexed _to, uint256 _amount);\n', '    event TokensGiven(address indexed _to, uint256 _amount);\n', '    event ErrorReturningEth(address _to, uint256 _amount);\n', '\n', '    /** Public variables **/\n', '    uint256 public currentAmountRaised;\n', '    uint256 public currentAmountOfTokensWithNoBonus;\n', '    uint256 public valueInUSD;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    address public recipient;\n', '\n', '    /** Private variables **/\n', '    uint256 nextParticipantIndex;\n', '    uint256 currentAmountOfTokens;\n', '    bool icoHasStarted;\n', '    bool icoHasClosed;\n', '    Token reward;\n', '    Whitelist whitelist;\n', '\n', '    /** Constants **/\n', '    uint256 BONUS25 = 60*60;\n', '    uint256 BONUS15 = BONUS25.add(60*60*24*4);\n', '    uint256 BONUS7 = BONUS15.add(60*60*24*5);\n', '    uint256 PRICEOFTOKEN = 25; // It means 0.25 USD\n', '    uint256 MAXAMOUNTOFTOKENS = (1200000 * 10 ** 18);\n', '\n', '    /** Mappings **/\n', '    mapping(address => uint256) contributed;\n', '    mapping(uint256 => address) participantIndex;\n', '\n', '    function BlocksquareSeriesA() public {\n', '        owner = msg.sender;\n', '        recipient = msg.sender;\n', '        reward = Token(0x509A38b7a1cC0dcd83Aa9d06214663D9eC7c7F4a);\n', '        whitelist = Whitelist(0xCB641F6B46e1f2970dB003C19515018D0338550a);\n', '    }\n', '\n', '    /**\n', '    * Basic payment\n', '    **/\n', '    function () payable public {\n', '        require(reward != address(0));\n', '        require(whitelist != address(0));\n', '        require(msg.value >= (2 ether / 10));\n', '        require(icoHasStarted);\n', '        require(!icoHasClosed);\n', '        require(valueInUSD != 0);\n', '        require(whitelist.isWhitelisted(msg.sender));\n', '        if(contributed[msg.sender] == 0) {\n', '            participantIndex[nextParticipantIndex] = msg.sender;\n', '            nextParticipantIndex += 1;\n', '        }\n', '\n', '        uint256 amountOfWei = msg.value;\n', '\n', '        contributed[msg.sender] = contributed[msg.sender].add(amountOfWei);\n', '        currentAmountRaised = currentAmountRaised.add(amountOfWei);\n', '        uint256 tokens = tokensToMint(amountOfWei);\n', '\n', '        reward.mintTokens(msg.sender, tokens);\n', '        currentAmountOfTokens = currentAmountOfTokens.add(tokens);\n', '        emit Received(msg.sender, msg.value);\n', '        emit TokensGiven(msg.sender, tokens);\n', '\n', '        if(address(this).balance >= 50 ether) {\n', '            if(!address(recipient).send(address(this).balance)) {\n', '                emit ErrorReturningEth(recipient, address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '    * Calculate tokens to mint.\n', '    *\n', '    * Calculets how much tokens sender will get based on _amountOfWei he sent.\n', '    *\n', '    * @param _amountOfWei Amount of wei sender has sent to the contract.\n', '    * @return Number of tokens sender will recieve.\n', '    **/\n', '    function tokensToMint(uint256 _amountOfWei) private returns (uint256) {\n', '        uint256 tokensPerEth = valueInUSD.div(PRICEOFTOKEN);\n', '\n', '        uint256 rewardAmount = tokensPerEth.mul(_amountOfWei);\n', '        if(currentAmountOfTokensWithNoBonus.add(rewardAmount) > MAXAMOUNTOFTOKENS) {\n', '            icoHasClosed = true;\n', '            uint256 over = currentAmountOfTokensWithNoBonus.add(rewardAmount).sub(MAXAMOUNTOFTOKENS);\n', '            rewardAmount = rewardAmount.sub(over);\n', '            uint256 weiToReturn = over.div(tokensPerEth);\n', '            currentAmountRaised = currentAmountRaised.sub(weiToReturn);\n', '            contributed[msg.sender] = contributed[msg.sender].sub(weiToReturn);\n', '            if(address(msg.sender).send(weiToReturn)) {\n', '                emit ErrorReturningEth(msg.sender, weiToReturn);\n', '            }\n', '        }\n', '        currentAmountOfTokensWithNoBonus = currentAmountOfTokensWithNoBonus.add(rewardAmount);\n', '\n', '        if(block.timestamp <= startTime.add(BONUS25)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(25).div(100));\n', '        }\n', '        else if(block.timestamp <= startTime.add(BONUS15)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(15).div(100));\n', '        }\n', '        else if(block.timestamp <= startTime.add(BONUS7)) {\n', '            rewardAmount = rewardAmount.add(rewardAmount.mul(7).div(100));\n', '        }\n', '\n', '        return rewardAmount;\n', '    }\n', '\n', '    /**\n', '    * Change USD value\n', '    *\n', '    * Change value of ETH in USD\n', '    *\n', '    * @param _value New value of ETH in USD\n', '    **/\n', '    function changeETHUSD(uint256 _value) public onlyOwner {\n', '        valueInUSD = _value;\n', '    }\n', '\n', '    /**\n', '    * Start Series A\n', '    *\n', '    * Starts Series A and sets value of ETH in USD.\n', '    *\n', '    * @param _value Value of ETH in USD.\n', '    **/\n', '    function start(uint256 _value) public onlyOwner {\n', '        require(!icoHasStarted);\n', '        valueInUSD = _value;\n', '        startTime = block.timestamp;\n', '        endTime = startTime.add(60*60).add(60*60*24*16);\n', '        icoHasStarted = true;\n', '    }\n', '\n', '    /**\n', '    * Close Series A\n', '    *\n', '    * Closes Series A.\n', '    **/\n', '    function closeICO() public onlyOwner {\n', '        require(icoHasStarted);\n', '        icoHasClosed = true;\n', '    }\n', '\n', '    /**\n', '    * Withdraw Ether\n', '    *\n', '    * Withdraw Ether from contract.\n', '    **/\n', '    function withdrawEther() public onlyOwner {\n', '        if(!address(recipient).send(address(this).balance)) {\n', '            emit ErrorReturningEth(recipient, address(this).balance);\n', '        }\n', '    }\n', '\n', '    /** Getters functions for info **/\n', '    function getToken() constant public returns (address _tokenAddress) {\n', '        return address(reward);\n', '    }\n', '\n', '    function isCrowdsaleOpen() constant public returns (bool _isOpened) {\n', '        return (!icoHasClosed && icoHasStarted);\n', '    }\n', '\n', '    function amountContributed(address _contributor) constant public returns(uint256 _contributedUntilNow){\n', '        return contributed[_contributor];\n', '    }\n', '\n', '    function numberOfContributors() constant public returns(uint256 _numOfContributors){\n', '        return nextParticipantIndex;\n', '    }\n', '\n', '    function numberOfTokens() constant public returns(uint256) {\n', '        return currentAmountOfTokens;\n', '    }\n', '\n', '    function hasAllowanceToRecieveTokens(address _address) constant public returns(bool) {\n', '        return whitelist.isWhitelisted(_address);\n', '    }\n', '}']
