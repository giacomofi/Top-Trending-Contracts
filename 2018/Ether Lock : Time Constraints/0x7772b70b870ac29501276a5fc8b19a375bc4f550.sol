['pragma experimental "v0.5.0";\n', '\n', '////////////////////\n', '//   HOURLY PAY   //\n', '//    CONTRACT    //\n', '//    v 0.2.1     //\n', '////////////////////\n', '\n', '// The Hourly Pay Contract allows you to track your time and get paid a hourly wage for tracked time.\n', '//\n', '// HOW IT WORKS:\n', '//\n', '//  1. Client creates the contract, making himself the owner of the contract.\n', '//\n', '//  2. Client can fund the contract with ETH by simply sending money to the contract (via payable fallback function).\n', '//\n', '//  3. Before hiring someone, client can change additional parameters, such as:\n', '//\n', '//      - setContractDurationInDays(days) - The duration of the contract (default is 365 days).\n', '//\n', '//      - setDailyHourLimit(hours) - How much hours the Employee can work per day (default is 8 hours).\n', '//\n', '//      - setPaydayFrequencyInDays(days) - How often the Employee can withdraw the earnings (default is every 3 days).\n', '//\n', '//      - setBeginTimeTS(utcTimestamp) - Work on contract can be started after this timestamp (default is contract creation time).\n', '//                                       Also defines the start of Day and Week for accounting and daily limits.\n', '//                                       Day transition time should be convenient for the employee (like 4am),\n', '//                                       so that work doesn&#39;t cross between days,\n', '//                                       The excess won&#39;t be transferred to the next day.\n', '//\n', '//  4. Client hires the Employee by invoking hire(addressOfEmployee, ratePerHourInWei)\n', '//     This starts the project and puts the contract in a workable state.\n', '//     Before hiring, contract should be loaded with enough ETH to provide at least one day of work at specified ratePerHourInWei\n', '// \n', '//  5. To start work and earn ETH the Employee should:\n', '//\n', '//      invoke startWork() when he starts working to run the timer.\n', '//\n', '//      invoke stopWork() when he finishes working to stop the timer.\n', '//\n', '//    After the timer is stopped - the ETH earnings are calculated and recorded on Employee&#39;s internal balance.\n', '//    If the stopWork() is invoked after more hours had passed than dailyLimit - the excess is ignored\n', '//    and only the dailyLimit is added to the internal balance.\n', '//\n', '//  6. Employee can withdraw earnings from internal balance after paydayFrequencyInDays days have passed after BeginTimeTS:\n', '//      by invoking withdraw()\n', '//\n', '//    After each withdrawal the paydayFrequencyInDays is reset and starts counting itself from the TS of the first startWork() after withdrawal.\n', '//\n', '//    This delay is implemented as a safety mechanism, so the Client can have time to check the work and\n', '//    cancel the earnings if something goes wrong.\n', '//    That way only money earned during the last paydayFrequencyInDays is at risk.\n', '//\n', '//  7. Client can fire() the Employee after his services are no longer needed.\n', '//    That would stop any ongoing work by terminating the timer and won&#39;t allow to start the work again.\n', '//\n', '//  8. If anything in the relationship or hour counting goes wrong, there are safety functions:\n', '//      - refundAll() - terminates all unwithdrawn earnings.\n', '//      - refund(amount) - terminates the (amount) of unwithdrawn earnings.\n', '//    Can be only called if not working.\n', '//    Both of these can be called by Client or Employee.\n', '//      * TODO: Still need to think if allowing Client to do that won&#39;t hurt the Employee.\n', '//      * TODO: SecondsWorkedToday don&#39;t reset after refund, so dailyLimit still affects\n', '//      * TODO: Think of a better name. ClearEarnings?\n', '//\n', '//  9. Client can withdraw any excess ETH from the contract via:\n', '//      - clientWithdrawAll() - withdraws all funds minus locked in earnings.\n', '//      - clientWithdraw(amount) - withdraws (amount), not locked in earnings.\n', '//     Can be invoked only if Employee isn&#39;t hired or has been fired.\n', '//\n', '// 10. Client and Contract Ownership can be made "Public"/"None" by calling:\n', '//      - releaseOwnership()\n', '//     It simply sets the Owner (Client) to 0x0, so no one is in control of the contract anymore.\n', '//     That way the contract can be used on projects as Hourly-Wage Donations.\n', '//\n', '///////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', 'contract HourlyPay { \n', '\n', '    ////////////////////////////////\n', '    // Addresses\n', '\n', '    address public owner;           // Client and owner address\n', '    address public employeeAddress = 0x0;  // Employee address\n', '\n', '\n', '    /////////////////////////////////\n', '    // Contract business properties\n', '    \n', '    uint public beginTimeTS;               // When the contract work can be started. Also TS of day transition.\n', '    uint public ratePerHourInWei;          // Employee rate in wei\n', '    uint public earnings = 0;              // Earnings of employee\n', '    bool public hired = false;             // If the employee is hired and approved to perform work\n', '    bool public working = false;           // Is employee currently working with timer on?\n', '    uint public startedWorkTS;             // Timestamp of when the timer started counting time\n', '    uint public workedTodayInSeconds = 0;  // How many seconds worked today\n', '    uint public currentDayTS;\n', '    uint public lastPaydayTS;\n', '    string public contractName = "Hourly Pay Contract";\n', '\n', '    ////////////////////////////////\n', '    // Contract Limits and maximums\n', '    \n', '    uint16 public contractDurationInDays = 365;  // Overall contract duration in days, default is 365 and it&#39;s also maximum for safety reasons\n', '    uint8 public dailyHourLimit = 8;               // Limits the hours per day, max 24 hours\n', '    uint8 public paydayFrequencyInDays = 3;       // How often can Withdraw be called, default is every 3 days\n', '\n', '    uint8 constant hoursInWeek = 168;\n', '    uint8 constant maxDaysInFrequency = 30; // every 30 days is a wise maximum\n', '\n', '\n', '    ////////////////\n', '    // Constructor\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        beginTimeTS = now;\n', '        currentDayTS = beginTimeTS;\n', '        lastPaydayTS = beginTimeTS;\n', '    }\n', '\n', '\n', '    //////////////\n', '    // Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEmployee {\n', '        require(msg.sender == employeeAddress);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwnerOrEmployee {\n', '        require((msg.sender == employeeAddress) || (msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    modifier beforeHire {\n', '        require(employeeAddress == 0x0);                        // Contract can hire someone only once\n', '        require(hired == false);                                // Shouldn&#39;t be already hired\n', '        _;\n', '    }\n', '\n', '\n', '    ///////////\n', '    // Events\n', '    \n', '    event GotFunds(address sender, uint amount);\n', '    event ContractDurationInDaysChanged(uint16 contractDurationInDays);\n', '    event DailyHourLimitChanged(uint8 dailyHourLimit);\n', '    event PaydayFrequencyInDaysChanged(uint32 paydayFrequencyInDays);\n', '    event BeginTimeTSChanged(uint beginTimeTS);\n', '    event Hired(address employeeAddress, uint ratePerHourInWei, uint hiredTS);\n', '    event NewDay(uint currentDayTS, uint16 contractDaysLeft);\n', '    event StartedWork(uint startedWorkTS, uint workedTodayInSeconds, string comment);\n', '    event StoppedWork(uint stoppedWorkTS, uint workedInSeconds, uint earned);\n', '    event Withdrawal(uint amount, address employeeAddress, uint withdrawalTS);\n', '    event Fired(address employeeAddress, uint firedTS);\n', '    event Refunded(uint amount, address whoInitiatedRefund, uint refundTS);\n', '    event ClientWithdrawal(uint amount, uint clientWithdrawalTS);\n', '    event ContractNameChanged(string contractName);\n', '    \n', '    ////////////////////////////////////////////////\n', '    // Fallback function to fund contract with ETH\n', '    \n', '    function () external payable {\n', '        emit GotFunds(msg.sender, msg.value);\n', '    }\n', '    \n', '    \n', '    ///////////////////////////\n', '    // Main Setters\n', '\n', '    function setContractName(string newContractName) external onlyOwner beforeHire {\n', '        contractName = newContractName;\n', '        emit ContractNameChanged(contractName);\n', '    }\n', '\n', '    function setContractDurationInDays(uint16 newContractDurationInDays) external onlyOwner beforeHire {\n', '        require(newContractDurationInDays <= 365);\n', '        contractDurationInDays = newContractDurationInDays;\n', '        emit ContractDurationInDaysChanged(contractDurationInDays);\n', '    }\n', '    \n', '    function setDailyHourLimit(uint8 newDailyHourLimit) external onlyOwner beforeHire {\n', '        require(newDailyHourLimit <= 24);\n', '        dailyHourLimit = newDailyHourLimit;\n', '        emit DailyHourLimitChanged(dailyHourLimit);\n', '    }\n', '\n', '    function setPaydayFrequencyInDays(uint8 newPaydayFrequencyInDays) external onlyOwner beforeHire {\n', '        require(newPaydayFrequencyInDays < maxDaysInFrequency);\n', '        paydayFrequencyInDays = newPaydayFrequencyInDays;\n', '        emit PaydayFrequencyInDaysChanged(paydayFrequencyInDays);\n', '    }\n', '    \n', '    function setBeginTimeTS(uint newBeginTimeTS) external onlyOwner beforeHire {\n', '        beginTimeTS = newBeginTimeTS;\n', '        currentDayTS = beginTimeTS;\n', '        lastPaydayTS = beginTimeTS;\n', '        emit BeginTimeTSChanged(beginTimeTS);\n', '    }\n', '    \n', '    ///////////////////\n', '    // Helper getters\n', '    \n', '    function getWorkSecondsInProgress() public view returns(uint) {\n', '        if (!working) return 0;\n', '        return now - startedWorkTS;\n', '    }\n', '    \n', '    function isOvertime() external view returns(bool) {\n', '        if (workedTodayInSeconds + getWorkSecondsInProgress() > dailyHourLimit * 1 hours) return true;\n', '        return false;\n', '    }\n', '    \n', '    function hasEnoughFundsToStart() public view returns(bool) {\n', '        return ((address(this).balance > earnings) &&\n', '                (address(this).balance - earnings >= ratePerHourInWei * (dailyHourLimit * 1 hours - (isNewDay() ? 0 : workedTodayInSeconds)) / 1 hours));\n', '    }\n', '    \n', '    function isNewDay() public view returns(bool) {\n', '        return (now - currentDayTS > 1 days);\n', '    }\n', '    \n', '    function canStartWork() public view returns(bool) {\n', '        return (hired\n', '            && !working\n', '            && (now > beginTimeTS)\n', '            && (now < beginTimeTS + (contractDurationInDays * 1 days))\n', '            && hasEnoughFundsToStart()\n', '            && ((workedTodayInSeconds < dailyHourLimit * 1 hours) || isNewDay()));\n', '    }\n', '\n', '    function canStopWork() external view returns(bool) {\n', '        return (working\n', '            && hired\n', '            && (now > startedWorkTS));\n', '    }\n', '\n', '    function currentTime() external view returns(uint) {\n', '        return now;\n', '    }\n', '\n', '    function getBalance() external view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    ////////////////////////////\n', '    // Main workflow functions\n', '\n', '    function releaseOwnership() external onlyOwner {\n', '        owner = 0x0;\n', '    }\n', '\n', '    function hire(address newEmployeeAddress, uint newRatePerHourInWei) external onlyOwner beforeHire {\n', '        require(newEmployeeAddress != 0x0);                     // Protection from burning the ETH\n', '\n', '        // Contract should be loaded with ETH for a minimum one day balance to perform Hire:\n', '        require(address(this).balance >= newRatePerHourInWei * dailyHourLimit);\n', '        employeeAddress = newEmployeeAddress;\n', '        ratePerHourInWei = newRatePerHourInWei;\n', '        \n', '        hired = true;\n', '        emit Hired(employeeAddress, ratePerHourInWei, now);\n', '    }\n', '\n', '    function startWork(string comment) external onlyEmployee {\n', '        require(hired == true);\n', '        require(working == false);\n', '        \n', '        require(now > beginTimeTS); // can start working only after contract beginTimeTS\n', '        require(now < beginTimeTS + (contractDurationInDays * 1 days)); // can&#39;t start after contractDurationInDays has passed since beginTimeTS\n', '        \n', '        checkForNewDay();\n', '        \n', '        require(workedTodayInSeconds < dailyHourLimit * 1 hours); // can&#39;t start if already approached dailyHourLimit\n', '\n', '        require(address(this).balance > earnings); // balance must be greater than earnings        \n', '\n', '        // balance minus earnings must be sufficient for at least 1 day of work minus workedTodayInSeconds:\n', '        require(address(this).balance - earnings >= ratePerHourInWei * (dailyHourLimit * 1 hours - workedTodayInSeconds) / 1 hours);\n', '        \n', '        if (earnings == 0) lastPaydayTS = now; // reset the payday timer TS if this is the first time work starts after last payday\n', '\n', '        startedWorkTS = now;\n', '        working = true;\n', '        \n', '        emit StartedWork(startedWorkTS, workedTodayInSeconds, comment);\n', '    }\n', '    \n', '    function checkForNewDay() internal {\n', '        if (now - currentDayTS > 1 days) { // new day\n', '            while (currentDayTS < now) {\n', '                currentDayTS += 1 days;\n', '            }\n', '            currentDayTS -= 1 days;\n', '            workedTodayInSeconds = 0;\n', '            emit NewDay(currentDayTS, uint16 ((beginTimeTS + (contractDurationInDays * 1 days) - currentDayTS) / 1 days));\n', '        }\n', '    }\n', '    \n', '    function stopWork() external onlyEmployee {\n', '        stopWorkInternal();\n', '    }\n', '    \n', '    function stopWorkInternal() internal {\n', '        require(hired == true);\n', '        require(working == true);\n', '    \n', '        require(now > startedWorkTS); // just a temporary overflow check, in case of miners manipulate time\n', '        \n', '        \n', '        uint newWorkedTodayInSeconds = workedTodayInSeconds + (now - startedWorkTS);\n', '        if (newWorkedTodayInSeconds > dailyHourLimit * 1 hours) { // check for overflow\n', '            newWorkedTodayInSeconds = dailyHourLimit * 1 hours;   // and assign max dailyHourLimit if there is an overflow\n', '        }\n', '        \n', '        uint earned = (newWorkedTodayInSeconds - workedTodayInSeconds) * ratePerHourInWei / 1 hours;\n', '        earnings += earned; // add new earned ETH to earnings\n', '        \n', '        emit StoppedWork(now, newWorkedTodayInSeconds - workedTodayInSeconds, earned);\n', '\n', '        workedTodayInSeconds = newWorkedTodayInSeconds; // updated todays works in seconds\n', '        working = false;\n', '\n', '        checkForNewDay();\n', '    }\n', '\n', '    function withdraw() external onlyEmployee {\n', '        require(working == false);\n', '        require(earnings > 0);\n', '        require(earnings <= address(this).balance);\n', '        \n', '        require(now - lastPaydayTS > paydayFrequencyInDays * 1 days); // check if payday frequency days passed after last withdrawal\n', '        \n', '        lastPaydayTS = now;\n', '        uint amountToWithdraw = earnings;\n', '        earnings = 0;\n', '        \n', '        employeeAddress.transfer(amountToWithdraw);\n', '        \n', '        emit Withdrawal(amountToWithdraw, employeeAddress, now);\n', '    }\n', '    \n', '    function withdrawAfterEnd() external onlyEmployee {\n', '        require(owner == 0x0); // only if there&#39;s no owner\n', '        require(now > beginTimeTS + (contractDurationInDays * 1 days)); // only after contract end\n', '        require(address(this).balance > 0); // only if there&#39;s balance\n', '\n', '        employeeAddress.transfer(address(this).balance);\n', '        emit Withdrawal(address(this).balance, employeeAddress, now);\n', '    }\n', '    \n', '    function fire() external onlyOwner {\n', '        if (working) stopWorkInternal(); // cease all motor functions if working\n', '        \n', '        hired = false; // fire\n', '        \n', '        emit Fired(employeeAddress, now);\n', '    }\n', '\n', '    function refundAll() external onlyOwnerOrEmployee {    // terminates all unwithdrawn earnings.\n', '        require(working == false);\n', '        require(earnings > 0);\n', '        uint amount = earnings;\n', '        earnings = 0;\n', '\n', '        emit Refunded(amount, msg.sender, now);\n', '    }\n', '    \n', '    function refund(uint amount) external onlyOwnerOrEmployee {  // terminates the (amount) of unwithdrawn earnings.\n', '        require(working == false);\n', '        require(amount < earnings);\n', '        earnings -= amount;\n', '\n', '        emit Refunded(amount, msg.sender, now);\n', '    }\n', '\n', '    function clientWithdrawAll() external onlyOwner { // withdraws all funds minus locked in earnings.\n', '        require(hired == false);\n', '        require(address(this).balance > earnings);\n', '        uint amount = address(this).balance - earnings;\n', '        \n', '        owner.transfer(amount);\n', '        \n', '        emit ClientWithdrawal(amount, now);\n', '    }\n', '    \n', '    function clientWithdraw(uint amount) external onlyOwner { // withdraws (amount), if not locked in earnings.\n', '        require(hired == false);\n', '        require(address(this).balance > earnings);\n', '        require(amount < address(this).balance);\n', '        require(address(this).balance - amount > earnings);\n', '        \n', '        owner.transfer(amount);\n', '\n', '        emit ClientWithdrawal(amount, now);\n', '    }\n', '}']
['pragma experimental "v0.5.0";\n', '\n', '////////////////////\n', '//   HOURLY PAY   //\n', '//    CONTRACT    //\n', '//    v 0.2.1     //\n', '////////////////////\n', '\n', '// The Hourly Pay Contract allows you to track your time and get paid a hourly wage for tracked time.\n', '//\n', '// HOW IT WORKS:\n', '//\n', '//  1. Client creates the contract, making himself the owner of the contract.\n', '//\n', '//  2. Client can fund the contract with ETH by simply sending money to the contract (via payable fallback function).\n', '//\n', '//  3. Before hiring someone, client can change additional parameters, such as:\n', '//\n', '//      - setContractDurationInDays(days) - The duration of the contract (default is 365 days).\n', '//\n', '//      - setDailyHourLimit(hours) - How much hours the Employee can work per day (default is 8 hours).\n', '//\n', '//      - setPaydayFrequencyInDays(days) - How often the Employee can withdraw the earnings (default is every 3 days).\n', '//\n', '//      - setBeginTimeTS(utcTimestamp) - Work on contract can be started after this timestamp (default is contract creation time).\n', '//                                       Also defines the start of Day and Week for accounting and daily limits.\n', '//                                       Day transition time should be convenient for the employee (like 4am),\n', "//                                       so that work doesn't cross between days,\n", "//                                       The excess won't be transferred to the next day.\n", '//\n', '//  4. Client hires the Employee by invoking hire(addressOfEmployee, ratePerHourInWei)\n', '//     This starts the project and puts the contract in a workable state.\n', '//     Before hiring, contract should be loaded with enough ETH to provide at least one day of work at specified ratePerHourInWei\n', '// \n', '//  5. To start work and earn ETH the Employee should:\n', '//\n', '//      invoke startWork() when he starts working to run the timer.\n', '//\n', '//      invoke stopWork() when he finishes working to stop the timer.\n', '//\n', "//    After the timer is stopped - the ETH earnings are calculated and recorded on Employee's internal balance.\n", '//    If the stopWork() is invoked after more hours had passed than dailyLimit - the excess is ignored\n', '//    and only the dailyLimit is added to the internal balance.\n', '//\n', '//  6. Employee can withdraw earnings from internal balance after paydayFrequencyInDays days have passed after BeginTimeTS:\n', '//      by invoking withdraw()\n', '//\n', '//    After each withdrawal the paydayFrequencyInDays is reset and starts counting itself from the TS of the first startWork() after withdrawal.\n', '//\n', '//    This delay is implemented as a safety mechanism, so the Client can have time to check the work and\n', '//    cancel the earnings if something goes wrong.\n', '//    That way only money earned during the last paydayFrequencyInDays is at risk.\n', '//\n', '//  7. Client can fire() the Employee after his services are no longer needed.\n', "//    That would stop any ongoing work by terminating the timer and won't allow to start the work again.\n", '//\n', '//  8. If anything in the relationship or hour counting goes wrong, there are safety functions:\n', '//      - refundAll() - terminates all unwithdrawn earnings.\n', '//      - refund(amount) - terminates the (amount) of unwithdrawn earnings.\n', '//    Can be only called if not working.\n', '//    Both of these can be called by Client or Employee.\n', "//      * TODO: Still need to think if allowing Client to do that won't hurt the Employee.\n", "//      * TODO: SecondsWorkedToday don't reset after refund, so dailyLimit still affects\n", '//      * TODO: Think of a better name. ClearEarnings?\n', '//\n', '//  9. Client can withdraw any excess ETH from the contract via:\n', '//      - clientWithdrawAll() - withdraws all funds minus locked in earnings.\n', '//      - clientWithdraw(amount) - withdraws (amount), not locked in earnings.\n', "//     Can be invoked only if Employee isn't hired or has been fired.\n", '//\n', '// 10. Client and Contract Ownership can be made "Public"/"None" by calling:\n', '//      - releaseOwnership()\n', '//     It simply sets the Owner (Client) to 0x0, so no one is in control of the contract anymore.\n', '//     That way the contract can be used on projects as Hourly-Wage Donations.\n', '//\n', '///////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', 'contract HourlyPay { \n', '\n', '    ////////////////////////////////\n', '    // Addresses\n', '\n', '    address public owner;           // Client and owner address\n', '    address public employeeAddress = 0x0;  // Employee address\n', '\n', '\n', '    /////////////////////////////////\n', '    // Contract business properties\n', '    \n', '    uint public beginTimeTS;               // When the contract work can be started. Also TS of day transition.\n', '    uint public ratePerHourInWei;          // Employee rate in wei\n', '    uint public earnings = 0;              // Earnings of employee\n', '    bool public hired = false;             // If the employee is hired and approved to perform work\n', '    bool public working = false;           // Is employee currently working with timer on?\n', '    uint public startedWorkTS;             // Timestamp of when the timer started counting time\n', '    uint public workedTodayInSeconds = 0;  // How many seconds worked today\n', '    uint public currentDayTS;\n', '    uint public lastPaydayTS;\n', '    string public contractName = "Hourly Pay Contract";\n', '\n', '    ////////////////////////////////\n', '    // Contract Limits and maximums\n', '    \n', "    uint16 public contractDurationInDays = 365;  // Overall contract duration in days, default is 365 and it's also maximum for safety reasons\n", '    uint8 public dailyHourLimit = 8;               // Limits the hours per day, max 24 hours\n', '    uint8 public paydayFrequencyInDays = 3;       // How often can Withdraw be called, default is every 3 days\n', '\n', '    uint8 constant hoursInWeek = 168;\n', '    uint8 constant maxDaysInFrequency = 30; // every 30 days is a wise maximum\n', '\n', '\n', '    ////////////////\n', '    // Constructor\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        beginTimeTS = now;\n', '        currentDayTS = beginTimeTS;\n', '        lastPaydayTS = beginTimeTS;\n', '    }\n', '\n', '\n', '    //////////////\n', '    // Modifiers\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEmployee {\n', '        require(msg.sender == employeeAddress);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwnerOrEmployee {\n', '        require((msg.sender == employeeAddress) || (msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    modifier beforeHire {\n', '        require(employeeAddress == 0x0);                        // Contract can hire someone only once\n', "        require(hired == false);                                // Shouldn't be already hired\n", '        _;\n', '    }\n', '\n', '\n', '    ///////////\n', '    // Events\n', '    \n', '    event GotFunds(address sender, uint amount);\n', '    event ContractDurationInDaysChanged(uint16 contractDurationInDays);\n', '    event DailyHourLimitChanged(uint8 dailyHourLimit);\n', '    event PaydayFrequencyInDaysChanged(uint32 paydayFrequencyInDays);\n', '    event BeginTimeTSChanged(uint beginTimeTS);\n', '    event Hired(address employeeAddress, uint ratePerHourInWei, uint hiredTS);\n', '    event NewDay(uint currentDayTS, uint16 contractDaysLeft);\n', '    event StartedWork(uint startedWorkTS, uint workedTodayInSeconds, string comment);\n', '    event StoppedWork(uint stoppedWorkTS, uint workedInSeconds, uint earned);\n', '    event Withdrawal(uint amount, address employeeAddress, uint withdrawalTS);\n', '    event Fired(address employeeAddress, uint firedTS);\n', '    event Refunded(uint amount, address whoInitiatedRefund, uint refundTS);\n', '    event ClientWithdrawal(uint amount, uint clientWithdrawalTS);\n', '    event ContractNameChanged(string contractName);\n', '    \n', '    ////////////////////////////////////////////////\n', '    // Fallback function to fund contract with ETH\n', '    \n', '    function () external payable {\n', '        emit GotFunds(msg.sender, msg.value);\n', '    }\n', '    \n', '    \n', '    ///////////////////////////\n', '    // Main Setters\n', '\n', '    function setContractName(string newContractName) external onlyOwner beforeHire {\n', '        contractName = newContractName;\n', '        emit ContractNameChanged(contractName);\n', '    }\n', '\n', '    function setContractDurationInDays(uint16 newContractDurationInDays) external onlyOwner beforeHire {\n', '        require(newContractDurationInDays <= 365);\n', '        contractDurationInDays = newContractDurationInDays;\n', '        emit ContractDurationInDaysChanged(contractDurationInDays);\n', '    }\n', '    \n', '    function setDailyHourLimit(uint8 newDailyHourLimit) external onlyOwner beforeHire {\n', '        require(newDailyHourLimit <= 24);\n', '        dailyHourLimit = newDailyHourLimit;\n', '        emit DailyHourLimitChanged(dailyHourLimit);\n', '    }\n', '\n', '    function setPaydayFrequencyInDays(uint8 newPaydayFrequencyInDays) external onlyOwner beforeHire {\n', '        require(newPaydayFrequencyInDays < maxDaysInFrequency);\n', '        paydayFrequencyInDays = newPaydayFrequencyInDays;\n', '        emit PaydayFrequencyInDaysChanged(paydayFrequencyInDays);\n', '    }\n', '    \n', '    function setBeginTimeTS(uint newBeginTimeTS) external onlyOwner beforeHire {\n', '        beginTimeTS = newBeginTimeTS;\n', '        currentDayTS = beginTimeTS;\n', '        lastPaydayTS = beginTimeTS;\n', '        emit BeginTimeTSChanged(beginTimeTS);\n', '    }\n', '    \n', '    ///////////////////\n', '    // Helper getters\n', '    \n', '    function getWorkSecondsInProgress() public view returns(uint) {\n', '        if (!working) return 0;\n', '        return now - startedWorkTS;\n', '    }\n', '    \n', '    function isOvertime() external view returns(bool) {\n', '        if (workedTodayInSeconds + getWorkSecondsInProgress() > dailyHourLimit * 1 hours) return true;\n', '        return false;\n', '    }\n', '    \n', '    function hasEnoughFundsToStart() public view returns(bool) {\n', '        return ((address(this).balance > earnings) &&\n', '                (address(this).balance - earnings >= ratePerHourInWei * (dailyHourLimit * 1 hours - (isNewDay() ? 0 : workedTodayInSeconds)) / 1 hours));\n', '    }\n', '    \n', '    function isNewDay() public view returns(bool) {\n', '        return (now - currentDayTS > 1 days);\n', '    }\n', '    \n', '    function canStartWork() public view returns(bool) {\n', '        return (hired\n', '            && !working\n', '            && (now > beginTimeTS)\n', '            && (now < beginTimeTS + (contractDurationInDays * 1 days))\n', '            && hasEnoughFundsToStart()\n', '            && ((workedTodayInSeconds < dailyHourLimit * 1 hours) || isNewDay()));\n', '    }\n', '\n', '    function canStopWork() external view returns(bool) {\n', '        return (working\n', '            && hired\n', '            && (now > startedWorkTS));\n', '    }\n', '\n', '    function currentTime() external view returns(uint) {\n', '        return now;\n', '    }\n', '\n', '    function getBalance() external view returns(uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    ////////////////////////////\n', '    // Main workflow functions\n', '\n', '    function releaseOwnership() external onlyOwner {\n', '        owner = 0x0;\n', '    }\n', '\n', '    function hire(address newEmployeeAddress, uint newRatePerHourInWei) external onlyOwner beforeHire {\n', '        require(newEmployeeAddress != 0x0);                     // Protection from burning the ETH\n', '\n', '        // Contract should be loaded with ETH for a minimum one day balance to perform Hire:\n', '        require(address(this).balance >= newRatePerHourInWei * dailyHourLimit);\n', '        employeeAddress = newEmployeeAddress;\n', '        ratePerHourInWei = newRatePerHourInWei;\n', '        \n', '        hired = true;\n', '        emit Hired(employeeAddress, ratePerHourInWei, now);\n', '    }\n', '\n', '    function startWork(string comment) external onlyEmployee {\n', '        require(hired == true);\n', '        require(working == false);\n', '        \n', '        require(now > beginTimeTS); // can start working only after contract beginTimeTS\n', "        require(now < beginTimeTS + (contractDurationInDays * 1 days)); // can't start after contractDurationInDays has passed since beginTimeTS\n", '        \n', '        checkForNewDay();\n', '        \n', "        require(workedTodayInSeconds < dailyHourLimit * 1 hours); // can't start if already approached dailyHourLimit\n", '\n', '        require(address(this).balance > earnings); // balance must be greater than earnings        \n', '\n', '        // balance minus earnings must be sufficient for at least 1 day of work minus workedTodayInSeconds:\n', '        require(address(this).balance - earnings >= ratePerHourInWei * (dailyHourLimit * 1 hours - workedTodayInSeconds) / 1 hours);\n', '        \n', '        if (earnings == 0) lastPaydayTS = now; // reset the payday timer TS if this is the first time work starts after last payday\n', '\n', '        startedWorkTS = now;\n', '        working = true;\n', '        \n', '        emit StartedWork(startedWorkTS, workedTodayInSeconds, comment);\n', '    }\n', '    \n', '    function checkForNewDay() internal {\n', '        if (now - currentDayTS > 1 days) { // new day\n', '            while (currentDayTS < now) {\n', '                currentDayTS += 1 days;\n', '            }\n', '            currentDayTS -= 1 days;\n', '            workedTodayInSeconds = 0;\n', '            emit NewDay(currentDayTS, uint16 ((beginTimeTS + (contractDurationInDays * 1 days) - currentDayTS) / 1 days));\n', '        }\n', '    }\n', '    \n', '    function stopWork() external onlyEmployee {\n', '        stopWorkInternal();\n', '    }\n', '    \n', '    function stopWorkInternal() internal {\n', '        require(hired == true);\n', '        require(working == true);\n', '    \n', '        require(now > startedWorkTS); // just a temporary overflow check, in case of miners manipulate time\n', '        \n', '        \n', '        uint newWorkedTodayInSeconds = workedTodayInSeconds + (now - startedWorkTS);\n', '        if (newWorkedTodayInSeconds > dailyHourLimit * 1 hours) { // check for overflow\n', '            newWorkedTodayInSeconds = dailyHourLimit * 1 hours;   // and assign max dailyHourLimit if there is an overflow\n', '        }\n', '        \n', '        uint earned = (newWorkedTodayInSeconds - workedTodayInSeconds) * ratePerHourInWei / 1 hours;\n', '        earnings += earned; // add new earned ETH to earnings\n', '        \n', '        emit StoppedWork(now, newWorkedTodayInSeconds - workedTodayInSeconds, earned);\n', '\n', '        workedTodayInSeconds = newWorkedTodayInSeconds; // updated todays works in seconds\n', '        working = false;\n', '\n', '        checkForNewDay();\n', '    }\n', '\n', '    function withdraw() external onlyEmployee {\n', '        require(working == false);\n', '        require(earnings > 0);\n', '        require(earnings <= address(this).balance);\n', '        \n', '        require(now - lastPaydayTS > paydayFrequencyInDays * 1 days); // check if payday frequency days passed after last withdrawal\n', '        \n', '        lastPaydayTS = now;\n', '        uint amountToWithdraw = earnings;\n', '        earnings = 0;\n', '        \n', '        employeeAddress.transfer(amountToWithdraw);\n', '        \n', '        emit Withdrawal(amountToWithdraw, employeeAddress, now);\n', '    }\n', '    \n', '    function withdrawAfterEnd() external onlyEmployee {\n', "        require(owner == 0x0); // only if there's no owner\n", '        require(now > beginTimeTS + (contractDurationInDays * 1 days)); // only after contract end\n', "        require(address(this).balance > 0); // only if there's balance\n", '\n', '        employeeAddress.transfer(address(this).balance);\n', '        emit Withdrawal(address(this).balance, employeeAddress, now);\n', '    }\n', '    \n', '    function fire() external onlyOwner {\n', '        if (working) stopWorkInternal(); // cease all motor functions if working\n', '        \n', '        hired = false; // fire\n', '        \n', '        emit Fired(employeeAddress, now);\n', '    }\n', '\n', '    function refundAll() external onlyOwnerOrEmployee {    // terminates all unwithdrawn earnings.\n', '        require(working == false);\n', '        require(earnings > 0);\n', '        uint amount = earnings;\n', '        earnings = 0;\n', '\n', '        emit Refunded(amount, msg.sender, now);\n', '    }\n', '    \n', '    function refund(uint amount) external onlyOwnerOrEmployee {  // terminates the (amount) of unwithdrawn earnings.\n', '        require(working == false);\n', '        require(amount < earnings);\n', '        earnings -= amount;\n', '\n', '        emit Refunded(amount, msg.sender, now);\n', '    }\n', '\n', '    function clientWithdrawAll() external onlyOwner { // withdraws all funds minus locked in earnings.\n', '        require(hired == false);\n', '        require(address(this).balance > earnings);\n', '        uint amount = address(this).balance - earnings;\n', '        \n', '        owner.transfer(amount);\n', '        \n', '        emit ClientWithdrawal(amount, now);\n', '    }\n', '    \n', '    function clientWithdraw(uint amount) external onlyOwner { // withdraws (amount), if not locked in earnings.\n', '        require(hired == false);\n', '        require(address(this).balance > earnings);\n', '        require(amount < address(this).balance);\n', '        require(address(this).balance - amount > earnings);\n', '        \n', '        owner.transfer(amount);\n', '\n', '        emit ClientWithdrawal(amount, now);\n', '    }\n', '}']
