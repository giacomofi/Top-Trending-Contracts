['pragma solidity ^0.4.18;\n', '\n', ' /// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure  returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', ' /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);  \n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  function decimals() public constant returns (uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract SilentNotaryTokenStorage is SafeMath, Ownable {\n', '\n', '  /// Information about frozen portion of tokens\n', '  struct FrozenPortion {\n', '    /// Earliest time when this portion will become available\n', '    uint unfreezeTime;\n', '\n', '    /// Frozen balance portion, in percents\n', '    uint portionPercent;\n', '\n', '    /// Frozen token amount\n', '    uint portionAmount;\n', '\n', '    /// Is this portion unfrozen (withdrawn) after freeze period has finished\n', '    bool isUnfrozen;\n', '  }\n', '\n', '  /// Specified amount of tokens was unfrozen\n', '  event Unfrozen(uint tokenAmount);\n', '\n', '  /// SilentNotary token contract\n', '  ERC20 public token;\n', '\n', '  /// All frozen portions of the contract token balance\n', '  FrozenPortion[] public frozenPortions;\n', '\n', '  /// Team wallet to withdraw unfrozen tokens\n', '  address public teamWallet;\n', '\n', '  /// Deployment time of this contract, which is also the start point to count freeze periods\n', '  uint public deployedTime;\n', '\n', '  /// Is current token amount fixed (must be to unfreeze)\n', '  bool public amountFixed;\n', '\n', '  /// @dev Constructor\n', '  /// @param _token SilentNotary token contract address\n', '  /// @param _teamWallet Wallet address to withdraw unfrozen tokens\n', '  /// @param _freezePeriods Ordered array of freeze periods\n', '  /// @param _freezePortions Ordered array of balance portions to freeze, in percents\n', '  function SilentNotaryTokenStorage (address _token, address _teamWallet, uint[] _freezePeriods, uint[] _freezePortions) public {\n', '    require(_token > 0);\n', '    require(_teamWallet > 0);\n', '    require(_freezePeriods.length > 0);\n', '    require(_freezePeriods.length == _freezePortions.length);\n', '\n', '    token = ERC20(_token);\n', '    teamWallet = _teamWallet;\n', '    deployedTime = now;\n', '\n', '    var cumulativeTime = deployedTime;\n', '    uint cumulativePercent = 0;\n', '    for (uint i = 0; i < _freezePeriods.length; i++) {\n', '      require(_freezePortions[i] > 0 && _freezePortions[i] <= 100);\n', '      cumulativePercent = safeAdd(cumulativePercent, _freezePortions[i]);\n', '      cumulativeTime = safeAdd(cumulativeTime, _freezePeriods[i]);\n', '      frozenPortions.push(FrozenPortion({\n', '        portionPercent: _freezePortions[i],\n', '        unfreezeTime: cumulativeTime,\n', '        portionAmount: 0,\n', '        isUnfrozen: false}));\n', '    }\n', '    assert(cumulativePercent == 100);\n', '  }\n', '\n', '  /// @dev Unfreeze currently available amount of tokens\n', '  function unfreeze() public onlyOwner {\n', '    require(amountFixed);\n', '\n', '    uint unfrozenTokens = 0;\n', '    for (uint i = 0; i < frozenPortions.length; i++) {\n', '      var portion = frozenPortions[i];\n', '      if (portion.isUnfrozen)\n', '        continue;\n', '      if (portion.unfreezeTime < now) {\n', '        unfrozenTokens = safeAdd(unfrozenTokens, portion.portionAmount);\n', '        portion.isUnfrozen = true;\n', '      }\n', '      else\n', '        break;\n', '    }\n', '    transferTokens(unfrozenTokens);\n', '  }\n', '\n', '  /// @dev Fix current token amount (calculate absolute values of every portion)\n', '  function fixAmount() public onlyOwner {\n', '    require(!amountFixed);\n', '    amountFixed = true;\n', '\n', '    uint currentBalance = token.balanceOf(this);\n', '    for (uint i = 0; i < frozenPortions.length; i++) {\n', '      var portion = frozenPortions[i];\n', '      portion.portionAmount = safeDiv(safeMul(currentBalance, portion.portionPercent), 100);\n', '    }\n', '  }\n', '\n', '  /// @dev Withdraw remaining tokens after all freeze periods are over (in case there were additional token transfers)\n', '  function withdrawRemainder() public onlyOwner {\n', '    for (uint i = 0; i < frozenPortions.length; i++) {\n', '      if (!frozenPortions[i].isUnfrozen)\n', '        revert();\n', '    }\n', '    transferTokens(token.balanceOf(this));\n', '  }\n', '\n', '  function transferTokens(uint tokenAmount) private {\n', '    require(tokenAmount > 0);\n', '    var transferSuccess = token.transfer(teamWallet, tokenAmount);\n', '    assert(transferSuccess);\n', '    Unfrozen(tokenAmount);\n', '  }\n', '}']