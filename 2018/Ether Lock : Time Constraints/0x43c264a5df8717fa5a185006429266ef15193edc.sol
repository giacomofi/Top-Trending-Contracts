['pragma solidity ^0.4.19;\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant public returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', ' \n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '  using SafeMath for uint256;\n', ' \n', '  mapping(address => uint256) balances;\n', ' \n', '  \n', ' \n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', ' \n', '  mapping (address => mapping (address => uint256)) allowed;\n', ' \n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '\n', ' \n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', ' \n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', ' \n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', ' \n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', ' \n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', ' \n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  \n', '\n', ' \n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function  transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '  \n', '\n', ' \n', '}\n', ' \n', ' \n', ' \n', ' \n', '\n', ' \n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  \n', '   function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    if(b==0) return 1;\n', '    assert(b>=0);\n', '    uint256 c = a ** b;\n', '    assert(c>=a );\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', 'function compoundInterest(uint256 depo, uint256 stage2, uint256 start, uint256 current)  internal pure returns (uint256)  {\n', '            if(current<start || start<stage2 || current<stage2) return depo;\n', '\n', '            uint256 ret=depo; uint256 g; uint256 d;\n', '            stage2=stage2/1 days;\n', '            start=start/1 days;\n', '            current=current/1 days;\n', '    \n', '\t\t\tuint256 dpercent=100;\n', '\t\t\tuint256 i=start;\n', '\t\t\t\n', '\t\t\tif(i-stage2>365) dpercent=200;\n', '\t\t\tif(i-stage2>730) dpercent=1000;\t\t\t\n', '\t\t\t\n', '\t\t\twhile(i<current)\n', '\t\t\t{\n', '\n', '\t\t\t\tg=i-stage2;\t\t\t\n', '\t\t\t\tif(g>265 && g<=365) \n', '\t\t\t\t{\t\t\n', '\t\t\t\t    d=365-g;\n', '\t\t\t\t\tif(d>=(current-start))  d=(current-start);\n', '\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\n', '\t\t\t\t    i+=d;\n', '\t\t\t\t\tdpercent=200;\n', '\t\t\t\t}\n', '\t\t\t\tif(g>630 && g<=730) \n', '\t\t\t\t{\t\t\t\t\n', '\t\t\t\t\td=730-g;\t\n', '\t\t\t\t\tif(d>=(current-start))  d=(current-start);\t\t\t\t\t\n', '\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\n', '\t\t\t\t\ti+=d;\n', '\t\t\t\t\tdpercent=1000;\t\t\t\t\t\n', '\t\t\t\t}\n', '\t\t\t\telse if(g>730) dpercent=1000;\t\t\t\t\n', '\t\t\t\telse if(g>365) dpercent=200;\n', '\t\t\t\t\n', '\t\t\t\tif(i+100<current) ret=fracExp(ret, dpercent, 100, 8);\n', '\t\t\t\telse return fracExp(ret, dpercent, current-i, 8);\n', '\t\t\t\ti+=100;\n', '\t\t\t\t\n', '\t\t\t}\n', '\n', '\t\t\treturn ret;\n', '\t\t\t\n', '\t\t\t\n', '    \n', '    \n', '\t}\n', '\n', '\n', 'function fracExp(uint256 depo, uint256 percent, uint256 period, uint256 p)  internal pure returns (uint256) {\n', '  uint256 s = 0;\n', '  uint256 N = 1;\n', '  uint256 B = 1;\n', '  \n', '\n', '  \n', '  for (uint256 i = 0; i < p; ++i){\n', '    s += depo * N / B / (percent**i);\n', '    N  = N * (period-i);\n', '    B  = B * (i+1);\n', '  }\n', '  return s;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract MMMTokenCoin is StandardToken, Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    string public constant name = "Make More Money";\n', '    string public constant symbol = "MMM";\n', '    uint32 public constant decimals = 2;\n', '    \n', '\t\n', '\t// Dates\n', '\tuint256 public stage2StartTime;\t\t\t\t\t// timestamp when compound interest will begin\n', '    uint256 globalInterestDate;             // last date when amount of tokens with interest was changed\n', '    uint256 globalInterestAmount;           // amount of tokens with interest\n', '\tmapping(address => uint256) dateOfStart;     // timestamp of last operation, from which interest calc will be started\n', '\tuint256 public currentDate;\t\t\t\t\t\t// current date timestamp\n', '\tuint256 public debugNow=0;\n', '\n', '\n', '\n', '    // Crowdsale \n', '    uint256 public totalSupply=99900000000;\t\t\t\n', ' uint256 public  softcap;\n', '    uint256 public  step0Rate=100000;       // rate of our tokens. 1 eth = 1000 MMM coins = 100000 tokens (seen as 1000,00 because of decimals)\n', '    uint256 public  currentRate=100000;   \n', '    uint256 public constant tokensForOwner=2000000000;   // tokens for owner won&#39;t dealt with compound interest\n', '    uint256 public tokensFromEther=0;\n', '    uint public saleStatus=0;      // 0 - sale is running, 1 - sale failed, 2 - sale successful\n', '    address multisig=0x8216A5958f05ad61898e3A6F97ae5118C0e4b1A6;\n', '    // counters of tokens for futher refund\n', '    mapping(address => uint256) boughtWithEther;                // tokens, bought with ether. can be refunded to ether\n', '    mapping(address => uint256) boughtWithOther;    \t\t\t// tokens, bought with other payment systems. can be refunded to other payment systems, using site\n', '    mapping(address => uint256) bountyAndRefsWithEther;  \t\t// bounty tokens, given to some people. can be converted to ether, if ico is succeed\n', '  \n', '    \n', '\n', '\t\t\n', '\t\t\n', '    // events\n', '    event RefundEther(address indexed to, uint256 tokens, uint256 eth); \n', '    event DateUpdated(uint256 cdate);    \n', '    event DebugLog(string what, uint256 param);\n', '    event Sale(address indexed to, uint256 amount);\n', '    event Step0Finished();\n', '    event RateSet(uint256 newRate);\t\n', '    event Burn(address indexed who, uint256 amount);\n', '   // DEBUG\n', '\n', '    bool bDbgEnabled=false;\n', '\t\n', '\t\n', '\t\n', '    function MMMTokenCoin() public   {  \n', '        // Crowdsale     \n', '        currentDate=(getNow()/1 days)*1 days;\n', '        stage2StartTime=getNow()+61 days;\n', '        \n', '        balances[owner]=tokensForOwner;\n', '        globalInterestAmount=0;\n', '        \n', '        if(bDbgEnabled) softcap=20000;\n', '        else  softcap=50000000;\n', '    }\n', '\t\n', '\t\n', '\tfunction debugSetNow(uint256 n) public\n', '\t{\n', '\t    require(bDbgEnabled);\n', '\t\tdebugNow=n;\n', '\t}\n', '\t\n', '\t\n', '\t /**\n', '     * @dev Returns current timestamp. In case of debugging, this function can return timestamp representing any other time\n', '     */\n', '     \n', '     \n', '\tfunction getNow() public view returns (uint256)\n', '\t{\n', '\t    \n', '\t    if(!bDbgEnabled) return now;\n', '\t    \n', '\t    if(debugNow==0) return now;\n', '\t\telse return debugNow;\n', '//\t\treturn now;\n', '\t}\n', '   \n', '    /**\n', '     * @dev Sets date from which interest will be calculated for specified address\n', '     * @param _owner - address of balance owner\n', '     */\n', '   \n', '    \n', '    function updateDate(address _owner) private {\n', '        if(currentDate<stage2StartTime) dateOfStart[_owner]=stage2StartTime;\n', '        else dateOfStart[_owner]=currentDate;\n', '    }\n', '    \n', '\n', '\t\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of. \n', '    * @return An uint25664 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) \n', '    { \n', '        \n', '         return balanceWithInterest(_owner);\n', '    }   \n', '   \n', '\t\n', '    /**\n', '     * @dev Gets balance including interest for specified address\n', '   \t * @param _owner The address to query the the balance of. \n', '     */\n', '\t\t\n', '\t\t\n', '    function balanceWithInterest(address _owner)  private constant returns (uint256 ret)\n', '    {\n', '        if( _owner==owner || saleStatus!=2) return balances[_owner]; \n', '        return balances[_owner].compoundInterest(stage2StartTime, dateOfStart[_owner], currentDate);\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '\t\t \n', '  function transfer(address _to, uint256 _value)  public returns (bool) {\n', '    if(msg.sender==owner) {\n', '    \t// if owner sends tokens before sale finish, consider then as ether-refundable bonus\n', '    \t// else as simple transfer\n', '        if(saleStatus==0) {\n', '            \ttransferFromOwner(_to, _value,1);\n', '            \ttokensFromEther=tokensFromEther.add(_value);\n', '\t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\n', '        \t}\n', '        \telse transferFromOwner(_to, _value,0);\n', '        \t\n', '        \tincreaseGlobalInterestAmount(_value);\n', '        \treturn true;   \n', '    }\n', '    \n', '    balances[msg.sender] = balanceWithInterest(msg.sender).sub(_value);\n', '\n', '    emit Transfer(msg.sender, _to, _value);\n', '    if(_to==address(this)) {\n', '\t\t// make refund if tokens sent to contract\n', '        uint256 left; left=processRefundEther(msg.sender, _value);\n', '        balances[msg.sender]=balances[msg.sender].add(left);\n', '    }\n', '    else {\n', '        balances[_to] = balanceWithInterest(_to).add(_value);\n', '        updateDate(_to);\n', '    }\n', '    \n', '    if(_to==owner) \n', '    {\n', '    \t// before sale finish, tokens can&#39;t be sent to owner\n', '        require(saleStatus!=0);\n', '        decreaseGlobalInterestAmount(_value);\n', '    }\n', '    \n', '    updateDate(msg.sender);\n', '    return true;\n', '  }\n', '  \n', '  \n', '  /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transfered\n', '    */\n', '\t  \n', '  \n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '           require(_to!=owner);\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '     allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '    if(_from==owner) {\n', '        if(saleStatus==0) {\n', '            transferFromOwner(_to, _value,1);\n', '            tokensFromEther=tokensFromEther.add(_value);\n', '\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\t\t\t\n', '        }\n', '        else transferFromOwner(_to, _value,0);\n', '      \n', '        increaseGlobalInterestAmount(_value);\n', '        return true;\n', '    }\n', '     \n', '     \n', '    balances[_from] = balanceWithInterest(_from).sub(_value);\n', '\n', '     emit Transfer(_from, _to, _value);\n', '\n', '    if(_to==address(this)) {\n', '\t\t// make refund if tokens sent to contract\t\t   \n', '        uint256 left; left=processRefundEther(_from, _value);\n', '        balances[_from]=balances[_from].add(left);\n', '    }\n', '    else {\n', '        balances[_to] = balanceWithInterest(_to).add(_value);\n', '        updateDate(_to);\n', '    }\n', '    \n', '    if(_to==owner) \n', '    {\n', '        require(saleStatus!=0);\n', '        decreaseGlobalInterestAmount(_value);\n', '    }\n', '\n', '    updateDate(_from);\n', '\n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '    /**\n', '    * @dev Burns tokens\n', '    * @param _amount amount of tokens to burn\n', '    */\n', '\t  \n', '\t  \n', '\t  \n', '  function burn(uint256 _amount) public \n', '  {\n', '\t  \trequire(_amount>0);\n', '        balances[msg.sender]=balanceOf(msg.sender).sub(_amount);\n', '\t\tdecreaseGlobalInterestAmount(_amount);\n', '        emit Burn(msg.sender, _amount);\n', '  }\n', '   \n', '   //// SALE ////\n', '   \n', '    /**\n', '     * @dev updates rate with whic tokens are being sold\n', '     */\n', '\n', ' \tfunction setRate(uint256 r) public {\n', '\t\trequire(saleStatus!=0);\n', '\t\tcurrentRate=r;\n', '\t\temit RateSet(currentRate);\n', '\t}\n', '\n', '    /**\n', '     * @dev updates current date value. For compound interest calculation\n', '     */\n', '    \n', '    function newDay() public   returns (bool b)\n', '    {\n', '        \n', '       uint256 g; uint256 newDate;\n', '       require(getNow()>=stage2StartTime);\n', '       require(getNow()>=currentDate);\n', '       newDate=(getNow()/1 days)*1 days;\n', '        if(getNow()>=stage2StartTime && saleStatus==0)\n', '        {\n', '            if(tokensForOwner.sub(balances[owner])>=softcap) saleStatus=2;\n', '            else saleStatus=1;\n', '         \n', '            emit Step0Finished();\n', '        }\n', '      \n', '\t   // check if overall compound interest of tokens will be less than total supply\n', '\t  \n', '       g=globalInterestAmount.compoundInterest(stage2StartTime, globalInterestDate, newDate);\n', '       if(g<=totalSupply && saleStatus==2) {\n', '             currentDate=(getNow()/1 days)*1 days; \n', '             globalInterestAmount=g;\n', '             globalInterestDate=currentDate;\n', '             emit DateUpdated(currentDate);\n', '             return true;\n', '       }\n', '       else if(saleStatus==1) currentDate=(getNow()/1 days)*1 days; \n', '       \n', '       return false;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev Sends collected ether to owner. If sale is not success, contract will hold ether for half year, and after, ether can be sent to owner\n', '     * @return amount of owner&#39;s ether\n', '     */\n', '     \n', '    function sendEtherToMultisig() public  returns(uint256 e) {\n', '        uint256 req;\n', '        require(msg.sender==owner || msg.sender==multisig);\n', '        require(saleStatus!=0);\n', '\n', '        if(saleStatus==2) {\n', '        \t// calculate ether for refunds\n', '        \treq=tokensFromEther.mul(1 ether).div(step0Rate).div(2);\n', '\n', '        \tif(bDbgEnabled) emit DebugLog("This balance is", this.balance);\n', '        \tif(req>=this.balance) return 0;\n', '    \t}\n', '    \telse if(saleStatus==1) {\n', '    \t\trequire(getNow()-stage2StartTime>15768000);\n', '    \t\treq=0; \n', '    \t}\n', '        uint256 amount;\n', '        amount=this.balance.sub(req);\n', '        multisig.transfer(amount);\n', '        return amount;\n', '        \n', '    }\n', '    \n', '\t\n', '\n', '\n', '\t\n', '\t\n', '\t/**\n', '\t\tRefund functions. \n', '\t\tIf ico is success, anyone can get 0.000005 eth for 1 token,  else 00001 eth\n', '\t\t\n', '\t*/\n', '\t\n', '    /**\n', '     * @dev Refunds ether to sender if he trasnfered tokens to contract address. Calculates max possible amount of refund. If sent tokens>refund amound, tokens will be returned to sender.\n', '     * @param _to Address of refund receiver\n', '     * @param _value Tokens requested for refund\n', '     */\n', '\t\n', '    function processRefundEther(address _to, uint256 _value) private returns (uint256 left)\n', '    {\n', '        require(saleStatus!=0);\n', '        require(_value>0);\n', '        uint256 Ether=0; uint256 bounty=0;  uint256 total=0;\n', '\n', '        uint256 rate2=saleStatus;\n', '\n', '        \n', '        if(_value>=boughtWithEther[_to]) {Ether=Ether.add(boughtWithEther[_to]); _value=_value.sub(boughtWithEther[_to]); }\n', '        else {Ether=Ether.add(_value); _value=_value.sub(Ether);}\n', '        boughtWithEther[_to]=boughtWithEther[_to].sub(Ether);\n', '        \n', '        if(rate2==2) {        \n', '            if(_value>=bountyAndRefsWithEther[_to]) {bounty=bounty.add(bountyAndRefsWithEther[_to]); _value=_value.sub(bountyAndRefsWithEther[_to]); }\n', '            else { bounty=bounty.add(_value); _value=_value.sub(bounty); }\n', '            bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].sub(bounty);\n', '        }\n', '        total=Ether.add(bounty);\n', '     //   if(_value>total) _value=_value.sub(total);\n', '        tokensFromEther=tokensFromEther.sub(total);\n', '       uint256 eth=total.mul(1 ether).div(step0Rate).div(rate2);\n', '         _to.transfer(eth);\n', '        if(bDbgEnabled) emit DebugLog("Will refund ", eth);\n', '\n', '        emit RefundEther(_to, total, eth);\n', '        decreaseGlobalInterestAmount(total);\n', '        return _value;\n', '    }\n', '    \n', '    \n', '\t\n', '\n', '\t     /**\n', '     * @dev Returns info about refundable tokens- bought with ether, payment systems, and bonus tokens convertable to ether\n', '     */\n', '\t\n', '\tfunction getRefundInfo(address _to) public returns (uint256, uint256, uint256)\n', '\t{\n', '\t    return  ( boughtWithEther[_to],  boughtWithOther[_to],  bountyAndRefsWithEther[_to]);\n', '\t    \n', '\t}\n', '\t\n', '    \n', '    /**\n', '     * @dev Withdraw tokens  refunded to other payment systems.\n', '     * @param _to Address of refund receiver\n', '     */\n', '    \n', '    function refundToOtherProcess(address _to, uint256 _value) public onlyOwner returns (uint256 o) {\n', '        require(saleStatus!=0);\n', '        //uint256 maxValue=refundToOtherGet(_to);\n', '        uint256 maxValue=0;\n', '        require(_value<=maxValue);\n', '        \n', '        uint256 Other=0; uint256 bounty=0; \n', '\n', '\n', '\n', '        \n', '        if(_value>=boughtWithOther[_to]) {Other=Other.add(boughtWithOther[_to]); _value=_value.sub(boughtWithOther[_to]); }\n', '        else {Other=Other.add(_value); _value=_value.sub(Other);}\n', '        boughtWithOther[_to]=boughtWithOther[_to].sub(Other);\n', '\n', '       \n', '        balances[_to]=balanceOf(_to).sub(Other).sub(bounty);\n', '        updateDate(_to);\n', '        decreaseGlobalInterestAmount(Other.add(bounty));\n', '        return _value;\n', '        \n', '        \n', '    }\n', '    \n', ' \n', '    /**\n', '     * @dev Converts ether to our tokens \n', '     */\n', '\t\t  \n', '    \n', '    function createTokensFromEther()  private   {\n', '               \n', '        assert(msg.value >= 1 ether / 1000);\n', '       \n', '         uint256 tokens = currentRate.mul(msg.value).div(1 ether);\n', '\n', '\n', '        transferFromOwner(msg.sender, tokens,2);\n', '      \n', '       if(saleStatus==0) {\n', '           boughtWithEther[msg.sender]=boughtWithEther[msg.sender].add(tokens);\n', '            tokensFromEther=tokensFromEther.add(tokens);\n', '       }\n', '      \n', '    }\n', '\t\n', '\t\n', '    /**\n', '     * @dev Converts other payments system payment to  tokens. Main logic is on site\n', '     */\n', '    \n', '    function createTokensFromOther(address _to, uint256 howMuch, address referer) public  onlyOwner   { \n', '      \n', '        require(_to!=address(this));\n', '         transferFromOwner(_to, howMuch,2);\n', '         if(referer!=0 && referer!=address(this) && referer!=0x0000000000000000000000000000000000000000 && howMuch.div(10)>0) {\n', '             transferFromOwner(referer, howMuch.div(10),1);\n', '\t         if(saleStatus==0) {\n', '\t             \ttokensFromEther=tokensFromEther.add( howMuch.div(10));\n', '\t \t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add( howMuch.div(10));\n', '\t         \t}\n', '         }\n', '         if(saleStatus==0) boughtWithOther[_to]= boughtWithOther[_to].add(howMuch);\n', '    }\n', '\n', '\t   /**\n', '     * @dev Gives refs tokens through payment on site. Main logic is on site\n', '     * @param _to Address of  receiver\n', '     * @param _amount Amount of tokens\t\t\n', '\t * @param t type of transfer. 0 is transfer, 1 bonus tokens, 2 - sale\n', '     */\n', '\t\n', '\tfunction transferFromOwner(address _to, uint256 _amount, uint t) private {\n', '\t   require(_to!=address(this) && _to!=address(owner) );\n', '        balances[owner]=balances[owner].sub(_amount); \n', '        balances[_to]=balanceOf(_to).add(_amount);\n', '        updateDate(_to);\n', '\n', '        increaseGlobalInterestAmount(_amount);\n', '\t    \n', '\t   \n', '\t     if(t==2) emit Sale(_to, _amount);\n', '        emit Transfer(owner, _to, _amount);\t     \n', '\t}\n', '\t\n', '\n', '    function increaseGlobalInterestAmount(uint256 c) private \n', '    {\n', '        globalInterestAmount=globalInterestAmount.add(c);\n', '\t\t\n', '    }\n', '    \n', '    function decreaseGlobalInterestAmount(uint256 c) private\n', '    {\n', '        if(c<globalInterestAmount) {\n', '            globalInterestAmount=globalInterestAmount.sub(c);\n', '        }\n', '            \n', '        \n', '    }\n', '    \n', '    function() external payable {\n', '        createTokensFromEther();\n', '    }\n', '\n', '    \n', '}']
['pragma solidity ^0.4.19;\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant public returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', ' \n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '  using SafeMath for uint256;\n', ' \n', '  mapping(address => uint256) balances;\n', ' \n', '  \n', ' \n', '}\n', '\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', ' \n', '  mapping (address => mapping (address => uint256)) allowed;\n', ' \n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '\n', ' \n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', ' \n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', ' \n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', ' \n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', ' \n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', ' \n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  \n', '  \n', '\n', ' \n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function  transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '  \n', '\n', ' \n', '}\n', ' \n', ' \n', ' \n', ' \n', '\n', ' \n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  \n', '   function pow(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    if(b==0) return 1;\n', '    assert(b>=0);\n', '    uint256 c = a ** b;\n', '    assert(c>=a );\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', 'function compoundInterest(uint256 depo, uint256 stage2, uint256 start, uint256 current)  internal pure returns (uint256)  {\n', '            if(current<start || start<stage2 || current<stage2) return depo;\n', '\n', '            uint256 ret=depo; uint256 g; uint256 d;\n', '            stage2=stage2/1 days;\n', '            start=start/1 days;\n', '            current=current/1 days;\n', '    \n', '\t\t\tuint256 dpercent=100;\n', '\t\t\tuint256 i=start;\n', '\t\t\t\n', '\t\t\tif(i-stage2>365) dpercent=200;\n', '\t\t\tif(i-stage2>730) dpercent=1000;\t\t\t\n', '\t\t\t\n', '\t\t\twhile(i<current)\n', '\t\t\t{\n', '\n', '\t\t\t\tg=i-stage2;\t\t\t\n', '\t\t\t\tif(g>265 && g<=365) \n', '\t\t\t\t{\t\t\n', '\t\t\t\t    d=365-g;\n', '\t\t\t\t\tif(d>=(current-start))  d=(current-start);\n', '\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\n', '\t\t\t\t    i+=d;\n', '\t\t\t\t\tdpercent=200;\n', '\t\t\t\t}\n', '\t\t\t\tif(g>630 && g<=730) \n', '\t\t\t\t{\t\t\t\t\n', '\t\t\t\t\td=730-g;\t\n', '\t\t\t\t\tif(d>=(current-start))  d=(current-start);\t\t\t\t\t\n', '\t\t\t\t\tret=fracExp(ret, dpercent, d, 8);\n', '\t\t\t\t\ti+=d;\n', '\t\t\t\t\tdpercent=1000;\t\t\t\t\t\n', '\t\t\t\t}\n', '\t\t\t\telse if(g>730) dpercent=1000;\t\t\t\t\n', '\t\t\t\telse if(g>365) dpercent=200;\n', '\t\t\t\t\n', '\t\t\t\tif(i+100<current) ret=fracExp(ret, dpercent, 100, 8);\n', '\t\t\t\telse return fracExp(ret, dpercent, current-i, 8);\n', '\t\t\t\ti+=100;\n', '\t\t\t\t\n', '\t\t\t}\n', '\n', '\t\t\treturn ret;\n', '\t\t\t\n', '\t\t\t\n', '    \n', '    \n', '\t}\n', '\n', '\n', 'function fracExp(uint256 depo, uint256 percent, uint256 period, uint256 p)  internal pure returns (uint256) {\n', '  uint256 s = 0;\n', '  uint256 N = 1;\n', '  uint256 B = 1;\n', '  \n', '\n', '  \n', '  for (uint256 i = 0; i < p; ++i){\n', '    s += depo * N / B / (percent**i);\n', '    N  = N * (period-i);\n', '    B  = B * (i+1);\n', '  }\n', '  return s;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '}\n', '\n', '\n', '\n', 'contract MMMTokenCoin is StandardToken, Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    string public constant name = "Make More Money";\n', '    string public constant symbol = "MMM";\n', '    uint32 public constant decimals = 2;\n', '    \n', '\t\n', '\t// Dates\n', '\tuint256 public stage2StartTime;\t\t\t\t\t// timestamp when compound interest will begin\n', '    uint256 globalInterestDate;             // last date when amount of tokens with interest was changed\n', '    uint256 globalInterestAmount;           // amount of tokens with interest\n', '\tmapping(address => uint256) dateOfStart;     // timestamp of last operation, from which interest calc will be started\n', '\tuint256 public currentDate;\t\t\t\t\t\t// current date timestamp\n', '\tuint256 public debugNow=0;\n', '\n', '\n', '\n', '    // Crowdsale \n', '    uint256 public totalSupply=99900000000;\t\t\t\n', ' uint256 public  softcap;\n', '    uint256 public  step0Rate=100000;       // rate of our tokens. 1 eth = 1000 MMM coins = 100000 tokens (seen as 1000,00 because of decimals)\n', '    uint256 public  currentRate=100000;   \n', "    uint256 public constant tokensForOwner=2000000000;   // tokens for owner won't dealt with compound interest\n", '    uint256 public tokensFromEther=0;\n', '    uint public saleStatus=0;      // 0 - sale is running, 1 - sale failed, 2 - sale successful\n', '    address multisig=0x8216A5958f05ad61898e3A6F97ae5118C0e4b1A6;\n', '    // counters of tokens for futher refund\n', '    mapping(address => uint256) boughtWithEther;                // tokens, bought with ether. can be refunded to ether\n', '    mapping(address => uint256) boughtWithOther;    \t\t\t// tokens, bought with other payment systems. can be refunded to other payment systems, using site\n', '    mapping(address => uint256) bountyAndRefsWithEther;  \t\t// bounty tokens, given to some people. can be converted to ether, if ico is succeed\n', '  \n', '    \n', '\n', '\t\t\n', '\t\t\n', '    // events\n', '    event RefundEther(address indexed to, uint256 tokens, uint256 eth); \n', '    event DateUpdated(uint256 cdate);    \n', '    event DebugLog(string what, uint256 param);\n', '    event Sale(address indexed to, uint256 amount);\n', '    event Step0Finished();\n', '    event RateSet(uint256 newRate);\t\n', '    event Burn(address indexed who, uint256 amount);\n', '   // DEBUG\n', '\n', '    bool bDbgEnabled=false;\n', '\t\n', '\t\n', '\t\n', '    function MMMTokenCoin() public   {  \n', '        // Crowdsale     \n', '        currentDate=(getNow()/1 days)*1 days;\n', '        stage2StartTime=getNow()+61 days;\n', '        \n', '        balances[owner]=tokensForOwner;\n', '        globalInterestAmount=0;\n', '        \n', '        if(bDbgEnabled) softcap=20000;\n', '        else  softcap=50000000;\n', '    }\n', '\t\n', '\t\n', '\tfunction debugSetNow(uint256 n) public\n', '\t{\n', '\t    require(bDbgEnabled);\n', '\t\tdebugNow=n;\n', '\t}\n', '\t\n', '\t\n', '\t /**\n', '     * @dev Returns current timestamp. In case of debugging, this function can return timestamp representing any other time\n', '     */\n', '     \n', '     \n', '\tfunction getNow() public view returns (uint256)\n', '\t{\n', '\t    \n', '\t    if(!bDbgEnabled) return now;\n', '\t    \n', '\t    if(debugNow==0) return now;\n', '\t\telse return debugNow;\n', '//\t\treturn now;\n', '\t}\n', '   \n', '    /**\n', '     * @dev Sets date from which interest will be calculated for specified address\n', '     * @param _owner - address of balance owner\n', '     */\n', '   \n', '    \n', '    function updateDate(address _owner) private {\n', '        if(currentDate<stage2StartTime) dateOfStart[_owner]=stage2StartTime;\n', '        else dateOfStart[_owner]=currentDate;\n', '    }\n', '    \n', '\n', '\t\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of. \n', '    * @return An uint25664 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) \n', '    { \n', '        \n', '         return balanceWithInterest(_owner);\n', '    }   \n', '   \n', '\t\n', '    /**\n', '     * @dev Gets balance including interest for specified address\n', '   \t * @param _owner The address to query the the balance of. \n', '     */\n', '\t\t\n', '\t\t\n', '    function balanceWithInterest(address _owner)  private constant returns (uint256 ret)\n', '    {\n', '        if( _owner==owner || saleStatus!=2) return balances[_owner]; \n', '        return balances[_owner].compoundInterest(stage2StartTime, dateOfStart[_owner], currentDate);\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '\t\t \n', '  function transfer(address _to, uint256 _value)  public returns (bool) {\n', '    if(msg.sender==owner) {\n', '    \t// if owner sends tokens before sale finish, consider then as ether-refundable bonus\n', '    \t// else as simple transfer\n', '        if(saleStatus==0) {\n', '            \ttransferFromOwner(_to, _value,1);\n', '            \ttokensFromEther=tokensFromEther.add(_value);\n', '\t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\n', '        \t}\n', '        \telse transferFromOwner(_to, _value,0);\n', '        \t\n', '        \tincreaseGlobalInterestAmount(_value);\n', '        \treturn true;   \n', '    }\n', '    \n', '    balances[msg.sender] = balanceWithInterest(msg.sender).sub(_value);\n', '\n', '    emit Transfer(msg.sender, _to, _value);\n', '    if(_to==address(this)) {\n', '\t\t// make refund if tokens sent to contract\n', '        uint256 left; left=processRefundEther(msg.sender, _value);\n', '        balances[msg.sender]=balances[msg.sender].add(left);\n', '    }\n', '    else {\n', '        balances[_to] = balanceWithInterest(_to).add(_value);\n', '        updateDate(_to);\n', '    }\n', '    \n', '    if(_to==owner) \n', '    {\n', "    \t// before sale finish, tokens can't be sent to owner\n", '        require(saleStatus!=0);\n', '        decreaseGlobalInterestAmount(_value);\n', '    }\n', '    \n', '    updateDate(msg.sender);\n', '    return true;\n', '  }\n', '  \n', '  \n', '  /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transfered\n', '    */\n', '\t  \n', '  \n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '           require(_to!=owner);\n', '    uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '     allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '    if(_from==owner) {\n', '        if(saleStatus==0) {\n', '            transferFromOwner(_to, _value,1);\n', '            tokensFromEther=tokensFromEther.add(_value);\n', '\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add(_value);\t\t\t\n', '        }\n', '        else transferFromOwner(_to, _value,0);\n', '      \n', '        increaseGlobalInterestAmount(_value);\n', '        return true;\n', '    }\n', '     \n', '     \n', '    balances[_from] = balanceWithInterest(_from).sub(_value);\n', '\n', '     emit Transfer(_from, _to, _value);\n', '\n', '    if(_to==address(this)) {\n', '\t\t// make refund if tokens sent to contract\t\t   \n', '        uint256 left; left=processRefundEther(_from, _value);\n', '        balances[_from]=balances[_from].add(left);\n', '    }\n', '    else {\n', '        balances[_to] = balanceWithInterest(_to).add(_value);\n', '        updateDate(_to);\n', '    }\n', '    \n', '    if(_to==owner) \n', '    {\n', '        require(saleStatus!=0);\n', '        decreaseGlobalInterestAmount(_value);\n', '    }\n', '\n', '    updateDate(_from);\n', '\n', '    return true;\n', '  }\n', '  \n', '  \n', '  \n', '    /**\n', '    * @dev Burns tokens\n', '    * @param _amount amount of tokens to burn\n', '    */\n', '\t  \n', '\t  \n', '\t  \n', '  function burn(uint256 _amount) public \n', '  {\n', '\t  \trequire(_amount>0);\n', '        balances[msg.sender]=balanceOf(msg.sender).sub(_amount);\n', '\t\tdecreaseGlobalInterestAmount(_amount);\n', '        emit Burn(msg.sender, _amount);\n', '  }\n', '   \n', '   //// SALE ////\n', '   \n', '    /**\n', '     * @dev updates rate with whic tokens are being sold\n', '     */\n', '\n', ' \tfunction setRate(uint256 r) public {\n', '\t\trequire(saleStatus!=0);\n', '\t\tcurrentRate=r;\n', '\t\temit RateSet(currentRate);\n', '\t}\n', '\n', '    /**\n', '     * @dev updates current date value. For compound interest calculation\n', '     */\n', '    \n', '    function newDay() public   returns (bool b)\n', '    {\n', '        \n', '       uint256 g; uint256 newDate;\n', '       require(getNow()>=stage2StartTime);\n', '       require(getNow()>=currentDate);\n', '       newDate=(getNow()/1 days)*1 days;\n', '        if(getNow()>=stage2StartTime && saleStatus==0)\n', '        {\n', '            if(tokensForOwner.sub(balances[owner])>=softcap) saleStatus=2;\n', '            else saleStatus=1;\n', '         \n', '            emit Step0Finished();\n', '        }\n', '      \n', '\t   // check if overall compound interest of tokens will be less than total supply\n', '\t  \n', '       g=globalInterestAmount.compoundInterest(stage2StartTime, globalInterestDate, newDate);\n', '       if(g<=totalSupply && saleStatus==2) {\n', '             currentDate=(getNow()/1 days)*1 days; \n', '             globalInterestAmount=g;\n', '             globalInterestDate=currentDate;\n', '             emit DateUpdated(currentDate);\n', '             return true;\n', '       }\n', '       else if(saleStatus==1) currentDate=(getNow()/1 days)*1 days; \n', '       \n', '       return false;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev Sends collected ether to owner. If sale is not success, contract will hold ether for half year, and after, ether can be sent to owner\n', "     * @return amount of owner's ether\n", '     */\n', '     \n', '    function sendEtherToMultisig() public  returns(uint256 e) {\n', '        uint256 req;\n', '        require(msg.sender==owner || msg.sender==multisig);\n', '        require(saleStatus!=0);\n', '\n', '        if(saleStatus==2) {\n', '        \t// calculate ether for refunds\n', '        \treq=tokensFromEther.mul(1 ether).div(step0Rate).div(2);\n', '\n', '        \tif(bDbgEnabled) emit DebugLog("This balance is", this.balance);\n', '        \tif(req>=this.balance) return 0;\n', '    \t}\n', '    \telse if(saleStatus==1) {\n', '    \t\trequire(getNow()-stage2StartTime>15768000);\n', '    \t\treq=0; \n', '    \t}\n', '        uint256 amount;\n', '        amount=this.balance.sub(req);\n', '        multisig.transfer(amount);\n', '        return amount;\n', '        \n', '    }\n', '    \n', '\t\n', '\n', '\n', '\t\n', '\t\n', '\t/**\n', '\t\tRefund functions. \n', '\t\tIf ico is success, anyone can get 0.000005 eth for 1 token,  else 00001 eth\n', '\t\t\n', '\t*/\n', '\t\n', '    /**\n', '     * @dev Refunds ether to sender if he trasnfered tokens to contract address. Calculates max possible amount of refund. If sent tokens>refund amound, tokens will be returned to sender.\n', '     * @param _to Address of refund receiver\n', '     * @param _value Tokens requested for refund\n', '     */\n', '\t\n', '    function processRefundEther(address _to, uint256 _value) private returns (uint256 left)\n', '    {\n', '        require(saleStatus!=0);\n', '        require(_value>0);\n', '        uint256 Ether=0; uint256 bounty=0;  uint256 total=0;\n', '\n', '        uint256 rate2=saleStatus;\n', '\n', '        \n', '        if(_value>=boughtWithEther[_to]) {Ether=Ether.add(boughtWithEther[_to]); _value=_value.sub(boughtWithEther[_to]); }\n', '        else {Ether=Ether.add(_value); _value=_value.sub(Ether);}\n', '        boughtWithEther[_to]=boughtWithEther[_to].sub(Ether);\n', '        \n', '        if(rate2==2) {        \n', '            if(_value>=bountyAndRefsWithEther[_to]) {bounty=bounty.add(bountyAndRefsWithEther[_to]); _value=_value.sub(bountyAndRefsWithEther[_to]); }\n', '            else { bounty=bounty.add(_value); _value=_value.sub(bounty); }\n', '            bountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].sub(bounty);\n', '        }\n', '        total=Ether.add(bounty);\n', '     //   if(_value>total) _value=_value.sub(total);\n', '        tokensFromEther=tokensFromEther.sub(total);\n', '       uint256 eth=total.mul(1 ether).div(step0Rate).div(rate2);\n', '         _to.transfer(eth);\n', '        if(bDbgEnabled) emit DebugLog("Will refund ", eth);\n', '\n', '        emit RefundEther(_to, total, eth);\n', '        decreaseGlobalInterestAmount(total);\n', '        return _value;\n', '    }\n', '    \n', '    \n', '\t\n', '\n', '\t     /**\n', '     * @dev Returns info about refundable tokens- bought with ether, payment systems, and bonus tokens convertable to ether\n', '     */\n', '\t\n', '\tfunction getRefundInfo(address _to) public returns (uint256, uint256, uint256)\n', '\t{\n', '\t    return  ( boughtWithEther[_to],  boughtWithOther[_to],  bountyAndRefsWithEther[_to]);\n', '\t    \n', '\t}\n', '\t\n', '    \n', '    /**\n', '     * @dev Withdraw tokens  refunded to other payment systems.\n', '     * @param _to Address of refund receiver\n', '     */\n', '    \n', '    function refundToOtherProcess(address _to, uint256 _value) public onlyOwner returns (uint256 o) {\n', '        require(saleStatus!=0);\n', '        //uint256 maxValue=refundToOtherGet(_to);\n', '        uint256 maxValue=0;\n', '        require(_value<=maxValue);\n', '        \n', '        uint256 Other=0; uint256 bounty=0; \n', '\n', '\n', '\n', '        \n', '        if(_value>=boughtWithOther[_to]) {Other=Other.add(boughtWithOther[_to]); _value=_value.sub(boughtWithOther[_to]); }\n', '        else {Other=Other.add(_value); _value=_value.sub(Other);}\n', '        boughtWithOther[_to]=boughtWithOther[_to].sub(Other);\n', '\n', '       \n', '        balances[_to]=balanceOf(_to).sub(Other).sub(bounty);\n', '        updateDate(_to);\n', '        decreaseGlobalInterestAmount(Other.add(bounty));\n', '        return _value;\n', '        \n', '        \n', '    }\n', '    \n', ' \n', '    /**\n', '     * @dev Converts ether to our tokens \n', '     */\n', '\t\t  \n', '    \n', '    function createTokensFromEther()  private   {\n', '               \n', '        assert(msg.value >= 1 ether / 1000);\n', '       \n', '         uint256 tokens = currentRate.mul(msg.value).div(1 ether);\n', '\n', '\n', '        transferFromOwner(msg.sender, tokens,2);\n', '      \n', '       if(saleStatus==0) {\n', '           boughtWithEther[msg.sender]=boughtWithEther[msg.sender].add(tokens);\n', '            tokensFromEther=tokensFromEther.add(tokens);\n', '       }\n', '      \n', '    }\n', '\t\n', '\t\n', '    /**\n', '     * @dev Converts other payments system payment to  tokens. Main logic is on site\n', '     */\n', '    \n', '    function createTokensFromOther(address _to, uint256 howMuch, address referer) public  onlyOwner   { \n', '      \n', '        require(_to!=address(this));\n', '         transferFromOwner(_to, howMuch,2);\n', '         if(referer!=0 && referer!=address(this) && referer!=0x0000000000000000000000000000000000000000 && howMuch.div(10)>0) {\n', '             transferFromOwner(referer, howMuch.div(10),1);\n', '\t         if(saleStatus==0) {\n', '\t             \ttokensFromEther=tokensFromEther.add( howMuch.div(10));\n', '\t \t\t\t\tbountyAndRefsWithEther[_to]=bountyAndRefsWithEther[_to].add( howMuch.div(10));\n', '\t         \t}\n', '         }\n', '         if(saleStatus==0) boughtWithOther[_to]= boughtWithOther[_to].add(howMuch);\n', '    }\n', '\n', '\t   /**\n', '     * @dev Gives refs tokens through payment on site. Main logic is on site\n', '     * @param _to Address of  receiver\n', '     * @param _amount Amount of tokens\t\t\n', '\t * @param t type of transfer. 0 is transfer, 1 bonus tokens, 2 - sale\n', '     */\n', '\t\n', '\tfunction transferFromOwner(address _to, uint256 _amount, uint t) private {\n', '\t   require(_to!=address(this) && _to!=address(owner) );\n', '        balances[owner]=balances[owner].sub(_amount); \n', '        balances[_to]=balanceOf(_to).add(_amount);\n', '        updateDate(_to);\n', '\n', '        increaseGlobalInterestAmount(_amount);\n', '\t    \n', '\t   \n', '\t     if(t==2) emit Sale(_to, _amount);\n', '        emit Transfer(owner, _to, _amount);\t     \n', '\t}\n', '\t\n', '\n', '    function increaseGlobalInterestAmount(uint256 c) private \n', '    {\n', '        globalInterestAmount=globalInterestAmount.add(c);\n', '\t\t\n', '    }\n', '    \n', '    function decreaseGlobalInterestAmount(uint256 c) private\n', '    {\n', '        if(c<globalInterestAmount) {\n', '            globalInterestAmount=globalInterestAmount.sub(c);\n', '        }\n', '            \n', '        \n', '    }\n', '    \n', '    function() external payable {\n', '        createTokensFromEther();\n', '    }\n', '\n', '    \n', '}']
