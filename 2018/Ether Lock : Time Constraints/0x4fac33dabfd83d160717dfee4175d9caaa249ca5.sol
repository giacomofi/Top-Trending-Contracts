['pragma solidity ^0.4.24;\n', '\n', 'contract Sacrific3d {\n', '    \n', '    struct Stage {\n', '        uint8 numberOfPlayers;\n', '        uint256 blocknumber;\n', '        bool finalized;\n', '        mapping (uint8 => address) slotXplayer;\n', '        mapping (address => bool) players;\n', '    }\n', '    \n', '    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n', '   \n', '    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\n', '    uint256 constant private P3D_SHARE = 0.005 ether;\n', '    \n', '    uint8 constant public MAX_PLAYERS_PER_STAGE = 5;\n', '    uint256 constant public OFFER_SIZE = 0.1 ether;\n', '    \n', '    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\n', '    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \n', '    uint256 public winningsPerRound = OFFER_SIZE + OFFER_SIZE / (MAX_PLAYERS_PER_STAGE - 1) - P3D_SHARE;\n', '    \n', '    mapping(address => uint256) private playerVault;\n', '    mapping(uint256 => Stage) private stages;\n', '    uint256 private numberOfFinalizedStages;\n', '    \n', '    uint256 public numberOfStages;\n', '    \n', '    event SacrificeOffered(address indexed player);\n', '    event SacrificeChosen(address indexed sarifice);\n', '    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\n', '    event StageInvalidated(uint256 indexed stage);\n', '    \n', '    modifier isValidOffer()\n', '    {\n', '        require(msg.value == OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier canPayFromVault()\n', '    {\n', '        require(playerVault[msg.sender] >= OFFER_SIZE);\n', '        _;\n', '    }\n', '    \n', '    modifier hasEarnings()\n', '    {\n', '        require(playerVault[msg.sender] > 0);\n', '        _;\n', '    }\n', '    \n', '    modifier prepareStage()\n', '    {\n', '        //create a new stage if current has reached max amount of players\n', '        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '           stages[numberOfStages] = Stage(0, 0, false);\n', '           numberOfStages++;\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier isNewToStage()\n', '    {\n', '        require(stages[numberOfStages - 1].players[msg.sender] == false);\n', '        _;\n', '    }\n', '    \n', '    constructor()\n', '        public\n', '    {\n', '        stages[numberOfStages] = Stage(0, 0, false);\n', '        numberOfStages++;\n', '    }\n', '    \n', '    function() external payable {}\n', '    \n', '    function offerAsSacrifice()\n', '        external\n', '        payable\n', '        isValidOffer\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        acceptOffer();\n', '        \n', '        //try to choose a sacrifice in an already full stage (finalize a stage)\n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function offerAsSacrificeFromVault()\n', '        external\n', '        canPayFromVault\n', '        prepareStage\n', '        isNewToStage\n', '    {\n', '        playerVault[msg.sender] -= OFFER_SIZE;\n', '        \n', '        acceptOffer();\n', '        \n', '        tryFinalizeStage();\n', '    }\n', '    \n', '    function withdraw()\n', '        external\n', '        hasEarnings\n', '    {\n', '        tryFinalizeStage();\n', '        \n', '        uint256 amount = playerVault[msg.sender];\n', '        playerVault[msg.sender] = 0;\n', '        \n', '        emit EarningsWithdrawn(msg.sender, amount); \n', '        \n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function myEarnings()\n', '        external\n', '        view\n', '        hasEarnings\n', '        returns(uint256)\n', '    {\n', '        return playerVault[msg.sender];\n', '    }\n', '    \n', '    function currentPlayers()\n', '        external\n', '        view\n', '        returns(uint256)\n', '    {\n', '        return stages[numberOfStages - 1].numberOfPlayers;\n', '    }\n', '    \n', '    function acceptOffer()\n', '        private\n', '    {\n', '        Stage storage currentStage = stages[numberOfStages - 1];\n', '        \n', '        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\n', '        \n', '        address player = msg.sender;\n', '        \n', '        //add player to current stage\n', '        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\n', '        currentStage.numberOfPlayers++;\n', '        currentStage.players[player] = true;\n', '        \n', '        emit SacrificeOffered(player);\n', '        \n', '        //add blocknumber to current stage when the last player is added\n', '        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n', '            currentStage.blocknumber = block.number;\n', '        }\n', '    }\n', '    \n', '    function tryFinalizeStage()\n', '        private\n', '    {\n', '        assert(numberOfStages >= numberOfFinalizedStages);\n', '        \n', '        //there are no stages to finalize\n', '        if(numberOfStages == numberOfFinalizedStages) {return;}\n', '        \n', '        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\n', '        \n', '        assert(!stageToFinalize.finalized);\n', '        \n', '        //stage is not ready to be finalized\n', '        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\n', '        \n', '        assert(stageToFinalize.blocknumber != 0);\n', '        \n', '        //check if blockhash can be determined\n', '        if(block.number - 256 <= stageToFinalize.blocknumber) {\n', "            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\n", '            if(block.number == stageToFinalize.blocknumber) {return;}\n', '                \n', '            //determine sacrifice\n', '            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\n', '            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\n', '            \n', '            emit SacrificeChosen(sacrifice);\n', '            \n', '            //allocate winnings to survivors\n', '            allocateSurvivorWinnings(sacrifice);\n', '            \n', '            //allocate p3d dividends to sacrifice if existing\n', '            uint256 dividends = p3dContract.myDividends(true);\n', '            if(dividends > 0) {\n', '                p3dContract.withdraw();\n', '                playerVault[sacrifice]+= dividends;\n', '            }\n', '            \n', '            //purchase p3d (using ref)\n', '            p3dContract.buy.value(p3dPerStage)(address(0x1EB2acB92624DA2e601EEb77e2508b32E49012ef));\n', '        } else {\n', '            invalidateStage(numberOfFinalizedStages);\n', '            \n', '            emit StageInvalidated(numberOfFinalizedStages);\n', '        }\n', '        //finalize stage\n', '        stageToFinalize.finalized = true;\n', '        numberOfFinalizedStages++;\n', '    }\n', '    \n', '    function allocateSurvivorWinnings(address sacrifice)\n', '        private\n', '    {\n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\n', '            if(survivor != sacrifice) {\n', '                playerVault[survivor] += winningsPerRound;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function invalidateStage(uint256 stageIndex)\n', '        private\n', '    {\n', '        Stage storage stageToInvalidate = stages[stageIndex];\n', '        \n', '        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n', '            address player = stageToInvalidate.slotXplayer[i];\n', '            playerVault[player] += OFFER_SIZE;\n', '        }\n', '    }\n', '}\n', '\n', 'interface HourglassInterface {\n', '    function buy(address _playerAddress) payable external returns(uint256);\n', '    function withdraw() external;\n', '    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n', '}']