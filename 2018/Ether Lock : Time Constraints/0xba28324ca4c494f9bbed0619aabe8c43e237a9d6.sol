['pragma solidity ^0.4.24;\n', '\n', 'contract Magic10 {\n', '    \n', '    // Timer of percentage increasing \n', '\tuint256 public periodLength = 7 days;\n', '\t\n', '\t// We need to work with fractional percents like 0.7%, so we need to devide by 1000 before multiply the number\n', '\t// Each variable which calculated with this value has a prefix Decimal\n', '\tuint256 public percentDecimals = 3;\n', '\t\n', '\t// Percents calculation using percentDecimals 2% = 20\n', '\tuint256 public startDecimalPercent = 20;\n', '\n', '    // Additional percent for completed period is 0.3% = 3\n', '\tuint256 public bonusDecimalPercentByPeriod = 3; \n', '\t\n', '\t// Maximal percent is 5% = 50\n', '\tuint256 public maximalDecimalPercent = 50;\n', '\n', '    // Structure of deposit\n', '\tstruct Deposit {\n', '\t    address owner;\n', '        uint256 amount;\n', '        uint64 timeFrom;\n', '    }\n', '    \n', '    // Notice, start index for all deposits is 1.\n', '    // List of all deposits\n', '    mapping(uint64 => Deposit) public deposits;\n', '    \n', '    // List of all deposits by each investor\n', '    // Implemented to enable quick access to investor deposits even without server caching\n', '    mapping(address => mapping(uint64 => uint64)) public investorsToDeposit;\n', '    \n', '    // Count of deposits by each investor\n', '    mapping(address => uint16) public depositsByInvestor;\n', '    \n', '    // List of registered referrals\n', '    mapping(address => bool) public referralList;\n', '    \n', '    // Total number of deposits\n', '    uint64 public depositsCount = 0;\n', '    \n', '    \n', '    // Create a new deposit\n', '    function createDeposit(address _referral) external payable {\n', '        \n', '        // Minimal deposit is 1 finney\n', '        require(msg.value >= 1 finney);\n', '        \n', '        // Create a deposit object\n', '        Deposit memory _deposit = Deposit({\n', '            owner: msg.sender,\n', '            amount: msg.value,\n', '            timeFrom: uint64(now)\n', '        });\n', '        \n', '        //\n', '        // Calculating IDS\n', '        //\n', '        \n', '        // New deposit ID equals to current deposits count + 1\n', '        uint64 depositId = depositsCount+1;\n', '        \n', '        // new deposit ID for investor equals current count + 1\n', '        uint64 depositIdByInvestor = depositsByInvestor[msg.sender] + 1;\n', '        \n', '        //\n', '        // Saving data\n', '        //\n', '        \n', '        // Saving deposit into current ID\n', '        deposits[depositId] = _deposit;\n', '        \n', '        // Adding deposit ID into list of deposits for current investor\n', '        investorsToDeposit[msg.sender][depositIdByInvestor] = depositId;\n', '        \n', '        //\n', '        // Counters incrementing    \n', '        //\n', '        \n', '        // Increment count of deposits for current investor\n', '        depositsByInvestor[msg.sender]++;\n', '        \n', '        // Increment global count of deposits\n', '        depositsCount++;\n', '        \n', '        //\n', '        // Additional sendings - 5% to company and 1-5% to referrals\n', '        //\n', '        \n', '        address company = 0xFd40fE6D5d31c6A523F89e3Af05bb3457B5EAD0F;\n', '        \n', '        // 5% goes to the company budget\n', '        company.transfer(msg.value / 20);\n', '        \n', '        // Referral percent\n', '        uint8 refferalPercent = currentReferralPercent();\n', '        \n', '        // Referral receive reward according current reward percent if he is in list.\n', '        if(referralList[_referral] && _referral != msg.sender) {\n', '            _referral.transfer(msg.value * refferalPercent/ 100);\n', '        }\n', '    }\n', '    \n', '    // Function for withdraw\n', '    function withdrawPercents(uint64 _depositId) external {\n', '        \n', '        // Get deposit information\n', '        Deposit memory deposit = deposits[_depositId];\n', '        \n', '        // Available for deposit owner only\n', '        require(deposit.owner == msg.sender);\n', '        \n', '        // Get reward amount by public function currentReward\n', '        uint256 reward = currentReward(_depositId);\n', '        \n', '        // Refresh deposit time and save it\n', '        deposit.timeFrom = uint64(now);\n', '        deposits[_depositId] = deposit;\n', '        \n', '        // Transfer reward to investor\n', '        deposit.owner.transfer(reward);\n', '    }\n', '\n', '    // Referal registration\n', '    function registerReferral(address _refferal) external {\n', '        // Available from this address only \n', '        require(msg.sender == 0x21b4d32e6875a6c2e44032da71a33438bbae8820);\n', '        \n', '        referralList[_refferal] = true;\n', '    }\n', '    \n', '    //\n', '    //\n', '    //\n', '    // Information functions\n', '    //\n', '    //\n', '    //\n', '    \n', '    // Calcaulating current reward by deposit ID\n', '    function currentReward(uint64 _depositId)\n', '        view \n', '        public \n', '        returns(uint256 amount) \n', '    {\n', '        // Get information about deposit\n', '        Deposit memory deposit = deposits[_depositId];\n', '        \n', '        // Bug protection with "now" time\n', '        if(deposit.timeFrom > now)\n', '            return 0;\n', '        \n', '        // Get current deposit percent using public function rewardDecimalPercentByTime\n', '        uint16 dayDecimalPercent = rewardDecimalPercentByTime(deposit.timeFrom);\n', '        \n', '        // Calculating reward for each day\n', '        uint256 amountByDay = ( deposit.amount * dayDecimalPercent / 10**percentDecimals ) ;\n', '        \n', '        // Calculate time from the start of the deposit to current time in minutes\n', '        uint256 minutesPassed = (now - deposit.timeFrom) / 60;\n', '        amount = amountByDay * minutesPassed / 1440;\n', '    }\n', '    \n', '    // Calculate reward percent by timestamp of creation\n', '    function rewardDecimalPercentByTime(uint256 _timeFrom) \n', '        view \n', '        public \n', '        returns(uint16 decimalPercent) \n', '    {\n', '        // Returning start percent, if sending timestamp from the future\n', '        if(_timeFrom >= now)\n', '            return uint16(startDecimalPercent);\n', '            \n', '        // Main calculating\n', '        decimalPercent = uint16(startDecimalPercent +  (( (now - _timeFrom) / periodLength ) * bonusDecimalPercentByPeriod));\n', '        \n', '        // Returning the maximum percentage if the percentage is higher than the maximum\n', '        if(decimalPercent > maximalDecimalPercent)\n', '            return uint16(maximalDecimalPercent);\n', '    }\n', '    \n', '    // Referral percent calculating by contract balance\n', '    function currentReferralPercent() \n', '        view \n', '        public \n', '        returns(uint8 percent) \n', '    {\n', '        if(address(this).balance > 10000 ether)\n', '            return 1;\n', '            \n', '        if(address(this).balance > 1000 ether)\n', '            return 2;\n', '            \n', '        if(address(this).balance > 100 ether)\n', '            return 3;\n', '            \n', '        if(address(this).balance > 10 ether)\n', '            return 4;\n', '        \n', '        return 5;\n', '    }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'contract Magic10 {\n', '    \n', '    // Timer of percentage increasing \n', '\tuint256 public periodLength = 7 days;\n', '\t\n', '\t// We need to work with fractional percents like 0.7%, so we need to devide by 1000 before multiply the number\n', '\t// Each variable which calculated with this value has a prefix Decimal\n', '\tuint256 public percentDecimals = 3;\n', '\t\n', '\t// Percents calculation using percentDecimals 2% = 20\n', '\tuint256 public startDecimalPercent = 20;\n', '\n', '    // Additional percent for completed period is 0.3% = 3\n', '\tuint256 public bonusDecimalPercentByPeriod = 3; \n', '\t\n', '\t// Maximal percent is 5% = 50\n', '\tuint256 public maximalDecimalPercent = 50;\n', '\n', '    // Structure of deposit\n', '\tstruct Deposit {\n', '\t    address owner;\n', '        uint256 amount;\n', '        uint64 timeFrom;\n', '    }\n', '    \n', '    // Notice, start index for all deposits is 1.\n', '    // List of all deposits\n', '    mapping(uint64 => Deposit) public deposits;\n', '    \n', '    // List of all deposits by each investor\n', '    // Implemented to enable quick access to investor deposits even without server caching\n', '    mapping(address => mapping(uint64 => uint64)) public investorsToDeposit;\n', '    \n', '    // Count of deposits by each investor\n', '    mapping(address => uint16) public depositsByInvestor;\n', '    \n', '    // List of registered referrals\n', '    mapping(address => bool) public referralList;\n', '    \n', '    // Total number of deposits\n', '    uint64 public depositsCount = 0;\n', '    \n', '    \n', '    // Create a new deposit\n', '    function createDeposit(address _referral) external payable {\n', '        \n', '        // Minimal deposit is 1 finney\n', '        require(msg.value >= 1 finney);\n', '        \n', '        // Create a deposit object\n', '        Deposit memory _deposit = Deposit({\n', '            owner: msg.sender,\n', '            amount: msg.value,\n', '            timeFrom: uint64(now)\n', '        });\n', '        \n', '        //\n', '        // Calculating IDS\n', '        //\n', '        \n', '        // New deposit ID equals to current deposits count + 1\n', '        uint64 depositId = depositsCount+1;\n', '        \n', '        // new deposit ID for investor equals current count + 1\n', '        uint64 depositIdByInvestor = depositsByInvestor[msg.sender] + 1;\n', '        \n', '        //\n', '        // Saving data\n', '        //\n', '        \n', '        // Saving deposit into current ID\n', '        deposits[depositId] = _deposit;\n', '        \n', '        // Adding deposit ID into list of deposits for current investor\n', '        investorsToDeposit[msg.sender][depositIdByInvestor] = depositId;\n', '        \n', '        //\n', '        // Counters incrementing    \n', '        //\n', '        \n', '        // Increment count of deposits for current investor\n', '        depositsByInvestor[msg.sender]++;\n', '        \n', '        // Increment global count of deposits\n', '        depositsCount++;\n', '        \n', '        //\n', '        // Additional sendings - 5% to company and 1-5% to referrals\n', '        //\n', '        \n', '        address company = 0xFd40fE6D5d31c6A523F89e3Af05bb3457B5EAD0F;\n', '        \n', '        // 5% goes to the company budget\n', '        company.transfer(msg.value / 20);\n', '        \n', '        // Referral percent\n', '        uint8 refferalPercent = currentReferralPercent();\n', '        \n', '        // Referral receive reward according current reward percent if he is in list.\n', '        if(referralList[_referral] && _referral != msg.sender) {\n', '            _referral.transfer(msg.value * refferalPercent/ 100);\n', '        }\n', '    }\n', '    \n', '    // Function for withdraw\n', '    function withdrawPercents(uint64 _depositId) external {\n', '        \n', '        // Get deposit information\n', '        Deposit memory deposit = deposits[_depositId];\n', '        \n', '        // Available for deposit owner only\n', '        require(deposit.owner == msg.sender);\n', '        \n', '        // Get reward amount by public function currentReward\n', '        uint256 reward = currentReward(_depositId);\n', '        \n', '        // Refresh deposit time and save it\n', '        deposit.timeFrom = uint64(now);\n', '        deposits[_depositId] = deposit;\n', '        \n', '        // Transfer reward to investor\n', '        deposit.owner.transfer(reward);\n', '    }\n', '\n', '    // Referal registration\n', '    function registerReferral(address _refferal) external {\n', '        // Available from this address only \n', '        require(msg.sender == 0x21b4d32e6875a6c2e44032da71a33438bbae8820);\n', '        \n', '        referralList[_refferal] = true;\n', '    }\n', '    \n', '    //\n', '    //\n', '    //\n', '    // Information functions\n', '    //\n', '    //\n', '    //\n', '    \n', '    // Calcaulating current reward by deposit ID\n', '    function currentReward(uint64 _depositId)\n', '        view \n', '        public \n', '        returns(uint256 amount) \n', '    {\n', '        // Get information about deposit\n', '        Deposit memory deposit = deposits[_depositId];\n', '        \n', '        // Bug protection with "now" time\n', '        if(deposit.timeFrom > now)\n', '            return 0;\n', '        \n', '        // Get current deposit percent using public function rewardDecimalPercentByTime\n', '        uint16 dayDecimalPercent = rewardDecimalPercentByTime(deposit.timeFrom);\n', '        \n', '        // Calculating reward for each day\n', '        uint256 amountByDay = ( deposit.amount * dayDecimalPercent / 10**percentDecimals ) ;\n', '        \n', '        // Calculate time from the start of the deposit to current time in minutes\n', '        uint256 minutesPassed = (now - deposit.timeFrom) / 60;\n', '        amount = amountByDay * minutesPassed / 1440;\n', '    }\n', '    \n', '    // Calculate reward percent by timestamp of creation\n', '    function rewardDecimalPercentByTime(uint256 _timeFrom) \n', '        view \n', '        public \n', '        returns(uint16 decimalPercent) \n', '    {\n', '        // Returning start percent, if sending timestamp from the future\n', '        if(_timeFrom >= now)\n', '            return uint16(startDecimalPercent);\n', '            \n', '        // Main calculating\n', '        decimalPercent = uint16(startDecimalPercent +  (( (now - _timeFrom) / periodLength ) * bonusDecimalPercentByPeriod));\n', '        \n', '        // Returning the maximum percentage if the percentage is higher than the maximum\n', '        if(decimalPercent > maximalDecimalPercent)\n', '            return uint16(maximalDecimalPercent);\n', '    }\n', '    \n', '    // Referral percent calculating by contract balance\n', '    function currentReferralPercent() \n', '        view \n', '        public \n', '        returns(uint8 percent) \n', '    {\n', '        if(address(this).balance > 10000 ether)\n', '            return 1;\n', '            \n', '        if(address(this).balance > 1000 ether)\n', '            return 2;\n', '            \n', '        if(address(this).balance > 100 ether)\n', '            return 3;\n', '            \n', '        if(address(this).balance > 10 ether)\n', '            return 4;\n', '        \n', '        return 5;\n', '    }\n', '}']
