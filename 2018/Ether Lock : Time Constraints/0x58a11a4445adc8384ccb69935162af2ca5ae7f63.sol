['pragma solidity ^0.4.23;\n', '\n', 'contract Ethervote {\n', '    \n', '    address feeRecieverOne = 0xa03F27587883135DA9565e7EfB523e1657A47a07;\n', '    address feeRecieverTwo = 0x549377418b1b7030381de9aA1319E41C044467c7;\n', '\n', '    address[] playerAddresses;\n', '    \n', '    uint public expiryBlock;\n', '    \n', '    uint public leftSharePrice = 10 finney;\n', '    uint public rightSharePrice = 10 finney;\n', '    \n', '    uint public leftSharePriceRateOfIncrease = 1 finney;\n', '    uint public rightSharePriceRateOfIncrease = 1 finney;\n', '    \n', '    uint public leftVotes = 0;\n', '    uint public rightVotes = 0;\n', '    \n', '    uint public thePot = 0 wei;\n', '    \n', '    bool public betIsSettled = false;\n', '\n', '    struct Player {\n', '        uint leftShares;\n', '        uint rightShares;\n', '        uint excessEther;\n', '        bool hasBetBefore;\n', '    }\n', '    \n', '    mapping(address => Player) players;\n', '    \n', '    \n', '    constructor() public {\n', '        expiryBlock = block.number + 17500;\n', '    }\n', '    \n', '    function bet(bool bettingLeft) public payable {\n', '        \n', '        require(block.number < expiryBlock);\n', '        \n', '        if(!players[msg.sender].hasBetBefore){\n', '            playerAddresses.push(msg.sender);\n', '            players[msg.sender].hasBetBefore = true;\n', '        }\n', '            \n', '            uint amountSent = msg.value;\n', '            \n', '            if(bettingLeft){\n', '                require(amountSent >= leftSharePrice);\n', '                \n', '                while(amountSent >= leftSharePrice){\n', '                    players[msg.sender].leftShares++;\n', '                    leftVotes++;\n', '                    thePot += leftSharePrice;\n', '                    amountSent -= leftSharePrice;\n', '                    \n', '                    if((leftVotes % 15) == 0){//if the number of left votes is a multiple of 15\n', '                        leftSharePrice += leftSharePriceRateOfIncrease;\n', '                        if(leftVotes <= 45){//increase the rate at first, then decrease it to zero.\n', '                            leftSharePriceRateOfIncrease += 1 finney;\n', '                        }else if(leftVotes > 45){\n', '                            if(leftSharePriceRateOfIncrease > 1 finney){\n', '                                leftSharePriceRateOfIncrease -= 1 finney;\n', '                            }else if(leftSharePriceRateOfIncrease <= 1 finney){\n', '                                leftSharePriceRateOfIncrease = 0 finney;\n', '                            }\n', '                        }\n', '                    }\n', '                    \n', '                }\n', '                if(amountSent > 0){\n', '                    players[msg.sender].excessEther += amountSent;\n', '                }\n', '                \n', '            }\n', '            else{//betting for the right option\n', '                require(amountSent >= rightSharePrice);\n', '                \n', '                while(amountSent >= rightSharePrice){\n', '                    players[msg.sender].rightShares++;\n', '                    rightVotes++;\n', '                    thePot += rightSharePrice;\n', '                    amountSent -= rightSharePrice;\n', '                    \n', '                    if((rightVotes % 15) == 0){//if the number of right votes is a multiple of 15\n', '                        rightSharePrice += rightSharePriceRateOfIncrease;\n', '                        if(rightVotes <= 45){//increase the rate at first, then decrease it to zero.\n', '                            rightSharePriceRateOfIncrease += 1 finney;\n', '                        }else if(rightVotes > 45){\n', '                            if(rightSharePriceRateOfIncrease > 1 finney){\n', '                                rightSharePriceRateOfIncrease -= 1 finney;\n', '                            }else if(rightSharePriceRateOfIncrease <= 1 finney){\n', '                                rightSharePriceRateOfIncrease = 0 finney;\n', '                            }\n', '                        }\n', '                    }\n', '                    \n', '                }\n', '                if(amountSent > 0){\n', '                    if(msg.sender.send(amountSent) == false)players[msg.sender].excessEther += amountSent;\n', '                }\n', '            }\n', '    }\n', '    \n', '    \n', '    function settleBet() public {\n', '        require(block.number >= expiryBlock);\n', '        require(betIsSettled == false);\n', '\n', '        uint winRewardOne = thePot * 2;\n', '        winRewardOne = winRewardOne / 20;\n', '        if(feeRecieverOne.send(winRewardOne) == false) players[feeRecieverOne].excessEther = winRewardOne;//in case the tx fails, the excess ether function lets you withdraw it manually\n', '\n', '        uint winRewardTwo = thePot * 1;\n', '        winRewardTwo = winRewardTwo / 20;\n', '        if(feeRecieverTwo.send(winRewardTwo) == false) players[feeRecieverTwo].excessEther = winRewardTwo;\n', '\n', '        uint winReward = thePot * 17;\n', '        winReward = winReward / 20;\n', '        \n', '        if(leftVotes > rightVotes){\n', '            winReward = winReward / leftVotes;\n', '            for(uint i=0;i<playerAddresses.length;i++){\n', '                if(players[playerAddresses[i]].leftShares > 0){\n', '                    if(playerAddresses[i].send(players[playerAddresses[i]].leftShares * winReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[i]].excessEther = players[playerAddresses[i]].leftShares * winReward;\n', '                    }\n', '                }\n', '            }\n', '        }else if(rightVotes > leftVotes){\n', '            winReward = winReward / rightVotes;\n', '            for(uint u=0;u<playerAddresses.length;u++){\n', '                if(players[playerAddresses[u]].rightShares > 0){\n', '                    if(playerAddresses[u].send(players[playerAddresses[u]].rightShares * winReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[u]].excessEther = players[playerAddresses[u]].rightShares * winReward;\n', '                    }\n', '                }\n', '            }\n', '        }else if(rightVotes == leftVotes){//split it in a tie\n', '            uint rightWinReward = (winReward / rightVotes) / 2;\n', '            for(uint q=0;q<playerAddresses.length;q++){\n', '                if(players[playerAddresses[q]].rightShares > 0){\n', '                    if(playerAddresses[q].send(players[playerAddresses[q]].rightShares * rightWinReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[q]].excessEther = players[playerAddresses[q]].rightShares * rightWinReward;\n', '                    }\n', '                }\n', '            }\n', '\n', '            uint leftWinReward = winReward / leftVotes;\n', '            for(uint l=0;l<playerAddresses.length;l++){\n', '                if(players[playerAddresses[l]].leftShares > 0){\n', '                    if(playerAddresses[l].send(players[playerAddresses[l]].leftShares * leftWinReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[l]].excessEther = players[playerAddresses[l]].leftShares * leftWinReward;\n', '                    }\n', '                }\n', '            }\n', '\n', '        }\n', '\n', '        betIsSettled = true;\n', '    }\n', '    \n', '    \n', '    function retrieveExcessEther() public {\n', '        assert(players[msg.sender].excessEther > 0);\n', '        if(msg.sender.send(players[msg.sender].excessEther)){\n', '            players[msg.sender].excessEther = 0;\n', '        }\n', '    }\n', '    \n', '    function viewMyShares(bool left) public view returns(uint){\n', '        if(left)return players[msg.sender].leftShares;\n', '        return players[msg.sender].rightShares;\n', '    }\n', '}']
['pragma solidity ^0.4.23;\n', '\n', 'contract Ethervote {\n', '    \n', '    address feeRecieverOne = 0xa03F27587883135DA9565e7EfB523e1657A47a07;\n', '    address feeRecieverTwo = 0x549377418b1b7030381de9aA1319E41C044467c7;\n', '\n', '    address[] playerAddresses;\n', '    \n', '    uint public expiryBlock;\n', '    \n', '    uint public leftSharePrice = 10 finney;\n', '    uint public rightSharePrice = 10 finney;\n', '    \n', '    uint public leftSharePriceRateOfIncrease = 1 finney;\n', '    uint public rightSharePriceRateOfIncrease = 1 finney;\n', '    \n', '    uint public leftVotes = 0;\n', '    uint public rightVotes = 0;\n', '    \n', '    uint public thePot = 0 wei;\n', '    \n', '    bool public betIsSettled = false;\n', '\n', '    struct Player {\n', '        uint leftShares;\n', '        uint rightShares;\n', '        uint excessEther;\n', '        bool hasBetBefore;\n', '    }\n', '    \n', '    mapping(address => Player) players;\n', '    \n', '    \n', '    constructor() public {\n', '        expiryBlock = block.number + 17500;\n', '    }\n', '    \n', '    function bet(bool bettingLeft) public payable {\n', '        \n', '        require(block.number < expiryBlock);\n', '        \n', '        if(!players[msg.sender].hasBetBefore){\n', '            playerAddresses.push(msg.sender);\n', '            players[msg.sender].hasBetBefore = true;\n', '        }\n', '            \n', '            uint amountSent = msg.value;\n', '            \n', '            if(bettingLeft){\n', '                require(amountSent >= leftSharePrice);\n', '                \n', '                while(amountSent >= leftSharePrice){\n', '                    players[msg.sender].leftShares++;\n', '                    leftVotes++;\n', '                    thePot += leftSharePrice;\n', '                    amountSent -= leftSharePrice;\n', '                    \n', '                    if((leftVotes % 15) == 0){//if the number of left votes is a multiple of 15\n', '                        leftSharePrice += leftSharePriceRateOfIncrease;\n', '                        if(leftVotes <= 45){//increase the rate at first, then decrease it to zero.\n', '                            leftSharePriceRateOfIncrease += 1 finney;\n', '                        }else if(leftVotes > 45){\n', '                            if(leftSharePriceRateOfIncrease > 1 finney){\n', '                                leftSharePriceRateOfIncrease -= 1 finney;\n', '                            }else if(leftSharePriceRateOfIncrease <= 1 finney){\n', '                                leftSharePriceRateOfIncrease = 0 finney;\n', '                            }\n', '                        }\n', '                    }\n', '                    \n', '                }\n', '                if(amountSent > 0){\n', '                    players[msg.sender].excessEther += amountSent;\n', '                }\n', '                \n', '            }\n', '            else{//betting for the right option\n', '                require(amountSent >= rightSharePrice);\n', '                \n', '                while(amountSent >= rightSharePrice){\n', '                    players[msg.sender].rightShares++;\n', '                    rightVotes++;\n', '                    thePot += rightSharePrice;\n', '                    amountSent -= rightSharePrice;\n', '                    \n', '                    if((rightVotes % 15) == 0){//if the number of right votes is a multiple of 15\n', '                        rightSharePrice += rightSharePriceRateOfIncrease;\n', '                        if(rightVotes <= 45){//increase the rate at first, then decrease it to zero.\n', '                            rightSharePriceRateOfIncrease += 1 finney;\n', '                        }else if(rightVotes > 45){\n', '                            if(rightSharePriceRateOfIncrease > 1 finney){\n', '                                rightSharePriceRateOfIncrease -= 1 finney;\n', '                            }else if(rightSharePriceRateOfIncrease <= 1 finney){\n', '                                rightSharePriceRateOfIncrease = 0 finney;\n', '                            }\n', '                        }\n', '                    }\n', '                    \n', '                }\n', '                if(amountSent > 0){\n', '                    if(msg.sender.send(amountSent) == false)players[msg.sender].excessEther += amountSent;\n', '                }\n', '            }\n', '    }\n', '    \n', '    \n', '    function settleBet() public {\n', '        require(block.number >= expiryBlock);\n', '        require(betIsSettled == false);\n', '\n', '        uint winRewardOne = thePot * 2;\n', '        winRewardOne = winRewardOne / 20;\n', '        if(feeRecieverOne.send(winRewardOne) == false) players[feeRecieverOne].excessEther = winRewardOne;//in case the tx fails, the excess ether function lets you withdraw it manually\n', '\n', '        uint winRewardTwo = thePot * 1;\n', '        winRewardTwo = winRewardTwo / 20;\n', '        if(feeRecieverTwo.send(winRewardTwo) == false) players[feeRecieverTwo].excessEther = winRewardTwo;\n', '\n', '        uint winReward = thePot * 17;\n', '        winReward = winReward / 20;\n', '        \n', '        if(leftVotes > rightVotes){\n', '            winReward = winReward / leftVotes;\n', '            for(uint i=0;i<playerAddresses.length;i++){\n', '                if(players[playerAddresses[i]].leftShares > 0){\n', '                    if(playerAddresses[i].send(players[playerAddresses[i]].leftShares * winReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[i]].excessEther = players[playerAddresses[i]].leftShares * winReward;\n', '                    }\n', '                }\n', '            }\n', '        }else if(rightVotes > leftVotes){\n', '            winReward = winReward / rightVotes;\n', '            for(uint u=0;u<playerAddresses.length;u++){\n', '                if(players[playerAddresses[u]].rightShares > 0){\n', '                    if(playerAddresses[u].send(players[playerAddresses[u]].rightShares * winReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[u]].excessEther = players[playerAddresses[u]].rightShares * winReward;\n', '                    }\n', '                }\n', '            }\n', '        }else if(rightVotes == leftVotes){//split it in a tie\n', '            uint rightWinReward = (winReward / rightVotes) / 2;\n', '            for(uint q=0;q<playerAddresses.length;q++){\n', '                if(players[playerAddresses[q]].rightShares > 0){\n', '                    if(playerAddresses[q].send(players[playerAddresses[q]].rightShares * rightWinReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[q]].excessEther = players[playerAddresses[q]].rightShares * rightWinReward;\n', '                    }\n', '                }\n', '            }\n', '\n', '            uint leftWinReward = winReward / leftVotes;\n', '            for(uint l=0;l<playerAddresses.length;l++){\n', '                if(players[playerAddresses[l]].leftShares > 0){\n', '                    if(playerAddresses[l].send(players[playerAddresses[l]].leftShares * leftWinReward) == false){\n', '                        //if the send fails\n', '                        players[playerAddresses[l]].excessEther = players[playerAddresses[l]].leftShares * leftWinReward;\n', '                    }\n', '                }\n', '            }\n', '\n', '        }\n', '\n', '        betIsSettled = true;\n', '    }\n', '    \n', '    \n', '    function retrieveExcessEther() public {\n', '        assert(players[msg.sender].excessEther > 0);\n', '        if(msg.sender.send(players[msg.sender].excessEther)){\n', '            players[msg.sender].excessEther = 0;\n', '        }\n', '    }\n', '    \n', '    function viewMyShares(bool left) public view returns(uint){\n', '        if(left)return players[msg.sender].leftShares;\n', '        return players[msg.sender].rightShares;\n', '    }\n', '}']
