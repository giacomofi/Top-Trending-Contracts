['pragma solidity ^0.4.18;\n', '\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '\n', '    struct inr {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '\n', '      function tokenFallback(address _from, uint _value, bytes _data){\n', '      inr memory igniter;\n', '      igniter.sender = _from;\n', '      igniter.value = _value;\n', '      igniter.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      igniter.sig = bytes4(u);\n', '\n', '    }\n', '}\n', '\n', 'contract iGniter is SafeMath {\n', '\n', '  struct serPayment {\n', '    uint unlockedTime;\n', '    uint256 unlockedBlockNumber;\n', '  }\n', '\n', '    string public name;\n', '    bytes32 public symbol;\n', '    uint8 public decimals;\n', '    uint256 public rewardPerBlockPerAddress;\n', '    uint256 public totalInitialAddresses;\n', '    uint256 public initialBlockCount;\n', '    uint256 private minedBlocks;\n', '    uint256 private iGniting;\n', '    uint256 private initialSupplyPerAddress;\n', '    uint256 private totalMaxAvailableAmount;\n', '    uint256 private availableAmount;\n', '    uint256 private burnt;\n', '    uint256 public inrSessions;\n', '    uint256 private availableBalance;\n', '    uint256 private balanceOfAddress;\n', '    uint256 private initialSupply;\n', '    uint256 private _totalSupply;\n', '    uint256 public currentCost;\n', '    uint256 private startBounty;\n', '    uint256 private finishBounty;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => uint) balances;\n', '    mapping(address => bool) public initialAddress;\n', '    mapping(address => bool) public bountyAddress;\n', '    mapping (address => mapping (address => uint)) internal _allowances;\n', '    mapping (address => serPayment) ignPayments;\n', '    address private _owner;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event LogBurn(address indexed owner, uint indexed value);\n', '\n', '    modifier isOwner() {\n', '\n', '      require(msg.sender == _owner);\n', '      _;\n', '    }\n', '\n', '    function iGniter() {\n', '\n', '        initialSupplyPerAddress = 10000000000; //10000\n', '        initialBlockCount = 4948670;\n', '        rewardPerBlockPerAddress = 7;\n', '        totalInitialAddresses = 5000;\n', '        initialSupply = initialSupplyPerAddress * totalInitialAddresses;\n', '       _owner = msg.sender;\n', '\n', '    }\n', '\n', '    function currentBlock() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number;\n', '    }\n', '\n', '    function blockDiff() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number - initialBlockCount;\n', '    }\n', '\n', '    function assignInitialAddresses(address[] _address) isOwner public returns (bool success)\n', '    {\n', '        if (block.number <= 7000000)\n', '        {\n', '          for (uint i = 0; i < _address.length; i++)\n', '          {\n', '            balanceOf[_address[i]] = initialSupplyPerAddress;\n', '            initialAddress[_address[i]] = true;\n', '          }\n', '\n', '          return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function assignBountyAddresses(address[] _address) isOwner public returns (bool success)\n', '    {\n', '      startBounty = 2500000000;\n', '\n', '        if (block.number <= 7000000)\n', '        {\n', '          for (uint i = 0; i < _address.length; i++)\n', '          {\n', '            balanceOf[_address[i]] = startBounty;\n', '            initialAddress[_address[i]] = true;\n', '          }\n', '\n', '          return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function completeBountyAddresses(address[] _address) isOwner public returns (bool success)\n', '    {\n', '      finishBounty = 7500000000;\n', '\n', '        if (block.number <= 7000000)\n', '        {\n', '          for (uint i = 0; i < _address.length; i++)\n', '          {\n', '            balanceOf[_address[i]] = balanceOf[_address[i]] + finishBounty;\n', '            initialAddress[_address[i]] = true;\n', '          }\n', '\n', '          return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _address) constant returns (uint256 Balance)\n', '    {\n', '        if ((initialAddress[_address])) {\n', '            minedBlocks = block.number - initialBlockCount;\n', '\n', '            if (minedBlocks >= 105120000) return balanceOf[_address]; //app. 2058\n', '\n', '            availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '            availableBalance = balanceOf[_address] + availableAmount;\n', '\n', '            return availableBalance;\n', '        }\n', '        else\n', '            return balanceOf[_address];\n', '    }\n', '\n', '    function name() constant returns (string _name)\n', '    {\n', '        name = "iGniter";\n', '        return name;\n', '    }\n', '\n', '    function symbol() constant returns (bytes32 _symbol)\n', '    {\n', '        symbol = "INR";\n', '        return symbol;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 _decimals)\n', '    {\n', '        decimals = 6;\n', '        return decimals;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply)\n', '    {\n', '        minedBlocks = block.number - initialBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        iGniting = availableAmount * totalInitialAddresses;\n', '        return iGniting + initialSupply - burnt;\n', '    }\n', '\n', '    function minedTotalSupply() constant returns (uint256 minedBlocks)\n', '    {\n', '        minedBlocks = block.number - initialBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        return availableAmount * totalInitialAddresses;\n', '    }\n', '\n', '    function initialiGnSupply() constant returns (uint256 maxSupply)\n', '    {\n', '        return initialSupplyPerAddress * totalInitialAddresses;\n', '    }\n', '\n', '    //burn tokens\n', '    function burn(uint256 _value) public returns(bool success) {\n', '\n', '        //get sum\n', '        minedBlocks = block.number - initialBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        iGniting = availableAmount * totalInitialAddresses;\n', '        _totalSupply = iGniting + initialSupply;\n', '\n', '        //burn time\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        burnt += _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && !isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            Transfer(msg.sender, _to, _value, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isContract(address _addr) returns (bool) {\n', '        uint codeSize;\n', '        assembly {\n', '            codeSize := extcodesize(_addr)\n', '        }\n', '        return codeSize > 0;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_allowances[_from][msg.sender] > 0 && _value > 0 && _allowances[_from][msg.sender] >= _value &&\n', '            balanceOf[_from] >= _value) {\n', '            balanceOf[_from] -= _value;\n', '            balanceOf[_to] += _value;\n', '            _allowances[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        _allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return _allowances[_owner][_spender];\n', '    }\n', '\n', '    function PaymentStatusBlockNum(address _address) constant returns (uint256 bn) {\n', '\n', '      return ignPayments[_address].unlockedBlockNumber;\n', '    }\n', '\n', '    function PaymentStatusTimeStamp(address _address) constant returns (uint256 ut) {\n', '\n', '      return ignPayments[_address].unlockedTime;\n', '    }\n', '\n', '    function updateCost(uint256 _currCost) isOwner public returns (uint256 currCost) {\n', '\n', '      currentCost = _currCost;\n', '\n', '      return currentCost;\n', '    }\n', '\n', '    function servicePayment(uint _value) public returns (bool, uint256, uint256) {\n', '\n', '      require(_value >= currentCost);\n', '      require(balanceOf[msg.sender] >= currentCost);\n', '\n', '      //either option available\n', '      ignPayments[msg.sender].unlockedTime = block.timestamp;\n', '      ignPayments[msg.sender].unlockedBlockNumber = block.number;\n', '\n', '      inrSessions++;\n', '\n', '      //burn\n', '      balanceOf[msg.sender] -= _value;\n', '      burnt += _value;\n', '      Burn(msg.sender, _value);\n', '\n', '      return (true, ignPayments[msg.sender].unlockedTime, ignPayments[msg.sender].unlockedBlockNumber);\n', '    }\n', '}']