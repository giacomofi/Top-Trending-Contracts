['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/MigrationTarget.sol\n', '\n', '//\n', '// Migration target\n', '// @dev Implement this interface to make migration target\n', '//\n', 'contract MigrationTarget {\n', '  function migrateFrom(address _from, uint256 _amount, uint256 _rewards, uint256 _trueBuy, bool _devStatus) public;\n', '}\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  // Event\n', '  event OwnershipChanged(address indexed oldOwner, address indexed newOwner);\n', '\n', '  // Modifier\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipChanged(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC20.sol\n', '\n', 'contract ERC20 {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address _owner) view public returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/StandardToken.sol\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is ERC20 {\n', '  /**\n', '   * Internal transfer, only can be called by this contract\n', '   */\n', '  function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '    // Prevent transfer to 0x0 address. Use burn() instead\n', '    require(_to != address(0));\n', '    // Check if the sender has enough\n', '    require(balances[_from] >= _value);\n', '    // Check for overflows\n', '    require(balances[_to] + _value > balances[_to]);\n', '    // Save this for an assertion in the future\n', '    uint256 previousBalances = balances[_from] + balances[_to];\n', '    // Subtract from the sender\n', '    balances[_from] -= _value;\n', '    // Add the same to the recipient\n', '    balances[_to] += _value;\n', '    emit Transfer(_from, _to, _value);\n', '    // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '    assert(balances[_from] + balances[_to] == previousBalances);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens\n', '   *\n', '   * Send `_value` tokens to `_to` from your account\n', '   *\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    return _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from other address\n', '   *\n', '   * Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    allowed[_from][msg.sender] -= _value;\n', '    return _transfer(_from, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) view public returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * Set allowance for other address\n', '   *\n', '   * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '   *\n', '   * @param _spender The address authorized to spend\n', '   * @param _value the max amount they can spend\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  mapping (address => uint256) public balances;\n', '  mapping (address => mapping (address => uint256)) public allowed;\n', '}\n', '\n', '// File: contracts/RoyaltyToken.sol\n', '\n', '/*  Royalty token */\n', 'contract RoyaltyToken is StandardToken {\n', '  using SafeMath for uint256;\n', '  // restricted addresses\t\n', '  mapping(address => bool) public restrictedAddresses;\n', '  \n', '  event RestrictedStatusChanged(address indexed _address, bool status);\n', '\n', '  struct Account {\n', '    uint256 balance;\n', '    uint256 lastRoyaltyPoint;\n', '  }\n', '\n', '  mapping(address => Account) public accounts;\n', '  uint256 public totalRoyalty;\n', '  uint256 public unclaimedRoyalty;\n', '\n', '  /**\n', '   * Get Royalty amount for given account\n', '   *\n', '   * @param account The address for Royalty account\n', '   */\n', '  function RoyaltysOwing(address account) public view returns (uint256) {\n', '    uint256 newRoyalty = totalRoyalty.sub(accounts[account].lastRoyaltyPoint);\n', '    return balances[account].mul(newRoyalty).div(totalSupply);\n', '  }\n', '\n', '  /**\n', '   * @dev Update account for Royalty\n', '   * @param account The address of owner\n', '   */\n', '  function updateAccount(address account) internal {\n', '    uint256 owing = RoyaltysOwing(account);\n', '    accounts[account].lastRoyaltyPoint = totalRoyalty;\n', '    if (owing > 0) {\n', '      unclaimedRoyalty = unclaimedRoyalty.sub(owing);\n', '      accounts[account].balance = accounts[account].balance.add(owing);\n', '    }\n', '  }\n', '\n', '  function disburse() public payable {\n', '    require(totalSupply > 0);\n', '    require(msg.value > 0);\n', '\n', '    uint256 newRoyalty = msg.value;\n', '    totalRoyalty = totalRoyalty.add(newRoyalty);\n', '    unclaimedRoyalty = unclaimedRoyalty.add(newRoyalty);\n', '  }\n', '\n', '  /**\n', '   * @dev Send `_value` tokens to `_to` from your account\n', '   *\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    // Require that the sender is not restricted\n', '    require(restrictedAddresses[msg.sender] == false);\n', '    updateAccount(_to);\n', '    updateAccount(msg.sender);\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from other address. Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  ) public returns (bool success) {\n', '    updateAccount(_to);\n', '    updateAccount(_from);\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function withdrawRoyalty() public {\n', '    updateAccount(msg.sender);\n', '\n', '    // retrieve Royalty amount\n', '    uint256 RoyaltyAmount = accounts[msg.sender].balance;\n', '    require(RoyaltyAmount > 0);\n', '    accounts[msg.sender].balance = 0;\n', '\n', '    // transfer Royalty amount\n', '    msg.sender.transfer(RoyaltyAmount);\n', '  }\n', '}\n', '\n', '// File: contracts/Q2.sol\n', '\n', 'contract Q2 is Ownable, RoyaltyToken {\n', '  using SafeMath for uint256;\n', '\n', '  string public name = "Q2";\n', '  string public symbol = "Q2";\n', '  uint8 public decimals = 18;\n', '\n', '  bool public whitelist = true;\n', '\n', '  // whitelist addresses\n', '  mapping(address => bool) public whitelistedAddresses;\n', '\n', '  // token creation cap\n', '  uint256 public creationCap = 15000000 * (10 ** 18); // 15M\n', '  uint256 public reservedFund = 10000000 * (10 ** 18); // 10M\n', '\n', '  // stage info\n', '  struct Stage {\n', '    uint8 number;\n', '    uint256 exchangeRate;\n', '    uint256 startBlock;\n', '    uint256 endBlock;\n', '    uint256 cap;\n', '  }\n', '\n', '  // events\n', '  event MintTokens(address indexed _to, uint256 _value);\n', '  event StageStarted(uint8 _stage, uint256 _totalSupply, uint256 _balance);\n', '  event StageEnded(uint8 _stage, uint256 _totalSupply, uint256 _balance);\n', '  event WhitelistStatusChanged(address indexed _address, bool status);\n', '  event WhitelistChanged(bool status);\n', '\n', '  // eth wallet\n', '  address public ethWallet;\n', '  mapping (uint8 => Stage) stages;\n', '\n', '  // current state info\n', '  uint8 public currentStage;\n', '\n', '  function Q2(address _ethWallet) public {\n', '    ethWallet = _ethWallet;\n', '\n', '    // reserved tokens\n', '    mintTokens(ethWallet, reservedFund);\n', '  }\n', '\n', '  function mintTokens(address to, uint256 value) internal {\n', '    require(value > 0);\n', '    balances[to] = balances[to].add(value);\n', '    totalSupply = totalSupply.add(value);\n', '    require(totalSupply <= creationCap);\n', '\n', '    // broadcast event\n', '    emit MintTokens(to, value);\n', '  }\n', '\n', '  function () public payable {\n', '    buyTokens();\n', '  }\n', '\n', '  function buyTokens() public payable {\n', '    require(whitelist==false || whitelistedAddresses[msg.sender] == true);\n', '    require(msg.value > 0);\n', '\n', '    Stage memory stage = stages[currentStage];\n', '    require(block.number >= stage.startBlock && block.number <= stage.endBlock);\n', '\n', '    uint256 tokens = msg.value * stage.exchangeRate;\n', '    require(totalSupply.add(tokens) <= stage.cap);\n', '\n', '    mintTokens(msg.sender, tokens);\n', '  }\n', '\n', '  function startStage(\n', '    uint256 _exchangeRate,\n', '    uint256 _cap,\n', '    uint256 _startBlock,\n', '    uint256 _endBlock\n', '  ) public onlyOwner {\n', '    require(_exchangeRate > 0 && _cap > 0);\n', '    require(_startBlock > block.number);\n', '    require(_startBlock < _endBlock);\n', '\n', '    // stop current stage if it&#39;s running\n', '    Stage memory currentObj = stages[currentStage];\n', '    if (currentObj.endBlock > 0) {\n', '      // broadcast stage end event\n', '      emit StageEnded(currentStage, totalSupply, address(this).balance);\n', '    }\n', '\n', '    // increment current stage\n', '    currentStage = currentStage + 1;\n', '\n', '    // create new stage object\n', '    Stage memory s = Stage({\n', '      number: currentStage,\n', '      startBlock: _startBlock,\n', '      endBlock: _endBlock,\n', '      exchangeRate: _exchangeRate,\n', '      cap: _cap + totalSupply\n', '    });\n', '    stages[currentStage] = s;\n', '\n', '    // broadcast stage started event\n', '    emit StageStarted(currentStage, totalSupply, address(this).balance);\n', '  }\n', '\n', '  function withdraw() public onlyOwner {\n', '    ethWallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function getCurrentStage() view public returns (\n', '    uint8 number,\n', '    uint256 exchangeRate,\n', '    uint256 startBlock,\n', '    uint256 endBlock,\n', '    uint256 cap\n', '  ) {\n', '    Stage memory currentObj = stages[currentStage];\n', '    number = currentObj.number;\n', '    exchangeRate = currentObj.exchangeRate;\n', '    startBlock = currentObj.startBlock;\n', '    endBlock = currentObj.endBlock;\n', '    cap = currentObj.cap;\n', '  }\n', '\n', '  function changeWhitelistStatus(address _address, bool status) public onlyOwner {\n', '    whitelistedAddresses[_address] = status;\n', '    emit WhitelistStatusChanged(_address, status);\n', '  }\n', '\n', '  function changeRestrictedtStatus(address _address, bool status) public onlyOwner {\n', '    restrictedAddresses[_address] = status;\n', '    emit RestrictedStatusChanged(_address, status);\n', '  }\n', '  \n', '  function changeWhitelist(bool status) public onlyOwner {\n', '     whitelist = status;\n', '     emit WhitelistChanged(status);\n', '  }\n', '}\n', '\n', '// File: contracts/Quarters.sol\n', '\n', 'interface TokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract Quarters is Ownable, StandardToken {\n', '  // Public variables of the token\n', '  string public name = "Quarters";\n', '  string public symbol = "Q";\n', '  uint8 public decimals = 0; // no decimals, only integer quarters\n', '\n', '  uint16 public ethRate = 4000; // Quarters/ETH\n', '  uint256 public tranche = 40000; // Number of Quarters in initial tranche\n', '\n', '  // List of developers\n', '  // address -> status\n', '  mapping (address => bool) public developers;\n', '\n', '  uint256 public outstandingQuarters;\n', '  address public q2;\n', '\n', '  // number of Quarters for next tranche\n', '  uint8 public trancheNumerator = 2;\n', '  uint8 public trancheDenominator = 1;\n', '\n', '  // initial multiples, rates (as percentages) for tiers of developers\n', '  uint32 public mega = 20;\n', '  uint32 public megaRate = 115;\n', '  uint32 public large = 100;\n', '  uint32 public largeRate = 90;\n', '  uint32 public medium = 2000;\n', '  uint32 public mediumRate = 75;\n', '  uint32 public small = 50000;\n', '  uint32 public smallRate = 50;\n', '  uint32 public microRate = 25;\n', '\n', '  // rewards related storage\n', '  mapping (address => uint256) public rewards;    // rewards earned, but not yet collected\n', '  mapping (address => uint256) public trueBuy;    // tranche rewards are set based on *actual* purchases of Quarters\n', '\n', '  uint256 public rewardAmount = 40;\n', '\n', '  uint8 public rewardNumerator = 1;\n', '  uint8 public rewardDenominator = 4;\n', '\n', '  // reserve ETH from Q2 to fund rewards\n', '  uint256 public reserveETH=0;\n', '\n', '  // ETH rate changed\n', '  event EthRateChanged(uint16 currentRate, uint16 newRate);\n', '\n', '  // This notifies clients about the amount burnt\n', '  event Burn(address indexed from, uint256 value);\n', '\n', '  event QuartersOrdered(address indexed sender, uint256 ethValue, uint256 tokens);\n', '  event DeveloperStatusChanged(address indexed developer, bool status);\n', '  event TrancheIncreased(uint256 _tranche, uint256 _etherPool, uint256 _outstandingQuarters);\n', '  event MegaEarnings(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\n', '  event Withdraw(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\n', '  event BaseRateChanged(uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool,  uint256 _totalSupply);\n', '  event Reward(address indexed _address, uint256 value, uint256 _outstandingQuarters, uint256 _totalSupply);\n', '\n', '  /**\n', '   * developer modifier\n', '   */\n', '  modifier onlyActiveDeveloper() {\n', '    require(developers[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Constructor function\n', '   *\n', '   * Initializes contract with initial supply tokens to the owner of the contract\n', '   */\n', '  function Quarters(\n', '    address _q2,\n', '    uint256 firstTranche\n', '  ) public {\n', '    q2 = _q2;\n', '    tranche = firstTranche; // number of Quarters to be sold before increasing price\n', '  }\n', '\n', '  function setEthRate (uint16 rate) onlyOwner public {\n', '    // Ether price is set in Wei\n', '    require(rate > 0);\n', '    ethRate = rate;\n', '    emit EthRateChanged(ethRate, rate);\n', '  }\n', '\n', '  /**\n', '   * Adjust reward amount\n', '   */\n', '  function adjustReward (uint256 reward) onlyOwner public {\n', '    rewardAmount = reward; // may be zero, no need to check value to 0\n', '  }\n', '\n', '  function adjustWithdrawRate(uint32 mega2, uint32 megaRate2, uint32 large2, uint32 largeRate2, uint32 medium2, uint32 mediumRate2, uint32 small2, uint32 smallRate2, uint32 microRate2) onlyOwner public {\n', '    // the values (mega, large, medium, small) are multiples, e.g., 20x, 100x, 10000x\n', '    // the rates (megaRate, etc.) are percentage points, e.g., 150 is 150% of the remaining etherPool\n', '    if (mega2 > 0 && megaRate2 > 0) {\n', '      mega = mega2;\n', '      megaRate = megaRate2;\n', '    }\n', '\n', '    if (large2 > 0 && largeRate2 > 0) {\n', '      large = large2;\n', '      largeRate = largeRate2;\n', '    }\n', '\n', '    if (medium2 > 0 && mediumRate2 > 0) {\n', '      medium = medium2;\n', '      mediumRate = mediumRate2;\n', '    }\n', '\n', '    if (small2 > 0 && smallRate2 > 0){\n', '      small = small2;\n', '      smallRate = smallRate2;\n', '    }\n', '\n', '    if (microRate2 > 0) {\n', '      microRate = microRate2;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * adjust tranche for next cycle\n', '   */\n', '  function adjustNextTranche (uint8 numerator, uint8 denominator) onlyOwner public {\n', '    require(numerator > 0 && denominator > 0);\n', '    trancheNumerator = numerator;\n', '    trancheDenominator = denominator;\n', '  }\n', '\n', '  function adjustTranche(uint256 tranche2) onlyOwner public {\n', '    require(tranche2 > 0);\n', '    tranche = tranche2;\n', '  }\n', '\n', '  /**\n', '   * Adjust rewards for `_address`\n', '   */\n', '  function updatePlayerRewards(address _address) internal {\n', '    require(_address != address(0));\n', '\n', '    uint256 _reward = 0;\n', '    if (rewards[_address] == 0) {\n', '      _reward = rewardAmount;\n', '    } else if (rewards[_address] < tranche) {\n', '      _reward = trueBuy[_address] * rewardNumerator / rewardDenominator;\n', '    }\n', '\n', '    if (_reward > 0) {\n', '      // update rewards record\n', '      rewards[_address] = tranche;\n', '\n', '      balances[_address] += _reward;\n', '      allowed[_address][msg.sender] += _reward; // set allowance\n', '\n', '      totalSupply += _reward;\n', '      outstandingQuarters += _reward;\n', '\n', '      uint256 spentETH = (_reward * (10 ** 18)) / ethRate;\n', '      if (reserveETH >= spentETH) {\n', '          reserveETH -= spentETH;\n', '        } else {\n', '          reserveETH = 0;\n', '        }\n', '\n', '      // tranche size change\n', '      _changeTrancheIfNeeded();\n', '\n', '      emit Approval(_address, msg.sender, _reward);\n', '      emit Reward(_address, _reward, outstandingQuarters, totalSupply);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Developer status\n', '   */\n', '  function setDeveloperStatus (address _address, bool status) onlyOwner public {\n', '    developers[_address] = status;\n', '    emit DeveloperStatusChanged(_address, status);\n', '  }\n', '\n', '  /**\n', '   * Set allowance for other address and notify\n', '   *\n', '   * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '   *\n', '   * @param _spender The address authorized to spend\n', '   * @param _value the max amount they can spend\n', '   * @param _extraData some extra information to send to the approved contract\n', '   */\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '  public\n', '  returns (bool success) {\n', '    TokenRecipient spender = TokenRecipient(_spender);\n', '    if (approve(_spender, _value)) {\n', '      spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '      return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * Destroy tokens\n', '   *\n', '   * Remove `_value` tokens from the system irreversibly\n', '   *\n', '   * @param _value the amount of money to burn\n', '   */\n', '  function burn(uint256 _value) public returns (bool success) {\n', '    require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '    balances[msg.sender] -= _value;            // Subtract from the sender\n', '    totalSupply -= _value;                     // Updates totalSupply\n', '    outstandingQuarters -= _value;              // Update outstanding quarters\n', '    emit Burn(msg.sender, _value);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Destroy tokens from other account\n', '   *\n', '   * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '   *\n', '   * @param _from the address of the sender\n', '   * @param _value the amount of money to burn\n', '   */\n', '  function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '    require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    balances[_from] -= _value;                         // Subtract from the targeted balance\n', '    allowed[_from][msg.sender] -= _value;              // Subtract from the sender&#39;s allowance\n', '    totalSupply -= _value;                      // Update totalSupply\n', '    outstandingQuarters -= _value;              // Update outstanding quarters\n', '    emit Burn(_from, _value);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Buy quarters by sending ethers to contract address (no data required)\n', '   */\n', '  function () payable public {\n', '    _buy(msg.sender);\n', '  }\n', '\n', '\n', '  function buy() payable public {\n', '    _buy(msg.sender);\n', '  }\n', '\n', '  function buyFor(address buyer) payable public {\n', '    uint256 _value =  _buy(buyer);\n', '\n', '    // allow donor (msg.sender) to spend buyer&#39;s tokens\n', '    allowed[buyer][msg.sender] += _value;\n', '    emit Approval(buyer, msg.sender, _value);\n', '  }\n', '\n', '  function _changeTrancheIfNeeded() internal {\n', '    if (totalSupply >= tranche) {\n', '      // change tranche size for next cycle\n', '      tranche = (tranche * trancheNumerator) / trancheDenominator;\n', '\n', '      // fire event for tranche change\n', '      emit TrancheIncreased(tranche, address(this).balance, outstandingQuarters);\n', '    }\n', '  }\n', '\n', '  // returns number of quarters buyer got\n', '  function _buy(address buyer) internal returns (uint256) {\n', '    require(buyer != address(0));\n', '\n', '    uint256 nq = (msg.value * ethRate) / (10 ** 18);\n', '    require(nq != 0);\n', '    if (nq > tranche) {\n', '      nq = tranche;\n', '    }\n', '\n', '    totalSupply += nq;\n', '    balances[buyer] += nq;\n', '    trueBuy[buyer] += nq;\n', '    outstandingQuarters += nq;\n', '\n', '    // change tranche size\n', '    _changeTrancheIfNeeded();\n', '\n', '    // event for quarters order (invoice)\n', '    emit QuartersOrdered(buyer, msg.value, nq);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '\n', '    // transfer owner&#39;s cut\n', '    Q2(q2).disburse.value(msg.value * 15 / 100)();\n', '\n', '    // return nq\n', '    return nq;\n', '  }\n', '\n', '  /**\n', '   * Transfer allowance from other address&#39;s allowance\n', '   *\n', '   * Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferAllowance(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    updatePlayerRewards(_from);\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    allowed[_from][msg.sender] -= _value;\n', '\n', '    if (_transfer(_from, _to, _value)) {\n', '      // allow msg.sender to spend _to&#39;s tokens\n', '      allowed[_to][msg.sender] += _value;\n', '      emit Approval(_to, msg.sender, _value);\n', '      return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  function withdraw(uint256 value) onlyActiveDeveloper public {\n', '    require(balances[msg.sender] >= value);\n', '\n', '    uint256 baseRate = getBaseRate();\n', '    require(baseRate > 0); // check if base rate > 0\n', '\n', '    uint256 earnings = value * baseRate;\n', '    uint256 rate = getRate(value); // get rate from value and tranche\n', '    uint256 earningsWithBonus = (rate * earnings) / 100;\n', '    if (earningsWithBonus > address(this).balance) {\n', '      earnings = address(this).balance;\n', '    } else {\n', '      earnings = earningsWithBonus;\n', '    }\n', '\n', '    balances[msg.sender] -= value;\n', '    outstandingQuarters -= value; // update the outstanding Quarters\n', '\n', '    uint256 etherPool = address(this).balance - earnings;\n', '    if (rate == megaRate) {\n', '      emit MegaEarnings(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool); // with current base rate\n', '    }\n', '\n', '    // event for withdraw\n', '    emit Withdraw(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool);  // with current base rate\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '\n', '    // earning for developers\n', '    msg.sender.transfer(earnings);  \n', '}\n', '\n', '  function disburse() public payable {\n', '    reserveETH += msg.value;\n', '  }\n', '\n', '  function getBaseRate () view public returns (uint256) {\n', '    if (outstandingQuarters > 0) {\n', '      return (address(this).balance - reserveETH) / outstandingQuarters;\n', '    }\n', '\n', '    return (address(this).balance - reserveETH);\n', '  }\n', '\n', '  function getRate (uint256 value) view public returns (uint32) {\n', '    if (value * mega > tranche) {  // size & rate for mega developer\n', '      return megaRate;\n', '    } else if (value * large > tranche) {   // size & rate for large developer\n', '      return largeRate;\n', '    } else if (value * medium > tranche) {  // size and rate for medium developer\n', '      return mediumRate;\n', '    } else if (value * small > tranche){  // size and rate for small developer\n', '      return smallRate;\n', '    }\n', '\n', '    return microRate; // rate for micro developer\n', '  }\n', '\n', '\n', '  //\n', '  // Migrations\n', '  //\n', '\n', '  // Target contract\n', '  address public migrationTarget;\n', '  bool public migrating = false;\n', '\n', '  // Migrate event\n', '  event Migrate(address indexed _from, uint256 _value);\n', '\n', '  //\n', '  // Migrate tokens to the new token contract.\n', '  //\n', '  function migrate() public {\n', '    require(migrationTarget != address(0));\n', '    uint256 _amount = balances[msg.sender];\n', '    require(_amount > 0);\n', '    balances[msg.sender] = 0;\n', '\n', '    totalSupply = totalSupply - _amount;\n', '    outstandingQuarters = outstandingQuarters - _amount;\n', '\n', '    rewards[msg.sender] = 0;\n', '    trueBuy[msg.sender] = 0;\n', '    developers[msg.sender] = false;\n', '\n', '    emit Migrate(msg.sender, _amount);\n', '    MigrationTarget(migrationTarget).migrateFrom(msg.sender, _amount, rewards[msg.sender], trueBuy[msg.sender], developers[msg.sender]);\n', '  }\n', '\n', '  //\n', '  // Set address of migration target contract\n', '  // @param _target The address of the MigrationTarget contract\n', '  //\n', '  function setMigrationTarget(address _target) onlyOwner public {\n', '    migrationTarget = _target;\n', '  }\n', '}']
['pragma solidity ^0.4.18;\n', '\n', '// File: contracts/MigrationTarget.sol\n', '\n', '//\n', '// Migration target\n', '// @dev Implement this interface to make migration target\n', '//\n', 'contract MigrationTarget {\n', '  function migrateFrom(address _from, uint256 _amount, uint256 _rewards, uint256 _trueBuy, bool _devStatus) public;\n', '}\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  // Event\n', '  event OwnershipChanged(address indexed oldOwner, address indexed newOwner);\n', '\n', '  // Modifier\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipChanged(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/ERC20.sol\n', '\n', 'contract ERC20 {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address _owner) view public returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) public returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b)\n', '    internal\n', '    pure\n', '    returns (uint256)\n', '  {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/StandardToken.sol\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is ERC20 {\n', '  /**\n', '   * Internal transfer, only can be called by this contract\n', '   */\n', '  function _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '    // Prevent transfer to 0x0 address. Use burn() instead\n', '    require(_to != address(0));\n', '    // Check if the sender has enough\n', '    require(balances[_from] >= _value);\n', '    // Check for overflows\n', '    require(balances[_to] + _value > balances[_to]);\n', '    // Save this for an assertion in the future\n', '    uint256 previousBalances = balances[_from] + balances[_to];\n', '    // Subtract from the sender\n', '    balances[_from] -= _value;\n', '    // Add the same to the recipient\n', '    balances[_to] += _value;\n', '    emit Transfer(_from, _to, _value);\n', '    // Asserts are used to use static analysis to find bugs in your code. They should never fail\n', '    assert(balances[_from] + balances[_to] == previousBalances);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens\n', '   *\n', '   * Send `_value` tokens to `_to` from your account\n', '   *\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    return _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * Transfer tokens from other address\n', '   *\n', '   * Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    allowed[_from][msg.sender] -= _value;\n', '    return _transfer(_from, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) view public returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /**\n', '   * Set allowance for other address\n', '   *\n', '   * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '   *\n', '   * @param _spender The address authorized to spend\n', '   * @param _value the max amount they can spend\n', '   */\n', '  function approve(address _spender, uint256 _value) public returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) view public returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  mapping (address => uint256) public balances;\n', '  mapping (address => mapping (address => uint256)) public allowed;\n', '}\n', '\n', '// File: contracts/RoyaltyToken.sol\n', '\n', '/*  Royalty token */\n', 'contract RoyaltyToken is StandardToken {\n', '  using SafeMath for uint256;\n', '  // restricted addresses\t\n', '  mapping(address => bool) public restrictedAddresses;\n', '  \n', '  event RestrictedStatusChanged(address indexed _address, bool status);\n', '\n', '  struct Account {\n', '    uint256 balance;\n', '    uint256 lastRoyaltyPoint;\n', '  }\n', '\n', '  mapping(address => Account) public accounts;\n', '  uint256 public totalRoyalty;\n', '  uint256 public unclaimedRoyalty;\n', '\n', '  /**\n', '   * Get Royalty amount for given account\n', '   *\n', '   * @param account The address for Royalty account\n', '   */\n', '  function RoyaltysOwing(address account) public view returns (uint256) {\n', '    uint256 newRoyalty = totalRoyalty.sub(accounts[account].lastRoyaltyPoint);\n', '    return balances[account].mul(newRoyalty).div(totalSupply);\n', '  }\n', '\n', '  /**\n', '   * @dev Update account for Royalty\n', '   * @param account The address of owner\n', '   */\n', '  function updateAccount(address account) internal {\n', '    uint256 owing = RoyaltysOwing(account);\n', '    accounts[account].lastRoyaltyPoint = totalRoyalty;\n', '    if (owing > 0) {\n', '      unclaimedRoyalty = unclaimedRoyalty.sub(owing);\n', '      accounts[account].balance = accounts[account].balance.add(owing);\n', '    }\n', '  }\n', '\n', '  function disburse() public payable {\n', '    require(totalSupply > 0);\n', '    require(msg.value > 0);\n', '\n', '    uint256 newRoyalty = msg.value;\n', '    totalRoyalty = totalRoyalty.add(newRoyalty);\n', '    unclaimedRoyalty = unclaimedRoyalty.add(newRoyalty);\n', '  }\n', '\n', '  /**\n', '   * @dev Send `_value` tokens to `_to` from your account\n', '   *\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transfer(address _to, uint256 _value) public returns (bool success) {\n', '    // Require that the sender is not restricted\n', '    require(restrictedAddresses[msg.sender] == false);\n', '    updateAccount(_to);\n', '    updateAccount(msg.sender);\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from other address. Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  ) public returns (bool success) {\n', '    updateAccount(_to);\n', '    updateAccount(_from);\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function withdrawRoyalty() public {\n', '    updateAccount(msg.sender);\n', '\n', '    // retrieve Royalty amount\n', '    uint256 RoyaltyAmount = accounts[msg.sender].balance;\n', '    require(RoyaltyAmount > 0);\n', '    accounts[msg.sender].balance = 0;\n', '\n', '    // transfer Royalty amount\n', '    msg.sender.transfer(RoyaltyAmount);\n', '  }\n', '}\n', '\n', '// File: contracts/Q2.sol\n', '\n', 'contract Q2 is Ownable, RoyaltyToken {\n', '  using SafeMath for uint256;\n', '\n', '  string public name = "Q2";\n', '  string public symbol = "Q2";\n', '  uint8 public decimals = 18;\n', '\n', '  bool public whitelist = true;\n', '\n', '  // whitelist addresses\n', '  mapping(address => bool) public whitelistedAddresses;\n', '\n', '  // token creation cap\n', '  uint256 public creationCap = 15000000 * (10 ** 18); // 15M\n', '  uint256 public reservedFund = 10000000 * (10 ** 18); // 10M\n', '\n', '  // stage info\n', '  struct Stage {\n', '    uint8 number;\n', '    uint256 exchangeRate;\n', '    uint256 startBlock;\n', '    uint256 endBlock;\n', '    uint256 cap;\n', '  }\n', '\n', '  // events\n', '  event MintTokens(address indexed _to, uint256 _value);\n', '  event StageStarted(uint8 _stage, uint256 _totalSupply, uint256 _balance);\n', '  event StageEnded(uint8 _stage, uint256 _totalSupply, uint256 _balance);\n', '  event WhitelistStatusChanged(address indexed _address, bool status);\n', '  event WhitelistChanged(bool status);\n', '\n', '  // eth wallet\n', '  address public ethWallet;\n', '  mapping (uint8 => Stage) stages;\n', '\n', '  // current state info\n', '  uint8 public currentStage;\n', '\n', '  function Q2(address _ethWallet) public {\n', '    ethWallet = _ethWallet;\n', '\n', '    // reserved tokens\n', '    mintTokens(ethWallet, reservedFund);\n', '  }\n', '\n', '  function mintTokens(address to, uint256 value) internal {\n', '    require(value > 0);\n', '    balances[to] = balances[to].add(value);\n', '    totalSupply = totalSupply.add(value);\n', '    require(totalSupply <= creationCap);\n', '\n', '    // broadcast event\n', '    emit MintTokens(to, value);\n', '  }\n', '\n', '  function () public payable {\n', '    buyTokens();\n', '  }\n', '\n', '  function buyTokens() public payable {\n', '    require(whitelist==false || whitelistedAddresses[msg.sender] == true);\n', '    require(msg.value > 0);\n', '\n', '    Stage memory stage = stages[currentStage];\n', '    require(block.number >= stage.startBlock && block.number <= stage.endBlock);\n', '\n', '    uint256 tokens = msg.value * stage.exchangeRate;\n', '    require(totalSupply.add(tokens) <= stage.cap);\n', '\n', '    mintTokens(msg.sender, tokens);\n', '  }\n', '\n', '  function startStage(\n', '    uint256 _exchangeRate,\n', '    uint256 _cap,\n', '    uint256 _startBlock,\n', '    uint256 _endBlock\n', '  ) public onlyOwner {\n', '    require(_exchangeRate > 0 && _cap > 0);\n', '    require(_startBlock > block.number);\n', '    require(_startBlock < _endBlock);\n', '\n', "    // stop current stage if it's running\n", '    Stage memory currentObj = stages[currentStage];\n', '    if (currentObj.endBlock > 0) {\n', '      // broadcast stage end event\n', '      emit StageEnded(currentStage, totalSupply, address(this).balance);\n', '    }\n', '\n', '    // increment current stage\n', '    currentStage = currentStage + 1;\n', '\n', '    // create new stage object\n', '    Stage memory s = Stage({\n', '      number: currentStage,\n', '      startBlock: _startBlock,\n', '      endBlock: _endBlock,\n', '      exchangeRate: _exchangeRate,\n', '      cap: _cap + totalSupply\n', '    });\n', '    stages[currentStage] = s;\n', '\n', '    // broadcast stage started event\n', '    emit StageStarted(currentStage, totalSupply, address(this).balance);\n', '  }\n', '\n', '  function withdraw() public onlyOwner {\n', '    ethWallet.transfer(address(this).balance);\n', '  }\n', '\n', '  function getCurrentStage() view public returns (\n', '    uint8 number,\n', '    uint256 exchangeRate,\n', '    uint256 startBlock,\n', '    uint256 endBlock,\n', '    uint256 cap\n', '  ) {\n', '    Stage memory currentObj = stages[currentStage];\n', '    number = currentObj.number;\n', '    exchangeRate = currentObj.exchangeRate;\n', '    startBlock = currentObj.startBlock;\n', '    endBlock = currentObj.endBlock;\n', '    cap = currentObj.cap;\n', '  }\n', '\n', '  function changeWhitelistStatus(address _address, bool status) public onlyOwner {\n', '    whitelistedAddresses[_address] = status;\n', '    emit WhitelistStatusChanged(_address, status);\n', '  }\n', '\n', '  function changeRestrictedtStatus(address _address, bool status) public onlyOwner {\n', '    restrictedAddresses[_address] = status;\n', '    emit RestrictedStatusChanged(_address, status);\n', '  }\n', '  \n', '  function changeWhitelist(bool status) public onlyOwner {\n', '     whitelist = status;\n', '     emit WhitelistChanged(status);\n', '  }\n', '}\n', '\n', '// File: contracts/Quarters.sol\n', '\n', 'interface TokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n', '}\n', '\n', 'contract Quarters is Ownable, StandardToken {\n', '  // Public variables of the token\n', '  string public name = "Quarters";\n', '  string public symbol = "Q";\n', '  uint8 public decimals = 0; // no decimals, only integer quarters\n', '\n', '  uint16 public ethRate = 4000; // Quarters/ETH\n', '  uint256 public tranche = 40000; // Number of Quarters in initial tranche\n', '\n', '  // List of developers\n', '  // address -> status\n', '  mapping (address => bool) public developers;\n', '\n', '  uint256 public outstandingQuarters;\n', '  address public q2;\n', '\n', '  // number of Quarters for next tranche\n', '  uint8 public trancheNumerator = 2;\n', '  uint8 public trancheDenominator = 1;\n', '\n', '  // initial multiples, rates (as percentages) for tiers of developers\n', '  uint32 public mega = 20;\n', '  uint32 public megaRate = 115;\n', '  uint32 public large = 100;\n', '  uint32 public largeRate = 90;\n', '  uint32 public medium = 2000;\n', '  uint32 public mediumRate = 75;\n', '  uint32 public small = 50000;\n', '  uint32 public smallRate = 50;\n', '  uint32 public microRate = 25;\n', '\n', '  // rewards related storage\n', '  mapping (address => uint256) public rewards;    // rewards earned, but not yet collected\n', '  mapping (address => uint256) public trueBuy;    // tranche rewards are set based on *actual* purchases of Quarters\n', '\n', '  uint256 public rewardAmount = 40;\n', '\n', '  uint8 public rewardNumerator = 1;\n', '  uint8 public rewardDenominator = 4;\n', '\n', '  // reserve ETH from Q2 to fund rewards\n', '  uint256 public reserveETH=0;\n', '\n', '  // ETH rate changed\n', '  event EthRateChanged(uint16 currentRate, uint16 newRate);\n', '\n', '  // This notifies clients about the amount burnt\n', '  event Burn(address indexed from, uint256 value);\n', '\n', '  event QuartersOrdered(address indexed sender, uint256 ethValue, uint256 tokens);\n', '  event DeveloperStatusChanged(address indexed developer, bool status);\n', '  event TrancheIncreased(uint256 _tranche, uint256 _etherPool, uint256 _outstandingQuarters);\n', '  event MegaEarnings(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\n', '  event Withdraw(address indexed developer, uint256 value, uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool);\n', '  event BaseRateChanged(uint256 _baseRate, uint256 _tranche, uint256 _outstandingQuarters, uint256 _etherPool,  uint256 _totalSupply);\n', '  event Reward(address indexed _address, uint256 value, uint256 _outstandingQuarters, uint256 _totalSupply);\n', '\n', '  /**\n', '   * developer modifier\n', '   */\n', '  modifier onlyActiveDeveloper() {\n', '    require(developers[msg.sender] == true);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Constructor function\n', '   *\n', '   * Initializes contract with initial supply tokens to the owner of the contract\n', '   */\n', '  function Quarters(\n', '    address _q2,\n', '    uint256 firstTranche\n', '  ) public {\n', '    q2 = _q2;\n', '    tranche = firstTranche; // number of Quarters to be sold before increasing price\n', '  }\n', '\n', '  function setEthRate (uint16 rate) onlyOwner public {\n', '    // Ether price is set in Wei\n', '    require(rate > 0);\n', '    ethRate = rate;\n', '    emit EthRateChanged(ethRate, rate);\n', '  }\n', '\n', '  /**\n', '   * Adjust reward amount\n', '   */\n', '  function adjustReward (uint256 reward) onlyOwner public {\n', '    rewardAmount = reward; // may be zero, no need to check value to 0\n', '  }\n', '\n', '  function adjustWithdrawRate(uint32 mega2, uint32 megaRate2, uint32 large2, uint32 largeRate2, uint32 medium2, uint32 mediumRate2, uint32 small2, uint32 smallRate2, uint32 microRate2) onlyOwner public {\n', '    // the values (mega, large, medium, small) are multiples, e.g., 20x, 100x, 10000x\n', '    // the rates (megaRate, etc.) are percentage points, e.g., 150 is 150% of the remaining etherPool\n', '    if (mega2 > 0 && megaRate2 > 0) {\n', '      mega = mega2;\n', '      megaRate = megaRate2;\n', '    }\n', '\n', '    if (large2 > 0 && largeRate2 > 0) {\n', '      large = large2;\n', '      largeRate = largeRate2;\n', '    }\n', '\n', '    if (medium2 > 0 && mediumRate2 > 0) {\n', '      medium = medium2;\n', '      mediumRate = mediumRate2;\n', '    }\n', '\n', '    if (small2 > 0 && smallRate2 > 0){\n', '      small = small2;\n', '      smallRate = smallRate2;\n', '    }\n', '\n', '    if (microRate2 > 0) {\n', '      microRate = microRate2;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * adjust tranche for next cycle\n', '   */\n', '  function adjustNextTranche (uint8 numerator, uint8 denominator) onlyOwner public {\n', '    require(numerator > 0 && denominator > 0);\n', '    trancheNumerator = numerator;\n', '    trancheDenominator = denominator;\n', '  }\n', '\n', '  function adjustTranche(uint256 tranche2) onlyOwner public {\n', '    require(tranche2 > 0);\n', '    tranche = tranche2;\n', '  }\n', '\n', '  /**\n', '   * Adjust rewards for `_address`\n', '   */\n', '  function updatePlayerRewards(address _address) internal {\n', '    require(_address != address(0));\n', '\n', '    uint256 _reward = 0;\n', '    if (rewards[_address] == 0) {\n', '      _reward = rewardAmount;\n', '    } else if (rewards[_address] < tranche) {\n', '      _reward = trueBuy[_address] * rewardNumerator / rewardDenominator;\n', '    }\n', '\n', '    if (_reward > 0) {\n', '      // update rewards record\n', '      rewards[_address] = tranche;\n', '\n', '      balances[_address] += _reward;\n', '      allowed[_address][msg.sender] += _reward; // set allowance\n', '\n', '      totalSupply += _reward;\n', '      outstandingQuarters += _reward;\n', '\n', '      uint256 spentETH = (_reward * (10 ** 18)) / ethRate;\n', '      if (reserveETH >= spentETH) {\n', '          reserveETH -= spentETH;\n', '        } else {\n', '          reserveETH = 0;\n', '        }\n', '\n', '      // tranche size change\n', '      _changeTrancheIfNeeded();\n', '\n', '      emit Approval(_address, msg.sender, _reward);\n', '      emit Reward(_address, _reward, outstandingQuarters, totalSupply);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Developer status\n', '   */\n', '  function setDeveloperStatus (address _address, bool status) onlyOwner public {\n', '    developers[_address] = status;\n', '    emit DeveloperStatusChanged(_address, status);\n', '  }\n', '\n', '  /**\n', '   * Set allowance for other address and notify\n', '   *\n', '   * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n', '   *\n', '   * @param _spender The address authorized to spend\n', '   * @param _value the max amount they can spend\n', '   * @param _extraData some extra information to send to the approved contract\n', '   */\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '  public\n', '  returns (bool success) {\n', '    TokenRecipient spender = TokenRecipient(_spender);\n', '    if (approve(_spender, _value)) {\n', '      spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '      return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  /**\n', '   * Destroy tokens\n', '   *\n', '   * Remove `_value` tokens from the system irreversibly\n', '   *\n', '   * @param _value the amount of money to burn\n', '   */\n', '  function burn(uint256 _value) public returns (bool success) {\n', '    require(balances[msg.sender] >= _value);   // Check if the sender has enough\n', '    balances[msg.sender] -= _value;            // Subtract from the sender\n', '    totalSupply -= _value;                     // Updates totalSupply\n', '    outstandingQuarters -= _value;              // Update outstanding quarters\n', '    emit Burn(msg.sender, _value);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Destroy tokens from other account\n', '   *\n', '   * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n', '   *\n', '   * @param _from the address of the sender\n', '   * @param _value the amount of money to burn\n', '   */\n', '  function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '    require(balances[_from] >= _value);                // Check if the targeted balance is enough\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    balances[_from] -= _value;                         // Subtract from the targeted balance\n', "    allowed[_from][msg.sender] -= _value;              // Subtract from the sender's allowance\n", '    totalSupply -= _value;                      // Update totalSupply\n', '    outstandingQuarters -= _value;              // Update outstanding quarters\n', '    emit Burn(_from, _value);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Buy quarters by sending ethers to contract address (no data required)\n', '   */\n', '  function () payable public {\n', '    _buy(msg.sender);\n', '  }\n', '\n', '\n', '  function buy() payable public {\n', '    _buy(msg.sender);\n', '  }\n', '\n', '  function buyFor(address buyer) payable public {\n', '    uint256 _value =  _buy(buyer);\n', '\n', "    // allow donor (msg.sender) to spend buyer's tokens\n", '    allowed[buyer][msg.sender] += _value;\n', '    emit Approval(buyer, msg.sender, _value);\n', '  }\n', '\n', '  function _changeTrancheIfNeeded() internal {\n', '    if (totalSupply >= tranche) {\n', '      // change tranche size for next cycle\n', '      tranche = (tranche * trancheNumerator) / trancheDenominator;\n', '\n', '      // fire event for tranche change\n', '      emit TrancheIncreased(tranche, address(this).balance, outstandingQuarters);\n', '    }\n', '  }\n', '\n', '  // returns number of quarters buyer got\n', '  function _buy(address buyer) internal returns (uint256) {\n', '    require(buyer != address(0));\n', '\n', '    uint256 nq = (msg.value * ethRate) / (10 ** 18);\n', '    require(nq != 0);\n', '    if (nq > tranche) {\n', '      nq = tranche;\n', '    }\n', '\n', '    totalSupply += nq;\n', '    balances[buyer] += nq;\n', '    trueBuy[buyer] += nq;\n', '    outstandingQuarters += nq;\n', '\n', '    // change tranche size\n', '    _changeTrancheIfNeeded();\n', '\n', '    // event for quarters order (invoice)\n', '    emit QuartersOrdered(buyer, msg.value, nq);\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '\n', "    // transfer owner's cut\n", '    Q2(q2).disburse.value(msg.value * 15 / 100)();\n', '\n', '    // return nq\n', '    return nq;\n', '  }\n', '\n', '  /**\n', "   * Transfer allowance from other address's allowance\n", '   *\n', '   * Send `_value` tokens to `_to` in behalf of `_from`\n', '   *\n', '   * @param _from The address of the sender\n', '   * @param _to The address of the recipient\n', '   * @param _value the amount to send\n', '   */\n', '  function transferAllowance(address _from, address _to, uint256 _value) public returns (bool success) {\n', '    updatePlayerRewards(_from);\n', '    require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '    allowed[_from][msg.sender] -= _value;\n', '\n', '    if (_transfer(_from, _to, _value)) {\n', "      // allow msg.sender to spend _to's tokens\n", '      allowed[_to][msg.sender] += _value;\n', '      emit Approval(_to, msg.sender, _value);\n', '      return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  function withdraw(uint256 value) onlyActiveDeveloper public {\n', '    require(balances[msg.sender] >= value);\n', '\n', '    uint256 baseRate = getBaseRate();\n', '    require(baseRate > 0); // check if base rate > 0\n', '\n', '    uint256 earnings = value * baseRate;\n', '    uint256 rate = getRate(value); // get rate from value and tranche\n', '    uint256 earningsWithBonus = (rate * earnings) / 100;\n', '    if (earningsWithBonus > address(this).balance) {\n', '      earnings = address(this).balance;\n', '    } else {\n', '      earnings = earningsWithBonus;\n', '    }\n', '\n', '    balances[msg.sender] -= value;\n', '    outstandingQuarters -= value; // update the outstanding Quarters\n', '\n', '    uint256 etherPool = address(this).balance - earnings;\n', '    if (rate == megaRate) {\n', '      emit MegaEarnings(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool); // with current base rate\n', '    }\n', '\n', '    // event for withdraw\n', '    emit Withdraw(msg.sender, earnings, baseRate, tranche, outstandingQuarters, etherPool);  // with current base rate\n', '\n', '    // log rate change\n', '    emit BaseRateChanged(getBaseRate(), tranche, outstandingQuarters, address(this).balance, totalSupply);\n', '\n', '    // earning for developers\n', '    msg.sender.transfer(earnings);  \n', '}\n', '\n', '  function disburse() public payable {\n', '    reserveETH += msg.value;\n', '  }\n', '\n', '  function getBaseRate () view public returns (uint256) {\n', '    if (outstandingQuarters > 0) {\n', '      return (address(this).balance - reserveETH) / outstandingQuarters;\n', '    }\n', '\n', '    return (address(this).balance - reserveETH);\n', '  }\n', '\n', '  function getRate (uint256 value) view public returns (uint32) {\n', '    if (value * mega > tranche) {  // size & rate for mega developer\n', '      return megaRate;\n', '    } else if (value * large > tranche) {   // size & rate for large developer\n', '      return largeRate;\n', '    } else if (value * medium > tranche) {  // size and rate for medium developer\n', '      return mediumRate;\n', '    } else if (value * small > tranche){  // size and rate for small developer\n', '      return smallRate;\n', '    }\n', '\n', '    return microRate; // rate for micro developer\n', '  }\n', '\n', '\n', '  //\n', '  // Migrations\n', '  //\n', '\n', '  // Target contract\n', '  address public migrationTarget;\n', '  bool public migrating = false;\n', '\n', '  // Migrate event\n', '  event Migrate(address indexed _from, uint256 _value);\n', '\n', '  //\n', '  // Migrate tokens to the new token contract.\n', '  //\n', '  function migrate() public {\n', '    require(migrationTarget != address(0));\n', '    uint256 _amount = balances[msg.sender];\n', '    require(_amount > 0);\n', '    balances[msg.sender] = 0;\n', '\n', '    totalSupply = totalSupply - _amount;\n', '    outstandingQuarters = outstandingQuarters - _amount;\n', '\n', '    rewards[msg.sender] = 0;\n', '    trueBuy[msg.sender] = 0;\n', '    developers[msg.sender] = false;\n', '\n', '    emit Migrate(msg.sender, _amount);\n', '    MigrationTarget(migrationTarget).migrateFrom(msg.sender, _amount, rewards[msg.sender], trueBuy[msg.sender], developers[msg.sender]);\n', '  }\n', '\n', '  //\n', '  // Set address of migration target contract\n', '  // @param _target The address of the MigrationTarget contract\n', '  //\n', '  function setMigrationTarget(address _target) onlyOwner public {\n', '    migrationTarget = _target;\n', '  }\n', '}']
