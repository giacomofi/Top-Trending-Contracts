['pragma solidity ^0.4.25;\n', '\n', '/*\n', '* https://12hourfasttrain.github.io\n', '*/\n', '// MULTIPLIER: 120%\n', '// THT Token Owners: 10%\n', '// Referral: 3%\n', '// Marketing: 3%\n', '// Last Investor: 10%\n', '// Min: 0.05 ETH\n', '// Max: 1 ETH\n', '\n', 'interface TwelveHourTokenInterface {\n', '     function fallback() external payable; \n', '     function buy(address _referredBy) external payable returns (uint256);\n', '     function exit() external;\n', '}\n', '\n', 'contract TwelveHourFastTrain {\n', '\taddress public owner;\n', '\taddress public twelveHourTokenAddress;\n', '    TwelveHourTokenInterface public TwelveHourToken; \n', '\tuint256 constant private THT_TOKEN_OWNERS     = 10;\n', '    address constant private PROMO = 0x31778364A4000F785c59D42Bb80e7E6E60b8457b;\n', '    uint constant public PROMO_PERCENT = 1;\n', '    uint constant public MULTIPLIER = 120;\n', '    uint constant public MAX_DEPOSIT = 1 ether;\n', '    uint constant public MIN_DEPOSIT = 0.05 ether;\n', '\tuint256 constant public VERIFY_REFERRAL_PRICE = 0.01 ether;\n', '\tuint256 constant public REFERRAL             = 3;\n', '\n', '    uint constant public LAST_DEPOSIT_PERCENT = 10;\n', '    \n', '    LastDeposit public last;\n', '\n', '\tmapping(address => bool) public referrals;\n', '\n', '    struct Deposit {\n', '        address depositor; \n', '        uint128 deposit;   \n', '        uint128 expect;    \n', '    }\n', '\n', '    struct LastDeposit {\n', '        address depositor;\n', '        uint expect;\n', '        uint depositTime;\n', '    }\n', '\n', '    Deposit[] public queue;\n', '    uint public currentReceiverIndex = 0; \n', '\n', '\tmodifier onlyOwner() \n', '    {\n', '      require(msg.sender == owner);\n', '      _;\n', '    }\n', '    modifier disableContract()\n', '    {\n', '      require(tx.origin == msg.sender);\n', '      _;\n', '    }\n', '\n', '\t/**\n', '    * @dev set TwelveHourToken contract\n', '    * @param _addr TwelveHourToken address\n', '    */\n', '    function setTwelveHourToken(address _addr) public onlyOwner\n', '    {\n', '      twelveHourTokenAddress = _addr;\n', '      TwelveHourToken = TwelveHourTokenInterface(twelveHourTokenAddress);  \n', '    }\n', '\n', '\tconstructor() public \n', '    {\n', '      owner = msg.sender;\n', '    }\n', '\n', '    function () public payable {\n', '        if (msg.sender != twelveHourTokenAddress) invest(0x0);\n', '    }\n', '\n', '    function invest(address _referral) public payable disableContract\n', '    {\n', '\t\tif(msg.value == 0 && msg.sender == last.depositor) {\n', '            require(gasleft() >= 220000, "We require more gas!");\n', '            require(last.depositTime + 12 hours < now, "Last depositor should wait 12 hours to claim reward");\n', '            \n', '            uint128 money = uint128((address(this).balance));\n', '            if(money >= last.expect){\n', '                last.depositor.transfer(last.expect);\n', '            } else {\n', '                last.depositor.transfer(money);\n', '            }\n', '            \n', '            delete last;\n', '        }\n', '        else if(msg.value > 0){\n', '            require(gasleft() >= 220000, "We require more gas!");\n', '            require(msg.value >= MIN_DEPOSIT, "Deposit must be >= 0.01 ETH and <= 1 ETH"); \n', '            uint256 valueDeposit = msg.value;\n', '            if(valueDeposit > MAX_DEPOSIT) {\n', '                msg.sender.transfer(valueDeposit - MAX_DEPOSIT);\n', '                valueDeposit = MAX_DEPOSIT;\n', '            }\n', '\t\t\tuint256 _profitTHT     = valueDeposit * THT_TOKEN_OWNERS / 100;\n', '\t\t\tsendProfitTHT(_profitTHT);\n', '            queue.push(Deposit(msg.sender, uint128(valueDeposit), uint128(valueDeposit*MULTIPLIER/100)));\n', '\n', '            last.depositor = msg.sender;\n', '            last.expect += valueDeposit*LAST_DEPOSIT_PERCENT/100;\n', '            last.depositTime = now;\n', '\n', '            uint promo = valueDeposit*PROMO_PERCENT/100;\n', '            PROMO.transfer(promo);\n', '\t\t\tuint devFee = valueDeposit*2/100;\n', '            owner.transfer(devFee);\n', '\t\t\t\n', '\t\t\tuint256 _referralBonus = valueDeposit * REFERRAL/100;\n', '\t\t\tif (_referral != 0x0 && _referral != msg.sender && referrals[_referral] == true) address(_referral).transfer(_referralBonus);\n', '\t\t\telse owner.transfer(_referralBonus);\n', '\n', '            pay();\n', '        }\n', '    }\n', '\n', '\tfunction pay() private {\n', '        uint128 money = uint128((address(this).balance)-last.expect);\n', '        for(uint i=0; i<queue.length; i++){\n', '            uint idx = currentReceiverIndex + i;  \n', '            Deposit storage dep = queue[idx]; \n', '            if(money >= dep.expect){  \n', '                dep.depositor.transfer(dep.expect); \n', '                money -= dep.expect;            \n', '                delete queue[idx];\n', '            }else{\n', '                dep.depositor.transfer(money); \n', '                dep.expect -= money;       \n', '                break;\n', '            }\n', '            if(gasleft() <= 50000)        \n', '                break;\n', '        }\n', '        currentReceiverIndex += i; \n', '    }\n', '\n', '\tfunction sendProfitTHT(uint256 profitTHT) private\n', '    {\n', '        buyTHT(calEthSendToTHT(profitTHT));\n', '        exitTHT();\n', '    }\n', '\t\n', '\tfunction exitTHT() private\n', '    {\n', '      TwelveHourToken.exit();\n', '    }\n', '\t\n', '\t/**\n', '    * @dev calculate dividend eth for THT owner\n', '    * @param _eth value want share\n', '    * value = _eth * 100 / 64\n', '    */\n', '    function calEthSendToTHT(uint256 _eth) private pure returns(uint256 _value)\n', '    {\n', '      _value = _eth * 100 / 64;\n', '    }\n', '\n', '\tfunction buyTHT(uint256 _value) private\n', '    {\n', '      TwelveHourToken.fallback.value(_value)();\n', '    }\n', '\n', '\tfunction totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n', '        Deposit storage dep = queue[idx];\n', '        return (dep.depositor, dep.deposit, dep.expect);\n', '    }\n', '\n', '\n', '\tfunction verifyReferrals() public payable disableContract\n', '    {\n', '      require(msg.value >= VERIFY_REFERRAL_PRICE);\n', '      referrals[msg.sender] = true;\n', '      owner.transfer(msg.value);\n', '    }\n', '    \n', '    function getDepositByAddress(address depositor) public view returns (uint256 index, uint256 deposit, uint256 expect) {\n', '        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n', '            Deposit storage dep = queue[i];\n', '            if(dep.depositor == depositor){\n', '                index = i;\n', '                deposit = dep.deposit;\n', '                expect = dep.expect;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getData()public view returns(uint256 _lastDepositBonus, uint256 _endTime, uint256 _currentlyServing, uint256 _queueLength, address _lastAddress) {\n', '        _lastDepositBonus = address(this).balance;\n', '        _endTime = last.depositTime + 12 hours;\n', '        _currentlyServing = currentReceiverIndex;\n', '        _queueLength = queue.length;\n', '        _lastAddress = last.depositor;\n', '    }\n', '\n', '}']