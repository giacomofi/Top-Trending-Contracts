['pragma solidity ^0.4.25;\n', '\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* Web              - https://255eth.club\n', '* Our partners telegram_channel - https://t.me/invest_to_smartcontract\n', '* EN  Telegram_chat: https://t.me/club_255eth_en\n', '* RU  Telegram_chat: https://t.me/club_255eth_ru\n', '* Email:             mailto:support(at sign)255eth.club\n', '* \n', '*  - GAIN 2,55% PER 24 HOURS (every 5900 blocks)\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 eth\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 90% payments\n', '*    -- 5% Referral program (3% first level, 2% second level)\n', '*    -- 5% (4% Marketing, 1% Operating Expenses)\n', '* \n', '*  - Referral will be rewarded\n', '*    -- Your referral will receive 3% of his first investment to deposit.\n', '* \n', '*  - HOW TO GET MORE INCOME?\n', '*    -- Marathon "The Best Investor"\n', '*       Current winner becomes common referrer for investors without \n', '*       referrer and get a lump sum of 3% of their deposits. \n', '*       To become winner you must invest more than previous winner.\n', '*       \n', '*       How to check: see bestInvestorInfo in the contract\n', '* \n', '*    -- Marathon "The Best Promoter"\n', '*       Current winner becomes common referrer for investors without \n', '*       referrer and get a lump sum of 2% of their deposits. \n', '*       To become winner you must invite more than previous winner.\n', '*\n', '*       How to check: see bestPromouterInfo in the contract\n', '* \n', '*    -- Send advertise tokens with contract method massAdvertiseTransfer or transfer \n', '*       and get 1% from first investments of invited wallets.\n', '*       Advertise tokens free for all but you will pay gas fee for call methods.\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', '*  freely accessed online. In order to insure our investors&#39; complete security, full control over the \n', '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', '*  system&#39;s permanent autonomous functioning.\n', '* \n', '* ---How to use:\n', '*  1. Send from ETH wallet to the smart contract address 0x19b369f69bc5bd6aadc4d30c179c8ac5ae6cbae0\n', '*     any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', '*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don&#39;t care unless you&#39;re \n', '*      spending too much on GAS). But not early then 24 hours from last time claim or invest.\n', '*  OR\n', '*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \n', '*      transaction), and only after that, deposit the amount that you want to reinvest.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 350000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Revolution. Scroll down to find it.\n', '*/\n', '\n', '\n', 'contract InvestorsStorage {\n', '  struct investor {\n', '    uint keyIndex;\n', '    uint value;\n', '    uint paymentTime;\n', '    uint refs;\n', '    uint refBonus;\n', '  }\n', '  struct bestAddress {\n', '      uint value;\n', '      address addr;\n', '  }\n', '  struct recordStats {\n', '    uint investors;\n', '    uint invested;\n', '  }\n', '  struct itmap {\n', '    mapping(uint => recordStats) stats;\n', '    mapping(address => investor) data;\n', '    address[] keys;\n', '    bestAddress bestInvestor;\n', '    bestAddress bestPromouter;\n', '  }\n', '  itmap private s;\n', '  \n', '  address private owner;\n', '  \n', '  event LogBestInvestorChanged(address indexed addr, uint when, uint invested);\n', '  event LogBestPromouterChanged(address indexed addr, uint when, uint refs);\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    s.keys.length++;\n', '  }\n', '\n', '  function insert(address addr, uint value) public onlyOwner returns (bool) {\n', '    uint keyIndex = s.data[addr].keyIndex;\n', '    if (keyIndex != 0) return false;\n', '    s.data[addr].value = value;\n', '    keyIndex = s.keys.length++;\n', '    s.data[addr].keyIndex = keyIndex;\n', '    s.keys[keyIndex] = addr;\n', '    updateBestInvestor(addr, s.data[addr].value);\n', '    \n', '    return true;\n', '  }\n', '\n', '  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].keyIndex,\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refs,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorBaseInfo(address addr) public view returns(uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refs,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorShortInfo(address addr) public view returns(uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function getBestInvestor() public view returns(uint, address) {\n', '    return (\n', '      s.bestInvestor.value,\n', '      s.bestInvestor.addr\n', '    );\n', '  }\n', '  \n', '  function getBestPromouter() public view returns(uint, address) {\n', '    return (\n', '      s.bestPromouter.value,\n', '      s.bestPromouter.addr\n', '    );\n', '  }\n', '\n', '  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    return true;\n', '  }\n', '  \n', '  function addRefBonusWithRefs(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    s.data[addr].refs++;\n', '    updateBestPromouter(addr, s.data[addr].refs);\n', '    \n', '    return true;\n', '  }\n', '\n', '  function addValue(address addr, uint value) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].value += value;\n', '    updateBestInvestor(addr, s.data[addr].value);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  function updateStats(uint dt, uint invested, uint investors) public {\n', '    s.stats[dt].invested += invested;\n', '    s.stats[dt].investors += investors;\n', '  }\n', '  \n', '  function stats(uint dt) public view returns (uint invested, uint investors) {\n', '    return ( \n', '      s.stats[dt].invested,\n', '      s.stats[dt].investors\n', '    );\n', '  }\n', '  \n', '  function updateBestInvestor(address addr, uint investorValue) internal {\n', '    if(investorValue > s.bestInvestor.value){\n', '        s.bestInvestor.value = investorValue;\n', '        s.bestInvestor.addr = addr;\n', '        emit LogBestInvestorChanged(addr, now, s.bestInvestor.value);\n', '    }      \n', '  }\n', '  \n', '  function updateBestPromouter(address addr, uint investorRefs) internal {\n', '    if(investorRefs > s.bestPromouter.value){\n', '        s.bestPromouter.value = investorRefs;\n', '        s.bestPromouter.addr = addr;\n', '        emit LogBestPromouterChanged(addr, now, s.bestPromouter.value);\n', '    }      \n', '  }\n', '\n', '  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].paymentTime = paymentTime;\n', '    return true;\n', '  }\n', '\n', '  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus = refBonus;\n', '    return true;\n', '  }\n', '\n', '  function keyFromIndex(uint i) public view returns (address) {\n', '    return s.keys[i];\n', '  }\n', '\n', '  function contains(address addr) public view returns (bool) {\n', '    return s.data[addr].keyIndex > 0;\n', '  }\n', '\n', '  function size() public view returns (uint) {\n', '    return s.keys.length;\n', '  }\n', '\n', '  function iterStart() public pure returns (uint) {\n', '    return 1;\n', '  }\n', '}\n', '\n', '\n', 'contract DT {\n', '        struct DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint private constant DAY_IN_SECONDS = 86400;\n', '        uint private constant YEAR_IN_SECONDS = 31536000;\n', '        uint private constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint private constant HOUR_IN_SECONDS = 3600;\n', '        uint private constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 private constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) internal pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) internal pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '        }\n', '        \n', '        function getYear(uint timestamp) internal pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '}\n', '/**\n', '    ERC20 Token standart for contract advetising\n', '**/\n', 'contract ERC20AdToken {\n', '    using SafeMath for uint;\n', '    using Zero for *;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply;\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping(address => address) public adtransfers;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor(string _symbol, string _name) public {\n', '        symbol = _symbol;\n', '        name = _name;\n', '        balanceOf[this] = 10000000000;\n', '        totalSupply = 10000000000;\n', '        emit Transfer(address(0), this, 10000000000);\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        //This method do not send anything. It is only notify blockchain that Advertise Token Transfered\n', '        //You can call this method for advertise this contract and invite new investors and gain 1% from each first investments.\n', '        if(!adtransfers[to].notZero()){\n', '            adtransfers[to] = msg.sender;\n', '            emit Transfer(this, to, tokens);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function massAdvertiseTransfer(address[] addresses, uint tokens) public returns (bool success) {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if(!adtransfers[addresses[i]].notZero()){\n', '                adtransfers[addresses[i]] = msg.sender;\n', '                emit Transfer(this, addresses[i], tokens);\n', '            }\n', '        }\n', '        \n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '}\n', '\n', 'contract EarnEveryDay_255 is ERC20AdToken, DT {\n', '  using Percent for Percent.percent;\n', '  using SafeMath for uint;\n', '  using Zero for *;\n', '  using ToAddress for *;\n', '  using Convert for *;\n', '\n', '  // investors storage - iterable map;\n', '  InvestorsStorage private m_investors;\n', '  mapping(address => address) private m_referrals;\n', '  bool private m_nextWave;\n', '\n', '  // automatically generates getters\n', '  address public adminAddr;\n', '  uint public waveStartup;\n', '  uint public totalInvestments;\n', '  uint public totalInvested;\n', '  uint public constant minInvesment = 10 finney; // 0.01 eth\n', '  uint public constant maxBalance = 255e5 ether; // 25,500,000 eth\n', '  uint public constant dividendsPeriod = 24 hours; //24 hours\n', '\n', '  // percents \n', '  Percent.percent private m_dividendsPercent = Percent.percent(255, 10000); // 255/10000*100% = 2.55%\n', '  Percent.percent private m_adminPercent = Percent.percent(5, 100); // 5/100*100% = 5%\n', '  Percent.percent private m_refPercent1 = Percent.percent(3, 100); // 3/100*100% = 3%\n', '  Percent.percent private m_refPercent2 = Percent.percent(2, 100); // 2/100*100% = 2%\n', '  Percent.percent private m_adBonus = Percent.percent(1, 100); // 1/100*100% = 1%\n', '\n', '  // more events for easy read from blockchain\n', '  event LogNewInvestor(address indexed addr, uint when, uint value);\n', '  event LogNewInvesment(address indexed addr, uint when, uint value);\n', '  event LogNewReferral(address indexed addr, uint when, uint value);\n', '  event LogPayDividends(address indexed addr, uint when, uint value);\n', '  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n', '  event LogBalanceChanged(uint when, uint balance);\n', '  event LogNextWave(uint when);\n', '\n', '  modifier balanceChanged {\n', '    _;\n', '    emit LogBalanceChanged(now, address(this).balance);\n', '  }\n', '\n', '  constructor() ERC20AdToken("Earn 2.55% Every Day. https://255eth.club", \n', '                            "Send your ETH to this contract and earn 2.55% every day for Live-long. https://255eth.club") public {\n', '    adminAddr = msg.sender;\n', '\n', '    nextWave();\n', '  }\n', '\n', '  function() public payable {\n', '    // investor get him dividends\n', '    if (msg.value == 0) {\n', '      getMyDividends();\n', '      return;\n', '    }\n', '\n', '    // sender do invest\n', '    address a = msg.data.toAddr();\n', '    doInvest(a);\n', '  }\n', '\n', '  function investorsNumber() public view returns(uint) {\n', '    return m_investors.size()-1;\n', '    // -1 because see InvestorsStorage constructor where keys.length++ \n', '  }\n', '\n', '  function balanceETH() public view returns(uint) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function dividendsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\n', '  }\n', '\n', '  function adminPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\n', '  }\n', '\n', '  function referrer1Percent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent1.num, m_refPercent1.den);\n', '  }\n', '  \n', '  function referrer2Percent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent2.num, m_refPercent2.den);\n', '  }\n', '  \n', '  function stats(uint date) public view returns(uint invested, uint investors) {\n', '    (invested, investors) = m_investors.stats(date);\n', '  }\n', '\n', '  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {\n', '    (value, paymentTime, refsCount, refBonus) = m_investors.investorBaseInfo(addr);\n', '    isReferral = m_referrals[addr].notZero();\n', '  }\n', '  \n', '  function bestInvestorInfo() public view returns(uint invested, address addr) {\n', '    (invested, addr) = m_investors.getBestInvestor();\n', '  }\n', '  \n', '  function bestPromouterInfo() public view returns(uint refs, address addr) {\n', '    (refs, addr) = m_investors.getBestPromouter();\n', '  }\n', '  \n', '  function _getMyDividents(bool withoutThrow) private {\n', '    // check investor info\n', '    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\n', '    if(investor.keyIndex <= 0){\n', '        if(withoutThrow){\n', '            return;\n', '        }\n', '        \n', '        revert("sender is not investor");\n', '    }\n', '\n', '    // calculate days after latest payment\n', '    uint256 daysAfter = now.sub(investor.paymentTime).div(dividendsPeriod);\n', '    if(daysAfter <= 0){\n', '        if(withoutThrow){\n', '            return;\n', '        }\n', '        \n', '        revert("the latest payment was earlier than dividents period");\n', '    }\n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    // check enough eth \n', '    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\n', '    if (address(this).balance < value + investor.refBonus) {\n', '      nextWave();\n', '      return;\n', '    }\n', '\n', '    // send dividends and ref bonus\n', '    if (investor.refBonus > 0) {\n', '      assert(m_investors.setRefBonus(msg.sender, 0));\n', '      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\n', '    } else {\n', '      sendDividends(msg.sender, value);\n', '    }      \n', '  }\n', '  \n', '  function getMyDividends() public balanceChanged {\n', '    _getMyDividents(false);\n', '  }\n', '\n', '  function doInvest(address ref) public payable balanceChanged {\n', '    require(msg.value >= minInvesment, "msg.value must be >= minInvesment");\n', '    require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '    uint value = msg.value;\n', '    // ref system works only once for sender-referral\n', '    if (!m_referrals[msg.sender].notZero()) {\n', '      // level 1\n', '      if (notZeroNotSender(ref) && m_investors.contains(ref)) {\n', '        uint reward = m_refPercent1.mul(value);\n', '        assert(m_investors.addRefBonusWithRefs(ref, reward)); // referrer 1 bonus\n', '        m_referrals[msg.sender] = ref;\n', '        value = m_dividendsPercent.add(value); // referral bonus\n', '        emit LogNewReferral(msg.sender, now, value); \n', '        // level 2\n', '        if (notZeroNotSender(m_referrals[ref]) && m_investors.contains(m_referrals[ref]) && ref != m_referrals[ref]) { \n', '          reward = m_refPercent2.mul(value);\n', '          assert(m_investors.addRefBonus(m_referrals[ref], reward)); // referrer 2 bonus\n', '        }\n', '      }else{\n', '        InvestorsStorage.bestAddress memory bestInvestor = getMemBestInvestor();\n', '        InvestorsStorage.bestAddress memory bestPromouter = getMemBestPromouter();\n', '        if(notZeroNotSender(bestInvestor.addr)){\n', '          assert(m_investors.addRefBonus(bestInvestor.addr, m_refPercent1.mul(value) )); // referrer 1 bonus\n', '          m_referrals[msg.sender] = bestInvestor.addr;\n', '        }\n', '        if(notZeroNotSender(bestPromouter.addr)){\n', '          assert(m_investors.addRefBonus(bestPromouter.addr, m_refPercent2.mul(value) )); // referrer 2 bonus\n', '          m_referrals[msg.sender] = bestPromouter.addr;\n', '        }\n', '      }\n', '      \n', '      if(notZeroNotSender(adtransfers[msg.sender]) && m_investors.contains(adtransfers[msg.sender])){\n', '          assert(m_investors.addRefBonus(adtransfers[msg.sender], m_adBonus.mul(msg.value) )); // advertise transfer bonud\n', '      }\n', '    }\n', '\n', '    _getMyDividents(true);\n', '\n', '    // commission\n', '    adminAddr.transfer(m_adminPercent.mul(msg.value));\n', '    \n', '    DT.DateTime memory dt = parseTimestamp(now);\n', '    uint today = dt.year.uintToString().strConcat((dt.month<10 ? "0":""), dt.month.uintToString(), (dt.day<10 ? "0":""), dt.day.uintToString()).stringToUint();\n', '    \n', '    // write to investors storage\n', '    if (m_investors.contains(msg.sender)) {\n', '      assert(m_investors.addValue(msg.sender, value));\n', '      m_investors.updateStats(today, value, 0);\n', '    } else {\n', '      assert(m_investors.insert(msg.sender, value));\n', '      m_investors.updateStats(today, value, 1);\n', '      emit LogNewInvestor(msg.sender, now, value); \n', '    }\n', '    \n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    emit LogNewInvesment(msg.sender, now, value);   \n', '    totalInvestments++;\n', '    totalInvested += msg.value;\n', '  }\n', '\n', '\n', '  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\n', '    (uint a, uint b, uint c, uint d, uint e) = m_investors.investorFullInfo(addr);\n', '    return InvestorsStorage.investor(a, b, c, d, e);\n', '  }\n', '  \n', '  function getMemBestInvestor() internal view returns(InvestorsStorage.bestAddress) {\n', '    (uint value, address addr) = m_investors.getBestInvestor();\n', '    return InvestorsStorage.bestAddress(value, addr);\n', '  }\n', '  \n', '  function getMemBestPromouter() internal view returns(InvestorsStorage.bestAddress) {\n', '    (uint value, address addr) = m_investors.getBestPromouter();\n', '    return InvestorsStorage.bestAddress(value, addr);\n', '  }\n', '\n', '  function notZeroNotSender(address addr) internal view returns(bool) {\n', '    return addr.notZero() && addr != msg.sender;\n', '  }\n', '\n', '  function sendDividends(address addr, uint value) private {\n', '    if (addr.send(value)) emit LogPayDividends(addr, now, value); \n', '  }\n', '\n', '  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\n', '    if (addr.send(value+refBonus)) {\n', '      emit LogPayDividends(addr, now, value);\n', '      emit LogPayReferrerBonus(addr, now, refBonus);\n', '    }\n', '  }\n', '\n', '  function nextWave() private {\n', '    m_investors = new InvestorsStorage();\n', '    totalInvestments = 0;\n', '    waveStartup = now;\n', '    m_nextWave = false;\n', '    emit LogNextWave(now);\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the\n', '    // benefit is lost if &#39;b&#39; is also tested.\n', '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', '    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn&#39;t hold\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', 'library Convert {\n', '    function stringToUint(string s) internal pure returns (uint) {\n', '        bytes memory b = bytes(s);\n', '        uint result = 0;\n', '        for (uint i = 0; i < b.length; i++) { // c = b[i] was not needed\n', '            if (b[i] >= 48 && b[i] <= 57) {\n', '                result = result * 10 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\n', '            }\n', '        }\n', '        return result; // this was missing\n', '    }\n', '    \n', '    function uintToString(uint v) internal pure returns (string) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i); // i + 1 is inefficient\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n', '        }\n', '        string memory str = string(s);  // memory isn&#39;t implicitly convertible to storage\n', '        return str; // this was missing\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '    \n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '}']
['pragma solidity ^0.4.25;\n', '\n', '/**\n', '*\n', '* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n', '* Web              - https://255eth.club\n', '* Our partners telegram_channel - https://t.me/invest_to_smartcontract\n', '* EN  Telegram_chat: https://t.me/club_255eth_en\n', '* RU  Telegram_chat: https://t.me/club_255eth_ru\n', '* Email:             mailto:support(at sign)255eth.club\n', '* \n', '*  - GAIN 2,55% PER 24 HOURS (every 5900 blocks)\n', '*  - Life-long payments\n', '*  - The revolutionary reliability\n', '*  - Minimal contribution 0.01 eth\n', '*  - Currency and payment - ETH\n', '*  - Contribution allocation schemes:\n', '*    -- 90% payments\n', '*    -- 5% Referral program (3% first level, 2% second level)\n', '*    -- 5% (4% Marketing, 1% Operating Expenses)\n', '* \n', '*  - Referral will be rewarded\n', '*    -- Your referral will receive 3% of his first investment to deposit.\n', '* \n', '*  - HOW TO GET MORE INCOME?\n', '*    -- Marathon "The Best Investor"\n', '*       Current winner becomes common referrer for investors without \n', '*       referrer and get a lump sum of 3% of their deposits. \n', '*       To become winner you must invest more than previous winner.\n', '*       \n', '*       How to check: see bestInvestorInfo in the contract\n', '* \n', '*    -- Marathon "The Best Promoter"\n', '*       Current winner becomes common referrer for investors without \n', '*       referrer and get a lump sum of 2% of their deposits. \n', '*       To become winner you must invite more than previous winner.\n', '*\n', '*       How to check: see bestPromouterInfo in the contract\n', '* \n', '*    -- Send advertise tokens with contract method massAdvertiseTransfer or transfer \n', '*       and get 1% from first investments of invited wallets.\n', '*       Advertise tokens free for all but you will pay gas fee for call methods.\n', '*\n', '*   ---About the Project\n', '*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n', '*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n', '*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n', "*  freely accessed online. In order to insure our investors' complete security, full control over the \n", '*  project has been transferred from the organizers to the smart contract: nobody can influence the \n', "*  system's permanent autonomous functioning.\n", '* \n', '* ---How to use:\n', '*  1. Send from ETH wallet to the smart contract address 0x19b369f69bc5bd6aadc4d30c179c8ac5ae6cbae0\n', '*     any amount from 0.01 ETH.\n', '*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n', '*     of your wallet.\n', "*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \n", '*      spending too much on GAS). But not early then 24 hours from last time claim or invest.\n', '*  OR\n', '*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \n', '*      transaction), and only after that, deposit the amount that you want to reinvest.\n', '*  \n', '* RECOMMENDED GAS LIMIT: 350000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* You can check the payments on the etherscan.io site, in the "Internal Txns" tab of your wallet.\n', '*\n', '* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n', '* have private keys.\n', '* \n', '* Contracts reviewed and approved by pros!\n', '* \n', '* Main contract - Revolution. Scroll down to find it.\n', '*/\n', '\n', '\n', 'contract InvestorsStorage {\n', '  struct investor {\n', '    uint keyIndex;\n', '    uint value;\n', '    uint paymentTime;\n', '    uint refs;\n', '    uint refBonus;\n', '  }\n', '  struct bestAddress {\n', '      uint value;\n', '      address addr;\n', '  }\n', '  struct recordStats {\n', '    uint investors;\n', '    uint invested;\n', '  }\n', '  struct itmap {\n', '    mapping(uint => recordStats) stats;\n', '    mapping(address => investor) data;\n', '    address[] keys;\n', '    bestAddress bestInvestor;\n', '    bestAddress bestPromouter;\n', '  }\n', '  itmap private s;\n', '  \n', '  address private owner;\n', '  \n', '  event LogBestInvestorChanged(address indexed addr, uint when, uint invested);\n', '  event LogBestPromouterChanged(address indexed addr, uint when, uint refs);\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "access denied");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '    s.keys.length++;\n', '  }\n', '\n', '  function insert(address addr, uint value) public onlyOwner returns (bool) {\n', '    uint keyIndex = s.data[addr].keyIndex;\n', '    if (keyIndex != 0) return false;\n', '    s.data[addr].value = value;\n', '    keyIndex = s.keys.length++;\n', '    s.data[addr].keyIndex = keyIndex;\n', '    s.keys[keyIndex] = addr;\n', '    updateBestInvestor(addr, s.data[addr].value);\n', '    \n', '    return true;\n', '  }\n', '\n', '  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].keyIndex,\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refs,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorBaseInfo(address addr) public view returns(uint, uint, uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].paymentTime,\n', '      s.data[addr].refs,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function investorShortInfo(address addr) public view returns(uint, uint) {\n', '    return (\n', '      s.data[addr].value,\n', '      s.data[addr].refBonus\n', '    );\n', '  }\n', '\n', '  function getBestInvestor() public view returns(uint, address) {\n', '    return (\n', '      s.bestInvestor.value,\n', '      s.bestInvestor.addr\n', '    );\n', '  }\n', '  \n', '  function getBestPromouter() public view returns(uint, address) {\n', '    return (\n', '      s.bestPromouter.value,\n', '      s.bestPromouter.addr\n', '    );\n', '  }\n', '\n', '  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    return true;\n', '  }\n', '  \n', '  function addRefBonusWithRefs(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus += refBonus;\n', '    s.data[addr].refs++;\n', '    updateBestPromouter(addr, s.data[addr].refs);\n', '    \n', '    return true;\n', '  }\n', '\n', '  function addValue(address addr, uint value) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].value += value;\n', '    updateBestInvestor(addr, s.data[addr].value);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  function updateStats(uint dt, uint invested, uint investors) public {\n', '    s.stats[dt].invested += invested;\n', '    s.stats[dt].investors += investors;\n', '  }\n', '  \n', '  function stats(uint dt) public view returns (uint invested, uint investors) {\n', '    return ( \n', '      s.stats[dt].invested,\n', '      s.stats[dt].investors\n', '    );\n', '  }\n', '  \n', '  function updateBestInvestor(address addr, uint investorValue) internal {\n', '    if(investorValue > s.bestInvestor.value){\n', '        s.bestInvestor.value = investorValue;\n', '        s.bestInvestor.addr = addr;\n', '        emit LogBestInvestorChanged(addr, now, s.bestInvestor.value);\n', '    }      \n', '  }\n', '  \n', '  function updateBestPromouter(address addr, uint investorRefs) internal {\n', '    if(investorRefs > s.bestPromouter.value){\n', '        s.bestPromouter.value = investorRefs;\n', '        s.bestPromouter.addr = addr;\n', '        emit LogBestPromouterChanged(addr, now, s.bestPromouter.value);\n', '    }      \n', '  }\n', '\n', '  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].paymentTime = paymentTime;\n', '    return true;\n', '  }\n', '\n', '  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n', '    if (s.data[addr].keyIndex == 0) return false;\n', '    s.data[addr].refBonus = refBonus;\n', '    return true;\n', '  }\n', '\n', '  function keyFromIndex(uint i) public view returns (address) {\n', '    return s.keys[i];\n', '  }\n', '\n', '  function contains(address addr) public view returns (bool) {\n', '    return s.data[addr].keyIndex > 0;\n', '  }\n', '\n', '  function size() public view returns (uint) {\n', '    return s.keys.length;\n', '  }\n', '\n', '  function iterStart() public pure returns (uint) {\n', '    return 1;\n', '  }\n', '}\n', '\n', '\n', 'contract DT {\n', '        struct DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint private constant DAY_IN_SECONDS = 86400;\n', '        uint private constant YEAR_IN_SECONDS = 31536000;\n', '        uint private constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint private constant HOUR_IN_SECONDS = 3600;\n', '        uint private constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 private constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) internal pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) internal pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (DateTime dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '        }\n', '        \n', '        function getYear(uint timestamp) internal pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) internal pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '}\n', '/**\n', '    ERC20 Token standart for contract advetising\n', '**/\n', 'contract ERC20AdToken {\n', '    using SafeMath for uint;\n', '    using Zero for *;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply;\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping(address => address) public adtransfers;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor(string _symbol, string _name) public {\n', '        symbol = _symbol;\n', '        name = _name;\n', '        balanceOf[this] = 10000000000;\n', '        totalSupply = 10000000000;\n', '        emit Transfer(address(0), this, 10000000000);\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        //This method do not send anything. It is only notify blockchain that Advertise Token Transfered\n', '        //You can call this method for advertise this contract and invite new investors and gain 1% from each first investments.\n', '        if(!adtransfers[to].notZero()){\n', '            adtransfers[to] = msg.sender;\n', '            emit Transfer(this, to, tokens);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function massAdvertiseTransfer(address[] addresses, uint tokens) public returns (bool success) {\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            if(!adtransfers[addresses[i]].notZero()){\n', '                adtransfers[addresses[i]] = msg.sender;\n', '                emit Transfer(this, addresses[i], tokens);\n', '            }\n', '        }\n', '        \n', '        return true;\n', '    }\n', '\n', '    function () public payable {\n', '        revert();\n', '    }\n', '\n', '}\n', '\n', 'contract EarnEveryDay_255 is ERC20AdToken, DT {\n', '  using Percent for Percent.percent;\n', '  using SafeMath for uint;\n', '  using Zero for *;\n', '  using ToAddress for *;\n', '  using Convert for *;\n', '\n', '  // investors storage - iterable map;\n', '  InvestorsStorage private m_investors;\n', '  mapping(address => address) private m_referrals;\n', '  bool private m_nextWave;\n', '\n', '  // automatically generates getters\n', '  address public adminAddr;\n', '  uint public waveStartup;\n', '  uint public totalInvestments;\n', '  uint public totalInvested;\n', '  uint public constant minInvesment = 10 finney; // 0.01 eth\n', '  uint public constant maxBalance = 255e5 ether; // 25,500,000 eth\n', '  uint public constant dividendsPeriod = 24 hours; //24 hours\n', '\n', '  // percents \n', '  Percent.percent private m_dividendsPercent = Percent.percent(255, 10000); // 255/10000*100% = 2.55%\n', '  Percent.percent private m_adminPercent = Percent.percent(5, 100); // 5/100*100% = 5%\n', '  Percent.percent private m_refPercent1 = Percent.percent(3, 100); // 3/100*100% = 3%\n', '  Percent.percent private m_refPercent2 = Percent.percent(2, 100); // 2/100*100% = 2%\n', '  Percent.percent private m_adBonus = Percent.percent(1, 100); // 1/100*100% = 1%\n', '\n', '  // more events for easy read from blockchain\n', '  event LogNewInvestor(address indexed addr, uint when, uint value);\n', '  event LogNewInvesment(address indexed addr, uint when, uint value);\n', '  event LogNewReferral(address indexed addr, uint when, uint value);\n', '  event LogPayDividends(address indexed addr, uint when, uint value);\n', '  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n', '  event LogBalanceChanged(uint when, uint balance);\n', '  event LogNextWave(uint when);\n', '\n', '  modifier balanceChanged {\n', '    _;\n', '    emit LogBalanceChanged(now, address(this).balance);\n', '  }\n', '\n', '  constructor() ERC20AdToken("Earn 2.55% Every Day. https://255eth.club", \n', '                            "Send your ETH to this contract and earn 2.55% every day for Live-long. https://255eth.club") public {\n', '    adminAddr = msg.sender;\n', '\n', '    nextWave();\n', '  }\n', '\n', '  function() public payable {\n', '    // investor get him dividends\n', '    if (msg.value == 0) {\n', '      getMyDividends();\n', '      return;\n', '    }\n', '\n', '    // sender do invest\n', '    address a = msg.data.toAddr();\n', '    doInvest(a);\n', '  }\n', '\n', '  function investorsNumber() public view returns(uint) {\n', '    return m_investors.size()-1;\n', '    // -1 because see InvestorsStorage constructor where keys.length++ \n', '  }\n', '\n', '  function balanceETH() public view returns(uint) {\n', '    return address(this).balance;\n', '  }\n', '\n', '  function dividendsPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\n', '  }\n', '\n', '  function adminPercent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\n', '  }\n', '\n', '  function referrer1Percent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent1.num, m_refPercent1.den);\n', '  }\n', '  \n', '  function referrer2Percent() public view returns(uint numerator, uint denominator) {\n', '    (numerator, denominator) = (m_refPercent2.num, m_refPercent2.den);\n', '  }\n', '  \n', '  function stats(uint date) public view returns(uint invested, uint investors) {\n', '    (invested, investors) = m_investors.stats(date);\n', '  }\n', '\n', '  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {\n', '    (value, paymentTime, refsCount, refBonus) = m_investors.investorBaseInfo(addr);\n', '    isReferral = m_referrals[addr].notZero();\n', '  }\n', '  \n', '  function bestInvestorInfo() public view returns(uint invested, address addr) {\n', '    (invested, addr) = m_investors.getBestInvestor();\n', '  }\n', '  \n', '  function bestPromouterInfo() public view returns(uint refs, address addr) {\n', '    (refs, addr) = m_investors.getBestPromouter();\n', '  }\n', '  \n', '  function _getMyDividents(bool withoutThrow) private {\n', '    // check investor info\n', '    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\n', '    if(investor.keyIndex <= 0){\n', '        if(withoutThrow){\n', '            return;\n', '        }\n', '        \n', '        revert("sender is not investor");\n', '    }\n', '\n', '    // calculate days after latest payment\n', '    uint256 daysAfter = now.sub(investor.paymentTime).div(dividendsPeriod);\n', '    if(daysAfter <= 0){\n', '        if(withoutThrow){\n', '            return;\n', '        }\n', '        \n', '        revert("the latest payment was earlier than dividents period");\n', '    }\n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    // check enough eth \n', '    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\n', '    if (address(this).balance < value + investor.refBonus) {\n', '      nextWave();\n', '      return;\n', '    }\n', '\n', '    // send dividends and ref bonus\n', '    if (investor.refBonus > 0) {\n', '      assert(m_investors.setRefBonus(msg.sender, 0));\n', '      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\n', '    } else {\n', '      sendDividends(msg.sender, value);\n', '    }      \n', '  }\n', '  \n', '  function getMyDividends() public balanceChanged {\n', '    _getMyDividents(false);\n', '  }\n', '\n', '  function doInvest(address ref) public payable balanceChanged {\n', '    require(msg.value >= minInvesment, "msg.value must be >= minInvesment");\n', '    require(address(this).balance <= maxBalance, "the contract eth balance limit");\n', '\n', '    uint value = msg.value;\n', '    // ref system works only once for sender-referral\n', '    if (!m_referrals[msg.sender].notZero()) {\n', '      // level 1\n', '      if (notZeroNotSender(ref) && m_investors.contains(ref)) {\n', '        uint reward = m_refPercent1.mul(value);\n', '        assert(m_investors.addRefBonusWithRefs(ref, reward)); // referrer 1 bonus\n', '        m_referrals[msg.sender] = ref;\n', '        value = m_dividendsPercent.add(value); // referral bonus\n', '        emit LogNewReferral(msg.sender, now, value); \n', '        // level 2\n', '        if (notZeroNotSender(m_referrals[ref]) && m_investors.contains(m_referrals[ref]) && ref != m_referrals[ref]) { \n', '          reward = m_refPercent2.mul(value);\n', '          assert(m_investors.addRefBonus(m_referrals[ref], reward)); // referrer 2 bonus\n', '        }\n', '      }else{\n', '        InvestorsStorage.bestAddress memory bestInvestor = getMemBestInvestor();\n', '        InvestorsStorage.bestAddress memory bestPromouter = getMemBestPromouter();\n', '        if(notZeroNotSender(bestInvestor.addr)){\n', '          assert(m_investors.addRefBonus(bestInvestor.addr, m_refPercent1.mul(value) )); // referrer 1 bonus\n', '          m_referrals[msg.sender] = bestInvestor.addr;\n', '        }\n', '        if(notZeroNotSender(bestPromouter.addr)){\n', '          assert(m_investors.addRefBonus(bestPromouter.addr, m_refPercent2.mul(value) )); // referrer 2 bonus\n', '          m_referrals[msg.sender] = bestPromouter.addr;\n', '        }\n', '      }\n', '      \n', '      if(notZeroNotSender(adtransfers[msg.sender]) && m_investors.contains(adtransfers[msg.sender])){\n', '          assert(m_investors.addRefBonus(adtransfers[msg.sender], m_adBonus.mul(msg.value) )); // advertise transfer bonud\n', '      }\n', '    }\n', '\n', '    _getMyDividents(true);\n', '\n', '    // commission\n', '    adminAddr.transfer(m_adminPercent.mul(msg.value));\n', '    \n', '    DT.DateTime memory dt = parseTimestamp(now);\n', '    uint today = dt.year.uintToString().strConcat((dt.month<10 ? "0":""), dt.month.uintToString(), (dt.day<10 ? "0":""), dt.day.uintToString()).stringToUint();\n', '    \n', '    // write to investors storage\n', '    if (m_investors.contains(msg.sender)) {\n', '      assert(m_investors.addValue(msg.sender, value));\n', '      m_investors.updateStats(today, value, 0);\n', '    } else {\n', '      assert(m_investors.insert(msg.sender, value));\n', '      m_investors.updateStats(today, value, 1);\n', '      emit LogNewInvestor(msg.sender, now, value); \n', '    }\n', '    \n', '    assert(m_investors.setPaymentTime(msg.sender, now));\n', '\n', '    emit LogNewInvesment(msg.sender, now, value);   \n', '    totalInvestments++;\n', '    totalInvested += msg.value;\n', '  }\n', '\n', '\n', '  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\n', '    (uint a, uint b, uint c, uint d, uint e) = m_investors.investorFullInfo(addr);\n', '    return InvestorsStorage.investor(a, b, c, d, e);\n', '  }\n', '  \n', '  function getMemBestInvestor() internal view returns(InvestorsStorage.bestAddress) {\n', '    (uint value, address addr) = m_investors.getBestInvestor();\n', '    return InvestorsStorage.bestAddress(value, addr);\n', '  }\n', '  \n', '  function getMemBestPromouter() internal view returns(InvestorsStorage.bestAddress) {\n', '    (uint value, address addr) = m_investors.getBestPromouter();\n', '    return InvestorsStorage.bestAddress(value, addr);\n', '  }\n', '\n', '  function notZeroNotSender(address addr) internal view returns(bool) {\n', '    return addr.notZero() && addr != msg.sender;\n', '  }\n', '\n', '  function sendDividends(address addr, uint value) private {\n', '    if (addr.send(value)) emit LogPayDividends(addr, now, value); \n', '  }\n', '\n', '  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\n', '    if (addr.send(value+refBonus)) {\n', '      emit LogPayDividends(addr, now, value);\n', '      emit LogPayReferrerBonus(addr, now, refBonus);\n', '    }\n', '  }\n', '\n', '  function nextWave() private {\n', '    m_investors = new InvestorsStorage();\n', '    totalInvestments = 0;\n', '    waveStartup = now;\n', '    m_nextWave = false;\n', '    emit LogNextWave(now);\n', '  }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = _a * _b;\n', '    require(c / _a == _b);\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    require(_b <= _a);\n', '    uint256 c = _a - _b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    uint256 c = _a + _b;\n', '    require(c >= _a);\n', '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'library Percent {\n', '  // Solidity automatically throws when dividing by 0\n', '  struct percent {\n', '    uint num;\n', '    uint den;\n', '  }\n', '  function mul(percent storage p, uint a) internal view returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    return a*p.num/p.den;\n', '  }\n', '\n', '  function div(percent storage p, uint a) internal view returns (uint) {\n', '    return a/p.num*p.den;\n', '  }\n', '\n', '  function sub(percent storage p, uint a) internal view returns (uint) {\n', '    uint b = mul(p, a);\n', '    if (b >= a) return 0;\n', '    return a - b;\n', '  }\n', '\n', '  function add(percent storage p, uint a) internal view returns (uint) {\n', '    return a + mul(p, a);\n', '  }\n', '}\n', '\n', 'library Zero {\n', '  function requireNotZero(uint a) internal pure {\n', '    require(a != 0, "require not zero");\n', '  }\n', '\n', '  function requireNotZero(address addr) internal pure {\n', '    require(addr != address(0), "require not zero address");\n', '  }\n', '\n', '  function notZero(address addr) internal pure returns(bool) {\n', '    return !(addr == address(0));\n', '  }\n', '\n', '  function isZero(address addr) internal pure returns(bool) {\n', '    return addr == address(0);\n', '  }\n', '}\n', '\n', 'library ToAddress {\n', '  function toAddr(uint source) internal pure returns(address) {\n', '    return address(source);\n', '  }\n', '\n', '  function toAddr(bytes source) internal pure returns(address addr) {\n', '    assembly { addr := mload(add(source,0x14)) }\n', '    return addr;\n', '  }\n', '}\n', '\n', 'library Convert {\n', '    function stringToUint(string s) internal pure returns (uint) {\n', '        bytes memory b = bytes(s);\n', '        uint result = 0;\n', '        for (uint i = 0; i < b.length; i++) { // c = b[i] was not needed\n', '            if (b[i] >= 48 && b[i] <= 57) {\n', '                result = result * 10 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\n', '            }\n', '        }\n', '        return result; // this was missing\n', '    }\n', '    \n', '    function uintToString(uint v) internal pure returns (string) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (v != 0) {\n', '            uint remainder = v % 10;\n', '            v = v / 10;\n', '            reversed[i++] = byte(48 + remainder);\n', '        }\n', '        bytes memory s = new bytes(i); // i + 1 is inefficient\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n', '        }\n', "        string memory str = string(s);  // memory isn't implicitly convertible to storage\n", '        return str; // this was missing\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '    \n', '    function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '    \n', '    function strConcat(string _a, string _b) internal pure returns (string) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '}']
