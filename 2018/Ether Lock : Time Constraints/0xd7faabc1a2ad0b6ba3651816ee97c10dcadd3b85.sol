['pragma solidity ^0.4.8;\n', '\n', '// 소유자 관리용 계약\n', 'contract Owned {\n', '    // 상태 변수\n', '    address public owner; // 소유자 주소\n', '\n', '    // 소유자 변경 시 이벤트\n', '    event TransferOwnership(address oldaddr, address newaddr);\n', '\n', '    // 소유자 한정 메서드용 수식자\n', '    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n', '\n', '    // 생성자\n', '    function Owned() public {\n', '        owner = msg.sender; // 처음에 계약을 생성한 주소를 소유자로 한다\n', '    }\n', '    \n', '    // (1) 소유자 변경\n', '    function transferOwnership(address _new) onlyOwner public {\n', '        address oldaddr = owner;\n', '        owner = _new;\n', '        emit TransferOwnership(oldaddr, owner);\n', '    }\n', '}\n', '\n', '// (2) 회원 관리용 계약\n', 'contract Members is Owned {\n', '    // (3) 상태 변수 선언\n', '    address public coin; // 토큰(가상 화폐) 주소\n', '    MemberStatus[] public status; // 회원 등급 배열\n', '    mapping(address => History) public tradingHistory; // 회원별 거래 이력\n', '     \n', '    // (4) 회원 등급용 구조체\n', '    struct MemberStatus {\n', '        string name; // 등급명\n', '        uint256 times; // 최저 거래 회수\n', '        uint256 sum; // 최저 거래 금액\n', '        int8 rate; // 캐시백 비율\n', '    }\n', '    // 거래 이력용 구조체\n', '    struct History {\n', '        uint256 times; // 거래 회수\n', '        uint256 sum; // 거래 금액\n', '        uint256 statusIndex; // 등급 인덱스\n', '    }\n', ' \n', '    // (5) 토큰 한정 메서드용 수식자\n', '    modifier onlyCoin() { if (msg.sender == coin) _; }\n', '     \n', '    // (6) 토큰 주소 설정\n', '    function setCoin(address _addr) onlyOwner public {\n', '        coin = _addr;\n', '    }\n', '     \n', '    // (7) 회원 등급 추가\n', '    function pushStatus(string _name, uint256 _times, uint256 _sum, int8 _rate) onlyOwner public {\n', '        status.push(MemberStatus({\n', '            name: _name,\n', '            times: _times,\n', '            sum: _sum,\n', '            rate: _rate\n', '        }));\n', '    }\n', ' \n', '    // (8) 회원 등급 내용 변경\n', '    function editStatus(uint256 _index, string _name, uint256 _times, uint256 _sum, int8 _rate) onlyOwner public {\n', '        if (_index < status.length) {\n', '            status[_index].name = _name;\n', '            status[_index].times = _times;\n', '            status[_index].sum = _sum;\n', '            status[_index].rate = _rate;\n', '        }\n', '    }\n', '     \n', '    // (9) 거래 내역 갱신\n', '    function updateHistory(address _member, uint256 _value) onlyCoin public {\n', '        tradingHistory[_member].times += 1;\n', '        tradingHistory[_member].sum += _value;\n', '        // 새로운 회원 등급 결정(거래마다 실행)\n', '        uint256 index;\n', '        int8 tmprate;\n', '        for (uint i = 0; i < status.length; i++) {\n', '            // 최저 거래 횟수, 최저 거래 금액 충족 시 가장 캐시백 비율이 좋은 등급으로 설정\n', '            if (tradingHistory[_member].times >= status[i].times &&\n', '                tradingHistory[_member].sum >= status[i].sum &&\n', '                tmprate < status[i].rate) {\n', '                index = i;\n', '            }\n', '        }\n', '        tradingHistory[_member].statusIndex = index;\n', '    }\n', '\n', '    // (10) 캐시백 비율 획득(회원의 등급에 해당하는 비율 확인)\n', '    function getCashbackRate(address _member) public constant returns (int8 rate){\n', '        rate = status[tradingHistory[_member].statusIndex].rate;\n', '    }\n', '}\n', '     \n', '// (11) 회원 관리 기능이 구현된 가상 화폐\n', 'contract OreOreCoin is Owned{\n', '    // 상태 변수 선언\n', '    string public name; // 토큰 이름\n', '    string public symbol; // 토큰 단위\n', '    uint8 public decimals; // 소수점 이하 자릿수\n', '    uint256 public totalSupply; // 토큰 총량\n', '    mapping (address => uint256) public balanceOf; // 각 주소의 잔고\n', '    mapping (address => int8) public blackList; // 블랙리스트\n', '    mapping (address => Members) public members; // 각 주소의 회원 정보\n', '     \n', '    // 이벤트 알림\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Blacklisted(address indexed target);\n', '    event DeleteFromBlacklist(address indexed target);\n', '    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n', '    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n', '    event Cashback(address indexed from, address indexed to, uint256 value);\n', '     \n', '    // 생성자\n', '    function OreOreCoin(uint256 _supply, string _name, string _symbol, uint8 _decimals) public {\n', '        balanceOf[msg.sender] = _supply;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _supply;\n', '    }\n', ' \n', '    // 주소를 블랙리스트에 등록\n', '    function blacklisting(address _addr) onlyOwner public {\n', '        blackList[_addr] = 1;\n', '        emit Blacklisted(_addr);\n', '    }\n', ' \n', '    // 주소를 블랙리스트에서 해제\n', '    function deleteFromBlacklist(address _addr) onlyOwner public {\n', '        blackList[_addr] = -1;\n', '        emit DeleteFromBlacklist(_addr);\n', '    }\n', ' \n', '    // 회원 관리 계약 설정\n', '    function setMembers(Members _members) public {\n', '        members[msg.sender] = Members(_members);\n', '    }\n', ' \n', '    // 송금\n', '    function transfer(address _to, uint256 _value)  public{\n', '        // 부정 송금 확인\n', '        if (balanceOf[msg.sender] < _value) return;\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) return;\n', '\n', '        // 블랙리스트에 존재하는 계정은 입출금 불가\n', '        if (blackList[msg.sender] > 0) {\n', '            emit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n', '        } else if (blackList[_to] > 0) {\n', '            emit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n', '        } else {\n', '            // (12) 캐시백 금액을 계산(각 대상의 비율을 사용)\n', '            uint256 cashback = 0;\n', '            if(members[_to] > address(0)) {\n', '                cashback = _value / 100 * uint256(members[_to].getCashbackRate(msg.sender));\n', '                members[_to].updateHistory(msg.sender, _value);\n', '            }\n', ' \n', '            balanceOf[msg.sender] -= (_value - cashback);\n', '            balanceOf[_to] += (_value - cashback);\n', ' \n', '            emit Transfer(msg.sender, _to, _value);\n', '            emit Cashback(_to, msg.sender, cashback);\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '// 소유자 관리용 계약\n', 'contract Owned {\n', '    // 상태 변수\n', '    address public owner; // 소유자 주소\n', '\n', '    // 소유자 변경 시 이벤트\n', '    event TransferOwnership(address oldaddr, address newaddr);\n', '\n', '    // 소유자 한정 메서드용 수식자\n', '    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n', '\n', '    // 생성자\n', '    function Owned() public {\n', '        owner = msg.sender; // 처음에 계약을 생성한 주소를 소유자로 한다\n', '    }\n', '    \n', '    // (1) 소유자 변경\n', '    function transferOwnership(address _new) onlyOwner public {\n', '        address oldaddr = owner;\n', '        owner = _new;\n', '        emit TransferOwnership(oldaddr, owner);\n', '    }\n', '}\n', '\n', '// (2) 회원 관리용 계약\n', 'contract Members is Owned {\n', '    // (3) 상태 변수 선언\n', '    address public coin; // 토큰(가상 화폐) 주소\n', '    MemberStatus[] public status; // 회원 등급 배열\n', '    mapping(address => History) public tradingHistory; // 회원별 거래 이력\n', '     \n', '    // (4) 회원 등급용 구조체\n', '    struct MemberStatus {\n', '        string name; // 등급명\n', '        uint256 times; // 최저 거래 회수\n', '        uint256 sum; // 최저 거래 금액\n', '        int8 rate; // 캐시백 비율\n', '    }\n', '    // 거래 이력용 구조체\n', '    struct History {\n', '        uint256 times; // 거래 회수\n', '        uint256 sum; // 거래 금액\n', '        uint256 statusIndex; // 등급 인덱스\n', '    }\n', ' \n', '    // (5) 토큰 한정 메서드용 수식자\n', '    modifier onlyCoin() { if (msg.sender == coin) _; }\n', '     \n', '    // (6) 토큰 주소 설정\n', '    function setCoin(address _addr) onlyOwner public {\n', '        coin = _addr;\n', '    }\n', '     \n', '    // (7) 회원 등급 추가\n', '    function pushStatus(string _name, uint256 _times, uint256 _sum, int8 _rate) onlyOwner public {\n', '        status.push(MemberStatus({\n', '            name: _name,\n', '            times: _times,\n', '            sum: _sum,\n', '            rate: _rate\n', '        }));\n', '    }\n', ' \n', '    // (8) 회원 등급 내용 변경\n', '    function editStatus(uint256 _index, string _name, uint256 _times, uint256 _sum, int8 _rate) onlyOwner public {\n', '        if (_index < status.length) {\n', '            status[_index].name = _name;\n', '            status[_index].times = _times;\n', '            status[_index].sum = _sum;\n', '            status[_index].rate = _rate;\n', '        }\n', '    }\n', '     \n', '    // (9) 거래 내역 갱신\n', '    function updateHistory(address _member, uint256 _value) onlyCoin public {\n', '        tradingHistory[_member].times += 1;\n', '        tradingHistory[_member].sum += _value;\n', '        // 새로운 회원 등급 결정(거래마다 실행)\n', '        uint256 index;\n', '        int8 tmprate;\n', '        for (uint i = 0; i < status.length; i++) {\n', '            // 최저 거래 횟수, 최저 거래 금액 충족 시 가장 캐시백 비율이 좋은 등급으로 설정\n', '            if (tradingHistory[_member].times >= status[i].times &&\n', '                tradingHistory[_member].sum >= status[i].sum &&\n', '                tmprate < status[i].rate) {\n', '                index = i;\n', '            }\n', '        }\n', '        tradingHistory[_member].statusIndex = index;\n', '    }\n', '\n', '    // (10) 캐시백 비율 획득(회원의 등급에 해당하는 비율 확인)\n', '    function getCashbackRate(address _member) public constant returns (int8 rate){\n', '        rate = status[tradingHistory[_member].statusIndex].rate;\n', '    }\n', '}\n', '     \n', '// (11) 회원 관리 기능이 구현된 가상 화폐\n', 'contract OreOreCoin is Owned{\n', '    // 상태 변수 선언\n', '    string public name; // 토큰 이름\n', '    string public symbol; // 토큰 단위\n', '    uint8 public decimals; // 소수점 이하 자릿수\n', '    uint256 public totalSupply; // 토큰 총량\n', '    mapping (address => uint256) public balanceOf; // 각 주소의 잔고\n', '    mapping (address => int8) public blackList; // 블랙리스트\n', '    mapping (address => Members) public members; // 각 주소의 회원 정보\n', '     \n', '    // 이벤트 알림\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Blacklisted(address indexed target);\n', '    event DeleteFromBlacklist(address indexed target);\n', '    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n', '    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n', '    event Cashback(address indexed from, address indexed to, uint256 value);\n', '     \n', '    // 생성자\n', '    function OreOreCoin(uint256 _supply, string _name, string _symbol, uint8 _decimals) public {\n', '        balanceOf[msg.sender] = _supply;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _supply;\n', '    }\n', ' \n', '    // 주소를 블랙리스트에 등록\n', '    function blacklisting(address _addr) onlyOwner public {\n', '        blackList[_addr] = 1;\n', '        emit Blacklisted(_addr);\n', '    }\n', ' \n', '    // 주소를 블랙리스트에서 해제\n', '    function deleteFromBlacklist(address _addr) onlyOwner public {\n', '        blackList[_addr] = -1;\n', '        emit DeleteFromBlacklist(_addr);\n', '    }\n', ' \n', '    // 회원 관리 계약 설정\n', '    function setMembers(Members _members) public {\n', '        members[msg.sender] = Members(_members);\n', '    }\n', ' \n', '    // 송금\n', '    function transfer(address _to, uint256 _value)  public{\n', '        // 부정 송금 확인\n', '        if (balanceOf[msg.sender] < _value) return;\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) return;\n', '\n', '        // 블랙리스트에 존재하는 계정은 입출금 불가\n', '        if (blackList[msg.sender] > 0) {\n', '            emit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n', '        } else if (blackList[_to] > 0) {\n', '            emit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n', '        } else {\n', '            // (12) 캐시백 금액을 계산(각 대상의 비율을 사용)\n', '            uint256 cashback = 0;\n', '            if(members[_to] > address(0)) {\n', '                cashback = _value / 100 * uint256(members[_to].getCashbackRate(msg.sender));\n', '                members[_to].updateHistory(msg.sender, _value);\n', '            }\n', ' \n', '            balanceOf[msg.sender] -= (_value - cashback);\n', '            balanceOf[_to] += (_value - cashback);\n', ' \n', '            emit Transfer(msg.sender, _to, _value);\n', '            emit Cashback(_to, msg.sender, cashback);\n', '        }\n', '    }\n', '}']
