['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract CCCP {\n', '    using SafeMath for uint256;\n', '    address[] users;\n', '    mapping(address => bool) usersExist;\n', '    mapping(address => address) users2users;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) balancesTotal;\n', '    uint256 nextUserId = 0;\n', '    uint256 cyles = 100;\n', '    \n', '    event Register(address indexed user, address indexed parentUser);\n', '    event BalanceUp(address indexed user, uint256 amount);\n', '    event ReferalBonus(address indexed user, uint256 amount);\n', '    event GetMyMoney(address user, uint256 amount);\n', '    \n', '    function () payable public {\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '\n', '    function register(address parentUser) payable public{\n', '        require(msg.value == 20 finney);\n', '        require(msg.sender != address(0));\n', '        require(parentUser != address(0));\n', '        require(!usersExist[msg.sender]);\n', '        _register(msg.sender, msg.value, parentUser);\n', '    }\n', '    \n', '    function _register(address user, uint256 amount, address parentUser) internal {\n', '        if (users.length > 0) {\n', '            require(parentUser!=user);\n', '            require(usersExist[parentUser]);\n', '        }\n', '        users.push(user);\n', '        usersExist[user]=true;\n', '        users2users[user]=parentUser;\n', '        emit Register(user, parentUser);\n', '        \n', '        uint256 referalBonus = amount.div(2);\n', '        \n', '        balances[parentUser] = balances[parentUser].add(referalBonus.div(2));\n', '        balancesTotal[parentUser] = balancesTotal[parentUser].add(referalBonus.div(2));\n', '        emit ReferalBonus(parentUser, referalBonus.div(2));\n', '        \n', '        balances[users2users[parentUser]] = balances[users2users[parentUser]].add(referalBonus.div(2));\n', '        balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(referalBonus.div(2));\n', '        emit ReferalBonus(users2users[parentUser], referalBonus.div(2));\n', '        \n', '        uint256 length = users.length;\n', '        uint256 existLastIndex = length.sub(1);\n', '        \n', '        for (uint i = 1; i <= cyles; i++) {\n', '            nextUserId = nextUserId.add(1);\n', '            if(nextUserId > existLastIndex){\n', '                nextUserId = 0;\n', '            }\n', '            balances[users[nextUserId]] = balances[users[nextUserId]].add(referalBonus.div(cyles));\n', '            balancesTotal[users[nextUserId]] = balancesTotal[users[nextUserId]].add(referalBonus.div(cyles));\n', '            emit BalanceUp(users[nextUserId], referalBonus.div(cyles));\n', '        }\n', '    }\n', '    \n', '    function getMyMoney() public {\n', '        require(balances[msg.sender]>0);\n', '        msg.sender.transfer(balances[msg.sender]);\n', '        emit GetMyMoney(msg.sender, balances[msg.sender]);\n', '        balances[msg.sender]=0;\n', '    }\n', '    \n', '    function balanceOf(address who) public constant returns (uint256 balance) {\n', '        return balances[who];\n', '    }\n', '    \n', '    function balanceTotalOf(address who) public constant returns (uint256 balanceTotal) {\n', '        return balancesTotal[who];\n', '    }\n', '    \n', '    function getNextUserId() public constant returns (uint256 nextUserId) {\n', '        return nextUserId;\n', '    }\n', '    \n', '    function getUserAddressById(uint256 id) public constant returns (address userAddress) {\n', '        return users[id];\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract CCCP {\n', '    using SafeMath for uint256;\n', '    address[] users;\n', '    mapping(address => bool) usersExist;\n', '    mapping(address => address) users2users;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) balancesTotal;\n', '    uint256 nextUserId = 0;\n', '    uint256 cyles = 100;\n', '    \n', '    event Register(address indexed user, address indexed parentUser);\n', '    event BalanceUp(address indexed user, uint256 amount);\n', '    event ReferalBonus(address indexed user, uint256 amount);\n', '    event GetMyMoney(address user, uint256 amount);\n', '    \n', '    function () payable public {\n', '        msg.sender.transfer(msg.value);\n', '    }\n', '\n', '    function register(address parentUser) payable public{\n', '        require(msg.value == 20 finney);\n', '        require(msg.sender != address(0));\n', '        require(parentUser != address(0));\n', '        require(!usersExist[msg.sender]);\n', '        _register(msg.sender, msg.value, parentUser);\n', '    }\n', '    \n', '    function _register(address user, uint256 amount, address parentUser) internal {\n', '        if (users.length > 0) {\n', '            require(parentUser!=user);\n', '            require(usersExist[parentUser]);\n', '        }\n', '        users.push(user);\n', '        usersExist[user]=true;\n', '        users2users[user]=parentUser;\n', '        emit Register(user, parentUser);\n', '        \n', '        uint256 referalBonus = amount.div(2);\n', '        \n', '        balances[parentUser] = balances[parentUser].add(referalBonus.div(2));\n', '        balancesTotal[parentUser] = balancesTotal[parentUser].add(referalBonus.div(2));\n', '        emit ReferalBonus(parentUser, referalBonus.div(2));\n', '        \n', '        balances[users2users[parentUser]] = balances[users2users[parentUser]].add(referalBonus.div(2));\n', '        balancesTotal[users2users[parentUser]] = balancesTotal[users2users[parentUser]].add(referalBonus.div(2));\n', '        emit ReferalBonus(users2users[parentUser], referalBonus.div(2));\n', '        \n', '        uint256 length = users.length;\n', '        uint256 existLastIndex = length.sub(1);\n', '        \n', '        for (uint i = 1; i <= cyles; i++) {\n', '            nextUserId = nextUserId.add(1);\n', '            if(nextUserId > existLastIndex){\n', '                nextUserId = 0;\n', '            }\n', '            balances[users[nextUserId]] = balances[users[nextUserId]].add(referalBonus.div(cyles));\n', '            balancesTotal[users[nextUserId]] = balancesTotal[users[nextUserId]].add(referalBonus.div(cyles));\n', '            emit BalanceUp(users[nextUserId], referalBonus.div(cyles));\n', '        }\n', '    }\n', '    \n', '    function getMyMoney() public {\n', '        require(balances[msg.sender]>0);\n', '        msg.sender.transfer(balances[msg.sender]);\n', '        emit GetMyMoney(msg.sender, balances[msg.sender]);\n', '        balances[msg.sender]=0;\n', '    }\n', '    \n', '    function balanceOf(address who) public constant returns (uint256 balance) {\n', '        return balances[who];\n', '    }\n', '    \n', '    function balanceTotalOf(address who) public constant returns (uint256 balanceTotal) {\n', '        return balancesTotal[who];\n', '    }\n', '    \n', '    function getNextUserId() public constant returns (uint256 nextUserId) {\n', '        return nextUserId;\n', '    }\n', '    \n', '    function getUserAddressById(uint256 id) public constant returns (address userAddress) {\n', '        return users[id];\n', '    }\n', '}']
